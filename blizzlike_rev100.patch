# HG changeset patch
# User asniker
# Date 1288614672 -18000
# Node ID 8044d11551fd86f7d52e128798def74e7728b644
# Parent  d0e77c9a61667e8ca8440aca6391a1faea780d7b
удаление ненужных патчей
Core/AI: implemented SmartScripts System (still beta) not 100% complete

diff --git a/sql/updates/10320_world_smart_scripts.sql b/sql/updates/10320_world_smart_scripts.sql
new file mode 100644
--- /dev/null
+++ b/sql/updates/10320_world_smart_scripts.sql
@@ -0,0 +1,1323 @@
+
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html>
+<head>
+ <link rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
+ 
+ <script type="text/javascript">
+ 
+ 
+ 
+ var codesite_token = null;
+ 
+ 
+ var logged_in_user_email = null;
+ 
+ 
+ var relative_base_url = "";
+ 
+ </script>
+ 
+ 
+ <title>10320_world_smart_scripts.sql - 
+ trinitycore -
+ 
+ Project Hosting on Google Code</title>
+ <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
+ 
+ <meta name="ROBOTS" content="NOARCHIVE">
+ 
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/ph_core.css">
+ 
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/ph_detail.css" >
+ 
+ 
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/d_sb_20080522.css" >
+ 
+ 
+ 
+<!--[if IE]>
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/d_ie.css" >
+<![endif]-->
+ <style type="text/css">
+ .menuIcon.off { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -42px }
+ .menuIcon.on { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -28px }
+ .menuIcon.down { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 0; }
+ </style>
+</head>
+<body class="t4">
+ <script type="text/javascript">
+ var _gaq = _gaq || [];
+ _gaq.push(
+ ['siteTracker._setAccount', 'UA-18071-1'],
+ ['siteTracker._trackPageview']);
+ 
+ _gaq.push(
+ ['projectTracker._setAccount', 'UA-4682200-2'],
+ ['projectTracker._trackPageview']);
+ 
+ (function() {
+ var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
+ ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
+ (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
+ })();
+ </script>
+ <div id="gaia">
+ 
+ <span>
+ 
+ <a href="#" id="projects-dropdown" onclick="return false;"><u>My favorites</u> <small>&#9660;</small></a>
+ | <a href="https://www.google.com/accounts/ServiceLogin?service=code&amp;ltmpl=phosting&amp;continue=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_smart_scripts.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;followup=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_smart_scripts.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8" onclick="_CS_click('/gb/ph/signin');"><u>Sign in</u></a>
+ 
+ </span>
+
+ </div>
+ <div class="gbh" style="left: 0pt;"></div>
+ <div class="gbh" style="right: 0pt;"></div>
+ 
+ 
+ <div style="height: 1px"></div>
+<!--[if IE 6]>
+<div style="text-align:center;">
+Support browsers that contribute to open source, try <a href="http://www.firefox.com">Firefox</a> or <a href="http://www.google.com/chrome">Google Chrome</a>.
+</div>
+<![endif]-->
+
+
+
+
+ <table style="padding:0px; margin: 20px 0px 0px 0px; width:100%" cellpadding="0" cellspacing="0">
+ <tr style="height: 58px;">
+ 
+ <td style="width: 55px; text-align:center;">
+ <a href="/p/trinitycore/">
+ 
+ 
+ <img src="/p/trinitycore/logo?cct=1282883506" alt="Logo">
+ 
+ </a>
+ </td>
+ 
+ <td style="padding-left: 0.5em">
+ 
+ <div id="pname" style="margin: 0px 0px -3px 0px">
+ <a href="/p/trinitycore/" style="text-decoration:none; color:#000">trinitycore</a>
+ 
+ </div>
+ <div id="psum">
+ <i><a id="project_summary_link" href="/p/trinitycore/" style="text-decoration:none; color:#000">Trinity Core Open Source MMo Framework</a></i>
+ </div>
+ 
+ </td>
+ <td style="white-space:nowrap;text-align:right">
+ 
+ <form action="/hosting/search">
+ <input size="30" name="q" value="">
+ <input type="submit" name="projectsearch" value="Search projects" >
+ </form>
+ 
+ </tr>
+ </table>
+
+
+ 
+<table id="mt" cellspacing="0" cellpadding="0" width="100%" border="0">
+ <tr>
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/">Project&nbsp;Home</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/downloads/list');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/downloads/list">Downloads</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/w/list');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/w/list">Wiki</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/issues/list');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/issues/list">Issues</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/source/checkout');">
+ <div class="tab active">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/source/checkout">Source</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ <td width="100%">&nbsp;</td>
+ </tr>
+</table>
+<table cellspacing="0" cellpadding="0" width="100%" align="center" border="0" class="st">
+ <tr>
+ 
+ 
+ 
+ 
+ 
+ 
+ <td>
+ <div class="st2">
+ <div class="isf">
+ 
+ <form action="/p/trinitycore/source/browse" style="display: inline">
+ 
+ Repository:
+ <select name="repo" id="repo" style="font-size: 92%" onchange="submit()">
+ <option value="default">default</option><option value="wiki">wiki</option><option value="tc-cal">tc-cal</option>
+ </select>
+ </form>
+ 
+ 
+ 
+ <span class="inst1"><a href="/p/trinitycore/source/checkout">Checkout</a></span> |
+ <span class="inst2"><a href="/p/trinitycore/source/browse/">Browse</a></span> |
+ <span class="inst3"><a href="/p/trinitycore/source/list">Changes</a></span> |
+ <span class="inst4"><a href="/p/trinitycore/source/clones">Clones</a></span> |
+ <form action="http://www.google.com/codesearch" method="get" style="display:inline"
+ onsubmit="document.getElementById('codesearchq').value = document.getElementById('origq').value + ' package:http://trinitycore\\.googlecode\\.com'">
+ <input type="hidden" name="q" id="codesearchq" value="">
+ <input maxlength="2048" size="38" id="origq" name="origq" value="" title="Google Code Search" style="font-size:92%">&nbsp;<input type="submit" value="Search Trunk" name="btnG" style="font-size:92%">
+ 
+ 
+ 
+ </form>
+ </div>
+</div>
+
+ </td>
+ 
+ 
+ 
+ <td height="4" align="right" valign="top" class="bevel-right">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ </td>
+ </tr>
+</table>
+<script type="text/javascript">
+ var cancelBubble = false;
+ function _go(url) { document.location = url; }
+</script>
+
+
+<div id="maincol"
+ 
+>
+
+ 
+<!-- IE -->
+
+
+
+
+<div class="expand">
+
+
+<style type="text/css">
+ #file_flipper { display: inline; float: right; white-space: nowrap; }
+ #file_flipper.hidden { display: none; }
+ #file_flipper .pagelink { color: #0000CC; text-decoration: underline; }
+ #file_flipper #visiblefiles { padding-left: 0.5em; padding-right: 0.5em; }
+</style>
+<div id="nav_and_rev" class="heading">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner" id="bub">
+ <div class="bub-top">
+ <div class="pagination" style="margin-left: 2em">
+ <table cellpadding="0" cellspacing="0" class="flipper">
+ <tbody>
+ <tr>
+ 
+ <td><b>e5037e953a</b></td>
+ 
+ </tr>
+ </tbody>
+ </table>
+ </div>
+ 
+ <div class="" style="vertical-align: top">
+ <div class="src_crumbs src_nav">
+ <strong class="src_nav">Source path:&nbsp;</strong>
+ <span id="crumb_root">
+ 
+ <a href="/p/trinitycore/source/browse/?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">hg</a>/&nbsp;</span>
+ <span id="crumb_links" class="ifClosed"><a href="/p/trinitycore/source/browse/sql/?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">sql</a><span class="sp">/&nbsp;</span><a href="/p/trinitycore/source/browse/sql/updates/?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">updates</a><span class="sp">/&nbsp;</span>10320_world_smart_scripts.sql</span>
+ 
+ 
+ 
+ 
+ <span class="sourcelabel src_nav"><strong>Branch:</strong> trunk</span>
+ 
+ 
+ 
+ <form class="src_nav">
+ 
+ <span class="sourcelabel src_nav">
+ <strong>Tag:</strong>
+ <select id="tag_select" name="r" onchange="submit()">
+ <option value="">&lt;none&gt;</option>
+ 
+ <option value="3.0.8 stable" >3.0.8 stable</option>
+ 
+ <option value="3.1.3-stable-last" >3.1.3-stable-last</option>
+ 
+ <option value="3.2.2a-initial-release" >3.2.2a-initial-release</option>
+ 
+ <option value="3.2.2a-last" >3.2.2a-last</option>
+ 
+ <option value="3.2.2a-really-last" >3.2.2a-really-last</option>
+ 
+ <option value="3.2.2a-stable" >3.2.2a-stable</option>
+ 
+ <option value="3.3.2-last" >3.3.2-last</option>
+ 
+ <option value="3.3.3a-LAST" >3.3.3a-LAST</option>
+ 
+ <option value="3.3.5a-clientsupport" >3.3.5a-clientsupport</option>
+ 
+ <option value="309-313" >309-313</option>
+ 
+ <option value="335a-stable" >335a-stable</option>
+ 
+ <option value="Stable" >Stable</option>
+ 
+ <option value="UP30" >UP30</option>
+ 
+ <option value="UP31" >UP31</option>
+ 
+ <option value="UP33" >UP33</option>
+ 
+ <option value="UP34" >UP34</option>
+ 
+ </select>
+ </span>
+ </form>
+ 
+ 
+ </div>
+ 
+ </div>
+ <div style="clear:both"></div>
+ </div>
+ </div>
+</div>
+
+<style type="text/css">
+ 
+  tr.inline_comment {
+ background: #fff;
+ vertical-align: top;
+ }
+ div.draft, div.published {
+ padding: .3em;
+ border: 1px solid #999; 
+ margin-bottom: .1em;
+ font-family: arial, sans-serif;
+ max-width: 60em;
+ }
+ div.draft {
+ background: #ffa;
+ } 
+ div.published {
+ background: #e5ecf9;
+ }
+ div.published .body, div.draft .body {
+ padding: .5em .1em .1em .1em;
+ max-width: 60em;
+ white-space: pre-wrap;
+ white-space: -moz-pre-wrap;
+ white-space: -pre-wrap;
+ white-space: -o-pre-wrap;
+ word-wrap: break-word;
+ }
+ div.draft .actions {
+ margin-left: 1em;
+ font-size: 90%;
+ }
+ div.draft form {
+ padding: .5em .5em .5em 0;
+ }
+ div.draft textarea, div.published textarea {
+ width: 95%;
+ height: 10em;
+ font-family: arial, sans-serif;
+ margin-bottom: .5em;
+ }
+
+
+ 
+ .nocursor, .nocursor td, .cursor_hidden, .cursor_hidden td {
+ background-color: white;
+ height: 2px;
+ }
+ .cursor, .cursor td {
+ background-color: darkblue;
+ height: 2px;
+ display: '';
+ }
+
+</style>
+<div class="fc">
+ 
+ 
+ 
+<style type="text/css">
+.undermouse span {
+ background-image: url(http://www.gstatic.com/codesite/ph/images/comments.gif); }
+</style>
+<table class="opened" id="review_comment_area"
+><tr>
+<td id="nums">
+<pre><table width="100%"><tr class="nocursor"><td></td></tr></table></pre>
+<pre><table width="100%" id="nums_table_0"><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_1"
+
+><td id="1"><a href="#1">1</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_2"
+
+><td id="2"><a href="#2">2</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_3"
+
+><td id="3"><a href="#3">3</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_4"
+
+><td id="4"><a href="#4">4</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_5"
+
+><td id="5"><a href="#5">5</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_6"
+
+><td id="6"><a href="#6">6</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_7"
+
+><td id="7"><a href="#7">7</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_8"
+
+><td id="8"><a href="#8">8</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_9"
+
+><td id="9"><a href="#9">9</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_10"
+
+><td id="10"><a href="#10">10</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_11"
+
+><td id="11"><a href="#11">11</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_12"
+
+><td id="12"><a href="#12">12</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_13"
+
+><td id="13"><a href="#13">13</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_14"
+
+><td id="14"><a href="#14">14</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_15"
+
+><td id="15"><a href="#15">15</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_16"
+
+><td id="16"><a href="#16">16</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_17"
+
+><td id="17"><a href="#17">17</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_18"
+
+><td id="18"><a href="#18">18</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_19"
+
+><td id="19"><a href="#19">19</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_20"
+
+><td id="20"><a href="#20">20</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_21"
+
+><td id="21"><a href="#21">21</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_22"
+
+><td id="22"><a href="#22">22</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_23"
+
+><td id="23"><a href="#23">23</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_24"
+
+><td id="24"><a href="#24">24</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_25"
+
+><td id="25"><a href="#25">25</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_26"
+
+><td id="26"><a href="#26">26</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_27"
+
+><td id="27"><a href="#27">27</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_28"
+
+><td id="28"><a href="#28">28</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_29"
+
+><td id="29"><a href="#29">29</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_30"
+
+><td id="30"><a href="#30">30</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_31"
+
+><td id="31"><a href="#31">31</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_32"
+
+><td id="32"><a href="#32">32</a></td></tr
+></table></pre>
+<pre><table width="100%"><tr class="nocursor"><td></td></tr></table></pre>
+</td>
+<td id="lines">
+<pre class="prettyprint"><table width="100%"><tr class="cursor_stop cursor_hidden"><td></td></tr></table></pre>
+<pre class="prettyprint lang-sql"><table id="src_table_0"><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_1
+
+><td class="source">DROP TABLE IF EXISTS smart_scripts;<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_2
+
+><td class="source">CREATE TABLE `smart_scripts` (<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_3
+
+><td class="source">  `entryorguid` mediumint(11) NOT NULL,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_4
+
+><td class="source">  `source_type` mediumint(5) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_5
+
+><td class="source">  `id` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_6
+
+><td class="source">  `link` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_7
+
+><td class="source">  `event_type` mediumint(5) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_8
+
+><td class="source">  `event_phase_mask` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_9
+
+><td class="source">  `event_chance` mediumint(5) unsigned NOT NULL DEFAULT &#39;100&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_10
+
+><td class="source">  `event_flags` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_11
+
+><td class="source">  `event_param1` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_12
+
+><td class="source">  `event_param2` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_13
+
+><td class="source">  `event_param3` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_14
+
+><td class="source">  `event_param4` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_15
+
+><td class="source">  `action_type` mediumint(5) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_16
+
+><td class="source">  `action_param1` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_17
+
+><td class="source">  `action_param2` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_18
+
+><td class="source">  `action_param3` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_19
+
+><td class="source">  `action_param4` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_20
+
+><td class="source">  `action_param5` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_21
+
+><td class="source">  `action_param6` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_22
+
+><td class="source">  `target_type` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_23
+
+><td class="source">  `target_param1` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_24
+
+><td class="source">  `target_param2` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_25
+
+><td class="source">  `target_param3` mediumint(11) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_26
+
+><td class="source">  `target_x` float NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_27
+
+><td class="source">  `target_y` float NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_28
+
+><td class="source">  `target_z` float NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_29
+
+><td class="source">  `target_o` float NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_30
+
+><td class="source">  `comment` varchar(255) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;Event Comment&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_31
+
+><td class="source">  PRIMARY KEY (`entryorguid`,`source_type`,`id`,`link`)<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_32
+
+><td class="source">) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED;<br></td></tr
+></table></pre>
+<pre class="prettyprint"><table width="100%"><tr class="cursor_stop cursor_hidden"><td></td></tr></table></pre>
+</td>
+</tr></table>
+<script type="text/javascript">
+ var lineNumUnderMouse = -1;
+ 
+ function gutterOver(num) {
+ gutterOut();
+ var newTR = document.getElementById('gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_' + num);
+ if (newTR) {
+ newTR.className = 'undermouse';
+ }
+ lineNumUnderMouse = num;
+ }
+ function gutterOut() {
+ if (lineNumUnderMouse != -1) {
+ var oldTR = document.getElementById(
+ 'gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_' + lineNumUnderMouse);
+ if (oldTR) {
+ oldTR.className = '';
+ }
+ lineNumUnderMouse = -1;
+ }
+ }
+ var numsGenState = {table_base_id: 'nums_table_'};
+ var srcGenState = {table_base_id: 'src_table_'};
+ var alignerRunning = false;
+ var startOver = false;
+ function setLineNumberHeights() {
+ if (alignerRunning) {
+ startOver = true;
+ return;
+ }
+ numsGenState.chunk_id = 0;
+ numsGenState.table = document.getElementById('nums_table_0');
+ numsGenState.row_num = 0;
+ srcGenState.chunk_id = 0;
+ srcGenState.table = document.getElementById('src_table_0');
+ srcGenState.row_num = 0;
+ alignerRunning = true;
+ continueToSetLineNumberHeights();
+ }
+ function rowGenerator(genState) {
+ if (genState.row_num < genState.table.rows.length) {
+ var currentRow = genState.table.rows[genState.row_num];
+ genState.row_num++;
+ return currentRow;
+ }
+ var newTable = document.getElementById(
+ genState.table_base_id + (genState.chunk_id + 1));
+ if (newTable) {
+ genState.chunk_id++;
+ genState.row_num = 0;
+ genState.table = newTable;
+ return genState.table.rows[0];
+ }
+ return null;
+ }
+ var MAX_ROWS_PER_PASS = 1000;
+ function continueToSetLineNumberHeights() {
+ var rowsInThisPass = 0;
+ var numRow = 1;
+ var srcRow = 1;
+ while (numRow && srcRow && rowsInThisPass < MAX_ROWS_PER_PASS) {
+ numRow = rowGenerator(numsGenState);
+ srcRow = rowGenerator(srcGenState);
+ rowsInThisPass++;
+ if (numRow && srcRow) {
+ if (numRow.offsetHeight != srcRow.offsetHeight) {
+ numRow.firstChild.style.height = srcRow.offsetHeight + 'px';
+ }
+ }
+ }
+ if (rowsInThisPass >= MAX_ROWS_PER_PASS) {
+ setTimeout(continueToSetLineNumberHeights, 10);
+ } else {
+ alignerRunning = false;
+ if (startOver) {
+ startOver = false;
+ setTimeout(setLineNumberHeights, 500);
+ }
+ }
+ }
+ // Do 2 complete passes, because there can be races
+ // between this code and prettify.
+ startOver = true;
+ setTimeout(setLineNumberHeights, 250);
+ window.onresize = setLineNumberHeights;
+</script>
+
+ 
+ 
+ <div id="log">
+ <div style="text-align:right">
+ <a class="ifCollapse" href="#" onclick="_toggleMeta('', 'p', 'trinitycore', this)">Show details</a>
+ <a class="ifExpand" href="#" onclick="_toggleMeta('', 'p', 'trinitycore', this)">Hide details</a>
+ </div>
+ <div class="ifExpand">
+ 
+ <div class="pmeta_bubble_bg" style="border:1px solid white">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <div id="changelog">
+ <p>Change log</p>
+ <div>
+ <a href="/p/trinitycore/source/detail?spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8&r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">e5037e953a</a>
+ by Rat
+ on Oct 27 (4 days ago)
+ &nbsp; <a href="/p/trinitycore/source/diff?spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8&r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;format=side&amp;path=/sql/updates/10320_world_smart_scripts.sql&amp;old_path=/sql/updates/10320_world_smart_scripts.sql&amp;old=">Diff</a>
+ </div>
+ <pre>Core/AI: implemented SmartScripts System
+(still beta) not 100% complete
+WARNING: Use scripts at own risk. You were
+warned.
+NOTE0: creature, gameobject, areatrigger
+type scripts should be fully functional
+NOTE1: has no effect on any core related
+stuff if not using any SmartScript
+NOTE2: all event/action/etc descriptions
+can be found in SmartScriptMgr.h
+
+SmartScripts is a reloadable DB-Sript
+...</pre>
+ </div>
+ 
+ 
+ 
+ 
+ 
+ 
+ <script type="text/javascript">
+ var detail_url = '/p/trinitycore/source/detail?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8';
+ var publish_url = '/p/trinitycore/source/detail?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8#publish';
+ // describe the paths of this revision in javascript.
+ var changed_paths = [];
+ var changed_urls = [];
+ 
+ changed_paths.push('/sql/updates/10320_world_smart_scripts.sql');
+ changed_urls.push('/p/trinitycore/source/browse/sql/updates/10320_world_smart_scripts.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ var selected_path = '/sql/updates/10320_world_smart_scripts.sql';
+ 
+ 
+ changed_paths.push('/sql/updates/10320_world_waypoints.sql');
+ changed_urls.push('/p/trinitycore/source/browse/sql/updates/10320_world_waypoints.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/CoreAI/GameObjectAI.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/CoreAI/GameObjectAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/CreatureAIRegistry.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/CreatureAIRegistry.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartAI/SmartAI.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartAI/SmartAI.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartAI.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartAI.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScript.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScript.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScriptMgr.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/CMakeLists.txt');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Chat/Chat.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Chat/Chat.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Chat/Chat.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Chat/Chat.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Chat/Commands/Level3.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Chat/Commands/Level3.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Scripting/ScriptLoader.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Scripting/ScriptLoader.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Spells/SpellEffects.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Spells/SpellEffects.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Texts/CreatureTextMgr.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Texts/CreatureTextMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/World/World.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/World/World.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/shared/Database/Implementation/WorldDatabase.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/shared/Database/Implementation/WorldDatabase.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/worldserver/CMakeLists.txt');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/worldserver/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ function getCurrentPageIndex() {
+ for (var i = 0; i < changed_paths.length; i++) {
+ if (selected_path == changed_paths[i]) {
+ return i;
+ }
+ }
+ }
+ function getNextPage() {
+ var i = getCurrentPageIndex();
+ if (i < changed_paths.length - 1) {
+ return changed_urls[i + 1];
+ }
+ return null;
+ }
+ function getPreviousPage() {
+ var i = getCurrentPageIndex();
+ if (i > 0) {
+ return changed_urls[i - 1];
+ }
+ return null;
+ }
+ function gotoNextPage() {
+ var page = getNextPage();
+ if (!page) {
+ page = detail_url;
+ }
+ window.location = page;
+ }
+ function gotoPreviousPage() {
+ var page = getPreviousPage();
+ if (!page) {
+ page = detail_url;
+ }
+ window.location = page;
+ }
+ function gotoDetailPage() {
+ window.location = detail_url;
+ }
+ function gotoPublishPage() {
+ window.location = publish_url;
+ }
+</script>
+ 
+ <style type="text/css">
+ #review_nav {
+ border-top: 3px solid white;
+ padding-top: 6px;
+ margin-top: 1em;
+ }
+ #review_nav td {
+ vertical-align: middle;
+ }
+ #review_nav select {
+ margin: .5em 0;
+ }
+ </style>
+ <div id="review_nav">
+ <table><tr><td>Go to:&nbsp;</td><td>
+ <select name="files_in_rev" onchange="window.location=this.value">
+ 
+ <option value="/p/trinitycore/source/browse/sql/updates/10320_world_smart_scripts.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ selected="selected"
+ >...es/10320_world_smart_scripts.sql</option>
+ 
+ <option value="/p/trinitycore/source/browse/sql/updates/10320_world_waypoints.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...pdates/10320_world_waypoints.sql</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/CoreAI/GameObjectAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...er/game/AI/CoreAI/GameObjectAI.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/CreatureAIRegistry.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...r/game/AI/CreatureAIRegistry.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...rver/game/AI/SmartAI/SmartAI.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...server/game/AI/SmartAI/SmartAI.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...game/AI/SmartScripts/SmartAI.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...r/game/AI/SmartScripts/SmartAI.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >.../AI/SmartScripts/SmartScript.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...me/AI/SmartScripts/SmartScript.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >.../SmartScripts/SmartScriptMgr.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...AI/SmartScripts/SmartScriptMgr.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/CMakeLists.txt</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Chat/Chat.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/Chat/Chat.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Chat/Chat.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/Chat/Chat.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Chat/Commands/Level3.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...er/game/Chat/Commands/Level3.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Scripting/ScriptLoader.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >.../game/Scripting/ScriptLoader.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...rotocol/Handlers/MiscHandler.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...otocol/Handlers/QuestHandler.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...otocol/Handlers/SpellHandler.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Spells/SpellEffects.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...ver/game/Spells/SpellEffects.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Texts/CreatureTextMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...r/game/Texts/CreatureTextMgr.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/World/World.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/World/World.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...Implementation/WorldDatabase.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...e/Implementation/WorldDatabase.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/worldserver/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...erver/worldserver/CMakeLists.txt</option>
+ 
+ </select>
+ </td></tr></table>
+ 
+ <div id="review_show_hide" class="opened">
+ <div class="ifOpened"><a href="#" onclick="return toggleComments()">Hide comments</a></div>
+ <div class="ifClosed"><a href="#" onclick="return toggleComments()">Show comments</a></div>
+ </div>
+ 
+ 
+ 
+
+
+
+ <div style="white-space:nowrap">
+ 
+ <a href="https://www.google.com/accounts/ServiceLogin?service=code&amp;ltmpl=phosting&amp;continue=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_smart_scripts.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;followup=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_smart_scripts.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ >Sign in</a> to write a code review</div>
+
+
+ 
+ </div>
+ 
+ 
+ </div>
+ <div class="round1"></div>
+ <div class="round2"></div>
+ <div class="round4"></div>
+ </div>
+ <div class="pmeta_bubble_bg" style="border:1px solid white">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <div id="older_bubble">
+ <p>Older revisions</p>
+ 
+ <a href="/p/trinitycore/source/list?path=/sql/updates/10320_world_smart_scripts.sql&r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">All revisions of this file</a>
+ </div>
+ </div>
+ <div class="round1"></div>
+ <div class="round2"></div>
+ <div class="round4"></div>
+ </div>
+ <div class="pmeta_bubble_bg" style="border:1px solid white">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <div id="fileinfo_bubble">
+ <p>File info</p>
+ 
+ <div>Size: 1803 bytes,
+ 32 lines</div>
+ 
+ <div><a href="http://trinitycore.googlecode.com/hg/sql/updates/10320_world_smart_scripts.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">View raw file</a></div>
+ </div>
+ 
+ </div>
+ <div class="round1"></div>
+ <div class="round2"></div>
+ <div class="round4"></div>
+ </div>
+ </div>
+ </div>
+
+
+</div>
+</div>
+
+<script src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/prettify/prettify.js"></script>
+<script type="text/javascript">prettyPrint();</script>
+
+<script src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/source_file_scripts.js"></script>
+
+ <script type="text/javascript" src="http://kibbles.googlecode.com/files/kibbles-1.3.1.comp.js"></script>
+ <script type="text/javascript">
+ var lastStop = null;
+ var initilized = false;
+ 
+ function updateCursor(next, prev) {
+ if (prev && prev.element) {
+ prev.element.className = 'cursor_stop cursor_hidden';
+ }
+ if (next && next.element) {
+ next.element.className = 'cursor_stop cursor';
+ lastStop = next.index;
+ }
+ }
+ 
+ function pubRevealed(data) {
+ updateCursorForCell(data.cellId, 'cursor_stop cursor_hidden');
+ if (initilized) {
+ reloadCursors();
+ }
+ }
+ 
+ function draftRevealed(data) {
+ updateCursorForCell(data.cellId, 'cursor_stop cursor_hidden');
+ if (initilized) {
+ reloadCursors();
+ }
+ }
+ 
+ function draftDestroyed(data) {
+ updateCursorForCell(data.cellId, 'nocursor');
+ if (initilized) {
+ reloadCursors();
+ }
+ }
+ function reloadCursors() {
+ kibbles.skipper.reset();
+ loadCursors();
+ if (lastStop != null) {
+ kibbles.skipper.setCurrentStop(lastStop);
+ }
+ }
+ // possibly the simplest way to insert any newly added comments
+ // is to update the class of the corresponding cursor row,
+ // then refresh the entire list of rows.
+ function updateCursorForCell(cellId, className) {
+ var cell = document.getElementById(cellId);
+ // we have to go two rows back to find the cursor location
+ var row = getPreviousElement(cell.parentNode);
+ row.className = className;
+ }
+ // returns the previous element, ignores text nodes.
+ function getPreviousElement(e) {
+ var element = e.previousSibling;
+ if (element.nodeType == 3) {
+ element = element.previousSibling;
+ }
+ if (element && element.tagName) {
+ return element;
+ }
+ }
+ function loadCursors() {
+ // register our elements with skipper
+ var elements = CR_getElements('*', 'cursor_stop');
+ var len = elements.length;
+ for (var i = 0; i < len; i++) {
+ var element = elements[i]; 
+ element.className = 'cursor_stop cursor_hidden';
+ kibbles.skipper.append(element);
+ }
+ }
+ function toggleComments() {
+ CR_toggleCommentDisplay();
+ reloadCursors();
+ }
+ function keysOnLoadHandler() {
+ // setup skipper
+ kibbles.skipper.addStopListener(
+ kibbles.skipper.LISTENER_TYPE.PRE, updateCursor);
+ // Set the 'offset' option to return the middle of the client area
+ // an option can be a static value, or a callback
+ kibbles.skipper.setOption('padding_top', 50);
+ // Set the 'offset' option to return the middle of the client area
+ // an option can be a static value, or a callback
+ kibbles.skipper.setOption('padding_bottom', 100);
+ // Register our keys
+ kibbles.skipper.addFwdKey("n");
+ kibbles.skipper.addRevKey("p");
+ kibbles.keys.addKeyPressListener(
+ 'u', function() { window.location = detail_url; });
+ kibbles.keys.addKeyPressListener(
+ 'r', function() { window.location = detail_url + '#publish'; });
+ 
+ kibbles.keys.addKeyPressListener('j', gotoNextPage);
+ kibbles.keys.addKeyPressListener('k', gotoPreviousPage);
+ 
+ 
+ }
+ window.onload = function() {keysOnLoadHandler();};
+ </script>
+
+<!-- code review support -->
+<script src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/code_review_scripts.js"></script>
+<script type="text/javascript">
+ 
+ // the comment form template
+ var form = '<div class="draft"><div class="header"><span class="title">Draft comment:</span></div>' +
+ '<div class="body"><form onsubmit="return false;"><textarea id="$ID">$BODY</textarea><br>$ACTIONS</form></div>' +
+ '</div>';
+ // the comment "plate" template used for both draft and published comment "plates".
+ var draft_comment = '<div class="draft" ondblclick="$ONDBLCLICK">' +
+ '<div class="header"><span class="title">Draft comment:</span><span class="actions">$ACTIONS</span></div>' +
+ '<pre id="$ID" class="body">$BODY</pre>' +
+ '</div>';
+ var published_comment = '<div class="published">' +
+ '<div class="header"><span class="title"><a href="$PROFILE_URL">$AUTHOR:</a></span><div>' +
+ '<pre id="$ID" class="body">$BODY</pre>' +
+ '</div>';
+
+ function showPublishInstructions() {
+ var element = document.getElementById('review_instr');
+ if (element) {
+ element.className = 'opened';
+ }
+ }
+ function revsOnLoadHandler() {
+ // register our source container with the commenting code
+ var paths = {'svne5037e953ab87554a8cf3197a9a50acf895fa3d8': '/sql/updates/10320_world_smart_scripts.sql'}
+ CR_setup('', 'p', 'trinitycore', '', 'svne5037e953ab87554a8cf3197a9a50acf895fa3d8', paths,
+ '', CR_BrowseIntegrationFactory);
+ // register our hidden ui elements with the code commenting code ui builder.
+ CR_registerLayoutElement('form', form);
+ CR_registerLayoutElement('draft_comment', draft_comment);
+ CR_registerLayoutElement('published_comment', published_comment);
+ 
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.REVEAL_DRAFT_PLATE, showPublishInstructions);
+ 
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.REVEAL_PUB_PLATE, pubRevealed);
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.REVEAL_DRAFT_PLATE, draftRevealed);
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.DISCARD_DRAFT_COMMENT, draftDestroyed);
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ var initilized = true;
+ reloadCursors();
+ }
+ window.onload = function() {keysOnLoadHandler(); revsOnLoadHandler();};
+</script>
+<script type="text/javascript" src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/dit_scripts.js"></script>
+
+ 
+ 
+ <script type="text/javascript" src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/core_scripts_20081103.js"></script>
+ <script type="text/javascript" src="/js/codesite_product_dictionary_ph.pack.04102009.js"></script>
+ </div>
+<div id="footer" dir="ltr">
+ 
+ <div class="text">
+ 
+ &copy;2010 Google -
+ <a href="/projecthosting/terms.html">Terms</a> -
+ <a href="http://www.google.com/privacy.html">Privacy</a> -
+ <a href="/p/support/">Project Hosting Help</a>
+ 
+ </div>
+</div>
+
+ <div class="hostedBy" style="margin-top: -20px;">
+ <span style="vertical-align: top;">Powered by <a href="http://code.google.com/projecthosting/">Google Project Hosting</a></span>
+ </div>
+ 
+ 
+
+
+ 
+ </body>
+</html>
+
diff --git a/sql/updates/10320_world_waypoints.sql b/sql/updates/10320_world_waypoints.sql
new file mode 100644
--- /dev/null
+++ b/sql/updates/10320_world_waypoints.sql
@@ -0,0 +1,1169 @@
+
+
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html>
+<head>
+ <link rel="icon" type="image/vnd.microsoft.icon" href="http://www.gstatic.com/codesite/ph/images/phosting.ico">
+ 
+ <script type="text/javascript">
+ 
+ 
+ 
+ var codesite_token = null;
+ 
+ 
+ var logged_in_user_email = null;
+ 
+ 
+ var relative_base_url = "";
+ 
+ </script>
+ 
+ 
+ <title>10320_world_waypoints.sql - 
+ trinitycore -
+ 
+ Project Hosting on Google Code</title>
+ <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
+ 
+ <meta name="ROBOTS" content="NOARCHIVE">
+ 
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/ph_core.css">
+ 
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/ph_detail.css" >
+ 
+ 
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/d_sb_20080522.css" >
+ 
+ 
+ 
+<!--[if IE]>
+ <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/3526988999065534654/css/d_ie.css" >
+<![endif]-->
+ <style type="text/css">
+ .menuIcon.off { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -42px }
+ .menuIcon.on { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -28px }
+ .menuIcon.down { background: no-repeat url(http://www.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 0; }
+ </style>
+</head>
+<body class="t4">
+ <script type="text/javascript">
+ var _gaq = _gaq || [];
+ _gaq.push(
+ ['siteTracker._setAccount', 'UA-18071-1'],
+ ['siteTracker._trackPageview']);
+ 
+ _gaq.push(
+ ['projectTracker._setAccount', 'UA-4682200-2'],
+ ['projectTracker._trackPageview']);
+ 
+ (function() {
+ var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
+ ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
+ (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
+ })();
+ </script>
+ <div id="gaia">
+ 
+ <span>
+ 
+ <a href="#" id="projects-dropdown" onclick="return false;"><u>My favorites</u> <small>&#9660;</small></a>
+ | <a href="https://www.google.com/accounts/ServiceLogin?service=code&amp;ltmpl=phosting&amp;continue=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_waypoints.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;followup=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_waypoints.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8" onclick="_CS_click('/gb/ph/signin');"><u>Sign in</u></a>
+ 
+ </span>
+
+ </div>
+ <div class="gbh" style="left: 0pt;"></div>
+ <div class="gbh" style="right: 0pt;"></div>
+ 
+ 
+ <div style="height: 1px"></div>
+<!--[if IE 6]>
+<div style="text-align:center;">
+Support browsers that contribute to open source, try <a href="http://www.firefox.com">Firefox</a> or <a href="http://www.google.com/chrome">Google Chrome</a>.
+</div>
+<![endif]-->
+
+
+
+
+ <table style="padding:0px; margin: 20px 0px 0px 0px; width:100%" cellpadding="0" cellspacing="0">
+ <tr style="height: 58px;">
+ 
+ <td style="width: 55px; text-align:center;">
+ <a href="/p/trinitycore/">
+ 
+ 
+ <img src="/p/trinitycore/logo?cct=1282883506" alt="Logo">
+ 
+ </a>
+ </td>
+ 
+ <td style="padding-left: 0.5em">
+ 
+ <div id="pname" style="margin: 0px 0px -3px 0px">
+ <a href="/p/trinitycore/" style="text-decoration:none; color:#000">trinitycore</a>
+ 
+ </div>
+ <div id="psum">
+ <i><a id="project_summary_link" href="/p/trinitycore/" style="text-decoration:none; color:#000">Trinity Core Open Source MMo Framework</a></i>
+ </div>
+ 
+ </td>
+ <td style="white-space:nowrap;text-align:right">
+ 
+ <form action="/hosting/search">
+ <input size="30" name="q" value="">
+ <input type="submit" name="projectsearch" value="Search projects" >
+ </form>
+ 
+ </tr>
+ </table>
+
+
+ 
+<table id="mt" cellspacing="0" cellpadding="0" width="100%" border="0">
+ <tr>
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/">Project&nbsp;Home</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/downloads/list');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/downloads/list">Downloads</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/w/list');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/w/list">Wiki</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/issues/list');">
+ <div class="tab inactive">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/issues/list">Issues</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ 
+ 
+ 
+ <th onclick="if (!cancelBubble) _go('/p/trinitycore/source/checkout');">
+ <div class="tab active">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <a onclick="cancelBubble=true;" href="/p/trinitycore/source/checkout">Source</a>
+ </div>
+ </div>
+ </th><td>&nbsp;&nbsp;</td>
+ 
+ 
+ <td width="100%">&nbsp;</td>
+ </tr>
+</table>
+<table cellspacing="0" cellpadding="0" width="100%" align="center" border="0" class="st">
+ <tr>
+ 
+ 
+ 
+ 
+ 
+ 
+ <td>
+ <div class="st2">
+ <div class="isf">
+ 
+ <form action="/p/trinitycore/source/browse" style="display: inline">
+ 
+ Repository:
+ <select name="repo" id="repo" style="font-size: 92%" onchange="submit()">
+ <option value="default">default</option><option value="wiki">wiki</option><option value="tc-cal">tc-cal</option>
+ </select>
+ </form>
+ 
+ 
+ 
+ <span class="inst1"><a href="/p/trinitycore/source/checkout">Checkout</a></span> |
+ <span class="inst2"><a href="/p/trinitycore/source/browse/">Browse</a></span> |
+ <span class="inst3"><a href="/p/trinitycore/source/list">Changes</a></span> |
+ <span class="inst4"><a href="/p/trinitycore/source/clones">Clones</a></span> |
+ <form action="http://www.google.com/codesearch" method="get" style="display:inline"
+ onsubmit="document.getElementById('codesearchq').value = document.getElementById('origq').value + ' package:http://trinitycore\\.googlecode\\.com'">
+ <input type="hidden" name="q" id="codesearchq" value="">
+ <input maxlength="2048" size="38" id="origq" name="origq" value="" title="Google Code Search" style="font-size:92%">&nbsp;<input type="submit" value="Search Trunk" name="btnG" style="font-size:92%">
+ 
+ 
+ 
+ </form>
+ </div>
+</div>
+
+ </td>
+ 
+ 
+ 
+ <td height="4" align="right" valign="top" class="bevel-right">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ </td>
+ </tr>
+</table>
+<script type="text/javascript">
+ var cancelBubble = false;
+ function _go(url) { document.location = url; }
+</script>
+
+
+<div id="maincol"
+ 
+>
+
+ 
+<!-- IE -->
+
+
+
+
+<div class="expand">
+
+
+<style type="text/css">
+ #file_flipper { display: inline; float: right; white-space: nowrap; }
+ #file_flipper.hidden { display: none; }
+ #file_flipper .pagelink { color: #0000CC; text-decoration: underline; }
+ #file_flipper #visiblefiles { padding-left: 0.5em; padding-right: 0.5em; }
+</style>
+<div id="nav_and_rev" class="heading">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner" id="bub">
+ <div class="bub-top">
+ <div class="pagination" style="margin-left: 2em">
+ <table cellpadding="0" cellspacing="0" class="flipper">
+ <tbody>
+ <tr>
+ 
+ <td><b>e5037e953a</b></td>
+ 
+ </tr>
+ </tbody>
+ </table>
+ </div>
+ 
+ <div class="" style="vertical-align: top">
+ <div class="src_crumbs src_nav">
+ <strong class="src_nav">Source path:&nbsp;</strong>
+ <span id="crumb_root">
+ 
+ <a href="/p/trinitycore/source/browse/?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">hg</a>/&nbsp;</span>
+ <span id="crumb_links" class="ifClosed"><a href="/p/trinitycore/source/browse/sql/?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">sql</a><span class="sp">/&nbsp;</span><a href="/p/trinitycore/source/browse/sql/updates/?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">updates</a><span class="sp">/&nbsp;</span>10320_world_waypoints.sql</span>
+ 
+ 
+ 
+ 
+ <span class="sourcelabel src_nav"><strong>Branch:</strong> trunk</span>
+ 
+ 
+ 
+ <form class="src_nav">
+ 
+ <span class="sourcelabel src_nav">
+ <strong>Tag:</strong>
+ <select id="tag_select" name="r" onchange="submit()">
+ <option value="">&lt;none&gt;</option>
+ 
+ <option value="3.0.8 stable" >3.0.8 stable</option>
+ 
+ <option value="3.1.3-stable-last" >3.1.3-stable-last</option>
+ 
+ <option value="3.2.2a-initial-release" >3.2.2a-initial-release</option>
+ 
+ <option value="3.2.2a-last" >3.2.2a-last</option>
+ 
+ <option value="3.2.2a-really-last" >3.2.2a-really-last</option>
+ 
+ <option value="3.2.2a-stable" >3.2.2a-stable</option>
+ 
+ <option value="3.3.2-last" >3.3.2-last</option>
+ 
+ <option value="3.3.3a-LAST" >3.3.3a-LAST</option>
+ 
+ <option value="3.3.5a-clientsupport" >3.3.5a-clientsupport</option>
+ 
+ <option value="309-313" >309-313</option>
+ 
+ <option value="335a-stable" >335a-stable</option>
+ 
+ <option value="Stable" >Stable</option>
+ 
+ <option value="UP30" >UP30</option>
+ 
+ <option value="UP31" >UP31</option>
+ 
+ <option value="UP33" >UP33</option>
+ 
+ <option value="UP34" >UP34</option>
+ 
+ </select>
+ </span>
+ </form>
+ 
+ 
+ </div>
+ 
+ </div>
+ <div style="clear:both"></div>
+ </div>
+ </div>
+</div>
+
+<style type="text/css">
+ 
+  tr.inline_comment {
+ background: #fff;
+ vertical-align: top;
+ }
+ div.draft, div.published {
+ padding: .3em;
+ border: 1px solid #999; 
+ margin-bottom: .1em;
+ font-family: arial, sans-serif;
+ max-width: 60em;
+ }
+ div.draft {
+ background: #ffa;
+ } 
+ div.published {
+ background: #e5ecf9;
+ }
+ div.published .body, div.draft .body {
+ padding: .5em .1em .1em .1em;
+ max-width: 60em;
+ white-space: pre-wrap;
+ white-space: -moz-pre-wrap;
+ white-space: -pre-wrap;
+ white-space: -o-pre-wrap;
+ word-wrap: break-word;
+ }
+ div.draft .actions {
+ margin-left: 1em;
+ font-size: 90%;
+ }
+ div.draft form {
+ padding: .5em .5em .5em 0;
+ }
+ div.draft textarea, div.published textarea {
+ width: 95%;
+ height: 10em;
+ font-family: arial, sans-serif;
+ margin-bottom: .5em;
+ }
+
+
+ 
+ .nocursor, .nocursor td, .cursor_hidden, .cursor_hidden td {
+ background-color: white;
+ height: 2px;
+ }
+ .cursor, .cursor td {
+ background-color: darkblue;
+ height: 2px;
+ display: '';
+ }
+
+</style>
+<div class="fc">
+ 
+ 
+ 
+<style type="text/css">
+.undermouse span {
+ background-image: url(http://www.gstatic.com/codesite/ph/images/comments.gif); }
+</style>
+<table class="opened" id="review_comment_area"
+><tr>
+<td id="nums">
+<pre><table width="100%"><tr class="nocursor"><td></td></tr></table></pre>
+<pre><table width="100%" id="nums_table_0"><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_1"
+
+><td id="1"><a href="#1">1</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_2"
+
+><td id="2"><a href="#2">2</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_3"
+
+><td id="3"><a href="#3">3</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_4"
+
+><td id="4"><a href="#4">4</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_5"
+
+><td id="5"><a href="#5">5</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_6"
+
+><td id="6"><a href="#6">6</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_7"
+
+><td id="7"><a href="#7">7</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_8"
+
+><td id="8"><a href="#8">8</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_9"
+
+><td id="9"><a href="#9">9</a></td></tr
+><tr id="gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_10"
+
+><td id="10"><a href="#10">10</a></td></tr
+></table></pre>
+<pre><table width="100%"><tr class="nocursor"><td></td></tr></table></pre>
+</td>
+<td id="lines">
+<pre class="prettyprint"><table width="100%"><tr class="cursor_stop cursor_hidden"><td></td></tr></table></pre>
+<pre class="prettyprint lang-sql"><table id="src_table_0"><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_1
+
+><td class="source">DROP TABLE IF EXISTS waypoints;<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_2
+
+><td class="source">CREATE TABLE `waypoints` (<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_3
+
+><td class="source">  `entry` mediumint(8) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_4
+
+><td class="source">  `pointid` mediumint(8) unsigned NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_5
+
+><td class="source">  `position_x` float NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_6
+
+><td class="source">  `position_y` float NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_7
+
+><td class="source">  `position_z` float NOT NULL DEFAULT &#39;0&#39;,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_8
+
+><td class="source">  `point_comment` text,<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_9
+
+><td class="source">  PRIMARY KEY (`entry`,`pointid`)<br></td></tr
+><tr
+id=sl_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_10
+
+><td class="source">) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT=&#39;Creature waypoints&#39;;<br></td></tr
+></table></pre>
+<pre class="prettyprint"><table width="100%"><tr class="cursor_stop cursor_hidden"><td></td></tr></table></pre>
+</td>
+</tr></table>
+<script type="text/javascript">
+ var lineNumUnderMouse = -1;
+ 
+ function gutterOver(num) {
+ gutterOut();
+ var newTR = document.getElementById('gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_' + num);
+ if (newTR) {
+ newTR.className = 'undermouse';
+ }
+ lineNumUnderMouse = num;
+ }
+ function gutterOut() {
+ if (lineNumUnderMouse != -1) {
+ var oldTR = document.getElementById(
+ 'gr_svne5037e953ab87554a8cf3197a9a50acf895fa3d8_' + lineNumUnderMouse);
+ if (oldTR) {
+ oldTR.className = '';
+ }
+ lineNumUnderMouse = -1;
+ }
+ }
+ var numsGenState = {table_base_id: 'nums_table_'};
+ var srcGenState = {table_base_id: 'src_table_'};
+ var alignerRunning = false;
+ var startOver = false;
+ function setLineNumberHeights() {
+ if (alignerRunning) {
+ startOver = true;
+ return;
+ }
+ numsGenState.chunk_id = 0;
+ numsGenState.table = document.getElementById('nums_table_0');
+ numsGenState.row_num = 0;
+ srcGenState.chunk_id = 0;
+ srcGenState.table = document.getElementById('src_table_0');
+ srcGenState.row_num = 0;
+ alignerRunning = true;
+ continueToSetLineNumberHeights();
+ }
+ function rowGenerator(genState) {
+ if (genState.row_num < genState.table.rows.length) {
+ var currentRow = genState.table.rows[genState.row_num];
+ genState.row_num++;
+ return currentRow;
+ }
+ var newTable = document.getElementById(
+ genState.table_base_id + (genState.chunk_id + 1));
+ if (newTable) {
+ genState.chunk_id++;
+ genState.row_num = 0;
+ genState.table = newTable;
+ return genState.table.rows[0];
+ }
+ return null;
+ }
+ var MAX_ROWS_PER_PASS = 1000;
+ function continueToSetLineNumberHeights() {
+ var rowsInThisPass = 0;
+ var numRow = 1;
+ var srcRow = 1;
+ while (numRow && srcRow && rowsInThisPass < MAX_ROWS_PER_PASS) {
+ numRow = rowGenerator(numsGenState);
+ srcRow = rowGenerator(srcGenState);
+ rowsInThisPass++;
+ if (numRow && srcRow) {
+ if (numRow.offsetHeight != srcRow.offsetHeight) {
+ numRow.firstChild.style.height = srcRow.offsetHeight + 'px';
+ }
+ }
+ }
+ if (rowsInThisPass >= MAX_ROWS_PER_PASS) {
+ setTimeout(continueToSetLineNumberHeights, 10);
+ } else {
+ alignerRunning = false;
+ if (startOver) {
+ startOver = false;
+ setTimeout(setLineNumberHeights, 500);
+ }
+ }
+ }
+ // Do 2 complete passes, because there can be races
+ // between this code and prettify.
+ startOver = true;
+ setTimeout(setLineNumberHeights, 250);
+ window.onresize = setLineNumberHeights;
+</script>
+
+ 
+ 
+ <div id="log">
+ <div style="text-align:right">
+ <a class="ifCollapse" href="#" onclick="_toggleMeta('', 'p', 'trinitycore', this)">Show details</a>
+ <a class="ifExpand" href="#" onclick="_toggleMeta('', 'p', 'trinitycore', this)">Hide details</a>
+ </div>
+ <div class="ifExpand">
+ 
+ <div class="pmeta_bubble_bg" style="border:1px solid white">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <div id="changelog">
+ <p>Change log</p>
+ <div>
+ <a href="/p/trinitycore/source/detail?spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8&r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">e5037e953a</a>
+ by Rat
+ on Oct 27 (4 days ago)
+ &nbsp; <a href="/p/trinitycore/source/diff?spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8&r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;format=side&amp;path=/sql/updates/10320_world_waypoints.sql&amp;old_path=/sql/updates/10320_world_waypoints.sql&amp;old=">Diff</a>
+ </div>
+ <pre>Core/AI: implemented SmartScripts System
+(still beta) not 100% complete
+WARNING: Use scripts at own risk. You were
+warned.
+NOTE0: creature, gameobject, areatrigger
+type scripts should be fully functional
+NOTE1: has no effect on any core related
+stuff if not using any SmartScript
+NOTE2: all event/action/etc descriptions
+can be found in SmartScriptMgr.h
+
+SmartScripts is a reloadable DB-Sript
+...</pre>
+ </div>
+ 
+ 
+ 
+ 
+ 
+ 
+ <script type="text/javascript">
+ var detail_url = '/p/trinitycore/source/detail?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8';
+ var publish_url = '/p/trinitycore/source/detail?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8#publish';
+ // describe the paths of this revision in javascript.
+ var changed_paths = [];
+ var changed_urls = [];
+ 
+ changed_paths.push('/sql/updates/10320_world_smart_scripts.sql');
+ changed_urls.push('/p/trinitycore/source/browse/sql/updates/10320_world_smart_scripts.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/sql/updates/10320_world_waypoints.sql');
+ changed_urls.push('/p/trinitycore/source/browse/sql/updates/10320_world_waypoints.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ var selected_path = '/sql/updates/10320_world_waypoints.sql';
+ 
+ 
+ changed_paths.push('/src/server/game/AI/CoreAI/GameObjectAI.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/CoreAI/GameObjectAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/CreatureAIRegistry.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/CreatureAIRegistry.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartAI/SmartAI.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartAI/SmartAI.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartAI.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartAI.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScript.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScript.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/AI/SmartScripts/SmartScriptMgr.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/CMakeLists.txt');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Chat/Chat.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Chat/Chat.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Chat/Chat.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Chat/Chat.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Chat/Commands/Level3.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Chat/Commands/Level3.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Scripting/ScriptLoader.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Scripting/ScriptLoader.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Spells/SpellEffects.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Spells/SpellEffects.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/Texts/CreatureTextMgr.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/Texts/CreatureTextMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/game/World/World.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/game/World/World.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/shared/Database/Implementation/WorldDatabase.cpp');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/shared/Database/Implementation/WorldDatabase.h');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ changed_paths.push('/src/server/worldserver/CMakeLists.txt');
+ changed_urls.push('/p/trinitycore/source/browse/src/server/worldserver/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8');
+ 
+ 
+ function getCurrentPageIndex() {
+ for (var i = 0; i < changed_paths.length; i++) {
+ if (selected_path == changed_paths[i]) {
+ return i;
+ }
+ }
+ }
+ function getNextPage() {
+ var i = getCurrentPageIndex();
+ if (i < changed_paths.length - 1) {
+ return changed_urls[i + 1];
+ }
+ return null;
+ }
+ function getPreviousPage() {
+ var i = getCurrentPageIndex();
+ if (i > 0) {
+ return changed_urls[i - 1];
+ }
+ return null;
+ }
+ function gotoNextPage() {
+ var page = getNextPage();
+ if (!page) {
+ page = detail_url;
+ }
+ window.location = page;
+ }
+ function gotoPreviousPage() {
+ var page = getPreviousPage();
+ if (!page) {
+ page = detail_url;
+ }
+ window.location = page;
+ }
+ function gotoDetailPage() {
+ window.location = detail_url;
+ }
+ function gotoPublishPage() {
+ window.location = publish_url;
+ }
+</script>
+ 
+ <style type="text/css">
+ #review_nav {
+ border-top: 3px solid white;
+ padding-top: 6px;
+ margin-top: 1em;
+ }
+ #review_nav td {
+ vertical-align: middle;
+ }
+ #review_nav select {
+ margin: .5em 0;
+ }
+ </style>
+ <div id="review_nav">
+ <table><tr><td>Go to:&nbsp;</td><td>
+ <select name="files_in_rev" onchange="window.location=this.value">
+ 
+ <option value="/p/trinitycore/source/browse/sql/updates/10320_world_smart_scripts.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...es/10320_world_smart_scripts.sql</option>
+ 
+ <option value="/p/trinitycore/source/browse/sql/updates/10320_world_waypoints.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ selected="selected"
+ >...pdates/10320_world_waypoints.sql</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/CoreAI/GameObjectAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...er/game/AI/CoreAI/GameObjectAI.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/CreatureAIRegistry.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...r/game/AI/CreatureAIRegistry.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...rver/game/AI/SmartAI/SmartAI.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartAI/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...server/game/AI/SmartAI/SmartAI.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...game/AI/SmartScripts/SmartAI.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartAI.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...r/game/AI/SmartScripts/SmartAI.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >.../AI/SmartScripts/SmartScript.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScript.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...me/AI/SmartScripts/SmartScript.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >.../SmartScripts/SmartScriptMgr.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/AI/SmartScripts/SmartScriptMgr.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...AI/SmartScripts/SmartScriptMgr.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/CMakeLists.txt</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Chat/Chat.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/Chat/Chat.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Chat/Chat.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/Chat/Chat.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Chat/Commands/Level3.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...er/game/Chat/Commands/Level3.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Scripting/ScriptLoader.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >.../game/Scripting/ScriptLoader.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...rotocol/Handlers/MiscHandler.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...otocol/Handlers/QuestHandler.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...otocol/Handlers/SpellHandler.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Spells/SpellEffects.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...ver/game/Spells/SpellEffects.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/Texts/CreatureTextMgr.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...r/game/Texts/CreatureTextMgr.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/game/World/World.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >/src/server/game/World/World.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.cpp?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...Implementation/WorldDatabase.cpp</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/shared/Database/Implementation/WorldDatabase.h?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...e/Implementation/WorldDatabase.h</option>
+ 
+ <option value="/p/trinitycore/source/browse/src/server/worldserver/CMakeLists.txt?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;spec=svne5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ 
+ >...erver/worldserver/CMakeLists.txt</option>
+ 
+ </select>
+ </td></tr></table>
+ 
+ <div id="review_show_hide" class="opened">
+ <div class="ifOpened"><a href="#" onclick="return toggleComments()">Hide comments</a></div>
+ <div class="ifClosed"><a href="#" onclick="return toggleComments()">Show comments</a></div>
+ </div>
+ 
+ 
+ 
+
+
+
+ <div style="white-space:nowrap">
+ 
+ <a href="https://www.google.com/accounts/ServiceLogin?service=code&amp;ltmpl=phosting&amp;continue=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_waypoints.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8&amp;followup=http%3A%2F%2Fcode.google.com%2Fp%2Ftrinitycore%2Fsource%2Fbrowse%2Fsql%2Fupdates%2F10320_world_waypoints.sql%3Fspec%3Dsvne5037e953ab87554a8cf3197a9a50acf895fa3d8%26r%3De5037e953ab87554a8cf3197a9a50acf895fa3d8"
+ >Sign in</a> to write a code review</div>
+
+
+ 
+ </div>
+ 
+ 
+ </div>
+ <div class="round1"></div>
+ <div class="round2"></div>
+ <div class="round4"></div>
+ </div>
+ <div class="pmeta_bubble_bg" style="border:1px solid white">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <div id="older_bubble">
+ <p>Older revisions</p>
+ 
+ <a href="/p/trinitycore/source/list?path=/sql/updates/10320_world_waypoints.sql&r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">All revisions of this file</a>
+ </div>
+ </div>
+ <div class="round1"></div>
+ <div class="round2"></div>
+ <div class="round4"></div>
+ </div>
+ <div class="pmeta_bubble_bg" style="border:1px solid white">
+ <div class="round4"></div>
+ <div class="round2"></div>
+ <div class="round1"></div>
+ <div class="box-inner">
+ <div id="fileinfo_bubble">
+ <p>File info</p>
+ 
+ <div>Size: 440 bytes,
+ 10 lines</div>
+ 
+ <div><a href="http://trinitycore.googlecode.com/hg/sql/updates/10320_world_waypoints.sql?r=e5037e953ab87554a8cf3197a9a50acf895fa3d8">View raw file</a></div>
+ </div>
+ 
+ </div>
+ <div class="round1"></div>
+ <div class="round2"></div>
+ <div class="round4"></div>
+ </div>
+ </div>
+ </div>
+
+
+</div>
+</div>
+
+<script src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/prettify/prettify.js"></script>
+<script type="text/javascript">prettyPrint();</script>
+
+<script src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/source_file_scripts.js"></script>
+
+ <script type="text/javascript" src="http://kibbles.googlecode.com/files/kibbles-1.3.1.comp.js"></script>
+ <script type="text/javascript">
+ var lastStop = null;
+ var initilized = false;
+ 
+ function updateCursor(next, prev) {
+ if (prev && prev.element) {
+ prev.element.className = 'cursor_stop cursor_hidden';
+ }
+ if (next && next.element) {
+ next.element.className = 'cursor_stop cursor';
+ lastStop = next.index;
+ }
+ }
+ 
+ function pubRevealed(data) {
+ updateCursorForCell(data.cellId, 'cursor_stop cursor_hidden');
+ if (initilized) {
+ reloadCursors();
+ }
+ }
+ 
+ function draftRevealed(data) {
+ updateCursorForCell(data.cellId, 'cursor_stop cursor_hidden');
+ if (initilized) {
+ reloadCursors();
+ }
+ }
+ 
+ function draftDestroyed(data) {
+ updateCursorForCell(data.cellId, 'nocursor');
+ if (initilized) {
+ reloadCursors();
+ }
+ }
+ function reloadCursors() {
+ kibbles.skipper.reset();
+ loadCursors();
+ if (lastStop != null) {
+ kibbles.skipper.setCurrentStop(lastStop);
+ }
+ }
+ // possibly the simplest way to insert any newly added comments
+ // is to update the class of the corresponding cursor row,
+ // then refresh the entire list of rows.
+ function updateCursorForCell(cellId, className) {
+ var cell = document.getElementById(cellId);
+ // we have to go two rows back to find the cursor location
+ var row = getPreviousElement(cell.parentNode);
+ row.className = className;
+ }
+ // returns the previous element, ignores text nodes.
+ function getPreviousElement(e) {
+ var element = e.previousSibling;
+ if (element.nodeType == 3) {
+ element = element.previousSibling;
+ }
+ if (element && element.tagName) {
+ return element;
+ }
+ }
+ function loadCursors() {
+ // register our elements with skipper
+ var elements = CR_getElements('*', 'cursor_stop');
+ var len = elements.length;
+ for (var i = 0; i < len; i++) {
+ var element = elements[i]; 
+ element.className = 'cursor_stop cursor_hidden';
+ kibbles.skipper.append(element);
+ }
+ }
+ function toggleComments() {
+ CR_toggleCommentDisplay();
+ reloadCursors();
+ }
+ function keysOnLoadHandler() {
+ // setup skipper
+ kibbles.skipper.addStopListener(
+ kibbles.skipper.LISTENER_TYPE.PRE, updateCursor);
+ // Set the 'offset' option to return the middle of the client area
+ // an option can be a static value, or a callback
+ kibbles.skipper.setOption('padding_top', 50);
+ // Set the 'offset' option to return the middle of the client area
+ // an option can be a static value, or a callback
+ kibbles.skipper.setOption('padding_bottom', 100);
+ // Register our keys
+ kibbles.skipper.addFwdKey("n");
+ kibbles.skipper.addRevKey("p");
+ kibbles.keys.addKeyPressListener(
+ 'u', function() { window.location = detail_url; });
+ kibbles.keys.addKeyPressListener(
+ 'r', function() { window.location = detail_url + '#publish'; });
+ 
+ kibbles.keys.addKeyPressListener('j', gotoNextPage);
+ kibbles.keys.addKeyPressListener('k', gotoPreviousPage);
+ 
+ 
+ }
+ window.onload = function() {keysOnLoadHandler();};
+ </script>
+
+<!-- code review support -->
+<script src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/code_review_scripts.js"></script>
+<script type="text/javascript">
+ 
+ // the comment form template
+ var form = '<div class="draft"><div class="header"><span class="title">Draft comment:</span></div>' +
+ '<div class="body"><form onsubmit="return false;"><textarea id="$ID">$BODY</textarea><br>$ACTIONS</form></div>' +
+ '</div>';
+ // the comment "plate" template used for both draft and published comment "plates".
+ var draft_comment = '<div class="draft" ondblclick="$ONDBLCLICK">' +
+ '<div class="header"><span class="title">Draft comment:</span><span class="actions">$ACTIONS</span></div>' +
+ '<pre id="$ID" class="body">$BODY</pre>' +
+ '</div>';
+ var published_comment = '<div class="published">' +
+ '<div class="header"><span class="title"><a href="$PROFILE_URL">$AUTHOR:</a></span><div>' +
+ '<pre id="$ID" class="body">$BODY</pre>' +
+ '</div>';
+
+ function showPublishInstructions() {
+ var element = document.getElementById('review_instr');
+ if (element) {
+ element.className = 'opened';
+ }
+ }
+ function revsOnLoadHandler() {
+ // register our source container with the commenting code
+ var paths = {'svne5037e953ab87554a8cf3197a9a50acf895fa3d8': '/sql/updates/10320_world_waypoints.sql'}
+ CR_setup('', 'p', 'trinitycore', '', 'svne5037e953ab87554a8cf3197a9a50acf895fa3d8', paths,
+ '', CR_BrowseIntegrationFactory);
+ // register our hidden ui elements with the code commenting code ui builder.
+ CR_registerLayoutElement('form', form);
+ CR_registerLayoutElement('draft_comment', draft_comment);
+ CR_registerLayoutElement('published_comment', published_comment);
+ 
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.REVEAL_DRAFT_PLATE, showPublishInstructions);
+ 
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.REVEAL_PUB_PLATE, pubRevealed);
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.REVEAL_DRAFT_PLATE, draftRevealed);
+ CR_registerActivityListener(CR_ACTIVITY_TYPE.DISCARD_DRAFT_COMMENT, draftDestroyed);
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ var initilized = true;
+ reloadCursors();
+ }
+ window.onload = function() {keysOnLoadHandler(); revsOnLoadHandler();};
+</script>
+<script type="text/javascript" src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/dit_scripts.js"></script>
+
+ 
+ 
+ <script type="text/javascript" src="http://www.gstatic.com/codesite/ph/3526988999065534654/js/core_scripts_20081103.js"></script>
+ <script type="text/javascript" src="/js/codesite_product_dictionary_ph.pack.04102009.js"></script>
+ </div>
+<div id="footer" dir="ltr">
+ 
+ <div class="text">
+ 
+ &copy;2010 Google -
+ <a href="/projecthosting/terms.html">Terms</a> -
+ <a href="http://www.google.com/privacy.html">Privacy</a> -
+ <a href="/p/support/">Project Hosting Help</a>
+ 
+ </div>
+</div>
+
+ <div class="hostedBy" style="margin-top: -20px;">
+ <span style="vertical-align: top;">Powered by <a href="http://code.google.com/projecthosting/">Google Project Hosting</a></span>
+ </div>
+ 
+ 
+
+
+ 
+ </body>
+</html>
+
diff --git a/src/server/game/AI/CoreAI/GameObjectAI.h b/src/server/game/AI/CoreAI/GameObjectAI.h
--- a/src/server/game/AI/CoreAI/GameObjectAI.h
+++ b/src/server/game/AI/CoreAI/GameObjectAI.h
@@ -40,6 +40,15 @@
         virtual void Reset() {};
         
         static int Permissible(const GameObject* go);
+
+		virtual bool GossipHello(Player* player) {return false;}
+		virtual bool GossipSelect(Player* player, uint32 sender, uint32 action) {return false;}
+		virtual bool GossipSelectCode(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/, const char* /*code*/) {return false;}
+		virtual bool QuestAccept(Player* player, Quest const* quest) {return false;}
+		virtual bool QuestReward(Player* player, Quest const* quest, uint32 opt) {return false;}
+		uint32 GetDialogStatus(Player* /*player*/) {return 100;}
+		virtual void Destroyed(Player* player, uint32 eventId) {}
+		virtual void SetData(uint32 id, uint32 value) {}
 };
 
 class NullGameObjectAI : public GameObjectAI
diff --git a/src/server/game/AI/CreatureAIRegistry.cpp b/src/server/game/AI/CreatureAIRegistry.cpp
--- a/src/server/game/AI/CreatureAIRegistry.cpp
+++ b/src/server/game/AI/CreatureAIRegistry.cpp
@@ -55,6 +55,7 @@
         (new CreatureAIFactory<SmartAI>("SmartAI"))->RegisterSelf();
 
         (new GameObjectAIFactory<GameObjectAI>("GameObjectAI"))->RegisterSelf();
+		(new GameObjectAIFactory<SmartGameObjectAI>("SmartGameObjectAI"))->RegisterSelf();
 
         (new MovementGeneratorFactory<RandomMovementGenerator<Creature> >(RANDOM_MOTION_TYPE))->RegisterSelf();
         (new MovementGeneratorFactory<WaypointMovementGenerator<Creature> >(WAYPOINT_MOTION_TYPE))->RegisterSelf();
diff --git a/src/server/game/AI/SmartAI/SmartAI.cpp b/src/server/game/AI/SmartAI/SmartAI.cpp
--- a/src/server/game/AI/SmartAI/SmartAI.cpp
+++ b/src/server/game/AI/SmartAI/SmartAI.cpp
@@ -1,191 +1,900 @@
-/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "SQLStorage.h"
-#include "SmartAI.h"
-#include "ObjectMgr.h"
-#include "ProgressBar.h"
-#include "ObjectDefines.h"
-#include "GridDefines.h"
-#include "ConditionMgr.h"
-#include "CreatureTextMgr.h"
-
-void SmartAIMgr::LoadSmartAIFromDB()
-{
-    //Drop Existing SmartAI List
-}
-
-SmartAI::SmartAI(Creature *c) : CreatureAI(c)
-{
-    // copy script to local (pretection for table reload)
-}
-
-int SmartAI::Permissible(const Creature* creature)
-{
-    if (creature->GetAIName() == "SmartAI")
-        return PERMIT_BASE_SPECIAL;
-    return PERMIT_BASE_NO;
-}
-
-void SmartAI::UpdateAI(const uint32 /*diff*/)
-{
-}
-
-void SmartAI::JustRespawned()
-{
-}
-
-void SmartAI::Reset()
-{
-}
-
-void SmartAI::JustReachedHome()
-{
-}
-
-void SmartAI::EnterCombat(Unit* /*enemy*/)
-{
-}
-
-void SmartAI::EnterEvadeMode()
-{
-}
-
-void SmartAI::JustDied(Unit* /*killer*/)
-{
-}
-
-void SmartAI::KilledUnit(Unit* /*victim*/)
-{
-}
-
-void SmartAI::JustSummoned(Creature* /*pUnit*/)
-{
-}
-
-void SmartAI::AttackStart(Unit* who)
-{
-    if (who && me->Attack(who, true))
-        me->GetMotionMaster()->MoveChase(who);
-}
-
-void SmartAI::MoveInLineOfSight(Unit* /*who*/)
-{
-    //CanAIAttack
-}
-
-void SmartAI::SpellHit(Unit* /*pUnit*/, const SpellEntry* /*pSpell*/)
-{
-}
-
-void SmartAI::SpellHitTarget(Unit* /*target*/, const SpellEntry* /*pSpell*/)
-{
-}
-
-void SmartAI::DamageTaken(Unit* /*done_by*/, uint32& /*damage*/, DamageEffectType /*damagetype*/)
-{
-}
-
-void SmartAI::HealReceived(Unit* /*done_by*/, uint32& /*addhealth*/)
-{
-}
-
-void SmartAI::ReceiveEmote(Player* /*pPlayer*/, uint32 /*text_emote*/)
-{
-}
-
-void SmartAI::MovementInform(uint32 /*MovementType*/, uint32 /*Data*/)
-{
-}
-
-void SmartAI::IsSummonedBy(Unit* /*summoner*/)
-{
-}
-
-void SmartAI::DamageDealt(Unit* /*done_to*/, uint32& /*damage*/)
-{
-}
-
-void SmartAI::SummonedCreatureDespawn(Creature* /*unit*/)
-{
-}
-
-void SmartAI::UpdateAIWhileCharmed(const uint32 /*diff*/)
-{
-}
-
-void SmartAI::CorpseRemoved(uint32& /*respawnDelay*/)
-{
-}
-
-void SmartAI::PassengerBoarded(Unit* /*who*/, int8 /*seatId*/, bool /*apply*/)
-{
-}
-
-void SmartAI::InitializeAI()
-{
-}
-
-void SmartAI::OnCharmed(bool /*apply*/)
-{
-}
-
-bool SmartAI::CanAIAttack(const Unit* /*who*/) const
-{
-    return true;
-}
-
-void SmartAI::DoAction(const int32 /*param*/)
-{
-}
-
-uint32 SmartAI::GetData(uint32 /*id*/)
-{
-    return 0;
-}
-
-void SmartAI::SetData(uint32 /*id*/, uint32 /*value*/)
-{
-}
-
-void SmartAI::SetGUID(const uint64& /*guid*/, int32 /*id*/)
-{
-}
-
-uint64 SmartAI::GetGUID(int32 /*id*/)
-{
-    return 0;
-}
-
-void SmartAI::MovepointReached(uint32 /*id*/)
-{
-}
-
-void SmartAI::MovepointStart(uint32 /*id*/)
-{
-}
-
-void SmartAI::SetRun(bool /*run*/)
-{
-}
-
-void SmartAI::SetMovePathEndAction(SMARTAI_ACTION /*action*/)
-{
-}
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "DatabaseEnv.h"
+#include "SQLStorage.h"
+#include "ObjectMgr.h"
+#include "ProgressBar.h"
+#include "ObjectDefines.h"
+#include "GridDefines.h"
+#include "GridNotifiers.h"
+#include "SpellMgr.h"
+#include "GridNotifiersImpl.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "InstanceScript.h"
+#include "ScriptedCreature.h"
+
+#include "SmartAI.h"
+#include "ScriptPCH.h"
+
+SmartAI::SmartAI(Creature *c) : CreatureAI(c)
+{
+    // copy script to local (pretection for table reload)
+
+    mWayPoints = NULL;
+    mEscortState = SMART_ESCORT_NONE;
+    mCurrentWPID = 0;//first wp id is 1 !!
+    mWPReached = false;
+    mWPPauseTimer = 0;
+    mLastWP = NULL;
+
+    mCanRepeatPath = false;
+
+    // spawn in run mode
+    me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
+    mRun = true;
+
+    me->GetPosition(&mLastOOCPos);
+    
+    mCanAutoAttack = true;
+    mCanCombatMove = true;
+
+    mForcedPaused = false;
+    mLastWPIDReached = 0;
+
+    mEscortQuestID = 0;
+
+    mDespawnTime = 0;
+    mDespawnState = 0;
+
+    mEscortInvokerCheckTimer = 1000;
+    mFollowGuid = 0;
+    mFollowDist = 0;
+    mFollowAngle = 0;
+    mFollowCredit = 0;
+    mFollowArrivedEntry = 0;
+    mFollowCreditType = 0;
+}
+
+void SmartAI::UpdateDespawn(const uint32 diff)
+{
+    if (mDespawnState <= 1 || mDespawnState > 3) return;
+    if (mDespawnTime < diff)
+    {
+        if (mDespawnState == 2)
+        {
+            me->SetVisibility(VISIBILITY_OFF);
+            mDespawnTime = 5000;
+            mDespawnState++;
+        }
+        else
+            me->ForcedDespawn();
+    } else mDespawnTime -= diff;
+}
+
+void SmartAI::Reset()
+{
+    SetRun(true);
+    GetScript()->OnReset();
+}
+
+WayPoint* SmartAI::GetNextWayPoint()
+{
+    if (!mWayPoints || mWayPoints->empty())
+        return NULL;
+
+    mCurrentWPID++;
+    WPPath::const_iterator itr = mWayPoints->find(mCurrentWPID);
+    if (itr != mWayPoints->end())
+    {
+        mLastWP = (*itr).second;
+        if (mLastWP->id != mCurrentWPID)
+        {
+            sLog.outError("SmartAI::GetNextWayPoint: Got not expected waypoint id %u, expected %u", mLastWP->id, mCurrentWPID);
+        }
+        return (*itr).second;
+    }
+    return NULL;
+}
+
+void SmartAI::StartPath(bool run, uint32 path, bool repeat, Unit* invoker)
+{
+    if (me->isInCombat())// no wp movement in combat
+    {
+        sLog.outError("SmartAI::StartPath: Creature entry %u wanted to start waypoint movement while in combat, ignoring.", me->GetEntry());
+        return;
+    }
+    if (HasEscortState(SMART_ESCORT_ESCORTING))
+        StopPath();
+    if (path)
+        if (!LoadPath(path))
+            return;
+    if (!mWayPoints || mWayPoints->empty())
+        return;
+
+    AddEscortState(SMART_ESCORT_ESCORTING);
+    mCanRepeatPath = repeat;
+
+    SetRun(run);
+
+    WayPoint* wp = GetNextWayPoint();
+    if (wp)
+    {
+        me->GetPosition(&mLastOOCPos);
+        me->GetMotionMaster()->MovePoint(wp->id, wp->x, wp->y, wp->z);
+        GetScript()->ProcessEventsFor(SMART_EVENT_WAYPOINT_START, NULL, wp->id, GetScript()->GetPathId());
+    }
+}
+
+bool SmartAI::LoadPath(uint32 entry)
+{
+    if (HasEscortState(SMART_ESCORT_ESCORTING))
+        return false;
+    mWayPoints = sSmartWaypointMgr.GetPath(entry);
+    if (!mWayPoints)
+    {
+        GetScript()->SetPathId(0);
+        return false;
+    }
+    GetScript()->SetPathId(entry);
+    return true;
+}
+
+void SmartAI::PausePath(uint32 delay, bool forced)
+{
+    if (!HasEscortState(SMART_ESCORT_ESCORTING))
+        return;
+    if (HasEscortState(SMART_ESCORT_PAUSED))
+    {
+        sLog.outError("SmartAI::StartPath: Creature entry %u wanted to pause waypoint movement while already paused, ignoring.", me->GetEntry());
+        return;
+    }
+    mForcedPaused = forced;
+    me->GetPosition(&mLastOOCPos);
+    AddEscortState(SMART_ESCORT_PAUSED);
+    mWPPauseTimer = delay;
+    if (forced)
+    {
+        SetRun(mRun);
+        me->StopMoving();//force stop
+        me->GetMotionMaster()->MoveIdle();//force stop
+    }
+    GetScript()->ProcessEventsFor(SMART_EVENT_WAYPOINT_PAUSED, NULL, mLastWP->id, GetScript()->GetPathId());
+}
+
+void SmartAI::StopPath(uint32 DespawnTime, uint32 quest, bool fail)
+{
+    if (!HasEscortState(SMART_ESCORT_ESCORTING))
+        return;
+
+    if (quest)
+        mEscortQuestID = quest;
+    SetDespawnTime(DespawnTime);
+    //mDespawnTime = DespawnTime;
+
+    me->GetPosition(&mLastOOCPos);
+    me->StopMoving();//force stop
+    me->GetMotionMaster()->MoveIdle();
+    GetScript()->ProcessEventsFor(SMART_EVENT_WAYPOINT_STOPPED, NULL, mLastWP->id, GetScript()->GetPathId());
+    EndPath(fail);
+}
+
+void SmartAI::EndPath(bool fail)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_WAYPOINT_ENDED, NULL, mLastWP->id, GetScript()->GetPathId());
+
+    RemoveEscortState(SMART_ESCORT_ESCORTING | SMART_ESCORT_PAUSED | SMART_ESCORT_RETURNING);
+    mWayPoints = NULL;
+    mCurrentWPID = 0;
+    mWPPauseTimer = 0;
+    mLastWP = NULL;
+    
+    if (mCanRepeatPath)
+        StartPath(mRun, GetScript()->GetPathId(), mCanRepeatPath);
+    else
+        GetScript()->SetPathId(0);
+
+
+    ObjectList* targets = GetScript()->GetTargetList(SMART_ESCORT_TARGETS);
+    if (targets && mEscortQuestID)
+    {
+        if (targets->size() == 1 && GetScript()->IsPlayer((*targets->begin())))
+        {
+            Player* plr = (*targets->begin())->ToPlayer();
+            if(!fail && plr->IsAtGroupRewardDistance(me) && !plr->GetCorpse())
+                plr->GroupEventHappens(mEscortQuestID, me);
+
+            if(fail && plr->GetQuestStatus(mEscortQuestID) == QUEST_STATUS_INCOMPLETE)
+                plr->FailQuest(mEscortQuestID);
+
+            if (Group *pGroup = plr->GetGroup())
+            {
+                for (GroupReference *gr = pGroup->GetFirstMember(); gr != NULL; gr = gr->next())
+                {
+                    Player *pGroupGuy = gr->getSource();
+
+                    if(!fail && pGroupGuy->IsAtGroupRewardDistance(me) && !pGroupGuy->GetCorpse())
+                        pGroupGuy->AreaExploredOrEventHappens(mEscortQuestID);
+                    if(fail && pGroupGuy->GetQuestStatus(mEscortQuestID) == QUEST_STATUS_INCOMPLETE)
+                        pGroupGuy->FailQuest(mEscortQuestID);
+                }
+            }
+        }else
+        {
+            for (ObjectList::iterator iter = targets->begin(); iter != targets->end(); iter++)
+            {
+                if (GetScript()->IsPlayer((*iter)))
+                {
+                    Player* plr = (*iter)->ToPlayer();
+                    if(!fail && plr->IsAtGroupRewardDistance(me) && !plr->GetCorpse())
+                        plr->AreaExploredOrEventHappens(mEscortQuestID);
+                    if(fail && plr->GetQuestStatus(mEscortQuestID) == QUEST_STATUS_INCOMPLETE)
+                        plr->FailQuest(mEscortQuestID);
+                }
+            }
+        }
+    }
+    if (mDespawnState == 1)
+        StartDespawn();
+}
+
+void SmartAI::ResumePath()
+{
+    //mWPReached = false;
+    SetRun(mRun);
+    if (mLastWP)
+        me->GetMotionMaster()->MovePoint(mLastWP->id, mLastWP->x, mLastWP->y, mLastWP->z);
+}
+
+void SmartAI::ReturnToLastOOCPos()
+{
+    SetRun(mRun);
+    me->GetMotionMaster()->MovePoint(SMART_ESCORT_LAST_OOC_POINT, mLastOOCPos);
+}
+
+void SmartAI::UpdatePath(const uint32 diff)
+{
+    if (!HasEscortState(SMART_ESCORT_ESCORTING))
+        return;
+    if (mEscortInvokerCheckTimer < diff)
+    {
+        if (!IsEscortInvokerInRange())
+        {
+            StopPath(mDespawnTime, mEscortQuestID, true);
+        }
+        mEscortInvokerCheckTimer = 1000;
+    } else mEscortInvokerCheckTimer -= diff;
+    // handle pause
+    if (HasEscortState(SMART_ESCORT_PAUSED))
+    {
+        if (mWPPauseTimer < diff)
+        {
+            if (!me->isInCombat() && !HasEscortState(SMART_ESCORT_RETURNING) && (mWPReached || mLastWPIDReached == SMART_ESCORT_LAST_OOC_POINT || mForcedPaused))
+            {
+                GetScript()->ProcessEventsFor(SMART_EVENT_WAYPOINT_RESUMED, NULL, mLastWP->id, GetScript()->GetPathId());
+                RemoveEscortState(SMART_ESCORT_PAUSED);
+                if (mForcedPaused)// if paused between 2 wps resend movement
+                {
+                    ResumePath();
+                    mWPReached = false;
+                    mForcedPaused = false;
+                }
+                if (mLastWPIDReached == SMART_ESCORT_LAST_OOC_POINT)
+                    mWPReached = true;
+            }
+            mWPPauseTimer = 0;
+        } else {
+            mWPPauseTimer -= diff;
+
+        }
+    }
+    if (HasEscortState(SMART_ESCORT_RETURNING))
+    {
+        if (mWPReached)//reached OOC WP
+        {
+            RemoveEscortState(SMART_ESCORT_RETURNING);
+            if (!HasEscortState(SMART_ESCORT_PAUSED))
+                ResumePath();
+            mWPReached = false;
+        }
+    }
+    if (me->isInCombat() || HasEscortState(SMART_ESCORT_PAUSED | SMART_ESCORT_RETURNING))
+        return;
+    // handle next wp
+    if (mWPReached)//reached WP
+    {
+        mWPReached = false;
+        if (mCurrentWPID == GetWPCount())
+        {
+            EndPath();
+        } else {
+            WayPoint* wp = GetNextWayPoint();
+            if (wp)
+            {
+                SetRun(mRun);
+                me->GetMotionMaster()->MovePoint(wp->id, wp->x, wp->y, wp->z);
+            }
+        }
+        
+    }
+}
+
+void SmartAI::UpdateAI(const uint32 diff)
+{
+    GetScript()->OnUpdate(diff);
+    UpdatePath(diff);
+    UpdateDespawn(diff);
+
+    //TODO move to void
+    if (mFollowGuid)
+    {
+        if (mFollowArrivedTimer < diff)
+        {
+            if (Creature* target = me->FindNearestCreature(mFollowArrivedEntry,INTERACTION_DISTANCE, true))
+            {
+                if (Player* plr = me->GetPlayer(*me, mFollowGuid))
+                {
+                    if (!mFollowCreditType)
+                        plr->RewardPlayerAndGroupAtEvent(mFollowCredit, me);
+                    else
+                        plr->GroupEventHappens(mFollowCredit, me);
+                }
+                mFollowGuid = 0;
+                mFollowDist = 0;
+                mFollowAngle = 0;
+                mFollowCredit = 0;
+                mFollowArrivedTimer = 1000;
+                mFollowArrivedEntry = 0;
+                mFollowCreditType = 0;
+                SetDespawnTime(5000);
+                me->StopMoving();
+                me->GetMotionMaster()->MoveIdle();
+                StartDespawn();
+                GetScript()->ProcessEventsFor(SMART_EVENT_FOLLOW_COPMLETE);
+                return;
+            }
+            mFollowArrivedTimer = 1000;
+        } else mFollowArrivedTimer -= diff;
+    }
+
+    if (!UpdateVictim())
+        return;
+
+    if(mCanAutoAttack)
+        DoMeleeAttackIfReady();
+}
+
+bool SmartAI::IsEscortInvokerInRange()
+{
+    ObjectList* targets = GetScript()->GetTargetList(SMART_ESCORT_TARGETS);
+    if (targets)
+    {
+        if (targets->size() == 1 && GetScript()->IsPlayer((*targets->begin())))
+        {
+            Player* plr = (*targets->begin())->ToPlayer();
+            if (me->GetDistance(plr) <= SMART_ESCORT_MAX_PLAYER_DIST)
+                        return true;
+
+            if (Group *pGroup = plr->GetGroup())
+            {
+                for (GroupReference *gr = pGroup->GetFirstMember(); gr != NULL; gr = gr->next())
+                {
+                    Player *pGroupGuy = gr->getSource();
+
+                    if (me->GetDistance(pGroupGuy) <= SMART_ESCORT_MAX_PLAYER_DIST)
+                        return true;
+                }
+            }
+        }else
+        {
+            for (ObjectList::iterator iter = targets->begin(); iter != targets->end(); iter++)
+            {
+                if (GetScript()->IsPlayer((*iter)))
+                {
+                    if (me->GetDistance((*iter)->ToPlayer()) <= SMART_ESCORT_MAX_PLAYER_DIST)
+                        return true;
+                }
+            }
+        }
+    }
+    return false;
+}
+
+void SmartAI::MovepointReached(uint32 id)
+{
+    if (id != SMART_ESCORT_LAST_OOC_POINT)
+        GetScript()->ProcessEventsFor(SMART_EVENT_WAYPOINT_REACHED, NULL, id);
+
+    mLastWPIDReached = id;
+    mWPReached = true;
+}
+
+void SmartAI::MovementInform(uint32 MovementType, uint32 Data)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_MOVEMENTINFORM, NULL, MovementType, Data);
+    if (MovementType != POINT_MOTION_TYPE || !HasEscortState(SMART_ESCORT_ESCORTING))
+        return;
+    MovepointReached(Data);
+}
+
+void SmartAI::EnterEvadeMode()
+{
+    if (!me->isAlive())
+        return;
+
+    me->RemoveAllAuras();
+    me->DeleteThreatList();
+    me->CombatStop(true);
+    me->LoadCreaturesAddon();
+    me->SetLootRecipient(NULL);
+    me->ResetPlayerDamageReq();
+
+    GetScript()->ProcessEventsFor(SMART_EVENT_EVADE);//must be after aura clear so we can cast spells from db
+
+    SetRun(mRun);
+    if (HasEscortState(SMART_ESCORT_ESCORTING))
+    {
+        AddEscortState(SMART_ESCORT_RETURNING);
+        ReturnToLastOOCPos();
+    } else if (mFollowGuid){
+        if (Unit* target = me->GetUnit(*me, mFollowGuid))
+            me->GetMotionMaster()->MoveFollow(target, mFollowDist, mFollowAngle);
+    } else {
+        me->GetMotionMaster()->MoveTargetedHome();
+    }
+
+    Reset(); 
+}
+
+void SmartAI::MoveInLineOfSight(Unit* who)
+{
+    if (!who) return;
+    GetScript()->OnMoveInLineOfSight(who);
+    //HasEscortState(SMART_ESCORT_ESCORTING) ||
+    if (me->HasReactState(REACT_PASSIVE) || AssistPlayerInCombat(who))
+        return;
+
+    if (!CanAIAttack(who))
+        return;
+
+    if (me->IsHostileTo(who))
+    {
+        float fAttackRadius = me->GetAttackDistance(who);
+        if (me->IsWithinDistInMap(who, fAttackRadius) && me->IsWithinLOSInMap(who))
+        {
+            if (!me->getVictim())
+            {
+                who->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+                AttackStart(who);
+            }
+            else/* if (me->GetMap()->IsDungeon())*/
+            {
+                who->SetInCombatWith(me);
+                me->AddThreat(who, 0.0f);
+            }
+        }
+    }
+
+    //if (me->canStartAttack(who, false))
+    //    AttackStart(who);
+}
+
+bool SmartAI::CanAIAttack(const Unit* who) const
+{
+    if (me->GetReactState() == REACT_PASSIVE)
+        return false;
+    return true;
+}
+
+bool SmartAI::AssistPlayerInCombat(Unit* pWho)
+{
+    if (!pWho || !pWho->getVictim())
+        return false;
+
+    //experimental (unknown) flag not present
+    if (!(me->GetCreatureInfo()->type_flags & CREATURE_TYPEFLAGS_AID_PLAYERS))
+        return false;
+
+    //not a player
+    if (!pWho->getVictim()->GetCharmerOrOwnerPlayerOrPlayerItself())
+        return false;
+
+    //never attack friendly
+    if (me->IsFriendlyTo(pWho))
+        return false;
+
+    //too far away and no free sight?
+    if (me->IsWithinDistInMap(pWho, SMART_MAX_AID_DIST) && me->IsWithinLOSInMap(pWho))
+    {
+        //already fighting someone?
+        if (!me->getVictim())
+        {
+            AttackStart(pWho);
+            return true;
+        }
+        else
+        {
+            pWho->SetInCombatWith(me);
+            me->AddThreat(pWho, 0.0f);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void SmartAI::JustRespawned()
+{
+    mDespawnTime = 0;
+    mDespawnState = 0;
+    mEscortState = SMART_ESCORT_NONE;
+    me->SetVisibility(VISIBILITY_ON);
+    if (me->getFaction() != me->GetCreatureInfo()->faction_A)
+        me->RestoreFaction();
+    GetScript()->ProcessEventsFor(SMART_EVENT_RESPAWN);
+    Reset();
+    mFollowGuid = 0;//do not reset follower on Reset(), we need it after combat evade
+    mFollowDist = 0;
+    mFollowAngle = 0;
+    mFollowCredit = 0;
+    mFollowArrivedTimer = 1000;
+    mFollowArrivedEntry = 0;
+    mFollowCreditType = 0;
+}
+
+int SmartAI::Permissible(const Creature* creature)
+{
+    if (creature->GetAIName() == "SmartAI")
+        return PERMIT_BASE_SPECIAL;
+    return PERMIT_BASE_NO;
+}
+
+void SmartAI::JustReachedHome()
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_REACHED_HOME);
+}
+
+void SmartAI::EnterCombat(Unit* enemy)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_AGGRO, enemy);
+    me->GetPosition(&mLastOOCPos);
+}
+
+void SmartAI::JustDied(Unit* killer)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_DEATH, killer);
+    if (HasEscortState(SMART_ESCORT_ESCORTING))
+        EndPath(true);
+}
+
+void SmartAI::KilledUnit(Unit* victim)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_KILL, victim);
+}
+
+void SmartAI::JustSummoned(Creature* pUnit)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_SUMMONED_UNIT, pUnit);
+}
+
+void SmartAI::AttackStart(Unit* who)
+{
+    if (who && me->Attack(who, true))
+    {
+        SetRun(mRun);
+        if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+            me->GetMotionMaster()->MovementExpired();
+
+        if (mCanCombatMove)
+            me->GetMotionMaster()->MoveChase(who);
+
+        me->GetPosition(&mLastOOCPos);
+    }
+}
+
+void SmartAI::SpellHit(Unit* pUnit, const SpellEntry* pSpell)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_SPELLHIT, pUnit, 0, 0, false, pSpell);
+}
+
+void SmartAI::SpellHitTarget(Unit* target, const SpellEntry* pSpell)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_SPELLHIT_TARGET, target, 0, 0, false, pSpell);
+}
+
+void SmartAI::DamageTaken(Unit* done_by, uint32& damage, DamageEffectType /*damagetype*/)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_DAMAGED, done_by, damage);
+}
+
+void SmartAI::HealReceived(Unit* done_by, uint32& addhealth)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_RECEIVE_HEAL, done_by, addhealth);
+}
+
+void SmartAI::ReceiveEmote(Player* pPlayer, uint32 text_emote)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_RECEIVE_EMOTE, pPlayer, text_emote);
+}
+
+void SmartAI::IsSummonedBy(Unit* summoner)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_JUST_SUMMONED, summoner);
+}
+
+void SmartAI::DamageDealt(Unit* done_to, uint32& damage)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_DAMAGED_TARGET, done_to, damage);
+}
+
+void SmartAI::SummonedCreatureDespawn(Creature* unit)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_SUMMON_DESPAWNED, unit);
+}
+
+void SmartAI::UpdateAIWhileCharmed(const uint32 diff)
+{
+}
+
+void SmartAI::CorpseRemoved(uint32& respawnDelay)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_CORPSE_REMOVED, NULL, respawnDelay);
+}
+
+void SmartAI::PassengerBoarded(Unit* who, int8 seatId, bool apply)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_PASSENGER_BOARDED, who, (uint32)seatId, 0, apply);
+}
+
+void SmartAI::InitializeAI()
+{
+    GetScript()->OnInitialize(me);
+    if (!me->isDead()) 
+        Reset();
+    GetScript()->ProcessEventsFor(SMART_EVENT_RESPAWN);
+}
+
+void SmartAI::OnCharmed(bool apply)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_CHARMED, NULL, 0, 0, apply);
+}
+
+void SmartAI::DoAction(const int32 param)
+{
+}
+
+uint32 SmartAI::GetData(uint32 id)
+{
+    return 0;
+}
+
+void SmartAI::SetData(uint32 id, uint32 value)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_DATA_SET, NULL, id, value);
+}
+
+void SmartAI::SetGUID(const uint64& guid, int32 id)
+{
+}
+
+uint64 SmartAI::GetGUID(int32 id)
+{
+    return 0;
+}
+
+void SmartAI::SetRun(bool run)
+{
+    if (run)
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
+    else
+        me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
+    mRun = run;
+}
+
+void SmartAI::SetFly(bool bFly)
+{
+    me->SetFlying(bFly);
+}
+
+void SmartAI::SetSwimm(bool bSwimm)
+{
+    if (bSwimm)
+        me->AddUnitMovementFlag(MOVEMENTFLAG_SWIMMING);
+    else
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_SWIMMING);
+}
+
+void SmartAI::sGossipHello(Player* player)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_GOSSIP_HELLO, player);
+}
+
+void SmartAI::sGossipSelect(Player* player, uint32 sender, uint32 action)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_GOSSIP_SELECT, player, sender, action);
+}
+
+void SmartAI::sGossipSelectCode(Player* player, uint32 sender, uint32 action, const char* code)
+{
+}
+
+void SmartAI::sQuestAccept(Player* player, Quest const* quest)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_ACCEPTED_QUEST, player, quest->GetQuestId());
+}
+
+void SmartAI::sQuestReward(Player* player, Quest const* quest, uint32 opt)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_REWARD_QUEST, player, quest->GetQuestId(), opt);
+}
+void SmartAI::SetCombatMove(bool on)
+{
+    if (mCanCombatMove == on)
+        return;
+    mCanCombatMove = on;
+    if (!HasEscortState(SMART_ESCORT_ESCORTING))
+    {
+        if (on && me->getVictim())
+        {
+            if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE)
+            {
+                SetRun(mRun);
+                me->GetMotionMaster()->MoveChase(me->getVictim());
+                me->CastStop();
+            }
+        }
+        else
+        {
+            me->StopMoving();
+            me->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+void SmartAI::SetFollow(Unit* target, float dist, float angle, uint32 credit, uint32 end, uint32 creditType)
+{
+    if (!target)
+        return;
+    SetRun(mRun);
+    mFollowGuid = target->GetGUID();
+    mFollowDist = dist;
+    mFollowAngle = angle;
+    mFollowArrivedTimer = 1000;
+    mFollowCredit = credit;
+    mFollowArrivedEntry = end;
+    me->GetMotionMaster()->MoveFollow(target, dist, angle);
+    mFollowCreditType = creditType;
+}
+/*
+SMART_EVENT_UPDATE_OOC
+SMART_EVENT_SPELLHIT
+SMART_EVENT_RANGE
+SMART_EVENT_RESPAWN
+SMART_EVENT_SUMMONED_UNIT
+SMART_EVENT_ACCEPTED_QUEST
+SMART_EVENT_REWARD_QUEST
+SMART_EVENT_TARGET_BUFFED
+SMART_EVENT_SUMMON_DESPAWNED
+SMART_EVENT_AI_INIT
+SMART_EVENT_DATA_SET
+SMART_EVENT_TEXT_OVER
+SMART_EVENT_TIMED_EVENT_TRIGGERED
+SMART_EVENT_UPDATE
+SMART_EVENT_LINK
+SMART_EVENT_GOSSIP_SELECT
+SMART_EVENT_JUST_CREATED
+SMART_EVENT_GOSSIP_HELLO
+SMART_EVENT_DEATH
+*/
+
+int SmartGameObjectAI::Permissible(const GameObject* g)
+{
+    if (g->GetAIName() == "SmartGameObjectAI")
+        return PERMIT_BASE_SPECIAL;
+    return PERMIT_BASE_NO;
+}
+
+void SmartGameObjectAI::UpdateAI(const uint32 diff)
+{
+    GetScript()->OnUpdate(diff);
+}
+
+void SmartGameObjectAI::InitializeAI()
+{
+    GetScript()->OnInitialize(go);
+    GetScript()->ProcessEventsFor(SMART_EVENT_RESPAWN);
+    //Reset();
+}
+
+void SmartGameObjectAI::Reset()
+{
+    GetScript()->OnReset();
+}
+
+// Called when a player opens a gossip dialog with the gameobject.
+bool SmartGameObjectAI::GossipHello(Player* player) 
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_GOSSIP_HELLO, player, 0 ,0 , false, NULL, go);
+    return false;
+}
+
+// Called when a player selects a gossip item in the gameobject's gossip menu.
+bool SmartGameObjectAI::GossipSelect(Player* player, uint32 sender, uint32 action)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_GOSSIP_SELECT, player, sender, action, false, NULL, go);
+    return false;
+}
+
+// Called when a player selects a gossip with a code in the gameobject's gossip menu.
+bool SmartGameObjectAI::GossipSelectCode(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/, const char* /*code*/)
+{
+    return false;
+}
+
+// Called when a player accepts a quest from the gameobject.
+bool SmartGameObjectAI::QuestAccept(Player* player, Quest const* quest)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_ACCEPTED_QUEST, player, quest->GetQuestId() ,0 , false, NULL, go);
+    return false;
+}
+
+// Called when a player selects a quest reward.
+bool SmartGameObjectAI::QuestReward(Player* player, Quest const* quest, uint32 opt)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_REWARD_QUEST, player, quest->GetQuestId() ,opt , false, NULL, go);
+    return false;
+}
+
+// Called when the dialog status between a player and the gameobject is requested.
+uint32 SmartGameObjectAI::GetDialogStatus(Player* /*player*/) { return 100; }
+
+// Called when the gameobject is destroyed (destructible buildings only).
+void SmartGameObjectAI::Destroyed(Player* player, uint32 eventId)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_DEATH, player, eventId ,0 , false, NULL, go);
+}
+
+void SmartGameObjectAI::SetData(uint32 id, uint32 value)
+{
+    GetScript()->ProcessEventsFor(SMART_EVENT_DATA_SET, NULL, id, value);
+}
+
+class SmartTrigger : public AreaTriggerScript
+{
+    public:
+
+        SmartTrigger()
+            : AreaTriggerScript("SmartTrigger")
+        {
+        }
+
+        bool OnTrigger(Player* player, AreaTriggerEntry const* trigger)
+        {
+            sLog.outDebug("AreaTrigger %u is using SmartTrigger script", trigger->id);
+            SmartScript script;
+            script.OnInitialize(NULL, trigger);
+            script.ProcessEventsFor(SMART_EVENT_AREATRIGGER_ONTRIGGER, player, trigger->id);
+            return true;
+        }
+};
+
+void AddSC_SmartSCripts()
+{
+    new SmartTrigger();
+}
diff --git a/src/server/game/AI/SmartAI/SmartAI.h b/src/server/game/AI/SmartAI/SmartAI.h
--- a/src/server/game/AI/SmartAI/SmartAI.h
+++ b/src/server/game/AI/SmartAI/SmartAI.h
@@ -1,368 +1,254 @@
-/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef TRINITY_SMARTAI_H
-#define TRINITY_SMARTAI_H
-
-#include "Common.h"
-#include "Creature.h"
-#include "CreatureAI.h"
-#include "Unit.h"
-
-/*
-N O T E S
-
-
-movepoints:
-    create ingame commands
-
-commands:
-    smartai
-    smartai movepoints
-    smartai movepoints start (id)
-    smartai movepoints add
-    smartai movepoints end
-    smartai movepoints show (id)
-    smartai reload
-    smartai create [reload creature]
-
-
-void passenger removed
-void setcanrun
-void setcanfly
-void setcanswim
-void setinhabittype
-
-event change flags
-
-need a local SendChat()
-
-*/
-
-//temp copied from eai, will be modded
-enum SMARTAI_EVENT
-{
-    SMART_EVENT_TIMER_IC                = 0,                    // InitialMin, InitialMax, RepeatMin, RepeatMax
-    SMART_EVENT_TIMER_OOC               = 1,                    // InitialMin, InitialMax, RepeatMin, RepeatMax
-    SMART_EVENT_HP                      = 2,                    // HPMax%, HPMin%, RepeatMin, RepeatMax
-    SMART_EVENT_MANA                    = 3,                    // ManaMax%,ManaMin% RepeatMin, RepeatMax
-    SMART_EVENT_AGGRO                   = 4,                    // NONE
-    SMART_EVENT_KILL                    = 5,                    // RepeatMin, RepeatMax
-    SMART_EVENT_DEATH                   = 6,                    // NONE
-    SMART_EVENT_EVADE                   = 7,                    // NONE
-    SMART_EVENT_SPELLHIT                = 8,                    // SpellID, School, RepeatMin, RepeatMax
-    SMART_EVENT_RANGE                   = 9,                    // MinDist, MaxDist, RepeatMin, RepeatMax
-    SMART_EVENT_OOC_LOS                 = 10,                   // NoHostile, MaxRnage, RepeatMin, RepeatMax
-    SMART_EVENT_SPAWNED                 = 11,                   // Condition, CondValue1
-    SMART_EVENT_TARGET_HP               = 12,                   // HPMax%, HPMin%, RepeatMin, RepeatMax
-    SMART_EVENT_TARGET_CASTING          = 13,                   // RepeatMin, RepeatMax
-    SMART_EVENT_FRIENDLY_HP             = 14,                   // HPDeficit, Radius, RepeatMin, RepeatMax
-    SMART_EVENT_FRIENDLY_IS_CC          = 15,                   // DispelType, Radius, RepeatMin, RepeatMax
-    SMART_EVENT_FRIENDLY_MISSING_BUFF   = 16,                   // SpellId, Radius, RepeatMin, RepeatMax
-    SMART_EVENT_SUMMONED_UNIT           = 17,                   // CreatureId, RepeatMin, RepeatMax
-    SMART_EVENT_TARGET_MANA             = 18,                   // ManaMax%, ManaMin%, RepeatMin, RepeatMax
-    SMART_EVENT_QUEST_ACCEPT            = 19,                   // QuestID
-    SMART_EVENT_QUEST_COMPLETE          = 20,                   //
-    SMART_EVENT_REACHED_HOME            = 21,                   // NONE
-    SMART_EVENT_RECEIVE_EMOTE           = 22,                   // EmoteId, Condition, CondValue1, CondValue2
-    SMART_EVENT_BUFFED                  = 23,                   // Param1 = SpellID, Param2 = Number of Time STacked, Param3/4 Repeat Min/Max
-    SMART_EVENT_TARGET_BUFFED           = 24,                   // Param1 = SpellID, Param2 = Number of Time STacked, Param3/4 Repeat Min/Max
-    SMART_EVENT_RESET                   = 35,                   // Is it called after combat, when the creature respawn and spawn. -- TRINITY ONLY
-
-    SMART_EVENT_END                     = 36,
-};
-
-//temp copied from eai, will be modded
-enum SMARTAI_ACTION
-{
-    SMART_ACTION_NONE                       = 0,                // No action
-    SMART_ACTION_TEXT                       = 1,                // TextId1, optionally -TextId2, optionally -TextId3(if -TextId2 exist). If more than just -TextId1 is defined, randomize. Negative values.
-    SMART_ACTION_SET_FACTION                = 2,                // FactionId (or 0 for default)
-    SMART_ACTION_MORPH_TO_ENTRY_OR_MODEL    = 3,                // Creature_template entry(param1) OR ModelId (param2) (or 0 for both to demorph)
-    SMART_ACTION_SOUND                      = 4,                // SoundId
-    SMART_ACTION_EMOTE                      = 5,                // EmoteId
-    SMART_ACTION_RANDOM_SAY                 = 6,                // UNUSED
-    SMART_ACTION_RANDOM_YELL                = 7,                // UNUSED
-    SMART_ACTION_RANDOM_TEXTEMOTE           = 8,                // UNUSED
-    SMART_ACTION_RANDOM_SOUND               = 9,                // SoundId1, SoundId2, SoundId3 (-1 in any field means no output if randomed that field)
-    SMART_ACTION_RANDOM_EMOTE               = 10,               // EmoteId1, EmoteId2, EmoteId3 (-1 in any field means no output if randomed that field)
-    SMART_ACTION_CAST                       = 11,               // SpellId, Target, CastFlags
-    SMART_ACTION_SUMMON                     = 12,               // CreatureID, Target, Duration in ms
-    SMART_ACTION_THREAT_SINGLE_PCT          = 13,               // Threat%, Target
-    SMART_ACTION_THREAT_ALL_PCT             = 14,               // Threat%
-    SMART_ACTION_QUEST_EVENT                = 15,               // QuestID, Target
-    SMART_ACTION_CAST_EVENT                 = 16,               // QuestID, SpellId, Target - must be removed as hack?
-    SMART_ACTION_SET_UNIT_FIELD             = 17,               // Field_Number, Value, Target
-    SMART_ACTION_SET_UNIT_FLAG              = 18,               // Flags (may be more than one field OR'd together), Target
-    SMART_ACTION_REMOVE_UNIT_FLAG           = 19,               // Flags (may be more than one field OR'd together), Target
-    SMART_ACTION_AUTO_ATTACK                = 20,               // AllowAttackState (0 = stop attack, anything else means continue attacking)
-    SMART_ACTION_COMBAT_MOVEMENT            = 21,               // AllowCombatMovement (0 = stop combat based movement, anything else continue attacking)
-    SMART_ACTION_SET_PHASE                  = 22,               // Phase
-    SMART_ACTION_INC_PHASE                  = 23,               // Value (may be negative to decrement phase, should not be 0)
-    SMART_ACTION_EVADE                      = 24,               // No Params
-    SMART_ACTION_FLEE_FOR_ASSIST            = 25,               // No Params
-    SMART_ACTION_QUEST_EVENT_ALL            = 26,               // QuestID
-    SMART_ACTION_CAST_EVENT_ALL             = 27,               // CreatureId, SpellId
-    SMART_ACTION_REMOVEAURASFROMSPELL       = 28,               // Target, Spellid
-    SMART_ACTION_RANGED_MOVEMENT            = 29,               // Distance, Angle
-    SMART_ACTION_RANDOM_PHASE               = 30,               // PhaseId1, PhaseId2, PhaseId3
-    SMART_ACTION_RANDOM_PHASE_RANGE         = 31,               // PhaseMin, PhaseMax
-    SMART_ACTION_SUMMON_ID                  = 32,               // CreatureId, Target, SpawnId
-    SMART_ACTION_KILLED_MONSTER             = 33,               // CreatureId, Target
-    SMART_ACTION_SET_INST_DATA              = 34,               // Field, Data
-    SMART_ACTION_SET_INST_DATA64            = 35,               // Field, Target
-    SMART_ACTION_UPDATE_TEMPLATE            = 36,               // Entry, Team
-    SMART_ACTION_DIE                        = 37,               // No Params
-    SMART_ACTION_ZONE_COMBAT_PULSE          = 38,               // No Params
-    SMART_ACTION_CALL_FOR_HELP              = 39,               // Radius
-    SMART_ACTION_SET_SHEATH                 = 40,               // Sheath (0-passive,1-melee,2-ranged)
-    SMART_ACTION_FORCE_DESPAWN              = 41,               // No Params
-    SMART_ACTION_SET_INVINCIBILITY_HP_LEVEL = 42,               // MinHpValue, format(0-flat,1-percent from max health)
-    SMART_ACTION_MOUNT_TO_ENTRY_OR_MODEL    = 43,               // Creature_template entry(param1) OR ModelId (param2) (or 0 for both to unmount)
-
-    SMART_ACTION_SET_PHASE_MASK             = 97,
-    SMART_ACTION_SET_STAND_STATE            = 98,
-    SMART_ACTION_MOVE_RANDOM_POINT          = 99,
-    SMART_ACTION_SET_VISIBILITY             = 100,
-    SMART_ACTION_SET_ACTIVE                 = 101,  //Apply
-    SMART_ACTION_SET_AGGRESSIVE             = 102,  //Apply
-    SMART_ACTION_ATTACK_START_PULSE         = 103,  //Distance
-    SMART_ACTION_SUMMON_GO                  = 104,  //GameObjectID, DespawnTime in ms
-
-    SMART_ACTION_END                        = 105,
-};
-
-//temp copied from eai, will be modded
-enum SMARTAI_TARGETS
-{
-    SMART_TARGET_SELF                           = 0,    //Self cast
-
-    //Hostile targets (if pet then returns pet owner)
-    SMART_TARGET_VICTIM                         = 1,    //Our current target (ie: highest aggro)
-    SMART_TARGET_HOSTILE_SECOND_AGGRO           = 2,    //Second highest aggro (generaly used for cleaves and some special attacks)
-    SMART_TARGET_HOSTILE_LAST_AGGRO             = 3,    //Dead last on aggro (no idea what this could be used for)
-    SMART_TARGET_HOSTILE_RANDOM                 = 4,    //Just any random target on our threat list
-    SMART_TARGET_HOSTILE_RANDOM_NOT_TOP         = 5,    //Any random target except top threat
-
-    //Invoker targets (if pet then returns pet owner)
-    SMART_TARGET_ACTION_INVOKER                 = 6,    //Unit who caused this Event to occur (only works for EVENT_T_AGGRO, EVENT_T_KILL, EVENT_T_DEATH, EVENT_T_SPELLHIT, EVENT_T_OOC_LOS, EVENT_T_FRIENDLY_HP, EVENT_T_FRIENDLY_IS_CC, EVENT_T_FRIENDLY_MISSING_BUFF)
-
-    //Hostile targets (including pets)
-    SMART_TARGET_HOSTILE_WPET                   = 7,    //Current target (can be a pet)
-    SMART_TARGET_HOSTILE_WPET_SECOND_AGGRO      = 8,    //Second highest aggro (generaly used for cleaves and some special attacks)
-    SMART_TARGET_HOSTILE_WPET_LAST_AGGRO        = 9,    //Dead last on aggro (no idea what this could be used for)
-    SMART_TARGET_HOSTILE_WPET_RANDOM            = 10,   //Just any random target on our threat list
-    SMART_TARGET_HOSTILE_WPET_RANDOM_NOT_TOP    = 11,   //Any random target except top threat
-
-    SMART_TARGET_ACTION_INVOKER_WPET            = 12,
-
-    SMART_TARGET_END                            = 13,
-};
-
-#define SMARTAI_EVENT_PARAM_COUNT 6
-#define SMARTAI_ACTION_PARAM_COUNT 6
-
-struct MovePoint
-{
-    MovePoint(uint32 _id, float _x, float _y, float _z)
-    {
-        id = _id;
-        x = _x;
-        y = _y;
-        z = _z;
-    }
-
-    uint32 id;
-    float x;
-    float y;
-    float z;
-};
-
-// one line in DB is one event
-struct SMARTAI_EVENT_HOLDER
-{
-    uint32 event_id;
-    SMARTAI_EVENT event_type;
-    uint32 event_phase_mask;
-    uint32 event_chance;
-    uint32 event_flags;
-    int32 event_param[SMARTAI_EVENT_PARAM_COUNT];
-
-    SMARTAI_ACTION action_type;
-    int32 action_param[SMARTAI_ACTION_PARAM_COUNT];
-
-    float param_x;
-    float param_y;
-    float param_z;
-    float param_o;
-};
-
-// all events for a single entry
-typedef std::vector<SMARTAI_EVENT_HOLDER> SmartAIEventList;
-
-// all events for all entries
-typedef UNORDERED_MAP<int32, SmartAIEventList> SmartAIEventMap;
-
-class SmartAIMgr
-{
-    SmartAIMgr(){};
-    public:
-        ~SmartAIMgr(){};
-
-        void LoadSmartAIFromDB();
-
-        // only use this after EntryExists() check
-        SmartAIEventList const& GetEventList(int32 entry) const
-        {
-            SmartAIEventMap::const_iterator sList = m_EventMap.find(entry);
-            return (*sList).second;
-        }
-        SmartAIEventMap const& GetEventMap() const { return m_EventMap; }
-
-        // do we have entry's eventList from DB?
-        bool EntryExists(int32 entry)
-        {
-            SmartAIEventMap::const_iterator sList = m_EventMap.find(entry);
-            if (sList != m_EventMap.end())
-                return true;
-            return false;
-        }
-
-    private:
-        SmartAIEventMap m_EventMap;
-};
-
-class SmartAI : public CreatureAI
-{
-    public:
-        ~SmartAI(){};
-        explicit SmartAI(Creature *c);
-
-        // Called when creature is spawned or respawned
-        void JustRespawned();
-
-        // Called after InitializeAI(), EnterEvadeMode() for resetting variables
-        void Reset();
-
-        // Called at reaching home after evade
-        void JustReachedHome();
-
-        // Called for reaction at enter to combat if not in combat yet (enemy can be NULL)
-        void EnterCombat(Unit *enemy);
-
-        // Called for reaction at stopping attack at no attackers or targets
-        void EnterEvadeMode();
-
-        // Called when the creature is killed
-        void JustDied(Unit* killer);
-
-        // Called when the creature kills a unit
-        void KilledUnit(Unit* victim);
-
-        // Called when the creature summon successfully other creature
-        void JustSummoned(Creature* pUnit);
-
-        // Tell creature to attack and follow the victim
-        void AttackStart(Unit *who);
-
-        // Called if IsVisible(Unit *who) is true at each *who move, reaction at visibility zone enter
-        void MoveInLineOfSight(Unit *who);
-
-        // Called when hit by a spell
-        void SpellHit(Unit* pUnit, const SpellEntry* pSpell);
-
-        // Called when spell hits a target
-        void SpellHitTarget(Unit* target, const SpellEntry*);
-
-        // Called at any Damage from any attacker (before damage apply)
-        void DamageTaken(Unit* done_by, uint32& damage, DamageEffectType damagetype);
-
-        // Called when the creature receives heal
-        void HealReceived(Unit* done_by, uint32& addhealth);
-
-        // Called at World update tick
-        void UpdateAI(const uint32 diff);
-
-        // Called at text emote receive from player
-        void ReceiveEmote(Player* pPlayer, uint32 text_emote);
-
-        // Called at waypoint reached or point movement finished
-        void MovementInform(uint32 MovementType, uint32 Data);
-
-        // Called when creature is summoned by another unit
-        void IsSummonedBy(Unit* summoner);
-
-        // Called at any Damage to any victim (before damage apply)
-        void DamageDealt(Unit * done_to, uint32 & damage);
-
-        // Called when a summoned creature dissapears (UnSommoned)
-        void SummonedCreatureDespawn(Creature* unit);
-
-        // called when the corpse of this creature gets removed
-        void CorpseRemoved(uint32 & respawnDelay);
-
-        // Called at World update tick if creature is charmed
-        void UpdateAIWhileCharmed(const uint32 diff);
-
-        // Called when a Player/Creature enters the creature (vehicle)
-        void PassengerBoarded(Unit* who, int8 seatId, bool apply);
-
-        // Called when gets initialized, when creature is added to world
-        void InitializeAI();
-
-        // Called when creature gets charmed by another unit
-        void OnCharmed(bool apply);
-
-        // Called when victim is in line of sight
-        bool CanAIAttack(const Unit* who) const;
-
-        // Used in scripts to share variables
-        void DoAction(const int32 param = 0);
-
-        // Used in scripts to share variables
-        uint32 GetData(uint32 id = 0);
-
-        // Used in scripts to share variables
-        void SetData(uint32 id, uint32 value);
-
-        // Used in scripts to share variables
-        void SetGUID(const uint64 &guid, int32 id = 0);
-
-        // Used in scripts to share variables
-        uint64 GetGUID(int32 id = 0);
-
-        //core related
-        static int Permissible(const Creature *);
-
-        // Called at movepoint reached
-        void MovepointReached(uint32 id);
-
-        // Start moving to the desired MovePoint
-        void MovepointStart(uint32 id);
-
-        // Makes the creature run/walk
-        void SetRun(bool bRun = true);
-
-        // Sets the action that will be called when creature reaches the last movepoint
-        void SetMovePathEndAction(SMARTAI_ACTION action = SMART_ACTION_FORCE_DESPAWN);
-
-    private:
-};
-
-#define sSmartAIMgr (*ACE_Singleton<SmartAIMgr, ACE_Null_Mutex>::instance())
-#endif
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITY_SMARTAI_H
+#define TRINITY_SMARTAI_H
+
+#include "Common.h"
+#include "Creature.h"
+#include "CreatureAI.h"
+#include "Unit.h"
+#include "ConditionMgr.h"
+#include "CreatureTextMgr.h"
+#include "Spell.h"
+
+#include "SmartScript.h"
+#include "SmartScriptMgr.h"
+#include "GameObjectAI.h"
+
+enum SmartEscortState
+{
+    SMART_ESCORT_NONE       = 0x000,                        //nothing in progress
+    SMART_ESCORT_ESCORTING  = 0x001,                        //escort is in progress
+    SMART_ESCORT_RETURNING  = 0x002,                        //escort is returning after being in combat
+    SMART_ESCORT_PAUSED     = 0x004                         //will not proceed with waypoints before state is removed
+};
+
+enum SmartEscortVars
+{
+    SMART_ESCORT_MAX_PLAYER_DIST        = 50,
+    SMART_MAX_AID_DIST    = SMART_ESCORT_MAX_PLAYER_DIST / 2,
+};
+
+class SmartAI : public CreatureAI
+{
+    public:
+        ~SmartAI(){};
+        explicit SmartAI(Creature *c);
+
+        // Start moving to the desired MovePoint
+        void StartPath(bool run = false, uint32 path = 0, bool repeat = false, Unit* invoker = NULL);
+        bool LoadPath(uint32 entry);
+        void PausePath(uint32 delay, bool forced = false);
+        void StopPath(uint32 DespawnTime = 0, uint32 quest = 0, bool fail = false);
+        void EndPath(bool fail = false);
+        void ResumePath();
+        WayPoint* GetNextWayPoint();
+        bool HasEscortState(uint32 uiEscortState) { return (mEscortState & uiEscortState); }
+        void AddEscortState(uint32 uiEscortState) { mEscortState |= uiEscortState; }
+        void RemoveEscortState(uint32 uiEscortState) { mEscortState &= ~uiEscortState; }
+        void SetAutoAttack(bool on) { mCanAutoAttack = on; }
+        void SetCombatMove(bool on);
+        void SetFollow(Unit* target, float dist = 0.0f, float angle = 0.0f, uint32 credit = 0, uint32 end = 0, uint32 creditType = 0);
+
+        SmartScript* GetScript() { return &mScript; }
+        bool IsEscortInvokerInRange();
+
+        // Called when creature is spawned or respawned
+        void JustRespawned();
+
+        // Called after InitializeAI(), EnterEvadeMode() for resetting variables
+        void Reset();
+
+        // Called at reaching home after evade
+        void JustReachedHome();
+
+        // Called for reaction at enter to combat if not in combat yet (enemy can be NULL)
+        void EnterCombat(Unit *enemy);
+
+        // Called for reaction at stopping attack at no attackers or targets
+        void EnterEvadeMode();
+
+        // Called when the creature is killed
+        void JustDied(Unit* killer);
+
+        // Called when the creature kills a unit
+        void KilledUnit(Unit* victim);
+
+        // Called when the creature summon successfully other creature
+        void JustSummoned(Creature* pUnit);
+
+        // Tell creature to attack and follow the victim
+        void AttackStart(Unit *who);
+
+        // Called if IsVisible(Unit *who) is true at each *who move, reaction at visibility zone enter
+        void MoveInLineOfSight(Unit *who);
+
+        // Called when hit by a spell
+        void SpellHit(Unit* pUnit, const SpellEntry* pSpell);
+
+        // Called when spell hits a target
+        void SpellHitTarget(Unit* target, const SpellEntry* pSpell);
+
+        // Called at any Damage from any attacker (before damage apply)
+        void DamageTaken(Unit* done_by, uint32& damage, DamageEffectType damagetype);
+
+        // Called when the creature receives heal
+        void HealReceived(Unit* done_by, uint32& addhealth);
+
+        // Called at World update tick
+        void UpdateAI(const uint32 diff);
+
+        // Called at text emote receive from player
+        void ReceiveEmote(Player* pPlayer, uint32 text_emote);
+
+        // Called at waypoint reached or point movement finished
+        void MovementInform(uint32 MovementType, uint32 Data);
+
+        // Called when creature is summoned by another unit
+        void IsSummonedBy(Unit* summoner);
+
+        // Called at any Damage to any victim (before damage apply)
+        void DamageDealt(Unit * done_to, uint32 & damage);
+
+        // Called when a summoned creature dissapears (UnSommoned)
+        void SummonedCreatureDespawn(Creature* unit);
+
+        // called when the corpse of this creature gets removed
+        void CorpseRemoved(uint32 & respawnDelay);
+
+        // Called at World update tick if creature is charmed
+        void UpdateAIWhileCharmed(const uint32 diff);
+
+        // Called when a Player/Creature enters the creature (vehicle)
+        void PassengerBoarded(Unit* who, int8 seatId, bool apply);
+
+        // Called when gets initialized, when creature is added to world
+        void InitializeAI();
+
+        // Called when creature gets charmed by another unit
+        void OnCharmed(bool apply);
+
+        // Called when victim is in line of sight
+        bool CanAIAttack(const Unit* who) const;
+
+        // Used in scripts to share variables
+        void DoAction(const int32 param = 0);
+
+        // Used in scripts to share variables
+        uint32 GetData(uint32 id = 0);
+
+        // Used in scripts to share variables
+        void SetData(uint32 id, uint32 value);
+
+        // Used in scripts to share variables
+        void SetGUID(const uint64 &guid, int32 id = 0);
+
+        // Used in scripts to share variables
+        uint64 GetGUID(int32 id = 0);
+
+        //core related
+        static int Permissible(const Creature *);
+
+        // Called at movepoint reached
+        void MovepointReached(uint32 id);
+
+        // Makes the creature run/walk
+        void SetRun(bool bRun = true);
+
+        void SetFly(bool bFly = true);
+
+        void SetSwimm(bool bSwimm = true);
+
+        void sGossipHello(Player* player);
+        void sGossipSelect(Player* player, uint32 sender, uint32 action);
+        void sGossipSelectCode(Player* player, uint32 sender, uint32 action, const char* code);
+        void sQuestAccept(Player* player, Quest const* quest);
+        //void sQuestSelect(Player* player, Quest const* quest);
+        //void sQuestComplete(Player* player, Quest const* quest);
+        void sQuestReward(Player* player, Quest const* quest, uint32 opt);
+
+        uint32 mEscortQuestID;
+
+        void SetDespawnTime (uint32 t)
+        {
+            mDespawnTime = t;
+            mDespawnState = t ? 1 : 0;
+        }
+        void StartDespawn() { mDespawnState = 2; }
+
+    private:
+        uint32 mFollowCreditType;
+        uint32 mFollowArrivedTimer;
+        uint32 mFollowCredit;
+        uint32 mFollowArrivedEntry;
+        uint64 mFollowGuid;
+        float mFollowDist;
+        float mFollowAngle;
+
+        void ReturnToLastOOCPos();
+        void UpdatePath(const uint32 diff);
+        SmartScript mScript;
+        WPPath* mWayPoints;
+        uint32 mEscortState;
+        uint32 mCurrentWPID;
+        uint32 mLastWPIDReached;
+        bool mWPReached;
+        uint32 mWPPauseTimer;
+        WayPoint* mLastWP;
+        Position mLastOOCPos;//set on enter combat
+        uint32 GetWPCount() { return mWayPoints ? mWayPoints->size() : 0; }
+        bool mCanRepeatPath;
+        bool mRun;
+        bool mCanAutoAttack;
+        bool mCanCombatMove;
+        bool mForcedPaused;
+
+        bool AssistPlayerInCombat(Unit* pWho);
+
+        uint32 mDespawnTime;
+        uint32 mDespawnState;
+        void UpdateDespawn(const uint32 diff);
+        uint32 mEscortInvokerCheckTimer;
+};
+
+class SmartGameObjectAI : public GameObjectAI
+{
+public:
+    SmartGameObjectAI(GameObject *g) : go(g), GameObjectAI(g) {}
+    ~SmartGameObjectAI() {}
+
+    void UpdateAI(const uint32 diff);
+    void InitializeAI();
+    void Reset();
+    SmartScript* GetScript() { return &mScript; }
+    static int Permissible(const GameObject* g);
+
+    bool GossipHello(Player* player) ;
+    bool GossipSelect(Player* player, uint32 sender, uint32 action);
+    bool GossipSelectCode(Player* /*player*/, uint32 /*sender*/, uint32 /*action*/, const char* /*code*/);
+    bool QuestAccept(Player* player, Quest const* quest);
+    bool QuestReward(Player* player, Quest const* quest, uint32 opt);
+    uint32 GetDialogStatus(Player* /*player*/);
+    void Destroyed(Player* player, uint32 eventId);
+    void SetData(uint32 id, uint32 value);
+
+protected:
+    GameObject * const go;
+    SmartScript mScript;
+};
+#endif
diff --git a/src/server/game/AI/SmartAI/SmartScript.cpp b/src/server/game/AI/SmartAI/SmartScript.cpp
new file mode 100644
--- /dev/null
+++ b/src/server/game/AI/SmartAI/SmartScript.cpp
@@ -0,0 +1,1950 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "DatabaseEnv.h"
+#include "SQLStorage.h"
+#include "ObjectMgr.h"
+#include "ProgressBar.h"
+#include "ObjectDefines.h"
+#include "GridDefines.h"
+#include "GridNotifiers.h"
+#include "SpellMgr.h"
+#include "GridNotifiersImpl.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "InstanceScript.h"
+#include "ScriptedCreature.h"
+#include "GossipDef.h"
+#include "ScriptedCreature.h"
+#include "SmartScript.h"
+#include "SmartAI.h"
+
+SmartScript::SmartScript()
+{
+    go = NULL;
+    me = NULL;
+    mEventPhase = 0;
+    mInvinceabilityHpLevel = 0;
+    mPathId = 0;
+    mTargetStorage = new ObjectListMap();
+    mStoredEvents.clear();
+    mTextTimer = 0;
+    mLastTextID = 0;
+    mTextGUID = 0;
+    mUseTextTimer = false;
+    mTemplate = SMARTAI_TEMPLATE_BASIC;
+    meOrigGUID = 0;
+    goOrigGUID = 0;
+}
+
+void SmartScript::OnReset()
+{
+    SetPhase(0);
+    ResetBaseObject();
+    for (SmartAIEventList::iterator i = mEvents.begin(); i != mEvents.end(); ++i)
+    {
+        if ((*i).GetEventType() == SMART_EVENT_UPDATE_OOC || (*i).GetEventType() == SMART_EVENT_UPDATE)
+            RecalcTimer((*i), (*i).event.minMaxRepeat.min, (*i).event.minMaxRepeat.max);
+        (*i).runOnce = false;
+    }
+    ProcessEventsFor(SMART_EVENT_RESET);
+}
+
+void SmartScript::ProcessEventsFor(SMART_EVENT e, Unit* unit, uint32 var0, uint32 var1, bool bvar, const SpellEntry* spell, GameObject* gob)
+{
+    for (SmartAIEventList::iterator i = mEvents.begin(); i != mEvents.end(); ++i)
+    {
+        if ((*i).GetEventType() == SMART_EVENT_LINK)//special handling
+            continue;
+        if ((*i).GetEventType() == e/* && (!(*i).event.event_phase_mask || IsInPhase((*i).event.event_phase_mask)) && !((*i).event.event_flags & SMART_EVENT_FLAG_NOT_REPEATABLE && (*i).runOnce)*/)
+            ProcessEvent(*i, unit, var0, var1, bvar, spell, gob);
+    }
+}
+
+void SmartScript::ProcessAction(SmartScriptHolder &e, Unit* unit, uint32 var0, uint32 var1, bool bvar, const SpellEntry* spell, GameObject* gob)
+{
+    //calc random
+    if (e.GetEventType() != SMART_EVENT_LINK && e.event.event_chance < 100 && e.event.event_chance)
+    {
+        uint32 rnd = urand(0, 100);
+        if (e.event.event_chance <= rnd)
+            return;
+    }
+    e.runOnce = true;//used for repeat check
+
+    if (e.link && e.link != e.event_id)
+    {
+        SmartScriptHolder linked = FindLinkedEvent(e.link);
+        if (linked.GetActionType() && linked.GetEventType() == SMART_EVENT_LINK)
+        {
+            ProcessEvent(linked, unit, var0, var1, bvar, spell, gob);
+        }else{
+            sLog.outErrorDb("SmartScript::ProcessAction: Entry %d SourceType %u, Event %u, Link Event %u not found or invalid, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.link);
+        }
+    }
+
+    switch (e.GetActionType())
+    {
+        case SMART_ACTION_TALK:
+            if (!me) return;
+            mLastTextID = e.action.talk.textGroupID1;
+            mTextTimer = sCreatureTextMgr.SendChat(me, uint8(e.action.talk.textGroupID1), IsPlayer(unit)? unit->GetGUID() : NULL);
+            mTextGUID = IsPlayer(unit)? unit->GetGUID() : NULL;
+            if (e.action.talk.textGroupID2) mTextIDs.push_back(e.action.talk.textGroupID2);
+            if (e.action.talk.textGroupID3) mTextIDs.push_back(e.action.talk.textGroupID3);
+            if (e.action.talk.textGroupID4) mTextIDs.push_back(e.action.talk.textGroupID4);
+            if (e.action.talk.textGroupID5) mTextIDs.push_back(e.action.talk.textGroupID5);
+            if (e.action.talk.textGroupID6) mTextIDs.push_back(e.action.talk.textGroupID6);
+            if (!mTextIDs.empty())
+                mUseTextTimer = true;
+            break;
+        case SMART_ACTION_PLAY_EMOTE:
+            if (me)
+                me->HandleEmoteCommand(e.action.emote.emote);
+            break;
+        case SMART_ACTION_SOUND:
+            if (me)
+                sCreatureTextMgr.SendSound(me, e.action.sound.sound, CHAT_TYPE_SAY, 0, TextRange(e.action.sound.range), Team(NULL), false);
+            break;
+        case SMART_ACTION_SET_FACTION:
+        {
+            if (!me) return;
+            if (e.action.faction.factionID)
+                me->setFaction(e.action.faction.factionID);
+            else
+            {
+                if (CreatureInfo const* ci = GetCreatureTemplateStore(me->GetEntry()))
+                {
+                    if (me->getFaction() != ci->faction_A)
+                        me->setFaction(ci->faction_A);
+                }
+            }
+            break;
+        }
+        case SMART_ACTION_MORPH_TO_ENTRY_OR_MODEL:
+        {
+            if (!me) return;
+            if (e.action.morphOrMount.creature || e.action.morphOrMount.model)
+            {
+                //set model based on entry from creature_template
+                if (e.action.morphOrMount.creature)
+                {
+                    if (CreatureInfo const* ci = GetCreatureTemplateStore(e.action.morphOrMount.creature))
+                    {
+                        uint32 display_id = sObjectMgr.ChooseDisplayId(0, ci);
+                        me->SetDisplayId(display_id);
+                    }
+                }
+                //if no param1, then use value from param2 (modelId)
+                else
+                    me->SetDisplayId(e.action.morphOrMount.model);
+            }
+            else
+                me->DeMorph();
+            break;
+        }
+        case SMART_ACTION_FAIL_QUEST:
+        {
+            if (!unit || !unit->ToPlayer()) return;//return if no player
+            unit->ToPlayer()->FailQuest(e.action.quest.quest);
+            break;
+        }
+        case SMART_ACTION_ADD_QUEST:
+        {
+            if (!unit || !unit->ToPlayer()) return;//return if no player
+            if (const Quest* q = sObjectMgr.GetQuestTemplate(e.action.quest.quest))
+                unit->ToPlayer()->AddQuest(q, NULL);
+            break;
+        }
+        case SMART_ACTION_SET_REACT_STATE:
+        {
+            if (!me) return;
+            me->SetReactState(ReactStates(e.action.react.state));
+            break;
+        }
+        case SMART_ACTION_RANDOM_EMOTE:
+            {
+                if (!me) return;
+                uint32 emotes[SMART_ACTION_PARAM_COUNT];
+                emotes[0] = e.action.randomEmote.emote1;
+                emotes[1] = e.action.randomEmote.emote2;
+                emotes[2] = e.action.randomEmote.emote3;
+                emotes[3] = e.action.randomEmote.emote4;
+                emotes[4] = e.action.randomEmote.emote5;
+                emotes[5] = e.action.randomEmote.emote6;
+                uint32 temp[SMART_ACTION_PARAM_COUNT];
+                uint32 count = 0;
+                for (uint8 i = 0; i < SMART_ACTION_PARAM_COUNT; i++)
+                {
+                    if (emotes[i])
+                    {
+                        temp[count] = emotes[i];
+                        count++;
+                    }
+                }
+                me->HandleEmoteCommand(temp[urand(0, count)]);
+                break;
+            }
+        case SMART_ACTION_THREAT_ALL_PCT:
+        {
+            if (!me) return;
+            std::list<HostileReference*>& threatList = me->getThreatManager().getThreatList();
+            for (std::list<HostileReference*>::iterator i = threatList.begin(); i != threatList.end(); ++i)
+                if (Unit* Temp = Unit::GetUnit(*me,(*i)->getUnitGuid()))
+                    me->getThreatManager().modifyThreatPercent(Temp, e.action.threatPCT.threatINC ? (int32)e.action.threatPCT.threatINC : -(int32)e.action.threatPCT.threatDEC);
+            break;
+        }
+        case SMART_ACTION_THREAT_SINGLE_PCT:
+        {
+            if (!me) return;
+            ObjectList* targets = GetTargets(e, unit);
+            if (!targets) return;
+            for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                if (IsUnit((*itr)))
+                    me->getThreatManager().modifyThreatPercent((*itr)->ToUnit(), e.action.threatPCT.threatINC ? (int32)e.action.threatPCT.threatINC : -(int32)e.action.threatPCT.threatDEC);
+            break;
+        }
+        case SMART_ACTION_CALL_AREAEXPLOREDOREVENTHAPPENS:
+            {
+                //if (!me) return;
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    if (IsPlayer((*itr)))
+                        (*itr)->ToPlayer()->AreaExploredOrEventHappens(e.action.quest.quest);
+                break;
+            }
+        case SMART_ACTION_SEND_CASTCREATUREORGO:
+            {
+                if (!me) return;
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    if (IsPlayer((*itr)))
+                        (*itr)->ToPlayer()->CastedCreatureOrGO(e.action.castedCreatureOrGO.creature, me->GetGUID(), e.action.castedCreatureOrGO.spell);
+                break;
+            }
+        case SMART_ACTION_CAST:
+            {
+                if (!me) return;
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    if (IsUnit((*itr)))
+                    {
+                        if (e.action.cast.flags & SMARTCAST_INTERRUPT_PREVIOUS)
+                            me->InterruptNonMeleeSpells(false);
+                        me->CastSpell((*itr)->ToUnit(), e.action.cast.spell,(e.action.cast.flags & SMARTCAST_TRIGGERED) ? true : false);
+                    }
+                break;
+            }
+        case SMART_ACTION_ADD_AURA:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    if (IsUnit((*itr)))
+                    {
+                        (*itr)->ToUnit()->AddAura(e.action.cast.spell, (*itr)->ToUnit());
+                    }
+                break;
+            }
+        case SMART_ACTION_ACTIVATE_GOBJECT:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    if (IsGameObject((*itr)))
+                    {
+                        // Activate
+                        (*itr)->ToGameObject()->SetLootState(GO_READY);
+                        (*itr)->ToGameObject()->UseDoorOrButton();
+                    }
+                break;
+            }
+        case SMART_ACTION_RESET_GOBJECT:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    if (IsGameObject((*itr)))
+                        (*itr)->ToGameObject()->ResetDoorOrButton();
+                break;
+            }
+        case SMART_ACTION_SET_EMOTE_STATE:
+            {
+                if (!me) return;
+                me->SetUInt32Value(UNIT_NPC_EMOTESTATE, e.action.emote.emote);
+                break;
+            }
+        case SMART_ACTION_SET_UNIT_FLAG:
+            {
+                if (!me) return;
+                me->SetFlag(UNIT_FIELD_FLAGS, e.action.unitFlag.flag);
+                break;
+            }
+        case SMART_ACTION_REMOVE_UNIT_FLAG:
+            {
+                if (!me) return;
+                me->RemoveFlag(UNIT_FIELD_FLAGS, e.action.unitFlag.flag);
+                break;
+            }
+        case SMART_ACTION_AUTO_ATTACK:
+            {
+                if (!IsSmart()) return;
+                CAST_AI(SmartAI, me->AI())->SetAutoAttack(e.action.autoAttack.attack ? true : false);
+                break;
+            }
+        case SMART_ACTION_ALLOW_COMBAT_MOVEMENT:
+            {
+                if (!IsSmart()) return;
+                bool move = e.action.combatMove.move ? true : false;
+                CAST_AI(SmartAI, me->AI())->SetCombatMove(move);
+                break;
+            }
+        case SMART_ACTION_SET_EVENT_PHASE:
+            {
+                SetPhase(e.action.setEventPhase.phase);
+                break;
+            }
+        case SMART_ACTION_INC_EVENT_PHASE:
+            {
+                IncPhase(e.action.incEventPhase.inc);
+                DecPhase(e.action.incEventPhase.dec);
+                break;
+            }
+        case SMART_ACTION_EVADE:
+            {
+                if (me) me->AI()->EnterEvadeMode();
+                return;
+            }
+        case SMART_ACTION_FLEE_FOR_ASSIST:
+            {
+                if (me) me->DoFleeToGetAssistance();
+                break;
+            }
+        case SMART_ACTION_CALL_GROUPEVENTHAPPENS:
+            {
+                if (IsPlayer(unit) && GetBaseObject())
+                    unit->ToPlayer()->GroupEventHappens(e.action.quest.quest, GetBaseObject());
+                break;
+            }
+        case SMART_ACTION_CALL_CASTEDCREATUREORGO:
+            {
+                if (!me) return;
+                std::list<HostileReference*>& threatList = me->getThreatManager().getThreatList();
+                for (std::list<HostileReference*>::iterator i = threatList.begin(); i != threatList.end(); ++i)
+                    if (Unit* Temp = Unit::GetUnit(*me,(*i)->getUnitGuid()))
+                        if (IsPlayer(Temp))
+                            Temp->ToPlayer()->CastedCreatureOrGO(e.action.castedCreatureOrGO.creature, me->GetGUID(), e.action.castedCreatureOrGO.spell);
+                break;
+            }
+        case SMART_ACTION_REMOVEAURASFROMSPELL:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(!IsUnit((*itr))) continue;
+                    (*itr)->ToUnit()->RemoveAurasDueToSpell(e.action.removeAura.spell);
+                }
+                break;
+            }
+        case SMART_ACTION_FOLLOW:
+            {
+                if (!IsSmart()) return;
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if (IsUnit((*itr)))
+                    {
+                        CAST_AI(SmartAI, me->AI())->SetFollow((*itr)->ToUnit(), (float)e.action.follow.dist, (float)e.action.follow.angle, e.action.follow.credit, e.action.follow.entry, e.action.follow.creditType);
+                        return;
+                    }
+                }
+                break;
+            }
+        case SMART_ACTION_RANDOM_PHASE:
+            {
+                uint32 phases[SMART_ACTION_PARAM_COUNT];
+                phases[0] = e.action.randomEmote.emote1;
+                phases[1] = e.action.randomEmote.emote2;
+                phases[2] = e.action.randomEmote.emote3;
+                phases[3] = e.action.randomEmote.emote4;
+                phases[4] = e.action.randomEmote.emote5;
+                phases[5] = e.action.randomEmote.emote6;
+                uint32 temp[SMART_ACTION_PARAM_COUNT];
+                uint32 count = 0;
+                for (uint8 i = 0; i < SMART_ACTION_PARAM_COUNT; i++)
+                {
+                    if (phases[i] > 0)
+                    {
+                        temp[count] = phases[i];
+                        count++;
+                    }
+                }
+                SetPhase(temp[urand(0, count)]);
+                break;
+            }
+        case SMART_ACTION_RANDOM_PHASE_RANGE:
+            {
+                SetPhase(urand(e.action.randomPhaseRange.phaseMin, e.action.randomPhaseRange.phaseMax));
+                break;
+            }
+        case SMART_ACTION_CALL_KILLEDMONSTER:
+            {
+                Player* pPlayer = NULL;
+                if (me)
+                    pPlayer = me->GetLootRecipient();
+                if (me && pPlayer)
+                    pPlayer->RewardPlayerAndGroupAtEvent(e.action.killedMonster.creature, pPlayer);
+                else if (GetBaseObject())
+                {
+                    ObjectList* targets = GetTargets(e, unit);
+                    if (!targets) return;
+                    for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    {
+                        if(!IsPlayer((*itr))) continue;
+                        (*itr)->ToPlayer()->RewardPlayerAndGroupAtEvent(e.action.killedMonster.creature, (*itr)->ToPlayer());
+                    }
+                }else if (trigger && IsPlayer(unit))
+                {
+                    unit->ToPlayer()->RewardPlayerAndGroupAtEvent(e.action.killedMonster.creature, unit);
+                }
+                break;
+            }
+        case SMART_ACTION_SET_INST_DATA:
+            {
+                WorldObject* obj = GetBaseObject();
+                if (!obj)
+                    obj = unit;
+                if (obj) return;
+                InstanceScript* pInst = (InstanceScript*)obj->GetInstanceScript();
+                if (!pInst)
+                {
+                    sLog.outErrorDb("SmartScript: Event %u attempt to set instance data without instance script. EntryOrGuid %d", e.GetEventType(), e.entryOrGuid);
+                    return;
+                }
+                pInst->SetData(e.action.setInstanceData.field, e.action.setInstanceData.data);
+                break;
+            }
+        case SMART_ACTION_SET_INST_DATA64:
+            {
+                WorldObject* obj = GetBaseObject();
+                if (!obj)
+                    obj = unit;
+                if (obj) return;
+                InstanceScript* pInst = (InstanceScript*)obj->GetInstanceScript();
+                if (!pInst)
+                {
+                    sLog.outErrorDb("SmartScript: Event %u attempt to set instance data without instance script. EntryOrGuid %d", e.GetEventType(), e.entryOrGuid);
+                    return;
+                }
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    pInst->SetData64(e.action.setInstanceData64.field, (*itr)->GetGUID());
+                    return;
+                }
+               
+                break;
+            }
+        case SMART_ACTION_UPDATE_TEMPLATE:
+            {
+                if (!me || me->GetEntry() == e.action.updateTemplate.creature)
+                    return;
+                me->UpdateEntry(e.action.updateTemplate.creature, e.action.updateTemplate.team ? HORDE : ALLIANCE);
+                break;
+            }
+        case SMART_ACTION_DIE:
+            {
+                if (me && !me->isDead())
+                    me->Kill(me);
+                break;
+            }
+        case SMART_ACTION_SET_IN_COMBAT_WITH_ZONE:
+            {
+                if (me)
+                    me->SetInCombatWithZone();
+                break;
+            }
+        case SMART_ACTION_CALL_FOR_HELP:
+            {
+                if (me)
+                    me->CallForHelp((float)e.action.callHelp.range);
+                break;
+            }
+        case SMART_ACTION_SET_SHEATH:
+            {
+                if (me)
+                    me->SetSheath(SheathState(e.action.setSheath.sheath));
+                break;
+            }
+        case SMART_ACTION_FORCE_DESPAWN:
+            {
+                if (!IsSmart()) return;
+                CAST_AI(SmartAI, me->AI())->SetDespawnTime(e.action.forceDespawn.delay + 1);//next tick
+                CAST_AI(SmartAI, me->AI())->StartDespawn();
+                break;
+            }
+        case SMART_ACTION_SET_INGAME_PHASE_MASK:
+            {
+                if (GetBaseObject())
+                    GetBaseObject()->SetPhaseMask(e.action.ingamePhaseMask.mask, true);
+                break;
+            }
+        case SMART_ACTION_MOUNT_TO_ENTRY_OR_MODEL:
+            {
+                if (!me) return;
+                if (e.action.morphOrMount.creature || e.action.morphOrMount.model)
+                {
+                    if (e.action.morphOrMount.creature > 0)
+                    {
+                        if (CreatureInfo const* cInfo = GetCreatureTemplateStore(e.action.morphOrMount.creature))
+                        {
+                            uint32 display_id = sObjectMgr.ChooseDisplayId(0, cInfo);
+                            me->Mount(display_id);
+                        }
+                    }
+                    else
+                        me->Mount(e.action.morphOrMount.model);
+                }
+                else
+                    me->Unmount();
+                break;
+            }
+        case SMART_ACTION_SET_INVINCIBILITY_HP_LEVEL:
+            {
+                if (!GetBaseObject()) return;
+                if (e.action.invincHP.minHP)
+                    mInvinceabilityHpLevel = me->CountPctFromMaxHealth(e.action.invincHP.minHP);
+                else
+                    mInvinceabilityHpLevel = e.action.invincHP.minHP;
+                break;
+            }
+        case SMART_ACTION_SET_DATA:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if (IsCreature((*itr)))
+                        (*itr)->ToCreature()->AI()->SetData(e.action.setData.field, e.action.setData.data);
+                    if (IsGameObject((*itr)))
+                        (*itr)->ToGameObject()->AI()->SetData(e.action.setData.field, e.action.setData.data);
+                    return;
+                }
+                break;
+            }
+        case SMART_ACTION_MOVE_FORWARD:
+            {
+                if (!me) return;
+                float x,y,z;
+                me->GetClosePoint(x, y, z, me->GetObjectSize() / 3, (float)e.action.moveRandom.distance);
+                me->GetMotionMaster()->MovePoint(SMART_RANDOM_POINT,x,y,z);
+                break;
+            }
+        case SMART_ACTION_SET_VISIBILITY:
+            {
+                if (me)
+                    me->SetVisibility(e.action.visibility.state ? VISIBILITY_ON : VISIBILITY_OFF);
+                break;
+            }
+        case SMART_ACTION_SET_ACTIVE:
+            {
+                if (GetBaseObject())
+                    GetBaseObject()->setActive(true);
+                break;
+            }
+        case SMART_ACTION_ATTACK_START:
+            {
+                if (!me) return;
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if (IsUnit((*itr)))
+                        me->AI()->AttackStart((*itr)->ToUnit());
+                    return;
+                }
+                break;
+            }
+        case SMART_ACTION_SUMMON_CREATURE:
+            {
+                WorldObject* obj = GetBaseObject();
+                if (!obj)
+                    obj = unit;
+                float x,y,z,o;;
+                ObjectList* targets = GetTargets(e, unit);
+                if (targets)
+                {
+                    for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    {
+                        if(!IsUnit((*itr))) continue;
+                        (*itr)->GetPosition(x,y,z,o);
+                        if (Creature* summon = GetBaseObject()->SummonCreature(e.action.summonCreature.creature, x, y, z, o, (TempSummonType)e.action.summonCreature.type, e.action.summonCreature.duration))
+                        {
+                            if (unit && e.action.summonCreature.attackInvoker)
+                            {
+                                summon->AI()->AttackStart((*itr)->ToUnit());
+                            }
+                        }
+                    }
+                }
+                if (e.GetTargetType() != SMART_TARGET_POSITION)
+                    return;
+                if (Creature* summon = GetBaseObject()->SummonCreature(e.action.summonCreature.creature, e.target.x, e.target.y, e.target.z, e.target.o, (TempSummonType)e.action.summonCreature.type, e.action.summonCreature.duration))
+                {
+                    if (unit && e.action.summonCreature.attackInvoker)
+                        summon->AI()->AttackStart(unit);
+                }
+                break;
+            }
+        case SMART_ACTION_SUMMON_GO:
+            {
+                if (!GetBaseObject()) return;
+                float x,y,z,o;
+                ObjectList* targets = GetTargets(e, unit);
+                if (targets)
+                {
+                    for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                    {
+                        if(!IsUnit((*itr))) continue;
+                        (*itr)->GetPosition(x,y,z,o);
+                        GetBaseObject()->SummonGameObject(e.action.summonGO.entry, x, y, z, o, 0, 0, 0, 0, e.action.summonGO.despawnTime);
+                    }
+                }
+                if (e.GetTargetType() != SMART_TARGET_POSITION)
+                    return;
+                GetBaseObject()->SummonGameObject(e.action.summonGO.entry, e.target.x, e.target.y, e.target.z, e.target.o, 0, 0, 0, 0, e.action.summonGO.despawnTime);
+                break;
+            }
+        case SMART_ACTION_KILL_UNIT:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(!IsUnit((*itr))) continue;
+                    (*itr)->ToUnit()->Kill((*itr)->ToUnit());
+                }
+                break;
+            }
+        case SMART_ACTION_INSTALL_AI_TEMPLATE:
+            {
+                InstallTemplate(e);
+                break;
+            }
+        case SMART_ACTION_ADD_ITEM:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(!IsPlayer((*itr))) continue;
+                    (*itr)->ToPlayer()->AddItem(e.action.item.entry, e.action.item.count);
+                }
+                break;
+            }
+        case SMART_ACTION_REMOVE_ITEM:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(!IsPlayer((*itr))) continue;
+                    (*itr)->ToPlayer()->DestroyItemCount(e.action.item.entry, e.action.item.count, true);
+                }
+                break;
+            }
+        case SMART_ACTION_STORE_VARIABLE_DECIMAL:
+            {
+                if(mStoredDecimals.find(e.action.storeVar.id) != mStoredDecimals.end())
+                    mStoredDecimals.erase(e.action.storeVar.id);
+                mStoredDecimals[e.action.storeVar.id] = e.action.storeVar.number;
+                break;
+            }
+        case SMART_ACTION_STORE_TARGET_LIST:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                StoreTargetList(targets, e.action.storeTargets.id);
+                break;
+            }
+        case SMART_ACTION_TELEPORT:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                uint32 map = e.action.teleport.mapID;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(!IsPlayer((*itr))) continue;
+                    (*itr)->ToPlayer()->TeleportTo(e.action.teleport.mapID, e.target.x, e.target.y, e.target.z, e.target.o);
+                }
+                break;
+            }
+        case SMART_ACTION_SET_FLY:
+            {
+                if (!IsSmart()) return;
+                CAST_AI(SmartAI, me->AI())->SetFly(e.action.setFly.fly ? true : false);
+                break;
+            }
+        case SMART_ACTION_SET_RUN:
+            {
+                if (!IsSmart()) return;
+                CAST_AI(SmartAI, me->AI())->SetRun(e.action.setRun.run ? true : false);
+                break;
+            }
+       
+        case SMART_ACTION_SET_SWIMM:
+            {
+                if (!IsSmart()) return;
+                CAST_AI(SmartAI, me->AI())->SetSwimm(e.action.setSwimm.swimm ? true : false);
+                break;
+            }
+        case SMART_ACTION_WP_LOAD:
+            {
+                if (!me) return;
+                uint32 entry = e.action.wpLoad.id;
+                break;
+            }
+        case SMART_ACTION_WP_START:
+            {
+                if (!IsSmart()) return;
+                bool run = e.action.wpStart.run ? true : false;
+                uint32 entry = e.action.wpStart.pathID;
+                bool repeat = e.action.wpStart.repeat ? true : false;
+                ObjectList* targets = GetTargets(e, unit);
+                StoreTargetList(targets, SMART_ESCORT_TARGETS);
+                me->SetReactState((ReactStates)e.action.wpStart.reactState);
+                CAST_AI(SmartAI, me->AI())->StartPath(run, entry, repeat, unit);
+
+                uint32 quest = e.action.wpStart.quest;
+                uint32 DespawnTime = e.action.wpStart.despawnTime;
+                CAST_AI(SmartAI, me->AI())->mEscortQuestID = quest;
+                CAST_AI(SmartAI, me->AI())->SetDespawnTime(DespawnTime);
+                break;
+            }
+        case SMART_ACTION_WP_PAUSE:
+            {
+                if (!IsSmart()) return;
+                uint32 delay = e.action.wpPause.delay;
+                CAST_AI(SmartAI, me->AI())->PausePath(delay, e.GetEventType() == SMART_EVENT_WAYPOINT_REACHED ? false : true);
+                break;
+            }
+        case SMART_ACTION_WP_STOP:
+            {
+                if (!IsSmart()) return;
+                uint32 DespawnTime = e.action.wpStop.despawnTime;
+                uint32 quest = e.action.wpStop.quest;
+                bool fail = e.action.wpStop.fail ? true : false;
+                CAST_AI(SmartAI, me->AI())->StopPath(DespawnTime, quest, fail);
+                break;
+            }
+        case SMART_ACTION_WP_RESUME:
+            {
+                if (!IsSmart()) return;
+                CAST_AI(SmartAI, me->AI())->ResumePath();
+                break;
+            }
+        case SMART_ACTION_SET_ORIENTATION:
+            {
+                if (!me) return;
+                ObjectList* targets = GetTargets(e, unit);
+                if (e.GetTargetType() == SMART_TARGET_POSITION)
+                    me->SetFacing(e.target.o, NULL);
+                else if (targets && !targets->empty())
+                    me->SetFacing(0, (*targets->begin()));
+                break;
+            }
+        case SMART_ACTION_PLAYMOVIE:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(!IsPlayer((*itr))) continue;
+                    (*itr)->ToPlayer()->SendMovieStart(e.action.movie.entry);
+                }
+
+                break;
+            }
+        case SMART_ACTION_MOVE_TO_POS:
+            {
+                if (!IsSmart()) return;
+                bool run = e.action.setRun.run ? true : false;
+                CAST_AI(SmartAI, me->AI())->SetRun(run);
+                me->GetMotionMaster()->MovePoint(0, e.target.x, e.target.y , e.target.z);
+                break;
+            }
+        case SMART_ACTION_RESPAWN_TARGET:
+        {
+            ObjectList* targets = GetTargets(e, unit);
+            if (!targets) return;
+            for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+            {
+                if(IsCreature((*itr)))
+                    (*itr)->ToCreature()->Respawn();
+                if(IsGameObject((*itr)))
+                    (*itr)->ToGameObject()->Respawn();
+            }
+            break;
+        }
+        case SMART_ACTION_CLOSE_GOSSIP:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(IsPlayer((*itr)))
+                        (*itr)->ToPlayer()->PlayerTalkClass->CloseGossip();
+                }
+                break;
+            }
+        case SMART_ACTION_EQUIP:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if(Creature* npc = (*itr)->ToCreature())
+                    {
+                        if (e.action.equip.entry && !e.action.equip.slot1 && !e.action.equip.slot2 && !e.action.equip.slot3)
+                            npc->LoadEquipment(e.action.equip.entry, true);
+                        else
+                        {
+                            npc->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, e.action.equip.slot1);
+                            npc->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, e.action.equip.slot2);
+                            npc->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, e.action.equip.slot3);
+                        }
+                    }
+                }
+                break;
+            }
+        case SMART_ACTION_CREATE_TIMED_EVENT:
+            {
+                SmartEvent ne;
+                ne.type = (SMART_EVENT)SMART_EVENT_UPDATE;
+                ne.event_chance = e.action.timeEvent.chance;
+                if (!ne.event_chance) ne.event_chance = 100;
+               
+                ne.minMaxRepeat.min = e.action.timeEvent.min;
+                ne.minMaxRepeat.max = e.action.timeEvent.max;
+                ne.minMaxRepeat.repeatMin = e.action.timeEvent.repeatMin;
+                ne.minMaxRepeat.repeatMax = e.action.timeEvent.repeatMax;
+
+                if (!ne.minMaxRepeat.repeatMin && !ne.minMaxRepeat.repeatMax)
+                    ne.event_flags |= SMART_EVENT_FLAG_NOT_REPEATABLE;
+
+                SmartAction ac;
+                ac.type = (SMART_ACTION)SMART_ACTION_TRIGGER_TIMED_EVENT;
+                ac.timeEvent.id = e.action.timeEvent.id;
+
+                SmartScriptHolder ev;
+                ev.event = ne;
+                ev.event_id = e.action.timeEvent.id;
+                ev.target = e.target;
+                ev.action = ac;
+                InitTimer(ev);
+                mStoredEvents.push_back(ev);
+               
+                break;
+            }
+        case SMART_ACTION_TRIGGER_TIMED_EVENT:
+            {
+                ProcessEventsFor((SMART_EVENT)SMART_EVENT_TIMED_EVENT_TRIGGERED, NULL, e.action.timeEvent.id);
+                break;
+            }
+        case SMART_ACTION_REMOVE_TIMED_EVENT:
+            {
+                mRemIDs.push_back(e.action.timeEvent.id);
+                break;
+            }
+        case SMART_ACTION_OVERRIDE_SCRIPT_BASE_OBJECT:
+            {
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if (IsCreature(*itr))
+                    {
+                        if (!meOrigGUID)
+                            meOrigGUID = me?me->GetGUID():0;
+                        if (!goOrigGUID)
+                            goOrigGUID = go?go->GetGUID():0;
+                        go = NULL;
+                        me = (*itr)->ToCreature();
+                        return;
+                    }else if (IsGameObject((*itr)))
+                    {
+                        if (!meOrigGUID)
+                            meOrigGUID = me?me->GetGUID():0;
+                        if (!goOrigGUID)
+                            goOrigGUID = go?go->GetGUID():0;
+                        go = (*itr)->ToGameObject();
+                        me = NULL;
+                        return;
+                    }
+                }
+                break;
+            }
+        case SMART_ACTION_RESET_SCRIPT_BASE_OBJECT:
+            ResetBaseObject();
+            break;
+        case SMART_ACTION_CALL_SCRIPT_RESET:
+            OnReset();
+            break;
+        default:
+            sLog.outErrorDb("SmartScript::ProcessAction: Unhandled Action type %u", e.GetActionType());
+            break;
+    }
+}
+
+void SmartScript::InstallTemplate(SmartScriptHolder e)
+{
+    if (!GetBaseObject())
+        return;
+    if (mTemplate)
+    {
+        sLog.outErrorDb("SmartScript::InstallTemplate: Entry %d SourceType %u AI Template can not be set more then once, skipped.", e.entryOrGuid, e.GetScriptType());
+        return;
+    }
+    mTemplate = (SMARTAI_TEMPLATE)e.action.installTtemplate.id;
+    switch ((SMARTAI_TEMPLATE)e.action.installTtemplate.id)
+    {
+        case SMARTAI_TEMPLATE_CASTER:
+            {
+                AddEvent(SMART_EVENT_UPDATE_IC,0, 0,0,e.action.installTtemplate.param2,e.action.installTtemplate.param3,SMART_ACTION_CAST,e.action.installTtemplate.param1,e.target.raw.param1,0,0,0,0,SMART_TARGET_VICTIM,0,0,0,1);
+                AddEvent(SMART_EVENT_RANGE,0, e.action.installTtemplate.param4,300,0,0,SMART_ACTION_ALLOW_COMBAT_MOVEMENT,1,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,1);
+                AddEvent(SMART_EVENT_RANGE,0, 0,e.action.installTtemplate.param4>10?e.action.installTtemplate.param4-10:0,0,0,SMART_ACTION_ALLOW_COMBAT_MOVEMENT,0,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,1);
+                AddEvent(SMART_EVENT_MANA_PCT,0,e.action.installTtemplate.param5-15>100?100:e.action.installTtemplate.param5+15,100,1000,1000,SMART_ACTION_SET_EVENT_PHASE,1,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,0);
+                AddEvent(SMART_EVENT_MANA_PCT,0,0,e.action.installTtemplate.param5,1000,1000,SMART_ACTION_SET_EVENT_PHASE,0,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,0);
+                AddEvent(SMART_EVENT_MANA_PCT,0,0,e.action.installTtemplate.param5,1000,1000,SMART_ACTION_ALLOW_COMBAT_MOVEMENT,1,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,0);
+                break;
+            }
+        case SMARTAI_TEMPLATE_TURRET:
+            {
+                AddEvent(SMART_EVENT_UPDATE_IC,0, 0,0,e.action.installTtemplate.param2,e.action.installTtemplate.param3,SMART_ACTION_CAST,e.action.installTtemplate.param1,e.target.raw.param1,0,0,0,0,SMART_TARGET_VICTIM,0,0,0,0);
+                AddEvent(SMART_EVENT_JUST_CREATED,0, 0,0,0,0,SMART_ACTION_ALLOW_COMBAT_MOVEMENT,0,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,0);
+                break;
+            }
+        case SMARTAI_TEMPLATE_CAGED_NPC_PART:
+            {
+                if (!me) return;
+                //store cage as id1
+                AddEvent(SMART_EVENT_DATA_SET,0,0,0,0,0,SMART_ACTION_STORE_TARGET_LIST,1,0,0,0,0,0,SMART_TARGET_CLOSEST_GAMEOBJECT,e.action.installTtemplate.param1,10,0,0);
+
+                 //reset(close) cage on hostage(me) respawn
+                AddEvent(SMART_EVENT_UPDATE,SMART_EVENT_FLAG_NOT_REPEATABLE,0,0,0,0,SMART_ACTION_RESET_GOBJECT,0,0,0,0,0,0,SMART_TARGET_GAMEOBJECT_DISTANCE,e.action.installTtemplate.param1,5,0,0);
+               
+                AddEvent(SMART_EVENT_DATA_SET,0,0,0,0,0,SMART_ACTION_SET_RUN,e.action.installTtemplate.param3,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,0);
+                AddEvent(SMART_EVENT_DATA_SET,0,0,0,0,0,SMART_ACTION_SET_EVENT_PHASE,1,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,0);
+
+                AddEvent(SMART_EVENT_UPDATE,SMART_EVENT_FLAG_NOT_REPEATABLE,1000,1000,0,0,SMART_ACTION_MOVE_FORWARD,e.action.installTtemplate.param4,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,1);
+                 //phase 1: give quest credit on movepoint reached
+                AddEvent(SMART_EVENT_MOVEMENTINFORM,0, POINT_MOTION_TYPE,SMART_RANDOM_POINT,0,0,SMART_ACTION_SET_DATA,0,0,0,0,0,0,SMART_TARGET_STORED,1,0,0,1);
+                //phase 1: despawn after time on movepoint reached
+                AddEvent(SMART_EVENT_MOVEMENTINFORM,0, POINT_MOTION_TYPE,SMART_RANDOM_POINT,0,0,SMART_ACTION_FORCE_DESPAWN,e.action.installTtemplate.param2,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,1);
+
+                if (sCreatureTextMgr.TextExist(me->GetEntry(), (uint8)e.action.installTtemplate.param5))
+                    AddEvent(SMART_EVENT_MOVEMENTINFORM,0, POINT_MOTION_TYPE,SMART_RANDOM_POINT,0,0,SMART_ACTION_TALK,e.action.installTtemplate.param5,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,1);
+                break;
+            }
+        case SMARTAI_TEMPLATE_CAGED_GO_PART:
+            {
+                if (!go) return;
+                //store hostage as id1
+                AddEvent(SMART_EVENT_GOSSIP_HELLO,0,0,0,0,0,SMART_ACTION_STORE_TARGET_LIST,1,0,0,0,0,0,SMART_TARGET_CLOSEST_CREATURE,e.action.installTtemplate.param1,10,0,0);
+                //store invoker as id2
+                AddEvent(SMART_EVENT_GOSSIP_HELLO,0,0,0,0,0,SMART_ACTION_STORE_TARGET_LIST,2,0,0,0,0,0,SMART_TARGET_NONE,0,0,0,0);
+                //signal hostage
+                AddEvent(SMART_EVENT_GOSSIP_HELLO,0,0,0,0,0,SMART_ACTION_SET_DATA,0,0,0,0,0,0,SMART_TARGET_STORED,1,0,0,0);
+                //when hostage raeched end point, give credit to invoker
+                if (e.action.installTtemplate.param2)
+                    AddEvent(SMART_EVENT_DATA_SET,0,0,0,0,0,SMART_ACTION_CALL_KILLEDMONSTER,e.action.installTtemplate.param1,0,0,0,0,0,SMART_TARGET_STORED,2,0,0,0);
+                else
+                    AddEvent(SMART_EVENT_GOSSIP_HELLO,0,0,0,0,0,SMART_ACTION_CALL_KILLEDMONSTER,e.action.installTtemplate.param1,0,0,0,0,0,SMART_TARGET_STORED,2,0,0,0);
+                break;
+            }
+        case SMARTAI_TEMPLATE_BASIC:
+        default:
+            return;
+    }
+}
+
+void SmartScript::AddEvent(SMART_EVENT e, uint32 event_flags, uint32 event_param1, uint32 event_param2, uint32 event_param3, uint32 event_param4, SMART_ACTION action, uint32 action_param1, uint32 action_param2, uint32 action_param3, uint32 action_param4, uint32 action_param5, uint32 action_param6, SMARTAI_TARGETS t, uint32 target_param1, uint32 target_param2, uint32 target_param3, uint32 phaseMask)
+{
+    mInstallEvents.push_back(CreateEvent(e, event_flags, event_param1, event_param2, event_param3, event_param4, action, action_param1, action_param2, action_param3, action_param4, action_param5, action_param6, t, target_param1, target_param2, target_param3, phaseMask));
+}
+
+SmartScriptHolder SmartScript::CreateEvent(SMART_EVENT e, uint32 event_flags, uint32 event_param1, uint32 event_param2, uint32 event_param3, uint32 event_param4, SMART_ACTION action, uint32 action_param1, uint32 action_param2, uint32 action_param3, uint32 action_param4, uint32 action_param5, uint32 action_param6, SMARTAI_TARGETS t, uint32 target_param1, uint32 target_param2, uint32 target_param3, uint32 phaseMask)
+{
+    SmartScriptHolder script;
+    script.event.type = e;
+    script.event.raw.param1 = event_param1;
+    script.event.raw.param2 = event_param2;
+    script.event.raw.param3 = event_param3;
+    script.event.raw.param4 = event_param4;
+    script.event.event_phase_mask = phaseMask;
+    script.event.event_flags = event_flags;
+
+    script.action.type = action;
+    script.action.raw.param1 = action_param1;
+    script.action.raw.param2 = action_param2;
+    script.action.raw.param3 = action_param3;
+    script.action.raw.param4 = action_param4;
+    script.action.raw.param5 = action_param5;
+    script.action.raw.param6 = action_param6;
+
+    script.target.type = t;
+    script.target.raw.param1 = target_param1;
+    script.target.raw.param2 = target_param2;
+    script.target.raw.param3 = target_param3;
+
+    script.source_type = SMART_SCRIPT_TYPE_CREATURE;
+    InitTimer(script);
+    return script;
+}
+
+ObjectList* SmartScript::GetTargets(SmartScriptHolder e, Unit* invoker)
+{
+    ObjectList* l = new ObjectList();
+    switch (e.GetTargetType())
+    {
+        case SMART_TARGET_SELF:
+            if (GetBaseObject())
+                l->push_back(GetBaseObject());
+            break;
+        case SMART_TARGET_VICTIM:
+            if (me && me->getVictim())
+                l->push_back(me->getVictim());
+            break;
+        case SMART_TARGET_HOSTILE_SECOND_AGGRO:
+            if (!me) return NULL;
+            if(Unit* u = me->AI()->SelectTarget(SELECT_TARGET_TOPAGGRO, 1))
+                l->push_back(u);
+            break;
+        case SMART_TARGET_HOSTILE_LAST_AGGRO:
+            if (!me) return NULL;
+            if(Unit* u = me->AI()->SelectTarget(SELECT_TARGET_BOTTOMAGGRO, 0))
+                l->push_back(u);
+            break;
+        case SMART_TARGET_HOSTILE_RANDOM:
+            if (!me) return NULL;
+            if(Unit* u = me->AI()->SelectTarget(SELECT_TARGET_RANDOM, 0))
+                l->push_back(u);
+            break;
+        case SMART_TARGET_HOSTILE_RANDOM_NOT_TOP:
+            if (!me) return NULL;
+            if(Unit* u = me->AI()->SelectTarget(SELECT_TARGET_RANDOM, 1))
+                l->push_back(u);
+            break;
+        case SMART_TARGET_NONE:
+        case SMART_TARGET_ACTION_INVOKER:
+            if (invoker)
+            {
+                l->push_back(invoker);
+            }
+            break;
+        case SMART_TARGET_INVOKER_PARTY:
+            if (invoker)
+            {
+                l->push_back(invoker);
+                if (Player* plr = invoker->ToPlayer())
+                {
+                    if (Group *pGroup = plr->GetGroup())
+                    {
+                        for (GroupReference *gr = pGroup->GetFirstMember(); gr != NULL; gr = gr->next())
+                        {
+                            if (Player *pGroupGuy = gr->getSource())
+                                l->push_back(pGroupGuy);
+                        }
+                    }                
+                }
+            }
+            break;
+        case SMART_TARGET_CREATURE_RANGE:
+            {
+                ObjectList* units = GetWorldObjectsInDist((float)e.target.unitRange.maxDist);
+                if (!units) return NULL;
+                for (ObjectList::const_iterator itr = units->begin(); itr != units->end(); itr++)
+                {
+                    if(!IsCreature((*itr)))
+                        continue;
+                    if (me && me == (*itr))
+                        continue;
+                    if (((e.target.unitRange.creature && (*itr)->ToCreature()->GetEntry() == e.target.unitRange.creature) || !e.target.unitRange.creature) && GetBaseObject()->IsInRange((*itr), (float)e.target.unitRange.minDist, (float)e.target.unitRange.maxDist))
+                        l->push_back((*itr));
+                }
+                break;
+            }
+        case SMART_TARGET_CREATURE_DISTANCE:
+            {
+                ObjectList* units = GetWorldObjectsInDist((float)e.target.unitDistance.dist);
+                if (!units) return NULL;
+                for (ObjectList::const_iterator itr = units->begin(); itr != units->end(); itr++)
+                {
+                    if(!IsCreature((*itr)))
+                        continue;
+                    if (me && me == (*itr))
+                        continue;
+                    if ((e.target.unitDistance.creature && (*itr)->ToCreature()->GetEntry() == e.target.unitDistance.creature) || !e.target.unitDistance.creature)
+                    {
+                        l->push_back((*itr));
+                    }
+                }
+                break;
+            }
+        case SMART_TARGET_GAMEOBJECT_DISTANCE:
+            {
+                ObjectList* units = GetWorldObjectsInDist((float)e.target.goDistance.dist);
+                if (!units) return NULL;
+                for (ObjectList::const_iterator itr = units->begin(); itr != units->end(); itr++)
+                {
+                    if(!IsGameObject((*itr)))
+                        continue;
+                    if (go && go == (*itr))
+                        continue;
+                    if ((e.target.goDistance.entry && (*itr)->ToGameObject()->GetEntry() == e.target.goDistance.entry) || !e.target.goDistance.entry)
+                        l->push_back((*itr));
+                }
+                break;
+            }
+        case SMART_TARGET_GAMEOBJECT_RANGE:
+            {
+                ObjectList* units = GetWorldObjectsInDist((float)e.target.goRange.maxDist);
+                if (!units) return NULL;
+                for (ObjectList::const_iterator itr = units->begin(); itr != units->end(); itr++)
+                {
+                    if(!IsGameObject((*itr)))
+                        continue;
+                    if (go && go == (*itr))
+                        continue;
+                    if (((e.target.goRange.entry && IsGameObject((*itr)) && (*itr)->ToGameObject()->GetEntry() == e.target.goRange.entry) || !e.target.goRange.entry) && GetBaseObject()->IsInRange((*itr), (float)e.target.goRange.minDist, (float)e.target.goRange.maxDist))
+                        l->push_back((*itr));
+                }
+                break;
+            }
+        case SMART_TARGET_CREATURE_GUID:
+            {
+                Creature* target = NULL;
+                if (e.target.unitGUID.entry)
+                {
+                    uint64 guid = MAKE_NEW_GUID(e.target.unitGUID.guid, e.target.unitGUID.entry, HIGHGUID_UNIT);
+                    target = HashMapHolder<Creature>::Find(guid);
+                } else
+                {
+                    if (!invoker)
+                    {
+                        sLog.outError("SMART_TARGET_CREATURE_GUID can not be used without invoker and without entry");
+                        return NULL;
+                    }
+                    target = FindCreatureNear(invoker, e.target.unitGUID.guid);
+                }
+                if (target)
+                {
+                    l->push_back(target);
+                }
+                break;
+            }
+        case SMART_TARGET_GAMEOBJECT_GUID:
+            {
+                GameObject* target = NULL;
+                if (e.target.unitGUID.entry)
+                {
+                    uint64 guid = MAKE_NEW_GUID(e.target.goGUID.guid, e.target.goGUID.entry, HIGHGUID_GAMEOBJECT);
+                    target = HashMapHolder<GameObject>::Find(guid);
+                } else
+                {
+                    if (!invoker)
+                    {
+                        sLog.outError("SMART_TARGET_GAMEOBJECT_GUID can not be used without invoker and without entry");
+                        return NULL;
+                    }
+                    target = FindGameObjectNear(invoker, e.target.goGUID.guid);
+                }
+                if (target)
+                {
+                    l->push_back(target);
+                }
+                break;
+            }
+        case SMART_TARGET_PLAYER_RANGE:
+            {
+                ObjectList* units = GetWorldObjectsInDist((float)e.target.playerRange.maxDist);
+                if (!units || !GetBaseObject()) return NULL;
+                for (ObjectList::const_iterator itr = units->begin(); itr != units->end(); itr++)
+                {
+                    if(IsPlayer((*itr)) && GetBaseObject()->IsInRange((*itr), (float)e.target.playerRange.minDist, (float)e.target.playerRange.maxDist))
+                        l->push_back((*itr));
+                }
+                break;
+            }
+        case SMART_TARGET_PLAYER_DISTANCE:
+            {
+                ObjectList* units = GetWorldObjectsInDist((float)e.target.playerDistance.dist);
+                if (!units) return NULL;
+                for (ObjectList::const_iterator itr = units->begin(); itr != units->end(); itr++)
+                {
+                    if(IsPlayer((*itr)))
+                        l->push_back((*itr));
+                }
+                break;
+            }
+        case SMART_TARGET_STORED:
+            {
+                ObjectListMap::iterator itr = mTargetStorage->find(e.target.stored.id);
+                if (itr != mTargetStorage->end())
+                    return itr->second;
+                return l;
+            }
+        case SMART_TARGET_CLOSEST_CREATURE:
+            {
+                Creature* target = GetClosestCreatureWithEntry(GetBaseObject(),e.target.closest.entry, (float)(e.target.closest.dist ? e.target.closest.dist : 100), e.target.closest.dead ? false : true);
+                if (target)
+                    l->push_back(target);
+                break;
+            }
+        case SMART_TARGET_CLOSEST_GAMEOBJECT:
+            {
+                GameObject* target = GetClosestGameObjectWithEntry(GetBaseObject(),e.target.closest.entry, (float)(e.target.closest.dist ? e.target.closest.dist : 100));
+                if (target)
+                    l->push_back(target);
+                break;
+            }
+        case SMART_TARGET_POSITION:
+        default:
+            return NULL;
+    }
+    return l;
+}
+
+ObjectList* SmartScript::GetWorldObjectsInDist(float dist)
+{
+    ObjectList* targets = new ObjectList();
+    WorldObject* obj = GetBaseObject();
+    if (obj)
+    {
+        Trinity::AllWorldObjectsInRange u_check(obj, dist);
+        Trinity::WorldObjectListSearcher<Trinity::AllWorldObjectsInRange> searcher(obj, *targets, u_check);
+        obj->VisitNearbyObject(dist, searcher);
+    }
+    return targets;
+}
+
+void SmartScript::ProcessEvent(SmartScriptHolder &e, Unit* unit, uint32 var0, uint32 var1, bool bvar, const SpellEntry* spell, GameObject* gob)
+{
+    if (!e.active && e.GetEventType() != SMART_EVENT_LINK)
+        return;
+
+    if ((e.event.event_phase_mask && !IsInPhase(e.event.event_phase_mask)) || ((e.event.event_flags & SMART_EVENT_FLAG_NOT_REPEATABLE) && e.runOnce))
+        return;
+   
+    switch (e.GetEventType())
+    {
+        case SMART_EVENT_LINK://special handling
+            ProcessAction(e, unit, var0, var1, bvar, spell, gob);
+            break;
+        //called from Update tick
+        case SMART_EVENT_UPDATE:
+            RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+            ProcessAction(e);
+            break;
+        case SMART_EVENT_UPDATE_OOC:
+            if(me && me->isInCombat())
+                return;
+            RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+            ProcessAction(e);
+            break;
+        case SMART_EVENT_UPDATE_IC:
+            if(!me || !me->isInCombat())
+                return;
+            RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+            ProcessAction(e);
+            break;
+        case SMART_EVENT_HEALT_PCT:
+            {
+                if (!me || !me->isInCombat() || !me->GetMaxHealth())
+                    return;
+                uint32 perc = (uint32)me->GetHealthPct();
+                if (perc > e.event.minMaxRepeat.max || perc < e.event.minMaxRepeat.min)
+                    return;
+                RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+                ProcessAction(e);
+                break;
+            }
+        case SMART_EVENT_TARGET_HEALTH_PCT:
+            {
+                if (!me || !me->isInCombat() || !me->getVictim() || !me->getVictim()->GetMaxHealth())
+                    return;
+                uint32 perc = (uint32)me->getVictim()->GetHealthPct();
+                if (perc > e.event.minMaxRepeat.max || perc < e.event.minMaxRepeat.min)
+                    return;
+                RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+                ProcessAction(e, me->getVictim());
+                break;
+            }
+        case SMART_EVENT_MANA_PCT:
+            {
+                if (!me || !me->isInCombat() || !me->GetMaxPower(POWER_MANA))
+                    return;
+                uint32 perc = uint32(100.0f * me->GetPower(POWER_MANA) / me->GetMaxPower(POWER_MANA));
+                if (perc > e.event.minMaxRepeat.max || perc < e.event.minMaxRepeat.min)
+                    return;
+                RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+                ProcessAction(e);
+                break;
+            }
+        case SMART_EVENT_TARGET_MANA_PCT:
+            {
+                if (!me || !me->isInCombat() || !me->getVictim() || !me->getVictim()->GetMaxPower(POWER_MANA))
+                    return;
+                uint32 perc = uint32(100.0f * me->getVictim()->GetPower(POWER_MANA) / me->getVictim()->GetMaxPower(POWER_MANA));
+                if (perc > e.event.minMaxRepeat.max || perc < e.event.minMaxRepeat.min)
+                    return;
+                RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+                ProcessAction(e, me->getVictim());
+                break;
+            }
+        case SMART_EVENT_RANGE:
+            {
+                if (!GetBaseObject()) return;
+                ObjectList* targets = GetTargets(e, unit);
+                if (!targets) return;
+                for (ObjectList::const_iterator itr = targets->begin(); itr != targets->end(); itr++)
+                {
+                    if (!IsUnit((*itr)))
+                        continue;
+                    if (GetBaseObject()->IsInMap((*itr)))
+                    if (GetBaseObject()->IsInRange((*itr),(float)e.event.minMaxRepeat.min,(float)e.event.minMaxRepeat.max))
+                    {
+                        ProcessAction(e, (*itr)->ToUnit());
+                        RecalcTimer(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax);
+                    }
+                }
+                break;
+            }
+        case SMART_EVENT_TARGET_CASTING:
+            {
+                if (!me || !me->isInCombat() || !me->getVictim() || !me->getVictim()->IsNonMeleeSpellCasted(false, false, true))
+                    return;
+                ProcessAction(e, me->getVictim());
+                RecalcTimer(e, e.event.minMax.repeatMin, e.event.minMax.repeatMax);
+            }
+        case SMART_EVENT_FRIENDLY_HEALTH:
+        {
+            if (!me || !me->isInCombat())
+                return;
+
+            Unit* pUnit = DoSelectLowestHpFriendly((float)e.event.friendlyHealt.radius, e.event.friendlyHealt.hpDeficit);
+            if (!pUnit)
+                return;
+            ProcessAction(e, pUnit);
+            RecalcTimer(e, e.event.friendlyHealt.repeatMin, e.event.friendlyHealt.repeatMax);
+            break;
+        }
+        case SMART_EVENT_FRIENDLY_IS_CC:
+        {
+            if (!me || !me->isInCombat())
+                return;
+
+            std::list<Creature*> pList;
+            DoFindFriendlyCC(pList, (float)e.event.friendlyCC.radius);
+            if (pList.empty())
+                return;
+            ProcessAction(e, *(pList.begin()));
+            RecalcTimer(e, e.event.friendlyCC.repeatMin, e.event.friendlyCC.repeatMax);
+            break;
+        }
+        case SMART_EVENT_FRIENDLY_MISSING_BUFF:
+        {
+            std::list<Creature*> pList;
+            DoFindFriendlyMissingBuff(pList, (float)e.event.missingBuff.radius, e.event.missingBuff.spell);
+
+            if (pList.empty())
+                return;
+            ProcessAction(e, *(pList.begin()));
+            RecalcTimer(e, e.event.missingBuff.repeatMin, e.event.missingBuff.repeatMax);
+            break;
+        }
+        case SMART_EVENT_HAS_AURA:
+        {
+            if (!me) return;
+            uint32 count = me->GetAuraCount(e.event.aura.spell);
+            if (count < e.event.aura.count)
+                return;
+            ProcessAction(e);
+            RecalcTimer(e, e.event.aura.repeatMin, e.event.aura.repeatMax);
+            break;
+        }
+        case SMART_EVENT_TARGET_BUFFED:
+        {
+            if (!me || !me->getVictim()) return;
+            if (!me) return;
+            uint32 count = me->getVictim()->GetAuraCount(e.event.aura.spell);
+            if (count < e.event.aura.count)
+                return;
+            ProcessAction(e);
+            RecalcTimer(e, e.event.aura.repeatMin, e.event.aura.repeatMax);
+            break;
+        }
+        //no params
+        case SMART_EVENT_AGGRO:
+        case SMART_EVENT_DEATH:
+        case SMART_EVENT_EVADE:
+        case SMART_EVENT_REACHED_HOME:
+        case SMART_EVENT_CHARMED:
+        case SMART_EVENT_CHARMED_TARGET:
+        case SMART_EVENT_CORPSE_REMOVED:
+        case SMART_EVENT_AI_INIT:
+        case SMART_EVENT_TRANSPORT_ADDPLAYER:
+        case SMART_EVENT_TRANSPORT_REMOVE_PLAYER:
+        case SMART_EVENT_QUEST_ACCEPTED:
+        case SMART_EVENT_QUEST_OBJ_COPLETETION:
+        case SMART_EVENT_QUEST_COMPLETION:
+        case SMART_EVENT_QUEST_REWARDED:
+        case SMART_EVENT_QUEST_FAIL:
+        case SMART_EVENT_JUST_SUMMONED:
+        case SMART_EVENT_RESET:
+        case SMART_EVENT_JUST_CREATED:
+        case SMART_EVENT_GOSSIP_HELLO:
+        case SMART_EVENT_FOLLOW_COPMLETE:
+            ProcessAction(e, unit, var0, var1, bvar, spell, gob);
+            break;
+        case SMART_EVENT_RECEIVE_EMOTE:
+            if (e.event.emote.emote == var0)
+            {
+                ProcessAction(e, unit);
+                RecalcTimer(e, e.event.emote.cooldownMin, e.event.emote.cooldownMax);
+            }
+            break;
+        case SMART_EVENT_KILL:
+        {
+            if (!me || !unit) return;
+            if (e.event.kill.playerOnly && unit->GetTypeId() != TYPEID_PLAYER)
+                return;
+            if (e.event.kill.creature && unit->GetEntry() != e.event.kill.creature)
+                return;
+            ProcessAction(e, unit);
+            RecalcTimer(e, e.event.kill.cooldownMin, e.event.kill.cooldownMax);
+            break;
+        }
+        case SMART_EVENT_SPELLHIT_TARGET:
+        case SMART_EVENT_SPELLHIT:
+        {
+            if (!spell) return;
+            if (!e.event.spellHit.spell || spell->Id == e.event.spellHit.spell)
+                if (!e.event.spellHit.school || (spell->SchoolMask & e.event.spellHit.school))
+                {
+                    ProcessAction(e, unit, 0, 0, bvar, spell);
+                    RecalcTimer(e, e.event.spellHit.cooldownMin, e.event.spellHit.cooldownMax);
+                }
+            break;
+        }
+        case SMART_EVENT_OOC_LOS:
+        {
+            if (!me || me->isInCombat()) return;
+            //can trigger if closer than fMaxAllowedRange
+            float range = (float)e.event.los.maxDist;
+
+            //if range is ok and we are actually in LOS
+            if (me->IsWithinDistInMap(unit, range) && me->IsWithinLOSInMap(unit))
+            {
+                //if friendly event&&who is not hostile OR hostile event&&who is hostile
+                if ((e.event.los.noHostile && !me->IsHostileTo(unit)) ||
+                    (!e.event.los.noHostile && me->IsHostileTo(unit)))
+                {
+                    ProcessAction(e, unit);
+                    RecalcTimer(e, e.event.los.cooldownMin, e.event.los.cooldownMax);
+                }
+            }
+            break;
+        }
+        case SMART_EVENT_IC_LOS:
+        {
+            if (!me || !me->isInCombat()) return;
+            //can trigger if closer than fMaxAllowedRange
+            float range = (float)e.event.los.maxDist;
+
+            //if range is ok and we are actually in LOS
+            if (me->IsWithinDistInMap(unit, range) && me->IsWithinLOSInMap(unit))
+            {
+                //if friendly event&&who is not hostile OR hostile event&&who is hostile
+                if ((e.event.los.noHostile && !me->IsHostileTo(unit)) ||
+                    (!e.event.los.noHostile && me->IsHostileTo(unit)))
+                {
+                    ProcessAction(e, unit);
+                    RecalcTimer(e, e.event.los.cooldownMin, e.event.los.cooldownMax);
+                }
+            }
+            break;
+        }
+        case SMART_EVENT_RESPAWN:
+        {
+            if (!GetBaseObject()) return;
+            if (e.event.respawn.type == SMART_SCRIPT_RESPAWN_CONDITION_MAP && GetBaseObject()->GetMapId() != e.event.respawn.map)
+                return;
+            if (e.event.respawn.type == SMART_SCRIPT_RESPAWN_CONDITION_AREA && GetBaseObject()->GetZoneId() != e.event.respawn.area)
+                return;
+            ProcessAction(e);
+            break;
+        }
+        case SMART_EVENT_SUMMONED_UNIT:
+        {
+            if (!IsCreature(unit)) return;
+            if (e.event.summoned.creature && unit->GetEntry() != e.event.summoned.creature)
+                return;
+            ProcessAction(e, unit);
+            RecalcTimer(e, e.event.summoned.cooldownMin, e.event.summoned.cooldownMax);
+            break;
+        }
+        case SMART_EVENT_RECEIVE_HEAL:
+        case SMART_EVENT_DAMAGED:
+        case SMART_EVENT_DAMAGED_TARGET:
+        {
+            if (var0 > e.event.minMaxRepeat.max || var0 < e.event.minMaxRepeat.min)
+                return;
+            ProcessAction(e, unit);
+            RecalcTimer(e, e.event.minMaxRepeat.repeatMin,e.event.minMaxRepeat.repeatMax);
+            break;
+        }
+        case SMART_EVENT_MOVEMENTINFORM:
+        {
+            if ((e.event.movementInform.type && var0 != e.event.movementInform.type) || (e.event.movementInform.id && var1 != e.event.movementInform.id))
+                return;
+            ProcessAction(e, unit, var0, var1);
+            break;
+        }
+        case SMART_EVENT_TRANSPORT_RELOCATE:
+        case SMART_EVENT_WAYPOINT_START:
+        {
+            if (e.event.waypoint.pathID && var0 != e.event.waypoint.pathID)
+                return;
+            ProcessAction(e, unit, var0);
+            break;
+        }
+        case SMART_EVENT_WAYPOINT_REACHED:
+        case SMART_EVENT_WAYPOINT_RESUMED:
+        case SMART_EVENT_WAYPOINT_PAUSED:
+        case SMART_EVENT_WAYPOINT_STOPPED:
+        case SMART_EVENT_WAYPOINT_ENDED:
+        {
+            if (!me || (e.event.waypoint.pointID && var0 != e.event.waypoint.pointID) || (e.event.waypoint.pathID && GetPathId() != e.event.waypoint.pathID))
+                return;
+            ProcessAction(e, unit);
+            break;
+        }
+        case SMART_EVENT_SUMMON_DESPAWNED:
+        case SMART_EVENT_INSTANCE_PLAYER_ENTER:
+        {
+            if (e.event.instancePlayerEnter.team && var0 != e.event.instancePlayerEnter.team)
+                return;
+            ProcessAction(e, unit, var0);
+            RecalcTimer(e, e.event.instancePlayerEnter.cooldownMin, e.event.instancePlayerEnter.cooldownMax);
+            break;
+        }
+        case SMART_EVENT_ACCEPTED_QUEST:
+        case SMART_EVENT_REWARD_QUEST:
+        {
+            if (e.event.quest.quest && var0 != e.event.quest.quest)
+                return;
+            ProcessAction(e, unit, var0);
+            break;
+        }
+        case SMART_EVENT_TRANSPORT_ADDCREATURE:
+        {
+            if (e.event.transportAddCreature.creature && var0 != e.event.transportAddCreature.creature)
+                return;
+            ProcessAction(e, unit, var0);
+            break;
+        }
+        case SMART_EVENT_AREATRIGGER_ONTRIGGER:
+        {
+            if (e.event.areatrigger.id && var0 != e.event.areatrigger.id)
+                return;
+            ProcessAction(e, unit, var0);
+            break;
+        }
+        case SMART_EVENT_TEXT_OVER:
+        {
+            if (e.event.textOver.textGroupID && var0 != e.event.textOver.textGroupID)
+                return;
+            ProcessAction(e, unit, var0);
+            break;
+        }
+        case SMART_EVENT_DATA_SET:
+        {
+            if (e.event.dataSet.id != var0 || e.event.dataSet.value != var1)
+                return;
+            ProcessAction(e, unit, var0, var1);
+            RecalcTimer(e, e.event.dataSet.cooldownMin, e.event.dataSet.cooldownMax);
+            break;
+        }
+        case SMART_EVENT_PASSENGER_REMOVED:
+        case SMART_EVENT_PASSENGER_BOARDED:
+        {
+            if (!unit) return;
+            ProcessAction(e, unit);
+            RecalcTimer(e, e.event.minMax.repeatMin, e.event.minMax.repeatMax);
+            break;
+        }
+        case SMART_EVENT_TIMED_EVENT_TRIGGERED:
+            {
+                if (e.event.timedEvent.id == var0)
+                    ProcessAction(e,unit);
+                break;
+            }
+        case SMART_EVENT_GOSSIP_SELECT:
+            {
+                if ((e.event.gossip.sender != var0 || e.event.gossip.action != var1))
+                    return;
+                ProcessAction(e, unit, var0, var1);
+                break;
+            }
+        default:
+            sLog.outErrorDb("SmartScript::ProcessEvent: Unhandled Event type %u", e.GetEventType());
+            break;
+    }
+}
+
+void SmartScript::InitTimer(SmartScriptHolder &e)
+{
+    switch (e.GetEventType())
+    {//set only events which have initial timers
+        case SMART_EVENT_UPDATE:
+        case SMART_EVENT_UPDATE_IC:
+        case SMART_EVENT_UPDATE_OOC:
+        case SMART_EVENT_OOC_LOS:
+        case SMART_EVENT_IC_LOS:
+            RecalcTimer(e, e.event.minMaxRepeat.min, e.event.minMaxRepeat.max);
+            break;
+        default:
+            e.active = true;
+            break;
+    }
+}
+void SmartScript::RecalcTimer(SmartScriptHolder &e, uint32 min, uint32 max)
+{
+    // min/max was checked at loading!
+    e.timer = urand(uint32(min), uint32(max));
+    e.active = e.timer ? false : true;
+}
+
+void SmartScript::UpdateTimer(SmartScriptHolder &e, const uint32 diff)
+{
+    if (e.GetEventType() == SMART_EVENT_LINK)
+        return;
+    if (e.event.event_phase_mask && !IsInPhase(e.event.event_phase_mask))
+        return;
+    if (e.timer < diff)
+    {
+        e.active = true;//activate events with cooldown
+        switch (e.GetEventType())//process ONLY timed events
+        {
+            case SMART_EVENT_UPDATE:
+            case SMART_EVENT_UPDATE_OOC:
+            case SMART_EVENT_UPDATE_IC:
+            case SMART_EVENT_HEALT_PCT:
+            case SMART_EVENT_TARGET_HEALTH_PCT:
+            case SMART_EVENT_MANA_PCT:
+            case SMART_EVENT_TARGET_MANA_PCT:
+            case SMART_EVENT_RANGE:        
+            case SMART_EVENT_TARGET_CASTING:
+            case SMART_EVENT_FRIENDLY_HEALTH:
+            case SMART_EVENT_FRIENDLY_IS_CC:
+            case SMART_EVENT_FRIENDLY_MISSING_BUFF:        
+            case SMART_EVENT_HAS_AURA:
+            case SMART_EVENT_TARGET_BUFFED:
+                ProcessEvent(e);
+                break;
+        }
+    } else e.timer -= diff;
+}
+
+bool SmartScript::CheckTimer(SmartScriptHolder &e)
+{
+    return e.active;
+}
+
+void SmartScript::InstallEvents()
+{
+    if (!mInstallEvents.empty())
+    {
+        for (SmartAIEventList::iterator i = mInstallEvents.begin(); i != mInstallEvents.end(); ++i)
+        {
+            mEvents.push_back((*i));//must be before UpdateTimers
+        }
+        mInstallEvents.clear();
+    }
+}
+
+void SmartScript::OnUpdate(const uint32 diff)
+{
+    if ((mScriptType == SMART_SCRIPT_TYPE_CREATURE || mScriptType == SMART_SCRIPT_TYPE_GAMEOBJECT) && !GetBaseObject())
+        return;
+    InstallEvents();//before UpdateTimers
+
+    for (SmartAIEventList::iterator i = mEvents.begin(); i != mEvents.end(); ++i)
+        UpdateTimer((*i), diff);
+
+    if (!mStoredEvents.empty())
+    {
+        for (SmartAIEventList::iterator i = mStoredEvents.begin(); i != mStoredEvents.end(); ++i)
+        {
+             UpdateTimer((*i), diff);
+        }
+    }
+    if (!mRemIDs.empty())
+    {
+        for (std::list<uint32>::iterator i = mRemIDs.begin(); i != mRemIDs.end(); ++i)
+        {
+             RemoveStoredEvent((*i));
+        }
+    }
+    if (mUseTextTimer && me)
+    {
+        if (mTextTimer < diff)
+        {
+            ProcessEventsFor(SMART_EVENT_TEXT_OVER, NULL, mLastTextID);
+            if (!mTextIDs.empty())
+            {
+                mLastTextID = (*mTextIDs.begin());
+                mTextIDs.erase(mTextIDs.begin());
+                mTextTimer = sCreatureTextMgr.SendChat(me, (uint8)mLastTextID, mTextGUID);
+            }else{
+                mLastTextID = 0;
+                mTextTimer = 0;
+                mUseTextTimer = false;
+            }
+        } else mTextTimer -= diff;
+    }
+}
+
+void SmartScript::FillScript(SmartAIEventList e, WorldObject* obj, AreaTriggerEntry const* at)
+{
+    if (e.empty())
+    {
+        if (obj)
+            sLog.outErrorDb("SmartScript: EventMap for Entry %u is empty but is using SmartScript.", obj->GetEntry());
+        if (at)
+            sLog.outErrorDb("SmartScript: EventMap for AreaTrigger %u is empty but is using SmartScript.", at->id);
+        return;
+    }
+    for (SmartAIEventList::iterator i = e.begin(); i != e.end(); ++i)
+    {
+        #ifndef TRINITY_DEBUG
+            if ((*i).event_flags & EFLAG_DEBUG_ONLY)
+                continue;
+        #endif
+
+        if ((*i).event.event_flags & SMART_EVENT_FLAG_DIFFICULTY_ALL)//if has instance flag add only if in it
+        {
+            if (obj && obj->GetMap()->IsDungeon())
+            {
+                if ((1 << (obj->GetMap()->GetSpawnMode()+1)) & (*i).event.event_flags)
+                {
+                    mEvents.push_back((*i));
+                }
+            }
+            continue;
+        }
+        mEvents.push_back((*i));//NOTE: 'world(0)' events still get processed in ANY instance mode
+    }
+    if (mEvents.empty() && obj)
+        sLog.outErrorDb("SmartScript: Entry %u has events but no events added to list because of instance flags.", obj->GetEntry());
+    if (mEvents.empty() && at)
+        sLog.outErrorDb("SmartScript: AreaTrigger %u has events but no events added to list because of instance flags. NOTE: triggers can not handle any instance flags.", at->id);
+}
+
+void SmartScript::GetScript()
+{
+    SmartAIEventList e;
+    if (me)
+    {
+        e = sSmartScriptMgr.GetScript(-((int32)me->GetDBTableGUIDLow()), mScriptType);
+        if (e.empty())
+            e = sSmartScriptMgr.GetScript((int32)me->GetEntry(), mScriptType);
+        FillScript(e, me, NULL);
+    }
+    else if (go)
+    {
+        e = sSmartScriptMgr.GetScript(-((int32)go->GetDBTableGUIDLow()), mScriptType);
+        if (e.empty())
+            e = sSmartScriptMgr.GetScript((int32)go->GetEntry(), mScriptType);
+        FillScript(e, go, NULL);
+    }
+    else if (trigger)
+    {
+        e = sSmartScriptMgr.GetScript((int32)trigger->id, mScriptType);
+        FillScript(e, NULL, trigger);
+    }
+}
+
+void SmartScript::OnInitialize(WorldObject* obj, AreaTriggerEntry const* at)
+{
+    if (obj)//handle object based scripts
+    {
+        switch (obj->GetTypeId())
+        {
+            case TYPEID_UNIT:
+                mScriptType = SMART_SCRIPT_TYPE_CREATURE;
+                me = obj->ToCreature();
+                sLog.outDebug("SmartScript::OnInitialize: source is Creature %u", me->GetEntry());
+                break;
+            case TYPEID_GAMEOBJECT:
+                mScriptType = SMART_SCRIPT_TYPE_GAMEOBJECT;
+                go = obj->ToGameObject();
+                sLog.outDebug("SmartScript::OnInitialize: source is GameObject %u", go->GetEntry());
+                break;
+            default:
+                sLog.outError("SmartScript::OnInitialize: Unhandled TypeID !WARNING!");
+                return;
+        }
+    } else if (at)
+    {
+        mScriptType = SMART_SCRIPT_TYPE_AREATRIGGER;
+        trigger = at;
+        sLog.outDebug("SmartScript::OnInitialize: source is AreaTrigger %u", trigger->id);
+    }
+    else
+    {
+        sLog.outError("SmartScript::OnInitialize: !WARNING! Initialized objects are NULL.");
+        return;
+    }
+
+    GetScript();//load copy of script
+
+    for (SmartAIEventList::iterator i = mEvents.begin(); i != mEvents.end(); ++i)
+        InitTimer((*i));//calculate timers for first time use
+
+    ProcessEventsFor(SMART_EVENT_AI_INIT);
+    InstallEvents();
+    ProcessEventsFor(SMART_EVENT_JUST_CREATED);
+}
+
+void SmartScript::OnMoveInLineOfSight(Unit* who)
+{
+    ProcessEventsFor(SMART_EVENT_OOC_LOS, who);
+
+    if(!me) return;
+    if (me->getVictim())
+        return;
+
+    ProcessEventsFor(SMART_EVENT_IC_LOS, who);
+   
+}
+
+/*
+void SmartScript::UpdateAIWhileCharmed(const uint32 diff)
+{
+}
+
+
+void SmartScript::DoAction(const int32 param)
+{
+}
+
+uint32 SmartScript::GetData(uint32 id)
+{
+    return 0;
+}
+
+void SmartScript::SetData(uint32 id, uint32 value)
+{
+}
+
+void SmartScript::SetGUID(const uint64& guid, int32 id)
+{
+}
+
+uint64 SmartScript::GetGUID(int32 id)
+{
+    return 0;
+}
+
+void SmartScript::MovepointStart(uint32 id)
+{
+}
+
+void SmartScript::SetRun(bool run)
+{
+}
+
+void SmartScript::SetMovePathEndAction(SMART_ACTION action)
+{
+}
+
+uint32 SmartScript::DoChat(int8 id, uint64 whisperGuid)
+{
+    return 0;
+}*/
+// SmartScript end
+
+
+Unit* SmartScript::DoSelectLowestHpFriendly(float range, uint32 MinHPDiff)
+{
+    if (!me) return NULL;
+    CellPair p(Trinity::ComputeCellPair(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.data.Part.reserved = ALL_DISTRICT;
+    cell.SetNoCreate();
+
+    Unit* pUnit = NULL;
+
+    Trinity::MostHPMissingInRange u_check(me, range, MinHPDiff);
+    Trinity::UnitLastSearcher<Trinity::MostHPMissingInRange> searcher(me, pUnit, u_check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher<Trinity::MostHPMissingInRange>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, range);
+    return pUnit;
+}
+
+void SmartScript::DoFindFriendlyCC(std::list<Creature*>& _list, float range)
+{
+    if (!me) return;
+    CellPair p(Trinity::ComputeCellPair(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.data.Part.reserved = ALL_DISTRICT;
+    cell.SetNoCreate();
+
+    Trinity::FriendlyCCedInRange u_check(me, range);
+    Trinity::CreatureListSearcher<Trinity::FriendlyCCedInRange> searcher(me, _list, u_check);
+
+    TypeContainerVisitor<Trinity::CreatureListSearcher<Trinity::FriendlyCCedInRange>, GridTypeMapContainer >  grid_creature_searcher(searcher);
+
+    cell.Visit(p, grid_creature_searcher, *me->GetMap());
+}
+
+void SmartScript::DoFindFriendlyMissingBuff(std::list<Creature*>& _list, float range, uint32 spellid)
+{
+    if (!me) return;
+    CellPair p(Trinity::ComputeCellPair(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.data.Part.reserved = ALL_DISTRICT;
+    cell.SetNoCreate();
+
+    Trinity::FriendlyMissingBuffInRange u_check(me, range, spellid);
+    Trinity::CreatureListSearcher<Trinity::FriendlyMissingBuffInRange> searcher(me, _list, u_check);
+
+    TypeContainerVisitor<Trinity::CreatureListSearcher<Trinity::FriendlyMissingBuffInRange>, GridTypeMapContainer >  grid_creature_searcher(searcher);
+
+    cell.Visit(p, grid_creature_searcher, *me->GetMap());
+}
+
diff --git a/src/server/game/AI/SmartAI/SmartScript.h b/src/server/game/AI/SmartAI/SmartScript.h
new file mode 100644
--- /dev/null
+++ b/src/server/game/AI/SmartAI/SmartScript.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITY_SMARTSCRIPT_H
+#define TRINITY_SMARTSCRIPT_H
+
+#include "Common.h"
+#include "Creature.h"
+#include "CreatureAI.h"
+#include "Unit.h"
+#include "ConditionMgr.h"
+#include "CreatureTextMgr.h"
+#include "Spell.h"
+#include "GridNotifiers.h"
+
+#include "SmartScriptMgr.h"
+//#include "SmartAI.h"
+
+class SmartScript
+{
+    public:
+        ~SmartScript(){};
+        SmartScript();
+
+        void OnInitialize(WorldObject* obj, AreaTriggerEntry const* at = NULL);
+        void GetScript();
+        void FillScript(SmartAIEventList e, WorldObject* obj, AreaTriggerEntry const* at);
+
+        void ProcessEventsFor(SMART_EVENT e, Unit* unit = NULL, uint32 var0 = 0, uint32 var1 = 0, bool bvar = false, const SpellEntry* spell = NULL, GameObject* gob = NULL);
+        void ProcessEvent(SmartScriptHolder &e, Unit* unit = NULL, uint32 var0 = 0, uint32 var1 = 0, bool bvar = false, const SpellEntry* spell = NULL, GameObject* gob = NULL);
+        bool CheckTimer(SmartScriptHolder &e);
+        void RecalcTimer(SmartScriptHolder &e, uint32 min, uint32 max);
+        void UpdateTimer(SmartScriptHolder &e, const uint32 diff);
+        void InitTimer(SmartScriptHolder &e);
+        void ProcessAction(SmartScriptHolder &e, Unit* unit = NULL, uint32 var0 = 0, uint32 var1 = 0, bool bvar = false, const SpellEntry* spell = NULL, GameObject* gob = NULL);
+        ObjectList* GetTargets(SmartScriptHolder e, Unit* invoker = NULL);
+        ObjectList* GetWorldObjectsInDist(float dist);
+        void InstallTemplate(SmartScriptHolder e);
+        SmartScriptHolder CreateEvent(SMART_EVENT e, uint32 event_flags, uint32 event_param1, uint32 event_param2, uint32 event_param3, uint32 event_param4, SMART_ACTION action, uint32 action_param1, uint32 action_param2, uint32 action_param3, uint32 action_param4, uint32 action_param5, uint32 action_param6, SMARTAI_TARGETS t, uint32 target_param1, uint32 target_param2, uint32 target_param3, uint32 phaseMask = 0);
+        void AddEvent(SMART_EVENT e, uint32 event_flags, uint32 event_param1, uint32 event_param2, uint32 event_param3, uint32 event_param4, SMART_ACTION action, uint32 action_param1, uint32 action_param2, uint32 action_param3, uint32 action_param4, uint32 action_param5, uint32 action_param6, SMARTAI_TARGETS t, uint32 target_param1, uint32 target_param2, uint32 target_param3, uint32 phaseMask = 0);
+        void SetPathId(uint32 id) { mPathId = id; }
+        uint32 GetPathId() { return mPathId; }
+        WorldObject* GetBaseObject()
+        {
+            WorldObject* obj = NULL;
+            if (me)
+                obj = me;
+            else if (go)
+                obj = go;
+            return obj;
+        }
+        bool IsUnit(WorldObject* obj)
+        {
+            return obj && (obj->GetTypeId() == TYPEID_UNIT || obj->GetTypeId() == TYPEID_PLAYER);
+        }
+        bool IsPlayer(WorldObject* obj)
+        {
+            return obj && obj->GetTypeId() == TYPEID_PLAYER;
+        }
+        bool IsCreature(WorldObject* obj)
+        {
+            return obj && obj->GetTypeId() == TYPEID_UNIT;
+        }
+        bool IsGameObject(WorldObject* obj)
+        {
+            return obj && obj->GetTypeId() == TYPEID_GAMEOBJECT;
+        }
+        bool ConditionValid(Unit* u, int32 c, int32 v1, int32 v2, int32 v3)
+        {
+            if (c == 0) return true;
+            if (!u || !u->ToPlayer()) return false;
+            Condition cond;
+            cond.mConditionType = ConditionType(uint32(c));
+            cond.mConditionValue1 = uint32(v1);
+            cond.mConditionValue1 = uint32(v2);
+            cond.mConditionValue1 = uint32(v3);
+            return cond.Meets(u->ToPlayer());
+        }
+
+        void OnUpdate(const uint32 diff);
+        void OnMoveInLineOfSight(Unit *who);
+
+        Unit* DoSelectLowestHpFriendly(float range, uint32 MinHPDiff);
+        void DoFindFriendlyCC(std::list<Creature*>& _list, float range);
+        void DoFindFriendlyMissingBuff(std::list<Creature*>& _list, float range, uint32 spellid);
+
+        void StoreTargetList(ObjectList* targets, uint32 id)
+        {
+            if (!targets) return;
+            if(mTargetStorage->find(id) != mTargetStorage->end())
+                mTargetStorage->erase(id);
+            (*mTargetStorage)[id] = targets;
+        }
+        bool IsSmart(Creature* c = NULL)
+        {
+            if (c && c->GetAIName() != "SmartAI") return false;
+            if (!me || me->GetAIName() != "SmartAI") return false;
+            return true;
+        }
+        ObjectList* GetTargetList(uint32 id)
+        {
+            ObjectListMap::iterator itr = mTargetStorage->find(id);
+            if(itr != mTargetStorage->end())
+                return (*itr).second;
+            return NULL;
+        }
+
+        inline GameObject* FindGameObjectNear(WorldObject* pSearchObject, uint32 guid) const
+        {
+            GameObject *pGameObject = NULL;
+
+            CellPair p(Trinity::ComputeCellPair(pSearchObject->GetPositionX(), pSearchObject->GetPositionY()));
+            Cell cell(p);
+            cell.data.Part.reserved = ALL_DISTRICT;
+
+            Trinity::GameObjectWithDbGUIDCheck goCheck(*pSearchObject, guid);
+            Trinity::GameObjectSearcher<Trinity::GameObjectWithDbGUIDCheck> checker(pSearchObject, pGameObject, goCheck);
+
+            TypeContainerVisitor<Trinity::GameObjectSearcher<Trinity::GameObjectWithDbGUIDCheck>, GridTypeMapContainer > objectChecker(checker);
+            cell.Visit(p, objectChecker, *pSearchObject->GetMap());
+
+            return pGameObject;
+        }
+
+        inline Creature* FindCreatureNear(WorldObject* pSearchObject, uint32 guid) const
+        {
+            Creature *crea = NULL;
+            CellPair p(Trinity::ComputeCellPair(pSearchObject->GetPositionX(), pSearchObject->GetPositionY()));
+            Cell cell(p);
+            cell.data.Part.reserved = ALL_DISTRICT;
+
+            Trinity::CreatureWithDbGUIDCheck target_check(pSearchObject, guid);
+            Trinity::CreatureSearcher<Trinity::CreatureWithDbGUIDCheck> checker(pSearchObject, crea, target_check);
+
+            TypeContainerVisitor<Trinity::CreatureSearcher <Trinity::CreatureWithDbGUIDCheck>, GridTypeMapContainer > unit_checker(checker);
+            cell.Visit(p, unit_checker, *pSearchObject->GetMap());
+
+            return crea;
+        }
+
+        ObjectListMap* mTargetStorage;
+        void ResetTexts() { mTextIDs.clear(); }
+
+        void OnReset();
+        void ResetBaseObject()
+        {
+            if (meOrigGUID)
+            {
+                if (Creature* m = HashMapHolder<Creature>::Find(meOrigGUID))
+                {
+                    me = m;
+                    go = NULL;
+                }
+            }
+            if (goOrigGUID)
+            {
+                if (GameObject* o = HashMapHolder<GameObject>::Find(goOrigGUID))
+                {
+                    me = NULL;
+                    go = o;
+                }
+            }
+            goOrigGUID = 0;
+            meOrigGUID = 0;
+        }
+
+    private:
+        void IncPhase(int32 p = 1) { p >= 0 ? mEventPhase += (uint32)p : DecPhase(abs(p)); }
+        void DecPhase(int32 p = 1) { mEventPhase  -= (mEventPhase < (uint32)p ? (uint32)p - mEventPhase : (uint32)p); }
+        bool IsInPhase(uint32 p) { return mEventPhase & p; }
+        void SetPhase(uint32 p = 0) { mEventPhase = p; }
+
+        SmartAIEventList mEvents;
+        SmartAIEventList mInstallEvents;
+        Creature* me;
+        uint64 meOrigGUID;
+        GameObject* go;
+        uint64 goOrigGUID;
+        AreaTriggerEntry const* trigger;
+        SmartScriptType mScriptType;
+        uint32 mEventPhase;
+        
+        uint32 mInvinceabilityHpLevel;
+        UNORDERED_MAP<int32, int32> mStoredDecimals;
+        uint32 mPathId;
+        SmartAIEventList mStoredEvents;
+        std::list<uint32>mRemIDs;
+
+        std::vector<uint32>mTextIDs;
+        uint32 mTextTimer;
+        uint32 mLastTextID;
+        uint64 mTextGUID;
+        bool mUseTextTimer;
+        SMARTAI_TEMPLATE mTemplate;
+        void InstallEvents();
+
+        void RemoveStoredEvent (uint32 id)
+        {
+            if (!mStoredEvents.empty())
+            {
+                for (SmartAIEventList::iterator i = mStoredEvents.begin(); i != mStoredEvents.end(); ++i)
+                {
+                    if (i->event_id = id)
+                    {
+                        mStoredEvents.erase(i);
+                        return;
+                    }
+                    
+                }
+            }
+        }
+        SmartScriptHolder FindLinkedEvent (uint32 link)
+        {
+            if (!mEvents.empty())
+            {
+                for (SmartAIEventList::iterator i = mEvents.begin(); i != mEvents.end(); ++i)
+                {
+                    if (i->event_id == link)
+                    {
+                        return (*i);
+                    }
+                    
+                }
+            }
+            SmartScriptHolder s;
+            return s;
+        }
+};
+
+#endif
diff --git a/src/server/game/AI/SmartAI/SmartScriptMgr.cpp b/src/server/game/AI/SmartAI/SmartScriptMgr.cpp
new file mode 100644
--- /dev/null
+++ b/src/server/game/AI/SmartAI/SmartScriptMgr.cpp
@@ -0,0 +1,776 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "DatabaseEnv.h"
+#include "SQLStorage.h"
+#include "ObjectMgr.h"
+#include "ProgressBar.h"
+#include "ObjectDefines.h"
+#include "GridDefines.h"
+#include "GridNotifiers.h"
+#include "SpellMgr.h"
+#include "GridNotifiersImpl.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "InstanceScript.h"
+#include "ScriptedCreature.h"
+
+#include "SmartScriptMgr.h"
+
+void SmartWaypointMgr::LoadFromDB()
+{
+    waypoint_map.clear();
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_LOAD_SMARTAI_WP);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded 0 SmartAI Waypoint Paths. DB table `waypoints` is empty.");
+        return;
+    }
+
+    WPPath* path = NULL;
+    uint32 last_entry = 0;
+    uint32 last_id = 1;
+    barGoLink bar(result->GetRowCount());
+    uint32 count = 0;
+    uint32 total = 0;
+
+    do
+    {
+        bar.step();
+        Field *fields = result->Fetch();
+        uint32 entry = fields[0].GetUInt32();
+        uint32 id = fields[1].GetUInt32();
+        float x,y,z;
+        x = fields[2].GetFloat();
+        y = fields[3].GetFloat();
+        z = fields[4].GetFloat();
+        
+        
+        WayPoint *wp = new WayPoint(id, x, y, z);
+
+        if (last_entry != entry)
+        {
+            path = new WPPath;
+            last_id = 1;
+        }
+        if (last_id != id)
+        {
+            sLog.outErrorDb("SmartWaypointMgr::LoadFromDB: Path entry %u, unexpected point id %u, expected %u.", entry, id, last_id);
+        }
+        last_id++;
+        (*path)[id] = wp;
+
+        if (last_entry != entry)
+        {
+            count++;
+            waypoint_map[entry] = path;
+        }
+        last_entry = entry;
+        total++;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u SmartAI Waypoint Paths, total %u waypoints.", count, total);
+}
+
+void SmartAIMgr::LoadSmartAIFromDB()
+{
+    for (uint8 i = 0; i < SMART_SCRIPT_TYPE_MAX; i++)
+        mEventMap[i].clear();  //Drop Existing SmartAI List
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_LOAD_SMART_SCRIPTS);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded 0 SmartAI scripts. DB table `smartai_scripts` is empty.");
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+    uint32 ScriptCount = 0;
+
+    do
+    {
+        bar.step();
+        Field* fields = result->Fetch();
+
+        SmartScriptHolder temp;
+
+        temp.entryOrGuid = fields[0].GetInt32();
+        SmartScriptType source_type = (SmartScriptType)fields[1].GetUInt32();
+        if (source_type >= SMART_SCRIPT_TYPE_MAX)
+        {
+            sLog.outErrorDb("SmartAIMgr::LoadSmartAIFromDB: invalid source_type (%u), skipped loading.", uint32(source_type));
+            continue;
+        }
+        if (temp.entryOrGuid >= 0)
+        {
+            switch(source_type)
+            {
+                case SMART_SCRIPT_TYPE_CREATURE:
+                {
+                    if (!sCreatureStorage.LookupEntry<CreatureInfo>((uint32)temp.entryOrGuid))
+                    {
+                        sLog.outErrorDb("SmartAIMgr::LoadSmartAIFromDB: Creature entry (%u) does not exist, skipped loading.", uint32(temp.entryOrGuid));
+                        continue;
+                    }
+                    break;
+                }
+                case SMART_SCRIPT_TYPE_GAMEOBJECT:
+                {
+                    if (!sGOStorage.LookupEntry<GameObjectInfo>((uint32)temp.entryOrGuid))
+                    {
+                        sLog.outErrorDb("SmartAIMgr::LoadSmartAIFromDB: GameObject entry (%u) does not exist, skipped loading.", uint32(temp.entryOrGuid));
+                        continue;
+                    }
+                    break;
+                }
+                case SMART_SCRIPT_TYPE_AREATRIGGER:
+                {
+                    if (!sAreaTriggerStore.LookupEntry((uint32)temp.entryOrGuid))
+                    {
+                        sLog.outErrorDb("SmartAIMgr::LoadSmartAIFromDB: AreaTrigger entry (%u) does not exist, skipped loading.", uint32(temp.entryOrGuid));
+                        continue;
+                    }
+                    break;
+                }
+                default:
+                    sLog.outErrorDb("SmartAIMgr::LoadSmartAIFromDB: not yet implemented source_type %u", (uint32)source_type);
+                    continue;
+            }
+        }else
+        {
+            if (!sObjectMgr.GetCreatureData(uint32(abs(temp.entryOrGuid))))
+            {
+                sLog.outErrorDb("SmartAIMgr::LoadSmartAIFromDB: Creature guid (%u) does not exist, skipped loading.", uint32(abs(temp.entryOrGuid)));
+                continue;
+            }
+        }
+        temp.source_type = source_type;
+        temp.event_id = fields[2].GetUInt32();
+        temp.link = fields[3].GetUInt32();
+        temp.event.type = (SMART_EVENT)fields[4].GetUInt32();
+        temp.event.event_phase_mask = fields[5].GetUInt32();
+        temp.event.event_chance = fields[6].GetUInt32();
+        temp.event.event_flags = fields[7].GetUInt32();
+
+        temp.event.raw.param1 = fields[8].GetUInt32();
+        temp.event.raw.param2 = fields[9].GetUInt32();
+        temp.event.raw.param3 = fields[10].GetUInt32();
+        temp.event.raw.param4 = fields[11].GetUInt32();
+
+        temp.action.type = (SMART_ACTION)fields[12].GetUInt32();
+
+        temp.action.raw.param1 = fields[13].GetUInt32();
+        temp.action.raw.param2 = fields[14].GetUInt32();
+        temp.action.raw.param3 = fields[15].GetUInt32();
+        temp.action.raw.param4 = fields[16].GetUInt32();
+        temp.action.raw.param5 = fields[17].GetUInt32();
+        temp.action.raw.param6 = fields[18].GetUInt32();
+
+        temp.target.type = (SMARTAI_TARGETS)fields[19].GetUInt32();
+        temp.target.raw.param1 = fields[20].GetUInt32();
+        temp.target.raw.param2 = fields[21].GetUInt32();
+        temp.target.raw.param3 = fields[22].GetUInt32();
+        temp.target.x = fields[23].GetFloat();
+        temp.target.y = fields[24].GetFloat();
+        temp.target.z = fields[25].GetFloat();
+        temp.target.o = fields[26].GetFloat();
+
+        //check target
+        if (!IsTargetValid(temp))
+            continue;
+
+        // check all event and action params
+        if (!IsEventValid(temp))
+            continue;
+
+        // creature entry / guid not found in storage, create empty event list for it and increase counters
+        if (mEventMap[source_type].find(temp.entryOrGuid) == mEventMap[source_type].end())
+        {
+            ++ScriptCount;
+            SmartAIEventList eventList;
+            mEventMap[source_type][temp.entryOrGuid] = eventList;
+        }
+        // store the new event
+        mEventMap[source_type][temp.entryOrGuid].push_back(temp);
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u SmartAI scripts.", ScriptCount);
+}
+
+bool SmartAIMgr::IsTargetValid(SmartScriptHolder e)
+{
+    if (e.GetActionType() == SMART_ACTION_INSTALL_AI_TEMPLATE)
+        return true; //AI template has special handling
+    switch (e.GetTargetType())
+    {
+        case SMART_TARGET_CREATURE_DISTANCE:
+        case SMART_TARGET_CREATURE_RANGE:
+            {
+                if (e.target.unitDistance.creature && !sCreatureStorage.LookupEntry<CreatureInfo>(e.target.unitDistance.creature))
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Creature entry %u as target_param1, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.target.unitDistance.creature);
+                    return false;
+                }
+                break;
+            }
+        case SMART_TARGET_GAMEOBJECT_DISTANCE:
+        case SMART_TARGET_GAMEOBJECT_RANGE:
+            {
+                if (e.target.goDistance.entry && !sGOStorage.LookupEntry<GameObjectInfo>(e.target.goDistance.entry))
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent GameObject entry %u as target_param1, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.target.goDistance.entry);
+                    return false;
+                }
+                break;
+            }
+        case SMART_TARGET_CREATURE_GUID:
+            {
+                if (e.target.unitGUID.entry && !IsCreatureValid(e, e.target.unitGUID.entry)) return false;
+                break;
+            }
+        case SMART_TARGET_GAMEOBJECT_GUID:
+            {
+                if (e.target.goGUID.entry && !IsGameObjectValid(e, e.target.goGUID.entry)) return false;
+                break;
+            }
+        case SMART_TARGET_PLAYER_RANGE:
+        case SMART_TARGET_PLAYER_DISTANCE:
+        case SMART_TARGET_SELF:
+        case SMART_TARGET_VICTIM:
+        case SMART_TARGET_HOSTILE_SECOND_AGGRO:
+        case SMART_TARGET_HOSTILE_LAST_AGGRO:
+        case SMART_TARGET_HOSTILE_RANDOM:
+        case SMART_TARGET_HOSTILE_RANDOM_NOT_TOP:
+        case SMART_TARGET_ACTION_INVOKER:
+        case SMART_TARGET_POSITION:
+        case SMART_TARGET_NONE:
+        case SMART_TARGET_CLOSEST_CREATURE:
+        case SMART_TARGET_CLOSEST_GAMEOBJECT:
+        case SMART_TARGET_CLOSEST_PLAYER:
+            break;
+        default:
+            sLog.outErrorDb("SmartAIMgr: Not handled target_type(%u), Entry %d SourceType %u Event %u Action %u, skipped.", e.GetTargetType(), e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+            return false;
+    }
+    return true;
+}
+
+bool SmartAIMgr::IsEventValid(SmartScriptHolder e)
+{
+    if (e.event.type >= SMART_EVENT_END)
+    {
+        sLog.outErrorDb("SmartAIMgr: EntryOrGuid %d using event(%u) has invalid event type (%u), skipped.", e.entryOrGuid, e.event_id, e.GetEventType());
+        return false;
+    }
+    if (!(SmartAIEventMask[e.event.type][1] & SmartAITypeMask[e.GetScriptType()][1]))
+    {
+        sLog.outErrorDb("SmartAIMgr: EntryOrGuid %d, event type %u can not be used for Script type %u", e.entryOrGuid, e.GetEventType(), e.GetScriptType());
+        return false;
+    }
+    if (e.action.type >= SMART_ACTION_END)
+    {
+        sLog.outErrorDb("SmartAIMgr: EntryOrGuid %d using event(%u) has invalid action type (%u), skipped.", e.entryOrGuid, e.event_id, e.GetActionType());
+        return false;
+    }
+    if (e.event.event_phase_mask > SMART_EVENT_PHASE_ALL)
+    {
+        sLog.outErrorDb("SmartAIMgr: EntryOrGuid %d using event(%u) has invalid phase mask (%u), skipped.", e.entryOrGuid, e.event_id, e.event.event_phase_mask);
+        return false;
+    }
+    switch (e.event.type)
+    {
+        case SMART_EVENT_UPDATE:
+        case SMART_EVENT_UPDATE_IC:
+        case SMART_EVENT_UPDATE_OOC:
+        case SMART_EVENT_HEALT_PCT:
+        case SMART_EVENT_MANA_PCT:
+        case SMART_EVENT_TARGET_HEALTH_PCT:
+        case SMART_EVENT_TARGET_MANA_PCT:
+        case SMART_EVENT_RANGE:
+        case SMART_EVENT_DAMAGED:
+        case SMART_EVENT_DAMAGED_TARGET:
+        case SMART_EVENT_RECEIVE_HEAL:
+            if (!IsMinMaxValid(e, e.event.minMaxRepeat.min, e.event.minMaxRepeat.max)) return false;
+            if (!IsMinMaxValid(e, e.event.minMaxRepeat.repeatMin, e.event.minMaxRepeat.repeatMax)) return false;
+            break;
+        case SMART_EVENT_SPELLHIT:
+        case SMART_EVENT_SPELLHIT_TARGET:
+            if (e.event.spellHit.spell)
+            {
+                SpellEntry const* pSpell = sSpellStore.LookupEntry(e.event.spellHit.spell);
+                if (!pSpell)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Spell entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.event.spellHit.spell);
+                    return false;
+                }
+                if (e.event.spellHit.school && (e.event.spellHit.school & pSpell->SchoolMask) != pSpell->SchoolMask)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses Spell entry %u with invalid school mask, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.event.spellHit.spell);
+                    return false;
+                }
+            }
+            if (!IsMinMaxValid(e, e.event.spellHit.cooldownMin, e.event.spellHit.cooldownMax)) return false;
+            break;
+        case SMART_EVENT_OOC_LOS:
+        case SMART_EVENT_IC_LOS:
+            if (!IsMinMaxValid(e, e.event.los.cooldownMin, e.event.los.cooldownMax)) return false;
+            break;
+        case SMART_EVENT_RESPAWN:
+            if (e.event.respawn.type == SMART_SCRIPT_RESPAWN_CONDITION_MAP && !sMapStore.LookupEntry(e.event.respawn.map))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Map entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.event.respawn.map);
+                return false;
+            }
+            if (e.event.respawn.type == SMART_SCRIPT_RESPAWN_CONDITION_AREA && !GetAreaEntryByAreaID(e.event.respawn.area))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Area entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.event.respawn.area);
+                return false;
+            }
+            break;
+        case SMART_EVENT_FRIENDLY_HEALTH:
+            if (!NotNULL(e, e.event.friendlyHealt.radius)) return false;
+            if (!IsMinMaxValid(e, e.event.friendlyHealt.repeatMin, e.event.friendlyHealt.repeatMax)) return false;
+            break;
+        case SMART_EVENT_FRIENDLY_IS_CC:
+            if (!IsMinMaxValid(e, e.event.friendlyCC.repeatMin, e.event.friendlyCC.repeatMax)) return false;
+            break;
+        case SMART_EVENT_FRIENDLY_MISSING_BUFF:
+        {
+            if (!IsSpellValid(e, e.event.missingBuff.spell)) return false;
+            if (!NotNULL(e, e.event.missingBuff.radius)) return false;
+            if (!IsMinMaxValid(e, e.event.missingBuff.repeatMin, e.event.missingBuff.repeatMax)) return false;
+            break;
+        }
+        case SMART_EVENT_KILL:
+            if (!IsMinMaxValid(e, e.event.kill.cooldownMin, e.event.kill.cooldownMax)) return false;
+            if (e.event.kill.creature && !IsCreatureValid(e, e.event.kill.creature)) return false;
+            break;
+        case SMART_EVENT_TARGET_CASTING:
+        case SMART_EVENT_PASSENGER_BOARDED:
+        case SMART_EVENT_PASSENGER_REMOVED:
+            if (!IsMinMaxValid(e, e.event.minMax.repeatMin, e.event.minMax.repeatMax)) return false;
+            break;
+        case SMART_EVENT_SUMMON_DESPAWNED:
+        case SMART_EVENT_SUMMONED_UNIT:
+            if (e.event.summoned.creature && !IsCreatureValid(e, e.event.summoned.creature)) return false;
+            if (!IsMinMaxValid(e, e.event.summoned.cooldownMin, e.event.summoned.cooldownMax)) return false;
+            break;
+        case SMART_EVENT_ACCEPTED_QUEST:
+        case SMART_EVENT_REWARD_QUEST:
+            if (!IsQuestValid(e, e.event.quest.quest)) return false;
+            break;
+        case SMART_EVENT_RECEIVE_EMOTE:
+        {
+            if (e.event.emote.emote && !IsEmoteValid(e, e.event.emote.emote)) return false;
+            if (!IsMinMaxValid(e, e.event.emote.cooldownMin, e.event.emote.cooldownMax)) return false;
+            break;
+        }
+        case SMART_EVENT_HAS_AURA:
+        case SMART_EVENT_TARGET_BUFFED:
+        {
+            if (!IsSpellValid(e, e.event.aura.spell)) return false;
+            if (!IsMinMaxValid(e, e.event.aura.repeatMin, e.event.aura.repeatMax)) return false;
+            break;
+        }
+        case SMART_EVENT_TRANSPORT_ADDCREATURE:
+            {
+                if (e.event.transportAddCreature.creature && !IsCreatureValid(e, e.event.transportAddCreature.creature)) return false;
+                break;
+            }
+        case SMART_EVENT_MOVEMENTINFORM:
+            {
+                if (e.event.movementInform.type > NULL_MOTION_TYPE)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses invalid Motion type %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.event.movementInform.type);
+                    return false;
+                }
+                break;
+            }
+        case SMART_EVENT_DATA_SET:
+            {
+                if (!IsMinMaxValid(e, e.event.dataSet.cooldownMin, e.event.dataSet.cooldownMax)) return false;
+                break;
+            }
+        case SMART_EVENT_AREATRIGGER_ONTRIGGER:
+            {
+                if (e.event.areatrigger.id && !IsAreaTriggerValid(e, e.event.areatrigger.id)) return false;
+                break;
+            }
+        case SMART_EVENT_TEXT_OVER:
+            if (e.event.textOver.textGroupID && !IsTextValid(e, e.event.textOver.textGroupID)) return false;
+            break;
+        case SMART_EVENT_LINK:
+            {
+                if (e.link && e.link == e.event_id)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u, Event %u, Link Event is linking self (infinite loop), skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id);
+                    return false;
+                }
+                break;
+            }
+        case SMART_EVENT_TIMED_EVENT_TRIGGERED:
+        case SMART_EVENT_INSTANCE_PLAYER_ENTER:
+        case SMART_EVENT_TRANSPORT_RELOCATE:
+        case SMART_EVENT_CHARMED:
+        case SMART_EVENT_CHARMED_TARGET:
+        case SMART_EVENT_CORPSE_REMOVED:
+        case SMART_EVENT_AI_INIT:
+        case SMART_EVENT_TRANSPORT_ADDPLAYER:
+        case SMART_EVENT_TRANSPORT_REMOVE_PLAYER:
+        case SMART_EVENT_AGGRO:
+        case SMART_EVENT_DEATH:
+        case SMART_EVENT_EVADE:
+        case SMART_EVENT_REACHED_HOME:
+        case SMART_EVENT_RESET:
+        case SMART_EVENT_QUEST_ACCEPTED:
+        case SMART_EVENT_QUEST_OBJ_COPLETETION:
+        case SMART_EVENT_QUEST_COMPLETION:
+        case SMART_EVENT_QUEST_REWARDED:
+        case SMART_EVENT_QUEST_FAIL:
+        case SMART_EVENT_JUST_SUMMONED:
+        case SMART_EVENT_WAYPOINT_START:
+        case SMART_EVENT_WAYPOINT_REACHED:
+        case SMART_EVENT_WAYPOINT_PAUSED:
+        case SMART_EVENT_WAYPOINT_RESUMED:
+        case SMART_EVENT_WAYPOINT_STOPPED:
+        case SMART_EVENT_WAYPOINT_ENDED:
+        case SMART_ACTION_PLAYMOVIE:
+        case SMART_EVENT_GOSSIP_SELECT:
+        case SMART_EVENT_GOSSIP_HELLO:
+        case SMART_EVENT_JUST_CREATED:
+        case SMART_EVENT_FOLLOW_COPMLETE:
+            break;
+        default: 
+            sLog.outErrorDb("SmartAIMgr: Not handled event_type(%u), Entry %d SourceType %u Event %u Action %u, skipped.", e.GetEventType(), e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+            return false;
+    }
+    switch (e.GetActionType())
+    {
+        case SMART_ACTION_TALK:
+            if (!IsTextValid(e, e.action.talk.textGroupID1)) return false;
+            if (e.action.talk.textGroupID2 && !IsTextValid(e, e.action.talk.textGroupID2)) return false;
+            if (e.action.talk.textGroupID3 && !IsTextValid(e, e.action.talk.textGroupID3)) return false;
+            if (e.action.talk.textGroupID4 && !IsTextValid(e, e.action.talk.textGroupID4)) return false;
+            if (e.action.talk.textGroupID5 && !IsTextValid(e, e.action.talk.textGroupID5)) return false;
+            if (e.action.talk.textGroupID6 && !IsTextValid(e, e.action.talk.textGroupID6)) return false;
+
+            break;
+        case SMART_ACTION_SET_FACTION:
+            if (e.action.faction.factionID && !sFactionStore.LookupEntry(e.action.faction.factionID))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Faction %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.faction.factionID);
+                return false;
+            }
+            break;
+        case SMART_ACTION_MORPH_TO_ENTRY_OR_MODEL:
+        case SMART_ACTION_MOUNT_TO_ENTRY_OR_MODEL:
+            if (e.action.morphOrMount.creature || e.action.morphOrMount.model)
+            {
+                if (e.action.morphOrMount.creature > 0 && !sCreatureStorage.LookupEntry<CreatureInfo>(e.action.morphOrMount.creature))
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Creature entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.morphOrMount.creature);
+                    return false;
+                }
+
+                if (e.action.morphOrMount.model)
+                {
+                    if (e.action.morphOrMount.creature)
+                    {
+                        sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u has ModelID set with also set CreatureId, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+                        return false;
+                    }
+                    else if (!sCreatureDisplayInfoStore.LookupEntry(e.action.morphOrMount.model))
+                    {
+                        sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Model id %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.morphOrMount.model);
+                        return false;
+                    }
+                }
+            }
+            break;
+        case SMART_ACTION_SOUND:
+            if (!IsSoundValid(e, e.action.sound.sound)) return false;
+            if (e.action.sound.range > TEXT_RANGE_WORLD)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses invalid Text Range %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.sound.range);
+                return false;
+            }
+            break;
+        case SMART_ACTION_SET_EMOTE_STATE:
+        case SMART_ACTION_PLAY_EMOTE:
+            if (!IsEmoteValid(e, e.action.emote.emote)) return false;
+            break;
+        case SMART_ACTION_FAIL_QUEST:
+        case SMART_ACTION_ADD_QUEST:
+            if (e.action.quest.quest && !IsQuestValid(e, e.action.quest.quest)) return false;
+            break;
+        case SMART_ACTION_RANDOM_EMOTE:
+            if (e.action.randomEmote.emote1 && !IsEmoteValid(e, e.action.randomEmote.emote1)) return false;
+            if (e.action.randomEmote.emote2 && !IsEmoteValid(e, e.action.randomEmote.emote2)) return false;
+            if (e.action.randomEmote.emote3 && !IsEmoteValid(e, e.action.randomEmote.emote3)) return false;
+            if (e.action.randomEmote.emote4 && !IsEmoteValid(e, e.action.randomEmote.emote4)) return false;
+            if (e.action.randomEmote.emote5 && !IsEmoteValid(e, e.action.randomEmote.emote5)) return false;
+            if (e.action.randomEmote.emote6 && !IsEmoteValid(e, e.action.randomEmote.emote6)) return false;
+            break;
+        case SMART_ACTION_ADD_AURA:
+        case SMART_ACTION_CAST:
+            if (!IsSpellValid(e, e.action.cast.spell)) return false;
+            break;
+        case SMART_ACTION_CALL_AREAEXPLOREDOREVENTHAPPENS:
+        case SMART_ACTION_CALL_GROUPEVENTHAPPENS:
+            if (Quest const* qid = sObjectMgr.GetQuestTemplate(e.action.quest.quest))
+            {
+                if (!qid->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u SpecialFlags for Quest entry %u does not include FLAGS_EXPLORATION_OR_EVENT(2), skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.quest.quest);
+                    return false;
+                }
+            }
+            else
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Quest entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.quest.quest);
+                return false;
+            }
+            break;
+        case SMART_ACTION_SEND_CASTCREATUREORGO:
+            if (!IsQuestValid(e, e.action.castCreatureOrGO.quest)) return false;
+            if (!IsSpellValid(e, e.action.castCreatureOrGO.spell)) return false;
+            break;
+
+
+
+        case SMART_ACTION_SET_EVENT_PHASE:
+            if (e.action.setEventPhase.phase >= SMART_EVENT_PHASE_MAX)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u attempts to set phase %u. Phase mask cannot be used past phase %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.setEventPhase.phase, SMART_EVENT_PHASE_MAX-1);
+                return false;
+            }
+            break;
+        case SMART_ACTION_INC_EVENT_PHASE:
+            if (!e.action.incEventPhase.inc && !e.action.incEventPhase.dec)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u is incrementing phase by 0, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+                return false;
+            }
+            else if (e.action.incEventPhase.inc > SMART_EVENT_PHASE_MAX || e.action.incEventPhase.dec > SMART_EVENT_PHASE_MAX)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u attempts to increment phase by too large value, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+                return false;
+            }
+            break;
+        case SMART_ACTION_CALL_CASTEDCREATUREORGO:
+            if (!IsCreatureValid(e, e.action.castedCreatureOrGO.creature)) return false;
+            if (!IsSpellValid(e, e.action.castedCreatureOrGO.spell)) return false;
+            break;
+        case SMART_ACTION_REMOVEAURASFROMSPELL:
+            if (!IsSpellValid(e, e.action.removeAura.spell)) return false;
+            break;
+        case SMART_ACTION_RANDOM_PHASE:
+            {
+                if (e.action.randomPhase.phase1 >= SMART_EVENT_PHASE_MAX ||
+                    e.action.randomPhase.phase2 >= SMART_EVENT_PHASE_MAX ||
+                    e.action.randomPhase.phase3 >= SMART_EVENT_PHASE_MAX ||
+                    e.action.randomPhase.phase4 >= SMART_EVENT_PHASE_MAX ||
+                    e.action.randomPhase.phase5 >= SMART_EVENT_PHASE_MAX ||
+                    e.action.randomPhase.phase6 >= SMART_EVENT_PHASE_MAX)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u attempts to set invalid phase, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+                    return false;
+                }
+            }
+            break;
+        case SMART_ACTION_RANDOM_PHASE_RANGE:       //PhaseMin, PhaseMax
+            {
+                if (e.action.randomPhaseRange.phaseMin >= SMART_EVENT_PHASE_MAX ||
+                    e.action.randomPhaseRange.phaseMax >= SMART_EVENT_PHASE_MAX)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u attempts to set invalid phase, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+                    return false;
+                }
+                if (!IsMinMaxValid(e, e.action.randomPhaseRange.phaseMin, e.action.randomPhaseRange.phaseMax)) return false;
+                break;
+            }
+        case SMART_ACTION_SUMMON_CREATURE:
+            if (!IsCreatureValid(e, e.action.summonCreature.creature)) return false;
+            if (e.action.summonCreature.type > TEMPSUMMON_MANUAL_DESPAWN)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses incorrect TempSummonType %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.summonCreature.type);
+                return false;
+            }
+            break;
+        case SMART_ACTION_CALL_KILLEDMONSTER:
+            if (!IsCreatureValid(e, e.action.killedMonster.creature)) return false;
+            break;
+        case SMART_ACTION_UPDATE_TEMPLATE:
+            if (e.action.updateTemplate.creature && !IsCreatureValid(e, e.action.updateTemplate.creature)) return false;
+            break;
+        case SMART_ACTION_SET_SHEATH:
+            if (e.action.setSheath.sheath && e.action.setSheath.sheath >= MAX_SHEATH_STATE)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses incorrect Sheath state %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.setSheath.sheath);
+                return false;
+            }
+            break;
+        case SMART_ACTION_SET_REACT_STATE:
+            {
+                if (e.action.react.state > REACT_AGGRESSIVE)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Creature %d Event %u Action %u uses invalid React State %u, skipped.", e.entryOrGuid, e.event_id, e.GetActionType(), e.action.react.state);
+                    return false;
+                }
+                break;
+            }
+        case SMART_ACTION_SUMMON_GO:
+            if (!IsGameObjectValid(e, e.action.summonGO.entry)) return false;
+            break;
+        case SMART_ACTION_WP_LOAD:
+            if (!sSmartWaypointMgr.GetPath(e.action.wpLoad.id))
+            {
+                sLog.outErrorDb("SmartAIMgr: Creature %d Event %u Action %u uses non-existent WaypointPath id %u, skipped.", e.entryOrGuid, e.event_id, e.GetActionType(), e.action.wpLoad.id);
+                return false;
+            }
+            break;
+        case SMART_ACTION_ADD_ITEM:
+        case SMART_ACTION_REMOVE_ITEM:
+            if (!IsItemValid(e, e.action.item.entry)) return false;
+            if (!NotNULL(e, e.action.item.count)) return false;
+            break;
+        case SMART_ACTION_TELEPORT:
+            if (!sMapStore.LookupEntry(e.action.teleport.mapID))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Map entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), e.action.teleport.mapID);
+                return false;
+            }
+            break;
+        case SMART_ACTION_INSTALL_AI_TEMPLATE:
+            if (e.action.installTtemplate.id >= SMARTAI_TEMPLATE_END)
+            {
+                sLog.outErrorDb("SmartAIMgr: Creature %d Event %u Action %u uses non-existent AI template id %u, skipped.", e.entryOrGuid, e.event_id, e.GetActionType(), e.action.installTtemplate.id);
+                return false;
+            }
+            break;
+        case SMART_ACTION_WP_STOP:
+            if (e.action.wpStop.quest && !IsQuestValid(e, e.action.wpStop.quest)) return false;
+            break;
+        case SMART_ACTION_WP_START:
+            {
+                if (e.action.wpStart.quest && !IsQuestValid(e, e.action.wpStart.quest)) return false;
+                if (e.action.wpStart.reactState > REACT_AGGRESSIVE)
+                {
+                    sLog.outErrorDb("SmartAIMgr: Creature %d Event %u Action %u uses invalid React State %u, skipped.", e.entryOrGuid, e.event_id, e.GetActionType(), e.action.wpStart.reactState);
+                    return false;
+                }
+                break;
+            }
+        case SMART_ACTION_CREATE_TIMED_EVENT:
+        {
+            if (!IsMinMaxValid(e, e.action.timeEvent.min, e.action.timeEvent.max)) return false; 
+            if (!IsMinMaxValid(e, e.action.timeEvent.repeatMin, e.action.timeEvent.repeatMax)) return false;
+            break;
+        }
+        case SMART_ACTION_FOLLOW:
+        case SMART_ACTION_SET_ORIENTATION:
+        case SMART_ACTION_STORE_TARGET_LIST:
+        case SMART_ACTION_EVADE:
+        case SMART_ACTION_FLEE_FOR_ASSIST:
+        case SMART_ACTION_DIE:
+        case SMART_ACTION_SET_IN_COMBAT_WITH_ZONE:
+        case SMART_ACTION_SET_ACTIVE:
+        case SMART_ACTION_STORE_VARIABLE_DECIMAL:
+        case SMART_ACTION_WP_RESUME:
+        case SMART_ACTION_KILL_UNIT:
+        case SMART_ACTION_SET_INVINCIBILITY_HP_LEVEL:
+        case SMART_ACTION_RESET_GOBJECT:
+        case SMART_ACTION_ATTACK_START:
+        case SMART_ACTION_THREAT_ALL_PCT:
+        case SMART_ACTION_THREAT_SINGLE_PCT:
+        case SMART_ACTION_SET_INST_DATA:
+        case SMART_ACTION_SET_INST_DATA64:
+        case SMART_ACTION_AUTO_ATTACK:
+        case SMART_ACTION_ALLOW_COMBAT_MOVEMENT:
+        case SMART_ACTION_CALL_FOR_HELP:
+        case SMART_ACTION_SET_DATA:
+        case SMART_ACTION_MOVE_FORWARD:
+        case SMART_ACTION_SET_VISIBILITY:
+        case SMART_ACTION_WP_PAUSE:
+        case SMART_ACTION_SET_FLY:
+        case SMART_ACTION_SET_RUN:
+        case SMART_ACTION_SET_SWIMM:
+        case SMART_ACTION_FORCE_DESPAWN:
+        case SMART_ACTION_SET_INGAME_PHASE_MASK:
+        case SMART_ACTION_SET_UNIT_FLAG:
+        case SMART_ACTION_REMOVE_UNIT_FLAG:
+        case SMART_ACTION_PLAYMOVIE:
+        case SMART_ACTION_MOVE_TO_POS:
+        case SMART_ACTION_RESPAWN_TARGET:
+        case SMART_ACTION_CLOSE_GOSSIP:
+        case SMART_ACTION_EQUIP:
+        case SMART_ACTION_TRIGGER_TIMED_EVENT:
+        case SMART_ACTION_REMOVE_TIMED_EVENT:
+        case SMART_ACTION_OVERRIDE_SCRIPT_BASE_OBJECT:
+        case SMART_ACTION_RESET_SCRIPT_BASE_OBJECT:
+        case SMART_ACTION_ACTIVATE_GOBJECT:
+        case SMART_ACTION_CALL_SCRIPT_RESET:
+        case SMART_ACTION_NONE:
+            break;
+        default:
+            sLog.outErrorDb("SmartAIMgr: Not handled action_type(%u), Entry %d SourceType %u Event %u, skipped.", e.GetActionType(), e.GetEventType(), e.entryOrGuid, e.GetScriptType(), e.event_id);
+            return false;
+    }
+
+    return true;
+}
+
+bool SmartAIMgr::IsTextValid(SmartScriptHolder e, uint32 id)
+{
+    bool error = false;
+    uint32 entry = 0;
+    if (e.entryOrGuid >= 0)
+        entry = uint32(e.entryOrGuid);
+    else {
+        entry = uint32(abs(e.entryOrGuid));
+        CreatureData const* data = sObjectMgr.GetCreatureData(entry);
+        if (!data)
+        {
+            sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u using non-existent Creature guid %d, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+            return false;
+        }
+        else
+            entry = data->id;
+    }
+    if (!entry || !sCreatureTextMgr.TextExist(entry, uint8(id)))
+        error = true;
+    if (error)
+    {
+        sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u using non-existent Text id %d, skipped.", e.entryOrGuid, e.GetScriptType(), e.source_type, e.GetActionType(), id);
+        return false;
+    }
+    return true;
+}
diff --git a/src/server/game/AI/SmartAI/SmartScriptMgr.h b/src/server/game/AI/SmartAI/SmartScriptMgr.h
new file mode 100644
--- /dev/null
+++ b/src/server/game/AI/SmartAI/SmartScriptMgr.h
@@ -0,0 +1,1276 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITY_SMARTSCRIPTMGR_H
+#define TRINITY_SMARTSCRIPTMGR_H
+
+#include "Common.h"
+#include "Creature.h"
+#include "CreatureAI.h"
+#include "Unit.h"
+#include "ConditionMgr.h"
+#include "CreatureTextMgr.h"
+#include "Spell.h"
+
+//#include "SmartScript.h"
+//#include "SmartAI.h"
+
+struct WayPoint
+{
+    WayPoint(uint32 _id, float _x, float _y, float _z)
+    {
+        id = _id;
+        x = _x;
+        y = _y;
+        z = _z;
+    }
+
+    uint32 id;
+    float x;
+    float y;
+    float z;
+};
+
+enum SMART_EVENT_PHASE
+{
+    SMART_EVENT_PHASE_ALWAYS  = 0,
+    SMART_EVENT_PHASE_1       = 1,
+    SMART_EVENT_PHASE_2       = 2,
+    SMART_EVENT_PHASE_3       = 3,
+    SMART_EVENT_PHASE_4       = 4,
+    SMART_EVENT_PHASE_5       = 5,
+    SMART_EVENT_PHASE_6       = 6,
+    SMART_EVENT_PHASE_MAX     = 7,
+
+    SMART_EVENT_PHASE_COUNT   = 6,
+};
+
+enum SMART_EVENT_PHASE_BITS
+{
+    SMART_EVENT_PHASE_ALWAYS_BIT   = 0,
+    SMART_EVENT_PHASE_1_BIT        = 1,
+    SMART_EVENT_PHASE_2_BIT        = 2,
+    SMART_EVENT_PHASE_3_BIT        = 4,
+    SMART_EVENT_PHASE_4_BIT        = 8,
+    SMART_EVENT_PHASE_5_BIT        = 16,
+    SMART_EVENT_PHASE_6_BIT        = 32,
+    SMART_EVENT_PHASE_ALL          = SMART_EVENT_PHASE_1_BIT + SMART_EVENT_PHASE_2_BIT + SMART_EVENT_PHASE_3_BIT + SMART_EVENT_PHASE_4_BIT + SMART_EVENT_PHASE_5_BIT + SMART_EVENT_PHASE_6_BIT,
+};
+
+const uint32 SmartPhaseMask[SMART_EVENT_PHASE_COUNT][2] =
+{
+    {SMART_EVENT_PHASE_1, SMART_EVENT_PHASE_1_BIT },
+    {SMART_EVENT_PHASE_2, SMART_EVENT_PHASE_2_BIT },
+    {SMART_EVENT_PHASE_3, SMART_EVENT_PHASE_3_BIT },
+    {SMART_EVENT_PHASE_4, SMART_EVENT_PHASE_4_BIT },
+    {SMART_EVENT_PHASE_5, SMART_EVENT_PHASE_5_BIT },
+    {SMART_EVENT_PHASE_6, SMART_EVENT_PHASE_6_BIT },
+};
+
+enum SMART_EVENT
+{
+    SMART_EVENT_UPDATE_IC                = 0,       //1             // InitialMin, InitialMax, RepeatMin, RepeatMax
+    SMART_EVENT_UPDATE_OOC               = 1,       //1             // InitialMin, InitialMax, RepeatMin, RepeatMax
+    SMART_EVENT_HEALT_PCT                = 2,       //1             // HPMin%, HPMax%,  RepeatMin, RepeatMax
+    SMART_EVENT_MANA_PCT                 = 3,       //1             // ManaMin%, ManaMax%, RepeatMin, RepeatMax
+    SMART_EVENT_AGGRO                    = 4,       //1             // NONE
+    SMART_EVENT_KILL                     = 5,       //1             // CooldownMin0, CooldownMax1,playerOnly2,else creature entry3
+    SMART_EVENT_DEATH                    = 6,       //1             // NONE
+    SMART_EVENT_EVADE                    = 7,       //1             // NONE
+    SMART_EVENT_SPELLHIT                 = 8,       //1             // SpellID, School, CooldownMin, CooldownMax
+    SMART_EVENT_RANGE                    = 9,       //1             // MinDist, MaxDist, RepeatMin, RepeatMax
+    SMART_EVENT_OOC_LOS                  = 10,      //1             // NoHostile, MaxRnage, CooldownMin, CooldownMax
+    SMART_EVENT_RESPAWN                  = 11,      //1             // type, MapId,ZoneId
+    SMART_EVENT_TARGET_HEALTH_PCT        = 12,      //1             // HPMin%, HPMax%, RepeatMin, RepeatMax
+    SMART_EVENT_TARGET_CASTING           = 13,      //1             // RepeatMin, RepeatMax
+    SMART_EVENT_FRIENDLY_HEALTH          = 14,      //1             // HPDeficit, Radius, RepeatMin, RepeatMax
+    SMART_EVENT_FRIENDLY_IS_CC           = 15,      //1             // Radius, RepeatMin, RepeatMax
+    SMART_EVENT_FRIENDLY_MISSING_BUFF    = 16,      //1             // SpellId, Radius, RepeatMin, RepeatMax
+    SMART_EVENT_SUMMONED_UNIT            = 17,      //1             // CreatureId(0 all), CooldownMin, CooldownMax 
+    SMART_EVENT_TARGET_MANA_PCT          = 18,      //1             // ManaMin%, ManaMax%, RepeatMin, RepeatMax
+    SMART_EVENT_ACCEPTED_QUEST           = 19,      //1             // QuestID(0any)
+    SMART_EVENT_REWARD_QUEST             = 20,      //1             // QuestID(0any)
+    SMART_EVENT_REACHED_HOME             = 21,      //1             // NONE
+    SMART_EVENT_RECEIVE_EMOTE            = 22,      //1             // EmoteId, CooldownMin, CooldownMax, condition, val1,val2,val3 
+    SMART_EVENT_HAS_AURA                 = 23,      //1             // Param1 = SpellID, Param2 = Number of Time STacked, Param3/4 RepeatMin, RepeatMax
+    SMART_EVENT_TARGET_BUFFED            = 24,      //1             // Param1 = SpellID, Param2 = Number of Time STacked, Param3/4 RepeatMin, RepeatMax
+    SMART_EVENT_RESET                    = 25,      //1             // Called after combat, when the creature respawn and spawn.
+                                                    
+    SMART_EVENT_IC_LOS                   = 26,      //1             // NoHostile, MaxRnage, CooldownMin, CooldownMax
+    SMART_EVENT_PASSENGER_BOARDED        = 27,      //1             // CooldownMin, CooldownMax
+    SMART_EVENT_PASSENGER_REMOVED        = 28,      //1             // CooldownMin, CooldownMax
+    SMART_EVENT_CHARMED                  = 29,      //1             // NONE
+    SMART_EVENT_CHARMED_TARGET           = 30,      //1             // NONE
+    SMART_EVENT_SPELLHIT_TARGET          = 31,      //1             // SpellID, School, CooldownMin, CooldownMax
+    SMART_EVENT_DAMAGED                  = 32,      //1             // MinDmg, MaxDmg, CooldownMin, CooldownMax
+    SMART_EVENT_DAMAGED_TARGET           = 33,      //1             // MinDmg, MaxDmg, CooldownMin, CooldownMax
+    SMART_EVENT_MOVEMENTINFORM           = 34,      //1             // MovementType(any), PointID
+    SMART_EVENT_SUMMON_DESPAWNED         = 35,      //1             // Entry, CooldownMin, CooldownMax
+    SMART_EVENT_CORPSE_REMOVED           = 36,      //1             // NONE
+    SMART_EVENT_AI_INIT                  = 37,      //1             // NONE
+    SMART_EVENT_DATA_SET                 = 38,      //1             // Id, Value, CooldownMin, CooldownMax
+    SMART_EVENT_WAYPOINT_START           = 39,      //1             // PointId(0any), pathID(0any)
+    SMART_EVENT_WAYPOINT_REACHED         = 40,      //1             // PointId(0any), pathID(0any)
+    SMART_EVENT_TRANSPORT_ADDPLAYER      = 41,      //1             // NONE
+    SMART_EVENT_TRANSPORT_ADDCREATURE    = 42,      //1             // Entry (0 any)
+    SMART_EVENT_TRANSPORT_REMOVE_PLAYER  = 43,      //1             // NONE
+    SMART_EVENT_TRANSPORT_RELOCATE       = 44,      //1             // PointId
+    SMART_EVENT_INSTANCE_PLAYER_ENTER    = 45,      //1             // Team (0 any), CooldownMin, CooldownMax
+    SMART_EVENT_AREATRIGGER_ONTRIGGER    = 46,      //1             // TriggerId(0 any)
+    SMART_EVENT_QUEST_ACCEPTED           = 47,      //1             // none
+    SMART_EVENT_QUEST_OBJ_COPLETETION    = 48,      //1             // none
+    SMART_EVENT_QUEST_COMPLETION         = 49,      //1             // none
+    SMART_EVENT_QUEST_REWARDED           = 50,      //1             // none
+    SMART_EVENT_QUEST_FAIL               = 51,      //1             // none
+    SMART_EVENT_TEXT_OVER                = 52,      //1             // GroupId from creature_text (0 any)
+    SMART_EVENT_RECEIVE_HEAL             = 53,      //1             // MinHeal, MaxHeal, CooldownMin, CooldownMax
+    SMART_EVENT_JUST_SUMMONED            = 54,      //1             // none
+    SMART_EVENT_WAYPOINT_PAUSED          = 55,      //1             // PointId(0any), pathID(0any)
+    SMART_EVENT_WAYPOINT_RESUMED         = 56,      //1             // PointId(0any), pathID(0any)
+    SMART_EVENT_WAYPOINT_STOPPED         = 57,      //1             // PointId(0any), pathID(0any)
+    SMART_EVENT_WAYPOINT_ENDED           = 58,      //1             // PointId(0any), pathID(0any)
+    SMART_EVENT_TIMED_EVENT_TRIGGERED    = 59,      //1             // id
+    SMART_EVENT_UPDATE                   = 60,      //1             // InitialMin, InitialMax, RepeatMin, RepeatMax
+    SMART_EVENT_LINK                     = 61,      //1             // INTERNAL USAGE, no params, used to link together multiple events, does not use any extra resources to iterate event lists needlessly
+    SMART_EVENT_GOSSIP_SELECT            = 62,      //1             // sender, action
+    SMART_EVENT_JUST_CREATED             = 63,      //1             // none
+    SMART_EVENT_GOSSIP_HELLO             = 64,      //1             // none
+    SMART_EVENT_FOLLOW_COPMLETE          = 65,      //1             // none
+
+    SMART_EVENT_END                      = 66,
+};
+
+struct SmartEvent
+{
+    SMART_EVENT type;
+    uint32 event_phase_mask;
+    uint32 event_chance;
+    uint32 event_flags;
+    union
+    {
+        struct
+        {
+            uint32 min;
+            uint32 max;
+            uint32 repeatMin;
+            uint32 repeatMax;
+        } minMaxRepeat;
+
+        struct
+        {
+            uint32 cooldownMin;
+            uint32 cooldownMax;
+            uint32 playerOnly;
+            uint32 creature;
+        } kill;
+
+        struct
+        {
+            uint32 spell;
+            uint32 school;
+            uint32 cooldownMin;
+            uint32 cooldownMax;
+        } spellHit;
+
+        struct
+        {
+            uint32 noHostile;
+            uint32 maxDist;
+            uint32 cooldownMin;
+            uint32 cooldownMax;
+        } los;
+
+        struct
+        {
+            uint32 type;
+            uint32 map;
+            uint32 area;
+        } respawn;
+
+        struct
+        {
+            uint32 repeatMin;
+            uint32 repeatMax;
+        } minMax;
+
+        struct
+        {
+            uint32 hpDeficit;
+            uint32 radius;
+            uint32 repeatMin;
+            uint32 repeatMax;
+        } friendlyHealt;
+
+        struct
+        {
+            uint32 radius;
+            uint32 repeatMin;
+            uint32 repeatMax;
+        } friendlyCC;
+
+        struct
+        {
+            uint32 spell;
+            uint32 radius;
+            uint32 repeatMin;
+            uint32 repeatMax;
+        } missingBuff;
+
+        struct
+        {
+            uint32 creature;
+            uint32 cooldownMin;
+            uint32 cooldownMax;
+        } summoned;
+
+        struct
+        {
+            uint32 quest;
+        } quest;
+
+        struct
+        {
+            uint32 emote;
+            uint32 cooldownMin;
+            uint32 cooldownMax;
+        } emote;
+
+        struct
+        {
+            uint32 spell;
+            uint32 count;
+            uint32 repeatMin;
+            uint32 repeatMax;
+        } aura;
+
+        struct
+        {
+            uint32 spell;
+            uint32 count;
+            uint32 repeatMin;
+            uint32 repeatMax;
+        } targetAura;
+
+        struct
+        {
+            uint32 type;
+            uint32 id;
+        } movementInform;
+
+        struct
+        {
+            uint32 id;
+            uint32 value;
+            uint32 cooldownMin;
+            uint32 cooldownMax;
+        } dataSet;
+
+        struct
+        {
+            uint32 pointID;
+            uint32 pathID;
+        } waypoint;
+
+        struct
+        {
+            uint32 creature;
+        } transportAddCreature;
+
+        struct
+        {
+            uint32 pointID;
+        } transportRelocate;
+
+        struct
+        {
+            uint32 team;
+            uint32 cooldownMin;
+            uint32 cooldownMax;
+        } instancePlayerEnter;
+
+        struct
+        {
+            uint32 id;
+        } areatrigger;
+
+        struct
+        {
+            uint32 textGroupID;
+        } textOver;
+
+        struct
+        {
+            uint32 id;
+        } timedEvent;
+
+        struct
+        {
+            uint32 sender;
+            uint32 action;
+        } gossip;
+
+        struct
+        {
+            uint32 param1;
+            uint32 param2;
+            uint32 param3;
+            uint32 param4;
+        } raw;
+    };
+};
+
+enum SMART_SCRIPT_RESPAWN_CONDITION
+{
+    SMART_SCRIPT_RESPAWN_CONDITION_NONE = 0,
+    SMART_SCRIPT_RESPAWN_CONDITION_MAP = 1,
+    SMART_SCRIPT_RESPAWN_CONDITION_AREA = 2,
+    SMART_SCRIPT_RESPAWN_CONDITION_END = 3,
+};
+
+enum SMART_ACTION
+{
+    SMART_ACTION_NONE                               = 0,      //1          // No action
+    SMART_ACTION_TALK                               = 1,      //1          // groupID from creature_text
+    SMART_ACTION_SET_FACTION                        = 2,      //1          // FactionId (or 0 for default)
+    SMART_ACTION_MORPH_TO_ENTRY_OR_MODEL            = 3,      //1          // Creature_template entry(param1) OR ModelId (param2) (or 0 for both to demorph)
+    SMART_ACTION_SOUND                              = 4,      //1          // SoundId, TextRange
+    SMART_ACTION_PLAY_EMOTE                         = 5,      //1          // EmoteId
+    SMART_ACTION_FAIL_QUEST                         = 6,      //1          //QuestID
+    SMART_ACTION_ADD_QUEST                          = 7,      //1          //QuestID
+    SMART_ACTION_SET_REACT_STATE                    = 8,      //1          // state
+    SMART_ACTION_ACTIVATE_GOBJECT                   = 9,      //1          // Target, TargetVar1,  TargetVar2,  TargetVar3
+    SMART_ACTION_RANDOM_EMOTE                       = 10,     //1          // EmoteId1, EmoteId2, EmoteId3...
+    SMART_ACTION_CAST                               = 11,     //1          // SpellId, CastFlags, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_SUMMON_CREATURE                    = 12,     //1          // CreatureID,summonType, duration in ms, storageID, attackInvoker, Target(place), TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_THREAT_SINGLE_PCT                  = 13,     //1          // Threat%, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_THREAT_ALL_PCT                     = 14,     //1          // Threat%
+    SMART_ACTION_CALL_AREAEXPLOREDOREVENTHAPPENS    = 15,     //1          // QuestID, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_SEND_CASTCREATUREORGO              = 16,     //1          // QuestID, SpellId, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_SET_EMOTE_STATE                    = 17,     //1          // emoteID
+    SMART_ACTION_SET_UNIT_FLAG                      = 18,     //1          // Flags (may be more than one field OR'd together), Target
+    SMART_ACTION_REMOVE_UNIT_FLAG                   = 19,     //1          // Flags (may be more than one field OR'd together), Target
+    SMART_ACTION_AUTO_ATTACK                        = 20,     //1          // AllowAttackState (0 = stop attack, anything else means continue attacking)
+    SMART_ACTION_ALLOW_COMBAT_MOVEMENT              = 21,     //1          // AllowCombatMovement (0 = stop combat based movement, anything else continue attacking)
+    SMART_ACTION_SET_EVENT_PHASE                    = 22,     //1          // Phase
+    SMART_ACTION_INC_EVENT_PHASE                    = 23,     //1          // Value (may be negative to decrement phase, should not be 0)
+    SMART_ACTION_EVADE                              = 24,     //1          // No Params
+    SMART_ACTION_FLEE_FOR_ASSIST                    = 25,     //1          // No Params
+    SMART_ACTION_CALL_GROUPEVENTHAPPENS             = 26,     //1          // QuestID 
+    SMART_ACTION_CALL_CASTEDCREATUREORGO            = 27,     //1          // CreatureId, SpellId
+    SMART_ACTION_REMOVEAURASFROMSPELL               = 28,     //1          // Spellid, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_FOLLOW                             = 29,     //1          // Distance, Angle, EndCreatureEntry, credit, creditType (0monsterkill,1event) Target(uses first found), TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_RANDOM_PHASE                       = 30,     //1          // PhaseId1, PhaseId2, PhaseId3...
+    SMART_ACTION_RANDOM_PHASE_RANGE                 = 31,     //1          // PhaseMin, PhaseMax
+    SMART_ACTION_RESET_GOBJECT                      = 32,     //1          // Target, TargetVar1,  TargetVar2,  TargetVar3    
+    SMART_ACTION_CALL_KILLEDMONSTER                 = 33,     //1          // CreatureId, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_SET_INST_DATA                      = 34,     //1          // Field, Data
+    SMART_ACTION_SET_INST_DATA64                    = 35,     //1          // Field, Target(uses first found), TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_UPDATE_TEMPLATE                    = 36,     //1          // Entry, Team
+    SMART_ACTION_DIE                                = 37,     //1          // No Params
+    SMART_ACTION_SET_IN_COMBAT_WITH_ZONE            = 38,     //1          // No Params
+    SMART_ACTION_CALL_FOR_HELP                      = 39,     //1          // Radius
+    SMART_ACTION_SET_SHEATH                         = 40,     //1          // Sheath (0-passive,1-melee,2-ranged)
+    SMART_ACTION_FORCE_DESPAWN                      = 41,     //1          // timer
+    SMART_ACTION_SET_INVINCIBILITY_HP_LEVEL         = 42,     //1          // MinHpValue(+pct, -flat)
+    SMART_ACTION_MOUNT_TO_ENTRY_OR_MODEL            = 43,     //1          // Creature_template entry(param1) OR ModelId (param2) (or 0 for both to unmount)
+    SMART_ACTION_SET_INGAME_PHASE_MASK              = 44,     //1          // mask
+
+    SMART_ACTION_SET_DATA                           = 45,     //1          // Field, Data (only creature TODO)
+    SMART_ACTION_MOVE_FORWARD                  = 46,     //1          // distance
+    SMART_ACTION_SET_VISIBILITY                     = 47,     //1          // on/off
+    SMART_ACTION_SET_ACTIVE                         = 48,     //1          // No Params    
+    SMART_ACTION_ATTACK_START                       = 49,     //1          // Target(uses first found), TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_SUMMON_GO                          = 50,     //1          // GameObjectID, DespawnTime in ms, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_KILL_UNIT                          = 51,     //1          // Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_WP_LOAD                            = 52,     //1          // pathID
+    SMART_ACTION_WP_START                           = 53,     //1          // run/walk, pathID, canRepeat, Target(used for escort quests), TargetVar1,  TargetVar2,  TargetVar3 + uses xyzo, quest, despawntime
+    SMART_ACTION_WP_PAUSE                           = 54,     //1          // time
+    SMART_ACTION_WP_STOP                            = 55,     //1          // despawnTime, quest, fail?
+    SMART_ACTION_ADD_ITEM                           = 56,     //1          // itemID, count, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_REMOVE_ITEM                        = 57,     //1          // itemID, count, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_INSTALL_AI_TEMPLATE                = 58,     //1          // AITemplateID
+    SMART_ACTION_SET_RUN                            = 59,     //1          // 0/1
+    SMART_ACTION_SET_FLY                            = 60,     //1          // 0/1
+    SMART_ACTION_SET_SWIMM                          = 61,     //1          // 0/1
+    SMART_ACTION_TELEPORT                           = 62,     //1          // mapID, Target, TargetVar1,  TargetVar2,  TargetVar3 + uses xyzo
+    SMART_ACTION_STORE_VARIABLE_DECIMAL             = 63,     //1          // varID, number
+    SMART_ACTION_STORE_TARGET_LIST                  = 64,     //1          // varID, Target, TargetVar1,  TargetVar2,  TargetVar3 
+    SMART_ACTION_WP_RESUME                          = 65,     //1          // none
+    SMART_ACTION_SET_ORIENTATION                    = 66,     //1          // Target, TargetVar1,  TargetVar2,  TargetVar3, orientation (used if target -1 or 0)
+    
+    SMART_ACTION_CREATE_TIMED_EVENT                 = 67,     //1           // id, InitialMin, InitialMax, RepeatMin(only if it repeats), RepeatMax(only if it repeats), chance
+    SMART_ACTION_PLAYMOVIE                          = 68,     //1           // entry
+    SMART_ACTION_MOVE_TO_POS                        = 69,     //1           // xyz
+    SMART_ACTION_RESPAWN_TARGET                     = 70,     //1           // Target, TargetVar1,  TargetVar2,  TargetVar3,
+    SMART_ACTION_EQUIP                              = 71,     //1           // entry slot1,slot2,slot3
+    SMART_ACTION_CLOSE_GOSSIP                       = 72,     //1           // none
+    SMART_ACTION_TRIGGER_TIMED_EVENT                = 73,     //1           // id(>1)
+    SMART_ACTION_REMOVE_TIMED_EVENT                 = 74,     //1           // id(>1)
+    SMART_ACTION_ADD_AURA                           = 75,     //1           // spellid,  targets
+    SMART_ACTION_OVERRIDE_SCRIPT_BASE_OBJECT        = 76,     //1           // target(first found used), WARNING: CAN CRASH CORE, do not use if you dont know what you are doing
+    SMART_ACTION_RESET_SCRIPT_BASE_OBJECT           = 77,     //1           // none
+    SMART_ACTION_CALL_SCRIPT_RESET                  = 78,     //1           // none
+    SMART_ACTION_END                                = 79,
+};
+
+struct SmartAction
+{
+    SMART_ACTION type;
+
+    union
+    {
+        struct
+        {
+            uint32 textGroupID1;
+            uint32 textGroupID2;
+            uint32 textGroupID3;
+            uint32 textGroupID4;
+            uint32 textGroupID5;
+            uint32 textGroupID6;
+        } talk;
+
+        struct
+        {
+            uint32 factionID;
+        } faction;
+        
+        struct
+        {
+            uint32 creature;
+            uint32 model;
+        } morphOrMount;
+
+        struct
+        {
+            uint32 sound;
+            uint32 range;
+        } sound;
+
+        struct
+        {
+            uint32 emote;
+        } emote;
+
+        struct
+        {
+            uint32 quest;
+        } quest;
+
+        struct
+        {
+            uint32 state;
+        } react;
+
+        struct
+        {
+            
+            uint32 emote1;
+            uint32 emote2;
+            uint32 emote3;
+            uint32 emote4;
+            uint32 emote5;
+            uint32 emote6;
+        } randomEmote;
+
+        struct
+        {
+            uint32 spell;
+            uint32 flags;
+        } cast;
+
+        struct
+        {
+            uint32 creature;
+            uint32 type;
+            uint32 duration;
+            uint32 storageID;
+            uint32 attackInvoker;
+        } summonCreature;
+
+        struct
+        {
+            uint32 threatINC;
+            uint32 threatDEC;
+        } threatPCT;
+
+        struct
+        {
+            uint32 quest;
+            uint32 spell;
+        } castCreatureOrGO;
+
+        struct
+        {
+            uint32 flag1;
+            uint32 flag2;
+            uint32 flag3;
+            uint32 flag4;
+            uint32 flag5;
+            uint32 flag6;
+        } addUnitFlag;
+
+        struct
+        {
+            uint32 flag1;
+            uint32 flag2;
+            uint32 flag3;
+            uint32 flag4;
+            uint32 flag5;
+            uint32 flag6;
+        } removeUnitFlag;
+
+        struct
+        {
+            uint32 attack;
+        } autoAttack;
+
+        struct
+        {
+            uint32 move;
+        } combatMove;
+
+        struct
+        {
+            uint32 phase;
+        } setEventPhase;
+
+        struct
+        {
+            uint32 inc;
+            uint32 dec;
+        } incEventPhase;
+
+        struct
+        {
+            uint32 creature;
+            uint32 spell;
+        } castedCreatureOrGO;
+
+        struct
+        {
+            uint32 spell;
+        } removeAura;
+
+        struct
+        {
+            uint32 dist;
+            uint32 angle;
+            uint32 entry;
+            uint32 credit;
+            uint32 creditType;
+        } follow;
+
+        struct
+        {
+            uint32 phase1;
+            uint32 phase2;
+            uint32 phase3;
+            uint32 phase4;
+            uint32 phase5;
+            uint32 phase6;
+        } randomPhase;
+
+        struct
+        {
+            uint32 phaseMin;
+            uint32 phaseMax;
+        } randomPhaseRange;
+
+        struct
+        {
+            uint32 creature;
+        } killedMonster;
+
+        struct
+        {
+            uint32 field;
+            uint32 data;
+        } setInstanceData;
+
+        struct
+        {
+            uint32 field;
+        } setInstanceData64;
+
+        struct
+        {
+            uint32 creature;
+            uint32 team;
+        } updateTemplate;
+
+        struct
+        {
+            uint32 range;
+        } callHelp;
+
+        struct
+        {
+            uint32 sheath;
+        } setSheath;
+
+        struct
+        {
+            uint32 delay;
+        } forceDespawn;
+
+        struct
+        {
+            uint32 minHP;
+            uint32 percent;
+        } invincHP;
+
+        struct
+        {
+            uint32 mask;
+        } ingamePhaseMask;
+
+        struct
+        {
+            uint32 field;
+            uint32 data;
+        } setData;
+
+        struct
+        {
+            uint32 distance;
+        } moveRandom;
+
+        struct
+        {
+            uint32 state;
+        } visibility;
+
+        struct
+        {
+            uint32 entry;
+            uint32 despawnTime;
+        } summonGO;
+
+        struct
+        {
+            uint32 id;
+        } wpLoad;
+        
+
+        struct
+        {
+            uint32 run;
+            uint32 pathID;
+            uint32 repeat;
+            uint32 quest;
+            uint32 despawnTime;
+            uint32 reactState;
+        } wpStart;
+
+        struct
+        {
+            uint32 delay;
+        } wpPause;
+
+        struct
+        {
+            uint32 despawnTime;
+            uint32 quest;
+            uint32 fail;
+        } wpStop;
+
+        struct
+        {
+            uint32 entry;
+            uint32 count;
+        } item;
+
+        struct
+        {
+            uint32 id;
+            uint32 param1;
+            uint32 param2;
+            uint32 param3;
+            uint32 param4;
+            uint32 param5;
+        } installTtemplate;
+
+        struct
+        {
+            uint32 run;
+        } setRun;
+
+        struct
+        {
+            uint32 fly;
+        } setFly;
+
+        struct
+        {
+            uint32 swimm;
+        } setSwimm;
+
+        struct
+        {
+            uint32 mapID;
+        } teleport;
+
+        struct
+        {
+            uint32 id;
+            uint32 number;
+        } storeVar;
+
+        struct
+        {
+            uint32 id;
+        } storeTargets;
+        
+
+        struct
+        {
+            uint32 id;
+            uint32 min;
+            uint32 max;
+            uint32 repeatMin;
+            uint32 repeatMax;
+            uint32 chance;
+        } timeEvent;
+
+        struct
+        {
+            uint32 entry;
+        } movie;
+
+        struct
+        {
+            uint32 entry;
+            uint32 slot1;
+            uint32 slot2;
+            uint32 slot3;
+        } equip;
+        
+        struct
+        {
+            uint32 flag;
+        } unitFlag;
+
+        struct
+        {
+            uint32 param1;
+            uint32 param2;
+            uint32 param3;
+            uint32 param4;
+            uint32 param5;
+            uint32 param6;
+        } raw;
+    };
+};
+
+enum SMARTAI_TEMPLATE
+{
+    SMARTAI_TEMPLATE_BASIC          = 0, //nothing is preset
+    SMARTAI_TEMPLATE_CASTER         = 1, //spellid, repeatMin, repeatMax, range, manaPCT +JOIN: target_param1 as castFlag
+    SMARTAI_TEMPLATE_TURRET         = 2, //spellid, repeatMin, repeatMax +JOIN: target_param1 as castFlag
+    SMARTAI_TEMPLATE_PASSIVE        = 3, 
+    SMARTAI_TEMPLATE_CAGED_GO_PART  = 4, //creatureID, give credit at point end?, 
+    SMARTAI_TEMPLATE_CAGED_NPC_PART = 5, //gameObjectID, despawntime, run?, dist, TextGroupID
+    SMARTAI_TEMPLATE_END            = 6,
+};
+
+enum SMARTAI_TARGETS
+{
+    SMART_TARGET_NONE                           = 0,    // NONE, defaulting to invoket
+    SMART_TARGET_SELF                           = 1,    // Self cast
+    SMART_TARGET_VICTIM                         = 2,    // Our current target (ie: highest aggro)
+    SMART_TARGET_HOSTILE_SECOND_AGGRO           = 3,    // Second highest aggro
+    SMART_TARGET_HOSTILE_LAST_AGGRO             = 4,    // Dead last on aggro
+    SMART_TARGET_HOSTILE_RANDOM                 = 5,    // Just any random target on our threat list
+    SMART_TARGET_HOSTILE_RANDOM_NOT_TOP         = 6,    // Any random target except top threat
+    SMART_TARGET_ACTION_INVOKER                 = 7,    // Unit who caused this Event to occur
+    SMART_TARGET_POSITION                       = 8,    // use xyz from event params
+    SMART_TARGET_CREATURE_RANGE                 = 9,    // CreatureEntry(0any), minDist, maxDist
+    SMART_TARGET_CREATURE_GUID                  = 10,   // guid, entry
+    SMART_TARGET_CREATURE_DISTANCE              = 11,   // CreatureEntry(0any), maxDist
+    SMART_TARGET_STORED                         = 12,   // id, uses pre-stored target(list)
+    SMART_TARGET_GAMEOBJECT_RANGE               = 13,   // entry(0any), min, max
+    SMART_TARGET_GAMEOBJECT_GUID                = 14,   // guid, entry
+    SMART_TARGET_GAMEOBJECT_DISTANCE            = 15,   // entry(0any), maxDist
+    SMART_TARGET_INVOKER_PARTY                  = 16,   // invoker's party members
+    SMART_TARGET_PLAYER_RANGE                   = 17,   // min, max
+    SMART_TARGET_PLAYER_DISTANCE                = 18,   // maxDist
+    SMART_TARGET_CLOSEST_CREATURE               = 19,   // CreatureEntry(0any)
+    SMART_TARGET_CLOSEST_GAMEOBJECT             = 20,   // entry(0any)
+    SMART_TARGET_CLOSEST_PLAYER                 = 21,   // none
+    SMART_TARGET_END                            = 22,
+};
+
+struct SmartTarget
+{
+    SmartTarget (SMARTAI_TARGETS t = SMART_TARGET_NONE, uint32 p1 = 0, uint32 p2 = 0, uint32 p3 = 0)
+    {
+        type = t;
+        raw.param1 = p1;
+        raw.param2 = p2;
+        raw.param3 = p3;
+    }
+    SMARTAI_TARGETS type;
+    float x,y,z,o;
+    union
+    {
+        struct
+        {
+            uint32 creature;
+            uint32 minDist;
+            uint32 maxDist;
+        } unitRange;
+
+        struct
+        {
+            uint32 guid;
+            uint32 entry;
+        } unitGUID;
+
+        struct
+        {
+            uint32 creature;
+            uint32 dist;
+        } unitDistance;
+
+        struct
+        {
+            uint32 dist;
+        } playerDistance;
+
+        struct
+        {
+            uint32 minDist;
+            uint32 maxDist;
+        } playerRange;
+
+        struct
+        {
+            uint32 id;
+        } stored;
+
+        struct
+        {
+            uint32 entry;
+            uint32 minDist;
+            uint32 maxDist;
+        } goRange;
+
+        struct
+        {
+            uint32 guid;
+            uint32 entry;
+        } goGUID;
+
+        struct
+        {
+            uint32 entry;
+            uint32 dist;
+        } goDistance;
+
+        struct
+        {
+            uint32 map;
+        } position;
+
+        struct
+        {
+            uint32 entry;
+            uint32 dist;
+            uint32 dead;
+        } closest;
+
+        struct
+        {
+            uint32 param1;
+            uint32 param2;
+            uint32 param3;
+        } raw;
+    };
+};
+
+enum eSmartAI
+{
+    SMART_EVENT_PARAM_COUNT = 4,
+    SMART_ACTION_PARAM_COUNT = 6,
+    SMART_SUMMON_COUNTER = 0xFFFFFF,
+    SMART_ESCORT_LAST_OOC_POINT = 0xFFFFFF,
+    SMART_RANDOM_POINT = 0xFFFFFE,
+    SMART_ESCORT_TARGETS = 0xFFFFFF
+};
+
+enum SmartScriptType
+{
+    SMART_SCRIPT_TYPE_CREATURE = 0,//done
+    SMART_SCRIPT_TYPE_GAMEOBJECT = 1,//done
+    SMART_SCRIPT_TYPE_AREATRIGGER = 2,//done
+    SMART_SCRIPT_TYPE_EVENT = 3,// 
+    SMART_SCRIPT_TYPE_GOSSIP = 4,//
+    SMART_SCRIPT_TYPE_QUEST = 5,//
+    SMART_SCRIPT_TYPE_SPELL = 6,//
+    SMART_SCRIPT_TYPE_TRANSPORT = 7,//
+    SMART_SCRIPT_TYPE_INSTANCE = 8,//
+    SMART_SCRIPT_TYPE_MAX = 9
+};
+
+enum SmartAITypeMaskId
+{
+    SMART_SCRIPT_TYPE_MASK_CREATURE = 1,
+    SMART_SCRIPT_TYPE_MASK_GAMEOBJECT = 2,
+    SMART_SCRIPT_TYPE_MASK_AREATRIGGER = 4,
+    SMART_SCRIPT_TYPE_MASK_EVENT = 8,
+    SMART_SCRIPT_TYPE_MASK_GOSSIP = 16,
+    SMART_SCRIPT_TYPE_MASK_QUEST = 32,
+    SMART_SCRIPT_TYPE_MASK_SPELL = 64,
+    SMART_SCRIPT_TYPE_MASK_TRANSPORT = 128,
+    SMART_SCRIPT_TYPE_MASK_INSTANCE = 256,
+};
+
+const uint32 SmartAITypeMask[SMART_SCRIPT_TYPE_MAX][2] =
+{
+    {SMART_SCRIPT_TYPE_CREATURE,      SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_SCRIPT_TYPE_GAMEOBJECT,    SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_SCRIPT_TYPE_AREATRIGGER,   SMART_SCRIPT_TYPE_MASK_AREATRIGGER },
+    {SMART_SCRIPT_TYPE_EVENT,         SMART_SCRIPT_TYPE_MASK_EVENT },
+    {SMART_SCRIPT_TYPE_GOSSIP,        SMART_SCRIPT_TYPE_MASK_GOSSIP },
+    {SMART_SCRIPT_TYPE_QUEST,         SMART_SCRIPT_TYPE_MASK_QUEST },
+    {SMART_SCRIPT_TYPE_SPELL,         SMART_SCRIPT_TYPE_MASK_SPELL },
+    {SMART_SCRIPT_TYPE_TRANSPORT,     SMART_SCRIPT_TYPE_MASK_TRANSPORT },
+    {SMART_SCRIPT_TYPE_INSTANCE,      SMART_SCRIPT_TYPE_MASK_INSTANCE }
+};
+
+const uint32 SmartAIEventMask[SMART_EVENT_END][2] =
+{
+    {SMART_EVENT_UPDATE_IC,                 SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_UPDATE_OOC,                SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT + SMART_SCRIPT_TYPE_MASK_INSTANCE },
+    {SMART_EVENT_HEALT_PCT,                 SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_MANA_PCT,                  SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_AGGRO,                     SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_KILL,                      SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_DEATH,                     SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_EVADE,                     SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_SPELLHIT,                  SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_RANGE,                     SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_OOC_LOS,                   SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_RESPAWN,                   SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_TARGET_HEALTH_PCT,         SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_TARGET_CASTING,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_FRIENDLY_HEALTH,           SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_FRIENDLY_IS_CC,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_FRIENDLY_MISSING_BUFF,     SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_SUMMONED_UNIT,             SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_TARGET_MANA_PCT,           SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_ACCEPTED_QUEST,            SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_REWARD_QUEST,              SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_REACHED_HOME,              SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_RECEIVE_EMOTE,             SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_HAS_AURA,                  SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_TARGET_BUFFED,             SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_RESET,                     SMART_SCRIPT_TYPE_MASK_CREATURE },                                         
+    {SMART_EVENT_IC_LOS,                    SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_PASSENGER_BOARDED,         SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_PASSENGER_REMOVED,         SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_CHARMED,                   SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_CHARMED_TARGET,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_SPELLHIT_TARGET,           SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_DAMAGED,                   SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_DAMAGED_TARGET,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_MOVEMENTINFORM,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_SUMMON_DESPAWNED,          SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_CORPSE_REMOVED,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_AI_INIT,                   SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_DATA_SET,                  SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_WAYPOINT_START,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_WAYPOINT_REACHED,          SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_TRANSPORT_ADDPLAYER,       SMART_SCRIPT_TYPE_MASK_TRANSPORT },
+    {SMART_EVENT_TRANSPORT_ADDCREATURE,     SMART_SCRIPT_TYPE_MASK_TRANSPORT },
+    {SMART_EVENT_TRANSPORT_REMOVE_PLAYER,   SMART_SCRIPT_TYPE_MASK_TRANSPORT },
+    {SMART_EVENT_TRANSPORT_RELOCATE,        SMART_SCRIPT_TYPE_MASK_TRANSPORT },
+    {SMART_EVENT_INSTANCE_PLAYER_ENTER,     SMART_SCRIPT_TYPE_MASK_INSTANCE },
+    {SMART_EVENT_AREATRIGGER_ONTRIGGER,     SMART_SCRIPT_TYPE_MASK_AREATRIGGER },
+    {SMART_EVENT_QUEST_ACCEPTED,            SMART_SCRIPT_TYPE_MASK_QUEST },
+    {SMART_EVENT_QUEST_OBJ_COPLETETION,     SMART_SCRIPT_TYPE_MASK_QUEST },
+    {SMART_EVENT_QUEST_REWARDED,            SMART_SCRIPT_TYPE_MASK_QUEST },
+    {SMART_EVENT_QUEST_COMPLETION,          SMART_SCRIPT_TYPE_MASK_QUEST },
+    {SMART_EVENT_QUEST_FAIL,                SMART_SCRIPT_TYPE_MASK_QUEST },
+    {SMART_EVENT_TEXT_OVER,                 SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_RECEIVE_HEAL,              SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_JUST_SUMMONED,             SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_WAYPOINT_PAUSED,           SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_WAYPOINT_RESUMED,          SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_WAYPOINT_STOPPED,          SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_WAYPOINT_ENDED,            SMART_SCRIPT_TYPE_MASK_CREATURE },
+    {SMART_EVENT_TIMED_EVENT_TRIGGERED,     SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_UPDATE,                    SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_LINK,                      SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT + SMART_SCRIPT_TYPE_MASK_AREATRIGGER + SMART_SCRIPT_TYPE_MASK_EVENT + SMART_SCRIPT_TYPE_MASK_GOSSIP + SMART_SCRIPT_TYPE_MASK_QUEST + SMART_SCRIPT_TYPE_MASK_SPELL + SMART_SCRIPT_TYPE_MASK_TRANSPORT + SMART_SCRIPT_TYPE_MASK_INSTANCE },
+    {SMART_EVENT_GOSSIP_SELECT,             SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_JUST_CREATED,              SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+    {SMART_EVENT_GOSSIP_HELLO,              SMART_SCRIPT_TYPE_MASK_CREATURE + SMART_SCRIPT_TYPE_MASK_GAMEOBJECT },
+
+};
+
+enum SmartEventFlags
+{
+    SMART_EVENT_FLAG_NOT_REPEATABLE        = 0x01,                     //Event can not repeat
+    SMART_EVENT_FLAG_DIFFICULTY_0          = 0x02,                     //Event only occurs in instance difficulty 0
+    SMART_EVENT_FLAG_DIFFICULTY_1          = 0x04,                     //Event only occurs in instance difficulty 1
+    SMART_EVENT_FLAG_DIFFICULTY_2          = 0x08,                     //Event only occurs in instance difficulty 2
+    SMART_EVENT_FLAG_DIFFICULTY_3          = 0x10,                     //Event only occurs in instance difficulty 3
+    SMART_EVENT_FLAG_RESERVED_5            = 0x20,
+    SMART_EVENT_FLAG_RESERVED_6            = 0x40,
+    SMART_EVENT_FLAG_DEBUG_ONLY            = 0x80,                     //Event only occurs in debug build
+
+    SMART_EVENT_FLAG_DIFFICULTY_ALL        = (SMART_EVENT_FLAG_DIFFICULTY_0|SMART_EVENT_FLAG_DIFFICULTY_1|SMART_EVENT_FLAG_DIFFICULTY_2|SMART_EVENT_FLAG_DIFFICULTY_3)
+};
+
+enum SmartCastFlags
+{
+    SMARTCAST_INTERRUPT_PREVIOUS     = 0x01,                     //Interrupt any spell casting
+    SMARTCAST_TRIGGERED              = 0x02,                     //Triggered (this makes spell cost zero mana and have no cast time)
+    //CAST_FORCE_CAST             = 0x04,                     //Forces cast even if creature is out of mana or out of range
+    //CAST_NO_MELEE_IF_OOM        = 0x08,                     //Prevents creature from entering melee if out of mana or out of range
+    //CAST_FORCE_TARGET_SELF      = 0x10,                     //Forces the target to cast this spell on itself
+    //CAST_AURA_NOT_PRESENT       = 0x20,                     //Only casts the spell if the target does not have an aura from the spell
+};
+
+// one line in DB is one event
+struct SmartScriptHolder
+{
+    SmartScriptHolder()
+    { 
+        timer = 0;
+        active = false;
+        runOnce = false;
+        link = 0;
+        entryOrGuid = 0;
+        link = 0;
+        event_id = 0;
+    }
+    int32 entryOrGuid;
+    SmartScriptType source_type;
+    uint32 event_id;
+    uint32 link;
+
+    SmartEvent event;
+    SmartAction action;
+    SmartTarget target;
+
+    public:
+        uint32 GetScriptType() { return (uint32)source_type; }
+        uint32 GetEventType() { return (uint32)event.type; }
+        uint32 GetActionType() { return (uint32)action.type; }
+        uint32 GetTargetType() { return (uint32)target.type; }
+
+    uint32 timer;
+    bool active;
+    bool runOnce;
+    
+    
+};
+
+typedef UNORDERED_MAP<uint32, WayPoint*> WPPath;
+
+typedef std::list<WorldObject*> ObjectList;
+typedef UNORDERED_MAP<uint32, ObjectList*> ObjectListMap;
+
+class SmartWaypointMgr
+{
+    friend class ACE_Singleton<SmartWaypointMgr, ACE_Null_Mutex>;
+    SmartWaypointMgr(){};
+    public:
+        ~SmartWaypointMgr(){};
+
+        void LoadFromDB();
+
+        WPPath* GetPath(uint32 id)
+        {
+            if (waypoint_map.find(id) != waypoint_map.end())
+                return waypoint_map[id];
+            else return 0;
+        }
+
+    private:
+        UNORDERED_MAP<uint32, WPPath*> waypoint_map;
+};
+
+// all events for a single entry
+typedef std::vector<SmartScriptHolder> SmartAIEventList;
+
+// all events for all entries / guids
+typedef UNORDERED_MAP<int32, SmartAIEventList> SmartAIEventMap;
+
+class SmartAIMgr
+{
+    friend class ACE_Singleton<SmartAIMgr, ACE_Null_Mutex>;
+    SmartAIMgr(){};
+    public:
+        ~SmartAIMgr(){};
+
+        void LoadSmartAIFromDB();
+
+        SmartAIEventList GetScript(int32 entry, SmartScriptType type)
+        {
+            SmartAIEventList temp;
+            if (mEventMap[uint32(type)].find(entry) != mEventMap[uint32(type)].end())
+                return mEventMap[uint32(type)][entry];
+            else 
+            {
+                if(entry > 0)//first search is for guid (negative), do not drop error if not found
+                    sLog.outError("SmartAIMgr::GetScript: Could not load Script for Entry %d AIType %u.", entry, uint32(type));
+                return temp;
+            }
+        }
+
+    private:
+        //event stores
+        SmartAIEventMap mEventMap[SMART_SCRIPT_TYPE_MAX];
+
+        bool IsEventValid(SmartScriptHolder e);
+        bool IsTargetValid(SmartScriptHolder e);
+        /*inline bool IsTargetValid(SmartScriptHolder e, int32 target)
+        {
+            if (target < SMART_TARGET_NONE || target >= SMART_TARGET_END)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses invalid Target type %d, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), target);
+                return false;
+            }
+            return true;
+        }*/
+        inline bool IsMinMaxValid(SmartScriptHolder e, uint32 min, uint32 max)
+        {
+            if (max < min)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses min/max params wrong (%u/%u), skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), min, max);
+                return false;
+            }
+            return true;
+        }
+        /*inline bool IsPercentValid(SmartScriptHolder e, int32 pct)
+        {
+            if (pct < -100 || pct > 100)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u has invalid Percent set (%d), skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), pct);
+                return false;
+            }
+            return true;
+        }*/
+        inline bool NotNULL(SmartScriptHolder e, uint32 data)
+        {
+            if (!data)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u Parameter can not be NULL, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+                return false;
+            }
+            return true;
+        }
+        inline bool IsCreatureValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sCreatureStorage.LookupEntry<CreatureInfo>(entry))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Creature entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        inline bool IsQuestValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sObjectMgr.GetQuestTemplate(entry))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Quest entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        inline bool IsGameObjectValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sGOStorage.LookupEntry<GameObjectInfo>(uint32(entry)))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent GameObject entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        inline bool IsSpellValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sSpellStore.LookupEntry(entry))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Spell entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        inline bool IsItemValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sItemStore.LookupEntry(entry))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Item entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        inline bool IsConditionValid(SmartScriptHolder e, uint32 t, uint32 v1, uint32 v2, uint32 v3)
+        {
+            bool error = false;
+            if (t > 0 && v1 >= 0 && v2 >= 0 && v3 >= 0)
+            {
+                Condition cond;
+                cond.mConditionType = ConditionType(t);
+                cond.mConditionValue1 = v1;
+                cond.mConditionValue2 = v2;
+                cond.mConditionValue3 = v3;
+                if (!sConditionMgr.isConditionTypeValid(&cond))
+                    error = true;
+            }
+            if (error)
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses invalid Condition, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType());
+                return false;
+            }
+            return true;
+        }
+        inline bool IsEmoteValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sEmotesTextStore.LookupEntry(entry))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Emote entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        inline bool IsAreaTriggerValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sAreaTriggerStore.LookupEntry(entry))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent AreaTrigger entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        inline bool IsSoundValid(SmartScriptHolder e, uint32 entry)
+        {
+            if (!sSoundEntriesStore.LookupEntry(entry))
+            {
+                sLog.outErrorDb("SmartAIMgr: Entry %d SourceType %u Event %u Action %u uses non-existent Sound entry %u, skipped.", e.entryOrGuid, e.GetScriptType(), e.event_id, e.GetActionType(), entry);
+                return false;
+            }
+            return true;
+        }
+        bool IsTextValid(SmartScriptHolder e, uint32 id);
+};
+
+#define sSmartScriptMgr (*ACE_Singleton<SmartAIMgr, ACE_Null_Mutex>::instance())
+#define sSmartWaypointMgr (*ACE_Singleton<SmartWaypointMgr, ACE_Null_Mutex>::instance())
+#endif
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -130,7 +130,7 @@
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
-  ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds
   ${CMAKE_CURRENT_SOURCE_DIR}/Battlegrounds/Zones
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -529,7 +529,8 @@
         { "reserved_name",               SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadReservedNameCommand,            "", NULL },
         { "reputation_reward_rate",      SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadReputationRewardRateCommand,    "", NULL },
         { "reputation_spillover_template",SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadReputationRewardRateCommand,    "", NULL },
-        { "skill_discovery_template",    SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSkillDiscoveryTemplateCommand,  "", NULL },
+        { "smartai_scripts",              SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSmartAI,                        "", NULL },
+		{ "skill_discovery_template",    SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSkillDiscoveryTemplateCommand,  "", NULL },
         { "skill_extra_item_template",   SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSkillExtraItemTemplateCommand,  "", NULL },
         { "skill_fishing_base_level",    SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadSkillFishingBaseLevelCommand,   "", NULL },
         { "skinning_loot_template",      SEC_ADMINISTRATOR, true,  &ChatHandler::HandleReloadLootTemplatesSkinningCommand,   "", NULL },
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -452,6 +452,7 @@
         bool HandleReloadWpScriptsCommand(const char* args);
         bool HandleReloadConditions(const char* args);
         bool HandleReloadCreatureText(const char* args);
+		bool HandleReloadSmartAI(const char* args);
        
         bool HandleResetAchievementsCommand(const char * args);
         bool HandleResetAllCommand(const char * args);
diff --git a/src/server/game/Chat/Commands/Level3.cpp b/src/server/game/Chat/Commands/Level3.cpp
--- a/src/server/game/Chat/Commands/Level3.cpp
+++ b/src/server/game/Chat/Commands/Level3.cpp
@@ -61,6 +61,7 @@
 #include "ScriptMgr.h"
 #include "LFGMgr.h"
 #include "CreatureTextMgr.h"
+#include "SmartAI.h"
 
 //reload commands
 bool ChatHandler::HandleReloadAllCommand(const char*)
@@ -1179,6 +1180,14 @@
     return true;
 }
 
+bool ChatHandler::HandleReloadSmartAI(const char* /*args*/)
+{
+	sLog.outString("Re-Loading SmartAI Scripts...");
+	sSmartScriptMgr.LoadSmartAIFromDB();
+	SendGlobalGMSysMessage("SmartAI Scripts reloaded.");
+	return true;
+}
+
 bool ChatHandler::HandleAccountSetGmLevelCommand(const char *args)
 {
     if (!*args)
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -44,6 +44,7 @@
 void AddSC_item_spell_scripts();
 void AddSC_example_spell_scripts();
 
+void AddSC_SmartSCripts();
 
 #ifdef SCRIPTS
 //world
@@ -63,13 +64,7 @@
 void AddSC_achievement_scripts();
 void AddSC_npc_customize();
 void AddSC_dungeon_finder();
-void AddSC_pvp_system();
 
-//guildhouse
-void AddSC_guildmaster();
-
-//hunter
-void AddSC_npc_buffnpc();
 
 //eastern kingdoms
 void AddSC_alterac_valley();                 //Alterac Valley
@@ -596,6 +591,7 @@
 {
     AddExampleScripts();
     AddSpellScripts();
+	AddSC_SmartSCripts();
 #ifdef SCRIPTS
     AddWorldScripts();
     AddEasternKingdomsScripts();
@@ -605,11 +601,6 @@
     AddBattlegroundScripts();
     AddOutdoorPvPScripts();
     AddCustomScripts();
-	//guildhouse
-	AddSC_guildmaster();
-
-	//hunter
-    AddSC_npc_buffnpc();
 	
 #endif
 }
@@ -661,7 +652,6 @@
     AddSC_chat_log();
 	AddSC_npc_customize();
 	AddSC_dungeon_finder();
-    AddSC_pvp_system();
 	
 #endif
 }
diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
@@ -50,6 +50,7 @@
 #include "MapManager.h"
 #include "InstanceScript.h"
 #include "LFGMgr.h"
+#include "GameObjectAI.h"
 
 void WorldSession::HandleRepopRequestOpcode(WorldPacket & recv_data)
 {
@@ -144,8 +145,11 @@
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
         else
+		{
             sScriptMgr.OnGossipSelectCode(_player, go, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId), code.c_str());
-    }
+            go->AI()->GossipSelectCode(_player, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId), code.c_str());
+		}
+		}
     else
     {
         if (unit)
@@ -154,8 +158,11 @@
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
         else
+		{
             sScriptMgr.OnGossipSelect(_player, go, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId));
-    }
+    go->AI()->GossipSelect(_player, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId));
+		}
+		}
 }
 
 void WorldSession::HandleWhoOpcode(WorldPacket & recv_data)
diff --git a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/QuestHandler.cpp
@@ -34,6 +34,9 @@
 #include "BattlegroundAV.h"
 #include "ScriptMgr.h"
 #include "ConditionMgr.h"
+#include "Creature.h"
+#include "CreatureAI.h"
+#include "GameObjectAI.h"
 
 void WorldSession::HandleQuestgiverStatusQueryOpcode(WorldPacket & recv_data)
 {
@@ -214,6 +217,7 @@
                 }
                 case TYPEID_GAMEOBJECT:
                     sScriptMgr.OnQuestAccept(_player, ((GameObject*)pObject), qInfo);
+					(pObject->ToGameObject())->AI()->QuestAccept(_player, qInfo);
                     break;
                 default:
                     break;
@@ -318,6 +322,7 @@
                         // Send next quest
                         if (Quest const* nextquest = _player->GetNextQuest(guid ,pQuest))
                             _player->PlayerTalkClass->SendQuestGiverQuestDetails(nextquest,guid,true);
+						 pObject->ToGameObject()->AI()->QuestReward(_player, pQuest, reward);
                     }
                     break;
                 case TYPEID_GAMEOBJECT:
diff --git a/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp b/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp
@@ -32,6 +32,7 @@
 #include "SpellAuras.h"
 #include "CreatureAI.h"
 #include "ScriptMgr.h"
+#include "GameObjectAI.h"
 
 void WorldSession::HandleClientCastFlags(WorldPacket& recvPacket, uint8 castFlags, SpellCastTargets & targets)
 {
@@ -295,6 +296,8 @@
     if (sScriptMgr.OnGossipHello(_player, obj))
         return;
 
+obj->AI()->GossipHello(_player);
+
     obj->Use(_player);
 }
 
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -1,4548 +1,4551 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "WorldPacket.h"
-#include "Opcodes.h"
-#include "Log.h"
-#include "UpdateMask.h"
-#include "World.h"
-#include "ObjectMgr.h"
-#include "SpellMgr.h"
-#include "Player.h"
-#include "SkillExtraItems.h"
-#include "Unit.h"
-#include "Spell.h"
-#include "DynamicObject.h"
-#include "SpellAuras.h"
-#include "SpellAuraEffects.h"
-#include "Group.h"
-#include "UpdateData.h"
-#include "MapManager.h"
-#include "ObjectAccessor.h"
-#include "SharedDefines.h"
-#include "Pet.h"
-#include "GameObject.h"
-#include "GossipDef.h"
-#include "Creature.h"
-#include "Totem.h"
-#include "CreatureAI.h"
-#include "BattlegroundMgr.h"
-#include "Battleground.h"
-#include "BattlegroundEY.h"
-#include "BattlegroundWS.h"
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPWG.h"
-#include "Language.h"
-#include "SocialMgr.h"
-#include "Util.h"
-#include "VMapFactory.h"
-#include "TemporarySummon.h"
-#include "CellImpl.h"
-#include "GridNotifiers.h"
-#include "GridNotifiersImpl.h"
-#include "SkillDiscovery.h"
-#include "Formulas.h"
-#include "Vehicle.h"
-#include "ScriptMgr.h"
-
-pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
-{
-    &Spell::EffectNULL,                                     //  0
-    &Spell::EffectInstaKill,                                //  1 SPELL_EFFECT_INSTAKILL
-    &Spell::EffectSchoolDMG,                                //  2 SPELL_EFFECT_SCHOOL_DAMAGE
-    &Spell::EffectDummy,                                    //  3 SPELL_EFFECT_DUMMY
-    &Spell::EffectUnused,                                   //  4 SPELL_EFFECT_PORTAL_TELEPORT          unused
-    &Spell::EffectTeleportUnits,                            //  5 SPELL_EFFECT_TELEPORT_UNITS
-    &Spell::EffectApplyAura,                                //  6 SPELL_EFFECT_APPLY_AURA
-    &Spell::EffectEnvirinmentalDMG,                         //  7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
-    &Spell::EffectPowerDrain,                               //  8 SPELL_EFFECT_POWER_DRAIN
-    &Spell::EffectHealthLeech,                              //  9 SPELL_EFFECT_HEALTH_LEECH
-    &Spell::EffectHeal,                                     // 10 SPELL_EFFECT_HEAL
-    &Spell::EffectBind,                                     // 11 SPELL_EFFECT_BIND
-    &Spell::EffectNULL,                                     // 12 SPELL_EFFECT_PORTAL
-    &Spell::EffectUnused,                                   // 13 SPELL_EFFECT_RITUAL_BASE              unused
-    &Spell::EffectUnused,                                   // 14 SPELL_EFFECT_RITUAL_SPECIALIZE        unused
-    &Spell::EffectUnused,                                   // 15 SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL   unused
-    &Spell::EffectQuestComplete,                            // 16 SPELL_EFFECT_QUEST_COMPLETE
-    &Spell::EffectWeaponDmg,                                // 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
-    &Spell::EffectResurrect,                                // 18 SPELL_EFFECT_RESURRECT
-    &Spell::EffectAddExtraAttacks,                          // 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
-    &Spell::EffectUnused,                                   // 20 SPELL_EFFECT_DODGE                    one spell: Dodge
-    &Spell::EffectUnused,                                   // 21 SPELL_EFFECT_EVADE                    one spell: Evade (DND)
-    &Spell::EffectParry,                                    // 22 SPELL_EFFECT_PARRY
-    &Spell::EffectBlock,                                    // 23 SPELL_EFFECT_BLOCK                    one spell: Block
-    &Spell::EffectCreateItem,                               // 24 SPELL_EFFECT_CREATE_ITEM
-    &Spell::EffectUnused,                                   // 25 SPELL_EFFECT_WEAPON
-    &Spell::EffectUnused,                                   // 26 SPELL_EFFECT_DEFENSE                  one spell: Defense
-    &Spell::EffectPersistentAA,                             // 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
-    &Spell::EffectSummonType,                               // 28 SPELL_EFFECT_SUMMON
-    &Spell::EffectLeap,                                     // 29 SPELL_EFFECT_LEAP
-    &Spell::EffectEnergize,                                 // 30 SPELL_EFFECT_ENERGIZE
-    &Spell::EffectWeaponDmg,                                // 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
-    &Spell::EffectTriggerMissileSpell,                      // 32 SPELL_EFFECT_TRIGGER_MISSILE
-    &Spell::EffectOpenLock,                                 // 33 SPELL_EFFECT_OPEN_LOCK
-    &Spell::EffectSummonChangeItem,                         // 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
-    &Spell::EffectApplyAreaAura,                            // 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
-    &Spell::EffectLearnSpell,                               // 36 SPELL_EFFECT_LEARN_SPELL
-    &Spell::EffectUnused,                                   // 37 SPELL_EFFECT_SPELL_DEFENSE            one spell: SPELLDEFENSE (DND)
-    &Spell::EffectDispel,                                   // 38 SPELL_EFFECT_DISPEL
-    &Spell::EffectUnused,                                   // 39 SPELL_EFFECT_LANGUAGE
-    &Spell::EffectDualWield,                                // 40 SPELL_EFFECT_DUAL_WIELD
-    &Spell::EffectJump,                                     // 41 SPELL_EFFECT_JUMP
-    &Spell::EffectJumpDest,                                 // 42 SPELL_EFFECT_JUMP_DEST
-    &Spell::EffectTeleUnitsFaceCaster,                      // 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
-    &Spell::EffectLearnSkill,                               // 44 SPELL_EFFECT_SKILL_STEP
-    &Spell::EffectAddHonor,                                 // 45 SPELL_EFFECT_ADD_HONOR                honor/pvp related
-    &Spell::EffectUnused,                                   // 46 SPELL_EFFECT_SPAWN clientside, unit appears as if it was just spawned
-    &Spell::EffectTradeSkill,                               // 47 SPELL_EFFECT_TRADE_SKILL
-    &Spell::EffectUnused,                                   // 48 SPELL_EFFECT_STEALTH                  one spell: Base Stealth
-    &Spell::EffectUnused,                                   // 49 SPELL_EFFECT_DETECT                   one spell: Detect
-    &Spell::EffectTransmitted,                              // 50 SPELL_EFFECT_TRANS_DOOR
-    &Spell::EffectUnused,                                   // 51 SPELL_EFFECT_FORCE_CRITICAL_HIT       unused
-    &Spell::EffectUnused,                                   // 52 SPELL_EFFECT_GUARANTEE_HIT            one spell: zzOLDCritical Shot
-    &Spell::EffectEnchantItemPerm,                          // 53 SPELL_EFFECT_ENCHANT_ITEM
-    &Spell::EffectEnchantItemTmp,                           // 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
-    &Spell::EffectTameCreature,                             // 55 SPELL_EFFECT_TAMECREATURE
-    &Spell::EffectSummonPet,                                // 56 SPELL_EFFECT_SUMMON_PET
-    &Spell::EffectLearnPetSpell,                            // 57 SPELL_EFFECT_LEARN_PET_SPELL
-    &Spell::EffectWeaponDmg,                                // 58 SPELL_EFFECT_WEAPON_DAMAGE
-    &Spell::EffectCreateRandomItem,                         // 59 SPELL_EFFECT_CREATE_RANDOM_ITEM       create item base at spell specific loot
-    &Spell::EffectProficiency,                              // 60 SPELL_EFFECT_PROFICIENCY
-    &Spell::EffectSendEvent,                                // 61 SPELL_EFFECT_SEND_EVENT
-    &Spell::EffectPowerBurn,                                // 62 SPELL_EFFECT_POWER_BURN
-    &Spell::EffectThreat,                                   // 63 SPELL_EFFECT_THREAT
-    &Spell::EffectTriggerSpell,                             // 64 SPELL_EFFECT_TRIGGER_SPELL
-    &Spell::EffectApplyAreaAura,                            // 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
-    &Spell::EffectRechargeManaGem,                          // 66 SPELL_EFFECT_CREATE_MANA_GEM          (possibly recharge it, misc - is item ID)
-    &Spell::EffectHealMaxHealth,                            // 67 SPELL_EFFECT_HEAL_MAX_HEALTH
-    &Spell::EffectInterruptCast,                            // 68 SPELL_EFFECT_INTERRUPT_CAST
-    &Spell::EffectDistract,                                 // 69 SPELL_EFFECT_DISTRACT
-    &Spell::EffectPull,                                     // 70 SPELL_EFFECT_PULL                     one spell: Distract Move
-    &Spell::EffectPickPocket,                               // 71 SPELL_EFFECT_PICKPOCKET
-    &Spell::EffectAddFarsight,                              // 72 SPELL_EFFECT_ADD_FARSIGHT
-    &Spell::EffectUnused,                                   // 73 SPELL_EFFECT_UNTRAIN_TALENTS
-    &Spell::EffectApplyGlyph,                               // 74 SPELL_EFFECT_APPLY_GLYPH
-    &Spell::EffectHealMechanical,                           // 75 SPELL_EFFECT_HEAL_MECHANICAL          one spell: Mechanical Patch Kit
-    &Spell::EffectSummonObjectWild,                         // 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
-    &Spell::EffectScriptEffect,                             // 77 SPELL_EFFECT_SCRIPT_EFFECT
-    &Spell::EffectUnused,                                   // 78 SPELL_EFFECT_ATTACK
-    &Spell::EffectSanctuary,                                // 79 SPELL_EFFECT_SANCTUARY
-    &Spell::EffectAddComboPoints,                           // 80 SPELL_EFFECT_ADD_COMBO_POINTS
-    &Spell::EffectUnused,                                   // 81 SPELL_EFFECT_CREATE_HOUSE             one spell: Create House (TEST)
-    &Spell::EffectNULL,                                     // 82 SPELL_EFFECT_BIND_SIGHT
-    &Spell::EffectDuel,                                     // 83 SPELL_EFFECT_DUEL
-    &Spell::EffectStuck,                                    // 84 SPELL_EFFECT_STUCK
-    &Spell::EffectSummonPlayer,                             // 85 SPELL_EFFECT_SUMMON_PLAYER
-    &Spell::EffectActivateObject,                           // 86 SPELL_EFFECT_ACTIVATE_OBJECT
-    &Spell::EffectWMODamage,                                // 87 SPELL_EFFECT_WMO_DAMAGE
-    &Spell::EffectWMORepair,                                // 88 SPELL_EFFECT_WMO_REPAIR
-    &Spell::EffectUnused,                                   // 89 SPELL_EFFECT_WMO_CHANGE // 0 intact // 1 damaged // 2 destroyed // 3 rebuilding
-    &Spell::EffectKillCreditPersonal,                       // 90 SPELL_EFFECT_KILL_CREDIT              Kill credit but only for single person
-    &Spell::EffectUnused,                                   // 91 SPELL_EFFECT_THREAT_ALL               one spell: zzOLDBrainwash
-    &Spell::EffectEnchantHeldItem,                          // 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
-    &Spell::EffectForceDeselect,                            // 93 SPELL_EFFECT_FORCE_DESELECT
-    &Spell::EffectSelfResurrect,                            // 94 SPELL_EFFECT_SELF_RESURRECT
-    &Spell::EffectSkinning,                                 // 95 SPELL_EFFECT_SKINNING
-    &Spell::EffectCharge,                                   // 96 SPELL_EFFECT_CHARGE
-    &Spell::EffectCastButtons,                              // 97 SPELL_EFFECT_CAST_BUTTON (totem bar since 3.2.2a)
-    &Spell::EffectKnockBack,                                // 98 SPELL_EFFECT_KNOCK_BACK
-    &Spell::EffectDisEnchant,                               // 99 SPELL_EFFECT_DISENCHANT
-    &Spell::EffectInebriate,                                //100 SPELL_EFFECT_INEBRIATE
-    &Spell::EffectFeedPet,                                  //101 SPELL_EFFECT_FEED_PET
-    &Spell::EffectDismissPet,                               //102 SPELL_EFFECT_DISMISS_PET
-    &Spell::EffectReputation,                               //103 SPELL_EFFECT_REPUTATION
-    &Spell::EffectSummonObject,                             //104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
-    &Spell::EffectSummonObject,                             //105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
-    &Spell::EffectSummonObject,                             //106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
-    &Spell::EffectSummonObject,                             //107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
-    &Spell::EffectDispelMechanic,                           //108 SPELL_EFFECT_DISPEL_MECHANIC
-    &Spell::EffectSummonDeadPet,                            //109 SPELL_EFFECT_SUMMON_DEAD_PET
-    &Spell::EffectDestroyAllTotems,                         //110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
-    &Spell::EffectDurabilityDamage,                         //111 SPELL_EFFECT_DURABILITY_DAMAGE
-    &Spell::EffectUnused,                                   //112 SPELL_EFFECT_112
-    &Spell::EffectResurrectNew,                             //113 SPELL_EFFECT_RESURRECT_NEW
-    &Spell::EffectTaunt,                                    //114 SPELL_EFFECT_ATTACK_ME
-    &Spell::EffectDurabilityDamagePCT,                      //115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
-    &Spell::EffectSkinPlayerCorpse,                         //116 SPELL_EFFECT_SKIN_PLAYER_CORPSE       one spell: Remove Insignia, bg usage, required special corpse flags...
-    &Spell::EffectSpiritHeal,                               //117 SPELL_EFFECT_SPIRIT_HEAL              one spell: Spirit Heal
-    &Spell::EffectSkill,                                    //118 SPELL_EFFECT_SKILL                    professions and more
-    &Spell::EffectApplyAreaAura,                            //119 SPELL_EFFECT_APPLY_AREA_AURA_PET
-    &Spell::EffectUnused,                                   //120 SPELL_EFFECT_TELEPORT_GRAVEYARD       one spell: Graveyard Teleport Test
-    &Spell::EffectWeaponDmg,                                //121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
-    &Spell::EffectUnused,                                   //122 SPELL_EFFECT_122                      unused
-    &Spell::EffectSendTaxi,                                 //123 SPELL_EFFECT_SEND_TAXI                taxi/flight related (misc value is taxi path id)
-    &Spell::EffectPullTowards,                              //124 SPELL_EFFECT_PULL_TOWARDS
-    &Spell::EffectModifyThreatPercent,                      //125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
-    &Spell::EffectStealBeneficialBuff,                      //126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF    spell steal effect?
-    &Spell::EffectProspecting,                              //127 SPELL_EFFECT_PROSPECTING              Prospecting spell
-    &Spell::EffectApplyAreaAura,                            //128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
-    &Spell::EffectApplyAreaAura,                            //129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
-    &Spell::EffectRedirectThreat,                           //130 SPELL_EFFECT_REDIRECT_THREAT
-    &Spell::EffectPlayerNotification,                       //131 SPELL_EFFECT_PLAYER_NOTIFICATION
-    &Spell::EffectPlayMusic,                                //132 SPELL_EFFECT_PLAY_MUSIC               sound id in misc value (SoundEntries.dbc)
-    &Spell::EffectUnlearnSpecialization,                    //133 SPELL_EFFECT_UNLEARN_SPECIALIZATION   unlearn profession specialization
-    &Spell::EffectKillCredit,                               //134 SPELL_EFFECT_KILL_CREDIT              misc value is creature entry
-    &Spell::EffectNULL,                                     //135 SPELL_EFFECT_CALL_PET
-    &Spell::EffectHealPct,                                  //136 SPELL_EFFECT_HEAL_PCT
-    &Spell::EffectEnergizePct,                              //137 SPELL_EFFECT_ENERGIZE_PCT
-    &Spell::EffectLeapBack,                                 //138 SPELL_EFFECT_LEAP_BACK                Leap back
-    &Spell::EffectQuestClear,                               //139 SPELL_EFFECT_CLEAR_QUEST              Reset quest status (miscValue - quest ID)
-    &Spell::EffectForceCast,                                //140 SPELL_EFFECT_FORCE_CAST
-    &Spell::EffectForceCastWithValue,                       //141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
-    &Spell::EffectTriggerSpellWithValue,                    //142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
-    &Spell::EffectApplyAreaAura,                            //143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
-    &Spell::EffectKnockBack,                                //144 SPELL_EFFECT_KNOCK_BACK_DEST
-    &Spell::EffectPullTowards,                              //145 SPELL_EFFECT_PULL_TOWARDS_DEST                      Black Hole Effect
-    &Spell::EffectActivateRune,                             //146 SPELL_EFFECT_ACTIVATE_RUNE
-    &Spell::EffectQuestFail,                                //147 SPELL_EFFECT_QUEST_FAIL               quest fail
-    &Spell::EffectUnused,                                   //148 SPELL_EFFECT_148   1 spell - 43509
-    &Spell::EffectChargeDest,                               //149 SPELL_EFFECT_CHARGE_DEST
-    &Spell::EffectQuestStart,                               //150 SPELL_EFFECT_QUEST_START
-    &Spell::EffectTriggerRitualOfSummoning,                 //151 SPELL_EFFECT_TRIGGER_SPELL_2
-    &Spell::EffectNULL,                                     //152 SPELL_EFFECT_152                      summon Refer-a-Friend
-    &Spell::EffectCreateTamedPet,                           //153 SPELL_EFFECT_CREATE_TAMED_PET         misc value is creature entry
-    &Spell::EffectDiscoverTaxi,                             //154 SPELL_EFFECT_DISCOVER_TAXI
-    &Spell::EffectTitanGrip,                                //155 SPELL_EFFECT_TITAN_GRIP Allows you to equip two-handed axes, maces and swords in one hand, but you attack $49152s1% slower than normal.
-    &Spell::EffectEnchantItemPrismatic,                     //156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
-    &Spell::EffectCreateItem2,                              //157 SPELL_EFFECT_CREATE_ITEM_2            create item or create item template and replace by some randon spell loot item
-    &Spell::EffectMilling,                                  //158 SPELL_EFFECT_MILLING                  milling
-    &Spell::EffectRenamePet,                                //159 SPELL_EFFECT_ALLOW_RENAME_PET         allow rename pet once again
-    &Spell::EffectNULL,                                     //160 SPELL_EFFECT_160                      1 spell - 45534
-    &Spell::EffectSpecCount,                                //161 SPELL_EFFECT_TALENT_SPEC_COUNT        second talent spec (learn/revert)
-    &Spell::EffectActivateSpec,                             //162 SPELL_EFFECT_TALENT_SPEC_SELECT       activate primary/secondary spec
-    &Spell::EffectNULL,                                     //163 unused
-    &Spell::EffectRemoveAura,                               //164 SPELL_EFFECT_REMOVE_AURA
-};
-
-void Spell::EffectNULL(SpellEffIndex /*effIndex*/)
-{
-    sLog.outDebug("WORLD: Spell Effect DUMMY");
-}
-
-void Spell::EffectUnused(SpellEffIndex /*effIndex*/)
-{
-    // NOT USED BY ANY SPELL OR USELESS OR IMPLEMENTED IN DIFFERENT WAY IN TRINITY
-}
-
-void Spell::EffectResurrectNew(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->isAlive())
-        return;
-
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (!unitTarget->IsInWorld())
-        return;
-
-    Player* pTarget = unitTarget->ToPlayer();
-
-    if (pTarget->isRessurectRequested())       // already have one active request
-        return;
-
-    uint32 health = damage;
-    uint32 mana = m_spellInfo->EffectMiscValue[effIndex];
-    ExecuteLogEffectResurrect(effIndex, pTarget);
-    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
-    SendResurrectRequest(pTarget);
-}
-
-void Spell::EffectInstaKill(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive())
-        return;
-
-    // Demonic Sacrifice
-    if (m_spellInfo->Id == 18788 && unitTarget->GetTypeId() == TYPEID_UNIT)
-    {
-        uint32 entry = unitTarget->GetEntry();
-        uint32 spellID;
-        switch (entry)
-        {
-            case   416: spellID = 18789; break;               //imp
-            case   417: spellID = 18792; break;               //fellhunter
-            case  1860: spellID = 18790; break;               //void
-            case  1863: spellID = 18791; break;               //succubus
-            case 17252: spellID = 35701; break;               //fellguard
-            default:
-                sLog.outError("EffectInstaKill: Unhandled creature entry (%u) case.", entry);
-                return;
-        }
-
-        m_caster->CastSpell(m_caster, spellID, true);
-    }
-
-    if (m_caster == unitTarget)                              // prevent interrupt message
-        finish();
-
-    WorldPacket data(SMSG_SPELLINSTAKILLLOG, 8+8+4);
-    data << uint64(m_caster->GetGUID());
-    data << uint64(unitTarget->GetGUID());
-    data << uint32(m_spellInfo->Id);
-    m_caster->SendMessageToSet(&data, true);
-
-    m_caster->DealDamage(unitTarget, unitTarget->GetHealth(), NULL, NODAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-}
-
-void Spell::EffectEnvirinmentalDMG(SpellEffIndex effIndex)
-{
-    uint32 absorb = 0;
-    uint32 resist = 0;
-
-    // Note: this hack with damage replace required until GO casting not implemented
-    // environment damage spells already have around enemies targeting but this not help in case not existed GO casting support
-    // currently each enemy selected explicitly and self cast damage, we prevent apply self casted spell bonuses/etc
-    damage = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex, m_caster);
-
-    m_caster->CalcAbsorbResist(m_caster, GetSpellSchoolMask(m_spellInfo), SPELL_DIRECT_DAMAGE, damage, &absorb, &resist, m_spellInfo);
-
-    m_caster->SendSpellNonMeleeDamageLog(m_caster, m_spellInfo->Id, damage, GetSpellSchoolMask(m_spellInfo), absorb, resist, false, 0, false);
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->EnvironmentalDamage(DAMAGE_FIRE, damage);
-}
-
-void Spell::EffectSchoolDMG(SpellEffIndex /*effIndex*/)
-{
-}
-
-void Spell::SpellDamageSchoolDmg(SpellEffIndex effIndex)
-{
-    bool apply_direct_bonus = true;
-
-    if (unitTarget && unitTarget->isAlive())
-    {
-        switch (m_spellInfo->SpellFamilyName)
-        {
-            case SPELLFAMILY_GENERIC:
-            {
-                // Meteor like spells (divided damage to targets)
-                if (m_customAttr & SPELL_ATTR_CU_SHARE_DAMAGE)
-                {
-                    uint32 count = 0;
-                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1<<effIndex))
-                            ++count;
-
-                    damage /= count;                    // divide to all targets
-                }
-
-                switch(m_spellInfo->Id)                     // better way to check unknown
-                {
-                    // Positive/Negative Charge
-                    case 28062:
-                    case 28085:
-                    case 39090:
-                    case 39093:
-                        if (!m_triggeredByAuraSpell)
-                            break;
-                        if (unitTarget == m_caster)
-                        {
-                            uint8 count = 0;
-                            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                                if (ihit->targetGUID != m_caster->GetGUID())
-                                    if (Player *target = ObjectAccessor::GetPlayer(*m_caster, ihit->targetGUID))
-                                        if (target->HasAura(m_triggeredByAuraSpell->Id))
-                                            ++count;
-                            if (count)
-                            {
-                                uint32 spellId = 0;
-                                switch (m_spellInfo->Id)
-                                {
-                                    case 28062: spellId = 29659; break;
-                                    case 28085: spellId = 29660; break;
-                                    case 39090: spellId = 39089; break;
-                                    case 39093: spellId = 39092; break;
-                                }
-                                m_caster->SetAuraStack(spellId, m_caster, count);
-                            }
-                        }
-
-                        if (unitTarget->HasAura(m_triggeredByAuraSpell->Id))
-                            damage = 0;
-                        break;
-                    // Consumption
-                    case 28865:
-                        damage = (((InstanceMap*)m_caster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY ? 2750 : 4250);
-                        break;
-                    // percent from health with min
-                    case 25599:                             // Thundercrash
-                    {
-                        damage = unitTarget->GetHealth() / 2;
-                        if (damage < 200)
-                            damage = 200;
-                        break;
-                    }
-                    // arcane charge. must only affect demons (also undead?)
-                    case 45072:
-                    {
-                        if (unitTarget->GetCreatureType() != CREATURE_TYPE_DEMON
-                            && unitTarget->GetCreatureType() != CREATURE_TYPE_UNDEAD)
-                            return;
-                        break;
-                    }
-                    case 33671: // gruul's shatter
-                    case 50811: // krystallus shatter ( Normal )
-                    case 61547: // krystallus shatter ( Heroic )
-                    {
-                        // don't damage self and only players
-                        if (unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                            return;
-
-                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
-                        if (!radius) return;
-                        float distance = m_caster->GetDistance2d(unitTarget);
-                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * ((radius - distance)/radius));
-                        break;
-                    }
-                    // TODO: add spell specific target requirement hook for spells
-                    // Shadowbolts only affects targets with Shadow Mark (Gothik)
-                    case 27831:
-                    case 55638:
-                        if (!unitTarget->HasAura(27825))
-                            return;
-                        break;
-                    // Cataclysmic Bolt
-                    case 38441:
-                    {
-                        damage = unitTarget->CountPctFromMaxHealth(50);
-                        break;
-                    }
-					case 69075:
-                    case 70834:
-                    case 70835:
-                    case 70836:
-                    {
-                        float distance = m_caster->GetDistance(unitTarget);
-                        float radius = 12.0f;
-                        if(distance > radius)
-                            return;
-
-                        if(distance < 1)
-                           distance = 1;
-
-                        int32 bp0 = m_spellInfo->EffectBasePoints[0];
-                        int32 damage = int32(bp0 / (distance / radius));
-                        break;
-                    }
-                    // Tympanic Tantrum
-                    case 62775:
-                    {
-                        damage = unitTarget->CountPctFromMaxHealth(10);
-                        break;
-                    }
-                    // Gargoyle Strike
-                    case 51963:
-                    {
-                        // about +4 base spell dmg per level
-                        damage = (m_caster->getLevel() - 60) * 4 + 60;
-                        break;
-                    }
-
-                    // Loken Pulsing Shockwave
-                    case 59837:
-                    case 52942:
-                    {
-                        // don't damage self and only players
-                        if(unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                            return;
-
-                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
-                        if (!radius)
-                            return;
-                        float distance = m_caster->GetDistance2d(unitTarget);
-                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * distance);
-                        break;
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_WARRIOR:
-            {
-                // Bloodthirst
-                if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
-                    damage = uint32(damage * (m_caster->GetTotalAttackPowerValue(BASE_ATTACK)) / 100);
-                // Shield Slam
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x200 && m_spellInfo->Category == 1209)
-                    damage += m_caster->ApplyEffectModifiers(m_spellInfo,effIndex,int32(m_caster->GetShieldBlockValue()));
-                // Victory Rush
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x100)
-                {
-                    damage = uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
-                    m_caster->ModifyAuraState(AURA_STATE_WARRIOR_VICTORY_RUSH, false);
-                }
-                // Shockwave
-                else if (m_spellInfo->Id == 46968)
-                {
-                    int32 pct = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, 2);
-                    if (pct > 0)
-                        damage+= int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * pct / 100);
-                    break;
-                }
-                break;
-            }
-            case SPELLFAMILY_WARLOCK:
-            {
-                // Incinerate Rank 1 & 2
-                if ((m_spellInfo->SpellFamilyFlags[1] & 0x000040) && m_spellInfo->SpellIconID == 2128)
-                {
-                    // Incinerate does more dmg (dmg*0.25) if the target have Immolate debuff.
-                    // Check aura state for speed but aura state set not only for Immolate spell
-                    if (unitTarget->HasAuraState(AURA_STATE_CONFLAGRATE))
-                    {
-                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0, 0))
-                            damage += damage/4;
-                    }
-                }
-                // Conflagrate - consumes Immolate or Shadowflame
-                else if (m_spellInfo->TargetAuraState == AURA_STATE_CONFLAGRATE)
-                {
-                    AuraEffect const* aura = NULL;                // found req. aura for damage calculation
-
-                    Unit::AuraEffectList const &mPeriodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
-                    for (Unit::AuraEffectList::const_iterator i = mPeriodic.begin(); i != mPeriodic.end(); ++i)
-                    {
-                        // for caster applied auras only
-                        if ((*i)->GetSpellProto()->SpellFamilyName != SPELLFAMILY_WARLOCK ||
-                            (*i)->GetCasterGUID() != m_caster->GetGUID())
-                            continue;
-
-                        // Immolate
-                        if ((*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x4)
-                        {
-                            aura = *i;                      // it selected always if exist
-                            break;
-                        }
-
-                        // Shadowflame
-                        if ((*i)->GetSpellProto()->SpellFamilyFlags[2] & 0x00000002)
-                            aura = *i;                      // remember but wait possible Immolate as primary priority
-                    }
-
-                    // found Immolate or Shadowflame
-                    if (aura)
-                    {
-                        uint32 pdamage = aura->GetAmount() > 0 ? aura->GetAmount() : 0;
-                        pdamage = m_caster->SpellDamageBonus(unitTarget, aura->GetSpellProto(), pdamage, DOT, aura->GetBase()->GetStackAmount());
-                        uint32 pct_dir = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 1));
-                        uint8 baseTotalTicks = uint8(m_caster->CalcSpellDuration(aura->GetSpellProto()) / aura->GetSpellProto()->EffectAmplitude[0]);
-                        damage += pdamage * baseTotalTicks * pct_dir / 100;
-
-                        uint32 pct_dot = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 2)) / 3;
-                        m_spellValue->EffectBasePoints[1] = SpellMgr::CalculateSpellEffectBaseAmount(pdamage * baseTotalTicks * pct_dot / 100, m_spellInfo, 1);
-
-                        apply_direct_bonus = false;
-                        // Glyph of Conflagrate
-                        if (!m_caster->HasAura(56235))
-                            unitTarget->RemoveAurasDueToSpell(aura->GetId(), m_caster->GetGUID());
-
-                        break;
-                    }
-                }
-                // Shadow Bite
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x400000)
-                {
-                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet())
-                    {
-                        // Get DoTs on target by owner (5% increase by dot)
-                        damage += 5 * unitTarget->GetDoTsByCaster(m_caster->GetOwnerGUID()) / 100;
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_PRIEST:
-            {
-                // Shadow Word: Death - deals damage equal to damage done to caster
-                if ((m_spellInfo->SpellFamilyFlags[1] & 0x2))
-                {
-                    int32 back_damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
-                    // Pain and Suffering reduces damage
-                    if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST, 2874, 0))
-                        back_damage -= aurEff->GetAmount() * back_damage / 100;
-
-                    if (back_damage < int32(unitTarget->GetHealth()))
-                        m_caster->CastCustomSpell(m_caster, 32409, &back_damage, 0, 0, true);
-                }
-                // Mind Blast - applies Mind Trauma if:
-                else if (m_spellInfo->SpellFamilyFlags[2] & 0x00002000)
-                {
-                    // We are in Shadow Form
-                    if (m_caster->m_form == FORM_SHADOW)
-                        // We have Improved Mind Blast
-                        if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST,95,0))
-                            // Chance has been successfully rolled
-                            if (roll_chance_i(aurEff->GetAmount()))
-                                m_caster->CastSpell(unitTarget, 48301, true);
-                }
-                // Smite
-                else if (m_spellInfo->SpellFamilyFlags[0] & 0x80)
-                {
-                    // Glyph of Smite
-                    if (AuraEffect * aurEff = m_caster->GetAuraEffect(55692, 0))
-                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x100000, 0, 0, m_caster->GetGUID()))
-                            damage += damage * aurEff->GetAmount() / 100;
-                }
-                // Improved Mind Blast (Mind Blast in shadow form bonus)
-                else if (m_caster->m_form == FORM_SHADOW && (m_spellInfo->SpellFamilyFlags[0] & 0x00002000))
-                {
-                    Unit::AuraEffectList const& ImprMindBlast = m_caster->GetAuraEffectsByType(SPELL_AURA_ADD_FLAT_MODIFIER);
-                    for (Unit::AuraEffectList::const_iterator i = ImprMindBlast.begin(); i != ImprMindBlast.end(); ++i)
-                    {
-                        if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_PRIEST &&
-                            ((*i)->GetSpellProto()->SpellIconID == 95))
-                        {
-                            int chance = SpellMgr::CalculateSpellEffectAmount((*i)->GetSpellProto(), 1, m_caster);
-                            if (roll_chance_i(chance))
-                                // Mind Trauma
-                                m_caster->CastSpell(unitTarget, 48301, true, 0);
-                            break;
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_DRUID:
-            {
-                // Ferocious Bite
-                if (m_caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->SpellFamilyFlags[0] & 0x000800000) && m_spellInfo->SpellVisual[0] == 6587)
-                {
-                    // converts each extra point of energy into ($f1+$AP/410) additional damage
-                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
-                    float multiple = ap / 410 + m_spellInfo->EffectDamageMultiplier[effIndex];
-                    int32 energy = -(m_caster->ModifyPower(POWER_ENERGY, -30));
-                    damage += int32(energy * multiple);
-                    damage += int32(m_caster->ToPlayer()->GetComboPoints() * ap * 7 / 100);
-                }
-                // Wrath
-                else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
-                {
-                    // Improved Insect Swarm
-                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))
-                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00200000, 0, 0))
-                            damage = int32(damage*(100.0f+aurEff->GetAmount())/100.0f);
-                }
-                break;
-            }
-            case SPELLFAMILY_ROGUE:
-            {
-                // Envenom
-                if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & 0x8)
-                {
-                    if (!m_caster->ToPlayer())
-                        return;
-
-                    uint32 combo = m_caster->ToPlayer()->GetComboPoints();
-                    if (!combo)
-                        return;
-
-                    AuraEffect const * aurEffA = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x10000, 0, 0, m_caster->GetGUID());
-                    if (!aurEffA)
-                        return;
-
-                    uint32 doses = aurEffA->GetBase()->GetStackAmount();
-                    if (doses > combo)
-                        doses = combo;
-
-                    // Master Poisoner
-                    bool needConsume = true;
-                    Unit::AuraEffectList const & auras = m_caster->ToPlayer()->GetAuraEffectsByType(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK);
-                    for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-                        if (((*itr)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_ROGUE) &&
-                            ((*itr)->GetSpellProto()->SpellIconID == 1960))
-                        {
-                            uint32 chance = SpellMgr::CalculateSpellEffectAmount((*itr)->GetSpellProto(), EFFECT_2);
-                            if ((chance >= 100) || roll_chance_i(chance))
-                                needConsume = false;
-                            break;
-                        }
-                    if (needConsume)
-                        for (uint32 i = 0; i < doses; ++i)
-                            unitTarget->RemoveAuraFromStack(aurEffA->GetId());
-
-                    damage *= doses;
-                    damage += int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.09f * combo);
-
-                    // Eviscerate and Envenom Bonus Damage
-                    if (AuraEffect const * aurEffB = m_caster->GetAuraEffect(37169, EFFECT_0, m_caster->GetGUID()))
-                        damage += combo * aurEffB->GetAmount();
-                    break;
-                }
-                // Eviscerate
-                if (m_spellInfo->SpellFamilyFlags[EFFECT_0] & 0x20000)
-                {
-                    if (!m_caster->ToPlayer())
-                        return;
-
-                    uint32 combo = m_caster->ToPlayer()->GetComboPoints();
-                    if (!combo)
-                        return;
-
-                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
-                    damage += irand(int32(ap * combo * 0.03f), int32(ap * combo * 0.07f));
-
-                    // Eviscerate and Envenom Bonus Damage
-                    if (AuraEffect const * aurEffB = m_caster->GetAuraEffect(37169, EFFECT_0, m_caster->GetGUID()))
-                        damage += combo * aurEffB->GetAmount();
-                    break;
-                }
-                break;
-            }
-            case SPELLFAMILY_HUNTER:
-            {
-                //Gore
-                if (m_spellInfo->SpellIconID == 1578)
-                {
-                    if (m_caster->HasAura(57627))           // Charge 6 sec post-affect
-                        damage *= 2;
-                }
-                // Steady Shot
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x1)
-                {
-                    bool found = false;
-                    // check dazed affect
-                    Unit::AuraEffectList const& decSpeedList = unitTarget->GetAuraEffectsByType(SPELL_AURA_MOD_DECREASE_SPEED);
-                    for (Unit::AuraEffectList::const_iterator iter = decSpeedList.begin(); iter != decSpeedList.end(); ++iter)
-                    {
-                        if ((*iter)->GetSpellProto()->SpellIconID == 15 && (*iter)->GetSpellProto()->Dispel == 0)
-                        {
-                            found = true;
-                            break;
-                        }
-                    }
-
-                    // TODO: should this be put on taken but not done?
-                    if (found)
-                        damage += SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
-
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        // Add Ammo and Weapon damage plus RAP * 0.1
-                        Item *item = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
-                        if (item)
-                        {
-                            float dmg_min = item->GetProto()->Damage->DamageMin;
-                            float dmg_max = item->GetProto()->Damage->DamageMax;
-                            if (dmg_max == 0.0f && dmg_min > dmg_max)
-                                damage += int32(dmg_min);
-                            else
-                                damage += irand(int32(dmg_min), int32(dmg_max));
-                            damage += int32(m_caster->ToPlayer()->GetAmmoDPS()*item->GetProto()->Delay*0.001f);
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_PALADIN:
-            {
-                // Hammer of the Righteous
-                if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & 0x40000)
-                {
-                    // Add main hand dps * effect[2] amount
-                    float average = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2;
-                    int32 count = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, EFFECT_2);
-                    damage += count * int32(average * IN_MILLISECONDS) / m_caster->GetAttackTime(BASE_ATTACK);
-                    break;
-                }
-                // Shield of Righteousness
-                 else if (m_spellInfo->SpellFamilyFlags[1]&0x00100000)
-                 {                
-					 damage += int32(m_caster->GetShieldBlockValue());
-                 }
-                // Blood Boil - bonus for diseased targets
-                if (m_spellInfo->SpellFamilyFlags[0] & 0x00040000 && unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0, 0, 0x00000002, m_caster->GetGUID()))
-                {
-                    damage += m_damage / 2;
-                    damage += int32(m_caster->GetTotalAttackPowerValue(RANGED_ATTACK)* 0.035f);
-                }
-                break;
-            }
-        }
-
-        if (m_originalCaster && damage > 0 && apply_direct_bonus)
-            damage = m_originalCaster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
-
-        m_damage += damage;
-    }
-}
-
-void Spell::EffectDummy(SpellEffIndex effIndex)
-{
-    if (!unitTarget && !gameObjTarget && !itemTarget)
-        return;
-
-    uint32 spell_id = 0;
-    int32 bp = 0;
-    bool triggered = true;
-    SpellCastTargets targets;
-
-    // selection by spell family
-    switch (m_spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            switch (m_spellInfo->Id)
-            {
-                case 8593:                                  // Symbol of life (restore creature to life)
-                case 31225:                                 // Shimmering Vessel (restore creature to life)
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-                    unitTarget->ToCreature()->setDeathState(JUST_ALIVED);
-                    return;
-                }
-                case 12162:                                 // Deep wounds
-                case 12850:                                 // (now good common check for this spells)
-                case 12868:
-                {
-                    if (!unitTarget)
-                        return;
-
-                    float damage;
-                    // DW should benefit of attack power, damage percent mods etc.
-                    // TODO: check if using offhand damage is correct and if it should be divided by 2
-                    if (m_caster->haveOffhandWeapon() && m_caster->getAttackTimer(BASE_ATTACK) > m_caster->getAttackTimer(OFF_ATTACK))
-                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE))/2;
-                    else
-                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE))/2;
-
-                    switch (m_spellInfo->Id)
-                    {
-                        case 12162: damage *= 0.16f; break; // Rank 1
-                        case 12850: damage *= 0.32f; break; // Rank 2
-                        case 12868: damage *= 0.48f; break; // Rank 3
-                        default:
-                            sLog.outError("Spell::EffectDummy: Spell %u not handled in DW",m_spellInfo->Id);
-                            return;
-                    };
-
-                    // get remaining damage of old Deep Wound aura
-                    AuraEffect* deepWound = unitTarget->GetAuraEffect(12721, 0);
-                    if (deepWound)
-                    {
-                        int32 remainingTicks = deepWound->GetBase()->GetDuration() / deepWound->GetAmplitude();
-                        damage += remainingTicks * deepWound->GetAmount();
-                    }
-
-                    // 1 tick/sec * 6 sec = 6 ticks
-                    int32 deepWoundsDotBasePoints0 = int32(damage / 6);
-                    m_caster->CastCustomSpell(unitTarget, 12721, &deepWoundsDotBasePoints0, NULL, NULL, true, NULL);
-                    return;
-                }
-                case 13567:                                 // Dummy Trigger
-                {
-                    // can be used for different aura triggering, so select by aura
-                    if (!m_triggeredByAuraSpell || !unitTarget)
-                        return;
-
-                    switch (m_triggeredByAuraSpell->Id)
-                    {
-                        case 26467:                         // Persistent Shield
-                            m_caster->CastCustomSpell(unitTarget, 26470, &damage, NULL, NULL, true);
-                            break;
-                        default:
-                            sLog.outError("EffectDummy: Non-handled case for spell 13567 for triggered aura %u",m_triggeredByAuraSpell->Id);
-                            break;
-                    }
-                    return;
-                }
-                case 17251:                                 // Spirit Healer Res
-                {
-                    if (!unitTarget || !m_originalCaster)
-                        return;
-
-                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        WorldPacket data(SMSG_SPIRIT_HEALER_CONFIRM, 8);
-                        data << uint64(unitTarget->GetGUID());
-                        m_originalCaster->ToPlayer()->GetSession()->SendPacket(&data);
-                    }
-                    return;
-                }
-                case 20577:                                 // Cannibalize
-                    if (unitTarget)
-                        m_caster->CastSpell(m_caster, 20578, false, NULL);
-                    return;
-                case 23019:                                 // Crystal Prison Dummy DND
-                {
-                    if (!unitTarget || !unitTarget->isAlive() || unitTarget->GetTypeId() != TYPEID_UNIT || unitTarget->ToCreature()->isPet())
-                        return;
-
-                    Creature* creatureTarget = unitTarget->ToCreature();
-
-                    m_caster->SummonGameObject(179644, creatureTarget->GetPositionX(), creatureTarget->GetPositionY(), creatureTarget->GetPositionZ(), creatureTarget->GetOrientation(), 0, 0, 0, 0, uint32(creatureTarget->GetRespawnTime()-time(NULL)));
-                    sLog.outDebug("SummonGameObject at SpellEfects.cpp EffectDummy for Spell 23019");
-
-                    creatureTarget->ForcedDespawn();
-
-                    return;
-                }
-                case 23448:                                 // Transporter Arrival - Ultrasafe Transporter: Gadgetzan - backfires
-                {
-                    int32 r = irand(0, 119);
-                    if (r < 20)                           // Transporter Malfunction - 1/6 polymorph
-                        m_caster->CastSpell(m_caster, 23444, true);
-                    else if (r < 100)                     // Evil Twin               - 4/6 evil twin
-                        m_caster->CastSpell(m_caster, 23445, true);
-                    else                                    // Transporter Malfunction - 1/6 miss the target
-                        m_caster->CastSpell(m_caster, 36902, true);
-                    return;
-                }
-                case 23453:                                 // Gnomish Transporter - Ultrasafe Transporter: Gadgetzan
-                    if (roll_chance_i(50))                // Gadgetzan Transporter         - success
-                        m_caster->CastSpell(m_caster, 23441, true);
-                    else                                    // Gadgetzan Transporter Failure - failure
-                        m_caster->CastSpell(m_caster, 23446, true);
-                    return;
-                case 25860:                                 // Reindeer Transformation
-                {
-                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
-                        return;
-
-                    float flyspeed = m_caster->GetSpeedRate(MOVE_FLIGHT);
-                    float speed = m_caster->GetSpeedRate(MOVE_RUN);
-
-                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    //5 different spells used depending on mounted speed and if mount can fly or not
-                    if (flyspeed >= 4.1f)
-                        // Flying Reindeer
-                        m_caster->CastSpell(m_caster, 44827, true); //310% flying Reindeer
-                    else if (flyspeed >= 3.8f)
-                        // Flying Reindeer
-                        m_caster->CastSpell(m_caster, 44825, true); //280% flying Reindeer
-                    else if (flyspeed >= 1.6f)
-                        // Flying Reindeer
-                        m_caster->CastSpell(m_caster, 44824, true); //60% flying Reindeer
-                    else if (speed >= 2.0f)
-                        // Reindeer
-                        m_caster->CastSpell(m_caster, 25859, true); //100% ground Reindeer
-                    else
-                        // Reindeer
-                        m_caster->CastSpell(m_caster, 25858, true); //60% ground Reindeer
-
-                    return;
-                }
-                case 26074:                                 // Holiday Cheer
-                    // implemented at client side
-                    return;
-                // Polarity Shift
-                case 28089:
-                    if (unitTarget)
-                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 28059 : 28084, true, NULL, NULL, m_caster->GetGUID());
-                    break;
-                // Polarity Shift
-                case 39096:
-                    if (unitTarget)
-                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 39088 : 39091, true, NULL, NULL, m_caster->GetGUID());
-                    break;
-                case 29200:                                 // Purify Helboar Meat
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    uint32 spell_id = roll_chance_i(50)
-                        ? 29277                             // Summon Purified Helboar Meat
-                        : 29278;                            // Summon Toxic Helboar Meat
-
-                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
-                    return;
-                }
-                case 29858:                                 // Soulshatter
-                    if (unitTarget && unitTarget->CanHaveThreatList()
-                        && unitTarget->getThreatManager().getThreat(m_caster) > 0.0f)
-                        m_caster->CastSpell(unitTarget,32835,true);
-                    return;
-                case 30458:                                 // Nigh Invulnerability
-                    if (!m_CastItem) return;
-                    if (roll_chance_i(86))                   // Nigh-Invulnerability   - success
-                        m_caster->CastSpell(m_caster, 30456, true, m_CastItem);
-                    else                                    // Complete Vulnerability - backfire in 14% casts
-                        m_caster->CastSpell(m_caster, 30457, true, m_CastItem);
-                    return;
-                case 30507:                                 // Poultryizer
-                    if (!m_CastItem) return;
-                    if (roll_chance_i(80))                   // Poultryized! - success
-                        m_caster->CastSpell(unitTarget, 30501, true, m_CastItem);
-                    else                                    // Poultryized! - backfire 20%
-                        m_caster->CastSpell(unitTarget, 30504, true, m_CastItem);
-                    return;
-                case 35745:                                 // Socrethar's Stone
-                {
-                    uint32 spell_id;
-                    switch(m_caster->GetAreaId())
-                    {
-                        case 3900: spell_id = 35743; break; // Socrethar Portal
-                        case 3742: spell_id = 35744; break; // Socrethar Portal
-                        default: return;
-                    }
-
-                    m_caster->CastSpell(m_caster, spell_id, true);
-                    return;
-                }
-                case 37674:                                 // Chaos Blast
-                {
-                    if (!unitTarget)
-                        return;
-
-                    int32 basepoints0 = 100;
-                    m_caster->CastCustomSpell(unitTarget, 37675, &basepoints0, NULL, NULL, true);
-                    return;
-                }
-                // Wrath of the Astromancer
-                case 42784:
-                {
-                    uint32 count = 0;
-                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1<<effIndex))
-                            ++count;
-
-                    damage = 12000; // maybe wrong value
-                    damage /= count;
-
-                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(42784);
-
-                     // now deal the damage
-                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1<<effIndex))
-                        {
-                            if (Unit* casttarget = Unit::GetUnit((*unitTarget), ihit->targetGUID))
-                                m_caster->DealDamage(casttarget, damage, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_ARCANE, spellInfo, false);
-                        }
-
-                    return;
-                }
-                // Demon Broiled Surprise
-                case 43723:
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    Player *player = (Player*)m_caster;
-
-                    if (player && player->GetQuestStatus(11379) == QUEST_STATUS_INCOMPLETE)
-                    {
-                        Creature *creature = player->FindNearestCreature(19973, 10, false);
-                        if (!creature)
-                        {
-                            SendCastResult(SPELL_FAILED_NOT_HERE);
-                            return;
-                        }
-
-                        player->CastSpell(player, 43753, false);
-                    }
-                    return;
-                }
-                case 44875:                                 // Complete Raptor Capture
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    unitTarget->ToCreature()->ForcedDespawn();
-
-                    //cast spell Raptor Capture Credit
-                    m_caster->CastSpell(m_caster, 42337, true, NULL);
-                    return;
-                }
-                case 47170:                                 // Impale Leviroth
-                {
-                    if (!unitTarget && unitTarget->GetEntry() != 26452 && unitTarget->HealthAbovePct(95))
-                        return;
-
-                        m_caster->DealDamage(unitTarget, unitTarget->CountPctFromMaxHealth(93));
-                        return;
-                }
-                case 49357:                                 // Brewfest Mount Transformation
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
-                        return;
-                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
-                    // Ram for Alliance, Kodo for Horde
-                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                    {
-                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Ram
-                            m_caster->CastSpell(m_caster, 43900, true);
-                        else
-                            // 60% Ram
-                            m_caster->CastSpell(m_caster, 43899, true);
-                    }
-                    else
-                    {
-                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Kodo
-                            m_caster->CastSpell(m_caster, 49379, true);
-                        else
-                            // 60% Kodo
-                            m_caster->CastSpell(m_caster, 49378, true);
-                    }
-                    return;
-                case 52845:                                 // Brewfest Mount Transformation (Faction Swap)
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
-                        return;
-                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
-                    // Ram for Horde, Kodo for Alliance
-                    if (m_caster->ToPlayer()->GetTeam() == HORDE)
-                    {
-                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Ram
-                            m_caster->CastSpell(m_caster, 43900, true);
-                        else
-                            // 60% Ram
-                            m_caster->CastSpell(m_caster, 43899, true);
-                    }
-                    else
-                    {
-                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Kodo
-                            m_caster->CastSpell(m_caster, 49379, true);
-                        else
-                            // 60% Kodo
-                            m_caster->CastSpell(m_caster, 49378, true);
-                    }
-                    return;
-                case 55004:                                 // Nitro Boosts
-                    if (!m_CastItem)
-                        return;
-                    if (roll_chance_i(95))                  // Nitro Boosts - success
-                        m_caster->CastSpell(m_caster, 54861, true, m_CastItem);
-                    else                                    // Knocked Up   - backfire 5%
-                        m_caster->CastSpell(m_caster, 46014, true, m_CastItem);
-                    return;
-                case 50243:                                 // Teach Language
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // spell has a 1/3 chance to trigger one of the below
-                    if (roll_chance_i(66))
-                        return;
-                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                    {
-                        // 1000001 - gnomish binary
-                        m_caster->CastSpell(m_caster, 50242, true);
-                    }
-                    else
-                    {
-                        // 01001000 - goblin binary
-                        m_caster->CastSpell(m_caster, 50246, true);
-                    }
-
-                    return;
-                }
-                case 51582:                                 //Rocket Boots Engaged (Rocket Boots Xtreme and Rocket Boots Xtreme Lite)
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    if (Battleground* bg = m_caster->ToPlayer()->GetBattleground())
-                        bg->EventPlayerDroppedFlag(m_caster->ToPlayer());
-
-                    m_caster->CastSpell(m_caster, 30452, true, NULL);
-                    return;
-                }
-                case 52759:                                 // Ancestral Awakening
-                    if (!unitTarget)
-                        return;
-                    m_caster->CastCustomSpell(unitTarget, 52752, &damage, NULL, NULL, true);
-                    return;
-                case 54171:                                   //Divine Storm
-                {
-                    if (!damage)
-                        return;
-
-                    if (m_UniqueTargetInfo.size())
-                    {
-                        SpellEntry const * spellInfo = sSpellStore.LookupEntry(53385);
-                        int32 heal = SpellMgr::CalculateSpellEffectAmount(spellInfo, EFFECT_1) * damage / m_UniqueTargetInfo.size() / 100;
-
-                        m_caster->CastCustomSpell(unitTarget, 54172, &heal, NULL, NULL, true);
-                    }
-                    return;
-                }
-                case 58418:                                 // Portal to Orgrimmar
-                case 58420:                                 // Portal to Stormwind
-                    return;                                 // implemented in EffectScript[0]
-                case 62324: // Throw Passenger
-                {
-                    if (m_targets.HasTraj())
-                    {
-                        if (Vehicle *vehicle = m_caster->GetVehicleKit())
-                            if (Unit *passenger = vehicle->GetPassenger(damage - 1))
-                            {
-                                std::list<Unit*> unitList;
-                                // use 99 because it is 3d search
-                                SearchAreaTarget(unitList, 99, PUSH_DST_CENTER, SPELL_TARGETS_ENTRY, 33114);
-                                float minDist = 99 * 99;
-                                Vehicle *target = NULL;
-                                for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
-                                {
-                                    if (Vehicle *seat = (*itr)->GetVehicleKit())
-                                        if (!seat->GetPassenger(0))
-                                            if (Unit *device = seat->GetPassenger(2))
-                                                if (!device->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
-                                                {
-                                                    float dist = (*itr)->GetExactDistSq(&m_targets.m_dstPos);
-                                                    if (dist < minDist)
-                                                    {
-                                                        minDist = dist;
-                                                        target = seat;
-                                                    }
-                                                }
-                                }
-                                if (target && target->GetBase()->IsWithinDist2d(&m_targets.m_dstPos, GetSpellRadius(m_spellInfo, effIndex, false) * 2)) // now we use *2 because the location of the seat is not correct
-                                    passenger->EnterVehicle(target, 0);
-                                else
-                                {
-                                    passenger->ExitVehicle();
-                                    float x, y, z;
-                                    m_targets.m_dstPos.GetPosition(x, y, z);
-                                    passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
-                                }
-                            }
-                    }
-                    return;
-                }
-                case 64385:                                 // Unusual Compass
-                {
-                    m_caster->SetOrientation(float(urand(0,62832)) / 10000.0f);
-                    WorldPacket data;
-                    m_caster->BuildHeartBeatMsg(&data);
-                    m_caster->SendMessageToSet(&data,true);
-                    return;
-                }
-                case 199999: //Earthen Power Helper (SERVERSIDE)
-                {
-                    if (!m_caster->isTotem())
-                        return;
-
-                    if (AuraEffect * aurEff = m_caster->ToTotem()->GetOwner()->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 2289, 0))
-                        if (roll_chance_i(aurEff->GetAmount()))
-                            m_caster->CastSpell(m_caster, 59566, true, NULL, NULL, m_originalCasterGUID);
-                    return;
-                }
-                case 51962:                                 // Offer Jungle Punch
-                {
-
-                    if (!m_caster || !unitTarget)
-                        return;
-
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    if (unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    Creature *target_crature = unitTarget->ToCreature();
-                    Player *caster_player = m_caster->ToPlayer();
-                    if(target_crature && caster_player)
-                    {
-                        switch(target_crature->GetEntry())
-                        {
-                            case 27986:
-                            case 28047:
-                            case 28568:
-                                caster_player->KilledMonsterCredit(target_crature->GetEntry(),0);
-                                break;
-                            default:
-                                break;
-                        }
-                    }
-                    return;
-                }
-
-            }
-
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-            // Charge
-            if (m_spellInfo->SpellFamilyFlags & SPELLFAMILYFLAG_WARRIOR_CHARGE && m_spellInfo->SpellVisual[0] == 867)
-            {
-                int32 chargeBasePoints0 = damage;
-                m_caster->CastCustomSpell(m_caster, 34846, &chargeBasePoints0, NULL, NULL, true);
-
-                //Juggernaut crit bonus
-                if (m_caster->HasAura(64976))
-                    m_caster->CastSpell(m_caster, 65156, true);
-                return;
-            }
-            //Slam
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_SLAM && m_spellInfo->SpellIconID == 559)
-            {
-                int32 bp0 = damage;
-                m_caster->CastCustomSpell(unitTarget, 50783, &bp0, NULL, NULL, true, 0);
-                return;
-            }
-            // Execute
-            if (m_spellInfo->SpellFamilyFlags[EFFECT_0] & SPELLFAMILYFLAG_WARRIOR_EXECUTE)
-            {
-                if (!unitTarget)
-                    return;
-
-                spell_id = 20647;
-
-                int32 rageUsed = std::min<int32>(300 - m_powerCost, m_caster->GetPower(POWER_RAGE));
-                int32 newRage = std::max<int32>(0, m_caster->GetPower(POWER_RAGE) - rageUsed);
-
-                // Sudden Death rage save
-                if (AuraEffect * aurEff = m_caster->GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_GENERIC, 1989, EFFECT_0))
-                {
-                    int32 ragesave = SpellMgr::CalculateSpellEffectAmount(aurEff->GetSpellProto(), EFFECT_1) * 10;
-                    newRage = std::max(newRage, ragesave);
-                }
-
-                m_caster->SetPower(POWER_RAGE, uint32(newRage));
-
-                // Glyph of Execution bonus
-                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58367, EFFECT_0))
-                    rageUsed += aurEff->GetAmount() * 10;
-
-                bp = damage + int32(rageUsed * m_spellInfo->EffectDamageMultiplier[effIndex] + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.2f);
-                break;
-            }
-            // Concussion Blow
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_CONCUSSION_BLOW)
-            {
-                m_damage+= uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
-                return;
-            }
-            switch(m_spellInfo->Id)
-            {
-                // Bloodthirst
-                case 23881:
-                {
-                    m_caster->CastCustomSpell(unitTarget, 55970, &damage, NULL, NULL, true, NULL);
-                    return;
-                }
-                case 55046:
-                {
-                    if (!m_caster || !unitTarget)
-                        return;
-                    if (m_caster->GetTypeId() != TYPEID_UNIT)
-                        return;
-                    if (unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    Creature *target_crature = unitTarget->ToCreature();
-                    Creature *caster_crature = m_caster->ToCreature();
-                    if(target_crature && caster_crature && target_crature->GetEntry() == 29639 && caster_crature->GetOwner())
-                    {
-                        if(Player *plr = caster_crature->GetOwner()->ToPlayer())
-                        {
-                            plr->KilledMonsterCredit(29734,0);
-                            plr->KilledMonsterCredit(29709,0);
-                        }
-                        target_crature->ForcedDespawn();
-                        caster_crature->ForcedDespawn();
-                    }
-                    return;
-                }
-            }
-            break;
-        case SPELLFAMILY_WARLOCK:
-            // Life Tap
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARLOCK_LIFETAP)
-            {
-                float spFactor = 0.0f;
-                switch (m_spellInfo->Id)
-                {
-                    case 11689: spFactor = 0.2f; break;
-                    case 27222:
-                    case 57946: spFactor = 0.5f; break;
-                }
-                int32 damage = int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) + (6.3875 * m_spellInfo->baseLevel));
-                int32 mana = int32(damage + (m_caster->ToPlayer()->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+SPELL_SCHOOL_SHADOW) * spFactor));
-
-                if (unitTarget && (int32(unitTarget->GetHealth()) > damage))
-                {
-                    // Shouldn't Appear in Combat Log
-                    unitTarget->ModifyHealth(-damage);
-
-                    // Improved Life Tap mod
-                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 208, 0))
-                        mana = (aurEff->GetAmount() + 100)* mana / 100;
-
-                    m_caster->CastCustomSpell(unitTarget, 31818, &mana, NULL, NULL, true);
-
-                    // Mana Feed
-                    int32 manaFeedVal = 0;
-                    if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_WARLOCK, 1982, 0))
-                        manaFeedVal = aurEff->GetAmount();
-
-                    if (manaFeedVal > 0)
-                    {
-                        manaFeedVal = manaFeedVal * mana / 100;
-                        m_caster->CastCustomSpell(m_caster, 32553, &manaFeedVal, NULL, NULL, true, NULL);
-                    }
-                }
-                else
-                    SendCastResult(SPELL_FAILED_FIZZLE);
-                return;
-            }
-            break;
-        case SPELLFAMILY_DRUID:
-            // Starfall
-            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_DRUID_STARFALL)
-            {
-                //Shapeshifting into an animal form or mounting cancels the effect.
-                if (m_caster->GetCreatureType() == CREATURE_TYPE_BEAST || m_caster->IsMounted())
-                {
-                    if (m_triggeredByAuraSpell)
-                        m_caster->RemoveAurasDueToSpell(m_triggeredByAuraSpell->Id);
-                    return;
-                }
-
-                //Any effect which causes you to lose control of your character will supress the starfall effect.
-                if (m_caster->hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_FLEEING | UNIT_STAT_ROOT | UNIT_STAT_CONFUSED))
-                    return;
-
-                if ((unitTarget->HasAuraType(SPELL_AURA_MOD_STEALTH) || unitTarget->m_invisibilityMask) 
-                        && !m_caster->canSeeOrDetect(unitTarget, true))
-                    return;
-
-                m_caster->CastSpell(unitTarget, damage, true);
-                return;
-            }
-            break;
-        case SPELLFAMILY_PALADIN:
-            // Divine Storm
-             if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & SPELLFAMILYFLAG1_PALADIN_DIVINESTORM)
-            {
-                int32 dmg, m_damageO, m_healingO;
-                Unit * unitTargetO;
-                switch (effIndex)
-                {
-                    case EFFECT_0:
-                        m_damageO = m_damage; m_healingO = m_healing; unitTargetO = unitTarget;                       
-                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                            if (ihit->effectMask & (1<<EFFECT_2))
-                            {
-                                DoAllEffectOnTarget(&(*ihit));
-                                ihit->damage = m_damage;
-                           }
-                        m_damage = m_damageO; m_healing = m_healingO; unitTarget = unitTargetO;
-                        return;
-                    case EFFECT_1:
-                        dmg = 0;
-                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                            if (ihit->effectMask & (1<<EFFECT_2))
-                                dmg += ihit->damage;
-                        if (dmg)
-                        {
-                            if (!unitTarget)
-                                unitTarget = m_caster;
-                            dmg = int32((float)dmg * (float)damage / 100.0f);
-                            m_caster->CastCustomSpell(unitTarget, 54171, &dmg, 0, 0, true);
-                        }
-                        return;
-                    default:
-                        return;
-                }
-
-            }
-            switch(m_spellInfo->Id)
-            {
-                case 31789:                                 // Righteous Defense (step 1)
-                {
-                    // Clear targets for eff 1
-                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        ihit->effectMask &= ~(1<<1);
-
-                    // not empty (checked), copy
-                    Unit::AttackerSet attackers = unitTarget->getAttackers();
-
-                    // selected from list 3
-                    for (uint32 i = 0; i < std::min(size_t(3), attackers.size()); ++i)
-                    {
-                        Unit::AttackerSet::iterator aItr = attackers.begin();
-                        std::advance(aItr, rand() % attackers.size());
-                        AddUnitTarget((*aItr), 1);
-                        attackers.erase(aItr);
-                    }
-
-                    // now let next effect cast spell at each target.
-                    return;
-                }
-            }
-            break;
-        case SPELLFAMILY_SHAMAN:
-            // Cleansing Totem Pulse
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_TOTEM_EFFECTS && m_spellInfo->SpellIconID == 1673)
-            {
-                int32 bp1 = 1;
-                // Cleansing Totem Effect
-                if (unitTarget)
-                    m_caster->CastCustomSpell(unitTarget, 52025, NULL, &bp1, NULL, true, NULL, NULL, m_originalCasterGUID);
-                return;
-            }
-            // Healing Stream Totem
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_HEALING_STREAM)
-            {
-                if (!unitTarget)
-                    return;
-                // Restorative Totems
-                if (Unit *owner = m_caster->GetOwner())
-                    if (AuraEffect *dummy = owner->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 338, 1))
-                        damage += damage * dummy->GetAmount() / 100;
-
-                    m_caster->CastCustomSpell(unitTarget, 52042, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
-                return;
-            }
-            // Mana Spring Totem
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_MANA_SPRING)
-            {
-                if (!unitTarget || unitTarget->getPowerType() != POWER_MANA)
-                    return;
-                m_caster->CastCustomSpell(unitTarget, 52032, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
-                return;
-            }
-            // Lava Lash
-            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_SHAMAN_LAVA_LASH)
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return;
-
-                if (m_caster->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
-                {
-                    // Damage is increased by 25% if your off-hand weapon is enchanted with Flametongue.
-                    if (m_caster->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 0x200000, 0, 0))
-                        m_damage += m_damage * damage / 100;
-                }
-                return;
-            }
-            break;
-        case SPELLFAMILY_DEATHKNIGHT:
-            // Death strike
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_STRIKE)
-            {
-                uint32 count = unitTarget->GetDiseasesByCaster(m_caster->GetGUID());
-                int32 bp = int32(count * m_caster->CountPctFromMaxHealth(int32(m_spellInfo->EffectDamageMultiplier[0])));
-                // Improved Death Strike
-                if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DEATHKNIGHT, 2751, 0))
-                    bp = int32(bp * (m_caster->CalculateSpellDamage(m_caster, aurEff->GetSpellProto(), 2) + 100.0f) / 100.0f);
-                m_caster->CastCustomSpell(m_caster, 45470, &bp, NULL, NULL, false);
-                return;
-            }
-            // Death Coil
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_COIL)
-            {
-                if (m_caster->IsFriendlyTo(unitTarget))
-                {
-                    int32 bp = int32(damage * 1.5f);
-                    m_caster->CastCustomSpell(unitTarget, 47633, &bp, NULL, NULL, true);
-                }
-                else
-                {
-                    int32 bp = damage;
-                    m_caster->CastCustomSpell(unitTarget, 47632, &bp, NULL, NULL, true);
-                }
-                return;
-            }
-            switch (m_spellInfo->Id)
-            {
-            case 49560: // Death Grip
-                Position pos;
-                GetSummonPosition(effIndex, pos);
-                if (Unit *unit = unitTarget->GetVehicleBase()) // what is this for?
-                    unit->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
-                else
-                    unitTarget->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
-                return;
-            case 46584: // Raise Dead
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return;
-
-                // Do we have talent Master of Ghouls?
-                if (m_caster->HasAura(52143))
-                    // summon as pet
-                    bp = 52150;
-                else
-                    // or guardian
-                    bp = 46585;
-
-                if (m_targets.HasDst())
-                    targets.setDst(m_targets.m_dstPos);
-                else
-                {
-                    targets.setDst(*m_caster);
-                    // Corpse not found - take reagents (only not triggered cast can take them)
-                    triggered = false;
-                }
-                // Remove cooldown - summon spellls have category
-                m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id, true);
-                spell_id = 48289;
-                break;
-            // Raise dead - take reagents and trigger summon spells
-            case 48289:
-                if (m_targets.HasDst())
-                    targets.setDst(m_targets.m_dstPos);
-
-                spell_id = CalculateDamage(0, NULL);
-                break;
-            }
-            break;
-        case SPELLFAMILY_MAGE:
-        {
-            switch (m_spellInfo->Id)
-            {
-                case 44450: // Burnout
-                {
-                    if (!unitTarget)
-                        return;
-
-                    unitTarget->ModifyPower(POWER_MANA, -damage);
-                    return;
-                }
-                default:
-                    break;
-            }
-            break;
-        }
-        default:
-            break;
-    }
-
-    //spells triggered by dummy effect should not miss
-    if (spell_id)
-    {
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
-
-        if (!spellInfo)
-        {
-            sLog.outError("EffectDummy of spell %u: triggering unknown spell id %i\n", m_spellInfo->Id, spell_id);
-            return;
-        }
-
-        targets.setUnitTarget(unitTarget);
-        Spell* spell = new Spell(m_caster, spellInfo, triggered, m_originalCasterGUID, true);
-        if (bp) spell->SetSpellValue(SPELLVALUE_BASE_POINT0, bp);
-        spell->prepare(&targets);
-    }
-
-    // pet auras
-    if (PetAura const* petSpell = sSpellMgr.GetPetAura(m_spellInfo->Id,effIndex))
-    {
-        m_caster->AddPetAura(petSpell);
-        return;
-    }
-
-    // normal DB scripted effect
-    sLog.outDebug("Spell ScriptStart spellid %u in EffectDummy(%u)", m_spellInfo->Id, effIndex);
-    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
-
-    // Script based implementation. Must be used only for not good for implementation in core spell effects
-    // So called only for not proccessed cases
-    if (gameObjTarget)
-        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, gameObjTarget);
-    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_UNIT)
-        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, unitTarget->ToCreature());
-    else if (itemTarget)
-        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, itemTarget);
-}
-
-void Spell::EffectTriggerSpellWithValue(SpellEffIndex effIndex)
-{
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerSpellWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    int32 bp = damage;
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastCustomSpell(unitTarget,triggered_spell_id,&bp,&bp,&bp,true);
-}
-
-void Spell::EffectTriggerRitualOfSummoning(SpellEffIndex effIndex)
-{
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerRitualOfSummoning of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    finish();
-
-    m_caster->CastSpell(unitTarget,spellInfo,false);
-}
-
-void Spell::EffectForceCast(SpellEffIndex effIndex)
-{
-      switch(m_spellInfo->Id)
-      {
-               case 66548://Teleport (IC battleground)
-               {
-                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(23472,60.0f,true))
-                       {
-                               float x,y,z,o;
-                               TargetTeleport->GetPosition(x,y,z,o);
-                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
-                                       return;
-                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
-                       }
-                       return;        
-               }
-               case 66549:
-               {
-                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(22515,60.0f,true))
-                       {
-                               float x,y,z,o;
-                               TargetTeleport->GetPosition(x,y,z,o);
-                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
-                                       return;
-                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
-                       }
-                       return;
-               }
-       }
-
-    if (!unitTarget)
-        return;
-
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectForceCast of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    if (damage)
-    {
-        switch(m_spellInfo->Id)
-        {
-                case 66218: //Catapulte
-                if (Vehicle *vehicle = m_caster->GetVehicleKit())
-                    if (Unit *passenger = vehicle->GetPassenger(0))
-                    {
-                        passenger->ExitVehicle();
-                    passenger->AddAura(66251,passenger);
-                        float x, y, z;
-                        m_targets.m_dstPos.GetPosition(x, y, z);
-                        passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
-                    }                    
-                return;    
-            case 66629:
-            case 66638:
-            {
-                if(!(m_caster->GetTypeId()==TYPEID_PLAYER))
-                    return;
-                Player *plr = m_caster->ToPlayer();
-                if (Battleground *bg = plr->GetBattleground())
-                    {
-                        if (bg->GetTypeID(true) == BATTLEGROUND_IC)
-                            bg->EventPlayerCapturedFlag(plr);
-                        return;
-                    }
-                
-                return;
-            }
-            case 52588: // Skeletal Gryphon Escape
-            case 48598: // Ride Flamebringer Cue
-                unitTarget->RemoveAura(damage);
-                break;
-            case 52463: // Hide In Mine Car
-            case 52349: // Overtake
-                unitTarget->CastCustomSpell(unitTarget, spellInfo->Id, &damage, NULL, NULL, true, NULL, NULL, m_originalCasterGUID);
-                return;
-            case 72378: // Blood Nova
-            case 73058: // Blood Nova
-                spellInfo = sSpellMgr.GetSpellForDifficultyFromSpell(spellInfo, m_caster);
-                break;
-        }
-    }
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastSpell(unitTarget, spellInfo, true, NULL, NULL, m_originalCasterGUID);
-}
-
-void Spell::EffectForceCastWithValue(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectForceCastWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-    int32 bp = damage;
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastCustomSpell(unitTarget, spellInfo->Id, &bp, &bp, &bp, true, NULL, NULL, m_originalCasterGUID);
-}
-
-
-void Spell::EffectTriggerSpell(SpellEffIndex effIndex)
-{
-    // only unit case known
-    if (!unitTarget)
-    {
-        if (gameObjTarget || itemTarget)
-            sLog.outError("Spell::EffectTriggerSpell (Spell: %u): Unsupported non-unit case!",m_spellInfo->Id);
-        return;
-    }
-
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-    Unit* originalCaster = NULL;
-
-    // special cases
-    switch(triggered_spell_id)
-    {
-        // Mirror Image
-        case 58832:
-        {
-            // Glyph of Mirror Image
-            if (m_caster->HasAura(63093))
-               m_caster->CastSpell(m_caster, 65047, true); // Mirror Image
-
-            break;
-        }
-        // Vanish (not exist)
-        case 18461:
-        {
-            unitTarget->RemoveMovementImpairingAuras();
-            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
-
-            // if this spell is given to NPC it must handle rest by it's own AI
-            if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-                return;
-
-            // get highest rank of the Stealth spell
-            uint32 spellId = 0;
-            SpellEntry const *spellInfo;
-            const PlayerSpellMap& sp_list = unitTarget->ToPlayer()->GetSpellMap();
-            for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
-            {
-                // only highest rank is shown in spell book, so simply check if shown in spell book
-                if (!itr->second->active || itr->second->disabled || itr->second->state == PLAYERSPELL_REMOVED)
-                    continue;
-
-                spellInfo = sSpellStore.LookupEntry(itr->first);
-                if (!spellInfo)
-                    continue;
-
-                if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_ROGUE_STEALTH)
-                {
-                    spellId = spellInfo->Id;
-                    break;
-                }
-            }
-
-            // no Stealth spell found
-            if (!spellId)
-                return;
-
-            // reset cooldown on it if needed
-            if (unitTarget->ToPlayer()->HasSpellCooldown(spellId))
-                unitTarget->ToPlayer()->RemoveSpellCooldown(spellId);
-
-            triggered_spell_id =  spellId;
-            break;
-        }
-        // Demonic Empowerment -- succubus
-        case 54437:
-        {
-            unitTarget->RemoveMovementImpairingAuras();
-            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
-            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STUN);
-
-            // Cast Lesser Invisibility
-            triggered_spell_id = 7870;
-            break;
-        }
-        // just skip
-        case 23770:                                         // Sayge's Dark Fortune of *
-            // not exist, common cooldown can be implemented in scripts if need.
-            return;
-        // Brittle Armor - (need add max stack of 24575 Brittle Armor)
-        case 29284:
-        {
-            // Brittle Armor
-            SpellEntry const* spell = sSpellStore.LookupEntry(24575);
-            if (!spell)
-                return;
-
-            for (uint32 j = 0; j < spell->StackAmount; ++j)
-                m_caster->CastSpell(unitTarget, spell->Id, true);
-            return;
-        }
-        // Mercurial Shield - (need add max stack of 26464 Mercurial Shield)
-        case 29286:
-        {
-            // Mercurial Shield
-            SpellEntry const* spell = sSpellStore.LookupEntry(26464);
-            if (!spell)
-                return;
-
-            for (uint32 j = 0; j < spell->StackAmount; ++j)
-                m_caster->CastSpell(unitTarget, spell->Id, true);
-            return;
-        }
-        // Righteous Defense
-        case 31980:
-        {
-            m_caster->CastSpell(unitTarget, 31790, true);
-            return;
-        }
-        // Cloak of Shadows
-        case 35729:
-        {
-            uint32 dispelMask = GetDispellMask(DISPEL_ALL);
-            Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
-            for (Unit::AuraApplicationMap::iterator iter = Auras.begin(); iter != Auras.end();)
-            {
-                // remove all harmful spells on you...
-                SpellEntry const* spell = iter->second->GetBase()->GetSpellProto();
-                if ((spell->DmgClass == SPELL_DAMAGE_CLASS_MAGIC // only affect magic spells
-                    || ((1<<spell->Dispel) & dispelMask))
-                    // ignore positive and passive auras
-                    && !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive() && !iter->second->GetBase()->IsDeathPersistent())
-                {
-                    m_caster->RemoveAura(iter);
-                }
-                else
-                    iter++;
-            }
-            return;
-        }
-        // Priest Shadowfiend (34433) need apply mana gain trigger aura on pet
-        case 41967:
-        {
-            if (Unit *pet = unitTarget->GetGuardianPet())
-                pet->CastSpell(pet, 28305, true);
-            return;
-        }
-        // Empower Rune Weapon
-        case 53258:
-            return; // skip, hack-added in spell effect
-        // Snake Trap
-        case 57879:
-            originalCaster = m_originalCaster;
-            break;
-        // Coldflame
-        case 33801:
-            return; // just make the core stfu
-    }
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerSpell of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
-    // Needed by freezing arrow and few other spells
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
-        && m_spellInfo->Category == spellInfo->Category)
-        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
-
-    // Note: not exist spells with weapon req. and IsSpellHaveCasterSourceTargets == true
-    // so this just for speedup places in else
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastSpell(unitTarget,spellInfo,true, 0, 0, (originalCaster ? originalCaster->GetGUID() : 0));
-}
-
-void Spell::EffectTriggerMissileSpell(SpellEffIndex effIndex)
-{
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerMissileSpell of spell %u (eff: %u): triggering unknown spell id %u",
-            m_spellInfo->Id,effIndex,triggered_spell_id);
-        return;
-    }
-
-    if (m_CastItem)
-        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
-
-    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
-    // Needed by freezing arrow and few other spells
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
-        && m_spellInfo->Category == spellInfo->Category)
-        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
-
-    float x, y, z;
-    m_targets.m_dstPos.GetPosition(x, y, z);
-    m_caster->CastSpell(x, y, z, spellInfo->Id, true, m_CastItem, 0, m_originalCasterGUID);
-}
-
-void Spell::EffectJump(SpellEffIndex effIndex)
-{
-    if (m_caster->isInFlight())
-        return;
-
-    float x,y,z,o;
-    if (m_targets.getUnitTarget())
-    {
-        m_targets.getUnitTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
-        o = m_caster->GetOrientation();
-    }
-    else if (m_targets.getGOTarget())
-    {
-        m_targets.getGOTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
-        o = m_caster->GetOrientation();
-    }
-    else
-    {
-        sLog.outError("Spell::EffectJump - unsupported target mode for spell ID %u", m_spellInfo->Id);
-        return;
-    }
-
-    float speedXY, speedZ;
-    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
-    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
-}
-
-void Spell::EffectJumpDest(SpellEffIndex effIndex)
-{
-    if (m_caster->isInFlight())
-        return;
-
-    // Init dest coordinates
-    float x,y,z,o;
-    if (m_targets.HasDst())
-    {
-        m_targets.m_dstPos.GetPosition(x, y, z);
-
-        if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DEST_TARGET_BACK)
-        {
-            // explicit cast data from client or server-side cast
-            // some spell at client send caster
-            Unit* pTarget = NULL;
-            if (m_targets.getUnitTarget() && m_targets.getUnitTarget() != m_caster)
-                pTarget = m_targets.getUnitTarget();
-            else if (m_caster->getVictim())
-                pTarget = m_caster->getVictim();
-            else if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                pTarget = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
-
-            o = pTarget ? pTarget->GetOrientation() : m_caster->GetOrientation();
-        }
-        else
-            o = m_caster->GetOrientation();
-    }
-    else
-    {
-        sLog.outError("Spell::EffectJumpDest - unsupported target mode for spell ID %u", m_spellInfo->Id);
-        return;
-    }
-
-    float speedXY, speedZ;
-    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
-    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
-}
-
-void Spell::CalculateJumpSpeeds(uint8 i, float dist, float & speedXY, float & speedZ)
-{
-    if (m_spellInfo->EffectMiscValue[i])
-        speedZ = float(m_spellInfo->EffectMiscValue[i])/10;
-    else if (m_spellInfo->EffectMiscValueB[i])
-        speedZ = float(m_spellInfo->EffectMiscValueB[i])/10;
-    else
-        speedZ = 10.0f;
-    speedXY = dist * 10.0f / speedZ;
-}
-
-void Spell::EffectTeleportUnits(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->isInFlight())
-        return;
-
-    // Pre effects
-    uint8 uiMaxSafeLevel = 0;
-    switch (m_spellInfo->Id)
-    {
-        case 66550:
-            return;
-        case 48129:  // Scroll of Recall
-            uiMaxSafeLevel = 40;
-        case 60320:  // Scroll of Recall II
-            if (!uiMaxSafeLevel)
-                uiMaxSafeLevel = 70;
-        case 60321:  // Scroll of Recal III
-            if (!uiMaxSafeLevel)
-                uiMaxSafeLevel = 80;
-
-            if (unitTarget->getLevel() > uiMaxSafeLevel)
-            {
-                unitTarget->AddAura(60444,unitTarget); //Apply Lost! Aura
-                return;
-            }
-            break;
-    }
-
-    // If not exist data for dest location - return
-    if (!m_targets.HasDst())
-    {
-        sLog.outError("Spell::EffectTeleportUnits - does not have destination for spell ID %u\n", m_spellInfo->Id);
-        return;
-    }
-
-    // Init dest coordinates
-    uint32 mapid = m_targets.m_dstPos.GetMapId();
-    if (mapid == MAPID_INVALID)
-        mapid = unitTarget->GetMapId();
-    float x, y, z, orientation;
-    m_targets.m_dstPos.GetPosition(x, y, z, orientation);
-    if (!orientation && m_targets.getUnitTarget())
-        orientation = m_targets.getUnitTarget()->GetOrientation();
-    sLog.outDebug("Spell::EffectTeleportUnits - teleport unit to %u %f %f %f %f\n", mapid, x, y, z, orientation);
-
-    if (mapid == unitTarget->GetMapId())
-        unitTarget->NearTeleportTo(x, y, z, orientation, unitTarget == m_caster);
-    else if (unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->TeleportTo(mapid, x, y, z, orientation, unitTarget == m_caster ? TELE_TO_SPELL : 0);
-
-    // post effects for TARGET_DST_DB
-    switch (m_spellInfo->Id)
-    {
-        // Dimensional Ripper - Everlook
-        case 23442:
-        {
-            int32 r = irand(0, 119);
-            if (r >= 70)                                  // 7/12 success
-            {
-                if (r < 100)                              // 4/12 evil twin
-                    m_caster->CastSpell(m_caster, 23445, true);
-                else                                        // 1/12 fire
-                    m_caster->CastSpell(m_caster, 23449, true);
-            }
-            return;
-        }
-        // Ultrasafe Transporter: Toshley's Station
-        case 36941:
-        {
-            if (roll_chance_i(50))                        // 50% success
-            {
-                int32 rand_eff = urand(1, 7);
-                switch (rand_eff)
-                {
-                    case 1:
-                        // soul split - evil
-                        m_caster->CastSpell(m_caster, 36900, true);
-                        break;
-                    case 2:
-                        // soul split - good
-                        m_caster->CastSpell(m_caster, 36901, true);
-                        break;
-                    case 3:
-                        // Increase the size
-                        m_caster->CastSpell(m_caster, 36895, true);
-                        break;
-                    case 4:
-                        // Decrease the size
-                        m_caster->CastSpell(m_caster, 36893, true);
-                        break;
-                    case 5:
-                    // Transform
-                    {
-                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                            m_caster->CastSpell(m_caster, 36897, true);
-                        else
-                            m_caster->CastSpell(m_caster, 36899, true);
-                        break;
-                    }
-                    case 6:
-                        // chicken
-                        m_caster->CastSpell(m_caster, 36940, true);
-                        break;
-                    case 7:
-                        // evil twin
-                        m_caster->CastSpell(m_caster, 23445, true);
-                        break;
-                }
-            }
-            return;
-        }
-        // Dimensional Ripper - Area 52
-        case 36890:
-        {
-            if (roll_chance_i(50))                        // 50% success
-            {
-                int32 rand_eff = urand(1, 4);
-                switch (rand_eff)
-                {
-                    case 1:
-                        // soul split - evil
-                        m_caster->CastSpell(m_caster, 36900, true);
-                        break;
-                    case 2:
-                        // soul split - good
-                        m_caster->CastSpell(m_caster, 36901, true);
-                        break;
-                    case 3:
-                        // Increase the size
-                        m_caster->CastSpell(m_caster, 36895, true);
-                        break;
-                    case 4:
-                        // Transform
-                    {
-                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                            m_caster->CastSpell(m_caster, 36897, true);
-                        else
-                            m_caster->CastSpell(m_caster, 36899, true);
-                        break;
-                    }
-                }
-            }
-            return;
-        }
-    }
-}
-
-void Spell::EffectApplyAura(SpellEffIndex effIndex)
-{
-    if (!m_spellAura || !unitTarget)
-        return;
-    ASSERT(unitTarget == m_spellAura->GetOwner());
-    m_spellAura->_ApplyEffectForTargets(effIndex);
-}
-
-void Spell::EffectApplyAreaAura(SpellEffIndex effIndex)
-{
-    if (!m_spellAura || !unitTarget)
-        return;
-    ASSERT (unitTarget == m_spellAura->GetOwner());
-    m_spellAura->_ApplyEffectForTargets(effIndex);
-}
-
-void Spell::EffectUnlearnSpecialization(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)unitTarget;
-    uint32 spellToUnlearn = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    _player->removeSpell(spellToUnlearn);
-
-    sLog.outDebug("Spell: Player %u has unlearned spell %u from NpcGUID: %u", _player->GetGUIDLow(), spellToUnlearn, m_caster->GetGUIDLow());
-}
-
-void Spell::EffectPowerDrain(SpellEffIndex effIndex)
-{
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
-        return;
-
-    // add spell damage bonus
-    damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, uint32(damage), SPELL_DIRECT_DAMAGE);
-
-    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
-    int32 power = damage;
-    if (powerType == POWER_MANA)
-        power -= unitTarget->GetSpellCritDamageReduction(power);
-
-    int32 newDamage = -(unitTarget->ModifyPower(powerType, -int32(power)));
-
-    float gainMultiplier = 0.0f;
-
-    // Don`t restore from self drain
-    if (m_caster != unitTarget)
-    {
-        gainMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
-
-        int32 gain = int32(newDamage * gainMultiplier);
-
-        m_caster->EnergizeBySpell(m_caster, m_spellInfo->Id, gain, powerType);
-    }
-    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, gainMultiplier);
-}
-
-void Spell::EffectSendEvent(SpellEffIndex effIndex)
-{
-    /*
-    we do not handle a flag dropping or clicking on flag in battleground by sendevent system
-    */
-    sLog.outDebug("Spell ScriptStart %u for spellid %u in EffectSendEvent ", m_spellInfo->EffectMiscValue[effIndex], m_spellInfo->Id);
-
-    Object *pTarget;
-    if (focusObject)
-        pTarget = focusObject;
-    else if (unitTarget)
-        pTarget = unitTarget;
-    else if (gameObjTarget)
-        pTarget = gameObjTarget;
-    else
-        pTarget = NULL;
-
-    m_caster->GetMap()->ScriptsStart(sEventScripts, m_spellInfo->EffectMiscValue[effIndex], m_caster, pTarget);
-}
-
-void Spell::EffectPowerBurn(SpellEffIndex effIndex)
-{
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
-        return;
-
-    // burn x% of target's mana, up to maximum of 2x% of caster's mana (Mana Burn)
-    if (m_spellInfo->ManaCostPercentage)
-    {
-        int32 maxDamage = m_caster->GetMaxPower(powerType) * damage * 2 / 100;
-        damage = unitTarget->GetMaxPower(powerType) * damage / 100;
-        damage = std::min(damage, maxDamage);
-    }
-
-    int32 power = damage;
-    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
-    if (powerType == POWER_MANA)
-        power -= unitTarget->GetSpellCritDamageReduction(power);
-
-    int32 newDamage = -(unitTarget->ModifyPower(powerType, -power));
-
-    // NO - Not a typo - EffectPowerBurn uses effect value multiplier - not effect damage multiplier
-    float dmgMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
-
-    // add log data before multiplication (need power amount, not damage)
-    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, 0.0f);
-
-    newDamage = int32(newDamage * dmgMultiplier);
-
-    m_damage += newDamage;
-}
-
-void Spell::EffectHeal(SpellEffIndex /*effIndex*/)
-{
-}
-
-void Spell::SpellDamageHeal(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->isAlive() && damage >= 0)
-    {
-        // Try to get original caster
-        Unit *caster = m_originalCasterGUID ? m_originalCaster : m_caster;
-
-        // Skip if m_originalCaster not available
-        if (!caster)
-            return;
-
-        int32 addhealth = damage;
-
-        // Vessel of the Naaru (Vial of the Sunwell trinket)
-        if (m_spellInfo->Id == 45064)
-        {
-            // Amount of heal - depends from stacked Holy Energy
-            int damageAmount = 0;
-            if (AuraEffect const * aurEff = m_caster->GetAuraEffect(45062, 0))
-            {
-                damageAmount+= aurEff->GetAmount();
-                m_caster->RemoveAurasDueToSpell(45062);
-            }
-
-            addhealth += damageAmount;
-        }
-        else if (m_spellInfo->Id == 67489 || m_spellInfo->Id == 67489)
-        {
-            if (m_caster->ToPlayer() != NULL && m_caster->ToPlayer()->HasSkill(SKILL_ENGINERING))
-                addhealth *= 1.25;
-        }
-        // Swiftmend - consumes Regrowth or Rejuvenation
-        else if (m_spellInfo->TargetAuraState == AURA_STATE_SWIFTMEND && unitTarget->HasAuraState(AURA_STATE_SWIFTMEND, m_spellInfo, m_caster))
-        {
-            Unit::AuraEffectList const& RejorRegr = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
-            // find most short by duration
-            AuraEffect *targetAura = NULL;
-            for (Unit::AuraEffectList::const_iterator i = RejorRegr.begin(); i != RejorRegr.end(); ++i)
-            {
-                if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID
-                    && (*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x50)
-                {
-                    if (!targetAura || (*i)->GetBase()->GetDuration() < targetAura->GetBase()->GetDuration())
-                        targetAura = *i;
-                }
-            }
-
-            if (!targetAura)
-            {
-                sLog.outError("Target(GUID:" UI64FMTD ") has aurastate AURA_STATE_SWIFTMEND but no matching aura.", unitTarget->GetGUID());
-                return;
-            }
-
-            int32 tickheal = targetAura->GetAmount();
-            if (Unit* auraCaster = targetAura->GetCaster())
-                tickheal = auraCaster->SpellHealingBonus(unitTarget, targetAura->GetSpellProto(), tickheal, DOT);
-            //int32 tickheal = targetAura->GetSpellProto()->EffectBasePoints[idx] + 1;
-            //It is said that talent bonus should not be included
-
-            int32 tickcount = 0;
-            // Rejuvenation
-            if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x10)
-                tickcount = 4;
-            // Regrowth
-            else // if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x40)
-                tickcount = 6;
-
-            addhealth += tickheal * tickcount;
-
-            // Glyph of Swiftmend
-            if (!caster->HasAura(54824))
-                unitTarget->RemoveAura(targetAura->GetId(), targetAura->GetCasterGUID());
-
-            //addhealth += tickheal * tickcount;
-            //addhealth = caster->SpellHealingBonus(m_spellInfo, addhealth,HEAL, unitTarget);
-        }
-        // Glyph of Nourish
-        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x2000000)
-        {
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
-
-            if (AuraEffect const* aurEff = m_caster->GetAuraEffect(62971, 0))
-            {
-                Unit::AuraEffectList const& Periodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
-                for (Unit::AuraEffectList::const_iterator i = Periodic.begin(); i != Periodic.end(); ++i)
-                {
-                    if (m_caster->GetGUID() == (*i)->GetCasterGUID())
-                        addhealth += addhealth * aurEff->GetAmount() / 100;
-                }
-            }
-        }
-        // Lifebloom - final heal coef multiplied by original DoT stack
-        else if (m_spellInfo->Id == 33778)
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL, m_spellValue->EffectBasePoints[1]);
-        // Riptide - increase healing done by Chain Heal
-        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x100)
-        {
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
-            if (AuraEffect * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0, 0, 0x10, m_originalCasterGUID))
-            {
-                addhealth = int32(addhealth * 1.25f);
-                // consume aura
-                unitTarget->RemoveAura(aurEff->GetBase());
-            }
-            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-            {
-                if (unitTarget->GetGUID() != ihit->targetGUID)
-                    addhealth = addhealth * 0.4;
-                else
-                    break;
-            }
-        }
-        // Death Pact - return pct of max health to caster
-        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, int32(caster->CountPctFromMaxHealth(damage)), HEAL);
-        else
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
-
-        // Remove Grievious bite if fully healed
-        if (unitTarget->HasAura(48920) && (unitTarget->GetHealth() + addhealth >= unitTarget->GetMaxHealth()))
-            unitTarget->RemoveAura(48920);
-
-        m_damage -= addhealth;
-    }
-}
-
-void Spell::EffectHealPct(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
-        return;
-
-    // Skip if m_originalCaster not available
-    if (!m_originalCaster)
-        return;
-
-    // Rune Tap - Party
-    if (m_spellInfo->Id == 59754 && unitTarget == m_caster)
-        return;
-
-    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, unitTarget->CountPctFromMaxHealth(damage), HEAL);
-}
-
-void Spell::EffectHealMechanical(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
-        return;
-
-    // Skip if m_originalCaster not available
-    if (!m_originalCaster)
-        return;
-
-    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, uint32(damage), HEAL);
-}
-
-void Spell::EffectHealthLeech(SpellEffIndex effIndex)
-{
-    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
-        return;
-
-    sLog.outDebug("HealthLeech :%i", damage);
-
-    float healMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
-
-    m_damage += damage;
-    // get max possible damage, don't count overkill for heal
-    uint32 healthGain = uint32(-unitTarget->GetHealthGain(-damage) * healMultiplier);
-
-    if (m_caster->isAlive())
-    {
-        healthGain = m_caster->SpellHealingBonus(m_caster, m_spellInfo, healthGain, HEAL);
-        m_caster->HealBySpell(m_caster, m_spellInfo, uint32(healthGain));
-    }
-}
-
-void Spell::DoCreateItem(uint32 /*i*/, uint32 itemtype)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* player = (Player*)unitTarget;
-
-    uint32 newitemid = itemtype;
-    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(newitemid);
-    if (!pProto)
-    {
-        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-        return;
-    }
-
-    // bg reward have some special in code work
-    uint32 bgType = 0;
-    switch(m_spellInfo->Id)
-    {
-        case SPELL_AV_MARK_WINNER:
-        case SPELL_AV_MARK_LOSER:
-            bgType = BATTLEGROUND_AV;
-            break;
-        case SPELL_WS_MARK_WINNER:
-        case SPELL_WS_MARK_LOSER:
-            bgType = BATTLEGROUND_WS;
-            break;
-        case SPELL_AB_MARK_WINNER:
-        case SPELL_AB_MARK_LOSER:
-            bgType = BATTLEGROUND_AB;
-            break;
-        default:
-            break;
-    }
-
-    uint32 num_to_add = damage;
-
-    if (num_to_add < 1)
-        num_to_add = 1;
-    if (num_to_add > pProto->GetMaxStackSize())
-        num_to_add = pProto->GetMaxStackSize();
-
-    // init items_count to 1, since 1 item will be created regardless of specialization
-    int items_count=1;
-    // the chance to create additional items
-    float additionalCreateChance=0.0f;
-    // the maximum number of created additional items
-    uint8 additionalMaxNum=0;
-    // get the chance and maximum number for creating extra items
-    if (canCreateExtraItems(player, m_spellInfo->Id, additionalCreateChance, additionalMaxNum))
-    {
-        // roll with this chance till we roll not to create or we create the max num
-        while (roll_chance_f(additionalCreateChance) && items_count <= additionalMaxNum)
-            ++items_count;
-    }
-
-    // really will be created more items
-    num_to_add *= items_count;
-
-    // can the player store the new item?
-    ItemPosCountVec dest;
-    uint32 no_space = 0;
-    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, num_to_add, &no_space);
-    if (msg != EQUIP_ERR_OK)
-    {
-        // convert to possible store amount
-        if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
-            num_to_add -= no_space;
-        else
-        {
-            // if not created by another reason from full inventory or unique items amount limitation
-            player->SendEquipError(msg, NULL, NULL, newitemid);
-            return;
-        }
-    }
-
-    if (num_to_add)
-    {
-        // create the new item and store it
-        Item* pItem = player->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
-
-        // was it successful? return error if not
-        if (!pItem)
-        {
-            player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-            return;
-        }
-
-        // set the "Crafted by ..." property of the item
-        if (pItem->GetProto()->Class != ITEM_CLASS_CONSUMABLE && pItem->GetProto()->Class != ITEM_CLASS_QUEST && newitemid != 6265 && newitemid != 6948)
-            pItem->SetUInt32Value(ITEM_FIELD_CREATOR, player->GetGUIDLow());
-
-        // send info to the client
-        if (pItem)
-            player->SendNewItem(pItem, num_to_add, true, bgType == 0);
-
-        // we succeeded in creating at least one item, so a levelup is possible
-        if (bgType == 0)
-            player->UpdateCraftSkill(m_spellInfo->Id);
-    }
-
-/*
-    // for battleground marks send by mail if not add all expected
-    if (no_space > 0 && bgType)
-    {
-        if (Battleground* bg = sBattlegroundMgr.GetBattlegroundTemplate(BattlegroundTypeId(bgType)))
-            bg->SendRewardMarkByMail(player, newitemid, no_space);
-    }
-*/
-}
-
-void Spell::EffectCreateItem(SpellEffIndex effIndex)
-{
-    DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
-    ExecuteLogEffectCreateItem(effIndex, m_spellInfo->EffectItemType[effIndex]);
-}
-
-void Spell::EffectCreateItem2(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player* player = (Player*)m_caster;
-
-    uint32 item_id = m_spellInfo->EffectItemType[effIndex];
-
-    if (item_id)
-        DoCreateItem(effIndex, item_id);
-
-    // special case: fake item replaced by generate using spell_loot_template
-    if (IsLootCraftingSpell(m_spellInfo))
-    {
-        if (item_id)
-        {
-            if (!player->HasItemCount(item_id, 1))
-                return;
-
-            // remove reagent
-            uint32 count = 1;
-            player->DestroyItemCount(item_id, count, true);
-
-            // create some random items
-            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
-        }
-        else
-            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);    // create some random items
-    }
-    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
-}
-
-void Spell::EffectCreateRandomItem(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player* player = (Player*)m_caster;
-
-    // create some random items
-    player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
-    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
-}
-
-void Spell::EffectPersistentAA(SpellEffIndex effIndex)
-{
-    if (!m_spellAura)
-    {
-        float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-        if (Player* modOwner = m_originalCaster->GetSpellModOwner())
-            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, radius);
-
-        Unit *caster = m_caster->GetEntry() == WORLD_TRIGGER ? m_originalCaster : m_caster;
-        // Caster not in world, might be spell triggered from aura removal
-        if (!caster->IsInWorld())
-            return;
-        DynamicObject* dynObj = new DynamicObject;
-        if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), caster, m_spellInfo->Id, m_targets.m_dstPos, radius, false))
-        {
-            delete dynObj;
-            return;
-        }
-        caster->AddDynObject(dynObj);
-        dynObj->GetMap()->Add(dynObj);
-
-        if (Aura * aura = Aura::TryCreate(m_spellInfo, dynObj, caster, &m_spellValue->EffectBasePoints[0]))
-            m_spellAura = aura;
-        else
-        {
-            ASSERT(false);
-            return;
-        }
-        m_spellAura->_RegisterForTargets();
-    }
-    ASSERT(m_spellAura->GetDynobjOwner());
-    m_spellAura->_ApplyEffectForTargets(effIndex);
-}
-
-void Spell::EffectEnergize(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (!unitTarget->isAlive())
-        return;
-
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    // Some level depends spells
-    int level_multiplier = 0;
-    int level_diff = 0;
-    switch (m_spellInfo->Id)
-    {
-        case 9512:                                          // Restore Energy
-            level_diff = m_caster->getLevel() - 40;
-            level_multiplier = 2;
-            break;
-        case 24571:                                         // Blood Fury
-            level_diff = m_caster->getLevel() - 60;
-            level_multiplier = 10;
-            break;
-        case 24532:                                         // Burst of Energy
-            level_diff = m_caster->getLevel() - 60;
-            level_multiplier = 4;
-            break;
-        case 31930:                                         // Judgements of the Wise
-        case 63375:                                         // Improved Stormstrike
-        case 68082:                                         // Glyph of Seal of Command
-            damage = damage * unitTarget->GetCreateMana() / 100;
-            break;
-        case 48542:                                         // Revitalize
-            damage = damage * unitTarget->GetMaxPower(power) / 100;
-            break;
-        case 67490:
-        case 67487:
-            if (m_caster->ToPlayer() != NULL && m_caster->ToPlayer()->HasSkill(SKILL_ENGINERING))
-                damage *= 1.25;
-            break;
-        default:
-            break;
-    }
-
-    if (level_diff > 0)
-        damage -= level_multiplier * level_diff;
-
-    if (damage < 0)
-        return;
-
-    if (unitTarget->GetMaxPower(power) == 0)
-        return;
-
-    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, damage, power);
-
-    // Mad Alchemist's Potion
-    if (m_spellInfo->Id == 45051)
-    {
-        // find elixirs on target
-        bool guardianFound = false;
-        bool battleFound = false;
-        Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
-        for (Unit::AuraApplicationMap::iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
-        {
-            uint32 spell_id = itr->second->GetBase()->GetId();
-            if (!guardianFound)
-                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_GUARDIAN))
-                    guardianFound = true;
-            if (!battleFound)
-                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_BATTLE))
-                    battleFound = true;
-            if (battleFound && guardianFound)
-                break;
-        }
-
-        // get all available elixirs by mask and spell level
-        std::set<uint32> avalibleElixirs;
-        if (!guardianFound)
-            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_GUARDIAN, avalibleElixirs);
-        if (!battleFound)
-            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_BATTLE, avalibleElixirs);
-        for (std::set<uint32>::iterator itr = avalibleElixirs.begin(); itr != avalibleElixirs.end() ;)
-        {
-            SpellEntry const *spellInfo = sSpellStore.LookupEntry(*itr);
-            if (spellInfo->spellLevel < m_spellInfo->spellLevel || spellInfo->spellLevel > unitTarget->getLevel())
-                avalibleElixirs.erase(itr++);
-            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_SHATTRATH))
-                avalibleElixirs.erase(itr++);
-            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_UNSTABLE))
-                avalibleElixirs.erase(itr++);
-            else
-                ++itr;
-        }
-
-        if (!avalibleElixirs.empty())
-        {
-            // cast random elixir on target
-            uint32 rand_spell = urand(0,avalibleElixirs.size()-1);
-            std::set<uint32>::iterator itr = avalibleElixirs.begin();
-            std::advance(itr, rand_spell);
-            m_caster->CastSpell(unitTarget,*itr,true,m_CastItem);
-        }
-    }
-}
-
-void Spell::EffectEnergizePct(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (!unitTarget->isAlive())
-        return;
-
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    uint32 maxPower = unitTarget->GetMaxPower(power);
-    if (maxPower == 0)
-        return;
-
-    uint32 gain = damage * maxPower / 100;
-    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, gain, power);
-}
-
-void Spell::SendLoot(uint64 guid, LootType loottype)
-{
-    Player* player = (Player*)m_caster;
-    if (!player)
-        return;
-
-    if (gameObjTarget)
-    {
-        if (sScriptMgr.OnGossipHello(player, gameObjTarget))
-            return;
-
-        switch (gameObjTarget->GetGoType())
-        {
-            case GAMEOBJECT_TYPE_DOOR:
-            case GAMEOBJECT_TYPE_BUTTON:
-                gameObjTarget->UseDoorOrButton();
-                player->GetMap()->ScriptsStart(sGameObjectScripts, gameObjTarget->GetDBTableGUIDLow(), player, gameObjTarget);
-                return;
-
-            case GAMEOBJECT_TYPE_QUESTGIVER:
-                // start or end quest
-                player->PrepareQuestMenu(guid);
-                player->SendPreparedQuest(guid);
-                return;
-
-            case GAMEOBJECT_TYPE_SPELL_FOCUS:
-                // triggering linked GO
-                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->spellFocus.linkedTrapId)
-                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
-                return;
-
-            case GAMEOBJECT_TYPE_GOOBER:
-                gameObjTarget->Use(m_caster);
-                return;
-
-            case GAMEOBJECT_TYPE_CHEST:
-                // TODO: possible must be moved to loot release (in different from linked triggering)
-                if (gameObjTarget->GetGOInfo()->chest.eventId)
-                {
-                    sLog.outDebug("Chest ScriptStart id %u for GO %u", gameObjTarget->GetGOInfo()->chest.eventId,gameObjTarget->GetDBTableGUIDLow());
-                    player->GetMap()->ScriptsStart(sEventScripts, gameObjTarget->GetGOInfo()->chest.eventId, player, gameObjTarget);
-                }
-
-                // triggering linked GO
-                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->chest.linkedTrapId)
-                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
-
-                // Don't return, let loots been taken
-            default:
-                break;
-        }
-    }
-
-    // Send loot
-    player->SendLoot(guid, loottype);
-}
-
-void Spell::EffectOpenLock(SpellEffIndex effIndex)
-{
-    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
-    {
-        sLog.outDebug("WORLD: Open Lock - No Player Caster!");
-        return;
-    }
-
-    Player* player = (Player*)m_caster;
-
-    uint32 lockId = 0;
-    uint64 guid = 0;
-
-    // Get lockId
-    if (gameObjTarget)
-    {
-        GameObjectInfo const* goInfo = gameObjTarget->GetGOInfo();
-        // Arathi Basin banner opening !
-        if ((goInfo->type == GAMEOBJECT_TYPE_BUTTON && goInfo->button.noDamageImmune) ||
-            (goInfo->type == GAMEOBJECT_TYPE_GOOBER && goInfo->goober.losOK))
-        {
-            //CanUseBattlegroundObject() already called in CheckCast()
-            // in battleground check
-            if (Battleground *bg = player->GetBattleground())
-          {
-        bg->EventPlayerClickedOnFlag(player, gameObjTarget);
-        return;
-          }
-        }
-        else if (goInfo->type == GAMEOBJECT_TYPE_FLAGSTAND)
-        {
-            //CanUseBattlegroundObject() already called in CheckCast()
-            // in battleground check
-            if (Battleground *bg = player->GetBattleground())
-            {
-                if (bg->GetTypeID(true) == BATTLEGROUND_EY)
-                    bg->EventPlayerClickedOnFlag(player, gameObjTarget);
-                return;
-            }
-        }else if (m_spellInfo->Id == 1842 && gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_TRAP && gameObjTarget->GetOwner())
-        {
-            gameObjTarget->SetLootState(GO_JUST_DEACTIVATED);
-            return;
-        }
-        // TODO: Add script for spell 41920 - Filling, becouse server it freze when use this spell
-        // handle outdoor pvp object opening, return true if go was registered for handling
-        // these objects must have been spawned by outdoorpvp!
-        else if (gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
-            return;
-        lockId = goInfo->GetLockId();
-        guid = gameObjTarget->GetGUID();
-    }
-    else if (itemTarget)
-    {
-        lockId = itemTarget->GetProto()->LockID;
-        guid = itemTarget->GetGUID();
-    }
-    else
-    {
-        sLog.outDebug("WORLD: Open Lock - No GameObject/Item Target!");
-        return;
-    }
-
-    SkillType skillId = SKILL_NONE;
-    int32 reqSkillValue = 0;
-    int32 skillValue;
-
-    SpellCastResult res = CanOpenLock(effIndex, lockId, skillId, reqSkillValue, skillValue);
-    if (res != SPELL_CAST_OK)
-    {
-        SendCastResult(res);
-        return;
-    }
-
-    if (gameObjTarget)
-        SendLoot(guid, LOOT_SKINNING);
-    else
-        itemTarget->SetFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_UNLOCKED);
-
-    // not allow use skill grow at item base open
-    if (!m_CastItem && skillId != SKILL_NONE)
-    {
-        // update skill if really known
-        if (uint32 pureSkillValue = player->GetPureSkillValue(skillId))
-        {
-            if (gameObjTarget)
-            {
-                // Allow one skill-up until respawned
-                if (!gameObjTarget->IsInSkillupList(player->GetGUIDLow()) &&
-                    player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue))
-                    gameObjTarget->AddToSkillupList(player->GetGUIDLow());
-            }
-            else if (itemTarget)
-            {
-                // Do one skill-up
-                player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue);
-            }
-        }
-    }
-    ExecuteLogEffectOpenLock(effIndex, gameObjTarget ? (Object*)gameObjTarget : (Object*)itemTarget);
-}
-
-void Spell::EffectSummonChangeItem(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *player = (Player*)m_caster;
-
-    // applied only to using item
-    if (!m_CastItem)
-        return;
-
-    // ... only to item in own inventory/bank/equip_slot
-    if (m_CastItem->GetOwnerGUID() != player->GetGUID())
-        return;
-
-    uint32 newitemid = m_spellInfo->EffectItemType[effIndex];
-    if (!newitemid)
-        return;
-
-    uint16 pos = m_CastItem->GetPos();
-
-    Item *pNewItem = Item::CreateItem(newitemid, 1, player);
-    if (!pNewItem)
-        return;
-
-    for (uint8 j = PERM_ENCHANTMENT_SLOT; j <= TEMP_ENCHANTMENT_SLOT; ++j)
-        if (m_CastItem->GetEnchantmentId(EnchantmentSlot(j)))
-            pNewItem->SetEnchantment(EnchantmentSlot(j), m_CastItem->GetEnchantmentId(EnchantmentSlot(j)), m_CastItem->GetEnchantmentDuration(EnchantmentSlot(j)), m_CastItem->GetEnchantmentCharges(EnchantmentSlot(j)));
-
-    if (m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) < m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY))
-    {
-        double loosePercent = 1 - m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) / double(m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY));
-        player->DurabilityLoss(pNewItem, loosePercent);
-    }
-
-    if (player->IsInventoryPos(pos))
-    {
-        ItemPosCountVec dest;
-        uint8 msg = player->CanStoreItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
-        if (msg == EQUIP_ERR_OK)
-        {
-            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
-
-            // prevent crash at access and unexpected charges counting with item update queue corrupt
-            if (m_CastItem == m_targets.getItemTarget())
-                m_targets.setItemTarget(NULL);
-
-            m_CastItem = NULL;
-
-            player->StoreItem(dest, pNewItem, true);
-            return;
-        }
-    }
-    else if (player->IsBankPos(pos))
-    {
-        ItemPosCountVec dest;
-        uint8 msg = player->CanBankItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
-        if (msg == EQUIP_ERR_OK)
-        {
-            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
-
-            // prevent crash at access and unexpected charges counting with item update queue corrupt
-            if (m_CastItem == m_targets.getItemTarget())
-                m_targets.setItemTarget(NULL);
-
-            m_CastItem = NULL;
-
-            player->BankItem(dest, pNewItem, true);
-            return;
-        }
-    }
-    else if (player->IsEquipmentPos(pos))
-    {
-        uint16 dest;
-
-        player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
-
-        uint8 msg = player->CanEquipItem(m_CastItem->GetSlot(), dest, pNewItem, true);
-
-        if (msg == EQUIP_ERR_OK || msg == EQUIP_ERR_CANT_DO_RIGHT_NOW)
-        {
-            if (msg == EQUIP_ERR_CANT_DO_RIGHT_NOW) dest = EQUIPMENT_SLOT_MAINHAND;
-
-            // prevent crash at access and unexpected charges counting with item update queue corrupt
-            if (m_CastItem == m_targets.getItemTarget())
-                m_targets.setItemTarget(NULL);
-
-            m_CastItem = NULL;
-
-            player->EquipItem(dest, pNewItem, true);
-            player->AutoUnequipOffhandIfNeed();
-            return;
-        }
-    }
-
-    // fail
-    delete pNewItem;
-}
-
-void Spell::EffectProficiency(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player *p_target = (Player*)unitTarget;
-
-    uint32 subClassMask = m_spellInfo->EquippedItemSubClassMask;
-    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON && !(p_target->GetWeaponProficiency() & subClassMask))
-    {
-        p_target->AddWeaponProficiency(subClassMask);
-        p_target->SendProficiency(ITEM_CLASS_WEAPON, p_target->GetWeaponProficiency());
-    }
-    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_ARMOR && !(p_target->GetArmorProficiency() & subClassMask))
-    {
-        p_target->AddArmorProficiency(subClassMask);
-        p_target->SendProficiency(ITEM_CLASS_ARMOR, p_target->GetArmorProficiency());
-    }
-}
-
-void Spell::EffectSummonType(SpellEffIndex effIndex)
-{
-    uint32 entry = m_spellInfo->EffectMiscValue[effIndex];
-    if (!entry)
-        return;
-
-    SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(m_spellInfo->EffectMiscValueB[effIndex]);
-    if (!properties)
-    {
-        sLog.outError("EffectSummonType: Unhandled summon type %u", m_spellInfo->EffectMiscValueB[effIndex]);
-        return;
-    }
-
-    if (!m_originalCaster)
-        return;
-
-    int32 duration = GetSpellDuration(m_spellInfo);
-    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
-        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
-
-    Position pos;
-    GetSummonPosition(effIndex, pos);
-
-    /*//totem must be at same Z in case swimming caster and etc.
-        if (fabs(z - m_caster->GetPositionZ()) > 5)
-            z = m_caster->GetPositionZ();
-
-    uint8 level = m_caster->getLevel();
-
-    // level of creature summoned using engineering item based at engineering skill level
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_CastItem)
-    {
-        ItemPrototype const *proto = m_CastItem->GetProto();
-        if (proto && proto->RequiredSkill == SKILL_ENGINERING)
-        {
-            uint16 skill202 = m_caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING);
-            if (skill202)
-                level = skill202/5;
-        }
-    }*/
-
-    TempSummon *summon = NULL;
-
-    switch (properties->Category)
-    {
-        default:
-            if (properties->Flags & 512)
-            {
-                SummonGuardian(effIndex, entry, properties);
-                break;
-            }
-            switch (properties->Type)
-            {
-                case SUMMON_TYPE_PET:
-                case SUMMON_TYPE_GUARDIAN:
-                case SUMMON_TYPE_GUARDIAN2:
-                case SUMMON_TYPE_MINION:
-                    SummonGuardian(effIndex, entry, properties);
-                    break;
-                case SUMMON_TYPE_VEHICLE:
-                case SUMMON_TYPE_VEHICLE2:
-                    if (m_originalCaster)
-                        summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-                    break;
-                case SUMMON_TYPE_TOTEM:
-                {
-                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-                    if (!summon || !summon->isTotem())
-                        return;
-
-                    // Mana Tide Totem
-                    if (summon->GetEntry() == 10467)
-                        if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                            damage = (m_caster->GetMaxHealth() * 0.10);
-
-                    if (damage)                                            // if not spell info, DB values used
-                    {
-                        summon->SetMaxHealth(damage);
-                        summon->SetHealth(damage);
-                    }
-
-                    //summon->SetUInt32Value(UNIT_CREATED_BY_SPELL,m_spellInfo->Id);
-
-                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER
-                        && properties->Slot >= SUMMON_SLOT_TOTEM
-                        && properties->Slot < MAX_TOTEM_SLOT)
-                    {
-                        // set display id depending on race
-                        uint32 displayId = m_originalCaster->GetModelForTotem(PlayerTotemType(properties->Id));
-                        summon->SetNativeDisplayId(displayId);
-                        summon->SetDisplayId(displayId);
-
-                        //summon->SendUpdateToPlayerm_originalCaster->ToPlayer();
-                        WorldPacket data(SMSG_TOTEM_CREATED, 1+8+4+4);
-                        data << uint8(properties->Slot-1);
-                        data << uint64(m_originalCaster->GetGUID());
-                        data << uint32(duration);
-                        data << uint32(m_spellInfo->Id);
-                        m_originalCaster->ToPlayer()->SendDirectMessage(&data);
-                    }
-                    break;
-                }
-                case SUMMON_TYPE_MINIPET:
-                {
-                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-                    if (!summon || !summon->HasUnitTypeMask(UNIT_MASK_MINION))
-                        return;
-
-                    //summon->InitPetCreateSpells();                         // e.g. disgusting oozeling has a create spell as summon...
-                    summon->SelectLevel(summon->GetCreatureInfo());       // some summoned creaters have different from 1 DB data for level/hp
-                    summon->SetUInt32Value(UNIT_NPC_FLAGS, summon->GetCreatureInfo()->npcflag);
-
-                    summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-
-                    summon->AI()->EnterEvadeMode();
-
-                    std::string name = m_originalCaster->GetName();
-                    name.append(petTypeSuffix[3]);
-                    summon->SetName(name);
-                    break;
-                }
-                default:
-                {
-                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-
-                    uint32 amount = damage > 0 ? damage : 1;
-                    if (m_spellInfo->Id == 18662) // Curse of Doom
-                        amount = 1;
-
-                    // Engineering dragonlings
-                    if (m_spellInfo->Id == 4073 ||
-                        m_spellInfo->Id == 12749 ||
-                        m_spellInfo->Id == 19804)
-                        amount = 1;
-
-                    for (uint32 count = 0; count < amount; ++count)
-                    {
-                        GetSummonPosition(effIndex, pos, radius, count);
-
-                        TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
-
-                        summon = m_originalCaster->SummonCreature(entry, pos, summonType, duration);
-                        if (!summon)
-                            continue;
-                        if (properties->Category == SUMMON_CATEGORY_ALLY)
-                        {
-                            summon->SetUInt64Value(UNIT_FIELD_SUMMONEDBY, m_originalCaster->GetGUID());
-                            summon->setFaction(m_originalCaster->getFaction());
-                            summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-                        }
-                        ExecuteLogEffectSummonObject(effIndex, summon);
-                    }
-                    return;
-                }
-            }//switch
-            break;
-        case SUMMON_CATEGORY_PET:
-            SummonGuardian(effIndex, entry, properties);
-            break;
-        case SUMMON_CATEGORY_PUPPET:
-            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-            break;
-        case SUMMON_CATEGORY_VEHICLE:
-        {
-            float x, y, z;
-            m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
-            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_caster);
-            if (!summon || !summon->IsVehicle())
-                return;
-
-            if (m_spellInfo->EffectBasePoints[effIndex])
-            {
-                SpellEntry const *spellProto = sSpellStore.LookupEntry(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
-                if (spellProto)
-                    m_caster->CastSpell(summon, spellProto, true);
-            }
-
-            m_caster->EnterVehicle(summon->GetVehicleKit());
-            break;
-        }
-    }
-
-    if (summon)
-    {
-        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-        summon->SetCreatorGUID(m_originalCaster->GetGUID());
-        ExecuteLogEffectSummonObject(effIndex, summon);
-    }
-}
-
-void Spell::EffectLearnSpell(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-    {
-        if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            EffectLearnPetSpell(effIndex);
-
-        return;
-    }
-
-    Player *player = (Player*)unitTarget;
-
-    uint32 spellToLearn = (m_spellInfo->Id == 483 || m_spellInfo->Id == 55884) ? damage : m_spellInfo->EffectTriggerSpell[effIndex];
-    player->learnSpell(spellToLearn, false);
-
-    sLog.outDebug("Spell: Player %u has learned spell %u from NpcGUID=%u", player->GetGUIDLow(), spellToLearn, m_caster->GetGUIDLow());
-}
-
-typedef std::list< std::pair<uint32, uint64> > DispelList;
-typedef std::list< std::pair<Aura *, uint8> > DispelChargesList;
-void Spell::EffectDispel(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    DispelChargesList dispel_list;
-
-    // Create dispel mask by dispel type
-    uint32 dispel_type = m_spellInfo->EffectMiscValue[effIndex];
-    uint32 dispelMask  = GetDispellMask(DispelType(dispel_type));
-
-    // we should not be able to dispel diseases if the target is affected by unholy blight
-    if (dispelMask & (1 << DISPEL_DISEASE) && unitTarget->HasAura(50536))
-        dispelMask &= ~(1 << DISPEL_DISEASE);
-
-    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
-    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        Aura * aura = itr->second;
-        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
-        if (!aurApp)
-            continue;
-
-        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
-        {
-            if (aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
-            {
-                bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR_EX_NEGATIVE)) : false;
-
-                // do not remove positive auras if friendly target
-                //               negative auras if non-friendly target
-                if (positive == unitTarget->IsFriendlyTo(m_caster))
-                    continue;
-            }
-
-            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
-            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
-            // Polymorph instead of 1 / (5 + 1) -> 16%.
-            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
-            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
-            if (charges > 0)
-                dispel_list.push_back(std::make_pair(aura, charges));
-        }
-    }
-
-    if (dispel_list.empty())
-        return;
-
-    // Ok if exist some buffs for dispel try dispel it
-    uint32 failCount = 0;
-    DispelList success_list;
-    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
-    // dispel N = damage buffs (or while exist buffs for dispel)
-    for (int32 count = 0; count < damage && !dispel_list.empty();)
-    {
-        // Random select buff for dispel
-        DispelChargesList::iterator itr = dispel_list.begin();
-        std::advance(itr, urand(0, dispel_list.size() - 1));
-
-        bool success = false;
-        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
-        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
-        {
-            dispel_list.erase(itr);
-            continue;
-        }
-        else
-        {
-            if (success)
-            {
-                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
-                --itr->second;
-                if (itr->second <= 0)
-                    dispel_list.erase(itr);
-            }
-            else
-            {
-                if (!failCount)
-                {
-                    // Failed to dispell
-                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
-                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
-                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
-                }
-                ++failCount;
-                dataFail << uint32(itr->first->GetId());                         // Spell Id
-            }
-            ++count;
-        }
-    }
-
-    if (failCount)
-        m_caster->SendMessageToSet(&dataFail, true);
-
-    if (success_list.empty())
-        return;
-
-    WorldPacket dataSuccess(SMSG_SPELLDISPELLOG, 8+8+4+1+4+damage*5);
-    // Send packet header
-    dataSuccess.append(unitTarget->GetPackGUID());         // Victim GUID
-    dataSuccess.append(m_caster->GetPackGUID());           // Caster GUID
-    dataSuccess << uint32(m_spellInfo->Id);                // dispel spell id
-    dataSuccess << uint8(0);                               // not used
-    dataSuccess << uint32(success_list.size());            // count
-    for (DispelList::iterator itr = success_list.begin(); itr != success_list.end(); ++itr)
-    {
-        // Send dispelled spell info
-        dataSuccess << uint32(itr->first);              // Spell Id
-        dataSuccess << uint8(0);                        // 0 - dispelled !=0 cleansed
-        unitTarget->RemoveAurasDueToSpellByDispel(itr->first, itr->second, m_caster);
-    }
-    m_caster->SendMessageToSet(&dataSuccess, true);
-
-    // On success dispel
-    // Devour Magic
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->Category == SPELLCATEGORY_DEVOUR_MAGIC)
-    {
-        int32 heal_amount = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
-        m_caster->CastCustomSpell(m_caster, 19658, &heal_amount, NULL, NULL, true);
-    }
-}
-
-void Spell::EffectDualWield(SpellEffIndex /*effIndex*/)
-{
-    unitTarget->SetCanDualWield(true);
-    if (unitTarget->GetTypeId() == TYPEID_UNIT)
-        unitTarget->ToCreature()->UpdateDamagePhysical(OFF_ATTACK);
-}
-
-void Spell::EffectPull(SpellEffIndex /*effIndex*/)
-{
-    // TODO: create a proper pull towards distract spell center for distract
-    sLog.outDebug("WORLD: Spell Effect DUMMY");
-}
-
-void Spell::EffectDistract(SpellEffIndex /*effIndex*/)
-{
-    // Check for possible target
-    if (!unitTarget || unitTarget->isInCombat())
-        return;
-
-    // target must be OK to do this
-    if (unitTarget->hasUnitState(UNIT_STAT_CONFUSED | UNIT_STAT_STUNNED | UNIT_STAT_FLEEING))
-        return;
-
-    float angle = unitTarget->GetAngle(&m_targets.m_dstPos);
-
-    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
-    {
-        // For players just turn them
-        unitTarget->ToPlayer()->SetPosition(unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), angle, false);
-        unitTarget->ToPlayer()->SendTeleportAckPacket();
-    }
-    else
-    {
-        // Set creature Distracted, Stop it, And turn it
-        unitTarget->SetOrientation(angle);
-        unitTarget->StopMoving();
-        unitTarget->GetMotionMaster()->MoveDistract(damage * IN_MILLISECONDS);
-    }
-}
-
-void Spell::EffectPickPocket(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // victim must be creature and attackable
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT || m_caster->IsFriendlyTo(unitTarget))
-        return;
-
-    // victim have to be alive and humanoid or undead
-    if (unitTarget->isAlive() && (unitTarget->GetCreatureTypeMask() &CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0)
-        m_caster->ToPlayer()->SendLoot(unitTarget->GetGUID(),LOOT_PICKPOCKETING);
-}
-
-void Spell::EffectAddFarsight(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-    int32 duration = GetSpellDuration(m_spellInfo);
-    // Caster not in world, might be spell triggered from aura removal
-    if (!m_caster->IsInWorld())
-        return;
-    DynamicObject* dynObj = new DynamicObject;
-    if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), m_caster, m_spellInfo->Id, m_targets.m_dstPos, radius, true))
-    {
-        delete dynObj;
-        return;
-    }
-    dynObj->SetDuration(duration);
-    dynObj->SetUInt32Value(DYNAMICOBJECT_BYTES, 0x80000002);
-    m_caster->AddDynObject(dynObj);
-
-    dynObj->setActive(true);    //must before add to map to be put in world container
-    dynObj->GetMap()->Add(dynObj); //grid will also be loaded
-
-    // Need to update visibility of object for client to accept farsight guid
-    m_caster->ToPlayer()->SetViewpoint(dynObj, true);
-    //m_caster->ToPlayer()->UpdateVisibilityOf(dynObj);
-}
-
-void Spell::EffectTeleUnitsFaceCaster(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    if (unitTarget->isInFlight())
-        return;
-
-    float dis = (float)m_caster->GetSpellRadiusForTarget(unitTarget, sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-
-    float fx,fy,fz;
-    m_caster->GetClosePoint(fx,fy,fz,unitTarget->GetObjectSize(),dis);
-
-    unitTarget->NearTeleportTo(fx,fy,fz,-m_caster->GetOrientation(),unitTarget == m_caster);
-}
-
-void Spell::EffectLearnSkill(SpellEffIndex effIndex)
-{
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (damage < 0)
-        return;
-
-    uint32 skillid =  m_spellInfo->EffectMiscValue[effIndex];
-    uint16 skillval = unitTarget->ToPlayer()->GetPureSkillValue(skillid);
-    unitTarget->ToPlayer()->SetSkill(skillid, SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex), skillval?skillval:1, damage*75);
-}
-
-void Spell::EffectAddHonor(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // not scale value for item based reward (/10 value expected)
-    if (m_CastItem)
-    {
-        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage/10);
-        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %d honor points (item %u) for player: %u", m_spellInfo->Id, damage/10, m_CastItem->GetEntry(),unitTarget->ToPlayer()->GetGUIDLow());
-        return;
-    }
-
-    // do not allow to add too many honor for player (50 * 21) = 1040 at level 70, or (50 * 31) = 1550 at level 80
-    if (damage <= 50)
-    {
-        uint32 honor_reward = Trinity::Honor::hk_honor_at_level(unitTarget->getLevel(), damage);
-        unitTarget->ToPlayer()->RewardHonor(NULL, 1, honor_reward);
-        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (scale) to player: %u", m_spellInfo->Id, honor_reward, unitTarget->ToPlayer()->GetGUIDLow());
-    }
-    else
-    {
-        //maybe we have correct honor_gain in damage already
-        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage);
-        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (non scale) for player: %u", m_spellInfo->Id, damage, unitTarget->ToPlayer()->GetGUIDLow());
-    }
-}
-
-void Spell::EffectTradeSkill(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    // uint32 skillid =  m_spellInfo->EffectMiscValue[i];
-    // uint16 skillmax = unitTarget->ToPlayer()->(skillid);
-    // unitTarget->ToPlayer()->SetSkill(skillid,skillval?skillval:1,skillmax+75);
-}
-
-void Spell::EffectEnchantItemPerm(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!itemTarget)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-
-    // Handle vellums
-    if (itemTarget->IsWeaponVellum() || itemTarget->IsArmorVellum())
-    {
-        // destroy one vellum from stack
-        uint32 count = 1;
-        p_caster->DestroyItemCount(itemTarget,count,true);
-        unitTarget=p_caster;
-        // and add a scroll
-        DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
-        itemTarget=NULL;
-        m_targets.setItemTarget(NULL);
-    }
-    else
-    {
-        // do not increase skill if vellum used
-        if (!(m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST))
-            p_caster->UpdateCraftSkill(m_spellInfo->Id);
-
-        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-        if (!enchant_id)
-            return;
-
-        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-        if (!pEnchant)
-            return;
-        
-        // item can be in trade slot and have owner diff. from caster
-        Player* item_owner = itemTarget->GetOwner();
-        if (!item_owner)
-            return;
-        
-        // Prevent applying enchanements with Use: spell on items that already have a Use: effect, this is usually blocked from client side and 
-        // can only be bypassed with memory manipulation.
-        for (int s = 0; s < 3; ++s) {
-            if (pEnchant->type[s] == ITEM_ENCHANTMENT_TYPE_USE_SPELL) {
-                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i) {
-                    ItemPrototype const *proto = itemTarget->GetProto();
-                    if (proto->Spells[i].SpellId && proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE) {
-                        sLog.outError("Exploiting attempt: Player %s(GUID: %u) tried to apply an enchanement with Use: spell on an item that already has a Use: effect,"
-                                      " this should be blocked from client side.", p_caster->GetName(), p_caster->GetGUIDLow());
-                        return;
-                    }
-                }
-            }
-        }
-
-        if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
-        {
-            sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
-                p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
-                itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
-                item_owner->GetName(),item_owner->GetSession()->GetAccountId());
-        }
-
-        // remove old enchanting before applying new if equipped
-        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,false);
-
-        itemTarget->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchant_id, 0, 0);
-
-        // add new enchanting if equipped
-        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,true);
-
-        itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
-    }
-}
-
-void Spell::EffectEnchantItemPrismatic(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!itemTarget)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-
-    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-    if (!enchant_id)
-        return;
-
-    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-    if (!pEnchant)
-        return;
-
-    // support only enchantings with add socket in this slot
-    {
-        bool add_socket = false;
-        for (uint8 i = 0; i < MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
-        {
-            if (pEnchant->type[i] == ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET)
-            {
-                add_socket = true;
-                break;
-            }
-        }
-        if (!add_socket)
-        {
-            sLog.outError("Spell::EffectEnchantItemPrismatic: attempt apply enchant spell %u with SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC (%u) but without ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET (%u), not suppoted yet.",
-                m_spellInfo->Id,SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC,ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET);
-            return;
-        }
-    }
-
-    // item can be in trade slot and have owner diff. from caster
-    Player* item_owner = itemTarget->GetOwner();
-    if (!item_owner)
-        return;
-
-    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
-    {
-        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
-            p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
-            itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
-            item_owner->GetName(),item_owner->GetSession()->GetAccountId());
-    }
-
-    // remove old enchanting before applying new if equipped
-    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,false);
-
-    itemTarget->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, enchant_id, 0, 0);
-
-    // add new enchanting if equipped
-    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,true);
-
-    itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
-}
-
-void Spell::EffectEnchantItemTmp(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-
-    // Rockbiter Weapon apply to both weapon
-    if (!itemTarget)
-    return;
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x400000)
-    {
-        uint32 spell_id = 0;
-
-        // enchanting spell selected by calculated damage-per-sec stored in Effect[1] base value
-        // Note: damage calculated (correctly) with rounding int32(float(v)) but
-        // RW enchantments applied damage int32(float(v)+0.5), this create  0..1 difference sometime
-        switch(damage)
-        {
-            // Rank 1
-            case  2: spell_id = 36744; break;               //  0% [ 7% == 2, 14% == 2, 20% == 2]
-            // Rank 2
-            case  4: spell_id = 36753; break;               //  0% [ 7% == 4, 14% == 4]
-            case  5: spell_id = 36751; break;               // 20%
-            // Rank 3
-            case  6: spell_id = 36754; break;               //  0% [ 7% == 6, 14% == 6]
-            case  7: spell_id = 36755; break;               // 20%
-            // Rank 4
-            case  9: spell_id = 36761; break;               //  0% [ 7% == 6]
-            case 10: spell_id = 36758; break;               // 14%
-            case 11: spell_id = 36760; break;               // 20%
-            default:
-                sLog.outError("Spell::EffectEnchantItemTmp: Damage %u not handled in S'RW",damage);
-                return;
-        }
-
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
-        if (!spellInfo)
-        {
-            sLog.outError("Spell::EffectEnchantItemTmp: unknown spell id %i", spell_id);
-            return;
-
-        }
-
-        for (int j = BASE_ATTACK; j <= OFF_ATTACK; ++j)
-        {
-            if (Item* item = p_caster->GetWeaponForAttack(WeaponAttackType(j)))
-            {
-                if (item->IsFitToSpellRequirements(m_spellInfo))
-                {
-                    Spell *spell = new Spell(m_caster, spellInfo, true);
-                    SpellCastTargets targets;
-                    targets.setItemTarget(item);
-                    spell->prepare(&targets);
-                }
-            }
-        }
-        return;
-    }
-    if (!itemTarget)
-        return;
-
-    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    if (!enchant_id)
-    {
-        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have 0 as enchanting id",m_spellInfo->Id,effIndex);
-        return;
-    }
-
-    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-    if (!pEnchant)
-    {
-        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have not existed enchanting id %u ",m_spellInfo->Id,effIndex,enchant_id);
-        return;
-    }
-
-    // select enchantment duration
-    uint32 duration;
-
-    // rogue family enchantments exception by duration
-    if (m_spellInfo->Id == 38615)
-        duration = 1800;                                    // 30 mins
-    // other rogue family enchantments always 1 hour (some have spell damage=0, but some have wrong data in EffBasePoints)
-    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE)
-        duration = 3600;                                    // 1 hour
-    // shaman family enchantments
-    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN)
-        duration = 1800;                                    // 30 mins
-    // other cases with this SpellVisual already selected
-    else if (m_spellInfo->SpellVisual[0] == 215)
-        duration = 1800;                                    // 30 mins
-    // some fishing pole bonuses except Glow Worm which lasts full hour
-    else if (m_spellInfo->SpellVisual[0] == 563 && m_spellInfo->Id != 64401)
-        duration = 600;                                     // 10 mins
-    // shaman rockbiter enchantments
-    else if (m_spellInfo->SpellVisual[0] == 0)
-        duration = 1800;                                    // 30 mins
-    else if (m_spellInfo->Id == 29702)
-        duration = 300;                                     // 5 mins
-    else if (m_spellInfo->Id == 37360)
-        duration = 300;                                     // 5 mins
-    // default case
-    else
-        duration = 3600;                                    // 1 hour
-
-    // item can be in trade slot and have owner diff. from caster
-    Player* item_owner = itemTarget->GetOwner();
-    if (!item_owner)
-        return;
-
-    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
-    {
-        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(temp): %s (Entry: %d) for player: %s (Account: %u)",
-            p_caster->GetName(), p_caster->GetSession()->GetAccountId(),
-            itemTarget->GetProto()->Name1, itemTarget->GetEntry(),
-            item_owner->GetName(), item_owner->GetSession()->GetAccountId());
-    }
-
-    // remove old enchanting before applying new if equipped
-    item_owner->ApplyEnchantment(itemTarget,TEMP_ENCHANTMENT_SLOT, false);
-
-    itemTarget->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, duration * 1000, 0);
-
-    // add new enchanting if equipped
-    item_owner->ApplyEnchantment(itemTarget, TEMP_ENCHANTMENT_SLOT, true);
-}
-
-void Spell::EffectTameCreature(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetPetGUID())
-        return;
-
-    if (!unitTarget)
-        return;
-
-    if (unitTarget->GetTypeId() != TYPEID_UNIT)
-        return;
-
-    Creature* creatureTarget = unitTarget->ToCreature();
-
-    if (creatureTarget->isPet())
-        return;
-
-    if (m_caster->getClass() != CLASS_HUNTER)
-        return;
-
-    // cast finish successfully
-    //SendChannelUpdate(0);
-    finish();
-
-    Pet* pet = m_caster->CreateTamedPetFrom(creatureTarget,m_spellInfo->Id);
-    if (!pet)                                               // in very specific state like near world end/etc.
-        return;
-
-    // "kill" original creature
-    creatureTarget->ForcedDespawn();
-
-    uint8 level = (creatureTarget->getLevel() < (m_caster->getLevel() - 5)) ? (m_caster->getLevel() - 5) : creatureTarget->getLevel();
-
-    // prepare visual effect for levelup
-    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level - 1);
-
-    // add to world
-    pet->GetMap()->Add(pet->ToCreature());
-
-    // visual effect for levelup
-    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level);
-
-    // caster have pet now
-    m_caster->SetMinion(pet, true);
-
-    pet->InitTalentForLevel();
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-        m_caster->ToPlayer()->PetSpellInitialize();
-    }
-}
-
-void Spell::EffectSummonPet(SpellEffIndex effIndex)
-{
-    Player *owner = NULL;
-    if (m_originalCaster)
-    {
-        if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
-            owner = (Player*)m_originalCaster;
-        else if (m_originalCaster->ToCreature()->isTotem())
-            owner = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself();
-    }
-
-    uint32 petentry = m_spellInfo->EffectMiscValue[effIndex];
-
-    if (!owner)
-    {
-        SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(67);
-        if (properties)
-            SummonGuardian(effIndex, petentry, properties);
-        return;
-    }
-
-    Pet *OldSummon = owner->GetPet();
-
-    // if pet requested type already exist
-    if (OldSummon)
-    {
-        if (petentry == 0 || OldSummon->GetEntry() == petentry)
-        {
-            // pet in corpse state can't be summoned
-            if (OldSummon->isDead())
-                return;
-
-            ASSERT(OldSummon->GetMap() == owner->GetMap());
-
-            //OldSummon->GetMap()->Remove(OldSummon->ToCreature(),false);
-
-            float px, py, pz;
-            owner->GetClosePoint(px, py, pz, OldSummon->GetObjectSize());
-
-            OldSummon->NearTeleportTo(px, py, pz, OldSummon->GetOrientation());
-            //OldSummon->Relocate(px, py, pz, OldSummon->GetOrientation());
-            //OldSummon->SetMap(owner->GetMap());
-            //owner->GetMap()->Add(OldSummon->ToCreature());
-
-            if (owner->GetTypeId() == TYPEID_PLAYER && OldSummon->isControlled())
-                owner->ToPlayer()->PetSpellInitialize();
-
-            return;
-        }
-
-        if (owner->GetTypeId() == TYPEID_PLAYER)
-            owner->ToPlayer()->RemovePet(OldSummon,(OldSummon->getPetType() == HUNTER_PET ? PET_SAVE_AS_DELETED : PET_SAVE_NOT_IN_SLOT),false);
-        else
-            return;
-    }
-
-    float x, y, z;
-    owner->GetClosePoint(x, y, z, owner->GetObjectSize());
-    Pet* pet = owner->SummonPet(petentry, x, y, z, owner->GetOrientation(), SUMMON_PET, 0);
-    if (!pet)
-        return;
-
-    if (m_caster->GetTypeId() == TYPEID_UNIT)
-    {
-        if (m_caster->ToCreature()->isTotem())
-            pet->SetReactState(REACT_AGGRESSIVE);
-        else
-            pet->SetReactState(REACT_DEFENSIVE);
-    }
-
-    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-
-    // generate new name for summon pet
-    std::string new_name=sObjectMgr.GeneratePetName(petentry);
-    if (!new_name.empty())
-        pet->SetName(new_name);
-
-    ExecuteLogEffectSummonObject(effIndex, pet);
-}
-
-void Spell::EffectLearnPetSpell(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)m_caster;
-
-    Pet *pet = _player->GetPet();
-    if (!pet)
-        return;
-    if (!pet->isAlive())
-        return;
-
-    SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[effIndex]);
-    if (!learn_spellproto)
-        return;
-
-    pet->learnSpell(learn_spellproto->Id);
-
-    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-    _player->PetSpellInitialize();
-}
-
-void Spell::EffectTaunt(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    // this effect use before aura Taunt apply for prevent taunt already attacking target
-    // for spell as marked "non effective at already attacking target"
-    if (!unitTarget || !unitTarget->CanHaveThreatList()
-        || unitTarget->getVictim() == m_caster)
-    {
-        SendCastResult(SPELL_FAILED_DONT_REPORT);
-        return;
-    }
-
-    if (m_spellInfo->Id == 62124)
-    {
-        int32 damageDone = int32(1 + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.5f);
-        bool is_crit = m_caster->isSpellCrit(unitTarget, m_spellInfo, m_spellSchoolMask, m_attackType);
-        if (is_crit)
-            damageDone *= 2;
-        m_caster->DealDamage(unitTarget, damageDone, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_HOLY, m_spellInfo, false);
-        m_caster->SendSpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, damageDone, SPELL_SCHOOL_MASK_HOLY, 0, 0, false, false, is_crit);
-    }
-
-    // Also use this effect to set the taunter's threat to the taunted creature's highest value
-    if (unitTarget->getThreatManager().getCurrentVictim())
-    {
-        float myThreat = unitTarget->getThreatManager().getThreat(m_caster);
-        float itsThreat = unitTarget->getThreatManager().getCurrentVictim()->getThreat();
-        if (itsThreat > myThreat)
-            unitTarget->getThreatManager().addThreat(m_caster, itsThreat - myThreat);
-    }
-
-    //Set aggro victim to caster
-    if (!unitTarget->getThreatManager().getOnlineContainer().empty())
-        if (HostileReference* forcedVictim = unitTarget->getThreatManager().getOnlineContainer().getReferenceByTarget(m_caster))
-            unitTarget->getThreatManager().setCurrentVictim(forcedVictim);
-
-    if (unitTarget->ToCreature()->IsAIEnabled && !unitTarget->ToCreature()->HasReactState(REACT_PASSIVE))
-        unitTarget->ToCreature()->AI()->AttackStart(m_caster);
-}
-
-void Spell::EffectWeaponDmg(SpellEffIndex /*effIndex*/)
-{
-}
-
-void Spell::SpellDamageWeaponDmg(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (!unitTarget->isAlive())
-        return;
-
-    // multiple weapon dmg effect workaround
-    // execute only the last weapon damage
-    // and handle all effects at once
-    for (uint32 j = effIndex + 1; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        switch (m_spellInfo->Effect[j])
-        {
-            case SPELL_EFFECT_WEAPON_DAMAGE:
-            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                return;     // we must calculate only at last weapon effect
-            break;
-        }
-    }
-
-    // some spell specific modifiers
-    float totalDamagePercentMod  = 1.0f;                    // applied to final bonus+weapon damage
-    int32 fixed_bonus = 0;
-    int32 spell_bonus = 0;                                  // bonus specific for spell
-
-    switch (m_spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            switch (m_spellInfo->Id)
-            {
-                case 69055:     // Saber Lash
-                case 70814:     // Saber Lash
-                {
-                    uint32 count = 0;
-                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1 << effIndex))
-                            ++count;
-
-                    totalDamagePercentMod /= count;
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            // Devastate (player ones)
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x40)
-            {
-                // Player can apply only 58567 Sunder Armor effect.
-                bool needCast = !unitTarget->HasAura(58567, m_caster->GetGUID());
-                if (needCast)
-                    m_caster->CastSpell(unitTarget, 58567, true);
-
-                if (Aura * aur = unitTarget->GetAura(58567, m_caster->GetGUID()))
-                {
-                    // 58388 - Glyph of Devastate dummy aura.
-                    if (int32 num = (needCast ? 0 : 1) + (m_caster->HasAura(58388) ? 1 : 0))
-                        aur->ModStackAmount(num);
-                    fixed_bonus += (aur->GetStackAmount() - 1) * CalculateDamage(2, unitTarget);
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_ROGUE:
-        {
-            // Fan of Knives, Hemorrhage, Ghostly Strike
-            if ((m_spellInfo->SpellFamilyFlags[1] & 0x40000)
-                || (m_spellInfo->SpellFamilyFlags[0] & 0x6000000))
-            {
-                // Hemorrhage
-                if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
-                {
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                        m_caster->ToPlayer()->AddComboPoints(unitTarget, 1, this);
-                }
-                // 50% more damage with daggers
-                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    if (Item* item = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType, true))
-                        if (item->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
-                            totalDamagePercentMod *= 1.5f;
-            }
-            // Mutilate (for each hand)
-            else if (m_spellInfo->SpellFamilyFlags[1] & 0x6)
-            {
-                bool found = false;
-                // fast check
-                if (unitTarget->HasAuraState(AURA_STATE_DEADLY_POISON, m_spellInfo, m_caster))
-                    found = true;
-                // full aura scan
-                else
-                {
-                    Unit::AuraApplicationMap const& auras = unitTarget->GetAppliedAuras();
-                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-                    {
-                        if (itr->second->GetBase()->GetSpellProto()->Dispel == DISPEL_POISON)
-                        {
-                            found = true;
-                            break;
-                        }
-                    }
-                }
-
-                if (found)
-                    totalDamagePercentMod *= 1.2f;          // 120% if poisoned
-            }
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Seal of Command - Increase damage by 36% on every swing
-            if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
-            {
-                totalDamagePercentMod *= 1.36f;            //136% damage
-            }
-
-            // Seal of Command Unleashed
-            else if (m_spellInfo->Id == 20467)
-            {
-                spell_bonus += int32(0.08f*m_caster->GetTotalAttackPowerValue(BASE_ATTACK));
-                spell_bonus += int32(0.13f*m_caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellInfo), m_spellInfo));
-            }
-            break;
-        }
-        case SPELLFAMILY_SHAMAN:
-        {
-            // Skyshatter Harness item set bonus
-            // Stormstrike
-            if (AuraEffect * aurEff = m_caster->IsScriptOverriden(m_spellInfo, 5634))
-                m_caster->CastSpell(m_caster, 38430, true, NULL, aurEff);
-            break;
-        }
-        case SPELLFAMILY_DRUID:
-        {
-            // Mangle (Cat): CP
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
-            {
-                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    m_caster->ToPlayer()->AddComboPoints(unitTarget,1, this);
-            }
-            // Shred, Maul - Rend and Tear
-            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00008800 && unitTarget->HasAuraState(AURA_STATE_BLEEDING))
-            {
-                if (AuraEffect const* rendAndTear = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 0))
-                {
-                    totalDamagePercentMod *= float((rendAndTear->GetAmount() + 100.0f) / 100.0f);
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_HUNTER:
-        {
-            // Kill Shot - bonus damage from Ranged Attack Power
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x800000)
-                spell_bonus += int32(0.4f*m_caster->GetTotalAttackPowerValue(RANGED_ATTACK));
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Plague Strike
-            if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
-            {
-                // Glyph of Plague Strike
-                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58657,0))
-                    totalDamagePercentMod *= float((aurEff->GetAmount() + 100.0f) / 100.0f);
-            }
-            // Blood Strike
-            else if (m_spellInfo->SpellFamilyFlags[0] & 0x400000)
-            {
-                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
-
-                // Glyph of Blood Strike
-                if (m_caster->GetAuraEffect(59332,0))
-                {
-                    if (unitTarget->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED))
-                       totalDamagePercentMod *= float((20 + 100.0f) / 100.0f);
-                }
-            }
-            // Death Strike
-            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000010)
-            {
-                // Glyph of Death Strike
-                if (m_caster->GetAuraEffect(59336,0))
-                {
-                    if (uint32 runic = m_caster->GetPower(POWER_RUNIC_POWER))
-                    {
-                        if (runic > 25)
-                            runic = 25;
-
-                        totalDamagePercentMod *= float((runic + 100.0f) / 100.0f);
-                    }
-                }
-            }
-            // Obliterate (12.5% more damage per disease)
-            else if (m_spellInfo->SpellFamilyFlags[1] & 0x20000)
-            {
-                bool consumeDiseases = true;
-                // Annihilation
-                if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2710, 0))
-                {
-                    // Do not consume diseases if roll sucesses
-                    if (roll_chance_i(aurEff->GetAmount()))
-                        consumeDiseases = false;
-                }
-                totalDamagePercentMod *= (float(CalculateDamage(2, unitTarget) * unitTarget->GetDiseasesByCaster(m_caster->GetGUID(), consumeDiseases) / 2) + 100.0f) / 100.0f;
-            }
-            // Blood-Caked Strike - Blood-Caked Blade
-            else if (m_spellInfo->SpellIconID == 1736)
-                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
-            // Rune Strike
-            else if (m_spellInfo->SpellFamilyFlags[1] & 0x20000000)
-                m_damage += int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.15f);
-            break;
-        }
-    }
-
-    bool normalized = false;
-    float weaponDamagePercentMod = 1.0;
-    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        switch(m_spellInfo->Effect[j])
-        {
-            case SPELL_EFFECT_WEAPON_DAMAGE:
-            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-                fixed_bonus += CalculateDamage(j, unitTarget);
-                break;
-            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                fixed_bonus += CalculateDamage(j, unitTarget);
-                normalized = true;
-                break;
-            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                weaponDamagePercentMod *= float(CalculateDamage(j,unitTarget)) / 100.0f;
-                break;
-            default:
-                break;                                      // not weapon damage effect, just skip
-        }
-    }
-
-    // apply to non-weapon bonus weapon total pct effect, weapon total flat effect included in weapon damage
-    if (fixed_bonus || spell_bonus)
-    {
-        UnitMods unitMod;
-        switch(m_attackType)
-        {
-            default:
-            case BASE_ATTACK:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
-            case OFF_ATTACK:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
-            case RANGED_ATTACK: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
-        }
-
-        float weapon_total_pct = 1.0f;
-        if (m_spellInfo->SchoolMask & SPELL_SCHOOL_MASK_NORMAL)
-             weapon_total_pct = m_caster->GetModifierValue(unitMod, TOTAL_PCT);
-
-        if (fixed_bonus)
-            fixed_bonus = int32(fixed_bonus * weapon_total_pct);
-        if (spell_bonus)
-            spell_bonus = int32(spell_bonus * weapon_total_pct);
-    }
-
-    int32 weaponDamage = m_caster->CalculateDamage(m_attackType, normalized, true);
-
-    // Sequence is important
-    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        // We assume that a spell have at most one fixed_bonus
-        // and at most one weaponDamagePercentMod
-        switch(m_spellInfo->Effect[j])
-        {
-            case SPELL_EFFECT_WEAPON_DAMAGE:
-            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                weaponDamage += fixed_bonus;
-                break;
-            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                weaponDamage = int32(weaponDamage * weaponDamagePercentMod);
-            default:
-                break;                                      // not weapon damage effect, just skip
-        }
-    }
-
-    if (spell_bonus)
-        weaponDamage += spell_bonus;
-
-    if (totalDamagePercentMod != 1.0f)
-        weaponDamage = int32(weaponDamage * totalDamagePercentMod);
-
-    // prevent negative damage
-    uint32 eff_damage = uint32(weaponDamage > 0 ? weaponDamage : 0);
-
-    // Add melee damage bonuses (also check for negative)
-    m_caster->MeleeDamageBonus(unitTarget, &eff_damage, m_attackType, m_spellInfo);
-    m_damage+= eff_damage;
-}
-
-void Spell::EffectThreat(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive() || !m_caster->isAlive())
-        return;
-
-    if (!unitTarget->CanHaveThreatList())
-        return;
-
-    unitTarget->AddThreat(m_caster, float(damage));
-}
-
-void Spell::EffectHealMaxHealth(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive())
-        return;
-
-    int32 addhealth;
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN) // Lay on Hands
-    {
-        if (m_caster->GetGUID() == unitTarget->GetGUID())
-        {
-            m_caster->CastSpell(m_caster, 25771, true); // Forbearance
-            m_caster->CastSpell(m_caster, 61988, true); // Immune shield marker (serverside)
-            m_caster->CastSpell(m_caster, 61987, true); // Avenging Wrath marker
-        }
-    }
-
-    // damage == 0 - heal for caster max health
-    if (damage == 0)
-        addhealth = m_caster->GetMaxHealth();
-    else
-        addhealth = unitTarget->GetMaxHealth() - unitTarget->GetHealth();
-
-    if (m_originalCaster)
-         m_healing += m_originalCaster->SpellHealingBonus(unitTarget,m_spellInfo, addhealth, HEAL);
-}
-
-void Spell::EffectInterruptCast(SpellEffIndex effIndex)
-{
-    if (!unitTarget || !unitTarget->isAlive())
-        return;
-
-    // TODO: not all spells that used this effect apply cooldown at school spells
-    // also exist case: apply cooldown to interrupted cast only and to all spells
-    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; ++i)
-    {
-        if (Spell* spell = unitTarget->GetCurrentSpell(CurrentSpellTypes(i)))
-        {
-            SpellEntry const* curSpellInfo = spell->m_spellInfo;
-            // check if we can interrupt spell
-            if ((spell->getState() == SPELL_STATE_CASTING
-                || (spell->getState() == SPELL_STATE_PREPARING && spell->GetCastTime() > 0.0f))
-                && curSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT && curSpellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
-            {
-                if (m_originalCaster)
-                {
-                    int32 duration = GetSpellDuration(m_spellInfo);
-                    unitTarget->ProhibitSpellScholl(GetSpellSchoolMask(curSpellInfo), unitTarget->ModSpellDuration(m_spellInfo, unitTarget, duration, false));
-                }
-                ExecuteLogEffectInterruptCast(effIndex, unitTarget, curSpellInfo->Id);
-                unitTarget->InterruptSpell(CurrentSpellTypes(i), false);
-            }
-        }
-    }
-}
-
-void Spell::EffectSummonObjectWild(SpellEffIndex effIndex)
-{
-    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    GameObject* pGameObj = new GameObject;
-
-    WorldObject* target = focusObject;
-    if (!target)
-        target = m_caster;
-
-    float x, y, z;
-    if (m_targets.HasDst())
-        m_targets.m_dstPos.GetPosition(x, y, z);
-    else
-        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
-
-    Map *map = target->GetMap();
-
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id, map,
-        m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    int32 duration = GetSpellDuration(m_spellInfo);
-
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-    pGameObj->SetSpellId(m_spellInfo->Id);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    // Wild object not have owner and check clickable by players
-    map->Add(pGameObj);
-
-    if (pGameObj->GetGoType() == GAMEOBJECT_TYPE_FLAGDROP && m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        Player *pl = m_caster->ToPlayer();
-        Battleground* bg = pl->GetBattleground();
-
-        switch(pGameObj->GetMapId())
-        {
-            case 489:                                       //WS
-            {
-                if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS && bg->GetStatus() == STATUS_IN_PROGRESS)
-                {
-                    uint32 team = ALLIANCE;
-
-                    if (pl->GetTeam() == team)
-                        team = HORDE;
-
-                    ((BattlegroundWS*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID(),team);
-                }
-                break;
-            }
-            case 566:                                       //EY
-            {
-                if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY && bg->GetStatus() == STATUS_IN_PROGRESS)
-                {
-                    ((BattlegroundEY*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID());
-                }
-                break;
-            }
-        }
-    }
-
-    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
-    {
-        GameObject* linkedGO = new GameObject;
-        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, map,
-            m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-        {
-            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-            linkedGO->SetSpellId(m_spellInfo->Id);
-
-            ExecuteLogEffectSummonObject(effIndex, linkedGO);
-
-            // Wild object not have owner and check clickable by players
-            map->Add(linkedGO);
-        }
-        else
-        {
-            delete linkedGO;
-            linkedGO = NULL;
-            return;
-        }
-    }
-}
-
-void Spell::EffectScriptEffect(SpellEffIndex effIndex)
-{
-    // TODO: we must implement hunter pet summon at login there (spell 6962)
-
-    switch(m_spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            switch(m_spellInfo->Id)
-            {        
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "DatabaseEnv.h"
+#include "WorldPacket.h"
+#include "Opcodes.h"
+#include "Log.h"
+#include "UpdateMask.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "SkillExtraItems.h"
+#include "Unit.h"
+#include "Spell.h"
+#include "DynamicObject.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "Group.h"
+#include "UpdateData.h"
+#include "MapManager.h"
+#include "ObjectAccessor.h"
+#include "SharedDefines.h"
+#include "Pet.h"
+#include "GameObject.h"
+#include "GossipDef.h"
+#include "Creature.h"
+#include "Totem.h"
+#include "CreatureAI.h"
+#include "BattlegroundMgr.h"
+#include "Battleground.h"
+#include "BattlegroundEY.h"
+#include "BattlegroundWS.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
+#include "Language.h"
+#include "SocialMgr.h"
+#include "Util.h"
+#include "VMapFactory.h"
+#include "TemporarySummon.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "SkillDiscovery.h"
+#include "Formulas.h"
+#include "Vehicle.h"
+#include "ScriptMgr.h"
+#include "GameObjectAI.h"
+
+pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
+{
+    &Spell::EffectNULL,                                     //  0
+    &Spell::EffectInstaKill,                                //  1 SPELL_EFFECT_INSTAKILL
+    &Spell::EffectSchoolDMG,                                //  2 SPELL_EFFECT_SCHOOL_DAMAGE
+    &Spell::EffectDummy,                                    //  3 SPELL_EFFECT_DUMMY
+    &Spell::EffectUnused,                                   //  4 SPELL_EFFECT_PORTAL_TELEPORT          unused
+    &Spell::EffectTeleportUnits,                            //  5 SPELL_EFFECT_TELEPORT_UNITS
+    &Spell::EffectApplyAura,                                //  6 SPELL_EFFECT_APPLY_AURA
+    &Spell::EffectEnvirinmentalDMG,                         //  7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
+    &Spell::EffectPowerDrain,                               //  8 SPELL_EFFECT_POWER_DRAIN
+    &Spell::EffectHealthLeech,                              //  9 SPELL_EFFECT_HEALTH_LEECH
+    &Spell::EffectHeal,                                     // 10 SPELL_EFFECT_HEAL
+    &Spell::EffectBind,                                     // 11 SPELL_EFFECT_BIND
+    &Spell::EffectNULL,                                     // 12 SPELL_EFFECT_PORTAL
+    &Spell::EffectUnused,                                   // 13 SPELL_EFFECT_RITUAL_BASE              unused
+    &Spell::EffectUnused,                                   // 14 SPELL_EFFECT_RITUAL_SPECIALIZE        unused
+    &Spell::EffectUnused,                                   // 15 SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL   unused
+    &Spell::EffectQuestComplete,                            // 16 SPELL_EFFECT_QUEST_COMPLETE
+    &Spell::EffectWeaponDmg,                                // 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
+    &Spell::EffectResurrect,                                // 18 SPELL_EFFECT_RESURRECT
+    &Spell::EffectAddExtraAttacks,                          // 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
+    &Spell::EffectUnused,                                   // 20 SPELL_EFFECT_DODGE                    one spell: Dodge
+    &Spell::EffectUnused,                                   // 21 SPELL_EFFECT_EVADE                    one spell: Evade (DND)
+    &Spell::EffectParry,                                    // 22 SPELL_EFFECT_PARRY
+    &Spell::EffectBlock,                                    // 23 SPELL_EFFECT_BLOCK                    one spell: Block
+    &Spell::EffectCreateItem,                               // 24 SPELL_EFFECT_CREATE_ITEM
+    &Spell::EffectUnused,                                   // 25 SPELL_EFFECT_WEAPON
+    &Spell::EffectUnused,                                   // 26 SPELL_EFFECT_DEFENSE                  one spell: Defense
+    &Spell::EffectPersistentAA,                             // 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
+    &Spell::EffectSummonType,                               // 28 SPELL_EFFECT_SUMMON
+    &Spell::EffectLeap,                                     // 29 SPELL_EFFECT_LEAP
+    &Spell::EffectEnergize,                                 // 30 SPELL_EFFECT_ENERGIZE
+    &Spell::EffectWeaponDmg,                                // 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
+    &Spell::EffectTriggerMissileSpell,                      // 32 SPELL_EFFECT_TRIGGER_MISSILE
+    &Spell::EffectOpenLock,                                 // 33 SPELL_EFFECT_OPEN_LOCK
+    &Spell::EffectSummonChangeItem,                         // 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
+    &Spell::EffectApplyAreaAura,                            // 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
+    &Spell::EffectLearnSpell,                               // 36 SPELL_EFFECT_LEARN_SPELL
+    &Spell::EffectUnused,                                   // 37 SPELL_EFFECT_SPELL_DEFENSE            one spell: SPELLDEFENSE (DND)
+    &Spell::EffectDispel,                                   // 38 SPELL_EFFECT_DISPEL
+    &Spell::EffectUnused,                                   // 39 SPELL_EFFECT_LANGUAGE
+    &Spell::EffectDualWield,                                // 40 SPELL_EFFECT_DUAL_WIELD
+    &Spell::EffectJump,                                     // 41 SPELL_EFFECT_JUMP
+    &Spell::EffectJumpDest,                                 // 42 SPELL_EFFECT_JUMP_DEST
+    &Spell::EffectTeleUnitsFaceCaster,                      // 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
+    &Spell::EffectLearnSkill,                               // 44 SPELL_EFFECT_SKILL_STEP
+    &Spell::EffectAddHonor,                                 // 45 SPELL_EFFECT_ADD_HONOR                honor/pvp related
+    &Spell::EffectUnused,                                   // 46 SPELL_EFFECT_SPAWN clientside, unit appears as if it was just spawned
+    &Spell::EffectTradeSkill,                               // 47 SPELL_EFFECT_TRADE_SKILL
+    &Spell::EffectUnused,                                   // 48 SPELL_EFFECT_STEALTH                  one spell: Base Stealth
+    &Spell::EffectUnused,                                   // 49 SPELL_EFFECT_DETECT                   one spell: Detect
+    &Spell::EffectTransmitted,                              // 50 SPELL_EFFECT_TRANS_DOOR
+    &Spell::EffectUnused,                                   // 51 SPELL_EFFECT_FORCE_CRITICAL_HIT       unused
+    &Spell::EffectUnused,                                   // 52 SPELL_EFFECT_GUARANTEE_HIT            one spell: zzOLDCritical Shot
+    &Spell::EffectEnchantItemPerm,                          // 53 SPELL_EFFECT_ENCHANT_ITEM
+    &Spell::EffectEnchantItemTmp,                           // 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
+    &Spell::EffectTameCreature,                             // 55 SPELL_EFFECT_TAMECREATURE
+    &Spell::EffectSummonPet,                                // 56 SPELL_EFFECT_SUMMON_PET
+    &Spell::EffectLearnPetSpell,                            // 57 SPELL_EFFECT_LEARN_PET_SPELL
+    &Spell::EffectWeaponDmg,                                // 58 SPELL_EFFECT_WEAPON_DAMAGE
+    &Spell::EffectCreateRandomItem,                         // 59 SPELL_EFFECT_CREATE_RANDOM_ITEM       create item base at spell specific loot
+    &Spell::EffectProficiency,                              // 60 SPELL_EFFECT_PROFICIENCY
+    &Spell::EffectSendEvent,                                // 61 SPELL_EFFECT_SEND_EVENT
+    &Spell::EffectPowerBurn,                                // 62 SPELL_EFFECT_POWER_BURN
+    &Spell::EffectThreat,                                   // 63 SPELL_EFFECT_THREAT
+    &Spell::EffectTriggerSpell,                             // 64 SPELL_EFFECT_TRIGGER_SPELL
+    &Spell::EffectApplyAreaAura,                            // 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
+    &Spell::EffectRechargeManaGem,                          // 66 SPELL_EFFECT_CREATE_MANA_GEM          (possibly recharge it, misc - is item ID)
+    &Spell::EffectHealMaxHealth,                            // 67 SPELL_EFFECT_HEAL_MAX_HEALTH
+    &Spell::EffectInterruptCast,                            // 68 SPELL_EFFECT_INTERRUPT_CAST
+    &Spell::EffectDistract,                                 // 69 SPELL_EFFECT_DISTRACT
+    &Spell::EffectPull,                                     // 70 SPELL_EFFECT_PULL                     one spell: Distract Move
+    &Spell::EffectPickPocket,                               // 71 SPELL_EFFECT_PICKPOCKET
+    &Spell::EffectAddFarsight,                              // 72 SPELL_EFFECT_ADD_FARSIGHT
+    &Spell::EffectUnused,                                   // 73 SPELL_EFFECT_UNTRAIN_TALENTS
+    &Spell::EffectApplyGlyph,                               // 74 SPELL_EFFECT_APPLY_GLYPH
+    &Spell::EffectHealMechanical,                           // 75 SPELL_EFFECT_HEAL_MECHANICAL          one spell: Mechanical Patch Kit
+    &Spell::EffectSummonObjectWild,                         // 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
+    &Spell::EffectScriptEffect,                             // 77 SPELL_EFFECT_SCRIPT_EFFECT
+    &Spell::EffectUnused,                                   // 78 SPELL_EFFECT_ATTACK
+    &Spell::EffectSanctuary,                                // 79 SPELL_EFFECT_SANCTUARY
+    &Spell::EffectAddComboPoints,                           // 80 SPELL_EFFECT_ADD_COMBO_POINTS
+    &Spell::EffectUnused,                                   // 81 SPELL_EFFECT_CREATE_HOUSE             one spell: Create House (TEST)
+    &Spell::EffectNULL,                                     // 82 SPELL_EFFECT_BIND_SIGHT
+    &Spell::EffectDuel,                                     // 83 SPELL_EFFECT_DUEL
+    &Spell::EffectStuck,                                    // 84 SPELL_EFFECT_STUCK
+    &Spell::EffectSummonPlayer,                             // 85 SPELL_EFFECT_SUMMON_PLAYER
+    &Spell::EffectActivateObject,                           // 86 SPELL_EFFECT_ACTIVATE_OBJECT
+    &Spell::EffectWMODamage,                                // 87 SPELL_EFFECT_WMO_DAMAGE
+    &Spell::EffectWMORepair,                                // 88 SPELL_EFFECT_WMO_REPAIR
+    &Spell::EffectUnused,                                   // 89 SPELL_EFFECT_WMO_CHANGE // 0 intact // 1 damaged // 2 destroyed // 3 rebuilding
+    &Spell::EffectKillCreditPersonal,                       // 90 SPELL_EFFECT_KILL_CREDIT              Kill credit but only for single person
+    &Spell::EffectUnused,                                   // 91 SPELL_EFFECT_THREAT_ALL               one spell: zzOLDBrainwash
+    &Spell::EffectEnchantHeldItem,                          // 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
+    &Spell::EffectForceDeselect,                            // 93 SPELL_EFFECT_FORCE_DESELECT
+    &Spell::EffectSelfResurrect,                            // 94 SPELL_EFFECT_SELF_RESURRECT
+    &Spell::EffectSkinning,                                 // 95 SPELL_EFFECT_SKINNING
+    &Spell::EffectCharge,                                   // 96 SPELL_EFFECT_CHARGE
+    &Spell::EffectCastButtons,                              // 97 SPELL_EFFECT_CAST_BUTTON (totem bar since 3.2.2a)
+    &Spell::EffectKnockBack,                                // 98 SPELL_EFFECT_KNOCK_BACK
+    &Spell::EffectDisEnchant,                               // 99 SPELL_EFFECT_DISENCHANT
+    &Spell::EffectInebriate,                                //100 SPELL_EFFECT_INEBRIATE
+    &Spell::EffectFeedPet,                                  //101 SPELL_EFFECT_FEED_PET
+    &Spell::EffectDismissPet,                               //102 SPELL_EFFECT_DISMISS_PET
+    &Spell::EffectReputation,                               //103 SPELL_EFFECT_REPUTATION
+    &Spell::EffectSummonObject,                             //104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
+    &Spell::EffectSummonObject,                             //105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
+    &Spell::EffectSummonObject,                             //106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
+    &Spell::EffectSummonObject,                             //107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
+    &Spell::EffectDispelMechanic,                           //108 SPELL_EFFECT_DISPEL_MECHANIC
+    &Spell::EffectSummonDeadPet,                            //109 SPELL_EFFECT_SUMMON_DEAD_PET
+    &Spell::EffectDestroyAllTotems,                         //110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
+    &Spell::EffectDurabilityDamage,                         //111 SPELL_EFFECT_DURABILITY_DAMAGE
+    &Spell::EffectUnused,                                   //112 SPELL_EFFECT_112
+    &Spell::EffectResurrectNew,                             //113 SPELL_EFFECT_RESURRECT_NEW
+    &Spell::EffectTaunt,                                    //114 SPELL_EFFECT_ATTACK_ME
+    &Spell::EffectDurabilityDamagePCT,                      //115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
+    &Spell::EffectSkinPlayerCorpse,                         //116 SPELL_EFFECT_SKIN_PLAYER_CORPSE       one spell: Remove Insignia, bg usage, required special corpse flags...
+    &Spell::EffectSpiritHeal,                               //117 SPELL_EFFECT_SPIRIT_HEAL              one spell: Spirit Heal
+    &Spell::EffectSkill,                                    //118 SPELL_EFFECT_SKILL                    professions and more
+    &Spell::EffectApplyAreaAura,                            //119 SPELL_EFFECT_APPLY_AREA_AURA_PET
+    &Spell::EffectUnused,                                   //120 SPELL_EFFECT_TELEPORT_GRAVEYARD       one spell: Graveyard Teleport Test
+    &Spell::EffectWeaponDmg,                                //121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
+    &Spell::EffectUnused,                                   //122 SPELL_EFFECT_122                      unused
+    &Spell::EffectSendTaxi,                                 //123 SPELL_EFFECT_SEND_TAXI                taxi/flight related (misc value is taxi path id)
+    &Spell::EffectPullTowards,                              //124 SPELL_EFFECT_PULL_TOWARDS
+    &Spell::EffectModifyThreatPercent,                      //125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
+    &Spell::EffectStealBeneficialBuff,                      //126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF    spell steal effect?
+    &Spell::EffectProspecting,                              //127 SPELL_EFFECT_PROSPECTING              Prospecting spell
+    &Spell::EffectApplyAreaAura,                            //128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
+    &Spell::EffectApplyAreaAura,                            //129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
+    &Spell::EffectRedirectThreat,                           //130 SPELL_EFFECT_REDIRECT_THREAT
+    &Spell::EffectPlayerNotification,                       //131 SPELL_EFFECT_PLAYER_NOTIFICATION
+    &Spell::EffectPlayMusic,                                //132 SPELL_EFFECT_PLAY_MUSIC               sound id in misc value (SoundEntries.dbc)
+    &Spell::EffectUnlearnSpecialization,                    //133 SPELL_EFFECT_UNLEARN_SPECIALIZATION   unlearn profession specialization
+    &Spell::EffectKillCredit,                               //134 SPELL_EFFECT_KILL_CREDIT              misc value is creature entry
+    &Spell::EffectNULL,                                     //135 SPELL_EFFECT_CALL_PET
+    &Spell::EffectHealPct,                                  //136 SPELL_EFFECT_HEAL_PCT
+    &Spell::EffectEnergizePct,                              //137 SPELL_EFFECT_ENERGIZE_PCT
+    &Spell::EffectLeapBack,                                 //138 SPELL_EFFECT_LEAP_BACK                Leap back
+    &Spell::EffectQuestClear,                               //139 SPELL_EFFECT_CLEAR_QUEST              Reset quest status (miscValue - quest ID)
+    &Spell::EffectForceCast,                                //140 SPELL_EFFECT_FORCE_CAST
+    &Spell::EffectForceCastWithValue,                       //141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
+    &Spell::EffectTriggerSpellWithValue,                    //142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
+    &Spell::EffectApplyAreaAura,                            //143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
+    &Spell::EffectKnockBack,                                //144 SPELL_EFFECT_KNOCK_BACK_DEST
+    &Spell::EffectPullTowards,                              //145 SPELL_EFFECT_PULL_TOWARDS_DEST                      Black Hole Effect
+    &Spell::EffectActivateRune,                             //146 SPELL_EFFECT_ACTIVATE_RUNE
+    &Spell::EffectQuestFail,                                //147 SPELL_EFFECT_QUEST_FAIL               quest fail
+    &Spell::EffectUnused,                                   //148 SPELL_EFFECT_148   1 spell - 43509
+    &Spell::EffectChargeDest,                               //149 SPELL_EFFECT_CHARGE_DEST
+    &Spell::EffectQuestStart,                               //150 SPELL_EFFECT_QUEST_START
+    &Spell::EffectTriggerRitualOfSummoning,                 //151 SPELL_EFFECT_TRIGGER_SPELL_2
+    &Spell::EffectNULL,                                     //152 SPELL_EFFECT_152                      summon Refer-a-Friend
+    &Spell::EffectCreateTamedPet,                           //153 SPELL_EFFECT_CREATE_TAMED_PET         misc value is creature entry
+    &Spell::EffectDiscoverTaxi,                             //154 SPELL_EFFECT_DISCOVER_TAXI
+    &Spell::EffectTitanGrip,                                //155 SPELL_EFFECT_TITAN_GRIP Allows you to equip two-handed axes, maces and swords in one hand, but you attack $49152s1% slower than normal.
+    &Spell::EffectEnchantItemPrismatic,                     //156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
+    &Spell::EffectCreateItem2,                              //157 SPELL_EFFECT_CREATE_ITEM_2            create item or create item template and replace by some randon spell loot item
+    &Spell::EffectMilling,                                  //158 SPELL_EFFECT_MILLING                  milling
+    &Spell::EffectRenamePet,                                //159 SPELL_EFFECT_ALLOW_RENAME_PET         allow rename pet once again
+    &Spell::EffectNULL,                                     //160 SPELL_EFFECT_160                      1 spell - 45534
+    &Spell::EffectSpecCount,                                //161 SPELL_EFFECT_TALENT_SPEC_COUNT        second talent spec (learn/revert)
+    &Spell::EffectActivateSpec,                             //162 SPELL_EFFECT_TALENT_SPEC_SELECT       activate primary/secondary spec
+    &Spell::EffectNULL,                                     //163 unused
+    &Spell::EffectRemoveAura,                               //164 SPELL_EFFECT_REMOVE_AURA
+};
+
+void Spell::EffectNULL(SpellEffIndex /*effIndex*/)
+{
+    sLog.outDebug("WORLD: Spell Effect DUMMY");
+}
+
+void Spell::EffectUnused(SpellEffIndex /*effIndex*/)
+{
+    // NOT USED BY ANY SPELL OR USELESS OR IMPLEMENTED IN DIFFERENT WAY IN TRINITY
+}
+
+void Spell::EffectResurrectNew(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->isAlive())
+        return;
+
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (!unitTarget->IsInWorld())
+        return;
+
+    Player* pTarget = unitTarget->ToPlayer();
+
+    if (pTarget->isRessurectRequested())       // already have one active request
+        return;
+
+    uint32 health = damage;
+    uint32 mana = m_spellInfo->EffectMiscValue[effIndex];
+    ExecuteLogEffectResurrect(effIndex, pTarget);
+    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
+    SendResurrectRequest(pTarget);
+}
+
+void Spell::EffectInstaKill(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive())
+        return;
+
+    // Demonic Sacrifice
+    if (m_spellInfo->Id == 18788 && unitTarget->GetTypeId() == TYPEID_UNIT)
+    {
+        uint32 entry = unitTarget->GetEntry();
+        uint32 spellID;
+        switch (entry)
+        {
+            case   416: spellID = 18789; break;               //imp
+            case   417: spellID = 18792; break;               //fellhunter
+            case  1860: spellID = 18790; break;               //void
+            case  1863: spellID = 18791; break;               //succubus
+            case 17252: spellID = 35701; break;               //fellguard
+            default:
+                sLog.outError("EffectInstaKill: Unhandled creature entry (%u) case.", entry);
+                return;
+        }
+
+        m_caster->CastSpell(m_caster, spellID, true);
+    }
+
+    if (m_caster == unitTarget)                              // prevent interrupt message
+        finish();
+
+    WorldPacket data(SMSG_SPELLINSTAKILLLOG, 8+8+4);
+    data << uint64(m_caster->GetGUID());
+    data << uint64(unitTarget->GetGUID());
+    data << uint32(m_spellInfo->Id);
+    m_caster->SendMessageToSet(&data, true);
+
+    m_caster->DealDamage(unitTarget, unitTarget->GetHealth(), NULL, NODAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+}
+
+void Spell::EffectEnvirinmentalDMG(SpellEffIndex effIndex)
+{
+    uint32 absorb = 0;
+    uint32 resist = 0;
+
+    // Note: this hack with damage replace required until GO casting not implemented
+    // environment damage spells already have around enemies targeting but this not help in case not existed GO casting support
+    // currently each enemy selected explicitly and self cast damage, we prevent apply self casted spell bonuses/etc
+    damage = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex, m_caster);
+
+    m_caster->CalcAbsorbResist(m_caster, GetSpellSchoolMask(m_spellInfo), SPELL_DIRECT_DAMAGE, damage, &absorb, &resist, m_spellInfo);
+
+    m_caster->SendSpellNonMeleeDamageLog(m_caster, m_spellInfo->Id, damage, GetSpellSchoolMask(m_spellInfo), absorb, resist, false, 0, false);
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->EnvironmentalDamage(DAMAGE_FIRE, damage);
+}
+
+void Spell::EffectSchoolDMG(SpellEffIndex /*effIndex*/)
+{
+}
+
+void Spell::SpellDamageSchoolDmg(SpellEffIndex effIndex)
+{
+    bool apply_direct_bonus = true;
+
+    if (unitTarget && unitTarget->isAlive())
+    {
+        switch (m_spellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_GENERIC:
+            {
+                // Meteor like spells (divided damage to targets)
+                if (m_customAttr & SPELL_ATTR_CU_SHARE_DAMAGE)
+                {
+                    uint32 count = 0;
+                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1<<effIndex))
+                            ++count;
+
+                    damage /= count;                    // divide to all targets
+                }
+
+                switch(m_spellInfo->Id)                     // better way to check unknown
+                {
+                    // Positive/Negative Charge
+                    case 28062:
+                    case 28085:
+                    case 39090:
+                    case 39093:
+                        if (!m_triggeredByAuraSpell)
+                            break;
+                        if (unitTarget == m_caster)
+                        {
+                            uint8 count = 0;
+                            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                                if (ihit->targetGUID != m_caster->GetGUID())
+                                    if (Player *target = ObjectAccessor::GetPlayer(*m_caster, ihit->targetGUID))
+                                        if (target->HasAura(m_triggeredByAuraSpell->Id))
+                                            ++count;
+                            if (count)
+                            {
+                                uint32 spellId = 0;
+                                switch (m_spellInfo->Id)
+                                {
+                                    case 28062: spellId = 29659; break;
+                                    case 28085: spellId = 29660; break;
+                                    case 39090: spellId = 39089; break;
+                                    case 39093: spellId = 39092; break;
+                                }
+                                m_caster->SetAuraStack(spellId, m_caster, count);
+                            }
+                        }
+
+                        if (unitTarget->HasAura(m_triggeredByAuraSpell->Id))
+                            damage = 0;
+                        break;
+                    // Consumption
+                    case 28865:
+                        damage = (((InstanceMap*)m_caster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY ? 2750 : 4250);
+                        break;
+                    // percent from health with min
+                    case 25599:                             // Thundercrash
+                    {
+                        damage = unitTarget->GetHealth() / 2;
+                        if (damage < 200)
+                            damage = 200;
+                        break;
+                    }
+                    // arcane charge. must only affect demons (also undead?)
+                    case 45072:
+                    {
+                        if (unitTarget->GetCreatureType() != CREATURE_TYPE_DEMON
+                            && unitTarget->GetCreatureType() != CREATURE_TYPE_UNDEAD)
+                            return;
+                        break;
+                    }
+                    case 33671: // gruul's shatter
+                    case 50811: // krystallus shatter ( Normal )
+                    case 61547: // krystallus shatter ( Heroic )
+                    {
+                        // don't damage self and only players
+                        if (unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                            return;
+
+                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
+                        if (!radius) return;
+                        float distance = m_caster->GetDistance2d(unitTarget);
+                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * ((radius - distance)/radius));
+                        break;
+                    }
+                    // TODO: add spell specific target requirement hook for spells
+                    // Shadowbolts only affects targets with Shadow Mark (Gothik)
+                    case 27831:
+                    case 55638:
+                        if (!unitTarget->HasAura(27825))
+                            return;
+                        break;
+                    // Cataclysmic Bolt
+                    case 38441:
+                    {
+                        damage = unitTarget->CountPctFromMaxHealth(50);
+                        break;
+                    }
+					case 69075:
+                    case 70834:
+                    case 70835:
+                    case 70836:
+                    {
+                        float distance = m_caster->GetDistance(unitTarget);
+                        float radius = 12.0f;
+                        if(distance > radius)
+                            return;
+
+                        if(distance < 1)
+                           distance = 1;
+
+                        int32 bp0 = m_spellInfo->EffectBasePoints[0];
+                        int32 damage = int32(bp0 / (distance / radius));
+                        break;
+                    }
+                    // Tympanic Tantrum
+                    case 62775:
+                    {
+                        damage = unitTarget->CountPctFromMaxHealth(10);
+                        break;
+                    }
+                    // Gargoyle Strike
+                    case 51963:
+                    {
+                        // about +4 base spell dmg per level
+                        damage = (m_caster->getLevel() - 60) * 4 + 60;
+                        break;
+                    }
+
+                    // Loken Pulsing Shockwave
+                    case 59837:
+                    case 52942:
+                    {
+                        // don't damage self and only players
+                        if(unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                            return;
+
+                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
+                        if (!radius)
+                            return;
+                        float distance = m_caster->GetDistance2d(unitTarget);
+                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * distance);
+                        break;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_WARRIOR:
+            {
+                // Bloodthirst
+                if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
+                    damage = uint32(damage * (m_caster->GetTotalAttackPowerValue(BASE_ATTACK)) / 100);
+                // Shield Slam
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x200 && m_spellInfo->Category == 1209)
+                    damage += m_caster->ApplyEffectModifiers(m_spellInfo,effIndex,int32(m_caster->GetShieldBlockValue()));
+                // Victory Rush
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x100)
+                {
+                    damage = uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
+                    m_caster->ModifyAuraState(AURA_STATE_WARRIOR_VICTORY_RUSH, false);
+                }
+                // Shockwave
+                else if (m_spellInfo->Id == 46968)
+                {
+                    int32 pct = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, 2);
+                    if (pct > 0)
+                        damage+= int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * pct / 100);
+                    break;
+                }
+                break;
+            }
+            case SPELLFAMILY_WARLOCK:
+            {
+                // Incinerate Rank 1 & 2
+                if ((m_spellInfo->SpellFamilyFlags[1] & 0x000040) && m_spellInfo->SpellIconID == 2128)
+                {
+                    // Incinerate does more dmg (dmg*0.25) if the target have Immolate debuff.
+                    // Check aura state for speed but aura state set not only for Immolate spell
+                    if (unitTarget->HasAuraState(AURA_STATE_CONFLAGRATE))
+                    {
+                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0, 0))
+                            damage += damage/4;
+                    }
+                }
+                // Conflagrate - consumes Immolate or Shadowflame
+                else if (m_spellInfo->TargetAuraState == AURA_STATE_CONFLAGRATE)
+                {
+                    AuraEffect const* aura = NULL;                // found req. aura for damage calculation
+
+                    Unit::AuraEffectList const &mPeriodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
+                    for (Unit::AuraEffectList::const_iterator i = mPeriodic.begin(); i != mPeriodic.end(); ++i)
+                    {
+                        // for caster applied auras only
+                        if ((*i)->GetSpellProto()->SpellFamilyName != SPELLFAMILY_WARLOCK ||
+                            (*i)->GetCasterGUID() != m_caster->GetGUID())
+                            continue;
+
+                        // Immolate
+                        if ((*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x4)
+                        {
+                            aura = *i;                      // it selected always if exist
+                            break;
+                        }
+
+                        // Shadowflame
+                        if ((*i)->GetSpellProto()->SpellFamilyFlags[2] & 0x00000002)
+                            aura = *i;                      // remember but wait possible Immolate as primary priority
+                    }
+
+                    // found Immolate or Shadowflame
+                    if (aura)
+                    {
+                        uint32 pdamage = aura->GetAmount() > 0 ? aura->GetAmount() : 0;
+                        pdamage = m_caster->SpellDamageBonus(unitTarget, aura->GetSpellProto(), pdamage, DOT, aura->GetBase()->GetStackAmount());
+                        uint32 pct_dir = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 1));
+                        uint8 baseTotalTicks = uint8(m_caster->CalcSpellDuration(aura->GetSpellProto()) / aura->GetSpellProto()->EffectAmplitude[0]);
+                        damage += pdamage * baseTotalTicks * pct_dir / 100;
+
+                        uint32 pct_dot = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 2)) / 3;
+                        m_spellValue->EffectBasePoints[1] = SpellMgr::CalculateSpellEffectBaseAmount(pdamage * baseTotalTicks * pct_dot / 100, m_spellInfo, 1);
+
+                        apply_direct_bonus = false;
+                        // Glyph of Conflagrate
+                        if (!m_caster->HasAura(56235))
+                            unitTarget->RemoveAurasDueToSpell(aura->GetId(), m_caster->GetGUID());
+
+                        break;
+                    }
+                }
+                // Shadow Bite
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x400000)
+                {
+                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet())
+                    {
+                        // Get DoTs on target by owner (5% increase by dot)
+                        damage += 5 * unitTarget->GetDoTsByCaster(m_caster->GetOwnerGUID()) / 100;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_PRIEST:
+            {
+                // Shadow Word: Death - deals damage equal to damage done to caster
+                if ((m_spellInfo->SpellFamilyFlags[1] & 0x2))
+                {
+                    int32 back_damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
+                    // Pain and Suffering reduces damage
+                    if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST, 2874, 0))
+                        back_damage -= aurEff->GetAmount() * back_damage / 100;
+
+                    if (back_damage < int32(unitTarget->GetHealth()))
+                        m_caster->CastCustomSpell(m_caster, 32409, &back_damage, 0, 0, true);
+                }
+                // Mind Blast - applies Mind Trauma if:
+                else if (m_spellInfo->SpellFamilyFlags[2] & 0x00002000)
+                {
+                    // We are in Shadow Form
+                    if (m_caster->m_form == FORM_SHADOW)
+                        // We have Improved Mind Blast
+                        if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST,95,0))
+                            // Chance has been successfully rolled
+                            if (roll_chance_i(aurEff->GetAmount()))
+                                m_caster->CastSpell(unitTarget, 48301, true);
+                }
+                // Smite
+                else if (m_spellInfo->SpellFamilyFlags[0] & 0x80)
+                {
+                    // Glyph of Smite
+                    if (AuraEffect * aurEff = m_caster->GetAuraEffect(55692, 0))
+                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x100000, 0, 0, m_caster->GetGUID()))
+                            damage += damage * aurEff->GetAmount() / 100;
+                }
+                // Improved Mind Blast (Mind Blast in shadow form bonus)
+                else if (m_caster->m_form == FORM_SHADOW && (m_spellInfo->SpellFamilyFlags[0] & 0x00002000))
+                {
+                    Unit::AuraEffectList const& ImprMindBlast = m_caster->GetAuraEffectsByType(SPELL_AURA_ADD_FLAT_MODIFIER);
+                    for (Unit::AuraEffectList::const_iterator i = ImprMindBlast.begin(); i != ImprMindBlast.end(); ++i)
+                    {
+                        if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_PRIEST &&
+                            ((*i)->GetSpellProto()->SpellIconID == 95))
+                        {
+                            int chance = SpellMgr::CalculateSpellEffectAmount((*i)->GetSpellProto(), 1, m_caster);
+                            if (roll_chance_i(chance))
+                                // Mind Trauma
+                                m_caster->CastSpell(unitTarget, 48301, true, 0);
+                            break;
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_DRUID:
+            {
+                // Ferocious Bite
+                if (m_caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->SpellFamilyFlags[0] & 0x000800000) && m_spellInfo->SpellVisual[0] == 6587)
+                {
+                    // converts each extra point of energy into ($f1+$AP/410) additional damage
+                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
+                    float multiple = ap / 410 + m_spellInfo->EffectDamageMultiplier[effIndex];
+                    int32 energy = -(m_caster->ModifyPower(POWER_ENERGY, -30));
+                    damage += int32(energy * multiple);
+                    damage += int32(m_caster->ToPlayer()->GetComboPoints() * ap * 7 / 100);
+                }
+                // Wrath
+                else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
+                {
+                    // Improved Insect Swarm
+                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))
+                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00200000, 0, 0))
+                            damage = int32(damage*(100.0f+aurEff->GetAmount())/100.0f);
+                }
+                break;
+            }
+            case SPELLFAMILY_ROGUE:
+            {
+                // Envenom
+                if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & 0x8)
+                {
+                    if (!m_caster->ToPlayer())
+                        return;
+
+                    uint32 combo = m_caster->ToPlayer()->GetComboPoints();
+                    if (!combo)
+                        return;
+
+                    AuraEffect const * aurEffA = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x10000, 0, 0, m_caster->GetGUID());
+                    if (!aurEffA)
+                        return;
+
+                    uint32 doses = aurEffA->GetBase()->GetStackAmount();
+                    if (doses > combo)
+                        doses = combo;
+
+                    // Master Poisoner
+                    bool needConsume = true;
+                    Unit::AuraEffectList const & auras = m_caster->ToPlayer()->GetAuraEffectsByType(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK);
+                    for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (((*itr)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_ROGUE) &&
+                            ((*itr)->GetSpellProto()->SpellIconID == 1960))
+                        {
+                            uint32 chance = SpellMgr::CalculateSpellEffectAmount((*itr)->GetSpellProto(), EFFECT_2);
+                            if ((chance >= 100) || roll_chance_i(chance))
+                                needConsume = false;
+                            break;
+                        }
+                    if (needConsume)
+                        for (uint32 i = 0; i < doses; ++i)
+                            unitTarget->RemoveAuraFromStack(aurEffA->GetId());
+
+                    damage *= doses;
+                    damage += int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.09f * combo);
+
+                    // Eviscerate and Envenom Bonus Damage
+                    if (AuraEffect const * aurEffB = m_caster->GetAuraEffect(37169, EFFECT_0, m_caster->GetGUID()))
+                        damage += combo * aurEffB->GetAmount();
+                    break;
+                }
+                // Eviscerate
+                if (m_spellInfo->SpellFamilyFlags[EFFECT_0] & 0x20000)
+                {
+                    if (!m_caster->ToPlayer())
+                        return;
+
+                    uint32 combo = m_caster->ToPlayer()->GetComboPoints();
+                    if (!combo)
+                        return;
+
+                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
+                    damage += irand(int32(ap * combo * 0.03f), int32(ap * combo * 0.07f));
+
+                    // Eviscerate and Envenom Bonus Damage
+                    if (AuraEffect const * aurEffB = m_caster->GetAuraEffect(37169, EFFECT_0, m_caster->GetGUID()))
+                        damage += combo * aurEffB->GetAmount();
+                    break;
+                }
+                break;
+            }
+            case SPELLFAMILY_HUNTER:
+            {
+                //Gore
+                if (m_spellInfo->SpellIconID == 1578)
+                {
+                    if (m_caster->HasAura(57627))           // Charge 6 sec post-affect
+                        damage *= 2;
+                }
+                // Steady Shot
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x1)
+                {
+                    bool found = false;
+                    // check dazed affect
+                    Unit::AuraEffectList const& decSpeedList = unitTarget->GetAuraEffectsByType(SPELL_AURA_MOD_DECREASE_SPEED);
+                    for (Unit::AuraEffectList::const_iterator iter = decSpeedList.begin(); iter != decSpeedList.end(); ++iter)
+                    {
+                        if ((*iter)->GetSpellProto()->SpellIconID == 15 && (*iter)->GetSpellProto()->Dispel == 0)
+                        {
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    // TODO: should this be put on taken but not done?
+                    if (found)
+                        damage += SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
+
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        // Add Ammo and Weapon damage plus RAP * 0.1
+                        Item *item = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
+                        if (item)
+                        {
+                            float dmg_min = item->GetProto()->Damage->DamageMin;
+                            float dmg_max = item->GetProto()->Damage->DamageMax;
+                            if (dmg_max == 0.0f && dmg_min > dmg_max)
+                                damage += int32(dmg_min);
+                            else
+                                damage += irand(int32(dmg_min), int32(dmg_max));
+                            damage += int32(m_caster->ToPlayer()->GetAmmoDPS()*item->GetProto()->Delay*0.001f);
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_PALADIN:
+            {
+                // Hammer of the Righteous
+                if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & 0x40000)
+                {
+                    // Add main hand dps * effect[2] amount
+                    float average = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2;
+                    int32 count = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, EFFECT_2);
+                    damage += count * int32(average * IN_MILLISECONDS) / m_caster->GetAttackTime(BASE_ATTACK);
+                    break;
+                }
+                // Shield of Righteousness
+                 else if (m_spellInfo->SpellFamilyFlags[1]&0x00100000)
+                 {                
+					 damage += int32(m_caster->GetShieldBlockValue());
+                 }
+                // Blood Boil - bonus for diseased targets
+                if (m_spellInfo->SpellFamilyFlags[0] & 0x00040000 && unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0, 0, 0x00000002, m_caster->GetGUID()))
+                {
+                    damage += m_damage / 2;
+                    damage += int32(m_caster->GetTotalAttackPowerValue(RANGED_ATTACK)* 0.035f);
+                }
+                break;
+            }
+        }
+
+        if (m_originalCaster && damage > 0 && apply_direct_bonus)
+            damage = m_originalCaster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
+
+        m_damage += damage;
+    }
+}
+
+void Spell::EffectDummy(SpellEffIndex effIndex)
+{
+    if (!unitTarget && !gameObjTarget && !itemTarget)
+        return;
+
+    uint32 spell_id = 0;
+    int32 bp = 0;
+    bool triggered = true;
+    SpellCastTargets targets;
+
+    // selection by spell family
+    switch (m_spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch (m_spellInfo->Id)
+            {
+                case 8593:                                  // Symbol of life (restore creature to life)
+                case 31225:                                 // Shimmering Vessel (restore creature to life)
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+                    unitTarget->ToCreature()->setDeathState(JUST_ALIVED);
+                    return;
+                }
+                case 12162:                                 // Deep wounds
+                case 12850:                                 // (now good common check for this spells)
+                case 12868:
+                {
+                    if (!unitTarget)
+                        return;
+
+                    float damage;
+                    // DW should benefit of attack power, damage percent mods etc.
+                    // TODO: check if using offhand damage is correct and if it should be divided by 2
+                    if (m_caster->haveOffhandWeapon() && m_caster->getAttackTimer(BASE_ATTACK) > m_caster->getAttackTimer(OFF_ATTACK))
+                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE))/2;
+                    else
+                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE))/2;
+
+                    switch (m_spellInfo->Id)
+                    {
+                        case 12162: damage *= 0.16f; break; // Rank 1
+                        case 12850: damage *= 0.32f; break; // Rank 2
+                        case 12868: damage *= 0.48f; break; // Rank 3
+                        default:
+                            sLog.outError("Spell::EffectDummy: Spell %u not handled in DW",m_spellInfo->Id);
+                            return;
+                    };
+
+                    // get remaining damage of old Deep Wound aura
+                    AuraEffect* deepWound = unitTarget->GetAuraEffect(12721, 0);
+                    if (deepWound)
+                    {
+                        int32 remainingTicks = deepWound->GetBase()->GetDuration() / deepWound->GetAmplitude();
+                        damage += remainingTicks * deepWound->GetAmount();
+                    }
+
+                    // 1 tick/sec * 6 sec = 6 ticks
+                    int32 deepWoundsDotBasePoints0 = int32(damage / 6);
+                    m_caster->CastCustomSpell(unitTarget, 12721, &deepWoundsDotBasePoints0, NULL, NULL, true, NULL);
+                    return;
+                }
+                case 13567:                                 // Dummy Trigger
+                {
+                    // can be used for different aura triggering, so select by aura
+                    if (!m_triggeredByAuraSpell || !unitTarget)
+                        return;
+
+                    switch (m_triggeredByAuraSpell->Id)
+                    {
+                        case 26467:                         // Persistent Shield
+                            m_caster->CastCustomSpell(unitTarget, 26470, &damage, NULL, NULL, true);
+                            break;
+                        default:
+                            sLog.outError("EffectDummy: Non-handled case for spell 13567 for triggered aura %u",m_triggeredByAuraSpell->Id);
+                            break;
+                    }
+                    return;
+                }
+                case 17251:                                 // Spirit Healer Res
+                {
+                    if (!unitTarget || !m_originalCaster)
+                        return;
+
+                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        WorldPacket data(SMSG_SPIRIT_HEALER_CONFIRM, 8);
+                        data << uint64(unitTarget->GetGUID());
+                        m_originalCaster->ToPlayer()->GetSession()->SendPacket(&data);
+                    }
+                    return;
+                }
+                case 20577:                                 // Cannibalize
+                    if (unitTarget)
+                        m_caster->CastSpell(m_caster, 20578, false, NULL);
+                    return;
+                case 23019:                                 // Crystal Prison Dummy DND
+                {
+                    if (!unitTarget || !unitTarget->isAlive() || unitTarget->GetTypeId() != TYPEID_UNIT || unitTarget->ToCreature()->isPet())
+                        return;
+
+                    Creature* creatureTarget = unitTarget->ToCreature();
+
+                    m_caster->SummonGameObject(179644, creatureTarget->GetPositionX(), creatureTarget->GetPositionY(), creatureTarget->GetPositionZ(), creatureTarget->GetOrientation(), 0, 0, 0, 0, uint32(creatureTarget->GetRespawnTime()-time(NULL)));
+                    sLog.outDebug("SummonGameObject at SpellEfects.cpp EffectDummy for Spell 23019");
+
+                    creatureTarget->ForcedDespawn();
+
+                    return;
+                }
+                case 23448:                                 // Transporter Arrival - Ultrasafe Transporter: Gadgetzan - backfires
+                {
+                    int32 r = irand(0, 119);
+                    if (r < 20)                           // Transporter Malfunction - 1/6 polymorph
+                        m_caster->CastSpell(m_caster, 23444, true);
+                    else if (r < 100)                     // Evil Twin               - 4/6 evil twin
+                        m_caster->CastSpell(m_caster, 23445, true);
+                    else                                    // Transporter Malfunction - 1/6 miss the target
+                        m_caster->CastSpell(m_caster, 36902, true);
+                    return;
+                }
+                case 23453:                                 // Gnomish Transporter - Ultrasafe Transporter: Gadgetzan
+                    if (roll_chance_i(50))                // Gadgetzan Transporter         - success
+                        m_caster->CastSpell(m_caster, 23441, true);
+                    else                                    // Gadgetzan Transporter Failure - failure
+                        m_caster->CastSpell(m_caster, 23446, true);
+                    return;
+                case 25860:                                 // Reindeer Transformation
+                {
+                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
+                        return;
+
+                    float flyspeed = m_caster->GetSpeedRate(MOVE_FLIGHT);
+                    float speed = m_caster->GetSpeedRate(MOVE_RUN);
+
+                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    //5 different spells used depending on mounted speed and if mount can fly or not
+                    if (flyspeed >= 4.1f)
+                        // Flying Reindeer
+                        m_caster->CastSpell(m_caster, 44827, true); //310% flying Reindeer
+                    else if (flyspeed >= 3.8f)
+                        // Flying Reindeer
+                        m_caster->CastSpell(m_caster, 44825, true); //280% flying Reindeer
+                    else if (flyspeed >= 1.6f)
+                        // Flying Reindeer
+                        m_caster->CastSpell(m_caster, 44824, true); //60% flying Reindeer
+                    else if (speed >= 2.0f)
+                        // Reindeer
+                        m_caster->CastSpell(m_caster, 25859, true); //100% ground Reindeer
+                    else
+                        // Reindeer
+                        m_caster->CastSpell(m_caster, 25858, true); //60% ground Reindeer
+
+                    return;
+                }
+                case 26074:                                 // Holiday Cheer
+                    // implemented at client side
+                    return;
+                // Polarity Shift
+                case 28089:
+                    if (unitTarget)
+                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 28059 : 28084, true, NULL, NULL, m_caster->GetGUID());
+                    break;
+                // Polarity Shift
+                case 39096:
+                    if (unitTarget)
+                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 39088 : 39091, true, NULL, NULL, m_caster->GetGUID());
+                    break;
+                case 29200:                                 // Purify Helboar Meat
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    uint32 spell_id = roll_chance_i(50)
+                        ? 29277                             // Summon Purified Helboar Meat
+                        : 29278;                            // Summon Toxic Helboar Meat
+
+                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
+                    return;
+                }
+                case 29858:                                 // Soulshatter
+                    if (unitTarget && unitTarget->CanHaveThreatList()
+                        && unitTarget->getThreatManager().getThreat(m_caster) > 0.0f)
+                        m_caster->CastSpell(unitTarget,32835,true);
+                    return;
+                case 30458:                                 // Nigh Invulnerability
+                    if (!m_CastItem) return;
+                    if (roll_chance_i(86))                   // Nigh-Invulnerability   - success
+                        m_caster->CastSpell(m_caster, 30456, true, m_CastItem);
+                    else                                    // Complete Vulnerability - backfire in 14% casts
+                        m_caster->CastSpell(m_caster, 30457, true, m_CastItem);
+                    return;
+                case 30507:                                 // Poultryizer
+                    if (!m_CastItem) return;
+                    if (roll_chance_i(80))                   // Poultryized! - success
+                        m_caster->CastSpell(unitTarget, 30501, true, m_CastItem);
+                    else                                    // Poultryized! - backfire 20%
+                        m_caster->CastSpell(unitTarget, 30504, true, m_CastItem);
+                    return;
+                case 35745:                                 // Socrethar's Stone
+                {
+                    uint32 spell_id;
+                    switch(m_caster->GetAreaId())
+                    {
+                        case 3900: spell_id = 35743; break; // Socrethar Portal
+                        case 3742: spell_id = 35744; break; // Socrethar Portal
+                        default: return;
+                    }
+
+                    m_caster->CastSpell(m_caster, spell_id, true);
+                    return;
+                }
+                case 37674:                                 // Chaos Blast
+                {
+                    if (!unitTarget)
+                        return;
+
+                    int32 basepoints0 = 100;
+                    m_caster->CastCustomSpell(unitTarget, 37675, &basepoints0, NULL, NULL, true);
+                    return;
+                }
+                // Wrath of the Astromancer
+                case 42784:
+                {
+                    uint32 count = 0;
+                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1<<effIndex))
+                            ++count;
+
+                    damage = 12000; // maybe wrong value
+                    damage /= count;
+
+                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(42784);
+
+                     // now deal the damage
+                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1<<effIndex))
+                        {
+                            if (Unit* casttarget = Unit::GetUnit((*unitTarget), ihit->targetGUID))
+                                m_caster->DealDamage(casttarget, damage, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_ARCANE, spellInfo, false);
+                        }
+
+                    return;
+                }
+                // Demon Broiled Surprise
+                case 43723:
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    Player *player = (Player*)m_caster;
+
+                    if (player && player->GetQuestStatus(11379) == QUEST_STATUS_INCOMPLETE)
+                    {
+                        Creature *creature = player->FindNearestCreature(19973, 10, false);
+                        if (!creature)
+                        {
+                            SendCastResult(SPELL_FAILED_NOT_HERE);
+                            return;
+                        }
+
+                        player->CastSpell(player, 43753, false);
+                    }
+                    return;
+                }
+                case 44875:                                 // Complete Raptor Capture
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    unitTarget->ToCreature()->ForcedDespawn();
+
+                    //cast spell Raptor Capture Credit
+                    m_caster->CastSpell(m_caster, 42337, true, NULL);
+                    return;
+                }
+                case 47170:                                 // Impale Leviroth
+                {
+                    if (!unitTarget && unitTarget->GetEntry() != 26452 && unitTarget->HealthAbovePct(95))
+                        return;
+
+                        m_caster->DealDamage(unitTarget, unitTarget->CountPctFromMaxHealth(93));
+                        return;
+                }
+                case 49357:                                 // Brewfest Mount Transformation
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
+                        return;
+                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                    // Ram for Alliance, Kodo for Horde
+                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                    {
+                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Ram
+                            m_caster->CastSpell(m_caster, 43900, true);
+                        else
+                            // 60% Ram
+                            m_caster->CastSpell(m_caster, 43899, true);
+                    }
+                    else
+                    {
+                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Kodo
+                            m_caster->CastSpell(m_caster, 49379, true);
+                        else
+                            // 60% Kodo
+                            m_caster->CastSpell(m_caster, 49378, true);
+                    }
+                    return;
+                case 52845:                                 // Brewfest Mount Transformation (Faction Swap)
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
+                        return;
+                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                    // Ram for Horde, Kodo for Alliance
+                    if (m_caster->ToPlayer()->GetTeam() == HORDE)
+                    {
+                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Ram
+                            m_caster->CastSpell(m_caster, 43900, true);
+                        else
+                            // 60% Ram
+                            m_caster->CastSpell(m_caster, 43899, true);
+                    }
+                    else
+                    {
+                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Kodo
+                            m_caster->CastSpell(m_caster, 49379, true);
+                        else
+                            // 60% Kodo
+                            m_caster->CastSpell(m_caster, 49378, true);
+                    }
+                    return;
+                case 55004:                                 // Nitro Boosts
+                    if (!m_CastItem)
+                        return;
+                    if (roll_chance_i(95))                  // Nitro Boosts - success
+                        m_caster->CastSpell(m_caster, 54861, true, m_CastItem);
+                    else                                    // Knocked Up   - backfire 5%
+                        m_caster->CastSpell(m_caster, 46014, true, m_CastItem);
+                    return;
+                case 50243:                                 // Teach Language
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // spell has a 1/3 chance to trigger one of the below
+                    if (roll_chance_i(66))
+                        return;
+                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                    {
+                        // 1000001 - gnomish binary
+                        m_caster->CastSpell(m_caster, 50242, true);
+                    }
+                    else
+                    {
+                        // 01001000 - goblin binary
+                        m_caster->CastSpell(m_caster, 50246, true);
+                    }
+
+                    return;
+                }
+                case 51582:                                 //Rocket Boots Engaged (Rocket Boots Xtreme and Rocket Boots Xtreme Lite)
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    if (Battleground* bg = m_caster->ToPlayer()->GetBattleground())
+                        bg->EventPlayerDroppedFlag(m_caster->ToPlayer());
+
+                    m_caster->CastSpell(m_caster, 30452, true, NULL);
+                    return;
+                }
+                case 52759:                                 // Ancestral Awakening
+                    if (!unitTarget)
+                        return;
+                    m_caster->CastCustomSpell(unitTarget, 52752, &damage, NULL, NULL, true);
+                    return;
+                case 54171:                                   //Divine Storm
+                {
+                    if (!damage)
+                        return;
+
+                    if (m_UniqueTargetInfo.size())
+                    {
+                        SpellEntry const * spellInfo = sSpellStore.LookupEntry(53385);
+                        int32 heal = SpellMgr::CalculateSpellEffectAmount(spellInfo, EFFECT_1) * damage / m_UniqueTargetInfo.size() / 100;
+
+                        m_caster->CastCustomSpell(unitTarget, 54172, &heal, NULL, NULL, true);
+                    }
+                    return;
+                }
+                case 58418:                                 // Portal to Orgrimmar
+                case 58420:                                 // Portal to Stormwind
+                    return;                                 // implemented in EffectScript[0]
+                case 62324: // Throw Passenger
+                {
+                    if (m_targets.HasTraj())
+                    {
+                        if (Vehicle *vehicle = m_caster->GetVehicleKit())
+                            if (Unit *passenger = vehicle->GetPassenger(damage - 1))
+                            {
+                                std::list<Unit*> unitList;
+                                // use 99 because it is 3d search
+                                SearchAreaTarget(unitList, 99, PUSH_DST_CENTER, SPELL_TARGETS_ENTRY, 33114);
+                                float minDist = 99 * 99;
+                                Vehicle *target = NULL;
+                                for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+                                {
+                                    if (Vehicle *seat = (*itr)->GetVehicleKit())
+                                        if (!seat->GetPassenger(0))
+                                            if (Unit *device = seat->GetPassenger(2))
+                                                if (!device->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+                                                {
+                                                    float dist = (*itr)->GetExactDistSq(&m_targets.m_dstPos);
+                                                    if (dist < minDist)
+                                                    {
+                                                        minDist = dist;
+                                                        target = seat;
+                                                    }
+                                                }
+                                }
+                                if (target && target->GetBase()->IsWithinDist2d(&m_targets.m_dstPos, GetSpellRadius(m_spellInfo, effIndex, false) * 2)) // now we use *2 because the location of the seat is not correct
+                                    passenger->EnterVehicle(target, 0);
+                                else
+                                {
+                                    passenger->ExitVehicle();
+                                    float x, y, z;
+                                    m_targets.m_dstPos.GetPosition(x, y, z);
+                                    passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
+                                }
+                            }
+                    }
+                    return;
+                }
+                case 64385:                                 // Unusual Compass
+                {
+                    m_caster->SetOrientation(float(urand(0,62832)) / 10000.0f);
+                    WorldPacket data;
+                    m_caster->BuildHeartBeatMsg(&data);
+                    m_caster->SendMessageToSet(&data,true);
+                    return;
+                }
+                case 199999: //Earthen Power Helper (SERVERSIDE)
+                {
+                    if (!m_caster->isTotem())
+                        return;
+
+                    if (AuraEffect * aurEff = m_caster->ToTotem()->GetOwner()->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 2289, 0))
+                        if (roll_chance_i(aurEff->GetAmount()))
+                            m_caster->CastSpell(m_caster, 59566, true, NULL, NULL, m_originalCasterGUID);
+                    return;
+                }
+                case 51962:                                 // Offer Jungle Punch
+                {
+
+                    if (!m_caster || !unitTarget)
+                        return;
+
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    Creature *target_crature = unitTarget->ToCreature();
+                    Player *caster_player = m_caster->ToPlayer();
+                    if(target_crature && caster_player)
+                    {
+                        switch(target_crature->GetEntry())
+                        {
+                            case 27986:
+                            case 28047:
+                            case 28568:
+                                caster_player->KilledMonsterCredit(target_crature->GetEntry(),0);
+                                break;
+                            default:
+                                break;
+                        }
+                    }
+                    return;
+                }
+
+            }
+
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+            // Charge
+            if (m_spellInfo->SpellFamilyFlags & SPELLFAMILYFLAG_WARRIOR_CHARGE && m_spellInfo->SpellVisual[0] == 867)
+            {
+                int32 chargeBasePoints0 = damage;
+                m_caster->CastCustomSpell(m_caster, 34846, &chargeBasePoints0, NULL, NULL, true);
+
+                //Juggernaut crit bonus
+                if (m_caster->HasAura(64976))
+                    m_caster->CastSpell(m_caster, 65156, true);
+                return;
+            }
+            //Slam
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_SLAM && m_spellInfo->SpellIconID == 559)
+            {
+                int32 bp0 = damage;
+                m_caster->CastCustomSpell(unitTarget, 50783, &bp0, NULL, NULL, true, 0);
+                return;
+            }
+            // Execute
+            if (m_spellInfo->SpellFamilyFlags[EFFECT_0] & SPELLFAMILYFLAG_WARRIOR_EXECUTE)
+            {
+                if (!unitTarget)
+                    return;
+
+                spell_id = 20647;
+
+                int32 rageUsed = std::min<int32>(300 - m_powerCost, m_caster->GetPower(POWER_RAGE));
+                int32 newRage = std::max<int32>(0, m_caster->GetPower(POWER_RAGE) - rageUsed);
+
+                // Sudden Death rage save
+                if (AuraEffect * aurEff = m_caster->GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_GENERIC, 1989, EFFECT_0))
+                {
+                    int32 ragesave = SpellMgr::CalculateSpellEffectAmount(aurEff->GetSpellProto(), EFFECT_1) * 10;
+                    newRage = std::max(newRage, ragesave);
+                }
+
+                m_caster->SetPower(POWER_RAGE, uint32(newRage));
+
+                // Glyph of Execution bonus
+                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58367, EFFECT_0))
+                    rageUsed += aurEff->GetAmount() * 10;
+
+                bp = damage + int32(rageUsed * m_spellInfo->EffectDamageMultiplier[effIndex] + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.2f);
+                break;
+            }
+            // Concussion Blow
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_CONCUSSION_BLOW)
+            {
+                m_damage+= uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
+                return;
+            }
+            switch(m_spellInfo->Id)
+            {
+                // Bloodthirst
+                case 23881:
+                {
+                    m_caster->CastCustomSpell(unitTarget, 55970, &damage, NULL, NULL, true, NULL);
+                    return;
+                }
+                case 55046:
+                {
+                    if (!m_caster || !unitTarget)
+                        return;
+                    if (m_caster->GetTypeId() != TYPEID_UNIT)
+                        return;
+                    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    Creature *target_crature = unitTarget->ToCreature();
+                    Creature *caster_crature = m_caster->ToCreature();
+                    if(target_crature && caster_crature && target_crature->GetEntry() == 29639 && caster_crature->GetOwner())
+                    {
+                        if(Player *plr = caster_crature->GetOwner()->ToPlayer())
+                        {
+                            plr->KilledMonsterCredit(29734,0);
+                            plr->KilledMonsterCredit(29709,0);
+                        }
+                        target_crature->ForcedDespawn();
+                        caster_crature->ForcedDespawn();
+                    }
+                    return;
+                }
+            }
+            break;
+        case SPELLFAMILY_WARLOCK:
+            // Life Tap
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARLOCK_LIFETAP)
+            {
+                float spFactor = 0.0f;
+                switch (m_spellInfo->Id)
+                {
+                    case 11689: spFactor = 0.2f; break;
+                    case 27222:
+                    case 57946: spFactor = 0.5f; break;
+                }
+                int32 damage = int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) + (6.3875 * m_spellInfo->baseLevel));
+                int32 mana = int32(damage + (m_caster->ToPlayer()->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+SPELL_SCHOOL_SHADOW) * spFactor));
+
+                if (unitTarget && (int32(unitTarget->GetHealth()) > damage))
+                {
+                    // Shouldn't Appear in Combat Log
+                    unitTarget->ModifyHealth(-damage);
+
+                    // Improved Life Tap mod
+                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 208, 0))
+                        mana = (aurEff->GetAmount() + 100)* mana / 100;
+
+                    m_caster->CastCustomSpell(unitTarget, 31818, &mana, NULL, NULL, true);
+
+                    // Mana Feed
+                    int32 manaFeedVal = 0;
+                    if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_WARLOCK, 1982, 0))
+                        manaFeedVal = aurEff->GetAmount();
+
+                    if (manaFeedVal > 0)
+                    {
+                        manaFeedVal = manaFeedVal * mana / 100;
+                        m_caster->CastCustomSpell(m_caster, 32553, &manaFeedVal, NULL, NULL, true, NULL);
+                    }
+                }
+                else
+                    SendCastResult(SPELL_FAILED_FIZZLE);
+                return;
+            }
+            break;
+        case SPELLFAMILY_DRUID:
+            // Starfall
+            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_DRUID_STARFALL)
+            {
+                //Shapeshifting into an animal form or mounting cancels the effect.
+                if (m_caster->GetCreatureType() == CREATURE_TYPE_BEAST || m_caster->IsMounted())
+                {
+                    if (m_triggeredByAuraSpell)
+                        m_caster->RemoveAurasDueToSpell(m_triggeredByAuraSpell->Id);
+                    return;
+                }
+
+                //Any effect which causes you to lose control of your character will supress the starfall effect.
+                if (m_caster->hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_FLEEING | UNIT_STAT_ROOT | UNIT_STAT_CONFUSED))
+                    return;
+
+                if ((unitTarget->HasAuraType(SPELL_AURA_MOD_STEALTH) || unitTarget->m_invisibilityMask) 
+                        && !m_caster->canSeeOrDetect(unitTarget, true))
+                    return;
+
+                m_caster->CastSpell(unitTarget, damage, true);
+                return;
+            }
+            break;
+        case SPELLFAMILY_PALADIN:
+            // Divine Storm
+             if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & SPELLFAMILYFLAG1_PALADIN_DIVINESTORM)
+            {
+                int32 dmg, m_damageO, m_healingO;
+                Unit * unitTargetO;
+                switch (effIndex)
+                {
+                    case EFFECT_0:
+                        m_damageO = m_damage; m_healingO = m_healing; unitTargetO = unitTarget;                       
+                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                            if (ihit->effectMask & (1<<EFFECT_2))
+                            {
+                                DoAllEffectOnTarget(&(*ihit));
+                                ihit->damage = m_damage;
+                           }
+                        m_damage = m_damageO; m_healing = m_healingO; unitTarget = unitTargetO;
+                        return;
+                    case EFFECT_1:
+                        dmg = 0;
+                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                            if (ihit->effectMask & (1<<EFFECT_2))
+                                dmg += ihit->damage;
+                        if (dmg)
+                        {
+                            if (!unitTarget)
+                                unitTarget = m_caster;
+                            dmg = int32((float)dmg * (float)damage / 100.0f);
+                            m_caster->CastCustomSpell(unitTarget, 54171, &dmg, 0, 0, true);
+                        }
+                        return;
+                    default:
+                        return;
+                }
+
+            }
+            switch(m_spellInfo->Id)
+            {
+                case 31789:                                 // Righteous Defense (step 1)
+                {
+                    // Clear targets for eff 1
+                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        ihit->effectMask &= ~(1<<1);
+
+                    // not empty (checked), copy
+                    Unit::AttackerSet attackers = unitTarget->getAttackers();
+
+                    // selected from list 3
+                    for (uint32 i = 0; i < std::min(size_t(3), attackers.size()); ++i)
+                    {
+                        Unit::AttackerSet::iterator aItr = attackers.begin();
+                        std::advance(aItr, rand() % attackers.size());
+                        AddUnitTarget((*aItr), 1);
+                        attackers.erase(aItr);
+                    }
+
+                    // now let next effect cast spell at each target.
+                    return;
+                }
+            }
+            break;
+        case SPELLFAMILY_SHAMAN:
+            // Cleansing Totem Pulse
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_TOTEM_EFFECTS && m_spellInfo->SpellIconID == 1673)
+            {
+                int32 bp1 = 1;
+                // Cleansing Totem Effect
+                if (unitTarget)
+                    m_caster->CastCustomSpell(unitTarget, 52025, NULL, &bp1, NULL, true, NULL, NULL, m_originalCasterGUID);
+                return;
+            }
+            // Healing Stream Totem
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_HEALING_STREAM)
+            {
+                if (!unitTarget)
+                    return;
+                // Restorative Totems
+                if (Unit *owner = m_caster->GetOwner())
+                    if (AuraEffect *dummy = owner->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 338, 1))
+                        damage += damage * dummy->GetAmount() / 100;
+
+                    m_caster->CastCustomSpell(unitTarget, 52042, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
+                return;
+            }
+            // Mana Spring Totem
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_MANA_SPRING)
+            {
+                if (!unitTarget || unitTarget->getPowerType() != POWER_MANA)
+                    return;
+                m_caster->CastCustomSpell(unitTarget, 52032, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
+                return;
+            }
+            // Lava Lash
+            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_SHAMAN_LAVA_LASH)
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return;
+
+                if (m_caster->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
+                {
+                    // Damage is increased by 25% if your off-hand weapon is enchanted with Flametongue.
+                    if (m_caster->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 0x200000, 0, 0))
+                        m_damage += m_damage * damage / 100;
+                }
+                return;
+            }
+            break;
+        case SPELLFAMILY_DEATHKNIGHT:
+            // Death strike
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_STRIKE)
+            {
+                uint32 count = unitTarget->GetDiseasesByCaster(m_caster->GetGUID());
+                int32 bp = int32(count * m_caster->CountPctFromMaxHealth(int32(m_spellInfo->EffectDamageMultiplier[0])));
+                // Improved Death Strike
+                if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DEATHKNIGHT, 2751, 0))
+                    bp = int32(bp * (m_caster->CalculateSpellDamage(m_caster, aurEff->GetSpellProto(), 2) + 100.0f) / 100.0f);
+                m_caster->CastCustomSpell(m_caster, 45470, &bp, NULL, NULL, false);
+                return;
+            }
+            // Death Coil
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_COIL)
+            {
+                if (m_caster->IsFriendlyTo(unitTarget))
+                {
+                    int32 bp = int32(damage * 1.5f);
+                    m_caster->CastCustomSpell(unitTarget, 47633, &bp, NULL, NULL, true);
+                }
+                else
+                {
+                    int32 bp = damage;
+                    m_caster->CastCustomSpell(unitTarget, 47632, &bp, NULL, NULL, true);
+                }
+                return;
+            }
+            switch (m_spellInfo->Id)
+            {
+            case 49560: // Death Grip
+                Position pos;
+                GetSummonPosition(effIndex, pos);
+                if (Unit *unit = unitTarget->GetVehicleBase()) // what is this for?
+                    unit->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
+                else
+                    unitTarget->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
+                return;
+            case 46584: // Raise Dead
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return;
+
+                // Do we have talent Master of Ghouls?
+                if (m_caster->HasAura(52143))
+                    // summon as pet
+                    bp = 52150;
+                else
+                    // or guardian
+                    bp = 46585;
+
+                if (m_targets.HasDst())
+                    targets.setDst(m_targets.m_dstPos);
+                else
+                {
+                    targets.setDst(*m_caster);
+                    // Corpse not found - take reagents (only not triggered cast can take them)
+                    triggered = false;
+                }
+                // Remove cooldown - summon spellls have category
+                m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id, true);
+                spell_id = 48289;
+                break;
+            // Raise dead - take reagents and trigger summon spells
+            case 48289:
+                if (m_targets.HasDst())
+                    targets.setDst(m_targets.m_dstPos);
+
+                spell_id = CalculateDamage(0, NULL);
+                break;
+            }
+            break;
+        case SPELLFAMILY_MAGE:
+        {
+            switch (m_spellInfo->Id)
+            {
+                case 44450: // Burnout
+                {
+                    if (!unitTarget)
+                        return;
+
+                    unitTarget->ModifyPower(POWER_MANA, -damage);
+                    return;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    //spells triggered by dummy effect should not miss
+    if (spell_id)
+    {
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
+
+        if (!spellInfo)
+        {
+            sLog.outError("EffectDummy of spell %u: triggering unknown spell id %i\n", m_spellInfo->Id, spell_id);
+            return;
+        }
+
+        targets.setUnitTarget(unitTarget);
+        Spell* spell = new Spell(m_caster, spellInfo, triggered, m_originalCasterGUID, true);
+        if (bp) spell->SetSpellValue(SPELLVALUE_BASE_POINT0, bp);
+        spell->prepare(&targets);
+    }
+
+    // pet auras
+    if (PetAura const* petSpell = sSpellMgr.GetPetAura(m_spellInfo->Id,effIndex))
+    {
+        m_caster->AddPetAura(petSpell);
+        return;
+    }
+
+    // normal DB scripted effect
+    sLog.outDebug("Spell ScriptStart spellid %u in EffectDummy(%u)", m_spellInfo->Id, effIndex);
+    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
+
+    // Script based implementation. Must be used only for not good for implementation in core spell effects
+    // So called only for not proccessed cases
+    if (gameObjTarget)
+        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, gameObjTarget);
+    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_UNIT)
+        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, unitTarget->ToCreature());
+    else if (itemTarget)
+        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, itemTarget);
+}
+
+void Spell::EffectTriggerSpellWithValue(SpellEffIndex effIndex)
+{
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerSpellWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    int32 bp = damage;
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastCustomSpell(unitTarget,triggered_spell_id,&bp,&bp,&bp,true);
+}
+
+void Spell::EffectTriggerRitualOfSummoning(SpellEffIndex effIndex)
+{
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerRitualOfSummoning of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    finish();
+
+    m_caster->CastSpell(unitTarget,spellInfo,false);
+}
+
+void Spell::EffectForceCast(SpellEffIndex effIndex)
+{
+      switch(m_spellInfo->Id)
+      {
+               case 66548://Teleport (IC battleground)
+               {
+                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(23472,60.0f,true))
+                       {
+                               float x,y,z,o;
+                               TargetTeleport->GetPosition(x,y,z,o);
+                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
+                                       return;
+                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
+                       }
+                       return;        
+               }
+               case 66549:
+               {
+                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(22515,60.0f,true))
+                       {
+                               float x,y,z,o;
+                               TargetTeleport->GetPosition(x,y,z,o);
+                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
+                                       return;
+                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
+                       }
+                       return;
+               }
+       }
+
+    if (!unitTarget)
+        return;
+
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectForceCast of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    if (damage)
+    {
+        switch(m_spellInfo->Id)
+        {
+                case 66218: //Catapulte
+                if (Vehicle *vehicle = m_caster->GetVehicleKit())
+                    if (Unit *passenger = vehicle->GetPassenger(0))
+                    {
+                        passenger->ExitVehicle();
+                    passenger->AddAura(66251,passenger);
+                        float x, y, z;
+                        m_targets.m_dstPos.GetPosition(x, y, z);
+                        passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
+                    }                    
+                return;    
+            case 66629:
+            case 66638:
+            {
+                if(!(m_caster->GetTypeId()==TYPEID_PLAYER))
+                    return;
+                Player *plr = m_caster->ToPlayer();
+                if (Battleground *bg = plr->GetBattleground())
+                    {
+                        if (bg->GetTypeID(true) == BATTLEGROUND_IC)
+                            bg->EventPlayerCapturedFlag(plr);
+                        return;
+                    }
+                
+                return;
+            }
+            case 52588: // Skeletal Gryphon Escape
+            case 48598: // Ride Flamebringer Cue
+                unitTarget->RemoveAura(damage);
+                break;
+            case 52463: // Hide In Mine Car
+            case 52349: // Overtake
+                unitTarget->CastCustomSpell(unitTarget, spellInfo->Id, &damage, NULL, NULL, true, NULL, NULL, m_originalCasterGUID);
+                return;
+            case 72378: // Blood Nova
+            case 73058: // Blood Nova
+                spellInfo = sSpellMgr.GetSpellForDifficultyFromSpell(spellInfo, m_caster);
+                break;
+        }
+    }
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastSpell(unitTarget, spellInfo, true, NULL, NULL, m_originalCasterGUID);
+}
+
+void Spell::EffectForceCastWithValue(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectForceCastWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+    int32 bp = damage;
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastCustomSpell(unitTarget, spellInfo->Id, &bp, &bp, &bp, true, NULL, NULL, m_originalCasterGUID);
+}
+
+
+void Spell::EffectTriggerSpell(SpellEffIndex effIndex)
+{
+    // only unit case known
+    if (!unitTarget)
+    {
+        if (gameObjTarget || itemTarget)
+            sLog.outError("Spell::EffectTriggerSpell (Spell: %u): Unsupported non-unit case!",m_spellInfo->Id);
+        return;
+    }
+
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+    Unit* originalCaster = NULL;
+
+    // special cases
+    switch(triggered_spell_id)
+    {
+        // Mirror Image
+        case 58832:
+        {
+            // Glyph of Mirror Image
+            if (m_caster->HasAura(63093))
+               m_caster->CastSpell(m_caster, 65047, true); // Mirror Image
+
+            break;
+        }
+        // Vanish (not exist)
+        case 18461:
+        {
+            unitTarget->RemoveMovementImpairingAuras();
+            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
+
+            // if this spell is given to NPC it must handle rest by it's own AI
+            if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+                return;
+
+            // get highest rank of the Stealth spell
+            uint32 spellId = 0;
+            SpellEntry const *spellInfo;
+            const PlayerSpellMap& sp_list = unitTarget->ToPlayer()->GetSpellMap();
+            for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
+            {
+                // only highest rank is shown in spell book, so simply check if shown in spell book
+                if (!itr->second->active || itr->second->disabled || itr->second->state == PLAYERSPELL_REMOVED)
+                    continue;
+
+                spellInfo = sSpellStore.LookupEntry(itr->first);
+                if (!spellInfo)
+                    continue;
+
+                if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_ROGUE_STEALTH)
+                {
+                    spellId = spellInfo->Id;
+                    break;
+                }
+            }
+
+            // no Stealth spell found
+            if (!spellId)
+                return;
+
+            // reset cooldown on it if needed
+            if (unitTarget->ToPlayer()->HasSpellCooldown(spellId))
+                unitTarget->ToPlayer()->RemoveSpellCooldown(spellId);
+
+            triggered_spell_id =  spellId;
+            break;
+        }
+        // Demonic Empowerment -- succubus
+        case 54437:
+        {
+            unitTarget->RemoveMovementImpairingAuras();
+            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
+            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STUN);
+
+            // Cast Lesser Invisibility
+            triggered_spell_id = 7870;
+            break;
+        }
+        // just skip
+        case 23770:                                         // Sayge's Dark Fortune of *
+            // not exist, common cooldown can be implemented in scripts if need.
+            return;
+        // Brittle Armor - (need add max stack of 24575 Brittle Armor)
+        case 29284:
+        {
+            // Brittle Armor
+            SpellEntry const* spell = sSpellStore.LookupEntry(24575);
+            if (!spell)
+                return;
+
+            for (uint32 j = 0; j < spell->StackAmount; ++j)
+                m_caster->CastSpell(unitTarget, spell->Id, true);
+            return;
+        }
+        // Mercurial Shield - (need add max stack of 26464 Mercurial Shield)
+        case 29286:
+        {
+            // Mercurial Shield
+            SpellEntry const* spell = sSpellStore.LookupEntry(26464);
+            if (!spell)
+                return;
+
+            for (uint32 j = 0; j < spell->StackAmount; ++j)
+                m_caster->CastSpell(unitTarget, spell->Id, true);
+            return;
+        }
+        // Righteous Defense
+        case 31980:
+        {
+            m_caster->CastSpell(unitTarget, 31790, true);
+            return;
+        }
+        // Cloak of Shadows
+        case 35729:
+        {
+            uint32 dispelMask = GetDispellMask(DISPEL_ALL);
+            Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::iterator iter = Auras.begin(); iter != Auras.end();)
+            {
+                // remove all harmful spells on you...
+                SpellEntry const* spell = iter->second->GetBase()->GetSpellProto();
+                if ((spell->DmgClass == SPELL_DAMAGE_CLASS_MAGIC // only affect magic spells
+                    || ((1<<spell->Dispel) & dispelMask))
+                    // ignore positive and passive auras
+                    && !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive() && !iter->second->GetBase()->IsDeathPersistent())
+                {
+                    m_caster->RemoveAura(iter);
+                }
+                else
+                    iter++;
+            }
+            return;
+        }
+        // Priest Shadowfiend (34433) need apply mana gain trigger aura on pet
+        case 41967:
+        {
+            if (Unit *pet = unitTarget->GetGuardianPet())
+                pet->CastSpell(pet, 28305, true);
+            return;
+        }
+        // Empower Rune Weapon
+        case 53258:
+            return; // skip, hack-added in spell effect
+        // Snake Trap
+        case 57879:
+            originalCaster = m_originalCaster;
+            break;
+        // Coldflame
+        case 33801:
+            return; // just make the core stfu
+    }
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerSpell of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
+    // Needed by freezing arrow and few other spells
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
+        && m_spellInfo->Category == spellInfo->Category)
+        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
+
+    // Note: not exist spells with weapon req. and IsSpellHaveCasterSourceTargets == true
+    // so this just for speedup places in else
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastSpell(unitTarget,spellInfo,true, 0, 0, (originalCaster ? originalCaster->GetGUID() : 0));
+}
+
+void Spell::EffectTriggerMissileSpell(SpellEffIndex effIndex)
+{
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerMissileSpell of spell %u (eff: %u): triggering unknown spell id %u",
+            m_spellInfo->Id,effIndex,triggered_spell_id);
+        return;
+    }
+
+    if (m_CastItem)
+        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
+
+    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
+    // Needed by freezing arrow and few other spells
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
+        && m_spellInfo->Category == spellInfo->Category)
+        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
+
+    float x, y, z;
+    m_targets.m_dstPos.GetPosition(x, y, z);
+    m_caster->CastSpell(x, y, z, spellInfo->Id, true, m_CastItem, 0, m_originalCasterGUID);
+}
+
+void Spell::EffectJump(SpellEffIndex effIndex)
+{
+    if (m_caster->isInFlight())
+        return;
+
+    float x,y,z,o;
+    if (m_targets.getUnitTarget())
+    {
+        m_targets.getUnitTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
+        o = m_caster->GetOrientation();
+    }
+    else if (m_targets.getGOTarget())
+    {
+        m_targets.getGOTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
+        o = m_caster->GetOrientation();
+    }
+    else
+    {
+        sLog.outError("Spell::EffectJump - unsupported target mode for spell ID %u", m_spellInfo->Id);
+        return;
+    }
+
+    float speedXY, speedZ;
+    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
+    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+}
+
+void Spell::EffectJumpDest(SpellEffIndex effIndex)
+{
+    if (m_caster->isInFlight())
+        return;
+
+    // Init dest coordinates
+    float x,y,z,o;
+    if (m_targets.HasDst())
+    {
+        m_targets.m_dstPos.GetPosition(x, y, z);
+
+        if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DEST_TARGET_BACK)
+        {
+            // explicit cast data from client or server-side cast
+            // some spell at client send caster
+            Unit* pTarget = NULL;
+            if (m_targets.getUnitTarget() && m_targets.getUnitTarget() != m_caster)
+                pTarget = m_targets.getUnitTarget();
+            else if (m_caster->getVictim())
+                pTarget = m_caster->getVictim();
+            else if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                pTarget = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
+
+            o = pTarget ? pTarget->GetOrientation() : m_caster->GetOrientation();
+        }
+        else
+            o = m_caster->GetOrientation();
+    }
+    else
+    {
+        sLog.outError("Spell::EffectJumpDest - unsupported target mode for spell ID %u", m_spellInfo->Id);
+        return;
+    }
+
+    float speedXY, speedZ;
+    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
+    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+}
+
+void Spell::CalculateJumpSpeeds(uint8 i, float dist, float & speedXY, float & speedZ)
+{
+    if (m_spellInfo->EffectMiscValue[i])
+        speedZ = float(m_spellInfo->EffectMiscValue[i])/10;
+    else if (m_spellInfo->EffectMiscValueB[i])
+        speedZ = float(m_spellInfo->EffectMiscValueB[i])/10;
+    else
+        speedZ = 10.0f;
+    speedXY = dist * 10.0f / speedZ;
+}
+
+void Spell::EffectTeleportUnits(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->isInFlight())
+        return;
+
+    // Pre effects
+    uint8 uiMaxSafeLevel = 0;
+    switch (m_spellInfo->Id)
+    {
+        case 66550:
+            return;
+        case 48129:  // Scroll of Recall
+            uiMaxSafeLevel = 40;
+        case 60320:  // Scroll of Recall II
+            if (!uiMaxSafeLevel)
+                uiMaxSafeLevel = 70;
+        case 60321:  // Scroll of Recal III
+            if (!uiMaxSafeLevel)
+                uiMaxSafeLevel = 80;
+
+            if (unitTarget->getLevel() > uiMaxSafeLevel)
+            {
+                unitTarget->AddAura(60444,unitTarget); //Apply Lost! Aura
+                return;
+            }
+            break;
+    }
+
+    // If not exist data for dest location - return
+    if (!m_targets.HasDst())
+    {
+        sLog.outError("Spell::EffectTeleportUnits - does not have destination for spell ID %u\n", m_spellInfo->Id);
+        return;
+    }
+
+    // Init dest coordinates
+    uint32 mapid = m_targets.m_dstPos.GetMapId();
+    if (mapid == MAPID_INVALID)
+        mapid = unitTarget->GetMapId();
+    float x, y, z, orientation;
+    m_targets.m_dstPos.GetPosition(x, y, z, orientation);
+    if (!orientation && m_targets.getUnitTarget())
+        orientation = m_targets.getUnitTarget()->GetOrientation();
+    sLog.outDebug("Spell::EffectTeleportUnits - teleport unit to %u %f %f %f %f\n", mapid, x, y, z, orientation);
+
+    if (mapid == unitTarget->GetMapId())
+        unitTarget->NearTeleportTo(x, y, z, orientation, unitTarget == m_caster);
+    else if (unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->TeleportTo(mapid, x, y, z, orientation, unitTarget == m_caster ? TELE_TO_SPELL : 0);
+
+    // post effects for TARGET_DST_DB
+    switch (m_spellInfo->Id)
+    {
+        // Dimensional Ripper - Everlook
+        case 23442:
+        {
+            int32 r = irand(0, 119);
+            if (r >= 70)                                  // 7/12 success
+            {
+                if (r < 100)                              // 4/12 evil twin
+                    m_caster->CastSpell(m_caster, 23445, true);
+                else                                        // 1/12 fire
+                    m_caster->CastSpell(m_caster, 23449, true);
+            }
+            return;
+        }
+        // Ultrasafe Transporter: Toshley's Station
+        case 36941:
+        {
+            if (roll_chance_i(50))                        // 50% success
+            {
+                int32 rand_eff = urand(1, 7);
+                switch (rand_eff)
+                {
+                    case 1:
+                        // soul split - evil
+                        m_caster->CastSpell(m_caster, 36900, true);
+                        break;
+                    case 2:
+                        // soul split - good
+                        m_caster->CastSpell(m_caster, 36901, true);
+                        break;
+                    case 3:
+                        // Increase the size
+                        m_caster->CastSpell(m_caster, 36895, true);
+                        break;
+                    case 4:
+                        // Decrease the size
+                        m_caster->CastSpell(m_caster, 36893, true);
+                        break;
+                    case 5:
+                    // Transform
+                    {
+                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                            m_caster->CastSpell(m_caster, 36897, true);
+                        else
+                            m_caster->CastSpell(m_caster, 36899, true);
+                        break;
+                    }
+                    case 6:
+                        // chicken
+                        m_caster->CastSpell(m_caster, 36940, true);
+                        break;
+                    case 7:
+                        // evil twin
+                        m_caster->CastSpell(m_caster, 23445, true);
+                        break;
+                }
+            }
+            return;
+        }
+        // Dimensional Ripper - Area 52
+        case 36890:
+        {
+            if (roll_chance_i(50))                        // 50% success
+            {
+                int32 rand_eff = urand(1, 4);
+                switch (rand_eff)
+                {
+                    case 1:
+                        // soul split - evil
+                        m_caster->CastSpell(m_caster, 36900, true);
+                        break;
+                    case 2:
+                        // soul split - good
+                        m_caster->CastSpell(m_caster, 36901, true);
+                        break;
+                    case 3:
+                        // Increase the size
+                        m_caster->CastSpell(m_caster, 36895, true);
+                        break;
+                    case 4:
+                        // Transform
+                    {
+                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                            m_caster->CastSpell(m_caster, 36897, true);
+                        else
+                            m_caster->CastSpell(m_caster, 36899, true);
+                        break;
+                    }
+                }
+            }
+            return;
+        }
+    }
+}
+
+void Spell::EffectApplyAura(SpellEffIndex effIndex)
+{
+    if (!m_spellAura || !unitTarget)
+        return;
+    ASSERT(unitTarget == m_spellAura->GetOwner());
+    m_spellAura->_ApplyEffectForTargets(effIndex);
+}
+
+void Spell::EffectApplyAreaAura(SpellEffIndex effIndex)
+{
+    if (!m_spellAura || !unitTarget)
+        return;
+    ASSERT (unitTarget == m_spellAura->GetOwner());
+    m_spellAura->_ApplyEffectForTargets(effIndex);
+}
+
+void Spell::EffectUnlearnSpecialization(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)unitTarget;
+    uint32 spellToUnlearn = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    _player->removeSpell(spellToUnlearn);
+
+    sLog.outDebug("Spell: Player %u has unlearned spell %u from NpcGUID: %u", _player->GetGUIDLow(), spellToUnlearn, m_caster->GetGUIDLow());
+}
+
+void Spell::EffectPowerDrain(SpellEffIndex effIndex)
+{
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
+        return;
+
+    // add spell damage bonus
+    damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, uint32(damage), SPELL_DIRECT_DAMAGE);
+
+    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
+    int32 power = damage;
+    if (powerType == POWER_MANA)
+        power -= unitTarget->GetSpellCritDamageReduction(power);
+
+    int32 newDamage = -(unitTarget->ModifyPower(powerType, -int32(power)));
+
+    float gainMultiplier = 0.0f;
+
+    // Don`t restore from self drain
+    if (m_caster != unitTarget)
+    {
+        gainMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
+
+        int32 gain = int32(newDamage * gainMultiplier);
+
+        m_caster->EnergizeBySpell(m_caster, m_spellInfo->Id, gain, powerType);
+    }
+    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, gainMultiplier);
+}
+
+void Spell::EffectSendEvent(SpellEffIndex effIndex)
+{
+    /*
+    we do not handle a flag dropping or clicking on flag in battleground by sendevent system
+    */
+    sLog.outDebug("Spell ScriptStart %u for spellid %u in EffectSendEvent ", m_spellInfo->EffectMiscValue[effIndex], m_spellInfo->Id);
+
+    Object *pTarget;
+    if (focusObject)
+        pTarget = focusObject;
+    else if (unitTarget)
+        pTarget = unitTarget;
+    else if (gameObjTarget)
+        pTarget = gameObjTarget;
+    else
+        pTarget = NULL;
+
+    m_caster->GetMap()->ScriptsStart(sEventScripts, m_spellInfo->EffectMiscValue[effIndex], m_caster, pTarget);
+}
+
+void Spell::EffectPowerBurn(SpellEffIndex effIndex)
+{
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
+        return;
+
+    // burn x% of target's mana, up to maximum of 2x% of caster's mana (Mana Burn)
+    if (m_spellInfo->ManaCostPercentage)
+    {
+        int32 maxDamage = m_caster->GetMaxPower(powerType) * damage * 2 / 100;
+        damage = unitTarget->GetMaxPower(powerType) * damage / 100;
+        damage = std::min(damage, maxDamage);
+    }
+
+    int32 power = damage;
+    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
+    if (powerType == POWER_MANA)
+        power -= unitTarget->GetSpellCritDamageReduction(power);
+
+    int32 newDamage = -(unitTarget->ModifyPower(powerType, -power));
+
+    // NO - Not a typo - EffectPowerBurn uses effect value multiplier - not effect damage multiplier
+    float dmgMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
+
+    // add log data before multiplication (need power amount, not damage)
+    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, 0.0f);
+
+    newDamage = int32(newDamage * dmgMultiplier);
+
+    m_damage += newDamage;
+}
+
+void Spell::EffectHeal(SpellEffIndex /*effIndex*/)
+{
+}
+
+void Spell::SpellDamageHeal(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->isAlive() && damage >= 0)
+    {
+        // Try to get original caster
+        Unit *caster = m_originalCasterGUID ? m_originalCaster : m_caster;
+
+        // Skip if m_originalCaster not available
+        if (!caster)
+            return;
+
+        int32 addhealth = damage;
+
+        // Vessel of the Naaru (Vial of the Sunwell trinket)
+        if (m_spellInfo->Id == 45064)
+        {
+            // Amount of heal - depends from stacked Holy Energy
+            int damageAmount = 0;
+            if (AuraEffect const * aurEff = m_caster->GetAuraEffect(45062, 0))
+            {
+                damageAmount+= aurEff->GetAmount();
+                m_caster->RemoveAurasDueToSpell(45062);
+            }
+
+            addhealth += damageAmount;
+        }
+        else if (m_spellInfo->Id == 67489 || m_spellInfo->Id == 67489)
+        {
+            if (m_caster->ToPlayer() != NULL && m_caster->ToPlayer()->HasSkill(SKILL_ENGINERING))
+                addhealth *= 1.25;
+        }
+        // Swiftmend - consumes Regrowth or Rejuvenation
+        else if (m_spellInfo->TargetAuraState == AURA_STATE_SWIFTMEND && unitTarget->HasAuraState(AURA_STATE_SWIFTMEND, m_spellInfo, m_caster))
+        {
+            Unit::AuraEffectList const& RejorRegr = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+            // find most short by duration
+            AuraEffect *targetAura = NULL;
+            for (Unit::AuraEffectList::const_iterator i = RejorRegr.begin(); i != RejorRegr.end(); ++i)
+            {
+                if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID
+                    && (*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x50)
+                {
+                    if (!targetAura || (*i)->GetBase()->GetDuration() < targetAura->GetBase()->GetDuration())
+                        targetAura = *i;
+                }
+            }
+
+            if (!targetAura)
+            {
+                sLog.outError("Target(GUID:" UI64FMTD ") has aurastate AURA_STATE_SWIFTMEND but no matching aura.", unitTarget->GetGUID());
+                return;
+            }
+
+            int32 tickheal = targetAura->GetAmount();
+            if (Unit* auraCaster = targetAura->GetCaster())
+                tickheal = auraCaster->SpellHealingBonus(unitTarget, targetAura->GetSpellProto(), tickheal, DOT);
+            //int32 tickheal = targetAura->GetSpellProto()->EffectBasePoints[idx] + 1;
+            //It is said that talent bonus should not be included
+
+            int32 tickcount = 0;
+            // Rejuvenation
+            if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x10)
+                tickcount = 4;
+            // Regrowth
+            else // if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x40)
+                tickcount = 6;
+
+            addhealth += tickheal * tickcount;
+
+            // Glyph of Swiftmend
+            if (!caster->HasAura(54824))
+                unitTarget->RemoveAura(targetAura->GetId(), targetAura->GetCasterGUID());
+
+            //addhealth += tickheal * tickcount;
+            //addhealth = caster->SpellHealingBonus(m_spellInfo, addhealth,HEAL, unitTarget);
+        }
+        // Glyph of Nourish
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x2000000)
+        {
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
+
+            if (AuraEffect const* aurEff = m_caster->GetAuraEffect(62971, 0))
+            {
+                Unit::AuraEffectList const& Periodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+                for (Unit::AuraEffectList::const_iterator i = Periodic.begin(); i != Periodic.end(); ++i)
+                {
+                    if (m_caster->GetGUID() == (*i)->GetCasterGUID())
+                        addhealth += addhealth * aurEff->GetAmount() / 100;
+                }
+            }
+        }
+        // Lifebloom - final heal coef multiplied by original DoT stack
+        else if (m_spellInfo->Id == 33778)
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL, m_spellValue->EffectBasePoints[1]);
+        // Riptide - increase healing done by Chain Heal
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x100)
+        {
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
+            if (AuraEffect * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0, 0, 0x10, m_originalCasterGUID))
+            {
+                addhealth = int32(addhealth * 1.25f);
+                // consume aura
+                unitTarget->RemoveAura(aurEff->GetBase());
+            }
+            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+            {
+                if (unitTarget->GetGUID() != ihit->targetGUID)
+                    addhealth = addhealth * 0.4;
+                else
+                    break;
+            }
+        }
+        // Death Pact - return pct of max health to caster
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, int32(caster->CountPctFromMaxHealth(damage)), HEAL);
+        else
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
+
+        // Remove Grievious bite if fully healed
+        if (unitTarget->HasAura(48920) && (unitTarget->GetHealth() + addhealth >= unitTarget->GetMaxHealth()))
+            unitTarget->RemoveAura(48920);
+
+        m_damage -= addhealth;
+    }
+}
+
+void Spell::EffectHealPct(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
+        return;
+
+    // Skip if m_originalCaster not available
+    if (!m_originalCaster)
+        return;
+
+    // Rune Tap - Party
+    if (m_spellInfo->Id == 59754 && unitTarget == m_caster)
+        return;
+
+    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, unitTarget->CountPctFromMaxHealth(damage), HEAL);
+}
+
+void Spell::EffectHealMechanical(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
+        return;
+
+    // Skip if m_originalCaster not available
+    if (!m_originalCaster)
+        return;
+
+    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, uint32(damage), HEAL);
+}
+
+void Spell::EffectHealthLeech(SpellEffIndex effIndex)
+{
+    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
+        return;
+
+    sLog.outDebug("HealthLeech :%i", damage);
+
+    float healMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
+
+    m_damage += damage;
+    // get max possible damage, don't count overkill for heal
+    uint32 healthGain = uint32(-unitTarget->GetHealthGain(-damage) * healMultiplier);
+
+    if (m_caster->isAlive())
+    {
+        healthGain = m_caster->SpellHealingBonus(m_caster, m_spellInfo, healthGain, HEAL);
+        m_caster->HealBySpell(m_caster, m_spellInfo, uint32(healthGain));
+    }
+}
+
+void Spell::DoCreateItem(uint32 /*i*/, uint32 itemtype)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* player = (Player*)unitTarget;
+
+    uint32 newitemid = itemtype;
+    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(newitemid);
+    if (!pProto)
+    {
+        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+        return;
+    }
+
+    // bg reward have some special in code work
+    uint32 bgType = 0;
+    switch(m_spellInfo->Id)
+    {
+        case SPELL_AV_MARK_WINNER:
+        case SPELL_AV_MARK_LOSER:
+            bgType = BATTLEGROUND_AV;
+            break;
+        case SPELL_WS_MARK_WINNER:
+        case SPELL_WS_MARK_LOSER:
+            bgType = BATTLEGROUND_WS;
+            break;
+        case SPELL_AB_MARK_WINNER:
+        case SPELL_AB_MARK_LOSER:
+            bgType = BATTLEGROUND_AB;
+            break;
+        default:
+            break;
+    }
+
+    uint32 num_to_add = damage;
+
+    if (num_to_add < 1)
+        num_to_add = 1;
+    if (num_to_add > pProto->GetMaxStackSize())
+        num_to_add = pProto->GetMaxStackSize();
+
+    // init items_count to 1, since 1 item will be created regardless of specialization
+    int items_count=1;
+    // the chance to create additional items
+    float additionalCreateChance=0.0f;
+    // the maximum number of created additional items
+    uint8 additionalMaxNum=0;
+    // get the chance and maximum number for creating extra items
+    if (canCreateExtraItems(player, m_spellInfo->Id, additionalCreateChance, additionalMaxNum))
+    {
+        // roll with this chance till we roll not to create or we create the max num
+        while (roll_chance_f(additionalCreateChance) && items_count <= additionalMaxNum)
+            ++items_count;
+    }
+
+    // really will be created more items
+    num_to_add *= items_count;
+
+    // can the player store the new item?
+    ItemPosCountVec dest;
+    uint32 no_space = 0;
+    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, num_to_add, &no_space);
+    if (msg != EQUIP_ERR_OK)
+    {
+        // convert to possible store amount
+        if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+            num_to_add -= no_space;
+        else
+        {
+            // if not created by another reason from full inventory or unique items amount limitation
+            player->SendEquipError(msg, NULL, NULL, newitemid);
+            return;
+        }
+    }
+
+    if (num_to_add)
+    {
+        // create the new item and store it
+        Item* pItem = player->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+
+        // was it successful? return error if not
+        if (!pItem)
+        {
+            player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+            return;
+        }
+
+        // set the "Crafted by ..." property of the item
+        if (pItem->GetProto()->Class != ITEM_CLASS_CONSUMABLE && pItem->GetProto()->Class != ITEM_CLASS_QUEST && newitemid != 6265 && newitemid != 6948)
+            pItem->SetUInt32Value(ITEM_FIELD_CREATOR, player->GetGUIDLow());
+
+        // send info to the client
+        if (pItem)
+            player->SendNewItem(pItem, num_to_add, true, bgType == 0);
+
+        // we succeeded in creating at least one item, so a levelup is possible
+        if (bgType == 0)
+            player->UpdateCraftSkill(m_spellInfo->Id);
+    }
+
+/*
+    // for battleground marks send by mail if not add all expected
+    if (no_space > 0 && bgType)
+    {
+        if (Battleground* bg = sBattlegroundMgr.GetBattlegroundTemplate(BattlegroundTypeId(bgType)))
+            bg->SendRewardMarkByMail(player, newitemid, no_space);
+    }
+*/
+}
+
+void Spell::EffectCreateItem(SpellEffIndex effIndex)
+{
+    DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
+    ExecuteLogEffectCreateItem(effIndex, m_spellInfo->EffectItemType[effIndex]);
+}
+
+void Spell::EffectCreateItem2(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player* player = (Player*)m_caster;
+
+    uint32 item_id = m_spellInfo->EffectItemType[effIndex];
+
+    if (item_id)
+        DoCreateItem(effIndex, item_id);
+
+    // special case: fake item replaced by generate using spell_loot_template
+    if (IsLootCraftingSpell(m_spellInfo))
+    {
+        if (item_id)
+        {
+            if (!player->HasItemCount(item_id, 1))
+                return;
+
+            // remove reagent
+            uint32 count = 1;
+            player->DestroyItemCount(item_id, count, true);
+
+            // create some random items
+            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
+        }
+        else
+            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);    // create some random items
+    }
+    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
+}
+
+void Spell::EffectCreateRandomItem(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player* player = (Player*)m_caster;
+
+    // create some random items
+    player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
+    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
+}
+
+void Spell::EffectPersistentAA(SpellEffIndex effIndex)
+{
+    if (!m_spellAura)
+    {
+        float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+        if (Player* modOwner = m_originalCaster->GetSpellModOwner())
+            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, radius);
+
+        Unit *caster = m_caster->GetEntry() == WORLD_TRIGGER ? m_originalCaster : m_caster;
+        // Caster not in world, might be spell triggered from aura removal
+        if (!caster->IsInWorld())
+            return;
+        DynamicObject* dynObj = new DynamicObject;
+        if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), caster, m_spellInfo->Id, m_targets.m_dstPos, radius, false))
+        {
+            delete dynObj;
+            return;
+        }
+        caster->AddDynObject(dynObj);
+        dynObj->GetMap()->Add(dynObj);
+
+        if (Aura * aura = Aura::TryCreate(m_spellInfo, dynObj, caster, &m_spellValue->EffectBasePoints[0]))
+            m_spellAura = aura;
+        else
+        {
+            ASSERT(false);
+            return;
+        }
+        m_spellAura->_RegisterForTargets();
+    }
+    ASSERT(m_spellAura->GetDynobjOwner());
+    m_spellAura->_ApplyEffectForTargets(effIndex);
+}
+
+void Spell::EffectEnergize(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (!unitTarget->isAlive())
+        return;
+
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    // Some level depends spells
+    int level_multiplier = 0;
+    int level_diff = 0;
+    switch (m_spellInfo->Id)
+    {
+        case 9512:                                          // Restore Energy
+            level_diff = m_caster->getLevel() - 40;
+            level_multiplier = 2;
+            break;
+        case 24571:                                         // Blood Fury
+            level_diff = m_caster->getLevel() - 60;
+            level_multiplier = 10;
+            break;
+        case 24532:                                         // Burst of Energy
+            level_diff = m_caster->getLevel() - 60;
+            level_multiplier = 4;
+            break;
+        case 31930:                                         // Judgements of the Wise
+        case 63375:                                         // Improved Stormstrike
+        case 68082:                                         // Glyph of Seal of Command
+            damage = damage * unitTarget->GetCreateMana() / 100;
+            break;
+        case 48542:                                         // Revitalize
+            damage = damage * unitTarget->GetMaxPower(power) / 100;
+            break;
+        case 67490:
+        case 67487:
+            if (m_caster->ToPlayer() != NULL && m_caster->ToPlayer()->HasSkill(SKILL_ENGINERING))
+                damage *= 1.25;
+            break;
+        default:
+            break;
+    }
+
+    if (level_diff > 0)
+        damage -= level_multiplier * level_diff;
+
+    if (damage < 0)
+        return;
+
+    if (unitTarget->GetMaxPower(power) == 0)
+        return;
+
+    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, damage, power);
+
+    // Mad Alchemist's Potion
+    if (m_spellInfo->Id == 45051)
+    {
+        // find elixirs on target
+        bool guardianFound = false;
+        bool battleFound = false;
+        Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
+        for (Unit::AuraApplicationMap::iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+        {
+            uint32 spell_id = itr->second->GetBase()->GetId();
+            if (!guardianFound)
+                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_GUARDIAN))
+                    guardianFound = true;
+            if (!battleFound)
+                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_BATTLE))
+                    battleFound = true;
+            if (battleFound && guardianFound)
+                break;
+        }
+
+        // get all available elixirs by mask and spell level
+        std::set<uint32> avalibleElixirs;
+        if (!guardianFound)
+            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_GUARDIAN, avalibleElixirs);
+        if (!battleFound)
+            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_BATTLE, avalibleElixirs);
+        for (std::set<uint32>::iterator itr = avalibleElixirs.begin(); itr != avalibleElixirs.end() ;)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(*itr);
+            if (spellInfo->spellLevel < m_spellInfo->spellLevel || spellInfo->spellLevel > unitTarget->getLevel())
+                avalibleElixirs.erase(itr++);
+            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_SHATTRATH))
+                avalibleElixirs.erase(itr++);
+            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_UNSTABLE))
+                avalibleElixirs.erase(itr++);
+            else
+                ++itr;
+        }
+
+        if (!avalibleElixirs.empty())
+        {
+            // cast random elixir on target
+            uint32 rand_spell = urand(0,avalibleElixirs.size()-1);
+            std::set<uint32>::iterator itr = avalibleElixirs.begin();
+            std::advance(itr, rand_spell);
+            m_caster->CastSpell(unitTarget,*itr,true,m_CastItem);
+        }
+    }
+}
+
+void Spell::EffectEnergizePct(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (!unitTarget->isAlive())
+        return;
+
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    uint32 maxPower = unitTarget->GetMaxPower(power);
+    if (maxPower == 0)
+        return;
+
+    uint32 gain = damage * maxPower / 100;
+    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, gain, power);
+}
+
+void Spell::SendLoot(uint64 guid, LootType loottype)
+{
+    Player* player = (Player*)m_caster;
+    if (!player)
+        return;
+
+    if (gameObjTarget)
+    {
+        if (sScriptMgr.OnGossipHello(player, gameObjTarget))
+            return;
+
+		gameObjTarget->AI()->GossipHello(player);
+
+        switch (gameObjTarget->GetGoType())
+        {
+            case GAMEOBJECT_TYPE_DOOR:
+            case GAMEOBJECT_TYPE_BUTTON:
+                gameObjTarget->UseDoorOrButton();
+                player->GetMap()->ScriptsStart(sGameObjectScripts, gameObjTarget->GetDBTableGUIDLow(), player, gameObjTarget);
+                return;
+
+            case GAMEOBJECT_TYPE_QUESTGIVER:
+                // start or end quest
+                player->PrepareQuestMenu(guid);
+                player->SendPreparedQuest(guid);
+                return;
+
+            case GAMEOBJECT_TYPE_SPELL_FOCUS:
+                // triggering linked GO
+                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->spellFocus.linkedTrapId)
+                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
+                return;
+
+            case GAMEOBJECT_TYPE_GOOBER:
+                gameObjTarget->Use(m_caster);
+                return;
+
+            case GAMEOBJECT_TYPE_CHEST:
+                // TODO: possible must be moved to loot release (in different from linked triggering)
+                if (gameObjTarget->GetGOInfo()->chest.eventId)
+                {
+                    sLog.outDebug("Chest ScriptStart id %u for GO %u", gameObjTarget->GetGOInfo()->chest.eventId,gameObjTarget->GetDBTableGUIDLow());
+                    player->GetMap()->ScriptsStart(sEventScripts, gameObjTarget->GetGOInfo()->chest.eventId, player, gameObjTarget);
+                }
+
+                // triggering linked GO
+                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->chest.linkedTrapId)
+                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
+
+                // Don't return, let loots been taken
+            default:
+                break;
+        }
+    }
+
+    // Send loot
+    player->SendLoot(guid, loottype);
+}
+
+void Spell::EffectOpenLock(SpellEffIndex effIndex)
+{
+    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
+    {
+        sLog.outDebug("WORLD: Open Lock - No Player Caster!");
+        return;
+    }
+
+    Player* player = (Player*)m_caster;
+
+    uint32 lockId = 0;
+    uint64 guid = 0;
+
+    // Get lockId
+    if (gameObjTarget)
+    {
+        GameObjectInfo const* goInfo = gameObjTarget->GetGOInfo();
+        // Arathi Basin banner opening !
+        if ((goInfo->type == GAMEOBJECT_TYPE_BUTTON && goInfo->button.noDamageImmune) ||
+            (goInfo->type == GAMEOBJECT_TYPE_GOOBER && goInfo->goober.losOK))
+        {
+            //CanUseBattlegroundObject() already called in CheckCast()
+            // in battleground check
+            if (Battleground *bg = player->GetBattleground())
+          {
+        bg->EventPlayerClickedOnFlag(player, gameObjTarget);
+        return;
+          }
+        }
+        else if (goInfo->type == GAMEOBJECT_TYPE_FLAGSTAND)
+        {
+            //CanUseBattlegroundObject() already called in CheckCast()
+            // in battleground check
+            if (Battleground *bg = player->GetBattleground())
+            {
+                if (bg->GetTypeID(true) == BATTLEGROUND_EY)
+                    bg->EventPlayerClickedOnFlag(player, gameObjTarget);
+                return;
+            }
+        }else if (m_spellInfo->Id == 1842 && gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_TRAP && gameObjTarget->GetOwner())
+        {
+            gameObjTarget->SetLootState(GO_JUST_DEACTIVATED);
+            return;
+        }
+        // TODO: Add script for spell 41920 - Filling, becouse server it freze when use this spell
+        // handle outdoor pvp object opening, return true if go was registered for handling
+        // these objects must have been spawned by outdoorpvp!
+        else if (gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
+            return;
+        lockId = goInfo->GetLockId();
+        guid = gameObjTarget->GetGUID();
+    }
+    else if (itemTarget)
+    {
+        lockId = itemTarget->GetProto()->LockID;
+        guid = itemTarget->GetGUID();
+    }
+    else
+    {
+        sLog.outDebug("WORLD: Open Lock - No GameObject/Item Target!");
+        return;
+    }
+
+    SkillType skillId = SKILL_NONE;
+    int32 reqSkillValue = 0;
+    int32 skillValue;
+
+    SpellCastResult res = CanOpenLock(effIndex, lockId, skillId, reqSkillValue, skillValue);
+    if (res != SPELL_CAST_OK)
+    {
+        SendCastResult(res);
+        return;
+    }
+
+    if (gameObjTarget)
+        SendLoot(guid, LOOT_SKINNING);
+    else
+        itemTarget->SetFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_UNLOCKED);
+
+    // not allow use skill grow at item base open
+    if (!m_CastItem && skillId != SKILL_NONE)
+    {
+        // update skill if really known
+        if (uint32 pureSkillValue = player->GetPureSkillValue(skillId))
+        {
+            if (gameObjTarget)
+            {
+                // Allow one skill-up until respawned
+                if (!gameObjTarget->IsInSkillupList(player->GetGUIDLow()) &&
+                    player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue))
+                    gameObjTarget->AddToSkillupList(player->GetGUIDLow());
+            }
+            else if (itemTarget)
+            {
+                // Do one skill-up
+                player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue);
+            }
+        }
+    }
+    ExecuteLogEffectOpenLock(effIndex, gameObjTarget ? (Object*)gameObjTarget : (Object*)itemTarget);
+}
+
+void Spell::EffectSummonChangeItem(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *player = (Player*)m_caster;
+
+    // applied only to using item
+    if (!m_CastItem)
+        return;
+
+    // ... only to item in own inventory/bank/equip_slot
+    if (m_CastItem->GetOwnerGUID() != player->GetGUID())
+        return;
+
+    uint32 newitemid = m_spellInfo->EffectItemType[effIndex];
+    if (!newitemid)
+        return;
+
+    uint16 pos = m_CastItem->GetPos();
+
+    Item *pNewItem = Item::CreateItem(newitemid, 1, player);
+    if (!pNewItem)
+        return;
+
+    for (uint8 j = PERM_ENCHANTMENT_SLOT; j <= TEMP_ENCHANTMENT_SLOT; ++j)
+        if (m_CastItem->GetEnchantmentId(EnchantmentSlot(j)))
+            pNewItem->SetEnchantment(EnchantmentSlot(j), m_CastItem->GetEnchantmentId(EnchantmentSlot(j)), m_CastItem->GetEnchantmentDuration(EnchantmentSlot(j)), m_CastItem->GetEnchantmentCharges(EnchantmentSlot(j)));
+
+    if (m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) < m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY))
+    {
+        double loosePercent = 1 - m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) / double(m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY));
+        player->DurabilityLoss(pNewItem, loosePercent);
+    }
+
+    if (player->IsInventoryPos(pos))
+    {
+        ItemPosCountVec dest;
+        uint8 msg = player->CanStoreItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
+        if (msg == EQUIP_ERR_OK)
+        {
+            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
+
+            // prevent crash at access and unexpected charges counting with item update queue corrupt
+            if (m_CastItem == m_targets.getItemTarget())
+                m_targets.setItemTarget(NULL);
+
+            m_CastItem = NULL;
+
+            player->StoreItem(dest, pNewItem, true);
+            return;
+        }
+    }
+    else if (player->IsBankPos(pos))
+    {
+        ItemPosCountVec dest;
+        uint8 msg = player->CanBankItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
+        if (msg == EQUIP_ERR_OK)
+        {
+            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
+
+            // prevent crash at access and unexpected charges counting with item update queue corrupt
+            if (m_CastItem == m_targets.getItemTarget())
+                m_targets.setItemTarget(NULL);
+
+            m_CastItem = NULL;
+
+            player->BankItem(dest, pNewItem, true);
+            return;
+        }
+    }
+    else if (player->IsEquipmentPos(pos))
+    {
+        uint16 dest;
+
+        player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
+
+        uint8 msg = player->CanEquipItem(m_CastItem->GetSlot(), dest, pNewItem, true);
+
+        if (msg == EQUIP_ERR_OK || msg == EQUIP_ERR_CANT_DO_RIGHT_NOW)
+        {
+            if (msg == EQUIP_ERR_CANT_DO_RIGHT_NOW) dest = EQUIPMENT_SLOT_MAINHAND;
+
+            // prevent crash at access and unexpected charges counting with item update queue corrupt
+            if (m_CastItem == m_targets.getItemTarget())
+                m_targets.setItemTarget(NULL);
+
+            m_CastItem = NULL;
+
+            player->EquipItem(dest, pNewItem, true);
+            player->AutoUnequipOffhandIfNeed();
+            return;
+        }
+    }
+
+    // fail
+    delete pNewItem;
+}
+
+void Spell::EffectProficiency(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player *p_target = (Player*)unitTarget;
+
+    uint32 subClassMask = m_spellInfo->EquippedItemSubClassMask;
+    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON && !(p_target->GetWeaponProficiency() & subClassMask))
+    {
+        p_target->AddWeaponProficiency(subClassMask);
+        p_target->SendProficiency(ITEM_CLASS_WEAPON, p_target->GetWeaponProficiency());
+    }
+    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_ARMOR && !(p_target->GetArmorProficiency() & subClassMask))
+    {
+        p_target->AddArmorProficiency(subClassMask);
+        p_target->SendProficiency(ITEM_CLASS_ARMOR, p_target->GetArmorProficiency());
+    }
+}
+
+void Spell::EffectSummonType(SpellEffIndex effIndex)
+{
+    uint32 entry = m_spellInfo->EffectMiscValue[effIndex];
+    if (!entry)
+        return;
+
+    SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(m_spellInfo->EffectMiscValueB[effIndex]);
+    if (!properties)
+    {
+        sLog.outError("EffectSummonType: Unhandled summon type %u", m_spellInfo->EffectMiscValueB[effIndex]);
+        return;
+    }
+
+    if (!m_originalCaster)
+        return;
+
+    int32 duration = GetSpellDuration(m_spellInfo);
+    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
+        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
+
+    Position pos;
+    GetSummonPosition(effIndex, pos);
+
+    /*//totem must be at same Z in case swimming caster and etc.
+        if (fabs(z - m_caster->GetPositionZ()) > 5)
+            z = m_caster->GetPositionZ();
+
+    uint8 level = m_caster->getLevel();
+
+    // level of creature summoned using engineering item based at engineering skill level
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_CastItem)
+    {
+        ItemPrototype const *proto = m_CastItem->GetProto();
+        if (proto && proto->RequiredSkill == SKILL_ENGINERING)
+        {
+            uint16 skill202 = m_caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING);
+            if (skill202)
+                level = skill202/5;
+        }
+    }*/
+
+    TempSummon *summon = NULL;
+
+    switch (properties->Category)
+    {
+        default:
+            if (properties->Flags & 512)
+            {
+                SummonGuardian(effIndex, entry, properties);
+                break;
+            }
+            switch (properties->Type)
+            {
+                case SUMMON_TYPE_PET:
+                case SUMMON_TYPE_GUARDIAN:
+                case SUMMON_TYPE_GUARDIAN2:
+                case SUMMON_TYPE_MINION:
+                    SummonGuardian(effIndex, entry, properties);
+                    break;
+                case SUMMON_TYPE_VEHICLE:
+                case SUMMON_TYPE_VEHICLE2:
+                    if (m_originalCaster)
+                        summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+                    break;
+                case SUMMON_TYPE_TOTEM:
+                {
+                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+                    if (!summon || !summon->isTotem())
+                        return;
+
+                    // Mana Tide Totem
+                    if (summon->GetEntry() == 10467)
+                        if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                            damage = (m_caster->GetMaxHealth() * 0.10);
+
+                    if (damage)                                            // if not spell info, DB values used
+                    {
+                        summon->SetMaxHealth(damage);
+                        summon->SetHealth(damage);
+                    }
+
+                    //summon->SetUInt32Value(UNIT_CREATED_BY_SPELL,m_spellInfo->Id);
+
+                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER
+                        && properties->Slot >= SUMMON_SLOT_TOTEM
+                        && properties->Slot < MAX_TOTEM_SLOT)
+                    {
+                        // set display id depending on race
+                        uint32 displayId = m_originalCaster->GetModelForTotem(PlayerTotemType(properties->Id));
+                        summon->SetNativeDisplayId(displayId);
+                        summon->SetDisplayId(displayId);
+
+                        //summon->SendUpdateToPlayerm_originalCaster->ToPlayer();
+                        WorldPacket data(SMSG_TOTEM_CREATED, 1+8+4+4);
+                        data << uint8(properties->Slot-1);
+                        data << uint64(m_originalCaster->GetGUID());
+                        data << uint32(duration);
+                        data << uint32(m_spellInfo->Id);
+                        m_originalCaster->ToPlayer()->SendDirectMessage(&data);
+                    }
+                    break;
+                }
+                case SUMMON_TYPE_MINIPET:
+                {
+                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+                    if (!summon || !summon->HasUnitTypeMask(UNIT_MASK_MINION))
+                        return;
+
+                    //summon->InitPetCreateSpells();                         // e.g. disgusting oozeling has a create spell as summon...
+                    summon->SelectLevel(summon->GetCreatureInfo());       // some summoned creaters have different from 1 DB data for level/hp
+                    summon->SetUInt32Value(UNIT_NPC_FLAGS, summon->GetCreatureInfo()->npcflag);
+
+                    summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+                    summon->AI()->EnterEvadeMode();
+
+                    std::string name = m_originalCaster->GetName();
+                    name.append(petTypeSuffix[3]);
+                    summon->SetName(name);
+                    break;
+                }
+                default:
+                {
+                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+
+                    uint32 amount = damage > 0 ? damage : 1;
+                    if (m_spellInfo->Id == 18662) // Curse of Doom
+                        amount = 1;
+
+                    // Engineering dragonlings
+                    if (m_spellInfo->Id == 4073 ||
+                        m_spellInfo->Id == 12749 ||
+                        m_spellInfo->Id == 19804)
+                        amount = 1;
+
+                    for (uint32 count = 0; count < amount; ++count)
+                    {
+                        GetSummonPosition(effIndex, pos, radius, count);
+
+                        TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
+
+                        summon = m_originalCaster->SummonCreature(entry, pos, summonType, duration);
+                        if (!summon)
+                            continue;
+                        if (properties->Category == SUMMON_CATEGORY_ALLY)
+                        {
+                            summon->SetUInt64Value(UNIT_FIELD_SUMMONEDBY, m_originalCaster->GetGUID());
+                            summon->setFaction(m_originalCaster->getFaction());
+                            summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+                        }
+                        ExecuteLogEffectSummonObject(effIndex, summon);
+                    }
+                    return;
+                }
+            }//switch
+            break;
+        case SUMMON_CATEGORY_PET:
+            SummonGuardian(effIndex, entry, properties);
+            break;
+        case SUMMON_CATEGORY_PUPPET:
+            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+            break;
+        case SUMMON_CATEGORY_VEHICLE:
+        {
+            float x, y, z;
+            m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_caster);
+            if (!summon || !summon->IsVehicle())
+                return;
+
+            if (m_spellInfo->EffectBasePoints[effIndex])
+            {
+                SpellEntry const *spellProto = sSpellStore.LookupEntry(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
+                if (spellProto)
+                    m_caster->CastSpell(summon, spellProto, true);
+            }
+
+            m_caster->EnterVehicle(summon->GetVehicleKit());
+            break;
+        }
+    }
+
+    if (summon)
+    {
+        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+        summon->SetCreatorGUID(m_originalCaster->GetGUID());
+        ExecuteLogEffectSummonObject(effIndex, summon);
+    }
+}
+
+void Spell::EffectLearnSpell(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+    {
+        if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            EffectLearnPetSpell(effIndex);
+
+        return;
+    }
+
+    Player *player = (Player*)unitTarget;
+
+    uint32 spellToLearn = (m_spellInfo->Id == 483 || m_spellInfo->Id == 55884) ? damage : m_spellInfo->EffectTriggerSpell[effIndex];
+    player->learnSpell(spellToLearn, false);
+
+    sLog.outDebug("Spell: Player %u has learned spell %u from NpcGUID=%u", player->GetGUIDLow(), spellToLearn, m_caster->GetGUIDLow());
+}
+
+typedef std::list< std::pair<uint32, uint64> > DispelList;
+typedef std::list< std::pair<Aura *, uint8> > DispelChargesList;
+void Spell::EffectDispel(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    DispelChargesList dispel_list;
+
+    // Create dispel mask by dispel type
+    uint32 dispel_type = m_spellInfo->EffectMiscValue[effIndex];
+    uint32 dispelMask  = GetDispellMask(DispelType(dispel_type));
+
+    // we should not be able to dispel diseases if the target is affected by unholy blight
+    if (dispelMask & (1 << DISPEL_DISEASE) && unitTarget->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura * aura = itr->second;
+        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
+        {
+            if (aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+            {
+                bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR_EX_NEGATIVE)) : false;
+
+                // do not remove positive auras if friendly target
+                //               negative auras if non-friendly target
+                if (positive == unitTarget->IsFriendlyTo(m_caster))
+                    continue;
+            }
+
+            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
+            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
+            // Polymorph instead of 1 / (5 + 1) -> 16%.
+            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
+            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispel_list.push_back(std::make_pair(aura, charges));
+        }
+    }
+
+    if (dispel_list.empty())
+        return;
+
+    // Ok if exist some buffs for dispel try dispel it
+    uint32 failCount = 0;
+    DispelList success_list;
+    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
+    // dispel N = damage buffs (or while exist buffs for dispel)
+    for (int32 count = 0; count < damage && !dispel_list.empty();)
+    {
+        // Random select buff for dispel
+        DispelChargesList::iterator itr = dispel_list.begin();
+        std::advance(itr, urand(0, dispel_list.size() - 1));
+
+        bool success = false;
+        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
+        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
+        {
+            dispel_list.erase(itr);
+            continue;
+        }
+        else
+        {
+            if (success)
+            {
+                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
+                --itr->second;
+                if (itr->second <= 0)
+                    dispel_list.erase(itr);
+            }
+            else
+            {
+                if (!failCount)
+                {
+                    // Failed to dispell
+                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
+                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
+                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
+                }
+                ++failCount;
+                dataFail << uint32(itr->first->GetId());                         // Spell Id
+            }
+            ++count;
+        }
+    }
+
+    if (failCount)
+        m_caster->SendMessageToSet(&dataFail, true);
+
+    if (success_list.empty())
+        return;
+
+    WorldPacket dataSuccess(SMSG_SPELLDISPELLOG, 8+8+4+1+4+damage*5);
+    // Send packet header
+    dataSuccess.append(unitTarget->GetPackGUID());         // Victim GUID
+    dataSuccess.append(m_caster->GetPackGUID());           // Caster GUID
+    dataSuccess << uint32(m_spellInfo->Id);                // dispel spell id
+    dataSuccess << uint8(0);                               // not used
+    dataSuccess << uint32(success_list.size());            // count
+    for (DispelList::iterator itr = success_list.begin(); itr != success_list.end(); ++itr)
+    {
+        // Send dispelled spell info
+        dataSuccess << uint32(itr->first);              // Spell Id
+        dataSuccess << uint8(0);                        // 0 - dispelled !=0 cleansed
+        unitTarget->RemoveAurasDueToSpellByDispel(itr->first, itr->second, m_caster);
+    }
+    m_caster->SendMessageToSet(&dataSuccess, true);
+
+    // On success dispel
+    // Devour Magic
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->Category == SPELLCATEGORY_DEVOUR_MAGIC)
+    {
+        int32 heal_amount = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
+        m_caster->CastCustomSpell(m_caster, 19658, &heal_amount, NULL, NULL, true);
+    }
+}
+
+void Spell::EffectDualWield(SpellEffIndex /*effIndex*/)
+{
+    unitTarget->SetCanDualWield(true);
+    if (unitTarget->GetTypeId() == TYPEID_UNIT)
+        unitTarget->ToCreature()->UpdateDamagePhysical(OFF_ATTACK);
+}
+
+void Spell::EffectPull(SpellEffIndex /*effIndex*/)
+{
+    // TODO: create a proper pull towards distract spell center for distract
+    sLog.outDebug("WORLD: Spell Effect DUMMY");
+}
+
+void Spell::EffectDistract(SpellEffIndex /*effIndex*/)
+{
+    // Check for possible target
+    if (!unitTarget || unitTarget->isInCombat())
+        return;
+
+    // target must be OK to do this
+    if (unitTarget->hasUnitState(UNIT_STAT_CONFUSED | UNIT_STAT_STUNNED | UNIT_STAT_FLEEING))
+        return;
+
+    float angle = unitTarget->GetAngle(&m_targets.m_dstPos);
+
+    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
+    {
+        // For players just turn them
+        unitTarget->ToPlayer()->SetPosition(unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), angle, false);
+        unitTarget->ToPlayer()->SendTeleportAckPacket();
+    }
+    else
+    {
+        // Set creature Distracted, Stop it, And turn it
+        unitTarget->SetOrientation(angle);
+        unitTarget->StopMoving();
+        unitTarget->GetMotionMaster()->MoveDistract(damage * IN_MILLISECONDS);
+    }
+}
+
+void Spell::EffectPickPocket(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // victim must be creature and attackable
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT || m_caster->IsFriendlyTo(unitTarget))
+        return;
+
+    // victim have to be alive and humanoid or undead
+    if (unitTarget->isAlive() && (unitTarget->GetCreatureTypeMask() &CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0)
+        m_caster->ToPlayer()->SendLoot(unitTarget->GetGUID(),LOOT_PICKPOCKETING);
+}
+
+void Spell::EffectAddFarsight(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+    int32 duration = GetSpellDuration(m_spellInfo);
+    // Caster not in world, might be spell triggered from aura removal
+    if (!m_caster->IsInWorld())
+        return;
+    DynamicObject* dynObj = new DynamicObject;
+    if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), m_caster, m_spellInfo->Id, m_targets.m_dstPos, radius, true))
+    {
+        delete dynObj;
+        return;
+    }
+    dynObj->SetDuration(duration);
+    dynObj->SetUInt32Value(DYNAMICOBJECT_BYTES, 0x80000002);
+    m_caster->AddDynObject(dynObj);
+
+    dynObj->setActive(true);    //must before add to map to be put in world container
+    dynObj->GetMap()->Add(dynObj); //grid will also be loaded
+
+    // Need to update visibility of object for client to accept farsight guid
+    m_caster->ToPlayer()->SetViewpoint(dynObj, true);
+    //m_caster->ToPlayer()->UpdateVisibilityOf(dynObj);
+}
+
+void Spell::EffectTeleUnitsFaceCaster(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    if (unitTarget->isInFlight())
+        return;
+
+    float dis = (float)m_caster->GetSpellRadiusForTarget(unitTarget, sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+
+    float fx,fy,fz;
+    m_caster->GetClosePoint(fx,fy,fz,unitTarget->GetObjectSize(),dis);
+
+    unitTarget->NearTeleportTo(fx,fy,fz,-m_caster->GetOrientation(),unitTarget == m_caster);
+}
+
+void Spell::EffectLearnSkill(SpellEffIndex effIndex)
+{
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (damage < 0)
+        return;
+
+    uint32 skillid =  m_spellInfo->EffectMiscValue[effIndex];
+    uint16 skillval = unitTarget->ToPlayer()->GetPureSkillValue(skillid);
+    unitTarget->ToPlayer()->SetSkill(skillid, SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex), skillval?skillval:1, damage*75);
+}
+
+void Spell::EffectAddHonor(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // not scale value for item based reward (/10 value expected)
+    if (m_CastItem)
+    {
+        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage/10);
+        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %d honor points (item %u) for player: %u", m_spellInfo->Id, damage/10, m_CastItem->GetEntry(),unitTarget->ToPlayer()->GetGUIDLow());
+        return;
+    }
+
+    // do not allow to add too many honor for player (50 * 21) = 1040 at level 70, or (50 * 31) = 1550 at level 80
+    if (damage <= 50)
+    {
+        uint32 honor_reward = Trinity::Honor::hk_honor_at_level(unitTarget->getLevel(), damage);
+        unitTarget->ToPlayer()->RewardHonor(NULL, 1, honor_reward);
+        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (scale) to player: %u", m_spellInfo->Id, honor_reward, unitTarget->ToPlayer()->GetGUIDLow());
+    }
+    else
+    {
+        //maybe we have correct honor_gain in damage already
+        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage);
+        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (non scale) for player: %u", m_spellInfo->Id, damage, unitTarget->ToPlayer()->GetGUIDLow());
+    }
+}
+
+void Spell::EffectTradeSkill(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    // uint32 skillid =  m_spellInfo->EffectMiscValue[i];
+    // uint16 skillmax = unitTarget->ToPlayer()->(skillid);
+    // unitTarget->ToPlayer()->SetSkill(skillid,skillval?skillval:1,skillmax+75);
+}
+
+void Spell::EffectEnchantItemPerm(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!itemTarget)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+
+    // Handle vellums
+    if (itemTarget->IsWeaponVellum() || itemTarget->IsArmorVellum())
+    {
+        // destroy one vellum from stack
+        uint32 count = 1;
+        p_caster->DestroyItemCount(itemTarget,count,true);
+        unitTarget=p_caster;
+        // and add a scroll
+        DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
+        itemTarget=NULL;
+        m_targets.setItemTarget(NULL);
+    }
+    else
+    {
+        // do not increase skill if vellum used
+        if (!(m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST))
+            p_caster->UpdateCraftSkill(m_spellInfo->Id);
+
+        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+        if (!enchant_id)
+            return;
+
+        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            return;
+        
+        // item can be in trade slot and have owner diff. from caster
+        Player* item_owner = itemTarget->GetOwner();
+        if (!item_owner)
+            return;
+        
+        // Prevent applying enchanements with Use: spell on items that already have a Use: effect, this is usually blocked from client side and 
+        // can only be bypassed with memory manipulation.
+        for (int s = 0; s < 3; ++s) {
+            if (pEnchant->type[s] == ITEM_ENCHANTMENT_TYPE_USE_SPELL) {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i) {
+                    ItemPrototype const *proto = itemTarget->GetProto();
+                    if (proto->Spells[i].SpellId && proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE) {
+                        sLog.outError("Exploiting attempt: Player %s(GUID: %u) tried to apply an enchanement with Use: spell on an item that already has a Use: effect,"
+                                      " this should be blocked from client side.", p_caster->GetName(), p_caster->GetGUIDLow());
+                        return;
+                    }
+                }
+            }
+        }
+
+        if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
+        {
+            sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
+                p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
+                itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
+                item_owner->GetName(),item_owner->GetSession()->GetAccountId());
+        }
+
+        // remove old enchanting before applying new if equipped
+        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,false);
+
+        itemTarget->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchant_id, 0, 0);
+
+        // add new enchanting if equipped
+        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,true);
+
+        itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
+    }
+}
+
+void Spell::EffectEnchantItemPrismatic(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!itemTarget)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+
+    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    // support only enchantings with add socket in this slot
+    {
+        bool add_socket = false;
+        for (uint8 i = 0; i < MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+        {
+            if (pEnchant->type[i] == ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET)
+            {
+                add_socket = true;
+                break;
+            }
+        }
+        if (!add_socket)
+        {
+            sLog.outError("Spell::EffectEnchantItemPrismatic: attempt apply enchant spell %u with SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC (%u) but without ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET (%u), not suppoted yet.",
+                m_spellInfo->Id,SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC,ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET);
+            return;
+        }
+    }
+
+    // item can be in trade slot and have owner diff. from caster
+    Player* item_owner = itemTarget->GetOwner();
+    if (!item_owner)
+        return;
+
+    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
+    {
+        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
+            p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
+            itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
+            item_owner->GetName(),item_owner->GetSession()->GetAccountId());
+    }
+
+    // remove old enchanting before applying new if equipped
+    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,false);
+
+    itemTarget->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, enchant_id, 0, 0);
+
+    // add new enchanting if equipped
+    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,true);
+
+    itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
+}
+
+void Spell::EffectEnchantItemTmp(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+
+    // Rockbiter Weapon apply to both weapon
+    if (!itemTarget)
+    return;
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x400000)
+    {
+        uint32 spell_id = 0;
+
+        // enchanting spell selected by calculated damage-per-sec stored in Effect[1] base value
+        // Note: damage calculated (correctly) with rounding int32(float(v)) but
+        // RW enchantments applied damage int32(float(v)+0.5), this create  0..1 difference sometime
+        switch(damage)
+        {
+            // Rank 1
+            case  2: spell_id = 36744; break;               //  0% [ 7% == 2, 14% == 2, 20% == 2]
+            // Rank 2
+            case  4: spell_id = 36753; break;               //  0% [ 7% == 4, 14% == 4]
+            case  5: spell_id = 36751; break;               // 20%
+            // Rank 3
+            case  6: spell_id = 36754; break;               //  0% [ 7% == 6, 14% == 6]
+            case  7: spell_id = 36755; break;               // 20%
+            // Rank 4
+            case  9: spell_id = 36761; break;               //  0% [ 7% == 6]
+            case 10: spell_id = 36758; break;               // 14%
+            case 11: spell_id = 36760; break;               // 20%
+            default:
+                sLog.outError("Spell::EffectEnchantItemTmp: Damage %u not handled in S'RW",damage);
+                return;
+        }
+
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
+        if (!spellInfo)
+        {
+            sLog.outError("Spell::EffectEnchantItemTmp: unknown spell id %i", spell_id);
+            return;
+
+        }
+
+        for (int j = BASE_ATTACK; j <= OFF_ATTACK; ++j)
+        {
+            if (Item* item = p_caster->GetWeaponForAttack(WeaponAttackType(j)))
+            {
+                if (item->IsFitToSpellRequirements(m_spellInfo))
+                {
+                    Spell *spell = new Spell(m_caster, spellInfo, true);
+                    SpellCastTargets targets;
+                    targets.setItemTarget(item);
+                    spell->prepare(&targets);
+                }
+            }
+        }
+        return;
+    }
+    if (!itemTarget)
+        return;
+
+    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    if (!enchant_id)
+    {
+        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have 0 as enchanting id",m_spellInfo->Id,effIndex);
+        return;
+    }
+
+    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+    {
+        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have not existed enchanting id %u ",m_spellInfo->Id,effIndex,enchant_id);
+        return;
+    }
+
+    // select enchantment duration
+    uint32 duration;
+
+    // rogue family enchantments exception by duration
+    if (m_spellInfo->Id == 38615)
+        duration = 1800;                                    // 30 mins
+    // other rogue family enchantments always 1 hour (some have spell damage=0, but some have wrong data in EffBasePoints)
+    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE)
+        duration = 3600;                                    // 1 hour
+    // shaman family enchantments
+    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN)
+        duration = 1800;                                    // 30 mins
+    // other cases with this SpellVisual already selected
+    else if (m_spellInfo->SpellVisual[0] == 215)
+        duration = 1800;                                    // 30 mins
+    // some fishing pole bonuses except Glow Worm which lasts full hour
+    else if (m_spellInfo->SpellVisual[0] == 563 && m_spellInfo->Id != 64401)
+        duration = 600;                                     // 10 mins
+    // shaman rockbiter enchantments
+    else if (m_spellInfo->SpellVisual[0] == 0)
+        duration = 1800;                                    // 30 mins
+    else if (m_spellInfo->Id == 29702)
+        duration = 300;                                     // 5 mins
+    else if (m_spellInfo->Id == 37360)
+        duration = 300;                                     // 5 mins
+    // default case
+    else
+        duration = 3600;                                    // 1 hour
+
+    // item can be in trade slot and have owner diff. from caster
+    Player* item_owner = itemTarget->GetOwner();
+    if (!item_owner)
+        return;
+
+    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
+    {
+        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(temp): %s (Entry: %d) for player: %s (Account: %u)",
+            p_caster->GetName(), p_caster->GetSession()->GetAccountId(),
+            itemTarget->GetProto()->Name1, itemTarget->GetEntry(),
+            item_owner->GetName(), item_owner->GetSession()->GetAccountId());
+    }
+
+    // remove old enchanting before applying new if equipped
+    item_owner->ApplyEnchantment(itemTarget,TEMP_ENCHANTMENT_SLOT, false);
+
+    itemTarget->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, duration * 1000, 0);
+
+    // add new enchanting if equipped
+    item_owner->ApplyEnchantment(itemTarget, TEMP_ENCHANTMENT_SLOT, true);
+}
+
+void Spell::EffectTameCreature(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetPetGUID())
+        return;
+
+    if (!unitTarget)
+        return;
+
+    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+        return;
+
+    Creature* creatureTarget = unitTarget->ToCreature();
+
+    if (creatureTarget->isPet())
+        return;
+
+    if (m_caster->getClass() != CLASS_HUNTER)
+        return;
+
+    // cast finish successfully
+    //SendChannelUpdate(0);
+    finish();
+
+    Pet* pet = m_caster->CreateTamedPetFrom(creatureTarget,m_spellInfo->Id);
+    if (!pet)                                               // in very specific state like near world end/etc.
+        return;
+
+    // "kill" original creature
+    creatureTarget->ForcedDespawn();
+
+    uint8 level = (creatureTarget->getLevel() < (m_caster->getLevel() - 5)) ? (m_caster->getLevel() - 5) : creatureTarget->getLevel();
+
+    // prepare visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level - 1);
+
+    // add to world
+    pet->GetMap()->Add(pet->ToCreature());
+
+    // visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level);
+
+    // caster have pet now
+    m_caster->SetMinion(pet, true);
+
+    pet->InitTalentForLevel();
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        m_caster->ToPlayer()->PetSpellInitialize();
+    }
+}
+
+void Spell::EffectSummonPet(SpellEffIndex effIndex)
+{
+    Player *owner = NULL;
+    if (m_originalCaster)
+    {
+        if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
+            owner = (Player*)m_originalCaster;
+        else if (m_originalCaster->ToCreature()->isTotem())
+            owner = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    uint32 petentry = m_spellInfo->EffectMiscValue[effIndex];
+
+    if (!owner)
+    {
+        SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(67);
+        if (properties)
+            SummonGuardian(effIndex, petentry, properties);
+        return;
+    }
+
+    Pet *OldSummon = owner->GetPet();
+
+    // if pet requested type already exist
+    if (OldSummon)
+    {
+        if (petentry == 0 || OldSummon->GetEntry() == petentry)
+        {
+            // pet in corpse state can't be summoned
+            if (OldSummon->isDead())
+                return;
+
+            ASSERT(OldSummon->GetMap() == owner->GetMap());
+
+            //OldSummon->GetMap()->Remove(OldSummon->ToCreature(),false);
+
+            float px, py, pz;
+            owner->GetClosePoint(px, py, pz, OldSummon->GetObjectSize());
+
+            OldSummon->NearTeleportTo(px, py, pz, OldSummon->GetOrientation());
+            //OldSummon->Relocate(px, py, pz, OldSummon->GetOrientation());
+            //OldSummon->SetMap(owner->GetMap());
+            //owner->GetMap()->Add(OldSummon->ToCreature());
+
+            if (owner->GetTypeId() == TYPEID_PLAYER && OldSummon->isControlled())
+                owner->ToPlayer()->PetSpellInitialize();
+
+            return;
+        }
+
+        if (owner->GetTypeId() == TYPEID_PLAYER)
+            owner->ToPlayer()->RemovePet(OldSummon,(OldSummon->getPetType() == HUNTER_PET ? PET_SAVE_AS_DELETED : PET_SAVE_NOT_IN_SLOT),false);
+        else
+            return;
+    }
+
+    float x, y, z;
+    owner->GetClosePoint(x, y, z, owner->GetObjectSize());
+    Pet* pet = owner->SummonPet(petentry, x, y, z, owner->GetOrientation(), SUMMON_PET, 0);
+    if (!pet)
+        return;
+
+    if (m_caster->GetTypeId() == TYPEID_UNIT)
+    {
+        if (m_caster->ToCreature()->isTotem())
+            pet->SetReactState(REACT_AGGRESSIVE);
+        else
+            pet->SetReactState(REACT_DEFENSIVE);
+    }
+
+    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+
+    // generate new name for summon pet
+    std::string new_name=sObjectMgr.GeneratePetName(petentry);
+    if (!new_name.empty())
+        pet->SetName(new_name);
+
+    ExecuteLogEffectSummonObject(effIndex, pet);
+}
+
+void Spell::EffectLearnPetSpell(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)m_caster;
+
+    Pet *pet = _player->GetPet();
+    if (!pet)
+        return;
+    if (!pet->isAlive())
+        return;
+
+    SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[effIndex]);
+    if (!learn_spellproto)
+        return;
+
+    pet->learnSpell(learn_spellproto->Id);
+
+    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+    _player->PetSpellInitialize();
+}
+
+void Spell::EffectTaunt(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    // this effect use before aura Taunt apply for prevent taunt already attacking target
+    // for spell as marked "non effective at already attacking target"
+    if (!unitTarget || !unitTarget->CanHaveThreatList()
+        || unitTarget->getVictim() == m_caster)
+    {
+        SendCastResult(SPELL_FAILED_DONT_REPORT);
+        return;
+    }
+
+    if (m_spellInfo->Id == 62124)
+    {
+        int32 damageDone = int32(1 + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.5f);
+        bool is_crit = m_caster->isSpellCrit(unitTarget, m_spellInfo, m_spellSchoolMask, m_attackType);
+        if (is_crit)
+            damageDone *= 2;
+        m_caster->DealDamage(unitTarget, damageDone, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_HOLY, m_spellInfo, false);
+        m_caster->SendSpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, damageDone, SPELL_SCHOOL_MASK_HOLY, 0, 0, false, false, is_crit);
+    }
+
+    // Also use this effect to set the taunter's threat to the taunted creature's highest value
+    if (unitTarget->getThreatManager().getCurrentVictim())
+    {
+        float myThreat = unitTarget->getThreatManager().getThreat(m_caster);
+        float itsThreat = unitTarget->getThreatManager().getCurrentVictim()->getThreat();
+        if (itsThreat > myThreat)
+            unitTarget->getThreatManager().addThreat(m_caster, itsThreat - myThreat);
+    }
+
+    //Set aggro victim to caster
+    if (!unitTarget->getThreatManager().getOnlineContainer().empty())
+        if (HostileReference* forcedVictim = unitTarget->getThreatManager().getOnlineContainer().getReferenceByTarget(m_caster))
+            unitTarget->getThreatManager().setCurrentVictim(forcedVictim);
+
+    if (unitTarget->ToCreature()->IsAIEnabled && !unitTarget->ToCreature()->HasReactState(REACT_PASSIVE))
+        unitTarget->ToCreature()->AI()->AttackStart(m_caster);
+}
+
+void Spell::EffectWeaponDmg(SpellEffIndex /*effIndex*/)
+{
+}
+
+void Spell::SpellDamageWeaponDmg(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (!unitTarget->isAlive())
+        return;
+
+    // multiple weapon dmg effect workaround
+    // execute only the last weapon damage
+    // and handle all effects at once
+    for (uint32 j = effIndex + 1; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        switch (m_spellInfo->Effect[j])
+        {
+            case SPELL_EFFECT_WEAPON_DAMAGE:
+            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                return;     // we must calculate only at last weapon effect
+            break;
+        }
+    }
+
+    // some spell specific modifiers
+    float totalDamagePercentMod  = 1.0f;                    // applied to final bonus+weapon damage
+    int32 fixed_bonus = 0;
+    int32 spell_bonus = 0;                                  // bonus specific for spell
+
+    switch (m_spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch (m_spellInfo->Id)
+            {
+                case 69055:     // Saber Lash
+                case 70814:     // Saber Lash
+                {
+                    uint32 count = 0;
+                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1 << effIndex))
+                            ++count;
+
+                    totalDamagePercentMod /= count;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            // Devastate (player ones)
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x40)
+            {
+                // Player can apply only 58567 Sunder Armor effect.
+                bool needCast = !unitTarget->HasAura(58567, m_caster->GetGUID());
+                if (needCast)
+                    m_caster->CastSpell(unitTarget, 58567, true);
+
+                if (Aura * aur = unitTarget->GetAura(58567, m_caster->GetGUID()))
+                {
+                    // 58388 - Glyph of Devastate dummy aura.
+                    if (int32 num = (needCast ? 0 : 1) + (m_caster->HasAura(58388) ? 1 : 0))
+                        aur->ModStackAmount(num);
+                    fixed_bonus += (aur->GetStackAmount() - 1) * CalculateDamage(2, unitTarget);
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_ROGUE:
+        {
+            // Fan of Knives, Hemorrhage, Ghostly Strike
+            if ((m_spellInfo->SpellFamilyFlags[1] & 0x40000)
+                || (m_spellInfo->SpellFamilyFlags[0] & 0x6000000))
+            {
+                // Hemorrhage
+                if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
+                {
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                        m_caster->ToPlayer()->AddComboPoints(unitTarget, 1, this);
+                }
+                // 50% more damage with daggers
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    if (Item* item = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType, true))
+                        if (item->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
+                            totalDamagePercentMod *= 1.5f;
+            }
+            // Mutilate (for each hand)
+            else if (m_spellInfo->SpellFamilyFlags[1] & 0x6)
+            {
+                bool found = false;
+                // fast check
+                if (unitTarget->HasAuraState(AURA_STATE_DEADLY_POISON, m_spellInfo, m_caster))
+                    found = true;
+                // full aura scan
+                else
+                {
+                    Unit::AuraApplicationMap const& auras = unitTarget->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        if (itr->second->GetBase()->GetSpellProto()->Dispel == DISPEL_POISON)
+                        {
+                            found = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (found)
+                    totalDamagePercentMod *= 1.2f;          // 120% if poisoned
+            }
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Seal of Command - Increase damage by 36% on every swing
+            if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
+            {
+                totalDamagePercentMod *= 1.36f;            //136% damage
+            }
+
+            // Seal of Command Unleashed
+            else if (m_spellInfo->Id == 20467)
+            {
+                spell_bonus += int32(0.08f*m_caster->GetTotalAttackPowerValue(BASE_ATTACK));
+                spell_bonus += int32(0.13f*m_caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellInfo), m_spellInfo));
+            }
+            break;
+        }
+        case SPELLFAMILY_SHAMAN:
+        {
+            // Skyshatter Harness item set bonus
+            // Stormstrike
+            if (AuraEffect * aurEff = m_caster->IsScriptOverriden(m_spellInfo, 5634))
+                m_caster->CastSpell(m_caster, 38430, true, NULL, aurEff);
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            // Mangle (Cat): CP
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
+            {
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    m_caster->ToPlayer()->AddComboPoints(unitTarget,1, this);
+            }
+            // Shred, Maul - Rend and Tear
+            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00008800 && unitTarget->HasAuraState(AURA_STATE_BLEEDING))
+            {
+                if (AuraEffect const* rendAndTear = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 0))
+                {
+                    totalDamagePercentMod *= float((rendAndTear->GetAmount() + 100.0f) / 100.0f);
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // Kill Shot - bonus damage from Ranged Attack Power
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x800000)
+                spell_bonus += int32(0.4f*m_caster->GetTotalAttackPowerValue(RANGED_ATTACK));
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Plague Strike
+            if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
+            {
+                // Glyph of Plague Strike
+                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58657,0))
+                    totalDamagePercentMod *= float((aurEff->GetAmount() + 100.0f) / 100.0f);
+            }
+            // Blood Strike
+            else if (m_spellInfo->SpellFamilyFlags[0] & 0x400000)
+            {
+                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
+
+                // Glyph of Blood Strike
+                if (m_caster->GetAuraEffect(59332,0))
+                {
+                    if (unitTarget->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED))
+                       totalDamagePercentMod *= float((20 + 100.0f) / 100.0f);
+                }
+            }
+            // Death Strike
+            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000010)
+            {
+                // Glyph of Death Strike
+                if (m_caster->GetAuraEffect(59336,0))
+                {
+                    if (uint32 runic = m_caster->GetPower(POWER_RUNIC_POWER))
+                    {
+                        if (runic > 25)
+                            runic = 25;
+
+                        totalDamagePercentMod *= float((runic + 100.0f) / 100.0f);
+                    }
+                }
+            }
+            // Obliterate (12.5% more damage per disease)
+            else if (m_spellInfo->SpellFamilyFlags[1] & 0x20000)
+            {
+                bool consumeDiseases = true;
+                // Annihilation
+                if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2710, 0))
+                {
+                    // Do not consume diseases if roll sucesses
+                    if (roll_chance_i(aurEff->GetAmount()))
+                        consumeDiseases = false;
+                }
+                totalDamagePercentMod *= (float(CalculateDamage(2, unitTarget) * unitTarget->GetDiseasesByCaster(m_caster->GetGUID(), consumeDiseases) / 2) + 100.0f) / 100.0f;
+            }
+            // Blood-Caked Strike - Blood-Caked Blade
+            else if (m_spellInfo->SpellIconID == 1736)
+                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
+            // Rune Strike
+            else if (m_spellInfo->SpellFamilyFlags[1] & 0x20000000)
+                m_damage += int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.15f);
+            break;
+        }
+    }
+
+    bool normalized = false;
+    float weaponDamagePercentMod = 1.0;
+    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        switch(m_spellInfo->Effect[j])
+        {
+            case SPELL_EFFECT_WEAPON_DAMAGE:
+            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+                fixed_bonus += CalculateDamage(j, unitTarget);
+                break;
+            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                fixed_bonus += CalculateDamage(j, unitTarget);
+                normalized = true;
+                break;
+            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                weaponDamagePercentMod *= float(CalculateDamage(j,unitTarget)) / 100.0f;
+                break;
+            default:
+                break;                                      // not weapon damage effect, just skip
+        }
+    }
+
+    // apply to non-weapon bonus weapon total pct effect, weapon total flat effect included in weapon damage
+    if (fixed_bonus || spell_bonus)
+    {
+        UnitMods unitMod;
+        switch(m_attackType)
+        {
+            default:
+            case BASE_ATTACK:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
+            case OFF_ATTACK:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
+            case RANGED_ATTACK: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
+        }
+
+        float weapon_total_pct = 1.0f;
+        if (m_spellInfo->SchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+             weapon_total_pct = m_caster->GetModifierValue(unitMod, TOTAL_PCT);
+
+        if (fixed_bonus)
+            fixed_bonus = int32(fixed_bonus * weapon_total_pct);
+        if (spell_bonus)
+            spell_bonus = int32(spell_bonus * weapon_total_pct);
+    }
+
+    int32 weaponDamage = m_caster->CalculateDamage(m_attackType, normalized, true);
+
+    // Sequence is important
+    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        // We assume that a spell have at most one fixed_bonus
+        // and at most one weaponDamagePercentMod
+        switch(m_spellInfo->Effect[j])
+        {
+            case SPELL_EFFECT_WEAPON_DAMAGE:
+            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                weaponDamage += fixed_bonus;
+                break;
+            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                weaponDamage = int32(weaponDamage * weaponDamagePercentMod);
+            default:
+                break;                                      // not weapon damage effect, just skip
+        }
+    }
+
+    if (spell_bonus)
+        weaponDamage += spell_bonus;
+
+    if (totalDamagePercentMod != 1.0f)
+        weaponDamage = int32(weaponDamage * totalDamagePercentMod);
+
+    // prevent negative damage
+    uint32 eff_damage = uint32(weaponDamage > 0 ? weaponDamage : 0);
+
+    // Add melee damage bonuses (also check for negative)
+    m_caster->MeleeDamageBonus(unitTarget, &eff_damage, m_attackType, m_spellInfo);
+    m_damage+= eff_damage;
+}
+
+void Spell::EffectThreat(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive() || !m_caster->isAlive())
+        return;
+
+    if (!unitTarget->CanHaveThreatList())
+        return;
+
+    unitTarget->AddThreat(m_caster, float(damage));
+}
+
+void Spell::EffectHealMaxHealth(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive())
+        return;
+
+    int32 addhealth;
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN) // Lay on Hands
+    {
+        if (m_caster->GetGUID() == unitTarget->GetGUID())
+        {
+            m_caster->CastSpell(m_caster, 25771, true); // Forbearance
+            m_caster->CastSpell(m_caster, 61988, true); // Immune shield marker (serverside)
+            m_caster->CastSpell(m_caster, 61987, true); // Avenging Wrath marker
+        }
+    }
+
+    // damage == 0 - heal for caster max health
+    if (damage == 0)
+        addhealth = m_caster->GetMaxHealth();
+    else
+        addhealth = unitTarget->GetMaxHealth() - unitTarget->GetHealth();
+
+    if (m_originalCaster)
+         m_healing += m_originalCaster->SpellHealingBonus(unitTarget,m_spellInfo, addhealth, HEAL);
+}
+
+void Spell::EffectInterruptCast(SpellEffIndex effIndex)
+{
+    if (!unitTarget || !unitTarget->isAlive())
+        return;
+
+    // TODO: not all spells that used this effect apply cooldown at school spells
+    // also exist case: apply cooldown to interrupted cast only and to all spells
+    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; ++i)
+    {
+        if (Spell* spell = unitTarget->GetCurrentSpell(CurrentSpellTypes(i)))
+        {
+            SpellEntry const* curSpellInfo = spell->m_spellInfo;
+            // check if we can interrupt spell
+            if ((spell->getState() == SPELL_STATE_CASTING
+                || (spell->getState() == SPELL_STATE_PREPARING && spell->GetCastTime() > 0.0f))
+                && curSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT && curSpellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+            {
+                if (m_originalCaster)
+                {
+                    int32 duration = GetSpellDuration(m_spellInfo);
+                    unitTarget->ProhibitSpellScholl(GetSpellSchoolMask(curSpellInfo), unitTarget->ModSpellDuration(m_spellInfo, unitTarget, duration, false));
+                }
+                ExecuteLogEffectInterruptCast(effIndex, unitTarget, curSpellInfo->Id);
+                unitTarget->InterruptSpell(CurrentSpellTypes(i), false);
+            }
+        }
+    }
+}
+
+void Spell::EffectSummonObjectWild(SpellEffIndex effIndex)
+{
+    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    GameObject* pGameObj = new GameObject;
+
+    WorldObject* target = focusObject;
+    if (!target)
+        target = m_caster;
+
+    float x, y, z;
+    if (m_targets.HasDst())
+        m_targets.m_dstPos.GetPosition(x, y, z);
+    else
+        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+
+    Map *map = target->GetMap();
+
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id, map,
+        m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    int32 duration = GetSpellDuration(m_spellInfo);
+
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+    pGameObj->SetSpellId(m_spellInfo->Id);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    // Wild object not have owner and check clickable by players
+    map->Add(pGameObj);
+
+    if (pGameObj->GetGoType() == GAMEOBJECT_TYPE_FLAGDROP && m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        Player *pl = m_caster->ToPlayer();
+        Battleground* bg = pl->GetBattleground();
+
+        switch(pGameObj->GetMapId())
+        {
+            case 489:                                       //WS
+            {
+                if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS && bg->GetStatus() == STATUS_IN_PROGRESS)
+                {
+                    uint32 team = ALLIANCE;
+
+                    if (pl->GetTeam() == team)
+                        team = HORDE;
+
+                    ((BattlegroundWS*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID(),team);
+                }
+                break;
+            }
+            case 566:                                       //EY
+            {
+                if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY && bg->GetStatus() == STATUS_IN_PROGRESS)
+                {
+                    ((BattlegroundEY*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID());
+                }
+                break;
+            }
+        }
+    }
+
+    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
+    {
+        GameObject* linkedGO = new GameObject;
+        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, map,
+            m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+        {
+            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+            linkedGO->SetSpellId(m_spellInfo->Id);
+
+            ExecuteLogEffectSummonObject(effIndex, linkedGO);
+
+            // Wild object not have owner and check clickable by players
+            map->Add(linkedGO);
+        }
+        else
+        {
+            delete linkedGO;
+            linkedGO = NULL;
+            return;
+        }
+    }
+}
+
+void Spell::EffectScriptEffect(SpellEffIndex effIndex)
+{
+    // TODO: we must implement hunter pet summon at login there (spell 6962)
+
+    switch(m_spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch(m_spellInfo->Id)
+            {        
 				//Teleport to Lake Wintergrasp
                 case 58622:
                    {
@@ -4560,2889 +4563,2889 @@
                         unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_ALLIENCE_CAMP, true);
                         }
                 return;
-                   }
-                // Glyph of Backstab
-                case 63975:
-                {
-                    if (AuraEffect const * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE,SPELLFAMILY_ROGUE,0x00100000,0,0,m_caster->GetGUID()))
-                    {
-                        uint32 countMin = aurEff->GetBase()->GetMaxDuration();
-                        uint32 countMax = 12000;
-                        countMax += m_caster->HasAura(56801) ? 4000 : 0;
-
-                        if (countMin < countMax)
-                        {
-                            aurEff->GetBase()->SetDuration(uint32(aurEff->GetBase()->GetDuration()+3000));
-                            aurEff->GetBase()->SetMaxDuration(countMin+2000);
-                        }
-
-                    }
-                    return;
-                }            
-                case 69200:                                 // Raging Spirit
-                {
-                    if (!unitTarget)
-                        return;
-
-                    unitTarget->CastSpell(unitTarget, 69201, true);
-                    return;
-                }
-                case 71446:                                 // Twilight Bloodbolt 10N
-                case 71478:                                 // Twilight Bloodbolt 25N
-                case 71479:                                 // Twilight Bloodbolt 10H
-                case 71480:                                 // Twilight Bloodbolt 25H
-                {
-                    if (!unitTarget)
-                        return;
-
-                    uint32 spellId = 71447;
-                    switch (m_spellInfo->Id)
-                    {
-                        case 71478: spellId = 71481; break;
-                        case 71479: spellId = 71482; break;
-                        case 71480: spellId = 71483; break;
-                    }
-                    unitTarget->CastSpell(unitTarget, spellId, true);
-                    return;
-                }
-                case 71899:                                 // Bloodbolt Whirl 10N
-                case 71900:                                 // Bloodbolt Whirl 25N
-                case 71901:                                 // Bloodbolt Whirl 10H
-                case 71902:                                 // Bloodbolt Whirl 25H
-                {
-                    if (!unitTarget)
-                        return;
-
-                    uint32 spellId = 71446;
-                    switch (m_spellInfo->Id)
-                    {
-                        case 71900: spellId = 71478; break;
-                        case 71901: spellId = 71479; break;
-                        case 71902: spellId = 71480; break;
-                    }
-                    m_caster->CastSpell(unitTarget, spellId, true);
-                    return;
-                }
-
-                case 45204: // Clone Me!
-                case 41055: // Copy Weapon
-                case 45206: // Copy Off-hand Weapon
-                    unitTarget->CastSpell(m_caster, damage, false);
-                    break;
-                case 45205: // Copy Offhand Weapon
-                case 41054: // Copy Weapon
-                    m_caster->CastSpell(unitTarget, damage, false);
-                    break;
-                case 55693:                                 // Remove Collapsing Cave Aura
-                    if (!unitTarget)
-                        return;
-                    unitTarget->RemoveAurasDueToSpell(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
-                    break;
-                // PX-238 Winter Wondervolt TRAP
-                case 26275:
-                {
-                    uint32 spells[4] = { 26272, 26157, 26273, 26274 };
-
-                    // check presence
-                    for (uint8 j = 0; j < 4; ++j)
-                        if (unitTarget->HasAuraEffect(spells[j],0))
-                            return;
-
-                    // select spell
-                    uint32 iTmpSpellId = spells[urand(0,3)];
-
-                    // cast
-                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
-                    return;
-                }
-                // Bending Shinbone
-                case 8856:
-                {
-                    if (!itemTarget && m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    uint32 spell_id = 0;
-                    switch(urand(1, 5))
-                    {
-                    case 1:  spell_id = 8854; break;
-                    default: spell_id = 8855; break;
-                    }
-
-                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
-                    return;
-                }
-                // Brittle Armor - need remove one 24575 Brittle Armor aura
-                case 24590:
-                    unitTarget->RemoveAuraFromStack(24575);
-                    return;
-                // Mercurial Shield - need remove one 26464 Mercurial Shield aura
-                case 26465:
-                    unitTarget->RemoveAuraFromStack(26464);
-                    return;
-				case 62575:
-				{
-					if(m_caster->GetOwner())
-						m_caster->GetOwner()->CastSpell(unitTarget,62626,true );
-						return;
-				}
-				case 62960:
-				{
-					if (!unitTarget)
-						return;
-					m_caster->CastSpell(unitTarget,62563,true );
-					m_caster->CastSpell(unitTarget,68321,true );
-					return;
-				}
-				case 62626:
-				case 68321:
-				{
-					if(!unitTarget)
-						return;
-					if (unitTarget->GetAura(62719))
-						unitTarget->RemoveAuraFromStack(62719);
-
-					if(unitTarget->GetAura(64100))
-						unitTarget->RemoveAuraFromStack(64100);
-					return;
-				}
-					// Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
-                case 22539:
-                case 22972:
-                case 22975:
-                case 22976:
-                case 22977:
-                case 22978:
-                case 22979:
-                case 22980:
-                case 22981:
-                case 22982:
-                case 22983:
-                case 22984:
-                case 22985:
-                {
-                    if (!unitTarget || !unitTarget->isAlive())
-                        return;
-
-                    // Onyxia Scale Cloak
-                    if (unitTarget->HasAura(22683))
-                        return;
-
-                    // Shadow Flame
-                    m_caster->CastSpell(unitTarget, 22682, true);
-                    return;
-                }
-                // Piccolo of the Flaming Fire
-                case 17512:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    unitTarget->HandleEmoteCommand(EMOTE_STATE_DANCE);
-                    return;
-                }
-                // Escape artist
-                case 20589:
-                    m_caster->RemoveMovementImpairingAuras();
-                    return;
-                // Decimate
-                case 28374:
-                case 54426:
-                    if (unitTarget)
-                    {
-                        int32 damage = int32(unitTarget->GetHealth()) - int32(unitTarget->CountPctFromMaxHealth(5));
-                        if (damage > 0)
-                            m_caster->CastCustomSpell(28375, SPELLVALUE_BASE_POINT0, damage, unitTarget);
-                    }
-                    return;
-                // Mirren's Drinking Hat
-                case 29830:
-                {
-                    uint32 item = 0;
-                    switch (urand(1, 6))
-                    {
-                        case 1:
-                        case 2:
-                        case 3:
-                            item = 23584; break;            // Loch Modan Lager
-                        case 4:
-                        case 5:
-                            item = 23585; break;            // Stouthammer Lite
-                        case 6:
-                            item = 23586; break;            // Aerie Peak Pale Ale
-                    }
-                    if (item)
-                        DoCreateItem(effIndex,item);
-                    break;
-                }
-                // Improved Sprint
-                case 30918:
-                {
-                    // Removes snares and roots.
-                    unitTarget->RemoveMovementImpairingAuras();
-                    break;
-                }
-                // Spirit Walk
-                case 58876:
-                {
-                    // Removes snares and roots.
-                    unitTarget->RemoveMovementImpairingAuras();
-                    break;
-                }
-                // Plant Warmaul Ogre Banner
-                case 32307:
-                {
-                    Player *p_caster = dynamic_cast<Player*>(m_caster);
-                    if (!p_caster)
-                        break;
-                    p_caster->RewardPlayerAndGroupAtEvent(18388, unitTarget);
-                    Creature *cTarget = dynamic_cast<Creature*>(unitTarget);
-                    if (!cTarget)
-                        break;
-                    cTarget->setDeathState(CORPSE);
-                    cTarget->RemoveCorpse();
-                    break;
-                }
-                case 48025:                                     // Headless Horseman's Mount
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 51621, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 48024, true); break;
-                    case 225:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 51617, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 48024, true);
-                        }break;
-                    case 300:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 48023, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 48024, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 47977:                                     // Magic Broom
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 42680, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 42683, true); break;
-                    case 225:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 42667, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 42683, true);
-                        }break;
-                    case 300:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 42668, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 42683, true);
-                        }break;
-                    }
-                    return;
-                }
-                // Mug Transformation
-                case 41931:
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    uint8 bag = 19;
-                    uint8 slot = 0;
-                    Item *item = NULL;
-
-                    while (bag) // 256 = 0 due to var type
-                    {
-                        item = m_caster->ToPlayer()->GetItemByPos(bag, slot);
-                        if (item && item->GetEntry() == 38587) break;
-                        ++slot;
-                        if (slot == 39)
-                        {
-                            slot = 0;
-                            ++bag;
-                        }
-                    }
-                    if (bag)
-                    {
-                        if (m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount() == 1) m_caster->ToPlayer()->RemoveItem(bag,slot,true);
-                        else m_caster->ToPlayer()->GetItemByPos(bag,slot)->SetCount(m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount()-1);
-                        // Spell 42518 (Braufest - Gratisprobe des Braufest herstellen)
-                        m_caster->CastSpell(m_caster, 42518, true);
-                        return;
-                    }
-                    break;
-                }
-                // Brutallus - Burn
-                case 45141:
-                case 45151:
-                {
-                    //Workaround for Range ... should be global for every ScriptEffect
-                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-                    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER && unitTarget->GetDistance(m_caster) >= radius && !unitTarget->HasAura(46394) && unitTarget != m_caster)
-                        unitTarget->CastSpell(unitTarget, 46394, true);
-
-                    break;
-                }
-                // Goblin Weather Machine
-                case 46203:
-                {
-                    if (!unitTarget)
-                        return;
-
-                    uint32 spellId = 0;
-                    switch(rand() % 4)
-                    {
-                        case 0: spellId = 46740; break;
-                        case 1: spellId = 46739; break;
-                        case 2: spellId = 46738; break;
-                        case 3: spellId = 46736; break;
-                    }
-                    unitTarget->CastSpell(unitTarget, spellId, true);
-                    break;
-                }
-                // 5,000 Gold
-                case 46642:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    unitTarget->ToPlayer()->ModifyMoney(5000 * GOLD);
-
-                    break;
-                }
-                // Roll Dice - Decahedral Dwarven Dice
-                case 47770:
-                {
-                    char buf[128];
-                    const char *gender = "his";
-                    if (m_caster->getGender() > 0)
-                        gender = "her";
-                    sprintf(buf, "%s rubs %s [Decahedral Dwarven Dice] between %s hands and rolls. One %u and one %u.", m_caster->GetName(), gender, gender, urand(1,10), urand(1,10));
-                    m_caster->MonsterTextEmote(buf, 0);
-                    break;
-                }
-                // Roll 'dem Bones - Worn Troll Dice
-                case 47776:
-                {
-                    char buf[128];
-                    const char *gender = "his";
-                    if (m_caster->getGender() > 0)
-                        gender = "her";
-                    sprintf(buf, "%s causually tosses %s [Worn Troll Dice]. One %u and one %u.", m_caster->GetName(), gender, urand(1,6), urand(1,6));
-                    m_caster->MonsterTextEmote(buf, 0);
-                    break;
-                }
-                // Vigilance
-                case 50725:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Remove Taunt cooldown
-                    unitTarget->ToPlayer()->RemoveSpellCooldown(355, true);
-
-                    return;
-                }
-                // Death Knight Initiate Visual
-                case 51519:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    uint32 iTmpSpellId = 0;
-                    switch (unitTarget->GetDisplayId())
-                    {
-                        case 25369: iTmpSpellId = 51552; break; // bloodelf female
-                        case 25373: iTmpSpellId = 51551; break; // bloodelf male
-                        case 25363: iTmpSpellId = 51542; break; // draenei female
-                        case 25357: iTmpSpellId = 51541; break; // draenei male
-                        case 25361: iTmpSpellId = 51537; break; // dwarf female
-                        case 25356: iTmpSpellId = 51538; break; // dwarf male
-                        case 25372: iTmpSpellId = 51550; break; // forsaken female
-                        case 25367: iTmpSpellId = 51549; break; // forsaken male
-                        case 25362: iTmpSpellId = 51540; break; // gnome female
-                        case 25359: iTmpSpellId = 51539; break; // gnome male
-                        case 25355: iTmpSpellId = 51534; break; // human female
-                        case 25354: iTmpSpellId = 51520; break; // human male
-                        case 25360: iTmpSpellId = 51536; break; // nightelf female
-                        case 25358: iTmpSpellId = 51535; break; // nightelf male
-                        case 25368: iTmpSpellId = 51544; break; // orc female
-                        case 25364: iTmpSpellId = 51543; break; // orc male
-                        case 25371: iTmpSpellId = 51548; break; // tauren female
-                        case 25366: iTmpSpellId = 51547; break; // tauren male
-                        case 25370: iTmpSpellId = 51545; break; // troll female
-                        case 25365: iTmpSpellId = 51546; break; // troll male
-                        default: return;
-                    }
-
-                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
-                    Creature* npc = unitTarget->ToCreature();
-                    npc->LoadEquipment(npc->GetEquipmentId());
-                    return;
-                }
-                // Emblazon Runeblade
-                case 51770:
-                {
-                    if (!m_originalCaster)
-                        return;
-
-                    m_originalCaster->CastSpell(m_originalCaster, damage, false);
-                    break;
-                }
-                // Deathbolt from Thalgran Blightbringer
-                // reflected by Freya's Ward
-                // Retribution by Sevenfold Retribution
-                case 51854:
-                {
-                    if (!m_caster || !unitTarget)
-                        return;
-                    if (unitTarget->HasAura(51845))
-                        unitTarget->CastSpell(m_caster, 51856, true);
-                    else
-                        m_caster->CastSpell(unitTarget, 51855, true);
-                    break;
-                }
-                // Summon Ghouls On Scarlet Crusade
-                case 51904:
-                {
-                    if (!m_targets.HasDst())
-                        return;
-
-                    float x, y, z;
-                    float radius = GetSpellRadius(m_spellInfo, effIndex, true);
-                    for (uint8 i = 0; i < 15; ++i)
-                    {
-                        m_caster->GetRandomPoint(m_targets.m_dstPos, radius, x, y, z);
-                        m_caster->CastSpell(x, y, z, 54522, true);
-                    }
-                    break;
-                }
-                case 52173: // Coyote Spirit Despawn
-                case 60243: // Blood Parrot Despawn
-                    if (unitTarget->GetTypeId() == TYPEID_UNIT && unitTarget->ToCreature()->isSummon())
-                        unitTarget->ToTempSummon()->UnSummon();
-                    return;
-                case 52479: // Gift of the Harvester
-                    if (unitTarget && m_originalCaster)
-                        m_originalCaster->CastSpell(unitTarget, urand(0, 1) ? damage : 52505, true);
-                    return;
-                // Death Gate
-                case 52751:
-                {
-                    if (!unitTarget || unitTarget->getClass() != CLASS_DEATH_KNIGHT)
-                        return;
-                    // triggered spell is stored in m_spellInfo->EffectBasePoints[0]
-                    unitTarget->CastSpell(unitTarget, damage, false);
-                    break;
-                }
-                case 53110: // Devour Humanoid
-                    if (unitTarget)
-                        unitTarget->CastSpell(m_caster, damage, true);
-                    return;
-                // Winged Steed of the Ebon Blade
-                case 54729:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 300)
-                            unitTarget->CastSpell(unitTarget, 54727, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 54726, true);
-                    }
-                    return;
-                }
-                case 58418:                                 // Portal to Orgrimmar
-                case 58420:                                 // Portal to Stormwind
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || effIndex != 0)
-                        return;
-
-                    uint32 spellID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0);
-                    uint32 questID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
-
-                    if (unitTarget->ToPlayer()->GetQuestStatus(questID) == QUEST_STATUS_COMPLETE && !unitTarget->ToPlayer()->GetQuestRewardStatus (questID))
-                        unitTarget->CastSpell(unitTarget, spellID, true);
-
-                    return;
-                }
-                case 58941:                                 // Rock Shards
-                    if (unitTarget && m_originalCaster)
-                    {
-                        for (uint32 i = 0; i < 3; ++i)
-                        {
-                            m_originalCaster->CastSpell(unitTarget, 58689, true);
-                            m_originalCaster->CastSpell(unitTarget, 58692, true);
-                        }
-                        if (((InstanceMap*)m_originalCaster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY)
-                        {
-                            m_originalCaster->CastSpell(unitTarget, 58695, true);
-                            m_originalCaster->CastSpell(unitTarget, 58696, true);
-                        }
-                        else
-                        {
-                            m_originalCaster->CastSpell(unitTarget, 60883, true);
-                            m_originalCaster->CastSpell(unitTarget, 60884, true);
-                        }
-                    }
-                    return;
-                case 58983: // Big Blizzard Bear
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 150)
-                            unitTarget->CastSpell(unitTarget, 58999, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 58997, true);
-                    }
-                    return;
-                }
-                case 63845: // Create Lance
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-			{
-                        m_caster->CastSpell(m_caster, 63914, true);
-			DoCreateItem(0,46069);
-			}
-                    else
-			{
-                        DoCreateItem(0,46070);
-			m_caster->CastSpell(m_caster, 63919, true);
-			}
-                    return;
-                }
-                case 62705:
-                {
- 	                if (!unitTarget->isInCombat())
- 	                    unitTarget->SetHealth(unitTarget->GetMaxHealth());
-                }
-                case 71342:                                     // Big Love Rocket
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 0: unitTarget->CastSpell(unitTarget, 71343, true); break;
-                    case 75: unitTarget->CastSpell(unitTarget, 71344, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 71345, true); break;
-                    case 225:
-                        {
-                        if (canFly)
-                                unitTarget->CastSpell(unitTarget, 71346, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 71345, true);
-                        }break;
-                    case 300:
-                        {
-                        if (canFly)
-                            unitTarget->CastSpell(unitTarget, 71347, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 71345, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 72286:                                     // Invincible
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 72281, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 72282, true); break;
-                    case 225:
-                        {
-                        if (canFly)
-                                unitTarget->CastSpell(unitTarget, 72283, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 72282, true);
-                        }break;
-                    case 300:
-                        {
-                        if (canFly)
-                            unitTarget->CastSpell(unitTarget, 72284, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 72282, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 74856:                                     // Blazing Hippogryph
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 300)
-                            unitTarget->CastSpell(unitTarget, 74855, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 74854, true);
-                    }
-                    return;
-                }
-                case 75614:                                     // Celestial Steed
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 75619, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 75620, true); break;
-                    case 225:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 75617, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 75620, true);
-                        }break;
-                    case 300:
-                        {
-                            if (canFly)
-                            {
-                                if (unitTarget->ToPlayer()->Has310Flyer(false))
-                                    unitTarget->CastSpell(unitTarget, 76153, true);
-                                else
-                                    unitTarget->CastSpell(unitTarget, 75618, true);
-                            }
-                            else
-                                unitTarget->CastSpell(unitTarget, 75620, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 75973:                                     // X-53 Touring Rocket
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 300)
-                        {
-                            if (unitTarget->ToPlayer()->Has310Flyer(false))
-                                unitTarget->CastSpell(unitTarget, 76154, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 75972, true);
-                        }
-                        else
-                            unitTarget->CastSpell(unitTarget, 75957, true);
-                    }
-                    return;
-                }
-                case 59317:                                 // Teleporting
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // return from top
-                    if (unitTarget->ToPlayer()->GetAreaId() == 4637)
-                        unitTarget->CastSpell(unitTarget, 59316, true);
-                    // teleport atop
-                    else
-                        unitTarget->CastSpell(unitTarget, 59314, true);
-
-                    return;
-                // random spell learn instead placeholder
-                case 60893:                                 // Northrend Alchemy Research
-                case 61177:                                 // Northrend Inscription Research
-                case 61288:                                 // Minor Inscription Research
-                case 61756:                                 // Northrend Inscription Research (FAST QA VERSION)
-                case 64323:                                 // Book of Glyph Mastery
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // learn random explicit discovery recipe (if any)
-                    if (uint32 discoveredSpell = GetExplicitDiscoverySpell(m_spellInfo->Id, (Player*)m_caster))
-                        m_caster->ToPlayer()->learnSpell(discoveredSpell, false);
-                    return;
-                }
-                case 62428: // Load into Catapult
-                {
-                    if (Vehicle *seat = m_caster->GetVehicleKit())
-                        if (Unit *passenger = seat->GetPassenger(0))
-                            if (Unit *demolisher = m_caster->GetVehicleBase())
-                                passenger->CastSpell(demolisher, damage, true);
-                    return;
-                }
-                case 62482: // Grab Crate
-                {
-                    if (unitTarget)
-                    {
-                        if (Vehicle *seat = m_caster->GetVehicleKit())
-                        {
-                            if (Creature *oldContainer = dynamic_cast<Creature*>(seat->GetPassenger(1)))
-                                oldContainer->DisappearAndDie();
-                            // TODO: a hack, range = 11, should after some time cast, otherwise too far
-                            unitTarget->CastSpell(seat->GetBase(), 62496, true);
-                            unitTarget->EnterVehicle(seat, 1);
-                        }
-                    }
-                    return;
-                }
-                case 60123: // Lightwell
-                {
-                    if (m_caster->GetTypeId() != TYPEID_UNIT || !m_caster->ToCreature()->isSummon())
-                        return;
-
-                    uint32 spell_heal;
-
-                    switch(m_caster->GetEntry())
-                    {
-                        case 31897: spell_heal = 7001; break;
-                        case 31896: spell_heal = 27873; break;
-                        case 31895: spell_heal = 27874; break;
-                        case 31894: spell_heal = 28276; break;
-                        case 31893: spell_heal = 48084; break;
-                        case 31883: spell_heal = 48085; break;
-                        default:
-                            sLog.outError("Unknown Lightwell spell caster %u", m_caster->GetEntry());
-                            return;
-                    }
-                    Aura * chargesaura = m_caster->GetAura(59907);
-
-                    if (chargesaura && chargesaura->GetCharges() > 1)
-                    {
-                        chargesaura->SetCharges(chargesaura->GetCharges() - 1);
-                        m_caster->CastSpell(unitTarget, spell_heal, true, NULL, NULL, m_caster->ToTempSummon()->GetSummonerGUID());
-                    }
-                    else
-                        m_caster->ToTempSummon()->UnSummon();
-                    return;
-                }
-                // Stoneclaw Totem
-                case 55328: // Rank 1
-                case 55329: // Rank 2
-                case 55330: // Rank 3
-                case 55332: // Rank 4
-                case 55333: // Rank 5
-                case 55335: // Rank 6
-                case 55278: // Rank 7
-                case 58589: // Rank 8
-                case 58590: // Rank 9
-                case 58591: // Rank 10
-                {
-                    int32 basepoints0 = damage;
-                    // Cast Absorb on totems
-                    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
-                    {
-                        if (!unitTarget->m_SummonSlot[slot])
-                            continue;
-
-                        Creature* totem = unitTarget->GetMap()->GetCreature(unitTarget->m_SummonSlot[slot]);
-                        if (totem && totem->isTotem())
-                        {
-                            m_caster->CastCustomSpell(totem, 55277, &basepoints0, NULL, NULL, true);
-                        }
-                    }
-                    // Glyph of Stoneclaw Totem
-                    if (AuraEffect *aur=unitTarget->GetAuraEffect(63298, 0))
-                    {
-                        basepoints0 *= aur->GetAmount();
-                        m_caster->CastCustomSpell(unitTarget, 55277, &basepoints0, NULL, NULL, true);
-                    }
-                    break;
-                }
-                case 66545: //Summon Memory
-                {
-                    uint8 uiRandom = urand(0,25);
-                    uint32 uiSpells[26] = {66704,66705,66706,66707,66709,66710,66711,66712,66713,66714,66715,66708,66708,66691,66692,66694,66695,66696,66697,66698,66699,66700,66701,66702,66703,66543};
-
-                    m_caster->CastSpell(m_caster,uiSpells[uiRandom],true);
-                    break;
-                }
-                case 45668:                                 // Ultra-Advanced Proto-Typical Shortening Blaster
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    if (roll_chance_i(50))                  // chance unknown, using 50
-                        return;
-
-                    static uint32 const spellPlayer[5] =
-                    {
-                        45674,                            // Bigger!
-                        45675,                            // Shrunk
-                        45678,                            // Yellow
-                        45682,                            // Ghost
-                        45684                             // Polymorph
-                    };
-
-                    static uint32 const spellTarget[5] = {
-                        45673,                            // Bigger!
-                        45672,                            // Shrunk
-                        45677,                            // Yellow
-                        45681,                            // Ghost
-                        45683                             // Polymorph
-                    };
-
-                    m_caster->CastSpell(m_caster, spellPlayer[urand(0,4)], true);
-                    unitTarget->CastSpell(unitTarget, spellTarget[urand(0,4)], true);
-                    break;
-                }
-                case 64142:                                 // Upper Deck - Create Foam Sword
-		{
-                    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    Player *plr = unitTarget->ToPlayer();
-                    static uint32 const itemId[] = {45061, 45176, 45177, 45178, 45179, 0};
-                    // player can only have one of these items
-                    for (uint32 const *itr = &itemId[0]; *itr; ++itr)
-                        if (plr->HasItemCount(*itr, 1, true))
-                            return;
-                    DoCreateItem(effIndex, itemId[urand(0,4)]);
-                    return;
-		}
-            }
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Judgement (seal trigger)
-            if (m_spellInfo->Category == SPELLCATEGORY_JUDGEMENT)
-            {
-                if (!unitTarget || !unitTarget->isAlive())
-                    return;
-                uint32 spellId1 = 0;
-                uint32 spellId2 = 0;
-                uint32 spellId3 = 0;
-
-                // Judgement self add switch
-                switch (m_spellInfo->Id)
-                {
-                    case 53407: spellId1 = 20184; break;    // Judgement of Justice
-                    case 20271:                             // Judgement of Light
-                    case 57774: spellId1 = 20185; break;    // Judgement of Light
-                    case 53408: spellId1 = 20186; break;    // Judgement of Wisdom
-                    default:
-                        sLog.outError("Unsupported Judgement (seal trigger) spell (Id: %u) in Spell::EffectScriptEffect",m_spellInfo->Id);
-                        return;
-                }
-                // all seals have aura dummy in 2 effect
-                Unit::AuraApplicationMap & sealAuras = m_caster->GetAppliedAuras();
-                for (Unit::AuraApplicationMap::iterator iter = sealAuras.begin(); iter != sealAuras.end();)
-                {
-                    switch (iter->first)
-                    {
-                        // Heart of the Crusader
-                        case 20335: // Rank 1
-                            spellId3 = 21183;
-                            break;
-                        case 20336: // Rank 2
-                            spellId3 = 54498;
-                            break;
-                        case 20337: // Rank 3
-                            spellId3 = 54499;
-                            break;
-                    }
-                    Aura * aura = iter->second->GetBase();
-                    if (IsSealSpell(aura->GetSpellProto()))
-                    {
-                        if (AuraEffect * aureff = aura->GetEffect(2))
-                            if (aureff->GetAuraType() == SPELL_AURA_DUMMY)
-                            {
-                                if (sSpellStore.LookupEntry(aureff->GetAmount()))
-                                    spellId2 = aureff->GetAmount();
-                                break;
-                            }
-                        if (!spellId2)
-                        {
-                            switch (iter->first)
-                            {
-                                // Seal of light, Seal of wisdom, Seal of justice
-                                case 20165:
-                                case 20166:
-                                case 20164:
-                                    spellId2 = 54158;
-                            }
-                        }
-                        break;
-                    }
-                    else
-                        ++iter;
-                }
-                if (spellId1)
-                    m_caster->CastSpell(unitTarget, spellId1, true);
-                if (spellId2)
-                    m_caster->CastSpell(unitTarget, spellId2, true);
-                if (spellId3)
-                    m_caster->CastSpell(unitTarget, spellId3, true);
-                return;
-            }
-        }
-        case SPELLFAMILY_POTION:
-        {
-            switch(m_spellInfo->Id)
-            {
-                // Netherbloom
-                case 28702:
-                {
-                    if (!unitTarget)
-                        return;
-                    // 25% chance of casting a random buff
-                    if (roll_chance_i(75))
-                        return;
-
-                    // triggered spells are 28703 to 28707
-                    // Note: some sources say, that there was the possibility of
-                    //       receiving a debuff. However, this seems to be removed by a patch.
-                    const uint32 spellid = 28703;
-
-                    // don't overwrite an existing aura
-                    for (uint8 i = 0; i < 5; ++i)
-                        if (unitTarget->HasAura(spellid + i))
-                            return;
-                    unitTarget->CastSpell(unitTarget, spellid+urand(0, 4), true);
-                    break;
-                }
-
-                // Nightmare Vine
-                case 28720:
-                {
-                    if (!unitTarget)
-                        return;
-                    // 25% chance of casting Nightmare Pollen
-                    if (roll_chance_i(75))
-                        return;
-                    unitTarget->CastSpell(unitTarget, 28721, true);
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Pestilence
-            if (m_spellInfo->SpellFamilyFlags[1]&0x10000)
-            {
-                // Get diseases on target of spell
-                if (m_targets.getUnitTarget() &&  // Glyph of Disease - cast on unit target too to refresh aura
-                    (m_targets.getUnitTarget() != unitTarget || m_caster->GetAura(63334)))
-                {
-                    // And spread them on target
-                    // Blood Plague
-                    if (m_targets.getUnitTarget()->GetAura(55078))
-                        m_caster->CastSpell(unitTarget, 55078, true);
-                    // Frost Fever
-                    if (m_targets.getUnitTarget()->GetAura(55095))
-                        m_caster->CastSpell(unitTarget, 55095, true);
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            // Shattering Throw
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x00400000)
-            {
-                if (!unitTarget)
-                    return;
-                // remove shields, will still display immune to damage part
-                unitTarget->RemoveAurasWithMechanic(1<<MECHANIC_IMMUNE_SHIELD, AURA_REMOVE_BY_ENEMY_SPELL);
-                return;
-            }
-            break;
-        }
-    }
-
-    // normal DB scripted effect
-    sLog.outDebug("Spell ScriptStart spellid %u in EffectScriptEffect(%u)", m_spellInfo->Id, effIndex);
-    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
-}
-
-void Spell::EffectSanctuary(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    std::list<Unit*> targets;
-    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(unitTarget, unitTarget, m_caster->GetMap()->GetVisibilityDistance());
-    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(unitTarget, targets, u_check);
-    unitTarget->VisitNearbyObject(m_caster->GetMap()->GetVisibilityDistance(), searcher);
-    for (std::list<Unit*>::iterator iter = targets.begin(); iter != targets.end(); ++iter)
-    {
-        if (!(*iter)->hasUnitState(UNIT_STAT_CASTING))
-            continue;
-
-        for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
-        {
-            if ((*iter)->GetCurrentSpell(i)
-            && (*iter)->GetCurrentSpell(i)->m_targets.getUnitTargetGUID() == unitTarget->GetGUID())
-            {
-                (*iter)->InterruptSpell(CurrentSpellTypes(i), false);
-            }
-        }
-    }
-
-    unitTarget->CombatStop();
-    unitTarget->getHostileRefManager().deleteReferences();   // stop all fighting
-    // Vanish allows to remove all threat and cast regular stealth so other spells can be used
-    if (m_caster->GetTypeId() == TYPEID_PLAYER
-        && m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE
-        && (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_ROGUE_VANISH))
-    {
-        
-        // Overkill
-        if (m_caster->ToPlayer()->HasSpell(58426))
-           m_caster->CastSpell(m_caster, 58427, true);
-    }
-}
-
-void Spell::EffectAddComboPoints(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    if (!m_caster->m_movedPlayer)
-        return;
-
-    if (damage <= 0)
-        return;
-
-    m_caster->m_movedPlayer->AddComboPoints(unitTarget, damage, this);
-}
-
-void Spell::EffectDuel(SpellEffIndex effIndex)
-{
-    if (!m_caster || !unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *caster = (Player*)m_caster;
-    Player *target = (Player*)unitTarget;
-
-    // caster or target already have requested duel
-    if (caster->duel || target->duel || !target->GetSocial() || target->GetSocial()->HasIgnore(caster->GetGUIDLow()))
-        return;
-
-    // Players can only fight a duel with each other outside (=not inside dungeons and not in capital cities)
-    // Don't have to check the target's map since you cannot challenge someone across maps
-    if (caster->GetMap()->Instanceable())
-    //if (mapid != 0 && mapid != 1 && mapid != 530 && mapid != 571 && mapid != 609)
-    {
-        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
-        return;
-    }
-
-    AreaTableEntry const* casterAreaEntry = GetAreaEntryByAreaID(caster->GetZoneId());
-    if (casterAreaEntry && (casterAreaEntry->flags & AREA_FLAG_CAPITAL))
-    {
-        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
-        return;
-    }
-
-    AreaTableEntry const* targetAreaEntry = GetAreaEntryByAreaID(target->GetZoneId());
-    if (targetAreaEntry && (targetAreaEntry->flags & AREA_FLAG_CAPITAL))
-    {
-        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
-        return;
-    }
-
-    //CREATE DUEL FLAG OBJECT
-    GameObject* pGameObj = new GameObject;
-
-    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    Map *map = m_caster->GetMap();
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id,
-        map, m_caster->GetPhaseMask(),
-        m_caster->GetPositionX()+(unitTarget->GetPositionX()-m_caster->GetPositionX())/2 ,
-        m_caster->GetPositionY()+(unitTarget->GetPositionY()-m_caster->GetPositionY())/2 ,
-        m_caster->GetPositionZ(),
-        m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    pGameObj->SetUInt32Value(GAMEOBJECT_FACTION, m_caster->getFaction());
-    pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel()+1);
-    int32 duration = GetSpellDuration(m_spellInfo);
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-    pGameObj->SetSpellId(m_spellInfo->Id);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    m_caster->AddGameObject(pGameObj);
-    map->Add(pGameObj);
-    //END
-
-    // Send request
-    WorldPacket data(SMSG_DUEL_REQUESTED, 8 + 8);
-    data << uint64(pGameObj->GetGUID());
-    data << uint64(caster->GetGUID());
-    caster->GetSession()->SendPacket(&data);
-    target->GetSession()->SendPacket(&data);
-
-    // create duel-info
-    DuelInfo *duel   = new DuelInfo;
-    duel->initiator  = caster;
-    duel->opponent   = target;
-    duel->startTime  = 0;
-    duel->startTimer = 0;
-    caster->duel     = duel;
-
-    DuelInfo *duel2   = new DuelInfo;
-    duel2->initiator  = caster;
-    duel2->opponent   = caster;
-    duel2->startTime  = 0;
-    duel2->startTimer = 0;
-    target->duel      = duel2;
-
-    caster->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
-    target->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
-
-    sScriptMgr.OnPlayerDuelRequest(target, caster);
-}
-
-void Spell::EffectStuck(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (!sWorld.getBoolConfig(CONFIG_CAST_UNSTUCK))
-        return;
-
-    Player* pTarget = (Player*)unitTarget;
-
-    sLog.outDebug("Spell Effect: Stuck");
-    sLog.outDetail("Player %s (guid %u) used auto-unstuck future at map %u (%f, %f, %f)", pTarget->GetName(), pTarget->GetGUIDLow(), m_caster->GetMapId(), m_caster->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ());
-
-    if (pTarget->isInFlight())
-        return;
-
-    pTarget->TeleportTo(pTarget->GetStartPosition(), unitTarget == m_caster ? TELE_TO_SPELL : 0);
-    // homebind location is loaded always
-    // pTarget->TeleportTo(pTarget->m_homebindMapId,pTarget->m_homebindX,pTarget->m_homebindY,pTarget->m_homebindZ,pTarget->GetOrientation(), (unitTarget == m_caster ? TELE_TO_SPELL : 0));
-
-    // Stuck spell trigger Hearthstone cooldown
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(8690);
-    if (!spellInfo)
-        return;
-    Spell spell(pTarget, spellInfo, true, 0);
-    spell.SendSpellCooldown();
-}
-
-void Spell::EffectSummonPlayer(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // Evil Twin (ignore player summon, but hide this for summoner)
-    if (unitTarget->HasAura(23445))
-        return;
-
-    float x, y, z;
-    m_caster->GetClosePoint(x, y, z, unitTarget->GetObjectSize());
-
-    unitTarget->ToPlayer()->SetSummonPoint(m_caster->GetMapId(),x,y,z);
-
-    WorldPacket data(SMSG_SUMMON_REQUEST, 8+4+4);
-    data << uint64(m_caster->GetGUID());                    // summoner guid
-    data << uint32(m_caster->GetZoneId());                  // summoner zone
-    data << uint32(MAX_PLAYER_SUMMON_DELAY*IN_MILLISECONDS); // auto decline after msecs
-    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-static ScriptInfo generateActivateCommand()
-{
-    ScriptInfo si;
-    si.command = SCRIPT_COMMAND_ACTIVATE_OBJECT;
-    return si;
-}
-
-void Spell::EffectActivateObject(SpellEffIndex effIndex)
-{
-    if (!gameObjTarget)
-        return;
-
-    static ScriptInfo activateCommand = generateActivateCommand();
-
-    int32 delay_secs = m_spellInfo->EffectMiscValue[effIndex];
-
-    gameObjTarget->GetMap()->ScriptCommandStart(activateCommand, delay_secs, m_caster, gameObjTarget);
-}
-
-void Spell::EffectApplyGlyph(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER || m_glyphIndex >= MAX_GLYPH_SLOT_INDEX)
-        return;
-
-    Player *player = (Player*)m_caster;
-
-    // glyph sockets level requirement
-    uint8 minLevel = 0;
-    switch (m_glyphIndex)
-    {
-        case 0:
-        case 1: minLevel = 15; break;
-        case 2: minLevel = 50; break;
-        case 3: minLevel = 30; break;
-        case 4: minLevel = 70; break;
-        case 5: minLevel = 80; break;
-    }
-    if (minLevel && m_caster->getLevel() < minLevel)
-    {
-        SendCastResult(SPELL_FAILED_GLYPH_SOCKET_LOCKED);
-        return;
-    }
-
-    // apply new one
-    if (uint32 glyph = m_spellInfo->EffectMiscValue[effIndex])
-    {
-        if (GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(glyph))
-        {
-            if (GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(player->GetGlyphSlot(m_glyphIndex)))
-            {
-                if (gp->TypeFlags != gs->TypeFlags)
-                {
-                    SendCastResult(SPELL_FAILED_INVALID_GLYPH);
-                    return;                                 // glyph slot mismatch
-                }
-            }
-
-            // remove old glyph
-            if (uint32 oldglyph = player->GetGlyph(m_glyphIndex))
-            {
-                if (GlyphPropertiesEntry const *old_gp = sGlyphPropertiesStore.LookupEntry(oldglyph))
-                {
-                    player->RemoveAurasDueToSpell(old_gp->SpellId);
-                    player->SetGlyph(m_glyphIndex, 0);
-                }
-            }
-
-            player->CastSpell(m_caster, gp->SpellId, true);
-            player->SetGlyph(m_glyphIndex, glyph);
-            player->SendTalentsInfoData(false);
-        }
-    }
-}
-
-void Spell::EffectEnchantHeldItem(SpellEffIndex effIndex)
-{
-    // this is only item spell effect applied to main-hand weapon of target player (players in area)
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* item_owner = (Player*)unitTarget;
-    Item* item = item_owner->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
-
-    if (!item)
-        return;
-
-    // must be equipped
-    if (!item ->IsEquipped())
-        return;
-
-    if (m_spellInfo->EffectMiscValue[effIndex])
-    {
-        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-        int32 duration = GetSpellDuration(m_spellInfo);          //Try duration index first ..
-        if (!duration)
-            duration = damage;//+1;            //Base points after ..
-        if (!duration)
-            duration = 10;                                  //10 seconds for enchants which don't have listed duration
-
-        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-        if (!pEnchant)
-            return;
-
-        // Always go to temp enchantment slot
-        EnchantmentSlot slot = TEMP_ENCHANTMENT_SLOT;
-
-        // Enchantment will not be applied if a different one already exists
-        if (item->GetEnchantmentId(slot) && item->GetEnchantmentId(slot) != enchant_id)
-            return;
-
-        // Apply the temporary enchantment
-        item->SetEnchantment(slot, enchant_id, duration*IN_MILLISECONDS, 0);
-        item_owner->ApplyEnchantment(item, slot, true);
-    }
-}
-
-void Spell::EffectDisEnchant(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-    if (!itemTarget || !itemTarget->GetProto()->DisenchantID)
-        return;
-
-    p_caster->UpdateCraftSkill(m_spellInfo->Id);
-
-    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(),LOOT_DISENCHANTING);
-
-    // item will be removed at disenchanting end
-}
-
-void Spell::EffectInebriate(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *player = (Player*)unitTarget;
-    uint16 currentDrunk = player->GetDrunkValue();
-    uint16 drunkMod = damage * 256;
-    if (currentDrunk + drunkMod > 0xFFFF)
-        currentDrunk = 0xFFFF;
-    else
-        currentDrunk += drunkMod;
-    player->SetDrunkValue(currentDrunk, m_CastItem ? m_CastItem->GetEntry() : 0);
-}
-
-void Spell::EffectFeedPet(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)m_caster;
-
-    Item* foodItem = m_targets.getItemTarget();
-    if (!foodItem)
-        return;
-
-    Pet *pet = _player->GetPet();
-    if (!pet)
-        return;
-
-    if (!pet->isAlive())
-        return;
-
-    int32 benefit = pet->GetCurrentFoodBenefitLevel(foodItem->GetProto()->ItemLevel);
-    if (benefit <= 0)
-        return;
-
-    ExecuteLogEffectDestroyItem(effIndex, foodItem->GetEntry());
-
-    uint32 count = 1;
-    _player->DestroyItemCount(foodItem, count, true);
-    // TODO: fix crash when a spell has two effects, both pointed at the same item target
-
-    m_caster->CastCustomSpell(pet, m_spellInfo->EffectTriggerSpell[effIndex], &benefit, NULL, NULL, true);
-}
-
-void Spell::EffectDismissPet(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Pet* pet = m_caster->ToPlayer()->GetPet();
-
-    // not let dismiss dead pet
-    if (!pet||!pet->isAlive())
-        return;
-
-    ExecuteLogEffectUnsummonObject(effIndex, pet);
-    m_caster->ToPlayer()->RemovePet(pet, PET_SAVE_NOT_IN_SLOT);
-}
-
-void Spell::EffectSummonObject(SpellEffIndex effIndex)
-{
-    uint32 go_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    uint8 slot = 0;
-    switch(m_spellInfo->Effect[effIndex])
-    {
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT1: slot = 0; break;
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT2: slot = 1; break;
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT3: slot = 2; break;
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT4: slot = 3; break;
-        default: return;
-    }
-
-    uint64 guid = m_caster->m_ObjectSlot[slot];
-    if (guid != 0)
-    {
-        GameObject* obj = NULL;
-        if (m_caster)
-            obj = m_caster->GetMap()->GetGameObject(guid);
-
-        if (obj)
-        {
-            // Recast case - null spell id to make auras not be removed on object remove from world
-            if (m_spellInfo->Id == obj->GetSpellId())
-                obj->SetSpellId(0);
-            m_caster->RemoveGameObject(obj, true);
-        }
-        m_caster->m_ObjectSlot[slot] = 0;
-    }
-
-    GameObject* pGameObj = new GameObject;
-
-    float x, y, z;
-    // If dest location if present
-    if (m_targets.HasDst())
-        m_targets.m_dstPos.GetPosition(x, y, z);
-    // Summon in random point all other units if location present
-    else
-        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
-
-    Map *map = m_caster->GetMap();
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), go_id, map,
-        m_caster->GetPhaseMask(), x, y, z, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL,m_caster->getLevel());
-    int32 duration = GetSpellDuration(m_spellInfo);
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-    pGameObj->SetSpellId(m_spellInfo->Id);
-    m_caster->AddGameObject(pGameObj);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    map->Add(pGameObj);
-
-    m_caster->m_ObjectSlot[slot] = pGameObj->GetGUID();
-}
-
-void Spell::EffectResurrect(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (unitTarget->isAlive())
-        return;
-    if (!unitTarget->IsInWorld())
-        return;
-
-    switch (m_spellInfo->Id)
-    {
-        // Defibrillate (Goblin Jumper Cables) have 33% chance on success
-        case 8342:
-            if (roll_chance_i(67))
-            {
-                m_caster->CastSpell(m_caster, 8338, true, m_CastItem);
-                return;
-            }
-            break;
-        // Defibrillate (Goblin Jumper Cables XL) have 50% chance on success
-        case 22999:
-            if (roll_chance_i(50))
-            {
-                m_caster->CastSpell(m_caster, 23055, true, m_CastItem);
-                return;
-            }
-            break;
-        // Defibrillate ( Gnomish Army Knife) have 67% chance on success_list
-        case 54732:
-            if (roll_chance_i(33))
-            {
-                return;
-            }
-            break;
-        default:
-            break;
-    }
-
-    Player* pTarget = unitTarget->ToPlayer();
-
-    if (pTarget->isRessurectRequested())       // already have one active request
-        return;
-
-    uint32 health = pTarget->CountPctFromMaxHealth(damage);
-    uint32 mana   = pTarget->GetMaxPower(POWER_MANA) * damage / 100;
-
-    ExecuteLogEffectResurrect(effIndex, pTarget);
-
-    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
-    SendResurrectRequest(pTarget);
-}
-
-void Spell::EffectAddExtraAttacks(SpellEffIndex effIndex)
-{
-    if (!unitTarget || !unitTarget->isAlive() || !unitTarget->getVictim())
-        return;
-
-    if (unitTarget->m_extraAttacks)
-        return;
-
-    unitTarget->m_extraAttacks = damage;
-
-    ExecuteLogEffectExtraAttacks(effIndex, unitTarget->getVictim(), damage);
-}
-
-void Spell::EffectParry(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->SetCanParry(true);
-}
-
-void Spell::EffectBlock(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->SetCanBlock(true);
-}
-
-void Spell::EffectLeap(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->isInFlight())
-        return;
-
-    if (!m_targets.HasDst())
-        return;
-
-    unitTarget->NearTeleportTo(m_targets.m_dstPos.GetPositionX(), m_targets.m_dstPos.GetPositionY(), m_targets.m_dstPos.GetPositionZ(), m_targets.m_dstPos.GetOrientation(), unitTarget == m_caster);
-}
-
-void Spell::EffectReputation(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)unitTarget;
-
-    int32  rep_change = damage;//+1;           // field store reputation change -1
-
-    uint32 faction_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id);
-
-    if (!factionEntry)
-        return;
-
-    if (RepRewardRate const * repData = sObjectMgr.GetRepRewardRate(faction_id))
-    {
-        rep_change = int32((float)rep_change * repData->spell_rate);
-    }
-
-    _player->GetReputationMgr().ModifyReputation(factionEntry, rep_change);
-}
-
-void Spell::EffectQuestComplete(SpellEffIndex effIndex)
-{
-    Player *pPlayer;
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = (Player*)m_caster;
-    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = (Player*)unitTarget;
-    else
-        return;
-
-    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
-    if (quest_id)
-    {
-        uint16 log_slot = pPlayer->FindQuestSlot(quest_id);
-        if (log_slot < MAX_QUEST_LOG_SIZE)
-            pPlayer->AreaExploredOrEventHappens(quest_id);
-        else if (!pPlayer->GetQuestRewardStatus(quest_id))   // never rewarded before
-            pPlayer->CompleteQuest(quest_id);   // quest not in log - for internal use
-    }
-}
-
-void Spell::EffectForceDeselect(SpellEffIndex /*effIndex*/)
-{
-    WorldPacket data(SMSG_CLEAR_TARGET, 8);
-    data << uint64(m_caster->GetGUID());
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::EffectSelfResurrect(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->isAlive())
-        return;
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!unitTarget->IsInWorld())
-        return;
-
-    uint32 health = 0;
-    uint32 mana = 0;
-
-    // flat case
-    if (damage < 0)
-    {
-        health = uint32(-damage);
-        mana = m_spellInfo->EffectMiscValue[effIndex];
-    }
-    // percent case
-    else
-    {
-        health = unitTarget->CountPctFromMaxHealth(damage);
-        if (unitTarget->GetMaxPower(POWER_MANA) > 0)
-            mana = uint32(damage/100.0f*unitTarget->GetMaxPower(POWER_MANA));
-    }
-
-    Player *plr = unitTarget->ToPlayer();
-    plr->ResurrectPlayer(0.0f);
-
-    plr->SetHealth(health);
-    plr->SetPower(POWER_MANA, mana);
-    plr->SetPower(POWER_RAGE, 0);
-    plr->SetPower(POWER_ENERGY, plr->GetMaxPower(POWER_ENERGY));
-
-    plr->SpawnCorpseBones();
-}
-
-void Spell::EffectSkinning(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->GetTypeId() != TYPEID_UNIT)
-        return;
-    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Creature* creature = unitTarget->ToCreature();
-    int32 targetLevel = creature->getLevel();
-
-    uint32 skill = creature->GetCreatureInfo()->GetRequiredLootSkill();
-
-    m_caster->ToPlayer()->SendLoot(creature->GetGUID(),LOOT_SKINNING);
-    creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
-
-    int32 reqValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel-10)*10 : targetLevel*5;
-
-    int32 skillValue = m_caster->ToPlayer()->GetPureSkillValue(skill);
-
-    // Double chances for elites
-    m_caster->ToPlayer()->UpdateGatherSkill(skill, skillValue, reqValue, creature->isElite() ? 2 : 1);
-}
-
-void Spell::EffectCharge(SpellEffIndex /*effIndex*/)
-{
-    Unit *target = m_targets.getUnitTarget();
-    if (!target)
-        return;
-
-    float x, y, z;
-    target->GetContactPoint(m_caster, x, y, z);
-    m_caster->GetMotionMaster()->MoveCharge(x, y, z);
-
-    // not all charge effects used in negative spells
-    if (!IsPositiveSpell(m_spellInfo->Id) && m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->Attack(target, true);
-}
-
-void Spell::EffectChargeDest(SpellEffIndex /*effIndex*/)
-{
-    if (m_targets.HasDst())
-    {
-        float x, y, z;
-        m_targets.m_dstPos.GetPosition(x, y, z);
-        m_caster->GetMotionMaster()->MoveCharge(x, y, z);
-    }
-}
-
-void Spell::EffectKnockBack(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    // Instantly interrupt non melee spells being casted
-    if (unitTarget->IsNonMeleeSpellCasted(true))
-        unitTarget->InterruptNonMeleeSpells(true);
-
-    // Typhoon
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x01000000)
-    {
-        // Glyph of Typhoon
-        if (m_caster->HasAura(62135))
-            return;
-    }
-
-    // Thunderstorm
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[1] & 0x00002000)
-    {
-        // Glyph of Thunderstorm
-        if (m_caster->HasAura(62132))
-            return;
-    }
-
-    float ratio = m_caster->GetCombatReach() / std::max(unitTarget->GetCombatReach(), 1.0f);
-    if (ratio < 1.0f)
-        ratio = ratio * ratio * ratio * 0.1f; // volume = length^3
-    else
-        ratio = 0.1f; // dbc value ratio
-    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex]) * ratio;
-    float speedz = float(damage) * ratio;
-    if (speedxy < 0.1f && speedz < 0.1f)
-        return;
-
-    float x, y;
-    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_KNOCK_BACK_DEST)
-    {
-        if (m_targets.HasDst())
-            m_targets.m_dstPos.GetPosition(x, y);
-        else
-            return;
-    }
-    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_KNOCK_BACK)
-    {
-        m_caster->GetPosition(x, y);
-    }
-
-    unitTarget->KnockbackFrom(x, y, speedxy, speedz);
-}
-
-void Spell::EffectLeapBack(SpellEffIndex effIndex)
-{
-    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex])/10;
-    float speedz = float(damage/10);
-    if (!speedxy)
-    {
-        if (m_targets.getUnitTarget())
-            m_caster->JumpTo(m_targets.getUnitTarget(), speedz);
-    }
-    else
-    {
-        //1891: Disengage
-        m_caster->JumpTo(speedxy, speedz, m_spellInfo->SpellIconID != 1891);
-    }
-}
-
-void Spell::EffectQuestClear(SpellEffIndex effIndex)
-{
-    Player *pPlayer = NULL;
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = m_caster->ToPlayer();
-    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = unitTarget->ToPlayer();
-
-    if (!pPlayer)
-        return;
-
-    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest_id);
-
-    if (!pQuest)
-        return;
-
-    QuestStatusMap::iterator qs_itr = pPlayer->getQuestStatusMap().find(quest_id);
-    // Player has never done this quest
-    if (qs_itr == pPlayer->getQuestStatusMap().end())
-        return;
-
-    // remove all quest entries for 'entry' from quest log
-    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
-    {
-        uint32 quest = pPlayer->GetQuestSlotQuestId(slot);
-        if (quest == quest_id)
-        {
-            pPlayer->SetQuestSlot(slot, 0);
-
-            // we ignore unequippable quest items in this case, its' still be equipped
-            pPlayer->TakeQuestSourceItem(quest, false);
-        }
-    }
-
-    // set quest status to not started (will be updated in DB at next save)
-    pPlayer->SetQuestStatus(quest_id, QUEST_STATUS_NONE);
-
-    // reset rewarded for restart repeatable quest
-    QuestStatusData &data = qs_itr->second;
-    data.m_rewarded = false;
-}
-
-void Spell::EffectSendTaxi(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->ActivateTaxiPathTo(m_spellInfo->EffectMiscValue[effIndex],m_spellInfo->Id);
-}
-
-void Spell::EffectPullTowards(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    float speedZ = (float)(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex) / 10);
-    float speedXY = (float)(m_spellInfo->EffectMiscValue[effIndex]/10);
-    Position pos;
-    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_PULL_TOWARDS_DEST)
-    {
-        if (m_targets.HasDst())
-            pos.Relocate(m_targets.m_dstPos);
-        else
-            return;
-    }
-    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_PULL_TOWARDS)
-    {
-        pos.Relocate(m_caster);
-    }
-
-    unitTarget->GetMotionMaster()->MoveJump(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), speedXY, speedZ);
-}
-
-void Spell::EffectDispelMechanic(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    uint32 mechanic = m_spellInfo->EffectMiscValue[effIndex];
-
-    std::queue < std::pair < uint32, uint64 > > dispel_list;
-
-    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
-    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        Aura * aura = itr->second;
-        if (!aura->GetApplicationOfTarget(unitTarget->GetGUID()))
-            continue;
-        bool success = false;
-        GetDispelChance(aura->GetCaster(), unitTarget, aura->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success);
-        if ((GetAllSpellMechanicMask(aura->GetSpellProto()) & (1 << mechanic)) && success)
-            dispel_list.push(std::make_pair(aura->GetId(), aura->GetCasterGUID()));
-    }
-
-    for (; dispel_list.size(); dispel_list.pop())
-    {
-        unitTarget->RemoveAura(dispel_list.front().first, dispel_list.front().second, 0, AURA_REMOVE_BY_ENEMY_SPELL);
-    }
-}
-
-void Spell::EffectSummonDeadPet(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player *_player = (Player*)m_caster;
-    Pet *pet = _player->GetPet();
-    if (!pet)
-        return;
-    if (pet->isAlive())
-        return;
-    if (damage < 0)
-        return;
-
-    float x,y,z;
-    _player->GetPosition(x, y, z);
-    _player->GetMap()->CreatureRelocation(pet, x, y, z, _player->GetOrientation());
-
-    pet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
-    pet->RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
-    pet->setDeathState(ALIVE);
-    pet->clearUnitState(UNIT_STAT_ALL_STATE);
-    pet->SetHealth(pet->CountPctFromMaxHealth(damage));
-
-    //pet->AIM_Initialize();
-    //_player->PetSpellInitialize();
-    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-}
-
-void Spell::EffectDestroyAllTotems(SpellEffIndex /*effIndex*/)
-{
-    int32 mana = 0;
-    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
-    {
-        if (!m_caster->m_SummonSlot[slot])
-            continue;
-
-        Creature* totem = m_caster->GetMap()->GetCreature(m_caster->m_SummonSlot[slot]);
-        if (totem && totem->isTotem())
-        {
-            uint32 spell_id = totem->GetUInt32Value(UNIT_CREATED_BY_SPELL);
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell_id);
-            if (spellInfo)
-            {
-                mana += spellInfo->manaCost;
-                mana += spellInfo->ManaCostPercentage * m_caster->GetCreateMana() / 100;
-            }
-            totem->ToTotem()->UnSummon();
-        }
-    }
-    mana = mana * damage / 100;
-
-    if (mana)
-        m_caster->CastCustomSpell(m_caster, 39104, &mana, NULL, NULL, true);
-}
-
-void Spell::EffectDurabilityDamage(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
-
-    // FIXME: some spells effects have value -1/-2
-    // Possibly its mean -1 all player equipped items and -2 all items
-    if (slot < 0)
-    {
-        unitTarget->ToPlayer()->DurabilityPointsLossAll(damage, (slot < -1));
-        return;
-    }
-
-    // invalid slot value
-    if (slot >= INVENTORY_SLOT_BAG_END)
-        return;
-
-    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
-        unitTarget->ToPlayer()->DurabilityPointsLoss(item, damage);
-
-    ExecuteLogEffectDurabilityDamage(effIndex, unitTarget, slot, damage);
-}
-
-void Spell::EffectDurabilityDamagePCT(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
-
-    // FIXME: some spells effects have value -1/-2
-    // Possibly its mean -1 all player equipped items and -2 all items
-    if (slot < 0)
-    {
-        unitTarget->ToPlayer()->DurabilityLossAll(double(damage)/100.0f, (slot < -1));
-        return;
-    }
-
-    // invalid slot value
-    if (slot >= INVENTORY_SLOT_BAG_END)
-        return;
-
-    if (damage <= 0)
-        return;
-
-    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
-        unitTarget->ToPlayer()->DurabilityLoss(item, double(damage)/100.0f);
-}
-
-void Spell::EffectModifyThreatPercent(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    unitTarget->getThreatManager().modifyThreatPercent(m_caster, damage);
-}
-
-void Spell::EffectTransmitted(SpellEffIndex effIndex)
-{
-    uint32 name_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(name_id);
-
-    if (!goinfo)
-    {
-        sLog.outErrorDb("Gameobject (Entry: %u) not exist and not created at spell (ID: %u) cast",name_id, m_spellInfo->Id);
-        return;
-    }
-
-    float fx, fy, fz;
-
-    if (m_targets.HasDst())
-        m_targets.m_dstPos.GetPosition(fx, fy, fz);
-    //FIXME: this can be better check for most objects but still hack
-    else if (m_spellInfo->EffectRadiusIndex[effIndex] && m_spellInfo->speed == 0)
-    {
-        float dis = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
-    }
-    else
-    {
-        //GO is always friendly to it's creator, get range for friends
-        float min_dis = GetSpellMinRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
-        float max_dis = GetSpellMaxRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
-        float dis = (float)rand_norm() * (max_dis - min_dis) + min_dis;
-
-        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
-    }
-
-    Map *cMap = m_caster->GetMap();
-    if (goinfo->type == GAMEOBJECT_TYPE_FISHINGNODE)
-    {
-        LiquidData liqData;
-        if ( !cMap->IsInWater(fx, fy, fz + 1.f/* -0.5f */, &liqData))             // Hack to prevent fishing bobber from failing to land on fishing hole
-        { // but this is not proper, we really need to ignore not materialized objects
-            SendCastResult(SPELL_FAILED_NOT_HERE);
-            SendChannelUpdate(0);
-            return;
-        }
-
-        // replace by water level in this case
-        //fz = cMap->GetWaterLevel(fx, fy);
-        fz = liqData.level;
-    }
-    // if gameobject is summoning object, it should be spawned right on caster's position
-    else if (goinfo->type == GAMEOBJECT_TYPE_SUMMONING_RITUAL)
-    {
-        m_caster->GetPosition(fx, fy, fz);
-    }
-
-    GameObject* pGameObj = new GameObject;
-
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), name_id, cMap,
-        m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    int32 duration = GetSpellDuration(m_spellInfo);
-
-    switch(goinfo->type)
-    {
-        case GAMEOBJECT_TYPE_FISHINGNODE:
-        {
-            m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT,pGameObj->GetGUID());
-            m_caster->AddGameObject(pGameObj);              // will removed at spell cancel
-
-            // end time of range when possible catch fish (FISHING_BOBBER_READY_TIME..GetDuration(m_spellInfo))
-            // start time == fish-FISHING_BOBBER_READY_TIME (0..GetDuration(m_spellInfo)-FISHING_BOBBER_READY_TIME)
-            int32 lastSec = 0;
-            switch(urand(0, 3))
-            {
-                case 0: lastSec =  3; break;
-                case 1: lastSec =  7; break;
-                case 2: lastSec = 13; break;
-                case 3: lastSec = 17; break;
-            }
-
-            duration = duration - lastSec*IN_MILLISECONDS + FISHING_BOBBER_READY_TIME*IN_MILLISECONDS;
-            break;
-        }
-        case GAMEOBJECT_TYPE_SUMMONING_RITUAL:
-        {
-            if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            {
-          pGameObj->AddUniqueUse(m_caster->ToPlayer());
-          m_caster->AddGameObject(pGameObj);          // will removed at spell cancel
-            }
-            break;
-        }
-        case GAMEOBJECT_TYPE_DUEL_ARBITER: // 52991
-            m_caster->AddGameObject(pGameObj);
-            break;
-        case GAMEOBJECT_TYPE_FISHINGHOLE:
-        case GAMEOBJECT_TYPE_CHEST:
-        default:
-            break;
-    }
-
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-
-    pGameObj->SetOwnerGUID(m_caster->GetGUID());
-
-    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
-    pGameObj->SetSpellId(m_spellInfo->Id);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    sLog.outStaticDebug("AddObject at SpellEfects.cpp EffectTransmitted");
-    //m_caster->AddGameObject(pGameObj);
-    //m_ObjToDel.push_back(pGameObj);
-
-    cMap->Add(pGameObj);
-
-    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
-    {
-        GameObject* linkedGO = new GameObject;
-        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, cMap,
-            m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-        {
-            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-            //linkedGO->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
-            linkedGO->SetSpellId(m_spellInfo->Id);
-            linkedGO->SetOwnerGUID(m_caster->GetGUID());
-
-            ExecuteLogEffectSummonObject(effIndex, linkedGO);
-
-            linkedGO->GetMap()->Add(linkedGO);
-        }
-        else
-        {
-            delete linkedGO;
-            linkedGO = NULL;
-            return;
-        }
-    }
-}
-
-void Spell::EffectProspecting(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_PROSPECTABLE))
-        return;
-
-    if (itemTarget->GetCount() < 5)
-        return;
-
-    if (sWorld.getBoolConfig(CONFIG_SKILL_PROSPECTING))
-    {
-        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_JEWELCRAFTING);
-        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
-        p_caster->UpdateGatherSkill(SKILL_JEWELCRAFTING, SkillValue, reqSkillValue);
-    }
-
-    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_PROSPECTING);
-}
-
-void Spell::EffectMilling(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_MILLABLE))
-        return;
-
-    if (itemTarget->GetCount() < 5)
-        return;
-
-    if (sWorld.getBoolConfig(CONFIG_SKILL_MILLING))
-    {
-        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_INSCRIPTION);
-        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
-        p_caster->UpdateGatherSkill(SKILL_INSCRIPTION, SkillValue, reqSkillValue);
-    }
-
-    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_MILLING);
-}
-
-void Spell::EffectSkill(SpellEffIndex /*effIndex*/)
-{
-    sLog.outDebug("WORLD: SkillEFFECT");
-}
-
-/* There is currently no need for this effect. We handle it in Battleground.cpp
-   If we would handle the resurrection here, the spiritguide would instantly disappear as the
-   player revives, and so we wouldn't see the spirit heal visual effect on the npc.
-   This is why we use a half sec delay between the visual effect and the resurrection itself */
-void Spell::EffectSpiritHeal(SpellEffIndex /*effIndex*/)
-{
-    /*
-    if (!unitTarget || unitTarget->isAlive())
-        return;
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!unitTarget->IsInWorld())
-        return;
-
-    //m_spellInfo->EffectBasePoints[i]; == 99 (percent?)
-    //unitTarget->ToPlayer()->setResurrect(m_caster->GetGUID(), unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), unitTarget->GetMaxHealth(), unitTarget->GetMaxPower(POWER_MANA));
-    unitTarget->ToPlayer()->ResurrectPlayer(1.0f);
-    unitTarget->ToPlayer()->SpawnCorpseBones();
-    */
-}
-
-// remove insignia spell effect
-void Spell::EffectSkinPlayerCorpse(SpellEffIndex /*effIndex*/)
-{
-    sLog.outDebug("Effect: SkinPlayerCorpse");
-    if ((m_caster->GetTypeId() != TYPEID_PLAYER) || (unitTarget->GetTypeId() != TYPEID_PLAYER) || (unitTarget->isAlive()))
-        return;
-
-    unitTarget->ToPlayer()->RemovedInsignia((Player*)m_caster);
-}
-
-void Spell::EffectStealBeneficialBuff(SpellEffIndex effIndex)
-{
-    sLog.outDebug("Effect: StealBeneficialBuff");
-
-    if (!unitTarget || unitTarget == m_caster)                 // can't steal from self
-        return;
-
-    DispelChargesList steal_list;
-
-    // Create dispel mask by dispel type
-    uint32 dispelMask  = GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[effIndex]));
-    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
-    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        Aura * aura = itr->second;
-        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
-        if (!aurApp)
-            continue;
-
-        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
-        {
-            // Need check for passive? this
-            if (!aurApp->IsPositive() || aura->IsPassive() || aura->GetSpellProto()->AttributesEx4 & SPELL_ATTR_EX4_NOT_STEALABLE)
-                continue;
-
-            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
-            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
-            // Polymorph instead of 1 / (5 + 1) -> 16%.
-            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
-            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
-            if (charges > 0)
-                steal_list.push_back(std::make_pair(aura, charges));
-        }
-    }
-
-    if (steal_list.empty())
-        return;
-
-    // Ok if exist some buffs for dispel try dispel it
-    uint32 failCount = 0;
-    DispelList success_list;
-    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
-    // dispel N = damage buffs (or while exist buffs for dispel)
-    for (int32 count = 0; count < damage && !steal_list.empty();)
-    {
-        // Random select buff for dispel
-        DispelChargesList::iterator itr = steal_list.begin();
-        std::advance(itr, urand(0, steal_list.size() - 1));
-
-        bool success = false;
-        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
-        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
-        {
-            steal_list.erase(itr);
-            continue;
-        }
-        else
-        {
-            if (success)
-            {
-                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
-                --itr->second;
-                if (itr->second <= 0)
-                    steal_list.erase(itr);
-            }
-            else
-            {
-                if (!failCount)
-                {
-                    // Failed to dispell
-                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
-                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
-                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
-                }
-                ++failCount;
-                dataFail << uint32(itr->first->GetId());                         // Spell Id
-            }
-            ++count;
-        }
-    }
-
-    if (failCount)
-        m_caster->SendMessageToSet(&dataFail, true);
-
-    if (success_list.empty())
-        return;
-
-    WorldPacket dataSuccess(SMSG_SPELLSTEALLOG, 8+8+4+1+4+damage*5);
-    dataSuccess.append(unitTarget->GetPackGUID());  // Victim GUID
-    dataSuccess.append(m_caster->GetPackGUID());    // Caster GUID
-    dataSuccess << uint32(m_spellInfo->Id);         // dispel spell id
-    dataSuccess << uint8(0);                        // not used
-    dataSuccess << uint32(success_list.size());     // count
-    for (DispelList::iterator itr = success_list.begin(); itr!=success_list.end(); ++itr)
-    {
-        dataSuccess << uint32(itr->first);          // Spell Id
-        dataSuccess << uint8(0);                    // 0 - steals !=0 transfers
-        unitTarget->RemoveAurasDueToSpellBySteal(itr->first, itr->second, m_caster);
-    }
-    m_caster->SendMessageToSet(&dataSuccess, true);
-}
-
-void Spell::EffectKillCreditPersonal(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->KilledMonsterCredit(m_spellInfo->EffectMiscValue[effIndex], 0);
-}
-
-void Spell::EffectKillCredit(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    int32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
-    if (!creatureEntry)
-    {
-        if (m_spellInfo->Id == 42793) // Burn Body
-            creatureEntry = 24008; // Fallen Combatant
-    }
-
-    if (creatureEntry)
-        unitTarget->ToPlayer()->RewardPlayerAndGroupAtEvent(creatureEntry, unitTarget);
-}
-
-void Spell::EffectQuestFail(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->FailQuest(m_spellInfo->EffectMiscValue[effIndex]);
-}
-
-void Spell::EffectQuestStart(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player * player = unitTarget->ToPlayer();
-    if (Quest const* qInfo = sObjectMgr.GetQuestTemplate(m_spellInfo->EffectMiscValue[effIndex]))
-    {
-        if (player->CanTakeQuest(qInfo, false) && player->CanAddQuest(qInfo, false))
-        {
-            player->AddQuest(qInfo, NULL);
-        }
-    }
-}
-
-void Spell::EffectActivateRune(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *plr = (Player*)m_caster;
-
-    if (plr->getClass() != CLASS_DEATH_KNIGHT)
-        return;
-
-    // needed later
-    m_runesState = m_caster->ToPlayer()->GetRunesState();
-
-    uint32 count = damage;
-    if (count == 0) count = 1;
-    for (uint32 j = 0; j < MAX_RUNES && count > 0; ++j)
-    {
-        if (plr->GetRuneCooldown(j) && plr->GetCurrentRune(j) == RuneType(m_spellInfo->EffectMiscValue[effIndex]))
-        {
-            plr->SetRuneCooldown(j, 0);
-            --count;
-        }
-    }
-    // Empower rune weapon
-    if (m_spellInfo->Id == 47568)
-    {
-        // Need to do this just once
-        if (effIndex != 0)
-            return;
-
-        for (uint32 i = 0; i < MAX_RUNES; ++i)
-        {
-            if (plr->GetRuneCooldown(i) && (plr->GetCurrentRune(i) == RUNE_FROST ||  plr->GetCurrentRune(i) == RUNE_DEATH))
-                plr->SetRuneCooldown(i, 0);
-        }
-    }
-}
-
-void Spell::EffectCreateTamedPet(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || unitTarget->GetPetGUID() || unitTarget->getClass() != CLASS_HUNTER)
-        return;
-
-    uint32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
-    Pet * pet = unitTarget->CreateTamedPetFrom(creatureEntry, m_spellInfo->Id);
-    if (!pet)
-        return;
-
-    // add to world
-    pet->GetMap()->Add(pet->ToCreature());
-
-    // unitTarget has pet now
-    unitTarget->SetMinion(pet, true);
-
-    pet->InitTalentForLevel();
-
-    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
-    {
-        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-        unitTarget->ToPlayer()->PetSpellInitialize();
-    }
-}
-
-void Spell::EffectDiscoverTaxi(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    uint32 nodeid = m_spellInfo->EffectMiscValue[effIndex];
-    if (sTaxiNodesStore.LookupEntry(nodeid))
-        unitTarget->ToPlayer()->GetSession()->SendDiscoverNewTaxiNode(nodeid);
-}
-
-void Spell::EffectTitanGrip(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->SetCanTitanGrip(true);
-}
-
-void Spell::EffectRedirectThreat(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget)
-        m_caster->SetReducedThreatPercent((uint32)damage, unitTarget->GetGUID());
-}
-
-void Spell::EffectWMODamage(SpellEffIndex /*effIndex*/)
-{
-    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        Unit *caster = m_originalCaster;
-        if (!caster)
-            return;
-
-        // Do not allow damage if hp is 0
-        if (gameObjTarget->GetGOValue()->building.health == 0)
-            return;
-
-        FactionTemplateEntry const *casterft, *goft;
-        casterft = caster->getFactionTemplateEntry();
-        goft = sFactionTemplateStore.LookupEntry(gameObjTarget->GetUInt32Value(GAMEOBJECT_FACTION));
-        // Do not allow to damage GO's of friendly factions (ie: Wintergrasp Walls/Ulduar Storm Beacons)
-        if ((casterft && goft && !casterft->IsFriendlyTo(*goft)) || !goft)
-        {
-            gameObjTarget->TakenDamage(uint32(damage), caster);
-            WorldPacket data(SMSG_DESTRUCTIBLE_BUILDING_DAMAGE, 8+8+8+4+4);
-            data.append(gameObjTarget->GetPackGUID());
-            data.append(caster->GetPackGUID());
-            if (Unit *who = caster->GetCharmerOrOwner())
-                data.append(who->GetPackGUID());
-            else
-                data << uint8(0);
-            data << uint32(damage);
-            data << uint32(m_spellInfo->Id);
-            gameObjTarget->SendMessageToSet(&data, false);
-        }
-    }
-}
-
-void Spell::EffectWMORepair(SpellEffIndex /*effIndex*/)
-{
-    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-        gameObjTarget->Rebuild();
-}
-
-void Spell::SummonGuardian(uint32 i, uint32 entry, SummonPropertiesEntry const *properties)
-{
-    Unit *caster = m_originalCaster;
-    if (!caster)
-        return;
-
-    if (caster->isTotem())
-      caster = caster->ToTotem()->GetOwner();
-
-    // in another case summon new
-    uint8 level = caster->getLevel();
-
-    // level of pet summoned using engineering item based at engineering skill level
-    if (m_CastItem && caster->GetTypeId() == TYPEID_PLAYER)
-        if (ItemPrototype const *proto = m_CastItem->GetProto())
-            if (proto->RequiredSkill == SKILL_ENGINERING)
-                if (uint16 skill202 = caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING))
-                    level = skill202/5;
-
-    //float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-    float radius = 5.0f;
-    uint32 amount = damage > 0 ? damage : 1;
-    int32 duration = GetSpellDuration(m_spellInfo);
-    switch (m_spellInfo->Id)
-    {
-        case 1122: // Inferno
-            amount = 1;
-            break;
-        case 49028: // Dancing Rune Weapon
-            if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(63330, 0)) // glyph of Dancing Rune Weapon
-                duration += aurEff->GetAmount();
-            break;
-        case 57879:
-            if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_HUNTER, 69, 2))
-                amount += aurEff->GetAmount();
-            break;
-    }
-    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
-        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
-
-    //TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
-    Map *map = caster->GetMap();
-
-    for (uint32 count = 0; count < amount; ++count)
-    {
-        Position pos;
-        GetSummonPosition(i, pos, radius, count);
-
-        TempSummon *summon = map->SummonCreature(entry, pos, properties, duration, caster);
-        if (!summon)
-            return;
-        if (summon->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
-            ((Guardian*)summon)->InitStatsForLevel(level);
-
-        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-        if (summon->HasUnitTypeMask(UNIT_MASK_MINION) && m_targets.HasDst())
-            ((Minion*)summon)->SetFollowAngle(m_caster->GetAngle(summon));
-
-        if (summon->GetEntry() == 27893)
-        {
-            if (uint32 weapon = m_caster->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID))
-            {
-                summon->SetDisplayId(11686);
-                summon->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, weapon);
-            }
-            else
-                summon->SetDisplayId(1126);
-        }
-
-        summon->AI()->EnterEvadeMode();
-
-        ExecuteLogEffectSummonObject(i, summon);
-    }
-}
-
-void Spell::GetSummonPosition(uint32 i, Position &pos, float radius, uint32 count)
-{
-    pos.SetOrientation(m_caster->GetOrientation());
-
-    if (m_targets.HasDst())
-    {
-        // Summon 1 unit in dest location
-        if (count == 0)
-            pos.Relocate(m_targets.m_dstPos);
-        // Summon in random point all other units if location present
-        else
-        {
-            //This is a workaround. Do not have time to write much about it
-            switch (m_spellInfo->EffectImplicitTargetA[i])
-            {
-                case TARGET_MINION:
-                case TARGET_DEST_CASTER_RANDOM:
-                    m_caster->GetNearPosition(pos, radius * (float)rand_norm(), (float)rand_norm()*static_cast<float>(2*M_PI));
-                    break;
-                case TARGET_DEST_DEST_RANDOM:
-                case TARGET_DEST_TARGET_RANDOM:
-                    m_caster->GetRandomPoint(m_targets.m_dstPos, radius, pos);
-                    break;
-                default:
-                    pos.Relocate(m_targets.m_dstPos);
-                    break;
-            }
-        }
-    }
-    // Summon if dest location not present near caster
-    else
-    {
-        float x, y, z;
-        m_caster->GetClosePoint(x,y,z,3.0f);
-        pos.Relocate(x, y, z);
-    }
-}
-
-void Spell::EffectRenamePet(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT ||
-        !unitTarget->ToCreature()->isPet() || ((Pet*)unitTarget)->getPetType() != HUNTER_PET)
-        return;
-
-    unitTarget->RemoveByteFlag(UNIT_FIELD_BYTES_2, 2, UNIT_CAN_BE_RENAMED);
-}
-
-void Spell::EffectPlayMusic(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    uint32 soundid = m_spellInfo->EffectMiscValue[effIndex];
-
-    if (!sSoundEntriesStore.LookupEntry(soundid))
-    {
-        sLog.outError("EffectPlayMusic: Sound (Id: %u) not exist in spell %u.",soundid,m_spellInfo->Id);
-        return;
-    }
-
-    WorldPacket data(SMSG_PLAY_MUSIC, 4);
-    data << uint32(soundid);
-    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-void Spell::EffectSpecCount(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->UpdateSpecCount(damage);
-}
-
-void Spell::EffectActivateSpec(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->ActivateSpec(damage-1);  // damage is 1 or 2, spec is 0 or 1
-}
-
-void Spell::EffectPlayerNotification(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
-
-    switch(m_spellInfo->Id)
-    {
-        case 58730: // Restricted Flight Area
-           {
-             if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-              {
-              if (pvpWG->isWarTime()==true)
-               {
-                unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
-                unitTarget->PlayDirectSound(9417); // Fel Reaver sound
-                unitTarget->MonsterTextEmote("The air is too thin in Wintergrasp for normal flight. You will be ejected in 9 sec.",unitTarget->GetGUID(),true);
-               break;
-               } else unitTarget->RemoveAura(58730);
-              }
-            break;
-            }
-        case 58600: // Restricted Flight Area
-            unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
-            break;
-    }
-}
-
-void Spell::EffectRemoveAura(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    // there may be need of specifying casterguid of removed auras
-    unitTarget->RemoveAurasDueToSpell(m_spellInfo->EffectTriggerSpell[effIndex]);
-}
-
-void Spell::EffectCastButtons(SpellEffIndex effIndex)
-{
-    if (!unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *p_caster = (Player*)m_caster;
-    uint32 button_id = m_spellInfo->EffectMiscValue[effIndex] + 132;
-    uint32 n_buttons = m_spellInfo->EffectMiscValueB[effIndex];
-
-    for (; n_buttons; n_buttons--, button_id++)
-    {
-        ActionButton const* ab = p_caster->GetActionButton(button_id);
-        if (!ab || ab->GetType() != ACTION_BUTTON_SPELL)
-            continue;
-
-        uint32 spell_id = ab->GetAction();
-        if (!spell_id)
-            continue;
-
-        if (p_caster->HasSpellCooldown(spell_id))
-            continue;
-
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
-        uint32 cost = CalculatePowerCost(spellInfo, m_caster, GetSpellSchoolMask(spellInfo));
-
-        if (m_caster->GetPower(POWER_MANA) < cost)
-            break;
-
-        m_caster->CastSpell(unitTarget, spell_id, true);
-        m_caster->ModifyPower(POWER_MANA, -(int32)cost);
-        p_caster->AddSpellAndCategoryCooldowns(spellInfo, 0);
-    }
-}
-
-void Spell::EffectRechargeManaGem(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *player = m_caster->ToPlayer();
-
-    if (!player)
-        return;
-
-    uint32 item_id = m_spellInfo->EffectItemType[0];
-
-    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item_id);
-    if (!pProto)
-    {
-        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-        return;
-    }
-
-    if (Item* pItem = player->GetItemByEntry(item_id))
-    {
-        for (int x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
-            pItem->SetSpellCharges(x,pProto->Spells[x].SpellCharges);
-        pItem->SetState(ITEM_CHANGED,player);
-    }
-}
-
-void Spell::EffectBind(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* player = (Player*)unitTarget;
-
-    uint32 area_id;
-    WorldLocation loc;
-    if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DST_DB || m_spellInfo->EffectImplicitTargetB[effIndex] == TARGET_DST_DB)
-    {
-        SpellTargetPosition const* st = sSpellMgr.GetSpellTargetPosition(m_spellInfo->Id);
-        if (!st)
-        {
-            sLog.outError( "Spell::EffectBind - unknown teleport coordinates for spell ID %u", m_spellInfo->Id );
-            return;
-        }
-
-        loc.m_mapId         = st->target_mapId;
-        loc.m_positionX   = st->target_X;
-        loc.m_positionY   = st->target_Y;
-        loc.m_positionZ   = st->target_Y;
-        loc.m_orientation = st->target_Orientation;
-        area_id = player->GetAreaId();
-    }
-    else
-    {
-        player->GetPosition(&loc);
-        area_id = player->GetAreaId();
-    }
-
-    player->SetHomebind(loc, area_id);
-
-    // binding
-    WorldPacket data( SMSG_BINDPOINTUPDATE, (4+4+4+4+4) );
-    data << float(loc.m_positionX);
-    data << float(loc.m_positionY);
-    data << float(loc.m_positionZ);
-    data << uint32(loc.m_mapId);
-    data << uint32(area_id);
-    player->SendDirectMessage( &data );
-
-    sLog.outStaticDebug("New homebind X      : %f", loc.m_positionX);
-    sLog.outStaticDebug("New homebind Y      : %f", loc.m_positionY);
-    sLog.outStaticDebug("New homebind Z      : %f", loc.m_positionZ);
-    sLog.outStaticDebug("New homebind MapId  : %u", loc.m_mapId);
-    sLog.outStaticDebug("New homebind AreaId : %u", area_id);
-
-    // zone update
-    data.Initialize(SMSG_PLAYERBOUND, 8+4);
-    data << uint64(player->GetGUID());
-    data << uint32(area_id);
-    player->SendDirectMessage( &data );
-}
+                   }
+                // Glyph of Backstab
+                case 63975:
+                {
+                    if (AuraEffect const * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE,SPELLFAMILY_ROGUE,0x00100000,0,0,m_caster->GetGUID()))
+                    {
+                        uint32 countMin = aurEff->GetBase()->GetMaxDuration();
+                        uint32 countMax = 12000;
+                        countMax += m_caster->HasAura(56801) ? 4000 : 0;
+
+                        if (countMin < countMax)
+                        {
+                            aurEff->GetBase()->SetDuration(uint32(aurEff->GetBase()->GetDuration()+3000));
+                            aurEff->GetBase()->SetMaxDuration(countMin+2000);
+                        }
+
+                    }
+                    return;
+                }            
+                case 69200:                                 // Raging Spirit
+                {
+                    if (!unitTarget)
+                        return;
+
+                    unitTarget->CastSpell(unitTarget, 69201, true);
+                    return;
+                }
+                case 71446:                                 // Twilight Bloodbolt 10N
+                case 71478:                                 // Twilight Bloodbolt 25N
+                case 71479:                                 // Twilight Bloodbolt 10H
+                case 71480:                                 // Twilight Bloodbolt 25H
+                {
+                    if (!unitTarget)
+                        return;
+
+                    uint32 spellId = 71447;
+                    switch (m_spellInfo->Id)
+                    {
+                        case 71478: spellId = 71481; break;
+                        case 71479: spellId = 71482; break;
+                        case 71480: spellId = 71483; break;
+                    }
+                    unitTarget->CastSpell(unitTarget, spellId, true);
+                    return;
+                }
+                case 71899:                                 // Bloodbolt Whirl 10N
+                case 71900:                                 // Bloodbolt Whirl 25N
+                case 71901:                                 // Bloodbolt Whirl 10H
+                case 71902:                                 // Bloodbolt Whirl 25H
+                {
+                    if (!unitTarget)
+                        return;
+
+                    uint32 spellId = 71446;
+                    switch (m_spellInfo->Id)
+                    {
+                        case 71900: spellId = 71478; break;
+                        case 71901: spellId = 71479; break;
+                        case 71902: spellId = 71480; break;
+                    }
+                    m_caster->CastSpell(unitTarget, spellId, true);
+                    return;
+                }
+
+                case 45204: // Clone Me!
+                case 41055: // Copy Weapon
+                case 45206: // Copy Off-hand Weapon
+                    unitTarget->CastSpell(m_caster, damage, false);
+                    break;
+                case 45205: // Copy Offhand Weapon
+                case 41054: // Copy Weapon
+                    m_caster->CastSpell(unitTarget, damage, false);
+                    break;
+                case 55693:                                 // Remove Collapsing Cave Aura
+                    if (!unitTarget)
+                        return;
+                    unitTarget->RemoveAurasDueToSpell(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
+                    break;
+                // PX-238 Winter Wondervolt TRAP
+                case 26275:
+                {
+                    uint32 spells[4] = { 26272, 26157, 26273, 26274 };
+
+                    // check presence
+                    for (uint8 j = 0; j < 4; ++j)
+                        if (unitTarget->HasAuraEffect(spells[j],0))
+                            return;
+
+                    // select spell
+                    uint32 iTmpSpellId = spells[urand(0,3)];
+
+                    // cast
+                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
+                    return;
+                }
+                // Bending Shinbone
+                case 8856:
+                {
+                    if (!itemTarget && m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    uint32 spell_id = 0;
+                    switch(urand(1, 5))
+                    {
+                    case 1:  spell_id = 8854; break;
+                    default: spell_id = 8855; break;
+                    }
+
+                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
+                    return;
+                }
+                // Brittle Armor - need remove one 24575 Brittle Armor aura
+                case 24590:
+                    unitTarget->RemoveAuraFromStack(24575);
+                    return;
+                // Mercurial Shield - need remove one 26464 Mercurial Shield aura
+                case 26465:
+                    unitTarget->RemoveAuraFromStack(26464);
+                    return;
+				case 62575:
+				{
+					if(m_caster->GetOwner())
+						m_caster->GetOwner()->CastSpell(unitTarget,62626,true );
+						return;
+				}
+				case 62960:
+				{
+					if (!unitTarget)
+						return;
+					m_caster->CastSpell(unitTarget,62563,true );
+					m_caster->CastSpell(unitTarget,68321,true );
+					return;
+				}
+				case 62626:
+				case 68321:
+				{
+					if(!unitTarget)
+						return;
+					if (unitTarget->GetAura(62719))
+						unitTarget->RemoveAuraFromStack(62719);
+
+					if(unitTarget->GetAura(64100))
+						unitTarget->RemoveAuraFromStack(64100);
+					return;
+				}
+					// Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
+                case 22539:
+                case 22972:
+                case 22975:
+                case 22976:
+                case 22977:
+                case 22978:
+                case 22979:
+                case 22980:
+                case 22981:
+                case 22982:
+                case 22983:
+                case 22984:
+                case 22985:
+                {
+                    if (!unitTarget || !unitTarget->isAlive())
+                        return;
+
+                    // Onyxia Scale Cloak
+                    if (unitTarget->HasAura(22683))
+                        return;
+
+                    // Shadow Flame
+                    m_caster->CastSpell(unitTarget, 22682, true);
+                    return;
+                }
+                // Piccolo of the Flaming Fire
+                case 17512:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    unitTarget->HandleEmoteCommand(EMOTE_STATE_DANCE);
+                    return;
+                }
+                // Escape artist
+                case 20589:
+                    m_caster->RemoveMovementImpairingAuras();
+                    return;
+                // Decimate
+                case 28374:
+                case 54426:
+                    if (unitTarget)
+                    {
+                        int32 damage = int32(unitTarget->GetHealth()) - int32(unitTarget->CountPctFromMaxHealth(5));
+                        if (damage > 0)
+                            m_caster->CastCustomSpell(28375, SPELLVALUE_BASE_POINT0, damage, unitTarget);
+                    }
+                    return;
+                // Mirren's Drinking Hat
+                case 29830:
+                {
+                    uint32 item = 0;
+                    switch (urand(1, 6))
+                    {
+                        case 1:
+                        case 2:
+                        case 3:
+                            item = 23584; break;            // Loch Modan Lager
+                        case 4:
+                        case 5:
+                            item = 23585; break;            // Stouthammer Lite
+                        case 6:
+                            item = 23586; break;            // Aerie Peak Pale Ale
+                    }
+                    if (item)
+                        DoCreateItem(effIndex,item);
+                    break;
+                }
+                // Improved Sprint
+                case 30918:
+                {
+                    // Removes snares and roots.
+                    unitTarget->RemoveMovementImpairingAuras();
+                    break;
+                }
+                // Spirit Walk
+                case 58876:
+                {
+                    // Removes snares and roots.
+                    unitTarget->RemoveMovementImpairingAuras();
+                    break;
+                }
+                // Plant Warmaul Ogre Banner
+                case 32307:
+                {
+                    Player *p_caster = dynamic_cast<Player*>(m_caster);
+                    if (!p_caster)
+                        break;
+                    p_caster->RewardPlayerAndGroupAtEvent(18388, unitTarget);
+                    Creature *cTarget = dynamic_cast<Creature*>(unitTarget);
+                    if (!cTarget)
+                        break;
+                    cTarget->setDeathState(CORPSE);
+                    cTarget->RemoveCorpse();
+                    break;
+                }
+                case 48025:                                     // Headless Horseman's Mount
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 51621, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 48024, true); break;
+                    case 225:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 51617, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 48024, true);
+                        }break;
+                    case 300:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 48023, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 48024, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 47977:                                     // Magic Broom
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 42680, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 42683, true); break;
+                    case 225:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 42667, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 42683, true);
+                        }break;
+                    case 300:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 42668, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 42683, true);
+                        }break;
+                    }
+                    return;
+                }
+                // Mug Transformation
+                case 41931:
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    uint8 bag = 19;
+                    uint8 slot = 0;
+                    Item *item = NULL;
+
+                    while (bag) // 256 = 0 due to var type
+                    {
+                        item = m_caster->ToPlayer()->GetItemByPos(bag, slot);
+                        if (item && item->GetEntry() == 38587) break;
+                        ++slot;
+                        if (slot == 39)
+                        {
+                            slot = 0;
+                            ++bag;
+                        }
+                    }
+                    if (bag)
+                    {
+                        if (m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount() == 1) m_caster->ToPlayer()->RemoveItem(bag,slot,true);
+                        else m_caster->ToPlayer()->GetItemByPos(bag,slot)->SetCount(m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount()-1);
+                        // Spell 42518 (Braufest - Gratisprobe des Braufest herstellen)
+                        m_caster->CastSpell(m_caster, 42518, true);
+                        return;
+                    }
+                    break;
+                }
+                // Brutallus - Burn
+                case 45141:
+                case 45151:
+                {
+                    //Workaround for Range ... should be global for every ScriptEffect
+                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+                    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER && unitTarget->GetDistance(m_caster) >= radius && !unitTarget->HasAura(46394) && unitTarget != m_caster)
+                        unitTarget->CastSpell(unitTarget, 46394, true);
+
+                    break;
+                }
+                // Goblin Weather Machine
+                case 46203:
+                {
+                    if (!unitTarget)
+                        return;
+
+                    uint32 spellId = 0;
+                    switch(rand() % 4)
+                    {
+                        case 0: spellId = 46740; break;
+                        case 1: spellId = 46739; break;
+                        case 2: spellId = 46738; break;
+                        case 3: spellId = 46736; break;
+                    }
+                    unitTarget->CastSpell(unitTarget, spellId, true);
+                    break;
+                }
+                // 5,000 Gold
+                case 46642:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    unitTarget->ToPlayer()->ModifyMoney(5000 * GOLD);
+
+                    break;
+                }
+                // Roll Dice - Decahedral Dwarven Dice
+                case 47770:
+                {
+                    char buf[128];
+                    const char *gender = "his";
+                    if (m_caster->getGender() > 0)
+                        gender = "her";
+                    sprintf(buf, "%s rubs %s [Decahedral Dwarven Dice] between %s hands and rolls. One %u and one %u.", m_caster->GetName(), gender, gender, urand(1,10), urand(1,10));
+                    m_caster->MonsterTextEmote(buf, 0);
+                    break;
+                }
+                // Roll 'dem Bones - Worn Troll Dice
+                case 47776:
+                {
+                    char buf[128];
+                    const char *gender = "his";
+                    if (m_caster->getGender() > 0)
+                        gender = "her";
+                    sprintf(buf, "%s causually tosses %s [Worn Troll Dice]. One %u and one %u.", m_caster->GetName(), gender, urand(1,6), urand(1,6));
+                    m_caster->MonsterTextEmote(buf, 0);
+                    break;
+                }
+                // Vigilance
+                case 50725:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Remove Taunt cooldown
+                    unitTarget->ToPlayer()->RemoveSpellCooldown(355, true);
+
+                    return;
+                }
+                // Death Knight Initiate Visual
+                case 51519:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    uint32 iTmpSpellId = 0;
+                    switch (unitTarget->GetDisplayId())
+                    {
+                        case 25369: iTmpSpellId = 51552; break; // bloodelf female
+                        case 25373: iTmpSpellId = 51551; break; // bloodelf male
+                        case 25363: iTmpSpellId = 51542; break; // draenei female
+                        case 25357: iTmpSpellId = 51541; break; // draenei male
+                        case 25361: iTmpSpellId = 51537; break; // dwarf female
+                        case 25356: iTmpSpellId = 51538; break; // dwarf male
+                        case 25372: iTmpSpellId = 51550; break; // forsaken female
+                        case 25367: iTmpSpellId = 51549; break; // forsaken male
+                        case 25362: iTmpSpellId = 51540; break; // gnome female
+                        case 25359: iTmpSpellId = 51539; break; // gnome male
+                        case 25355: iTmpSpellId = 51534; break; // human female
+                        case 25354: iTmpSpellId = 51520; break; // human male
+                        case 25360: iTmpSpellId = 51536; break; // nightelf female
+                        case 25358: iTmpSpellId = 51535; break; // nightelf male
+                        case 25368: iTmpSpellId = 51544; break; // orc female
+                        case 25364: iTmpSpellId = 51543; break; // orc male
+                        case 25371: iTmpSpellId = 51548; break; // tauren female
+                        case 25366: iTmpSpellId = 51547; break; // tauren male
+                        case 25370: iTmpSpellId = 51545; break; // troll female
+                        case 25365: iTmpSpellId = 51546; break; // troll male
+                        default: return;
+                    }
+
+                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
+                    Creature* npc = unitTarget->ToCreature();
+                    npc->LoadEquipment(npc->GetEquipmentId());
+                    return;
+                }
+                // Emblazon Runeblade
+                case 51770:
+                {
+                    if (!m_originalCaster)
+                        return;
+
+                    m_originalCaster->CastSpell(m_originalCaster, damage, false);
+                    break;
+                }
+                // Deathbolt from Thalgran Blightbringer
+                // reflected by Freya's Ward
+                // Retribution by Sevenfold Retribution
+                case 51854:
+                {
+                    if (!m_caster || !unitTarget)
+                        return;
+                    if (unitTarget->HasAura(51845))
+                        unitTarget->CastSpell(m_caster, 51856, true);
+                    else
+                        m_caster->CastSpell(unitTarget, 51855, true);
+                    break;
+                }
+                // Summon Ghouls On Scarlet Crusade
+                case 51904:
+                {
+                    if (!m_targets.HasDst())
+                        return;
+
+                    float x, y, z;
+                    float radius = GetSpellRadius(m_spellInfo, effIndex, true);
+                    for (uint8 i = 0; i < 15; ++i)
+                    {
+                        m_caster->GetRandomPoint(m_targets.m_dstPos, radius, x, y, z);
+                        m_caster->CastSpell(x, y, z, 54522, true);
+                    }
+                    break;
+                }
+                case 52173: // Coyote Spirit Despawn
+                case 60243: // Blood Parrot Despawn
+                    if (unitTarget->GetTypeId() == TYPEID_UNIT && unitTarget->ToCreature()->isSummon())
+                        unitTarget->ToTempSummon()->UnSummon();
+                    return;
+                case 52479: // Gift of the Harvester
+                    if (unitTarget && m_originalCaster)
+                        m_originalCaster->CastSpell(unitTarget, urand(0, 1) ? damage : 52505, true);
+                    return;
+                // Death Gate
+                case 52751:
+                {
+                    if (!unitTarget || unitTarget->getClass() != CLASS_DEATH_KNIGHT)
+                        return;
+                    // triggered spell is stored in m_spellInfo->EffectBasePoints[0]
+                    unitTarget->CastSpell(unitTarget, damage, false);
+                    break;
+                }
+                case 53110: // Devour Humanoid
+                    if (unitTarget)
+                        unitTarget->CastSpell(m_caster, damage, true);
+                    return;
+                // Winged Steed of the Ebon Blade
+                case 54729:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 300)
+                            unitTarget->CastSpell(unitTarget, 54727, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 54726, true);
+                    }
+                    return;
+                }
+                case 58418:                                 // Portal to Orgrimmar
+                case 58420:                                 // Portal to Stormwind
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || effIndex != 0)
+                        return;
+
+                    uint32 spellID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0);
+                    uint32 questID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
+
+                    if (unitTarget->ToPlayer()->GetQuestStatus(questID) == QUEST_STATUS_COMPLETE && !unitTarget->ToPlayer()->GetQuestRewardStatus (questID))
+                        unitTarget->CastSpell(unitTarget, spellID, true);
+
+                    return;
+                }
+                case 58941:                                 // Rock Shards
+                    if (unitTarget && m_originalCaster)
+                    {
+                        for (uint32 i = 0; i < 3; ++i)
+                        {
+                            m_originalCaster->CastSpell(unitTarget, 58689, true);
+                            m_originalCaster->CastSpell(unitTarget, 58692, true);
+                        }
+                        if (((InstanceMap*)m_originalCaster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY)
+                        {
+                            m_originalCaster->CastSpell(unitTarget, 58695, true);
+                            m_originalCaster->CastSpell(unitTarget, 58696, true);
+                        }
+                        else
+                        {
+                            m_originalCaster->CastSpell(unitTarget, 60883, true);
+                            m_originalCaster->CastSpell(unitTarget, 60884, true);
+                        }
+                    }
+                    return;
+                case 58983: // Big Blizzard Bear
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 150)
+                            unitTarget->CastSpell(unitTarget, 58999, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 58997, true);
+                    }
+                    return;
+                }
+                case 63845: // Create Lance
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+			{
+                        m_caster->CastSpell(m_caster, 63914, true);
+			DoCreateItem(0,46069);
+			}
+                    else
+			{
+                        DoCreateItem(0,46070);
+			m_caster->CastSpell(m_caster, 63919, true);
+			}
+                    return;
+                }
+                case 62705:
+                {
+ 	                if (!unitTarget->isInCombat())
+ 	                    unitTarget->SetHealth(unitTarget->GetMaxHealth());
+                }
+                case 71342:                                     // Big Love Rocket
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 0: unitTarget->CastSpell(unitTarget, 71343, true); break;
+                    case 75: unitTarget->CastSpell(unitTarget, 71344, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 71345, true); break;
+                    case 225:
+                        {
+                        if (canFly)
+                                unitTarget->CastSpell(unitTarget, 71346, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 71345, true);
+                        }break;
+                    case 300:
+                        {
+                        if (canFly)
+                            unitTarget->CastSpell(unitTarget, 71347, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 71345, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 72286:                                     // Invincible
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 72281, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 72282, true); break;
+                    case 225:
+                        {
+                        if (canFly)
+                                unitTarget->CastSpell(unitTarget, 72283, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 72282, true);
+                        }break;
+                    case 300:
+                        {
+                        if (canFly)
+                            unitTarget->CastSpell(unitTarget, 72284, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 72282, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 74856:                                     // Blazing Hippogryph
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 300)
+                            unitTarget->CastSpell(unitTarget, 74855, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 74854, true);
+                    }
+                    return;
+                }
+                case 75614:                                     // Celestial Steed
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 75619, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 75620, true); break;
+                    case 225:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 75617, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 75620, true);
+                        }break;
+                    case 300:
+                        {
+                            if (canFly)
+                            {
+                                if (unitTarget->ToPlayer()->Has310Flyer(false))
+                                    unitTarget->CastSpell(unitTarget, 76153, true);
+                                else
+                                    unitTarget->CastSpell(unitTarget, 75618, true);
+                            }
+                            else
+                                unitTarget->CastSpell(unitTarget, 75620, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 75973:                                     // X-53 Touring Rocket
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 300)
+                        {
+                            if (unitTarget->ToPlayer()->Has310Flyer(false))
+                                unitTarget->CastSpell(unitTarget, 76154, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 75972, true);
+                        }
+                        else
+                            unitTarget->CastSpell(unitTarget, 75957, true);
+                    }
+                    return;
+                }
+                case 59317:                                 // Teleporting
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // return from top
+                    if (unitTarget->ToPlayer()->GetAreaId() == 4637)
+                        unitTarget->CastSpell(unitTarget, 59316, true);
+                    // teleport atop
+                    else
+                        unitTarget->CastSpell(unitTarget, 59314, true);
+
+                    return;
+                // random spell learn instead placeholder
+                case 60893:                                 // Northrend Alchemy Research
+                case 61177:                                 // Northrend Inscription Research
+                case 61288:                                 // Minor Inscription Research
+                case 61756:                                 // Northrend Inscription Research (FAST QA VERSION)
+                case 64323:                                 // Book of Glyph Mastery
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // learn random explicit discovery recipe (if any)
+                    if (uint32 discoveredSpell = GetExplicitDiscoverySpell(m_spellInfo->Id, (Player*)m_caster))
+                        m_caster->ToPlayer()->learnSpell(discoveredSpell, false);
+                    return;
+                }
+                case 62428: // Load into Catapult
+                {
+                    if (Vehicle *seat = m_caster->GetVehicleKit())
+                        if (Unit *passenger = seat->GetPassenger(0))
+                            if (Unit *demolisher = m_caster->GetVehicleBase())
+                                passenger->CastSpell(demolisher, damage, true);
+                    return;
+                }
+                case 62482: // Grab Crate
+                {
+                    if (unitTarget)
+                    {
+                        if (Vehicle *seat = m_caster->GetVehicleKit())
+                        {
+                            if (Creature *oldContainer = dynamic_cast<Creature*>(seat->GetPassenger(1)))
+                                oldContainer->DisappearAndDie();
+                            // TODO: a hack, range = 11, should after some time cast, otherwise too far
+                            unitTarget->CastSpell(seat->GetBase(), 62496, true);
+                            unitTarget->EnterVehicle(seat, 1);
+                        }
+                    }
+                    return;
+                }
+                case 60123: // Lightwell
+                {
+                    if (m_caster->GetTypeId() != TYPEID_UNIT || !m_caster->ToCreature()->isSummon())
+                        return;
+
+                    uint32 spell_heal;
+
+                    switch(m_caster->GetEntry())
+                    {
+                        case 31897: spell_heal = 7001; break;
+                        case 31896: spell_heal = 27873; break;
+                        case 31895: spell_heal = 27874; break;
+                        case 31894: spell_heal = 28276; break;
+                        case 31893: spell_heal = 48084; break;
+                        case 31883: spell_heal = 48085; break;
+                        default:
+                            sLog.outError("Unknown Lightwell spell caster %u", m_caster->GetEntry());
+                            return;
+                    }
+                    Aura * chargesaura = m_caster->GetAura(59907);
+
+                    if (chargesaura && chargesaura->GetCharges() > 1)
+                    {
+                        chargesaura->SetCharges(chargesaura->GetCharges() - 1);
+                        m_caster->CastSpell(unitTarget, spell_heal, true, NULL, NULL, m_caster->ToTempSummon()->GetSummonerGUID());
+                    }
+                    else
+                        m_caster->ToTempSummon()->UnSummon();
+                    return;
+                }
+                // Stoneclaw Totem
+                case 55328: // Rank 1
+                case 55329: // Rank 2
+                case 55330: // Rank 3
+                case 55332: // Rank 4
+                case 55333: // Rank 5
+                case 55335: // Rank 6
+                case 55278: // Rank 7
+                case 58589: // Rank 8
+                case 58590: // Rank 9
+                case 58591: // Rank 10
+                {
+                    int32 basepoints0 = damage;
+                    // Cast Absorb on totems
+                    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
+                    {
+                        if (!unitTarget->m_SummonSlot[slot])
+                            continue;
+
+                        Creature* totem = unitTarget->GetMap()->GetCreature(unitTarget->m_SummonSlot[slot]);
+                        if (totem && totem->isTotem())
+                        {
+                            m_caster->CastCustomSpell(totem, 55277, &basepoints0, NULL, NULL, true);
+                        }
+                    }
+                    // Glyph of Stoneclaw Totem
+                    if (AuraEffect *aur=unitTarget->GetAuraEffect(63298, 0))
+                    {
+                        basepoints0 *= aur->GetAmount();
+                        m_caster->CastCustomSpell(unitTarget, 55277, &basepoints0, NULL, NULL, true);
+                    }
+                    break;
+                }
+                case 66545: //Summon Memory
+                {
+                    uint8 uiRandom = urand(0,25);
+                    uint32 uiSpells[26] = {66704,66705,66706,66707,66709,66710,66711,66712,66713,66714,66715,66708,66708,66691,66692,66694,66695,66696,66697,66698,66699,66700,66701,66702,66703,66543};
+
+                    m_caster->CastSpell(m_caster,uiSpells[uiRandom],true);
+                    break;
+                }
+                case 45668:                                 // Ultra-Advanced Proto-Typical Shortening Blaster
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    if (roll_chance_i(50))                  // chance unknown, using 50
+                        return;
+
+                    static uint32 const spellPlayer[5] =
+                    {
+                        45674,                            // Bigger!
+                        45675,                            // Shrunk
+                        45678,                            // Yellow
+                        45682,                            // Ghost
+                        45684                             // Polymorph
+                    };
+
+                    static uint32 const spellTarget[5] = {
+                        45673,                            // Bigger!
+                        45672,                            // Shrunk
+                        45677,                            // Yellow
+                        45681,                            // Ghost
+                        45683                             // Polymorph
+                    };
+
+                    m_caster->CastSpell(m_caster, spellPlayer[urand(0,4)], true);
+                    unitTarget->CastSpell(unitTarget, spellTarget[urand(0,4)], true);
+                    break;
+                }
+                case 64142:                                 // Upper Deck - Create Foam Sword
+		{
+                    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    Player *plr = unitTarget->ToPlayer();
+                    static uint32 const itemId[] = {45061, 45176, 45177, 45178, 45179, 0};
+                    // player can only have one of these items
+                    for (uint32 const *itr = &itemId[0]; *itr; ++itr)
+                        if (plr->HasItemCount(*itr, 1, true))
+                            return;
+                    DoCreateItem(effIndex, itemId[urand(0,4)]);
+                    return;
+		}
+            }
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Judgement (seal trigger)
+            if (m_spellInfo->Category == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (!unitTarget || !unitTarget->isAlive())
+                    return;
+                uint32 spellId1 = 0;
+                uint32 spellId2 = 0;
+                uint32 spellId3 = 0;
+
+                // Judgement self add switch
+                switch (m_spellInfo->Id)
+                {
+                    case 53407: spellId1 = 20184; break;    // Judgement of Justice
+                    case 20271:                             // Judgement of Light
+                    case 57774: spellId1 = 20185; break;    // Judgement of Light
+                    case 53408: spellId1 = 20186; break;    // Judgement of Wisdom
+                    default:
+                        sLog.outError("Unsupported Judgement (seal trigger) spell (Id: %u) in Spell::EffectScriptEffect",m_spellInfo->Id);
+                        return;
+                }
+                // all seals have aura dummy in 2 effect
+                Unit::AuraApplicationMap & sealAuras = m_caster->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::iterator iter = sealAuras.begin(); iter != sealAuras.end();)
+                {
+                    switch (iter->first)
+                    {
+                        // Heart of the Crusader
+                        case 20335: // Rank 1
+                            spellId3 = 21183;
+                            break;
+                        case 20336: // Rank 2
+                            spellId3 = 54498;
+                            break;
+                        case 20337: // Rank 3
+                            spellId3 = 54499;
+                            break;
+                    }
+                    Aura * aura = iter->second->GetBase();
+                    if (IsSealSpell(aura->GetSpellProto()))
+                    {
+                        if (AuraEffect * aureff = aura->GetEffect(2))
+                            if (aureff->GetAuraType() == SPELL_AURA_DUMMY)
+                            {
+                                if (sSpellStore.LookupEntry(aureff->GetAmount()))
+                                    spellId2 = aureff->GetAmount();
+                                break;
+                            }
+                        if (!spellId2)
+                        {
+                            switch (iter->first)
+                            {
+                                // Seal of light, Seal of wisdom, Seal of justice
+                                case 20165:
+                                case 20166:
+                                case 20164:
+                                    spellId2 = 54158;
+                            }
+                        }
+                        break;
+                    }
+                    else
+                        ++iter;
+                }
+                if (spellId1)
+                    m_caster->CastSpell(unitTarget, spellId1, true);
+                if (spellId2)
+                    m_caster->CastSpell(unitTarget, spellId2, true);
+                if (spellId3)
+                    m_caster->CastSpell(unitTarget, spellId3, true);
+                return;
+            }
+        }
+        case SPELLFAMILY_POTION:
+        {
+            switch(m_spellInfo->Id)
+            {
+                // Netherbloom
+                case 28702:
+                {
+                    if (!unitTarget)
+                        return;
+                    // 25% chance of casting a random buff
+                    if (roll_chance_i(75))
+                        return;
+
+                    // triggered spells are 28703 to 28707
+                    // Note: some sources say, that there was the possibility of
+                    //       receiving a debuff. However, this seems to be removed by a patch.
+                    const uint32 spellid = 28703;
+
+                    // don't overwrite an existing aura
+                    for (uint8 i = 0; i < 5; ++i)
+                        if (unitTarget->HasAura(spellid + i))
+                            return;
+                    unitTarget->CastSpell(unitTarget, spellid+urand(0, 4), true);
+                    break;
+                }
+
+                // Nightmare Vine
+                case 28720:
+                {
+                    if (!unitTarget)
+                        return;
+                    // 25% chance of casting Nightmare Pollen
+                    if (roll_chance_i(75))
+                        return;
+                    unitTarget->CastSpell(unitTarget, 28721, true);
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Pestilence
+            if (m_spellInfo->SpellFamilyFlags[1]&0x10000)
+            {
+                // Get diseases on target of spell
+                if (m_targets.getUnitTarget() &&  // Glyph of Disease - cast on unit target too to refresh aura
+                    (m_targets.getUnitTarget() != unitTarget || m_caster->GetAura(63334)))
+                {
+                    // And spread them on target
+                    // Blood Plague
+                    if (m_targets.getUnitTarget()->GetAura(55078))
+                        m_caster->CastSpell(unitTarget, 55078, true);
+                    // Frost Fever
+                    if (m_targets.getUnitTarget()->GetAura(55095))
+                        m_caster->CastSpell(unitTarget, 55095, true);
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            // Shattering Throw
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x00400000)
+            {
+                if (!unitTarget)
+                    return;
+                // remove shields, will still display immune to damage part
+                unitTarget->RemoveAurasWithMechanic(1<<MECHANIC_IMMUNE_SHIELD, AURA_REMOVE_BY_ENEMY_SPELL);
+                return;
+            }
+            break;
+        }
+    }
+
+    // normal DB scripted effect
+    sLog.outDebug("Spell ScriptStart spellid %u in EffectScriptEffect(%u)", m_spellInfo->Id, effIndex);
+    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
+}
+
+void Spell::EffectSanctuary(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    std::list<Unit*> targets;
+    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(unitTarget, unitTarget, m_caster->GetMap()->GetVisibilityDistance());
+    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(unitTarget, targets, u_check);
+    unitTarget->VisitNearbyObject(m_caster->GetMap()->GetVisibilityDistance(), searcher);
+    for (std::list<Unit*>::iterator iter = targets.begin(); iter != targets.end(); ++iter)
+    {
+        if (!(*iter)->hasUnitState(UNIT_STAT_CASTING))
+            continue;
+
+        for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
+        {
+            if ((*iter)->GetCurrentSpell(i)
+            && (*iter)->GetCurrentSpell(i)->m_targets.getUnitTargetGUID() == unitTarget->GetGUID())
+            {
+                (*iter)->InterruptSpell(CurrentSpellTypes(i), false);
+            }
+        }
+    }
+
+    unitTarget->CombatStop();
+    unitTarget->getHostileRefManager().deleteReferences();   // stop all fighting
+    // Vanish allows to remove all threat and cast regular stealth so other spells can be used
+    if (m_caster->GetTypeId() == TYPEID_PLAYER
+        && m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE
+        && (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_ROGUE_VANISH))
+    {
+        
+        // Overkill
+        if (m_caster->ToPlayer()->HasSpell(58426))
+           m_caster->CastSpell(m_caster, 58427, true);
+    }
+}
+
+void Spell::EffectAddComboPoints(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    if (!m_caster->m_movedPlayer)
+        return;
+
+    if (damage <= 0)
+        return;
+
+    m_caster->m_movedPlayer->AddComboPoints(unitTarget, damage, this);
+}
+
+void Spell::EffectDuel(SpellEffIndex effIndex)
+{
+    if (!m_caster || !unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *caster = (Player*)m_caster;
+    Player *target = (Player*)unitTarget;
+
+    // caster or target already have requested duel
+    if (caster->duel || target->duel || !target->GetSocial() || target->GetSocial()->HasIgnore(caster->GetGUIDLow()))
+        return;
+
+    // Players can only fight a duel with each other outside (=not inside dungeons and not in capital cities)
+    // Don't have to check the target's map since you cannot challenge someone across maps
+    if (caster->GetMap()->Instanceable())
+    //if (mapid != 0 && mapid != 1 && mapid != 530 && mapid != 571 && mapid != 609)
+    {
+        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
+        return;
+    }
+
+    AreaTableEntry const* casterAreaEntry = GetAreaEntryByAreaID(caster->GetZoneId());
+    if (casterAreaEntry && (casterAreaEntry->flags & AREA_FLAG_CAPITAL))
+    {
+        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
+        return;
+    }
+
+    AreaTableEntry const* targetAreaEntry = GetAreaEntryByAreaID(target->GetZoneId());
+    if (targetAreaEntry && (targetAreaEntry->flags & AREA_FLAG_CAPITAL))
+    {
+        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
+        return;
+    }
+
+    //CREATE DUEL FLAG OBJECT
+    GameObject* pGameObj = new GameObject;
+
+    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    Map *map = m_caster->GetMap();
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id,
+        map, m_caster->GetPhaseMask(),
+        m_caster->GetPositionX()+(unitTarget->GetPositionX()-m_caster->GetPositionX())/2 ,
+        m_caster->GetPositionY()+(unitTarget->GetPositionY()-m_caster->GetPositionY())/2 ,
+        m_caster->GetPositionZ(),
+        m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    pGameObj->SetUInt32Value(GAMEOBJECT_FACTION, m_caster->getFaction());
+    pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel()+1);
+    int32 duration = GetSpellDuration(m_spellInfo);
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+    pGameObj->SetSpellId(m_spellInfo->Id);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    m_caster->AddGameObject(pGameObj);
+    map->Add(pGameObj);
+    //END
+
+    // Send request
+    WorldPacket data(SMSG_DUEL_REQUESTED, 8 + 8);
+    data << uint64(pGameObj->GetGUID());
+    data << uint64(caster->GetGUID());
+    caster->GetSession()->SendPacket(&data);
+    target->GetSession()->SendPacket(&data);
+
+    // create duel-info
+    DuelInfo *duel   = new DuelInfo;
+    duel->initiator  = caster;
+    duel->opponent   = target;
+    duel->startTime  = 0;
+    duel->startTimer = 0;
+    caster->duel     = duel;
+
+    DuelInfo *duel2   = new DuelInfo;
+    duel2->initiator  = caster;
+    duel2->opponent   = caster;
+    duel2->startTime  = 0;
+    duel2->startTimer = 0;
+    target->duel      = duel2;
+
+    caster->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
+    target->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
+
+    sScriptMgr.OnPlayerDuelRequest(target, caster);
+}
+
+void Spell::EffectStuck(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (!sWorld.getBoolConfig(CONFIG_CAST_UNSTUCK))
+        return;
+
+    Player* pTarget = (Player*)unitTarget;
+
+    sLog.outDebug("Spell Effect: Stuck");
+    sLog.outDetail("Player %s (guid %u) used auto-unstuck future at map %u (%f, %f, %f)", pTarget->GetName(), pTarget->GetGUIDLow(), m_caster->GetMapId(), m_caster->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ());
+
+    if (pTarget->isInFlight())
+        return;
+
+    pTarget->TeleportTo(pTarget->GetStartPosition(), unitTarget == m_caster ? TELE_TO_SPELL : 0);
+    // homebind location is loaded always
+    // pTarget->TeleportTo(pTarget->m_homebindMapId,pTarget->m_homebindX,pTarget->m_homebindY,pTarget->m_homebindZ,pTarget->GetOrientation(), (unitTarget == m_caster ? TELE_TO_SPELL : 0));
+
+    // Stuck spell trigger Hearthstone cooldown
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(8690);
+    if (!spellInfo)
+        return;
+    Spell spell(pTarget, spellInfo, true, 0);
+    spell.SendSpellCooldown();
+}
+
+void Spell::EffectSummonPlayer(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // Evil Twin (ignore player summon, but hide this for summoner)
+    if (unitTarget->HasAura(23445))
+        return;
+
+    float x, y, z;
+    m_caster->GetClosePoint(x, y, z, unitTarget->GetObjectSize());
+
+    unitTarget->ToPlayer()->SetSummonPoint(m_caster->GetMapId(),x,y,z);
+
+    WorldPacket data(SMSG_SUMMON_REQUEST, 8+4+4);
+    data << uint64(m_caster->GetGUID());                    // summoner guid
+    data << uint32(m_caster->GetZoneId());                  // summoner zone
+    data << uint32(MAX_PLAYER_SUMMON_DELAY*IN_MILLISECONDS); // auto decline after msecs
+    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+static ScriptInfo generateActivateCommand()
+{
+    ScriptInfo si;
+    si.command = SCRIPT_COMMAND_ACTIVATE_OBJECT;
+    return si;
+}
+
+void Spell::EffectActivateObject(SpellEffIndex effIndex)
+{
+    if (!gameObjTarget)
+        return;
+
+    static ScriptInfo activateCommand = generateActivateCommand();
+
+    int32 delay_secs = m_spellInfo->EffectMiscValue[effIndex];
+
+    gameObjTarget->GetMap()->ScriptCommandStart(activateCommand, delay_secs, m_caster, gameObjTarget);
+}
+
+void Spell::EffectApplyGlyph(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER || m_glyphIndex >= MAX_GLYPH_SLOT_INDEX)
+        return;
+
+    Player *player = (Player*)m_caster;
+
+    // glyph sockets level requirement
+    uint8 minLevel = 0;
+    switch (m_glyphIndex)
+    {
+        case 0:
+        case 1: minLevel = 15; break;
+        case 2: minLevel = 50; break;
+        case 3: minLevel = 30; break;
+        case 4: minLevel = 70; break;
+        case 5: minLevel = 80; break;
+    }
+    if (minLevel && m_caster->getLevel() < minLevel)
+    {
+        SendCastResult(SPELL_FAILED_GLYPH_SOCKET_LOCKED);
+        return;
+    }
+
+    // apply new one
+    if (uint32 glyph = m_spellInfo->EffectMiscValue[effIndex])
+    {
+        if (GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(glyph))
+        {
+            if (GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(player->GetGlyphSlot(m_glyphIndex)))
+            {
+                if (gp->TypeFlags != gs->TypeFlags)
+                {
+                    SendCastResult(SPELL_FAILED_INVALID_GLYPH);
+                    return;                                 // glyph slot mismatch
+                }
+            }
+
+            // remove old glyph
+            if (uint32 oldglyph = player->GetGlyph(m_glyphIndex))
+            {
+                if (GlyphPropertiesEntry const *old_gp = sGlyphPropertiesStore.LookupEntry(oldglyph))
+                {
+                    player->RemoveAurasDueToSpell(old_gp->SpellId);
+                    player->SetGlyph(m_glyphIndex, 0);
+                }
+            }
+
+            player->CastSpell(m_caster, gp->SpellId, true);
+            player->SetGlyph(m_glyphIndex, glyph);
+            player->SendTalentsInfoData(false);
+        }
+    }
+}
+
+void Spell::EffectEnchantHeldItem(SpellEffIndex effIndex)
+{
+    // this is only item spell effect applied to main-hand weapon of target player (players in area)
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* item_owner = (Player*)unitTarget;
+    Item* item = item_owner->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+    if (!item)
+        return;
+
+    // must be equipped
+    if (!item ->IsEquipped())
+        return;
+
+    if (m_spellInfo->EffectMiscValue[effIndex])
+    {
+        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+        int32 duration = GetSpellDuration(m_spellInfo);          //Try duration index first ..
+        if (!duration)
+            duration = damage;//+1;            //Base points after ..
+        if (!duration)
+            duration = 10;                                  //10 seconds for enchants which don't have listed duration
+
+        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            return;
+
+        // Always go to temp enchantment slot
+        EnchantmentSlot slot = TEMP_ENCHANTMENT_SLOT;
+
+        // Enchantment will not be applied if a different one already exists
+        if (item->GetEnchantmentId(slot) && item->GetEnchantmentId(slot) != enchant_id)
+            return;
+
+        // Apply the temporary enchantment
+        item->SetEnchantment(slot, enchant_id, duration*IN_MILLISECONDS, 0);
+        item_owner->ApplyEnchantment(item, slot, true);
+    }
+}
+
+void Spell::EffectDisEnchant(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+    if (!itemTarget || !itemTarget->GetProto()->DisenchantID)
+        return;
+
+    p_caster->UpdateCraftSkill(m_spellInfo->Id);
+
+    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(),LOOT_DISENCHANTING);
+
+    // item will be removed at disenchanting end
+}
+
+void Spell::EffectInebriate(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *player = (Player*)unitTarget;
+    uint16 currentDrunk = player->GetDrunkValue();
+    uint16 drunkMod = damage * 256;
+    if (currentDrunk + drunkMod > 0xFFFF)
+        currentDrunk = 0xFFFF;
+    else
+        currentDrunk += drunkMod;
+    player->SetDrunkValue(currentDrunk, m_CastItem ? m_CastItem->GetEntry() : 0);
+}
+
+void Spell::EffectFeedPet(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)m_caster;
+
+    Item* foodItem = m_targets.getItemTarget();
+    if (!foodItem)
+        return;
+
+    Pet *pet = _player->GetPet();
+    if (!pet)
+        return;
+
+    if (!pet->isAlive())
+        return;
+
+    int32 benefit = pet->GetCurrentFoodBenefitLevel(foodItem->GetProto()->ItemLevel);
+    if (benefit <= 0)
+        return;
+
+    ExecuteLogEffectDestroyItem(effIndex, foodItem->GetEntry());
+
+    uint32 count = 1;
+    _player->DestroyItemCount(foodItem, count, true);
+    // TODO: fix crash when a spell has two effects, both pointed at the same item target
+
+    m_caster->CastCustomSpell(pet, m_spellInfo->EffectTriggerSpell[effIndex], &benefit, NULL, NULL, true);
+}
+
+void Spell::EffectDismissPet(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Pet* pet = m_caster->ToPlayer()->GetPet();
+
+    // not let dismiss dead pet
+    if (!pet||!pet->isAlive())
+        return;
+
+    ExecuteLogEffectUnsummonObject(effIndex, pet);
+    m_caster->ToPlayer()->RemovePet(pet, PET_SAVE_NOT_IN_SLOT);
+}
+
+void Spell::EffectSummonObject(SpellEffIndex effIndex)
+{
+    uint32 go_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    uint8 slot = 0;
+    switch(m_spellInfo->Effect[effIndex])
+    {
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT1: slot = 0; break;
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT2: slot = 1; break;
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT3: slot = 2; break;
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT4: slot = 3; break;
+        default: return;
+    }
+
+    uint64 guid = m_caster->m_ObjectSlot[slot];
+    if (guid != 0)
+    {
+        GameObject* obj = NULL;
+        if (m_caster)
+            obj = m_caster->GetMap()->GetGameObject(guid);
+
+        if (obj)
+        {
+            // Recast case - null spell id to make auras not be removed on object remove from world
+            if (m_spellInfo->Id == obj->GetSpellId())
+                obj->SetSpellId(0);
+            m_caster->RemoveGameObject(obj, true);
+        }
+        m_caster->m_ObjectSlot[slot] = 0;
+    }
+
+    GameObject* pGameObj = new GameObject;
+
+    float x, y, z;
+    // If dest location if present
+    if (m_targets.HasDst())
+        m_targets.m_dstPos.GetPosition(x, y, z);
+    // Summon in random point all other units if location present
+    else
+        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+
+    Map *map = m_caster->GetMap();
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), go_id, map,
+        m_caster->GetPhaseMask(), x, y, z, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL,m_caster->getLevel());
+    int32 duration = GetSpellDuration(m_spellInfo);
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+    pGameObj->SetSpellId(m_spellInfo->Id);
+    m_caster->AddGameObject(pGameObj);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    map->Add(pGameObj);
+
+    m_caster->m_ObjectSlot[slot] = pGameObj->GetGUID();
+}
+
+void Spell::EffectResurrect(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (unitTarget->isAlive())
+        return;
+    if (!unitTarget->IsInWorld())
+        return;
+
+    switch (m_spellInfo->Id)
+    {
+        // Defibrillate (Goblin Jumper Cables) have 33% chance on success
+        case 8342:
+            if (roll_chance_i(67))
+            {
+                m_caster->CastSpell(m_caster, 8338, true, m_CastItem);
+                return;
+            }
+            break;
+        // Defibrillate (Goblin Jumper Cables XL) have 50% chance on success
+        case 22999:
+            if (roll_chance_i(50))
+            {
+                m_caster->CastSpell(m_caster, 23055, true, m_CastItem);
+                return;
+            }
+            break;
+        // Defibrillate ( Gnomish Army Knife) have 67% chance on success_list
+        case 54732:
+            if (roll_chance_i(33))
+            {
+                return;
+            }
+            break;
+        default:
+            break;
+    }
+
+    Player* pTarget = unitTarget->ToPlayer();
+
+    if (pTarget->isRessurectRequested())       // already have one active request
+        return;
+
+    uint32 health = pTarget->CountPctFromMaxHealth(damage);
+    uint32 mana   = pTarget->GetMaxPower(POWER_MANA) * damage / 100;
+
+    ExecuteLogEffectResurrect(effIndex, pTarget);
+
+    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
+    SendResurrectRequest(pTarget);
+}
+
+void Spell::EffectAddExtraAttacks(SpellEffIndex effIndex)
+{
+    if (!unitTarget || !unitTarget->isAlive() || !unitTarget->getVictim())
+        return;
+
+    if (unitTarget->m_extraAttacks)
+        return;
+
+    unitTarget->m_extraAttacks = damage;
+
+    ExecuteLogEffectExtraAttacks(effIndex, unitTarget->getVictim(), damage);
+}
+
+void Spell::EffectParry(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->SetCanParry(true);
+}
+
+void Spell::EffectBlock(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->SetCanBlock(true);
+}
+
+void Spell::EffectLeap(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->isInFlight())
+        return;
+
+    if (!m_targets.HasDst())
+        return;
+
+    unitTarget->NearTeleportTo(m_targets.m_dstPos.GetPositionX(), m_targets.m_dstPos.GetPositionY(), m_targets.m_dstPos.GetPositionZ(), m_targets.m_dstPos.GetOrientation(), unitTarget == m_caster);
+}
+
+void Spell::EffectReputation(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)unitTarget;
+
+    int32  rep_change = damage;//+1;           // field store reputation change -1
+
+    uint32 faction_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id);
+
+    if (!factionEntry)
+        return;
+
+    if (RepRewardRate const * repData = sObjectMgr.GetRepRewardRate(faction_id))
+    {
+        rep_change = int32((float)rep_change * repData->spell_rate);
+    }
+
+    _player->GetReputationMgr().ModifyReputation(factionEntry, rep_change);
+}
+
+void Spell::EffectQuestComplete(SpellEffIndex effIndex)
+{
+    Player *pPlayer;
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = (Player*)m_caster;
+    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = (Player*)unitTarget;
+    else
+        return;
+
+    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
+    if (quest_id)
+    {
+        uint16 log_slot = pPlayer->FindQuestSlot(quest_id);
+        if (log_slot < MAX_QUEST_LOG_SIZE)
+            pPlayer->AreaExploredOrEventHappens(quest_id);
+        else if (!pPlayer->GetQuestRewardStatus(quest_id))   // never rewarded before
+            pPlayer->CompleteQuest(quest_id);   // quest not in log - for internal use
+    }
+}
+
+void Spell::EffectForceDeselect(SpellEffIndex /*effIndex*/)
+{
+    WorldPacket data(SMSG_CLEAR_TARGET, 8);
+    data << uint64(m_caster->GetGUID());
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::EffectSelfResurrect(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->isAlive())
+        return;
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!unitTarget->IsInWorld())
+        return;
+
+    uint32 health = 0;
+    uint32 mana = 0;
+
+    // flat case
+    if (damage < 0)
+    {
+        health = uint32(-damage);
+        mana = m_spellInfo->EffectMiscValue[effIndex];
+    }
+    // percent case
+    else
+    {
+        health = unitTarget->CountPctFromMaxHealth(damage);
+        if (unitTarget->GetMaxPower(POWER_MANA) > 0)
+            mana = uint32(damage/100.0f*unitTarget->GetMaxPower(POWER_MANA));
+    }
+
+    Player *plr = unitTarget->ToPlayer();
+    plr->ResurrectPlayer(0.0f);
+
+    plr->SetHealth(health);
+    plr->SetPower(POWER_MANA, mana);
+    plr->SetPower(POWER_RAGE, 0);
+    plr->SetPower(POWER_ENERGY, plr->GetMaxPower(POWER_ENERGY));
+
+    plr->SpawnCorpseBones();
+}
+
+void Spell::EffectSkinning(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+        return;
+    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Creature* creature = unitTarget->ToCreature();
+    int32 targetLevel = creature->getLevel();
+
+    uint32 skill = creature->GetCreatureInfo()->GetRequiredLootSkill();
+
+    m_caster->ToPlayer()->SendLoot(creature->GetGUID(),LOOT_SKINNING);
+    creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+
+    int32 reqValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel-10)*10 : targetLevel*5;
+
+    int32 skillValue = m_caster->ToPlayer()->GetPureSkillValue(skill);
+
+    // Double chances for elites
+    m_caster->ToPlayer()->UpdateGatherSkill(skill, skillValue, reqValue, creature->isElite() ? 2 : 1);
+}
+
+void Spell::EffectCharge(SpellEffIndex /*effIndex*/)
+{
+    Unit *target = m_targets.getUnitTarget();
+    if (!target)
+        return;
+
+    float x, y, z;
+    target->GetContactPoint(m_caster, x, y, z);
+    m_caster->GetMotionMaster()->MoveCharge(x, y, z);
+
+    // not all charge effects used in negative spells
+    if (!IsPositiveSpell(m_spellInfo->Id) && m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->Attack(target, true);
+}
+
+void Spell::EffectChargeDest(SpellEffIndex /*effIndex*/)
+{
+    if (m_targets.HasDst())
+    {
+        float x, y, z;
+        m_targets.m_dstPos.GetPosition(x, y, z);
+        m_caster->GetMotionMaster()->MoveCharge(x, y, z);
+    }
+}
+
+void Spell::EffectKnockBack(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    // Instantly interrupt non melee spells being casted
+    if (unitTarget->IsNonMeleeSpellCasted(true))
+        unitTarget->InterruptNonMeleeSpells(true);
+
+    // Typhoon
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x01000000)
+    {
+        // Glyph of Typhoon
+        if (m_caster->HasAura(62135))
+            return;
+    }
+
+    // Thunderstorm
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[1] & 0x00002000)
+    {
+        // Glyph of Thunderstorm
+        if (m_caster->HasAura(62132))
+            return;
+    }
+
+    float ratio = m_caster->GetCombatReach() / std::max(unitTarget->GetCombatReach(), 1.0f);
+    if (ratio < 1.0f)
+        ratio = ratio * ratio * ratio * 0.1f; // volume = length^3
+    else
+        ratio = 0.1f; // dbc value ratio
+    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex]) * ratio;
+    float speedz = float(damage) * ratio;
+    if (speedxy < 0.1f && speedz < 0.1f)
+        return;
+
+    float x, y;
+    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_KNOCK_BACK_DEST)
+    {
+        if (m_targets.HasDst())
+            m_targets.m_dstPos.GetPosition(x, y);
+        else
+            return;
+    }
+    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_KNOCK_BACK)
+    {
+        m_caster->GetPosition(x, y);
+    }
+
+    unitTarget->KnockbackFrom(x, y, speedxy, speedz);
+}
+
+void Spell::EffectLeapBack(SpellEffIndex effIndex)
+{
+    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex])/10;
+    float speedz = float(damage/10);
+    if (!speedxy)
+    {
+        if (m_targets.getUnitTarget())
+            m_caster->JumpTo(m_targets.getUnitTarget(), speedz);
+    }
+    else
+    {
+        //1891: Disengage
+        m_caster->JumpTo(speedxy, speedz, m_spellInfo->SpellIconID != 1891);
+    }
+}
+
+void Spell::EffectQuestClear(SpellEffIndex effIndex)
+{
+    Player *pPlayer = NULL;
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = m_caster->ToPlayer();
+    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = unitTarget->ToPlayer();
+
+    if (!pPlayer)
+        return;
+
+    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest_id);
+
+    if (!pQuest)
+        return;
+
+    QuestStatusMap::iterator qs_itr = pPlayer->getQuestStatusMap().find(quest_id);
+    // Player has never done this quest
+    if (qs_itr == pPlayer->getQuestStatusMap().end())
+        return;
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 quest = pPlayer->GetQuestSlotQuestId(slot);
+        if (quest == quest_id)
+        {
+            pPlayer->SetQuestSlot(slot, 0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            pPlayer->TakeQuestSourceItem(quest, false);
+        }
+    }
+
+    // set quest status to not started (will be updated in DB at next save)
+    pPlayer->SetQuestStatus(quest_id, QUEST_STATUS_NONE);
+
+    // reset rewarded for restart repeatable quest
+    QuestStatusData &data = qs_itr->second;
+    data.m_rewarded = false;
+}
+
+void Spell::EffectSendTaxi(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->ActivateTaxiPathTo(m_spellInfo->EffectMiscValue[effIndex],m_spellInfo->Id);
+}
+
+void Spell::EffectPullTowards(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    float speedZ = (float)(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex) / 10);
+    float speedXY = (float)(m_spellInfo->EffectMiscValue[effIndex]/10);
+    Position pos;
+    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_PULL_TOWARDS_DEST)
+    {
+        if (m_targets.HasDst())
+            pos.Relocate(m_targets.m_dstPos);
+        else
+            return;
+    }
+    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_PULL_TOWARDS)
+    {
+        pos.Relocate(m_caster);
+    }
+
+    unitTarget->GetMotionMaster()->MoveJump(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), speedXY, speedZ);
+}
+
+void Spell::EffectDispelMechanic(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    uint32 mechanic = m_spellInfo->EffectMiscValue[effIndex];
+
+    std::queue < std::pair < uint32, uint64 > > dispel_list;
+
+    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura * aura = itr->second;
+        if (!aura->GetApplicationOfTarget(unitTarget->GetGUID()))
+            continue;
+        bool success = false;
+        GetDispelChance(aura->GetCaster(), unitTarget, aura->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success);
+        if ((GetAllSpellMechanicMask(aura->GetSpellProto()) & (1 << mechanic)) && success)
+            dispel_list.push(std::make_pair(aura->GetId(), aura->GetCasterGUID()));
+    }
+
+    for (; dispel_list.size(); dispel_list.pop())
+    {
+        unitTarget->RemoveAura(dispel_list.front().first, dispel_list.front().second, 0, AURA_REMOVE_BY_ENEMY_SPELL);
+    }
+}
+
+void Spell::EffectSummonDeadPet(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player *_player = (Player*)m_caster;
+    Pet *pet = _player->GetPet();
+    if (!pet)
+        return;
+    if (pet->isAlive())
+        return;
+    if (damage < 0)
+        return;
+
+    float x,y,z;
+    _player->GetPosition(x, y, z);
+    _player->GetMap()->CreatureRelocation(pet, x, y, z, _player->GetOrientation());
+
+    pet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
+    pet->RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+    pet->setDeathState(ALIVE);
+    pet->clearUnitState(UNIT_STAT_ALL_STATE);
+    pet->SetHealth(pet->CountPctFromMaxHealth(damage));
+
+    //pet->AIM_Initialize();
+    //_player->PetSpellInitialize();
+    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+}
+
+void Spell::EffectDestroyAllTotems(SpellEffIndex /*effIndex*/)
+{
+    int32 mana = 0;
+    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
+    {
+        if (!m_caster->m_SummonSlot[slot])
+            continue;
+
+        Creature* totem = m_caster->GetMap()->GetCreature(m_caster->m_SummonSlot[slot]);
+        if (totem && totem->isTotem())
+        {
+            uint32 spell_id = totem->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell_id);
+            if (spellInfo)
+            {
+                mana += spellInfo->manaCost;
+                mana += spellInfo->ManaCostPercentage * m_caster->GetCreateMana() / 100;
+            }
+            totem->ToTotem()->UnSummon();
+        }
+    }
+    mana = mana * damage / 100;
+
+    if (mana)
+        m_caster->CastCustomSpell(m_caster, 39104, &mana, NULL, NULL, true);
+}
+
+void Spell::EffectDurabilityDamage(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
+
+    // FIXME: some spells effects have value -1/-2
+    // Possibly its mean -1 all player equipped items and -2 all items
+    if (slot < 0)
+    {
+        unitTarget->ToPlayer()->DurabilityPointsLossAll(damage, (slot < -1));
+        return;
+    }
+
+    // invalid slot value
+    if (slot >= INVENTORY_SLOT_BAG_END)
+        return;
+
+    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        unitTarget->ToPlayer()->DurabilityPointsLoss(item, damage);
+
+    ExecuteLogEffectDurabilityDamage(effIndex, unitTarget, slot, damage);
+}
+
+void Spell::EffectDurabilityDamagePCT(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
+
+    // FIXME: some spells effects have value -1/-2
+    // Possibly its mean -1 all player equipped items and -2 all items
+    if (slot < 0)
+    {
+        unitTarget->ToPlayer()->DurabilityLossAll(double(damage)/100.0f, (slot < -1));
+        return;
+    }
+
+    // invalid slot value
+    if (slot >= INVENTORY_SLOT_BAG_END)
+        return;
+
+    if (damage <= 0)
+        return;
+
+    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        unitTarget->ToPlayer()->DurabilityLoss(item, double(damage)/100.0f);
+}
+
+void Spell::EffectModifyThreatPercent(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    unitTarget->getThreatManager().modifyThreatPercent(m_caster, damage);
+}
+
+void Spell::EffectTransmitted(SpellEffIndex effIndex)
+{
+    uint32 name_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(name_id);
+
+    if (!goinfo)
+    {
+        sLog.outErrorDb("Gameobject (Entry: %u) not exist and not created at spell (ID: %u) cast",name_id, m_spellInfo->Id);
+        return;
+    }
+
+    float fx, fy, fz;
+
+    if (m_targets.HasDst())
+        m_targets.m_dstPos.GetPosition(fx, fy, fz);
+    //FIXME: this can be better check for most objects but still hack
+    else if (m_spellInfo->EffectRadiusIndex[effIndex] && m_spellInfo->speed == 0)
+    {
+        float dis = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
+    }
+    else
+    {
+        //GO is always friendly to it's creator, get range for friends
+        float min_dis = GetSpellMinRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
+        float max_dis = GetSpellMaxRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
+        float dis = (float)rand_norm() * (max_dis - min_dis) + min_dis;
+
+        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
+    }
+
+    Map *cMap = m_caster->GetMap();
+    if (goinfo->type == GAMEOBJECT_TYPE_FISHINGNODE)
+    {
+        LiquidData liqData;
+        if ( !cMap->IsInWater(fx, fy, fz + 1.f/* -0.5f */, &liqData))             // Hack to prevent fishing bobber from failing to land on fishing hole
+        { // but this is not proper, we really need to ignore not materialized objects
+            SendCastResult(SPELL_FAILED_NOT_HERE);
+            SendChannelUpdate(0);
+            return;
+        }
+
+        // replace by water level in this case
+        //fz = cMap->GetWaterLevel(fx, fy);
+        fz = liqData.level;
+    }
+    // if gameobject is summoning object, it should be spawned right on caster's position
+    else if (goinfo->type == GAMEOBJECT_TYPE_SUMMONING_RITUAL)
+    {
+        m_caster->GetPosition(fx, fy, fz);
+    }
+
+    GameObject* pGameObj = new GameObject;
+
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), name_id, cMap,
+        m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    int32 duration = GetSpellDuration(m_spellInfo);
+
+    switch(goinfo->type)
+    {
+        case GAMEOBJECT_TYPE_FISHINGNODE:
+        {
+            m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT,pGameObj->GetGUID());
+            m_caster->AddGameObject(pGameObj);              // will removed at spell cancel
+
+            // end time of range when possible catch fish (FISHING_BOBBER_READY_TIME..GetDuration(m_spellInfo))
+            // start time == fish-FISHING_BOBBER_READY_TIME (0..GetDuration(m_spellInfo)-FISHING_BOBBER_READY_TIME)
+            int32 lastSec = 0;
+            switch(urand(0, 3))
+            {
+                case 0: lastSec =  3; break;
+                case 1: lastSec =  7; break;
+                case 2: lastSec = 13; break;
+                case 3: lastSec = 17; break;
+            }
+
+            duration = duration - lastSec*IN_MILLISECONDS + FISHING_BOBBER_READY_TIME*IN_MILLISECONDS;
+            break;
+        }
+        case GAMEOBJECT_TYPE_SUMMONING_RITUAL:
+        {
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            {
+          pGameObj->AddUniqueUse(m_caster->ToPlayer());
+          m_caster->AddGameObject(pGameObj);          // will removed at spell cancel
+            }
+            break;
+        }
+        case GAMEOBJECT_TYPE_DUEL_ARBITER: // 52991
+            m_caster->AddGameObject(pGameObj);
+            break;
+        case GAMEOBJECT_TYPE_FISHINGHOLE:
+        case GAMEOBJECT_TYPE_CHEST:
+        default:
+            break;
+    }
+
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+
+    pGameObj->SetOwnerGUID(m_caster->GetGUID());
+
+    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
+    pGameObj->SetSpellId(m_spellInfo->Id);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    sLog.outStaticDebug("AddObject at SpellEfects.cpp EffectTransmitted");
+    //m_caster->AddGameObject(pGameObj);
+    //m_ObjToDel.push_back(pGameObj);
+
+    cMap->Add(pGameObj);
+
+    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
+    {
+        GameObject* linkedGO = new GameObject;
+        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, cMap,
+            m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+        {
+            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+            //linkedGO->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
+            linkedGO->SetSpellId(m_spellInfo->Id);
+            linkedGO->SetOwnerGUID(m_caster->GetGUID());
+
+            ExecuteLogEffectSummonObject(effIndex, linkedGO);
+
+            linkedGO->GetMap()->Add(linkedGO);
+        }
+        else
+        {
+            delete linkedGO;
+            linkedGO = NULL;
+            return;
+        }
+    }
+}
+
+void Spell::EffectProspecting(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_PROSPECTABLE))
+        return;
+
+    if (itemTarget->GetCount() < 5)
+        return;
+
+    if (sWorld.getBoolConfig(CONFIG_SKILL_PROSPECTING))
+    {
+        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_JEWELCRAFTING);
+        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
+        p_caster->UpdateGatherSkill(SKILL_JEWELCRAFTING, SkillValue, reqSkillValue);
+    }
+
+    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_PROSPECTING);
+}
+
+void Spell::EffectMilling(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_MILLABLE))
+        return;
+
+    if (itemTarget->GetCount() < 5)
+        return;
+
+    if (sWorld.getBoolConfig(CONFIG_SKILL_MILLING))
+    {
+        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_INSCRIPTION);
+        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
+        p_caster->UpdateGatherSkill(SKILL_INSCRIPTION, SkillValue, reqSkillValue);
+    }
+
+    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_MILLING);
+}
+
+void Spell::EffectSkill(SpellEffIndex /*effIndex*/)
+{
+    sLog.outDebug("WORLD: SkillEFFECT");
+}
+
+/* There is currently no need for this effect. We handle it in Battleground.cpp
+   If we would handle the resurrection here, the spiritguide would instantly disappear as the
+   player revives, and so we wouldn't see the spirit heal visual effect on the npc.
+   This is why we use a half sec delay between the visual effect and the resurrection itself */
+void Spell::EffectSpiritHeal(SpellEffIndex /*effIndex*/)
+{
+    /*
+    if (!unitTarget || unitTarget->isAlive())
+        return;
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!unitTarget->IsInWorld())
+        return;
+
+    //m_spellInfo->EffectBasePoints[i]; == 99 (percent?)
+    //unitTarget->ToPlayer()->setResurrect(m_caster->GetGUID(), unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), unitTarget->GetMaxHealth(), unitTarget->GetMaxPower(POWER_MANA));
+    unitTarget->ToPlayer()->ResurrectPlayer(1.0f);
+    unitTarget->ToPlayer()->SpawnCorpseBones();
+    */
+}
+
+// remove insignia spell effect
+void Spell::EffectSkinPlayerCorpse(SpellEffIndex /*effIndex*/)
+{
+    sLog.outDebug("Effect: SkinPlayerCorpse");
+    if ((m_caster->GetTypeId() != TYPEID_PLAYER) || (unitTarget->GetTypeId() != TYPEID_PLAYER) || (unitTarget->isAlive()))
+        return;
+
+    unitTarget->ToPlayer()->RemovedInsignia((Player*)m_caster);
+}
+
+void Spell::EffectStealBeneficialBuff(SpellEffIndex effIndex)
+{
+    sLog.outDebug("Effect: StealBeneficialBuff");
+
+    if (!unitTarget || unitTarget == m_caster)                 // can't steal from self
+        return;
+
+    DispelChargesList steal_list;
+
+    // Create dispel mask by dispel type
+    uint32 dispelMask  = GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[effIndex]));
+    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura * aura = itr->second;
+        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
+        {
+            // Need check for passive? this
+            if (!aurApp->IsPositive() || aura->IsPassive() || aura->GetSpellProto()->AttributesEx4 & SPELL_ATTR_EX4_NOT_STEALABLE)
+                continue;
+
+            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
+            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
+            // Polymorph instead of 1 / (5 + 1) -> 16%.
+            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
+            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                steal_list.push_back(std::make_pair(aura, charges));
+        }
+    }
+
+    if (steal_list.empty())
+        return;
+
+    // Ok if exist some buffs for dispel try dispel it
+    uint32 failCount = 0;
+    DispelList success_list;
+    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
+    // dispel N = damage buffs (or while exist buffs for dispel)
+    for (int32 count = 0; count < damage && !steal_list.empty();)
+    {
+        // Random select buff for dispel
+        DispelChargesList::iterator itr = steal_list.begin();
+        std::advance(itr, urand(0, steal_list.size() - 1));
+
+        bool success = false;
+        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
+        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
+        {
+            steal_list.erase(itr);
+            continue;
+        }
+        else
+        {
+            if (success)
+            {
+                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
+                --itr->second;
+                if (itr->second <= 0)
+                    steal_list.erase(itr);
+            }
+            else
+            {
+                if (!failCount)
+                {
+                    // Failed to dispell
+                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
+                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
+                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
+                }
+                ++failCount;
+                dataFail << uint32(itr->first->GetId());                         // Spell Id
+            }
+            ++count;
+        }
+    }
+
+    if (failCount)
+        m_caster->SendMessageToSet(&dataFail, true);
+
+    if (success_list.empty())
+        return;
+
+    WorldPacket dataSuccess(SMSG_SPELLSTEALLOG, 8+8+4+1+4+damage*5);
+    dataSuccess.append(unitTarget->GetPackGUID());  // Victim GUID
+    dataSuccess.append(m_caster->GetPackGUID());    // Caster GUID
+    dataSuccess << uint32(m_spellInfo->Id);         // dispel spell id
+    dataSuccess << uint8(0);                        // not used
+    dataSuccess << uint32(success_list.size());     // count
+    for (DispelList::iterator itr = success_list.begin(); itr!=success_list.end(); ++itr)
+    {
+        dataSuccess << uint32(itr->first);          // Spell Id
+        dataSuccess << uint8(0);                    // 0 - steals !=0 transfers
+        unitTarget->RemoveAurasDueToSpellBySteal(itr->first, itr->second, m_caster);
+    }
+    m_caster->SendMessageToSet(&dataSuccess, true);
+}
+
+void Spell::EffectKillCreditPersonal(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->KilledMonsterCredit(m_spellInfo->EffectMiscValue[effIndex], 0);
+}
+
+void Spell::EffectKillCredit(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    int32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
+    if (!creatureEntry)
+    {
+        if (m_spellInfo->Id == 42793) // Burn Body
+            creatureEntry = 24008; // Fallen Combatant
+    }
+
+    if (creatureEntry)
+        unitTarget->ToPlayer()->RewardPlayerAndGroupAtEvent(creatureEntry, unitTarget);
+}
+
+void Spell::EffectQuestFail(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->FailQuest(m_spellInfo->EffectMiscValue[effIndex]);
+}
+
+void Spell::EffectQuestStart(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player * player = unitTarget->ToPlayer();
+    if (Quest const* qInfo = sObjectMgr.GetQuestTemplate(m_spellInfo->EffectMiscValue[effIndex]))
+    {
+        if (player->CanTakeQuest(qInfo, false) && player->CanAddQuest(qInfo, false))
+        {
+            player->AddQuest(qInfo, NULL);
+        }
+    }
+}
+
+void Spell::EffectActivateRune(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *plr = (Player*)m_caster;
+
+    if (plr->getClass() != CLASS_DEATH_KNIGHT)
+        return;
+
+    // needed later
+    m_runesState = m_caster->ToPlayer()->GetRunesState();
+
+    uint32 count = damage;
+    if (count == 0) count = 1;
+    for (uint32 j = 0; j < MAX_RUNES && count > 0; ++j)
+    {
+        if (plr->GetRuneCooldown(j) && plr->GetCurrentRune(j) == RuneType(m_spellInfo->EffectMiscValue[effIndex]))
+        {
+            plr->SetRuneCooldown(j, 0);
+            --count;
+        }
+    }
+    // Empower rune weapon
+    if (m_spellInfo->Id == 47568)
+    {
+        // Need to do this just once
+        if (effIndex != 0)
+            return;
+
+        for (uint32 i = 0; i < MAX_RUNES; ++i)
+        {
+            if (plr->GetRuneCooldown(i) && (plr->GetCurrentRune(i) == RUNE_FROST ||  plr->GetCurrentRune(i) == RUNE_DEATH))
+                plr->SetRuneCooldown(i, 0);
+        }
+    }
+}
+
+void Spell::EffectCreateTamedPet(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || unitTarget->GetPetGUID() || unitTarget->getClass() != CLASS_HUNTER)
+        return;
+
+    uint32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
+    Pet * pet = unitTarget->CreateTamedPetFrom(creatureEntry, m_spellInfo->Id);
+    if (!pet)
+        return;
+
+    // add to world
+    pet->GetMap()->Add(pet->ToCreature());
+
+    // unitTarget has pet now
+    unitTarget->SetMinion(pet, true);
+
+    pet->InitTalentForLevel();
+
+    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
+    {
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        unitTarget->ToPlayer()->PetSpellInitialize();
+    }
+}
+
+void Spell::EffectDiscoverTaxi(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    uint32 nodeid = m_spellInfo->EffectMiscValue[effIndex];
+    if (sTaxiNodesStore.LookupEntry(nodeid))
+        unitTarget->ToPlayer()->GetSession()->SendDiscoverNewTaxiNode(nodeid);
+}
+
+void Spell::EffectTitanGrip(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->SetCanTitanGrip(true);
+}
+
+void Spell::EffectRedirectThreat(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget)
+        m_caster->SetReducedThreatPercent((uint32)damage, unitTarget->GetGUID());
+}
+
+void Spell::EffectWMODamage(SpellEffIndex /*effIndex*/)
+{
+    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        Unit *caster = m_originalCaster;
+        if (!caster)
+            return;
+
+        // Do not allow damage if hp is 0
+        if (gameObjTarget->GetGOValue()->building.health == 0)
+            return;
+
+        FactionTemplateEntry const *casterft, *goft;
+        casterft = caster->getFactionTemplateEntry();
+        goft = sFactionTemplateStore.LookupEntry(gameObjTarget->GetUInt32Value(GAMEOBJECT_FACTION));
+        // Do not allow to damage GO's of friendly factions (ie: Wintergrasp Walls/Ulduar Storm Beacons)
+        if ((casterft && goft && !casterft->IsFriendlyTo(*goft)) || !goft)
+        {
+            gameObjTarget->TakenDamage(uint32(damage), caster);
+            WorldPacket data(SMSG_DESTRUCTIBLE_BUILDING_DAMAGE, 8+8+8+4+4);
+            data.append(gameObjTarget->GetPackGUID());
+            data.append(caster->GetPackGUID());
+            if (Unit *who = caster->GetCharmerOrOwner())
+                data.append(who->GetPackGUID());
+            else
+                data << uint8(0);
+            data << uint32(damage);
+            data << uint32(m_spellInfo->Id);
+            gameObjTarget->SendMessageToSet(&data, false);
+        }
+    }
+}
+
+void Spell::EffectWMORepair(SpellEffIndex /*effIndex*/)
+{
+    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        gameObjTarget->Rebuild();
+}
+
+void Spell::SummonGuardian(uint32 i, uint32 entry, SummonPropertiesEntry const *properties)
+{
+    Unit *caster = m_originalCaster;
+    if (!caster)
+        return;
+
+    if (caster->isTotem())
+      caster = caster->ToTotem()->GetOwner();
+
+    // in another case summon new
+    uint8 level = caster->getLevel();
+
+    // level of pet summoned using engineering item based at engineering skill level
+    if (m_CastItem && caster->GetTypeId() == TYPEID_PLAYER)
+        if (ItemPrototype const *proto = m_CastItem->GetProto())
+            if (proto->RequiredSkill == SKILL_ENGINERING)
+                if (uint16 skill202 = caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING))
+                    level = skill202/5;
+
+    //float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+    float radius = 5.0f;
+    uint32 amount = damage > 0 ? damage : 1;
+    int32 duration = GetSpellDuration(m_spellInfo);
+    switch (m_spellInfo->Id)
+    {
+        case 1122: // Inferno
+            amount = 1;
+            break;
+        case 49028: // Dancing Rune Weapon
+            if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(63330, 0)) // glyph of Dancing Rune Weapon
+                duration += aurEff->GetAmount();
+            break;
+        case 57879:
+            if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_HUNTER, 69, 2))
+                amount += aurEff->GetAmount();
+            break;
+    }
+    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
+        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
+
+    //TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
+    Map *map = caster->GetMap();
+
+    for (uint32 count = 0; count < amount; ++count)
+    {
+        Position pos;
+        GetSummonPosition(i, pos, radius, count);
+
+        TempSummon *summon = map->SummonCreature(entry, pos, properties, duration, caster);
+        if (!summon)
+            return;
+        if (summon->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)summon)->InitStatsForLevel(level);
+
+        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+        if (summon->HasUnitTypeMask(UNIT_MASK_MINION) && m_targets.HasDst())
+            ((Minion*)summon)->SetFollowAngle(m_caster->GetAngle(summon));
+
+        if (summon->GetEntry() == 27893)
+        {
+            if (uint32 weapon = m_caster->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID))
+            {
+                summon->SetDisplayId(11686);
+                summon->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, weapon);
+            }
+            else
+                summon->SetDisplayId(1126);
+        }
+
+        summon->AI()->EnterEvadeMode();
+
+        ExecuteLogEffectSummonObject(i, summon);
+    }
+}
+
+void Spell::GetSummonPosition(uint32 i, Position &pos, float radius, uint32 count)
+{
+    pos.SetOrientation(m_caster->GetOrientation());
+
+    if (m_targets.HasDst())
+    {
+        // Summon 1 unit in dest location
+        if (count == 0)
+            pos.Relocate(m_targets.m_dstPos);
+        // Summon in random point all other units if location present
+        else
+        {
+            //This is a workaround. Do not have time to write much about it
+            switch (m_spellInfo->EffectImplicitTargetA[i])
+            {
+                case TARGET_MINION:
+                case TARGET_DEST_CASTER_RANDOM:
+                    m_caster->GetNearPosition(pos, radius * (float)rand_norm(), (float)rand_norm()*static_cast<float>(2*M_PI));
+                    break;
+                case TARGET_DEST_DEST_RANDOM:
+                case TARGET_DEST_TARGET_RANDOM:
+                    m_caster->GetRandomPoint(m_targets.m_dstPos, radius, pos);
+                    break;
+                default:
+                    pos.Relocate(m_targets.m_dstPos);
+                    break;
+            }
+        }
+    }
+    // Summon if dest location not present near caster
+    else
+    {
+        float x, y, z;
+        m_caster->GetClosePoint(x,y,z,3.0f);
+        pos.Relocate(x, y, z);
+    }
+}
+
+void Spell::EffectRenamePet(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT ||
+        !unitTarget->ToCreature()->isPet() || ((Pet*)unitTarget)->getPetType() != HUNTER_PET)
+        return;
+
+    unitTarget->RemoveByteFlag(UNIT_FIELD_BYTES_2, 2, UNIT_CAN_BE_RENAMED);
+}
+
+void Spell::EffectPlayMusic(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    uint32 soundid = m_spellInfo->EffectMiscValue[effIndex];
+
+    if (!sSoundEntriesStore.LookupEntry(soundid))
+    {
+        sLog.outError("EffectPlayMusic: Sound (Id: %u) not exist in spell %u.",soundid,m_spellInfo->Id);
+        return;
+    }
+
+    WorldPacket data(SMSG_PLAY_MUSIC, 4);
+    data << uint32(soundid);
+    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Spell::EffectSpecCount(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->UpdateSpecCount(damage);
+}
+
+void Spell::EffectActivateSpec(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->ActivateSpec(damage-1);  // damage is 1 or 2, spec is 0 or 1
+}
+
+void Spell::EffectPlayerNotification(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
+
+    switch(m_spellInfo->Id)
+    {
+        case 58730: // Restricted Flight Area
+           {
+             if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+              {
+              if (pvpWG->isWarTime()==true)
+               {
+                unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+                unitTarget->PlayDirectSound(9417); // Fel Reaver sound
+                unitTarget->MonsterTextEmote("The air is too thin in Wintergrasp for normal flight. You will be ejected in 9 sec.",unitTarget->GetGUID(),true);
+               break;
+               } else unitTarget->RemoveAura(58730);
+              }
+            break;
+            }
+        case 58600: // Restricted Flight Area
+            unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+            break;
+    }
+}
+
+void Spell::EffectRemoveAura(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    // there may be need of specifying casterguid of removed auras
+    unitTarget->RemoveAurasDueToSpell(m_spellInfo->EffectTriggerSpell[effIndex]);
+}
+
+void Spell::EffectCastButtons(SpellEffIndex effIndex)
+{
+    if (!unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *p_caster = (Player*)m_caster;
+    uint32 button_id = m_spellInfo->EffectMiscValue[effIndex] + 132;
+    uint32 n_buttons = m_spellInfo->EffectMiscValueB[effIndex];
+
+    for (; n_buttons; n_buttons--, button_id++)
+    {
+        ActionButton const* ab = p_caster->GetActionButton(button_id);
+        if (!ab || ab->GetType() != ACTION_BUTTON_SPELL)
+            continue;
+
+        uint32 spell_id = ab->GetAction();
+        if (!spell_id)
+            continue;
+
+        if (p_caster->HasSpellCooldown(spell_id))
+            continue;
+
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
+        uint32 cost = CalculatePowerCost(spellInfo, m_caster, GetSpellSchoolMask(spellInfo));
+
+        if (m_caster->GetPower(POWER_MANA) < cost)
+            break;
+
+        m_caster->CastSpell(unitTarget, spell_id, true);
+        m_caster->ModifyPower(POWER_MANA, -(int32)cost);
+        p_caster->AddSpellAndCategoryCooldowns(spellInfo, 0);
+    }
+}
+
+void Spell::EffectRechargeManaGem(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *player = m_caster->ToPlayer();
+
+    if (!player)
+        return;
+
+    uint32 item_id = m_spellInfo->EffectItemType[0];
+
+    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item_id);
+    if (!pProto)
+    {
+        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+        return;
+    }
+
+    if (Item* pItem = player->GetItemByEntry(item_id))
+    {
+        for (int x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
+            pItem->SetSpellCharges(x,pProto->Spells[x].SpellCharges);
+        pItem->SetState(ITEM_CHANGED,player);
+    }
+}
+
+void Spell::EffectBind(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* player = (Player*)unitTarget;
+
+    uint32 area_id;
+    WorldLocation loc;
+    if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DST_DB || m_spellInfo->EffectImplicitTargetB[effIndex] == TARGET_DST_DB)
+    {
+        SpellTargetPosition const* st = sSpellMgr.GetSpellTargetPosition(m_spellInfo->Id);
+        if (!st)
+        {
+            sLog.outError( "Spell::EffectBind - unknown teleport coordinates for spell ID %u", m_spellInfo->Id );
+            return;
+        }
+
+        loc.m_mapId         = st->target_mapId;
+        loc.m_positionX   = st->target_X;
+        loc.m_positionY   = st->target_Y;
+        loc.m_positionZ   = st->target_Y;
+        loc.m_orientation = st->target_Orientation;
+        area_id = player->GetAreaId();
+    }
+    else
+    {
+        player->GetPosition(&loc);
+        area_id = player->GetAreaId();
+    }
+
+    player->SetHomebind(loc, area_id);
+
+    // binding
+    WorldPacket data( SMSG_BINDPOINTUPDATE, (4+4+4+4+4) );
+    data << float(loc.m_positionX);
+    data << float(loc.m_positionY);
+    data << float(loc.m_positionZ);
+    data << uint32(loc.m_mapId);
+    data << uint32(area_id);
+    player->SendDirectMessage( &data );
+
+    sLog.outStaticDebug("New homebind X      : %f", loc.m_positionX);
+    sLog.outStaticDebug("New homebind Y      : %f", loc.m_positionY);
+    sLog.outStaticDebug("New homebind Z      : %f", loc.m_positionZ);
+    sLog.outStaticDebug("New homebind MapId  : %u", loc.m_mapId);
+    sLog.outStaticDebug("New homebind AreaId : %u", area_id);
+
+    // zone update
+    data.Initialize(SMSG_PLAYERBOUND, 8+4);
+    data << uint64(player->GetGUID());
+    data << uint32(area_id);
+    player->SendDirectMessage( &data );
+}
diff --git a/src/server/game/Texts/CreatureTextMgr.cpp b/src/server/game/Texts/CreatureTextMgr.cpp
--- a/src/server/game/Texts/CreatureTextMgr.cpp
+++ b/src/server/game/Texts/CreatureTextMgr.cpp
@@ -116,14 +116,14 @@
     CreatureTextMap::const_iterator sList = mTextMap.find(source->GetEntry());
     if (sList == mTextMap.end())
     {
-        sLog.outErrorDb("CreatureTextMgr: Could not find Text for Creature(%s) Entry %u in 'creature_text' table. Ignoring.",source->GetName(), source->GetEntry());
+         sLog.outDebug("CreatureTextMgr::TextExist: Could not find Text for Creature (entry %u) in 'creature_text' table.", sourceEntry);
         return 0;
     }
     CreatureTextHolder TextHolder = (*sList).second;
     CreatureTextHolder::const_iterator itr = TextHolder.find(textGroup);
     if (itr == TextHolder.end())
     {
-        sLog.outErrorDb("CreatureTextMgr: Could not find TextGroup %u for Creature(%s) GuidLow %u Entry %u. Ignoring.",uint32(textGroup), source->GetName(), source->GetGUIDLow(), source->GetEntry());
+        sLog.outDebug("CreatureTextMgr::TextExist: Could not find TextGroup %u for Creature (entry %u).",uint32(textGroup), sourceEntry);
         return 0;
     }
     CreatureTextGroup TextGroup = (*itr).second;//has all texts in the group
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -73,6 +73,7 @@
 #include "ScriptMgr.h"
 #include "WeatherMgr.h"
 #include "CreatureTextMgr.h"
+#include "SmartAI.h"
 
 
 volatile bool World::m_stopEvent = false;
@@ -1606,6 +1607,9 @@
     sLog.outString("Loading Waypoints...");
     sWaypointMgr->Load();
 
+	sLog.outString("Loading SmartAI Waypoints...");
+	sSmartWaypointMgr.LoadFromDB();
+
     sLog.outString("Loading Creature Formations...");
     formation_mgr.LoadCreatureFormations();
 
@@ -1676,6 +1680,9 @@
     sLog.outString("Validating spell scripts...");
     sObjectMgr.ValidateSpellScripts();
 
+	sLog.outString("Loading SmartAI scripts...");
+	sSmartScriptMgr.LoadSmartAIFromDB();
+
     ///- Initialize game time and timers
     sLog.outDebug("DEBUG:: Initialize game time and timers");
     m_gameTime = time(NULL);
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -29,9 +29,7 @@
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
-  Custom/npc_teleport.cpp
-  Custom/buffnpc.cpp
-  Custom/guildmaster.cpp
+  Custom/npc_teleport.cpp
   ../game/AI/ScriptedAI/sc_npc_teleport.cpp
   ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
diff --git a/src/server/scripts/Custom/buffnpc.cpp b/src/server/scripts/Custom/buffnpc.cpp
deleted file mode 100644
--- a/src/server/scripts/Custom/buffnpc.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-// -- Buff NPC Script for MCWoW - by FreeCry -- //
-#include "ScriptPCH.h"
-#include "buffNPC.h"
-
-
-class npc_buffnpc : public CreatureScript
-{
-public:
-	npc_buffnpc() : CreatureScript("npc_buffnpc") { }
-
-bool OnGossipHello(Player* player, Creature* creature)
-{
-	if (player->isInCombat())
-	{
-		player->SEND_GOSSIP_MENU(40033, creature->GetGUID());
-		return true;
-	}
-	else
-	{	
-		player->ADD_GOSSIP_ITEM(0, "  ,                   .", GOSSIP_SENDER_MAIN, buffs);
-		player->ADD_GOSSIP_ITEM(0, "   ,                      .", GOSSIP_SENDER_MAIN, closemenu);
-
-		player->SEND_GOSSIP_MENU(40034, creature->GetGUID());
-		return true;
-	}
-}
-bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
-{
-	switch(action)
-	{
-
-	case buffs:
-		player->ADD_GOSSIP_ITEM(3, "                ", GOSSIP_SENDER_MAIN, gsdm);
-		player->ADD_GOSSIP_ITEM(3, "                 ", GOSSIP_SENDER_MAIN, gsdk);
-		player->ADD_GOSSIP_ITEM(3, "                         ", GOSSIP_SENDER_MAIN, gsdw);
-		player->ADD_GOSSIP_ITEM(3, "                 ", GOSSIP_SENDER_MAIN, gsdr);
-		player->ADD_GOSSIP_ITEM(3, "         ", GOSSIP_SENDER_MAIN, ai);
-		player->ADD_GOSSIP_ITEM(3, "                     ", GOSSIP_SENDER_MAIN, buffpkt1);
-		player->ADD_GOSSIP_ITEM(0, "               .", GOSSIP_SENDER_MAIN, closemenu);
-
-
-		player->SEND_GOSSIP_MENU(40035, creature->GetGUID());
-		break;
-
-	case gsdm:
-		player->CastSpell(player, 48934, true);
-
-		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
-		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
-		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
-		return true;
-
-	case gsdk:
-		player->CastSpell(player, 25898, true);
-
-		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
-		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
-		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
-		return true;
-
-	case gsdw:
-		player->CastSpell(player, 48938, true);
-
-		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
-		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
-		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
-		return true;
-
-	case gsdr:
-		player->CastSpell(player, 25899, true);
-
-		player->ADD_GOSSIP_ITEM(0, "  ,       ..", GOSSIP_SENDER_MAIN, buffs);
-		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
-		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
-		return true;
-
-	case ai:
-		player->CastSpell(player, 42995, true);
-
-		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
-		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
-		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
-		return true;
-
-	case buffpkt1:
-		player->CastSpell(player, 48162, true);
-		player->CastSpell(player, 48074, true);
-		player->CastSpell(player, 48170, true);
-		player->CastSpell(player, 48470, true);
-
-		player->ADD_GOSSIP_ITEM(0, "  ,       ..", GOSSIP_SENDER_MAIN, buffs);
-		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
-		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
-		return true;
-
-	case closemenu:
-		player->CLOSE_GOSSIP_MENU();break;
-		return true;
-	}
-
-return true;
-}
-};
-
-void AddSC_npc_buffNPC()
-{
-new npc_buffnpc;
-}
diff --git a/src/server/scripts/Custom/buffnpc.h b/src/server/scripts/Custom/buffnpc.h
deleted file mode 100644
--- a/src/server/scripts/Custom/buffnpc.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// -- Buff NPC Script for MCWoW - by FreeCry -- //
-#ifndef BUFFNPC
-#define BUFFNPC
-
-enum
-{	
-	menu		=		100,
-	closemenu	=		200,
-	buffs		=		300,
-
-	gsdm		=		301,
-	gsdk		=		302,
-	gsdw		=		303,
-	gsdr		=		304,
-	gds			=		305,
-	ai			=		306,
-	buffpkt1	=		307,
-};
-
-#endif
-
diff --git a/src/server/scripts/Custom/guildmaster.cpp b/src/server/scripts/Custom/guildmaster.cpp
deleted file mode 100644
--- a/src/server/scripts/Custom/guildmaster.cpp
+++ /dev/null
@@ -1,339 +0,0 @@
-#include "ScriptPCH.h"
-
-//extern DatabaseMysql SD2Database;
-
-extern WorldDatabaseWorkerPool WorldDatabase;
-
-#define ALREADY_HOUSE_GOSSIP_MESSAGE "You have already have a guild house : %s"
-#define MSG_GOSSIP_TELE "Teleport to the guild house"
-#define MSG_GOSSIP_BUY "Buy guild house for (1000 Or)"
-#define MSG_GOSSIP_SELL "Sell guild house for (500 Or)"
-#define MSG_GOSSIP_NEXTPAGE "Next page -->"
-#define MSG_INCOMBAT "You can't get into the guild house as long as you don't leave the battlefield"
-#define MSG_NOGUILDHOUSE "Your guild don't have a guild house!"
-#define MSG_NOFREEGH "Sorry, but all guild house is buy"
-#define MSG_ALREADYHAVEGH "You have already a guild house(%s)."
-#define MSG_NOTENOUGHMONEY "You don't have enough money to buy a guild house"
-#define MSG_GHOCCUPIED "This guild house isn't available for sale or used by someone else"
-#define MSG_CONGRATULATIONS "Congratulations, you've just bought a guild house!"
-#define MSG_SOLD "You sold the guild house and got him %u d'Or."
-#define MSG_NOTINGUILD "To order a guild house, you need to join the guild!"
-
-#define CODE_SELL "SELL"
-#define MSG_CODEBOX_SELL "Type \"" CODE_SELL "\" into the field to confirm that you want to sell your GuildHouse."
-
-#define OFFSET_GH_ID_TO_ACTION 1500
-#define OFFSET_SHOWBUY_FROM 10000
-
-#define ACTION_TELE 1001
-#define ACTION_SHOW_BUYLIST 1002 //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
-#define ACTION_SELL_GUILDHOUSE 1003
-
-#define ICON_GOSSIP_BALOON 0
-#define ICON_GOSSIP_WING 2
-#define ICON_GOSSIP_BOOK 3
-#define ICON_GOSSIP_WHEEL1 4
-#define ICON_GOSSIP_WHEEL2 5
-#define ICON_GOSSIP_GOLD 6
-#define ICON_GOSSIP_BALOONDOTS 7
-#define ICON_GOSSIP_TABARD 8
-#define ICON_GOSSIP_XSWORDS 9
-
-#define COST_GH_BUY 10000000 //1000 g.
-#define COST_GH_SELL 5000000 //500 g.
-
-#define GOSSIP_COUNT_MAX 10
-
-bool isPlayerGuildLeader(Player *player)
-{
-	return (player->GetRank() == 0) && (player->GetGuildId() != 0);
-}
-
-bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
-{
-	if (guildId == 0)
-	{
-		//if player has no guild
-		return false;
-	}
-
-	QueryResult result;
-	result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guildhouses` WHERE `guildId` = %u", guildId);
-	if (result)
-	{
-		Field *fields = result->Fetch();
-		x = fields[0].GetFloat();
-		y = fields[1].GetFloat();
-		z = fields[2].GetFloat();
-		map = fields[3].GetUInt32();
-		return true;
-	}
-	
-	return false;
-}
-
-void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
-{
-	if (player->GetGuildId() == 0)
-	{
-		//if player has no guild
-		_creature->MonsterWhisper(MSG_NOTINGUILD, player->GetGUID());
-		return;
-	}
-
-	if (!player->getAttackers().empty())
-	{
-		//if player in combat
-		_creature->MonsterSay(MSG_INCOMBAT, LANG_UNIVERSAL, player->GetGUID());
-		return;
-	}
-
-	float x, y, z;
-	uint32 map;
-
-	if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
-	{
-		//teleport player to the specified location
-		player->TeleportTo(map, x, y, z, 0.0f);
-	}
-	else
-		_creature->MonsterWhisper(MSG_NOGUILDHOUSE, player->GetGUID());
-}
-
-bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
-{
-	//show not occupied guildhouses
-
-	QueryResult result;
-	result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guildhouses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
-	showFromId, GOSSIP_COUNT_MAX);
-
-	if (result)
-	{
-		uint32 guildhouseId = 0;
-		std::string comment = "";
-		do
-		{
-			Field *fields = result->Fetch();
-			guildhouseId = fields[0].GetInt32();
-			comment = fields[1].GetString();
-
-			//send comment as a gossip item
-			//transmit guildhouseId in Action variable
-			player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
-			guildhouseId + OFFSET_GH_ID_TO_ACTION);
-		} 
-		while (result->NextRow());
-
-		if (result->GetRowCount() == GOSSIP_COUNT_MAX)
-		{
-			//assume that we have additional page
-			//add link to next GOSSIP_COUNT_MAX items
-			player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN,
-			guildhouseId + OFFSET_SHOWBUY_FROM);
-		}
-
-		player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
-
-		return true;
-	} 
-	else
-	{
-		if (showFromId = 0)
-		{
-			//all guildhouses are occupied
-			_creature->MonsterWhisper(MSG_NOFREEGH, player->GetGUID());
-			player->CLOSE_GOSSIP_MENU();
-		} 
-		else
-		{
-			//this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
-			//just show GHs from beginning
-			showBuyList(player, _creature, 0);
-		}
-	}
-
-	return false;
-}
-
-bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
-{
-	QueryResult result;
-	result = WorldDatabase.PQuery("SELECT `comment` FROM `guildhouses` WHERE `guildId` = %u",
-	player->GetGuildId());
-
-	if (result)
-	{
-		if (whisper)
-		{
-			//whisper to player "already have etc..."
-			Field *fields = result->Fetch();
-			char msg[100];
-			sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetString());
-			_creature->MonsterWhisper(msg, player->GetGUID());
-		}
-
-		return true;
-	}
-	
-	return false;
-}
-
-void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
-{
-	if (player->GetMoney() < COST_GH_BUY)
-	{
-		//show how much money player need to buy GH (in gold)
-		char msg[100];
-		sprintf(msg, MSG_NOTENOUGHMONEY, COST_GH_BUY / 10000);
-		_creature->MonsterWhisper(msg, player->GetGUID());
-		return;
-	}
-
-	if (isPlayerHasGuildhouse(player, _creature, true))
-	{
-		//player already have GH
-		return;
-	}
-
-	QueryResult result;
-
-	//check if somebody already occupied this GH
-	result = WorldDatabase.PQuery("SELECT `id` FROM `guildhouses` WHERE `id` = %u AND `guildId` <> 0", guildhouseId);
-
-	if (result)
-	{
-		_creature->MonsterWhisper(MSG_GHOCCUPIED, player->GetGUID());
-		return;
-	}
-
-	//update DB
-	result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = %u WHERE `id` = %u",
-	player->GetGuildId(), guildhouseId);
-
-	if (result)
-	player->ModifyMoney(-COST_GH_BUY);
-	_creature->MonsterSay(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player->GetGUID());
-}
-
-void sellGuildhouse(Player *player, Creature *_creature)
-{
-	if (isPlayerHasGuildhouse(player, _creature))
-	{
-		QueryResult result;
-		result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = 0 WHERE `guildId` = %u",
-		player->GetGuildId());
-
-		if (result)
-		player->ModifyMoney(COST_GH_SELL);
-
-		//display message e.g. "here your money etc."
-		char msg[100];
-		sprintf(msg, MSG_SOLD, COST_GH_SELL / 10000);
-		_creature->MonsterWhisper(msg, player->GetGUID());
-	}
-}
-
-class guildmaster : public CreatureScript
-{
-	public:
-        guildmaster() : CreatureScript("guildmaster") { }
-	
-    bool GossipSelectWithCode(Player *player, Creature *_creature, uint32 sender, uint32 action, const char* sCode)
-    {
-    	if (sender == GOSSIP_SENDER_MAIN)
-    	{
-    		if (action == ACTION_SELL_GUILDHOUSE)
-    		{
-    			int i = -1;
-    			try
-    			{
-    				//compare code
-    				
-    				if (strlen(sCode) + 1 == sizeof CODE_SELL)
-    				i = strcmp(CODE_SELL, sCode);
-    			} 
-    			
-    			catch(char *str) {sLog.outErrorDb(str);
-    		}
-
-    		if (i == 0)
-    		{
-    			//right code
-    			sellGuildhouse(player, _creature);
-    		}
-    		
-    		player->CLOSE_GOSSIP_MENU();
-    		return true;
-    	}
-     }
-     return false;
-}
-
-    bool OnGossipSelect(Player *player, Creature *_creature, uint32 sender, uint32 action)
-    {
-		player->PlayerTalkClass->ClearMenus();
-    	if (sender != GOSSIP_SENDER_MAIN)
-    	return false;
-
-    	switch (action)
-    	{
-    	case ACTION_TELE:
-    		//teleport player to GH
-    		player->CLOSE_GOSSIP_MENU();
-    		teleportPlayerToGuildHouse(player, _creature);
-    	break;
-    	case ACTION_SHOW_BUYLIST:
-    		//show list of GHs which currently not occupied
-    		showBuyList(player, _creature);
-    	break;
-    	default:
-    		if (action > OFFSET_SHOWBUY_FROM)
-    		{
-    			showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
-    		} 
-    		else if (action > OFFSET_GH_ID_TO_ACTION)
-    		{
-    			//player clicked on buy list
-    			player->CLOSE_GOSSIP_MENU();
-    			
-    			//get guildhouseId from action
-    			//guildhouseId = action - OFFSET_GH_ID_TO_ACTION
-    			buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
-    		}
-    	break;
-     }
-
-    	return true;
-    }
-
-
-    bool OnGossipHello(Player *player, Creature *_creature)
-    {
-    	player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE,
-    	GOSSIP_SENDER_MAIN, ACTION_TELE);
-
-    	if (isPlayerGuildLeader(player))
-    	{
-    		if (isPlayerHasGuildhouse(player, _creature))
-    		{
-    			//and additional for guildhouse owner (Removed : player->PlayerTalkClass->GetGossipMenu().AddMenuItem(ICON_GOSSIP_GOLD, MSG_GOSSIP_SELL, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_CODEBOX_SELL, 0, true);)
-			}
-			else
-			{
-				//show additional menu for guild leader
-				player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, MSG_GOSSIP_BUY,
-				GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
-			}
-    	}
-    	
-    	player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
-    	return true;
-    }
-
-
-};
-void AddSC_guildmaster()
-{
-    new guildmaster();
-}
diff --git a/src/server/scripts/Custom/hunterpet_vendor.cpp b/src/server/scripts/Custom/hunterpet_vendor.cpp
deleted file mode 100644
Binary file src/server/scripts/Custom/hunterpet_vendor.cpp has changed
diff --git a/src/server/scripts/Custom/hunterpet_vendor.h b/src/server/scripts/Custom/hunterpet_vendor.h
deleted file mode 100644
--- a/src/server/scripts/Custom/hunterpet_vendor.h
+++ /dev/null
@@ -1,56 +0,0 @@
-// -- Custom Hunter-Vendor Script By MCWoW (FreeCry) -- //
-
-#ifndef HUNTERPETVENDOR
-#define HUNTERPETVENDOR
-
-    enum normalpets
-	{
-	main					=  100,
-	pets					=  200,
-	exotic					=  300,
-	felshetzer				=  201,
-	fledermaus				=  202,
-	netherrochen			=  203,
-	raubvogelrot			=  204,
-	raubvogelschwarz		=  205,
-	raubvogelweiss			=  206,
-	schlange				=  207,
-	spinne					=  208,
-	gorillaschwarz			=  209,
-	gorillaweiss			=  210,
-	krebs					=  211,
-	krokolisk				=  212,
-	aasvogel				=  213,
-	hyaene					=  214,
-	katzetiger				=  215,
-	katzeloewe				=  216,
-	katzeluchs				=  217,
-	raptorgruen				=  218,
-	raptorrot				=  219,	
-	weitschreiter			=  220,
-	wesperot				=  221,
-	wespeblau				=  222,
-	wolfruestung			=  223,
-	wolfgrau				=  224,
-	wolfweiss				=  225
-	};
-	
-	enum exotic
-	{
-	schimaere				=  326,
-	silithidgelb			=  327,
-	silithidrot				=  328,
-	rhinozeros				=  329,
-	wurmbraun				=  330,
-	wurmgelb				=  331,
-	kernhundweiss			=  332,
-	kernhundrot				=  333,
-	teufelssaurierweiss		=  334,
-	teufelssaurierschwarz	=  335,
-	skoll					=  336,
-	loque					=  337,
-	gondria					=  338,
-	arcturis				=  339
-};
-
-#endif
diff --git a/src/server/scripts/World/CMakeLists.txt b/src/server/scripts/World/CMakeLists.txt
--- a/src/server/scripts/World/CMakeLists.txt
+++ b/src/server/scripts/World/CMakeLists.txt
@@ -15,7 +15,6 @@
   World/boss_taerar.cpp
   World/npc_mount.cpp
   World/go_scripts.cpp
-  World/pvp_system_streaks.cpp
   World/npc_innkeeper.cpp
   World/dungeon_finder.cpp
   World/achievement_scripts.cpp
diff --git a/src/server/scripts/World/pvp_system_streaks.cpp b/src/server/scripts/World/pvp_system_streaks.cpp
deleted file mode 100644
--- a/src/server/scripts/World/pvp_system_streaks.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-
-//  Posted by kjanko @ http://forum.trinitycore.org/topic/28829-killstreak-pvp-system/
-//  Updated By {VAS} KalCorp to 1.01
-
-
-#include "ScriptPCH.h"
-#include "Configuration/Config.h"
-#include "ScriptMgr.h"
-#include "string.h"
-
-float version = 1.01f;
-std::string PVP_System_Streaks = "";
-uint32 PVP_System_Last_Streak = 50;
-int PVP_System_LoseToken = 0;
-int PVP_System_AnyPlace = 0;
-int PVP_System_BattleGounds = 1;
-int PVP_System_SamePlayer = 1;
-int PVP_System_AddToken = 0;
-std::string PVP_System_Color = "cffFF8000";
-
-
-struct SystemInfo
-{
-    uint32 KillStreak;
-    uint32 LastGUIDKill;
-};
-
-static std::map<uint32, SystemInfo> KillingStreak;
-
-class PVP_System_Streaks_WorldScript : public WorldScript
-{
-    public:
-        PVP_System_Streaks_WorldScript() : WorldScript("PVP_System_Streaks_WorldScript") {}
-
-
-	void SetInitialWorldSettings()
-	{
-		//Needs VAS-Hooks v1.01+ to work
-
-		sLog.outString("----------------------------------------------------");
-		sLog.outString("  Powered by PVP System Streaks v%4.2f ",version); 
-		sLog.outString("----------------------------------------------------");
-
-		PVP_System_Streaks = sConfig.GetStringDefault("PVP.System.Streaks", "5,10,20,30,40,50");
-		PVP_System_Last_Streak = sConfig.GetIntDefault("PVP_System.Last.Streak", 50);
-		PVP_System_LoseToken = sConfig.GetIntDefault("PVP.System.LoseToken", 0);
-		PVP_System_AnyPlace = sConfig.GetIntDefault("PVP.System.AnyPlace", 0);
-		PVP_System_BattleGounds = sConfig.GetIntDefault("PVP.System.BattleGounds", 1);
-		PVP_System_Color = sConfig.GetStringDefault("PVP.System.Color", "cffFF8000");
-		PVP_System_SamePlayer = sConfig.GetIntDefault("PVP.System.SamePlayer", 1);
-		PVP_System_AddToken = sConfig.GetIntDefault("PVP.System.AddToken", 1);
-
-		sLog.outString("  PVP.System.Streaks = %s", PVP_System_Streaks);
-		sLog.outString("  PVP.System.Last.Streak = %u", PVP_System_Last_Streak);
-		sLog.outString("  PVP.System.AnyPlace = %u", PVP_System_AnyPlace);
-		sLog.outString("  PVP.System.BattleGounds = %u", PVP_System_BattleGounds);
-		sLog.outString("  PVP.System.SamePlayer = %u", PVP_System_SamePlayer);
-		sLog.outString("  PVP.System.AddToken = %u", PVP_System_AddToken);
-		sLog.outString("  PVP.System.LoseToken = %u", PVP_System_LoseToken);
-		sLog.outString("  PVP.System.Color = %s", PVP_System_Color.c_str());
-
-		sLog.outString("  Contributors: kjanko, Rusfighter, KalCorp");
-
-		sLog.outString("----------------------------------------------------\n");
-	}
-};
-
-class PVP_System_Streaks_PlayerScript : public PlayerScript
-{
-    public:
-        PVP_System_Streaks_PlayerScript() : PlayerScript("PVP_System_Streaks_PlayerScript") {}
-
-	void OnPVPKill(Player *pKiller, Player *pVictim)
-	{
-		uint32 kGUID; 
-		uint32 vGUID;
-		kGUID = pKiller->GetGUID();
-		vGUID = pVictim->GetGUID(); 
-		char msg[500];
-
-		sLog.outString("PVP_System_Streaks_PlayerScript started");
-
-		if (PVP_System_AnyPlace != 0)
-			if ((!pKiller->GetMap()->IsBattleground()) && PVP_System_BattleGounds != 1)
-				return;
-
-		if(kGUID == vGUID)
-			return;
-                
-		if(KillingStreak[kGUID].LastGUIDKill == vGUID)
-			if (PVP_System_SamePlayer !=1 )
-				return;
-
-                
-		KillingStreak[kGUID].KillStreak++;
-		KillingStreak[vGUID].KillStreak = 0;
-		KillingStreak[kGUID].LastGUIDKill = vGUID;
-		KillingStreak[vGUID].LastGUIDKill = 0;
-
-		if (PVP_System_AddToken == 1)
-			pKiller->AddItem(29434, 1);
-
-		if (PVP_System_LoseToken == 1)
-			pVictim->DestroyItemCount(29434,1,true,false);
-
-
- 
-		if ( CheckString(PVP_System_Streaks,KillingStreak[kGUID].KillStreak) )
-		{
-			sprintf(msg, "|%s[PvP System]: %s killed %s and is on a %u Killing Streak! |r",PVP_System_Color.c_str(), pKiller->GetName(), pVictim->GetName(),KillingStreak[kGUID].KillStreak);
-			sWorld.SendWorldText(LANG_SYSTEMMESSAGE, msg);
-			pKiller->AddItem(29434, int(KillingStreak[kGUID].KillStreak/2));
-			if (KillingStreak[kGUID].KillStreak >= PVP_System_Last_Streak)
-				KillingStreak[kGUID].KillStreak = 0;
-		}
-	}
-
-	bool CheckString(std::string IDString,int CurrentID)
-	{
-        std::string temp_str;
-        std::stringstream map_ss;
-		map_ss.str(IDString);
-        while (std::getline(map_ss, temp_str, ','))
-        {
-			std::stringstream ss2(temp_str);
-			int temp_num = -1;
-			ss2 >> temp_num;
-			if (temp_num >= 0)
-			{
-				if (temp_num == CurrentID)
-						return true;
-				}
-		}
-		return false;
-	}
-
-	void OnLogin(Player *Player)
-	{
-
-		PVP_System_Streaks = sConfig.GetStringDefault("PVP.System.Streaks", "5,10,20,30,40,50");
-		PVP_System_Last_Streak = sConfig.GetIntDefault("PVP_System.Last.Streak", 50);
-		PVP_System_LoseToken = sConfig.GetIntDefault("PVP.System.LoseToken", 0);
-		PVP_System_AnyPlace = sConfig.GetIntDefault("PVP.System.AnyPlace", 0);
-		PVP_System_BattleGounds = sConfig.GetIntDefault("PVP.System.BattleGounds", 1);
-		PVP_System_Color = sConfig.GetStringDefault("PVP.System.Color", "cffFF8000");
-		PVP_System_SamePlayer = sConfig.GetIntDefault("PVP.System.SamePlayer", 1);
-		PVP_System_AddToken = sConfig.GetIntDefault("PVP.System.AddToken", 1);
-
-		ChatHandler chH = ChatHandler(Player);
-		chH.PSendSysMessage("\n|%s----------------------------------------------------|r",PVP_System_Color.c_str());
-		chH.PSendSysMessage("|%s  Powered by {VAS} PVP System Streaks v%4.2f |r",PVP_System_Color.c_str(),version);
-		chH.PSendSysMessage("|%s----------------------------------------------------|r \n",PVP_System_Color.c_str());
-		chH.PSendSysMessage("|%s  PVP.System.Streaks = %s|r",PVP_System_Color.c_str(), PVP_System_Streaks);
-		chH.PSendSysMessage("|%s  PVP.System.Last.Streak = %u|r",PVP_System_Color.c_str(), PVP_System_Last_Streak);
-		chH.PSendSysMessage("|%s  PVP.System.AnyPlace = %u|r",PVP_System_Color.c_str(), PVP_System_AnyPlace);
-		chH.PSendSysMessage("|%s  PVP.System.BattleGounds = %u|r",PVP_System_Color.c_str(), PVP_System_BattleGounds);
-		chH.PSendSysMessage("|%s----------------------------------------------------|r \n",PVP_System_Color.c_str());
-	}
-
-};
-
-
-void AddSC_PVP_System()
-{
-    new PVP_System_Streaks_PlayerScript;
-	new PVP_System_Streaks_WorldScript;
-}
\ No newline at end of file
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.cpp b/src/server/shared/Database/Implementation/WorldDatabase.cpp
--- a/src/server/shared/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/shared/Database/Implementation/WorldDatabase.cpp
@@ -37,6 +37,8 @@
     PrepareStatement(WORLD_REP_CRELINKED_RESPAWN, "REPLACE INTO creature_linked_respawn (guid,linkedGuid) VALUES (?, ?)");
     PrepareStatement(WORLD_DEL_GAMEOBJECT_RESPAWN_TIMES, "DELETE FROM gameobject_respawn WHERE respawntime <= UNIX_TIMESTAMP(NOW())");
     PrepareStatement(WORLD_LOAD_CRETEXT, "SELECT entry, groupid, id, text, type, language, probability, emote, duration, sound FROM creature_text");
+	PrepareStatement(WORLD_LOAD_SMART_SCRIPTS,  "SELECT entryorguid, source_type, id, link, event_type, event_phase_mask, event_chance, event_flags, event_param1, event_param2, event_param3, event_param4, action_type, action_param1, action_param2, action_param3, action_param4, action_param5, action_param6, target_type, target_param1, target_param2, target_param3, target_x, target_y, target_z, target_o FROM smart_scripts");
+	PrepareStatement(WORLD_LOAD_SMARTAI_WP,  "SELECT entry, pointid, position_x, position_y, position_z FROM waypoints ORDER BY entry, pointid");
 
     return true;
 }
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.h b/src/server/shared/Database/Implementation/WorldDatabase.h
--- a/src/server/shared/Database/Implementation/WorldDatabase.h
+++ b/src/server/shared/Database/Implementation/WorldDatabase.h
@@ -50,6 +50,8 @@
     WORLD_REP_CRELINKED_RESPAWN,
     WORLD_DEL_GAMEOBJECT_RESPAWN_TIMES,
     WORLD_LOAD_CRETEXT,
+	WORLD_LOAD_SMART_SCRIPTS,
+	WORLD_LOAD_SMARTAI_WP,
     MAX_WORLDDATABASE_STATEMENTS,
 };
 
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -73,6 +73,7 @@
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/EventAI
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse/AuctionHouseBot
   ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2166,22 +2166,6 @@
 LevelReq.Mail = 1
 DungeonFinder.Enable = 1
 
-###############################################################################
-#
-# 		PVP System
-#
-#		0=Off,  1=On
-#
-###############################################################################
-PVP.System.Streaks = 2,5,10,20,30,40,50
-PVP.System.Last.Streak = 50
-PVP.System.LoseToken = 0
-PVP.System.AnyPlace = 0
-PVP.System.BattleGounds = 1
-PVP.System.SamePlayer = 0
-PVP_System_AddToken = 0
-PVP.System.Color = cffC400C4
-
 #######################################################################
 #   OutdoorPvP.Wintergrasp.Enabled
 #       Determines whether the Wintergrasp battle is enabled or not.
