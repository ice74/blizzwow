# HG changeset patch
# User asniker
# Date 1288684016 -18000
# Node ID 707ee118f59383468721c61787bd41e06eb9cf0d
# Parent  869efe898cdc4ac0eb0def41e47f5429f84d8add
fix crash after logout and fix cmake

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2005-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2005-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/PreLoad.cmake b/PreLoad.cmake
--- a/PreLoad.cmake
+++ b/PreLoad.cmake
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2005-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2005-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/cmake/compiler/gcc/settings.cmake b/cmake/compiler/gcc/settings.cmake
--- a/cmake/compiler/gcc/settings.cmake
+++ b/cmake/compiler/gcc/settings.cmake
@@ -1,4 +1,4 @@
-﻿# Set build-directive (used in core to tell which buildtype we used)
+# Set build-directive (used in core to tell which buildtype we used)
 add_definitions(-D_BUILD_DIRECTIVE="${CMAKE_BUILD_TYPE}")
 
 add_definitions(-fno-delete-null-pointer-checks)
diff --git a/cmake/compiler/icc/settings.cmake b/cmake/compiler/icc/settings.cmake
--- a/cmake/compiler/icc/settings.cmake
+++ b/cmake/compiler/icc/settings.cmake
@@ -1,4 +1,4 @@
-﻿# Set build-directive (used in core to tell which buildtype we used)
+# Set build-directive (used in core to tell which buildtype we used)
 add_definitions(-D_BUILD_DIRECTIVE="${CMAKE_BUILD_TYPE}")
 
 if( USE_SFMT)
diff --git a/cmake/compiler/msvc/settings.cmake b/cmake/compiler/msvc/settings.cmake
--- a/cmake/compiler/msvc/settings.cmake
+++ b/cmake/compiler/msvc/settings.cmake
@@ -1,4 +1,4 @@
-﻿# set up output paths for executable binaries (.exe-files, and .dll-files on DLL-capable platforms)
+# set up output paths for executable binaries (.exe-files, and .dll-files on DLL-capable platforms)
 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
 
 # set up output paths ofr static libraries etc (commented out - shown here as an example only)
diff --git a/cmake/compiler/xcode/settings.cmake b/cmake/compiler/xcode/settings.cmake
--- a/cmake/compiler/xcode/settings.cmake
+++ b/cmake/compiler/xcode/settings.cmake
@@ -1,3 +1,3 @@
-﻿# Set build-directive (used in core to tell which buildtype we used)
+# Set build-directive (used in core to tell which buildtype we used)
 add_definitions(-D_BUILD_DIRECTIVE="$(CONFIGURATION)")
 
diff --git a/cmake/genrev.cmake b/cmake/genrev.cmake
--- a/cmake/genrev.cmake
+++ b/cmake/genrev.cmake
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/cmake/macros/CheckBuildDir.cmake b/cmake/macros/CheckBuildDir.cmake
--- a/cmake/macros/CheckBuildDir.cmake
+++ b/cmake/macros/CheckBuildDir.cmake
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/cmake/macros/CheckPlatform.cmake b/cmake/macros/CheckPlatform.cmake
--- a/cmake/macros/CheckPlatform.cmake
+++ b/cmake/macros/CheckPlatform.cmake
@@ -1,4 +1,4 @@
-﻿# check what platform we're on (64-bit or 32-bit), and create a simpler test than CMAKE_SIZEOF_VOID_P
+# check what platform we're on (64-bit or 32-bit), and create a simpler test than CMAKE_SIZEOF_VOID_P
 if(CMAKE_SIZEOF_VOID_P MATCHES 8)
     set(PLATFORM 64)
     MESSAGE(STATUS "Detected 64-bit platform")
diff --git a/cmake/macros/EnsureVersion.cmake b/cmake/macros/EnsureVersion.cmake
--- a/cmake/macros/EnsureVersion.cmake
+++ b/cmake/macros/EnsureVersion.cmake
@@ -1,4 +1,4 @@
-﻿# This file defines the following macros for developers to use in ensuring
+# This file defines the following macros for developers to use in ensuring
 # that installed software is of the right version:
 #
 # ENSURE_VERSION        - test that a version number is greater than
diff --git a/cmake/macros/FindACE.cmake b/cmake/macros/FindACE.cmake
--- a/cmake/macros/FindACE.cmake
+++ b/cmake/macros/FindACE.cmake
@@ -1,4 +1,4 @@
-﻿#
+#
 # Find the ACE client includes and library
 # 
 
diff --git a/cmake/macros/FindMySQL.cmake b/cmake/macros/FindMySQL.cmake
--- a/cmake/macros/FindMySQL.cmake
+++ b/cmake/macros/FindMySQL.cmake
@@ -1,4 +1,4 @@
-﻿#
+#
 # Find the MySQL client includes and library
 # 
 
diff --git a/cmake/macros/FindOpenSSL.cmake b/cmake/macros/FindOpenSSL.cmake
--- a/cmake/macros/FindOpenSSL.cmake
+++ b/cmake/macros/FindOpenSSL.cmake
@@ -1,4 +1,4 @@
-﻿#
+#
 # Find the OpenSSL client includes and library
 # 
 
diff --git a/cmake/macros/FindPCHSupport.cmake b/cmake/macros/FindPCHSupport.cmake
--- a/cmake/macros/FindPCHSupport.cmake
+++ b/cmake/macros/FindPCHSupport.cmake
@@ -1,4 +1,4 @@
-﻿# - Try to find precompiled headers support for GCC 3.4 and 4.x (and MSVC)
+# - Try to find precompiled headers support for GCC 3.4 and 4.x (and MSVC)
 # Once done this will define:
 #
 # Variable:
diff --git a/cmake/macros/FindReadline.cmake b/cmake/macros/FindReadline.cmake
--- a/cmake/macros/FindReadline.cmake
+++ b/cmake/macros/FindReadline.cmake
@@ -1,4 +1,4 @@
-﻿# find Readline (terminal input library) includes and library
+# find Readline (terminal input library) includes and library
 #
 # READLINE_INCLUDE_DIR - where the directory containing the READLINE headers can be found
 # READLINE_LIBRARY     - full path to the READLINE library
diff --git a/cmake/options.cmake b/cmake/options.cmake
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/cmake/platform/osx/settings.cmake b/cmake/platform/osx/settings.cmake
--- a/cmake/platform/osx/settings.cmake
+++ b/cmake/platform/osx/settings.cmake
@@ -1,4 +1,4 @@
-﻿set(MACOSX 1)
+set(MACOSX 1)
 set(OSX_LIBS /usr/lib/libcrypto.dylib)
 add_definitions(-D__ASSERTMACROS__)
 
diff --git a/cmake/platform/settings.cmake b/cmake/platform/settings.cmake
--- a/cmake/platform/settings.cmake
+++ b/cmake/platform/settings.cmake
@@ -1,4 +1,4 @@
-﻿# set installation prefix
+# set installation prefix
 if( PREFIX )
   set(CMAKE_INSTALL_PREFIX "${PREFIX}")
 endif()
diff --git a/cmake/platform/unix/cmake_uninstall.in.cmake b/cmake/platform/unix/cmake_uninstall.in.cmake
--- a/cmake/platform/unix/cmake_uninstall.in.cmake
+++ b/cmake/platform/unix/cmake_uninstall.in.cmake
@@ -1,4 +1,4 @@
-﻿# from cmake wiki
+# from cmake wiki
 IF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
   MESSAGE(FATAL_ERROR "Cannot find install manifest: \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\"")
 ENDIF(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
diff --git a/cmake/platform/unix/settings.cmake b/cmake/platform/unix/settings.cmake
--- a/cmake/platform/unix/settings.cmake
+++ b/cmake/platform/unix/settings.cmake
@@ -1,4 +1,4 @@
-﻿# set default configuration directory
+# set default configuration directory
 if( NOT CONF_DIR )
   set(CONF_DIR ${CMAKE_INSTALL_PREFIX}/etc)
   message(STATUS "UNIX: Using default configuration directory")
diff --git a/cmake/platform/win/settings.cmake b/cmake/platform/win/settings.cmake
--- a/cmake/platform/win/settings.cmake
+++ b/cmake/platform/win/settings.cmake
@@ -1,4 +1,4 @@
-﻿# Platform-specfic options
+# Platform-specfic options
 option(USE_MYSQL_SOURCES "Use included MySQL-sources to build libraries" 1)
 
 # Package overloads
diff --git a/cmake/showoptions.cmake b/cmake/showoptions.cmake
--- a/cmake/showoptions.cmake
+++ b/cmake/showoptions.cmake
@@ -1,4 +1,4 @@
-﻿# output generic information about the core and buildtype chosen
+# output generic information about the core and buildtype chosen
 
 message("")
 message("* TrinityCore revision   : ${rev_id_str} (${rev_hash_str})")
diff --git a/revision.h.in.cmake b/revision.h.in.cmake
--- a/revision.h.in.cmake
+++ b/revision.h.in.cmake
@@ -1,4 +1,4 @@
-﻿#ifndef __REVISION_H__
+#ifndef __REVISION_H__
 #define __REVISION_H__
  #define _REVISION      "7"
  #define _HASH          "01.11.10"
diff --git a/sql/CMakeLists.txt b/sql/CMakeLists.txt
--- a/sql/CMakeLists.txt
+++ b/sql/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿if( WITH_SQL )
+if( WITH_SQL )
   add_subdirectory(updates)
   add_subdirectory(scripts)
   add_subdirectory(base)
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/revision.h/CMakeLists.txt b/src/revision.h/CMakeLists.txt
--- a/src/revision.h/CMakeLists.txt
+++ b/src/revision.h/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/server/CMakeLists.txt b/src/server/CMakeLists.txt
--- a/src/server/CMakeLists.txt
+++ b/src/server/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/server/authserver/CMakeLists.txt b/src/server/authserver/CMakeLists.txt
--- a/src/server/authserver/CMakeLists.txt
+++ b/src/server/authserver/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/server/collision/CMakeLists.txt b/src/server/collision/CMakeLists.txt
--- a/src/server/collision/CMakeLists.txt
+++ b/src/server/collision/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -1174,10 +1174,8 @@
             plr->SetBattlegroundRaid(group, subgroup);
         }
         else
-        {
-            SQLTransaction trans = CharacterDatabase.BeginTransaction();
-            group->AddMember(plr_guid, plr->GetName(),trans);
-            CharacterDatabase.CommitTransaction(trans);
+        {       
+            group->AddMember(plr_guid, plr->GetName());         
             if (Group* originalGroup = plr->GetOriginalGroup())
                 if (originalGroup->IsLeader(plr_guid))
                     group->ChangeLeader(plr_guid);
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/server/game/DungeonFinding/LFG.h b/src/server/game/DungeonFinding/LFG.h
--- a/src/server/game/DungeonFinding/LFG.h
+++ b/src/server/game/DungeonFinding/LFG.h
@@ -1,67 +1,66 @@
-﻿/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#ifndef _LFG_H
-#define _LFG_H
-
-enum LfgRoles
-{
-    ROLE_NONE   = 0x00,
-    ROLE_LEADER = 0x01,
-    ROLE_TANK   = 0x02,
-    ROLE_HEALER = 0x04,
-    ROLE_DAMAGE = 0x08,
-};
-
-enum LfgState
-{
-    LFG_STATE_NONE = 0,                                     // Not using LFG / LFR
-    LFG_STATE_LFG  = 1,                                     // Using Dungeon finder
-    LFG_STATE_LFR  = 2,                                     // Using Raid finder
-};
-
-enum LfgUpdateType
-{
-    LFG_UPDATETYPE_LEADER               = 1,
-    LFG_UPDATETYPE_ROLECHECK_ABORTED    = 4,
-    LFG_UPDATETYPE_JOIN_PROPOSAL        = 5,
-    LFG_UPDATETYPE_ROLECHECK_FAILED     = 6,
-    LFG_UPDATETYPE_REMOVED_FROM_QUEUE   = 7,
-    LFG_UPDATETYPE_PROPOSAL_FAILED      = 8,
-    LFG_UPDATETYPE_PROPOSAL_DECLINED    = 9,
-    LFG_UPDATETYPE_GROUP_FOUND          = 10,
-    LFG_UPDATETYPE_ADDED_TO_QUEUE       = 12,
-    LFG_UPDATETYPE_PROPOSAL_BEGIN       = 13,
-    LFG_UPDATETYPE_CLEAR_LOCK_LIST      = 14,
-    LFG_UPDATETYPE_GROUP_MEMBER_OFFLINE = 15,
-    LFG_UPDATETYPE_GROUP_DISBAND        = 16,
-};
-
-typedef std::set<uint32> LfgDungeonSet;
-
-struct LookingForGroup
-{
-    LookingForGroup(): roles(0), update(true), state(LFG_STATE_NONE) {}
-    uint8 roles;
-    bool update;
-    LfgState state;
-    LfgDungeonSet applyDungeons;                            // Dungeons the player have applied for
-    std::string comment;
-};
-
-#endif
+﻿/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _LFG_H
+#define _LFG_H
+
+enum LfgRoles
+{
+    ROLE_NONE   = 0x00,
+    ROLE_LEADER = 0x01,
+    ROLE_TANK   = 0x02,
+    ROLE_HEALER = 0x04,
+    ROLE_DAMAGE = 0x08,
+};
+
+enum LfgState
+{
+    LFG_STATE_NONE = 0,                                     // Not using LFG / LFR
+    LFG_STATE_LFG  = 1,                                     // Using Dungeon finder
+    LFG_STATE_LFR  = 2,                                     // Using Raid finder
+};
+
+enum LfgUpdateType
+{
+    LFG_UPDATETYPE_LEADER               = 1,
+    LFG_UPDATETYPE_ROLECHECK_ABORTED    = 4,
+    LFG_UPDATETYPE_JOIN_PROPOSAL        = 5,
+    LFG_UPDATETYPE_ROLECHECK_FAILED     = 6,
+    LFG_UPDATETYPE_REMOVED_FROM_QUEUE   = 7,
+    LFG_UPDATETYPE_PROPOSAL_FAILED      = 8,
+    LFG_UPDATETYPE_PROPOSAL_DECLINED    = 9,
+    LFG_UPDATETYPE_GROUP_FOUND          = 10,
+    LFG_UPDATETYPE_ADDED_TO_QUEUE       = 12,
+    LFG_UPDATETYPE_PROPOSAL_BEGIN       = 13,
+    LFG_UPDATETYPE_CLEAR_LOCK_LIST      = 14,
+    LFG_UPDATETYPE_GROUP_MEMBER_OFFLINE = 15,
+    LFG_UPDATETYPE_GROUP_DISBAND        = 16,
+};
+
+typedef std::set<uint32> LfgDungeonSet;
+
+struct LookingForGroup
+{
+    LookingForGroup(): roles(0), update(true), state(LFG_STATE_NONE) {}
+    uint8 roles;
+    bool update;
+    LfgState state;
+    LfgDungeonSet applyDungeons;                            // Dungeons the player have applied for
+    std::string comment;
+};
+
+#endif
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -1,2311 +1,2271 @@
-﻿/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "Common.h"
-#include "SharedDefines.h"
-
-#include "DisableMgr.h"
-#include "ObjectMgr.h"
-#include "ProgressBar.h"
-#include "SocialMgr.h"
-#include "LFGMgr.h"
-
-#include "Group.h"
-#include "Player.h"
-
-// --- Temporal functions
-// Added to try to find bugs that leaves data inconsistent
-void LFGMgr::Cleaner()
-{
-    LfgQueueInfoMap::iterator itQueue;
-    LfgGuidList::iterator itGuidListRemove;
-    LfgGuidList eraseList;
-
-    for (LfgQueueInfoMap::iterator it = m_QueueInfoMap.begin(); it != m_QueueInfoMap.end();)
-    {
-        itQueue = it++;
-        // Remove empty queues
-        if (!itQueue->second)
-        {
-            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from QueueInfoMap, data is null", itQueue->first);
-            m_QueueInfoMap.erase(itQueue);
-        }
-        // Remove queue with empty players
-        else if(!itQueue->second->roles.size())
-        {
-            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from QueueInfoMap, no players in queue!", itQueue->first);
-            m_QueueInfoMap.erase(itQueue);
-        }
-    }
-
-    // Remove from NewToQueue those guids that do not exist in queueMap
-    for (LfgGuidList::iterator it = m_newToQueue.begin(); it != m_newToQueue.end();)
-    {
-        itGuidListRemove = it++;
-        if (m_QueueInfoMap.find(*itGuidListRemove) == m_QueueInfoMap.end())
-        {
-            eraseList.push_back(*itGuidListRemove);
-            m_newToQueue.erase(itGuidListRemove);
-            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from newToQueue, no queue info with that guid", (*itGuidListRemove));
-        }
-    }
-
-    // Remove from currentQueue those guids that do not exist in queueMap
-    for (LfgGuidList::iterator it = m_currentQueue.begin(); it != m_currentQueue.end();)
-    {
-        itGuidListRemove = it++;
-        if (m_QueueInfoMap.find(*itGuidListRemove) == m_QueueInfoMap.end())
-        {
-            eraseList.push_back(*itGuidListRemove);
-            m_newToQueue.erase(itGuidListRemove);
-            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from currentQueue, no queue info with that guid", (*itGuidListRemove));
-        }
-    }
-
-    for (LfgGuidList::iterator it = eraseList.begin(); it != eraseList.end(); ++it)
-    {
-        if (IS_GROUP(*it))
-        {
-            if (Group* grp = sObjectMgr.GetGroupByGUID(GUID_LOPART(*it)))
-                for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-                    if (Player* plr = itr->getSource())
-                        plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-        }
-        else
-            if (Player* plr = sObjectMgr.GetPlayer(*it))
-                plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-    }
-}
-
-LFGMgr::LFGMgr()
-{
-    m_QueueTimer = 0;
-    m_WaitTimeAvg = -1;
-    m_WaitTimeTank = -1;
-    m_WaitTimeHealer = -1;
-    m_WaitTimeDps = -1;
-    m_NumWaitTimeAvg = 0;
-    m_NumWaitTimeTank = 0;
-    m_NumWaitTimeHealer = 0;
-    m_NumWaitTimeDps = 0;
-    m_update = true;
-    m_lfgProposalId = 1;
-    GetAllDungeons();
-}
-
-LFGMgr::~LFGMgr()
-{
-    for (LfgRewardMap::iterator itr = m_RewardMap.begin(); itr != m_RewardMap.end(); ++itr)
-        delete itr->second;
-    m_RewardMap.clear();
-
-    m_EncountersByAchievement.clear();
-
-    for (LfgQueueInfoMap::iterator it = m_QueueInfoMap.begin(); it != m_QueueInfoMap.end(); ++it)
-        delete it->second;
-    m_QueueInfoMap.clear();
-
-    for (LfgProposalMap::iterator it = m_Proposals.begin(); it != m_Proposals.end(); ++it)
-        delete it->second;
-    m_Proposals.clear();
-
-    for (LfgPlayerBootMap::iterator it = m_Boots.begin(); it != m_Boots.end(); ++it)
-        delete it->second;
-    m_Boots.clear();
-
-    for (LfgRoleCheckMap::iterator it = m_RoleChecks.begin(); it != m_RoleChecks.end(); ++it)
-        delete it->second;
-    m_RoleChecks.clear();
-
-    for (LfgDungeonMap::iterator it = m_CachedDungeonMap.begin(); it != m_CachedDungeonMap.end(); ++it)
-        delete it->second;
-    m_CachedDungeonMap.clear();
-
-    m_CompatibleMap.clear();
-    m_QueueInfoMap.clear();
-    m_currentQueue.clear();
-    m_newToQueue.clear();
-}
-
-/// <summary>
-/// Load achievement <-> encounter associations
-/// </summary>
-void LFGMgr::LoadDungeonEncounters()
-{
-    m_EncountersByAchievement.clear();
-
-    uint32 count = 0;
-    QueryResult result = WorldDatabase.Query("SELECT achievementId, dungeonId FROM lfg_dungeon_encounters");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outErrorDb(">> Loaded 0 dungeon encounter lfg associations. DB table `lfg_dungeon_encounters` is empty!");
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    Field* fields = NULL;
-    do
-    {
-        bar.step();
-        fields = result->Fetch();
-        uint32 achievementId = fields[0].GetUInt32();
-        uint32 dungeonId = fields[1].GetUInt32();
-
-        if (AchievementEntry const* achievement = sAchievementStore.LookupEntry(achievementId))
-        {
-            if (!(achievement->flags & ACHIEVEMENT_FLAG_COUNTER))
-            {
-                sLog.outErrorDb("Achievement %u specified in table `lfg_dungeon_encounters` is not a statistic!", achievementId);
-                continue;
-            }
-        }
-        else
-        {
-            sLog.outErrorDb("Achievement %u specified in table `lfg_dungeon_encounters` does not exist!", achievementId);
-            continue;
-        }
-
-        if (!sLFGDungeonStore.LookupEntry(dungeonId))
-        {
-            sLog.outErrorDb("Dungeon %u specified in table `lfg_dungeon_encounters` does not exist!", dungeonId);
-            continue;
-        }
-
-        m_EncountersByAchievement[achievementId] = dungeonId;
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u dungeon encounter lfg associations.", count);
-}
-
-/// <summary>
-/// Load rewards for completing dungeons
-/// </summary>
-void LFGMgr::LoadRewards()
-{
-    for (LfgRewardMap::iterator itr = m_RewardMap.begin(); itr != m_RewardMap.end(); ++itr)
-        delete itr->second;
-    m_RewardMap.clear();
-
-    uint32 count = 0;
-    // ORDER BY is very important for GetRandomDungeonReward!
-    QueryResult result = WorldDatabase.Query("SELECT dungeonId, maxLevel, firstQuestId, firstMoneyVar, firstXPVar, otherQuestId, otherMoneyVar, otherXPVar FROM lfg_dungeon_rewards ORDER BY dungeonId, maxLevel ASC");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outErrorDb(">> Loaded 0 lfg dungeon rewards. DB table `lfg_dungeon_rewards` is empty!");
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    Field* fields = NULL;
-    do
-    {
-        bar.step();
-        fields = result->Fetch();
-        uint32 dungeonId = fields[0].GetUInt32();
-        uint32 maxLevel = fields[1].GetUInt8();
-        uint32 firstQuestId = fields[2].GetUInt32();
-        uint32 firstMoneyVar = fields[3].GetUInt32();
-        uint32 firstXPVar = fields[4].GetUInt32();
-        uint32 otherQuestId = fields[5].GetUInt32();
-        uint32 otherMoneyVar = fields[6].GetUInt32();
-        uint32 otherXPVar = fields[7].GetUInt32();
-
-        if (!sLFGDungeonStore.LookupEntry(dungeonId))
-        {
-            sLog.outErrorDb("Dungeon %u specified in table `lfg_dungeon_rewards` does not exist!", dungeonId);
-            continue;
-        }
-
-        if (!maxLevel || maxLevel > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-        {
-            sLog.outErrorDb("Level %u specified for dungeon %u in table `lfg_dungeon_rewards` can never be reached!", maxLevel, dungeonId);
-            maxLevel = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
-        }
-
-        if (firstQuestId && !sObjectMgr.GetQuestTemplate(firstQuestId))
-        {
-            sLog.outErrorDb("First quest %u specified for dungeon %u in table `lfg_dungeon_rewards` does not exist!", firstQuestId, dungeonId);
-            firstQuestId = 0;
-        }
-
-        if (otherQuestId && !sObjectMgr.GetQuestTemplate(otherQuestId))
-        {
-            sLog.outErrorDb("Other quest %u specified for dungeon %u in table `lfg_dungeon_rewards` does not exist!", otherQuestId, dungeonId);
-            otherQuestId = 0;
-        }
-
-        m_RewardMap.insert(LfgRewardMap::value_type(dungeonId, new LfgReward(maxLevel, firstQuestId, firstMoneyVar, firstXPVar, otherQuestId, otherMoneyVar, otherXPVar)));
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u lfg dungeon rewards.", count);
-}
-
-void LFGMgr::Update(uint32 diff)
-{
-    if (!m_update || !sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
-        return;
-
-    m_update = false;
-    time_t currTime = time(NULL);
-
-    // Remove obsolete role checks
-    LfgRoleCheckMap::iterator itRoleCheck;
-    LfgRoleCheck* pRoleCheck;
-    for (LfgRoleCheckMap::iterator it = m_RoleChecks.begin(); it != m_RoleChecks.end();)
-    {
-        itRoleCheck = it++;
-        pRoleCheck = itRoleCheck->second;
-        if (currTime < pRoleCheck->cancelTime)
-            continue;
-        pRoleCheck->result = LFG_ROLECHECK_MISSING_ROLE;
-
-        Player* plr = NULL;
-        for (LfgRolesMap::const_iterator itRoles = pRoleCheck->roles.begin(); itRoles != pRoleCheck->roles.end(); ++itRoles)
-        {
-            plr = sObjectMgr.GetPlayerByLowGUID(itRoles->first);
-            if (!plr)
-                continue;
-            plr->GetSession()->SendLfgRoleCheckUpdate(pRoleCheck);
-            plr->GetLfgDungeons()->clear();
-            plr->SetLfgRoles(ROLE_NONE);
-            if (!plr->GetGroup() || !plr->GetGroup()->isLFGGroup())
-                plr->SetLfgState(LFG_STATE_NONE);
-
-            if (itRoles->first == pRoleCheck->leader)
-                plr->GetSession()->SendLfgJoinResult(LFG_JOIN_FAILED, pRoleCheck->result);
-        }
-        delete pRoleCheck;
-        m_RoleChecks.erase(itRoleCheck);
-    }
-
-    // Remove obsolete proposals
-    LfgProposalMap::iterator itRemove;
-    for (LfgProposalMap::iterator it = m_Proposals.begin(); it != m_Proposals.end();)
-    {
-        itRemove = it++;
-        if (itRemove->second->cancelTime < currTime)
-            RemoveProposal(itRemove, LFG_UPDATETYPE_PROPOSAL_FAILED);
-    }
-
-    // Remove obsolete kicks
-    LfgPlayerBootMap::iterator itBoot;
-    LfgPlayerBoot* pBoot;
-    for (LfgPlayerBootMap::iterator it = m_Boots.begin(); it != m_Boots.end();)
-    {
-        itBoot = it++;
-        pBoot = itBoot->second;
-        if (pBoot->cancelTime < currTime)
-        {
-            Group* grp = sObjectMgr.GetGroupByGUID(itBoot->first);
-            pBoot->inProgress = false;
-            for (LfgAnswerMap::const_iterator itVotes = pBoot->votes.begin(); itVotes != pBoot->votes.end(); ++itVotes)
-                if (Player* plrg = sObjectMgr.GetPlayerByLowGUID(itVotes->first))
-                    if (plrg->GetGUIDLow() != pBoot->victimLowGuid)
-                        plrg->GetSession()->SendLfgBootPlayer(pBoot);
-            if (grp)
-                grp->SetLfgKickActive(false);
-            delete pBoot;
-            m_Boots.erase(itBoot);
-        }
-    }
-
-    // Consistency cleaner
-    Cleaner();
-
-    // Check if a proposal can be formed with the new groups being added
-    LfgProposalList proposals;
-    LfgGuidList firstNew;
-    while (!m_newToQueue.empty())
-    {
-        sLog.outDebug("LFGMgr::Update: checking [" UI64FMTD "] m_newToQueue(%u), m_currentQueue(%u)", m_newToQueue.front(), uint32(m_newToQueue.size()), uint32(m_currentQueue.size()));
-
-        firstNew.push_back(m_newToQueue.front());
-
-        if (IS_GROUP(firstNew.front()))
-            CheckCompatibility(firstNew, &proposals);       // Check if the group itself match
-
-        if (!proposals.size())
-            FindNewGroups(firstNew, m_currentQueue, &proposals);
-
-        if (proposals.size())                               // Group found!
-        {
-            sLog.outDebug("LFGMgr::Update: Found %u size proposals for [" UI64FMTD "]", uint32(m_newToQueue.front()), firstNew.front());
-            LfgProposal* pProposal = (*proposals.begin());
-            // TODO: Create algorithm to select better group based on GS (uses to be good tank with bad healer and viceversa)
-
-            // Remove groups in the proposal from new and current queues (not from queue map)
-            for (LfgGuidList::const_iterator it = pProposal->queues.begin(); it != pProposal->queues.end(); ++it)
-            {
-                m_currentQueue.remove(*it);
-                m_newToQueue.remove(*it);
-            }
-            m_Proposals[++m_lfgProposalId] = pProposal;
-
-            uint32 lowGuid = 0;
-            for (LfgProposalPlayerMap::const_iterator itPlayers = pProposal->players.begin(); itPlayers != pProposal->players.end(); ++itPlayers)
-            {
-                lowGuid = itPlayers->first;
-                if (Player* plr = sObjectMgr.GetPlayerByLowGUID(itPlayers->first))
-                {
-                    if (plr->GetGroup())
-                        plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_PROPOSAL_BEGIN);
-                    else
-                        plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_PROPOSAL_BEGIN);
-                    plr->GetSession()->SendUpdateProposal(m_lfgProposalId, pProposal);
-                }
-            }
-
-            if (pProposal->state == LFG_PROPOSAL_SUCCESS)
-                UpdateProposal(m_lfgProposalId, lowGuid, true);
-
-            // Clean up
-            for (LfgProposalList::iterator it = proposals.begin(); it != proposals.end(); ++it)
-            {
-                if ((*it) == pProposal)                     // Do not remove the selected proposal;
-                    continue;
-                (*it)->queues.clear();
-                for (LfgProposalPlayerMap::iterator itPlayers = (*it)->players.begin(); itPlayers != (*it)->players.end(); ++itPlayers)
-                    delete itPlayers->second;
-                (*it)->players.clear();
-                delete (*it);
-            }
-            proposals.clear();
-        }
-        else
-        {
-            m_currentQueue.push_back(m_newToQueue.front()); // Group not found, add this group to the queue.
-            m_newToQueue.pop_front();
-        }
-        firstNew.clear();
-    }
-
-    // Update all players status queue info
-    if (m_QueueTimer > LFG_QUEUEUPDATE_INTERVAL)
-    {
-        m_QueueTimer = 0;
-        time_t currTime = time(NULL);
-        int32 waitTime;
-        LfgQueueInfo* queue;
-        uint32 dungeonId;
-        uint32 queuedTime;
-        uint8 role;
-        for (LfgQueueInfoMap::const_iterator itQueue = m_QueueInfoMap.begin(); itQueue != m_QueueInfoMap.end(); ++itQueue)
-        {
-            queue = itQueue->second;
-            if (!queue)
-            {
-                sLog.outError("LFGMgr::Update: [" UI64FMTD "] queued with null queue info!", itQueue->first);
-                continue;
-            }
-            dungeonId = (*queue->dungeons.begin());
-            queuedTime = uint32(currTime - queue->joinTime);
-            role = ROLE_NONE;
-            for (LfgRolesMap::const_iterator itPlayer = queue->roles.begin(); itPlayer != queue->roles.end(); ++itPlayer)
-                role |= itPlayer->second;
-
-            waitTime = -1;
-            if (role & ROLE_TANK)
-            {
-                if (role & ROLE_HEALER || role & ROLE_DAMAGE)
-                    waitTime = m_WaitTimeAvg;
-                else
-                    waitTime = m_WaitTimeTank;
-            }
-            else if (role & ROLE_HEALER)
-            {
-                if (role & ROLE_DAMAGE)
-                    waitTime = m_WaitTimeAvg;
-                else
-                    waitTime = m_WaitTimeHealer;
-            }
-            else if (role & ROLE_DAMAGE)
-                waitTime = m_WaitTimeDps;
-
-            for (LfgRolesMap::const_iterator itPlayer = queue->roles.begin(); itPlayer != queue->roles.end(); ++itPlayer)
-                if (Player* plr = sObjectMgr.GetPlayerByLowGUID(itPlayer->first))
-                    plr->GetSession()->SendLfgQueueStatus(dungeonId, waitTime, m_WaitTimeAvg, m_WaitTimeTank, m_WaitTimeHealer, m_WaitTimeDps, queuedTime, queue->tanks, queue->healers, queue->dps);
-        }
-    }
-    else
-        m_QueueTimer += diff;
-    m_update = true;
-}
-
-/// <summary>
-/// Add a guid to new queue, checks consistency
-/// </summary>
-/// <param name="uint64">Player or group guid</param>
-void LFGMgr::AddGuidToNewQueue(uint64 guid)
-{
-    // Consistency check
-    LfgGuidList::iterator it = std::find(m_newToQueue.begin(), m_newToQueue.end(), guid);
-
-    if (it != m_newToQueue.end())
-    {
-        sLog.outError("LFGMgr::AddGuidToNewQueue: [" UI64FMTD "] being added to queue and it was already added. ignoring", guid);
-        return;
-    }
-
-    it = std::find(m_currentQueue.begin(), m_currentQueue.end(), guid);
-    if (it != m_currentQueue.end())
-    {
-        sLog.outError("LFGMgr::AddGuidToNewQueue: [" UI64FMTD "] being added to queue and already in current queue (removing to readd)", guid);
-        m_currentQueue.erase(it);
-    }
-
-    // Add to queue
-    m_newToQueue.push_back(guid);
-    sLog.outDebug("LFGMgr::AddGuidToNewQueue: [" UI64FMTD "] added to m_newToQueue (size: %u)", guid, uint32(m_newToQueue.size()));
-}
-
-/// <summary>
-/// Creates a QueueInfo and adds it to the queue. Tries to match a group before joining.
-/// </summary>
-/// <param name="uint64">Player or group guid</param>
-/// <param name="LfgRolesMap*">Player roles</param>
-/// <param name="LfgDungeonSet*">Selected dungeons</param>
-void LFGMgr::AddToQueue(uint64 guid, LfgRolesMap* roles, LfgDungeonSet* dungeons)
-{
-    if (!roles || !roles->size())
-    {
-        sLog.outError("LFGMgr::AddToQueue: [" UI64FMTD "] has no roles", guid);
-        return;
-    }
-
-    if (!dungeons || !dungeons->size())
-    {
-        sLog.outError("LFGMgr::AddToQueue: [" UI64FMTD "] has no dungeons", guid);
-        return;
-    }
-
-    LfgQueueInfo* pqInfo = new LfgQueueInfo();
-    pqInfo->joinTime = time_t(time(NULL));
-    for (LfgRolesMap::const_iterator it = roles->begin(); it != roles->end(); ++it)
-    {
-        if (pqInfo->tanks && it->second & ROLE_TANK)
-            --pqInfo->tanks;
-        else if (pqInfo->healers && it->second & ROLE_HEALER)
-            --pqInfo->healers;
-        else
-            --pqInfo->dps;
-    }
-    for (LfgRolesMap::const_iterator itRoles = roles->begin(); itRoles != roles->end(); ++itRoles)
-        pqInfo->roles[itRoles->first] = itRoles->second;
-
-    for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
-        pqInfo->dungeons.insert(*it);
-
-    sLog.outDebug("LFGMgr::AddToQueue: [" UI64FMTD "] joining with %u members", guid, uint32(pqInfo->roles.size()));
-    m_QueueInfoMap[guid] = pqInfo;
-    AddGuidToNewQueue(guid);
-}
-
-/// <summary>
-/// Removes the player/group from all queues
-/// </summary>
-/// <param name="uint64">Player or group guid</param>
-/// <returns>bool</returns>
-bool LFGMgr::RemoveFromQueue(uint64 guid)
-{
-    bool ret = false;
-    uint32 before = m_QueueInfoMap.size();
-
-    m_currentQueue.remove(guid);
-    m_newToQueue.remove(guid);
-    RemoveFromCompatibles(guid);
-
-    LfgQueueInfoMap::iterator it = m_QueueInfoMap.find(guid);
-    if (it != m_QueueInfoMap.end())
-    {
-        delete it->second;
-        m_QueueInfoMap.erase(it);
-        ret = true;
-    }
-    sLog.outDebug("LFGMgr::RemoveFromQueue: [" UI64FMTD "] %s - Queue(%u)", guid, 
-        before != m_QueueInfoMap.size() ? "Removed" : "Not in queue", uint32(m_QueueInfoMap.size()));
-    return ret;
-}
-
-/// <summary>
-/// Adds the player/group to lfg queue
-/// </summary>
-/// <param name="Player*">Player</param>
-void LFGMgr::Join(Player* plr)
-{
-    LfgDungeonSet* dungeons = NULL;
-    Group* grp = plr->GetGroup();
-
-    if (grp && grp->GetLeaderGUID() != plr->GetGUID())
-        return;
-
-    uint64 guid = grp ? grp->GetGUID() : plr->GetGUID();
-
-    LfgJoinResult result = LFG_JOIN_OK;
-    // Previous checks before joining
-    LfgQueueInfoMap::iterator itQueue = m_QueueInfoMap.find(guid);
-    if (itQueue != m_QueueInfoMap.end())
-    {
-        time_t now = time_t(time(NULL));
-        time_t joinTime = itQueue->second->joinTime;
-        uint32 diff = uint32(now - joinTime);
-        sLog.outError("LFGMgr::Join: [" UI64FMTD "] trying to join but is already in queue! diff %u (" UI64FMTD " - " UI64FMTD ")", guid, diff, uint64(now), uint64(joinTime));
-        Leave(plr, grp);
-        result = LFG_JOIN_INTERNAL_ERROR;
-    }
-    else if (plr->InBattleground() || plr->InArena() || plr->InBattlegroundQueue())
-        result = LFG_JOIN_USING_BG_SYSTEM;
-    else if (plr->HasAura(LFG_SPELL_DUNGEON_DESERTER))
-        result = LFG_JOIN_DESERTER;
-    else if (plr->HasAura(LFG_SPELL_DUNGEON_COOLDOWN))
-        result = LFG_JOIN_RANDOM_COOLDOWN;
-    else
-    {
-        dungeons = plr->GetLfgDungeons();
-        if (!dungeons || !dungeons->size())
-            result = LFG_JOIN_NOT_MEET_REQS;
-        else // Check if all dungeons are valid
-            for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
-            {
-                if (!GetDungeonGroupType(*it))
-                {
-                    result = LFG_JOIN_DUNGEON_INVALID;
-                    break;
-                }
-            }
-    }
-
-    // Group checks
-    if (grp && result == LFG_JOIN_OK)
-    {
-        if (grp->GetMembersCount() > MAXGROUPSIZE)
-            result = LFG_JOIN_TOO_MUCH_MEMBERS;
-        else
-        {
-            Player* plrg;
-            uint8 memberCount = 0;
-            for (GroupReference* itr = grp->GetFirstMember(); itr != NULL && result == LFG_JOIN_OK; itr = itr->next())
-            {
-                plrg = itr->getSource();
-                if (plrg)
-                {
-                    if (plrg->HasAura(LFG_SPELL_DUNGEON_DESERTER))
-                        result = LFG_JOIN_PARTY_DESERTER;
-                    else if (plrg->HasAura(LFG_SPELL_DUNGEON_COOLDOWN))
-                        result = LFG_JOIN_PARTY_RANDOM_COOLDOWN;
-                    ++memberCount;
-                }
-            }
-            if (memberCount != grp->GetMembersCount())
-                result = LFG_JOIN_DISCONNECTED;
-        }
-    }
-
-    if (result != LFG_JOIN_OK)                              // Someone can't join. Clear all stuf
-    {
-        sLog.outDebug("LFGMgr::Join: [" UI64FMTD "] joining with %u members. result: %u", guid, grp ? grp->GetMembersCount() : 1, result);
-        plr->GetLfgDungeons()->clear();
-        plr->SetLfgRoles(ROLE_NONE);
-        if (grp && !grp->isLFGGroup())
-            plr->SetLfgState(LFG_STATE_NONE);
-        plr->GetSession()->SendLfgJoinResult(result);
-        plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_ROLECHECK_FAILED);
-        return;
-    }
-
-    if (grp)
-    {
-        Player* plrg = NULL;
-        for (GroupReference* itr = plr->GetGroup()->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            plrg = itr->getSource();                        // Not null, checked earlier
-            plrg->SetLfgState(LFG_STATE_LFG);
-            if (plrg != plr)
-            {
-                dungeons = plrg->GetLfgDungeons();
-                dungeons->clear();
-                for (LfgDungeonSet::const_iterator itDungeon = plr->GetLfgDungeons()->begin(); itDungeon != plr->GetLfgDungeons()->end(); ++itDungeon)
-                    dungeons->insert(*itDungeon);
-            }
-            plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_JOIN_PROPOSAL);
-        }
-        UpdateRoleCheck(grp, plr);
-    }
-    else
-    {
-        plr->SetLfgState(LFG_STATE_LFG);
-        LfgRolesMap roles;
-        roles[plr->GetGUIDLow()] = plr->GetLfgRoles();
-
-        // Expand random dungeons
-        LfgLockStatusMap* playersLockMap = NULL;
-        if (plr->GetLfgDungeons()->size() == 1 && isRandomDungeon(*plr->GetLfgDungeons()->begin()))
-        {
-            PlayerSet players;
-            players.insert(plr);
-            dungeons = GetDungeonsByRandom(*plr->GetLfgDungeons()->begin());
-            playersLockMap = CheckCompatibleDungeons(dungeons, &players);
-            if (dungeons && !dungeons->size())
-            {
-                delete dungeons;
-                dungeons = NULL;
-            }
-        }
-        else
-            dungeons = plr->GetLfgDungeons();
-
-        if (!dungeons || !dungeons->size())
-            plr->GetSession()->SendLfgJoinResult(LFG_JOIN_NOT_MEET_REQS, 0, playersLockMap);
-        else
-        {
-            plr->GetSession()->SendLfgJoinResult(LFG_JOIN_OK, 0);
-            plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_JOIN_PROPOSAL);
-            AddToQueue(plr->GetGUID(), &roles, dungeons);
-        }
-        roles.clear();
-    }
-    std::string dungeonsstr = ConcatenateDungeons(dungeons);
-    sLog.outDebug("LFGMgr::Join: [" UI64FMTD "] joined with %u members. dungeons: %s", guid, grp ? grp->GetMembersCount() : 1, dungeonsstr.c_str());
-}
-
-/// <summary>
-/// Leave the lfg queue
-/// </summary>
-/// <param name="Player*">Player (could be NULL)</param>
-/// <param name="Group*">Group (could be NULL)</param>
-void LFGMgr::Leave(Player* plr, Group* grp /* = NULL*/)
-{
-    if ((plr && (!plr->GetLfgUpdate() || !plr->isUsingLfg())) || !sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
-        return;
-
-    uint64 guid = grp ? grp->GetGUID() : plr ? plr->GetGUID() : 0;
-    sLog.outDebug("LFGMgr::Leave: [" UI64FMTD "]", guid);
-
-    // Remove from Role Checks
-    if (grp)
-    {
-        grp->SetLfgQueued(false);
-        LfgRoleCheckMap::const_iterator itRoleCheck = m_RoleChecks.find(GUID_LOPART(guid));
-        if (itRoleCheck != m_RoleChecks.end())
-        {
-            UpdateRoleCheck(grp);                           // No player to update role = LFG_ROLECHECK_ABORTED
-            return;
-        }
-    }
-
-    // Remove from Proposals
-    bool proposalFound = false;
-    LfgProposalMap::iterator it = m_Proposals.begin();
-    while (it != m_Proposals.end() && !proposalFound)
-    {
-        // Mark the player/leader of group who left as didn't accept the proposal
-        for (LfgProposalPlayerMap::iterator itPlayer = it->second->players.begin(); itPlayer != it->second->players.end(); ++itPlayer)
-        {
-            if ((plr && itPlayer->first == plr->GetGUIDLow()) || (grp && itPlayer->first == GUID_LOPART(grp->GetLeaderGUID())))
-            {
-                itPlayer->second->accept = LFG_ANSWER_DENY;
-                proposalFound = true;
-            }
-        }
-        if (!proposalFound)
-            ++it;
-    }
-
-    // Remove from queue - if proposal is found, RemoveProposal will call RemoveFromQueue
-    if (proposalFound)
-        RemoveProposal(it, LFG_UPDATETYPE_PROPOSAL_DECLINED);
-    else
-        RemoveFromQueue(guid);
-
-    if (grp)
-    {
-        for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-            if (Player* plrg = itr->getSource())
-            {
-                plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-                plrg->GetLfgDungeons()->clear();
-                plrg->SetLfgRoles(ROLE_NONE);
-                plrg->SetLfgState(LFG_STATE_NONE);
-            }
-    }
-    else
-    {
-        plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-        plr->GetLfgDungeons()->clear();
-        plr->SetLfgRoles(ROLE_NONE);
-        plr->SetLfgState(LFG_STATE_NONE);
-        plr->RemoveAurasDueToSpell(LFG_SPELL_LUCK_OF_THE_DRAW);
-    }
-}
-
-/// <summary>
-/// Given a Lfg group checks if leader needs to be show the popup to select more players
-/// </summary>
-/// <param name="Group*">Group than needs new players</param>
-void LFGMgr::OfferContinue(Group* grp)
-{
-    if (!sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
-        return;
-
-    ASSERT(grp);
-    if (Player* leader = sObjectMgr.GetPlayer(grp->GetLeaderGUID()))
-        leader->GetSession()->SendLfgOfferContinue(grp->GetLfgDungeonEntry(false));
-}
-
-/// <summary>
-/// Check the queue to try to match groups. Returns all the possible matches
-/// </summary>
-/// <param name="LfgGuidList &">Guids we trying to match with the rest of groups</param>
-/// <param name="LfgGuidList">All guids in queue</param>
-/// <param name="LfgProposalList*">Proposals found.</param>
-void LFGMgr::FindNewGroups(LfgGuidList& check, LfgGuidList all, LfgProposalList* proposals)
-{
-    ASSERT(proposals);
-    if (!check.size() || check.size() > MAXGROUPSIZE)
-        return;
-
-    if (check.size() == 1)                                  // Consistency check
-    {
-        uint64 guid = (*check.begin());
-        LfgQueueInfoMap::iterator itQueue = m_QueueInfoMap.find(guid);
-        if (itQueue == m_QueueInfoMap.end())
-        {
-            sLog.outError("LFGMgr::FindNewGroups: [" UI64FMTD "] is not queued but listed as queued!", guid);
-            RemoveFromQueue(guid);
-            return;
-        }
-    }
-
-    sLog.outDebug("LFGMgr::FindNewGroup: (%s) - all(%s)", ConcatenateGuids(check).c_str(), ConcatenateGuids(all).c_str());
-
-    // Check individual compatibilities
-    LfgGuidList compatibles;
-    for (LfgGuidList::iterator it = all.begin(); it != all.end(); ++it)
-    {
-        check.push_back(*it);
-        if (CheckCompatibility(check, proposals))
-            compatibles.push_back(*it);
-        check.pop_back();
-    }
-
-    // Check multiple groups
-    while (compatibles.size() > 1)
-    {
-        check.push_back(compatibles.front());
-        compatibles.pop_front();
-        FindNewGroups(check, compatibles, proposals);
-        check.pop_back();
-    }
-}
-
-/// <summary>
-/// Check compatibilities between groups.
-/// </summary>
-/// <param name="LfgGuidList">Guids we checking compatibility</param>
-/// <returns>bool</returns>
-/// <param name="LfgProposalList*">Proposals found.</param>
-bool LFGMgr::CheckCompatibility(LfgGuidList check, LfgProposalList* proposals)
-{
-    std::string strGuids = ConcatenateGuids(check);
-
-    if (check.size() > MAXGROUPSIZE || !check.size())
-    {
-        sLog.outDebug("LFGMgr::CheckCompatibility: (%s): Size wrong - Not compatibles", strGuids.c_str());
-        return false;
-    }
-
-    // No previous check have been done, do it now
-    uint8 numPlayers = 0;
-    uint8 numLfgGroups = 0;
-    uint32 groupLowGuid = 0;
-    LfgQueueInfoMap pqInfoMap;
-    LfgQueueInfoMap::iterator itQueue;
-    for (LfgGuidList::const_iterator it = check.begin(); it != check.end() && numLfgGroups < 2 && numPlayers <= MAXGROUPSIZE; ++it)
-    {
-        itQueue = m_QueueInfoMap.find(*it);
-        if (itQueue == m_QueueInfoMap.end())
-        {
-            sLog.outError("LFGMgr::CheckCompatibility: [" UI64FMTD "] is not queued but listed as queued!", (*it));
-            RemoveFromQueue(*it);
-            return false;
-        }
-        pqInfoMap[*it] = itQueue->second;
-        numPlayers += itQueue->second->roles.size();
-
-        if (IS_GROUP(*it))
-        {
-            uint32 lowGuid = GUID_LOPART(*it);
-            if (Group* grp = sObjectMgr.GetGroupByGUID(lowGuid))
-                if (grp->isLFGGroup())
-                {
-                    if (!numLfgGroups)
-                        groupLowGuid = lowGuid;
-                    ++numLfgGroups;
-                }
-        }
-    }
-
-    if (check.size() == 1 && numPlayers != MAXGROUPSIZE) // Single group with less than MAXGROUPSIZE - Compatibles
-        return true;
-
-    if (check.size() > 1)
-    {
-        // Previously cached?
-        LfgAnswer answer = GetCompatibles(strGuids);
-        if (answer != LFG_ANSWER_PENDING)
-        {
-            if (numPlayers != MAXGROUPSIZE || answer == LFG_ANSWER_DENY)
-            {
-                sLog.outDebug("LFGMgr::CheckCompatibility: (%s) compatibles (cached): %d", strGuids.c_str(), answer);
-                return bool(answer);
-            }
-            // MAXGROUPSIZE + LFG_ANSWER_AGREE = Match - we don't have it cached so do calcs again
-        }
-        else if (check.size() > 2)
-        {
-            uint64 frontGuid = check.front();
-            check.pop_front();
-
-            // Check all-but-new compatibilities (New,A,B,C,D) --> check(A,B,C,D)
-            if (!CheckCompatibility(check, proposals))      // Group not compatible
-            {
-                sLog.outDebug("LFGMgr::CheckCompatibility: (%s) no compatibles (%s not compatibles)", strGuids.c_str(), ConcatenateGuids(check).c_str());
-                SetCompatibles(strGuids, false);
-                return false;
-            }
-            check.push_front(frontGuid);
-            // all-but-new compatibles, now check with new
-        }
-    }
-
-    // Do not match - groups already in a lfgDungeon or too much players
-    if (numLfgGroups > 1 || numPlayers > MAXGROUPSIZE)
-    {
-        pqInfoMap.clear();
-        SetCompatibles(strGuids, false);
-        if (numLfgGroups > 1)
-            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) More than one Lfggroup (%u)", strGuids.c_str(), numLfgGroups);
-        else
-            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Too much players (%u)", strGuids.c_str(), numPlayers);
-        return false;
-    }
-
-    // ----- Player checks -----
-    LfgRolesMap rolesMap;
-    uint32 newLeaderLowGuid = 0;
-    for (LfgQueueInfoMap::const_iterator it = pqInfoMap.begin(); it != pqInfoMap.end(); ++it)
-    {
-        for (LfgRolesMap::const_iterator itRoles = it->second->roles.begin(); itRoles != it->second->roles.end(); ++itRoles)
-        {
-            // Assign new leader
-            if (itRoles->second & ROLE_LEADER && (!newLeaderLowGuid || urand(0, 1)))
-                newLeaderLowGuid = itRoles->first;
-            if (rolesMap[itRoles->first])                   // Player already added!
-            {
-                // Find the other guid
-                uint64 guid1 = it->first;
-                uint64 guid2 = 0;
-                for (LfgQueueInfoMap::const_iterator it2 = pqInfoMap.begin(); it2 != it && !guid2; ++it2)
-                {
-                    if (it2->second->roles.find(itRoles->first) != it2->second->roles.end())
-                        guid2 = it2->first;
-                }
-                uint64 playerguid;
-
-                // store in guid2 the obsolete group
-                if (pqInfoMap[guid2]->joinTime > it->second->joinTime)
-                {
-                    playerguid = guid2;
-                    guid2 = guid1;
-                    guid1 = playerguid;
-                }
-                playerguid = MAKE_NEW_GUID(itRoles->first, 0, HIGHGUID_PLAYER);
-                sLog.outError("LFGMgr::CheckCompatibility: check(%s) player [" UI64FMTD "] in queue with [" UI64FMTD "] and OBSOLETE! [" UI64FMTD "]",
-                    strGuids.c_str(), playerguid, guid1, guid2);
-            }
-            rolesMap[itRoles->first] = itRoles->second;
-        }
-    }
-
-    if (rolesMap.size() != numPlayers)
-    {
-        pqInfoMap.clear();
-        rolesMap.clear();
-        return false;
-    }
-
-    Player* plr;
-    PlayerSet players;
-    for (LfgRolesMap::const_iterator it = rolesMap.begin(); it != rolesMap.end(); ++it)
-    {
-        plr = sObjectMgr.GetPlayerByLowGUID(it->first);
-        if (!plr)
-            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Warning! %u offline! Marking as not compatibles!", strGuids.c_str(), it->first);
-        else
-        {
-            for (PlayerSet::const_iterator itPlayer = players.begin(); itPlayer != players.end() && plr; ++itPlayer)
-            {
-                // Do not form a group with ignoring candidates
-                if (plr->GetSocial()->HasIgnore((*itPlayer)->GetGUIDLow()) || (*itPlayer)->GetSocial()->HasIgnore(plr->GetGUIDLow()))
-                {
-                    sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Players [" UI64FMTD "] and [" UI64FMTD "] ignoring", strGuids.c_str(), (*itPlayer)->GetGUID(), plr->GetGUID());
-                    plr = NULL;
-                }
-                // neither with diferent faction if it's not a mixed faction server
-                else if (plr->GetTeam() != (*itPlayer)->GetTeam() && !sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP))
-                {
-                    sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Players [" UI64FMTD "] and [" UI64FMTD "] are from diff sides", strGuids.c_str(), (*itPlayer)->GetGUID(), plr->GetGUID());
-                    plr = NULL;
-                }
-            }
-            if (plr)
-                players.insert(plr);
-        }
-    }
-
-    // if we dont have the same ammount of players then we have self ignoring candidates or different faction groups
-    // otherwise check if roles are compatible
-    if (players.size() != numPlayers || !CheckGroupRoles(rolesMap))
-    {
-        if (players.size() == numPlayers)
-            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Roles not compatible", strGuids.c_str());
-        pqInfoMap.clear();
-        rolesMap.clear();
-        players.clear();
-        SetCompatibles(strGuids, false);
-        return false;
-    }
-
-    // ----- Selected Dungeon checks -----
-    // Check if there are any compatible dungeon from the selected dungeons
-    LfgDungeonMap dungeonMap;
-    for (LfgQueueInfoMap::const_iterator it = pqInfoMap.begin(); it != pqInfoMap.end(); ++it)
-        dungeonMap[it->first] = &it->second->dungeons;
-
-    LfgDungeonSet* compatibleDungeons = CheckCompatibleDungeons(&dungeonMap, &players);
-    dungeonMap.clear();
-    pqInfoMap.clear();
-    if (!compatibleDungeons || !compatibleDungeons->size())
-    {
-        if (compatibleDungeons)
-            delete compatibleDungeons;
-        players.clear();
-        rolesMap.clear();
-        SetCompatibles(strGuids, false);
-        return false;
-    }
-    SetCompatibles(strGuids, true);
-
-    // ----- Group is compatible, if we have MAXGROUPSIZE members then match is found
-    if (numPlayers != MAXGROUPSIZE)
-    {
-        players.clear();
-        rolesMap.clear();
-        sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Compatibles but not match. Players(%u)", strGuids.c_str(), numPlayers);
-        return true;
-    }
-    sLog.outDebug("LFGMgr::CheckCompatibility: (%s) MATCH! Group formed", strGuids.c_str());
-
-    // Select a random dungeon from the compatible list
-    LfgDungeonSet::iterator itDungeon = compatibleDungeons->begin();
-    uint32 selectedDungeon = urand(0, compatibleDungeons->size() - 1);
-    while (selectedDungeon > 0)
-    {
-        ++itDungeon;
-        --selectedDungeon;
-    }
-    selectedDungeon = (*itDungeon);
-    compatibleDungeons->clear();
-    delete compatibleDungeons;
-
-    // Create a new proposal
-    LfgProposal* pProposal = new LfgProposal(selectedDungeon);
-    pProposal->cancelTime = time_t(time(NULL)) + LFG_TIME_PROPOSAL;
-    pProposal->queues = check;
-    pProposal->groupLowGuid = groupLowGuid;
-
-    // Assign new roles to players and assign new leader
-    LfgProposalPlayer* ppPlayer;
-    uint32 lowGuid;
-    PlayerSet::const_iterator itPlayers = players.begin();
-    if (!newLeaderLowGuid)
-    {
-        uint8 pos = urand(0, players.size() - 1);
-        for (uint8 i = 0; i < pos; ++i)
-            ++itPlayers;
-        newLeaderLowGuid = (*itPlayers)->GetGUIDLow();
-    }
-    pProposal->leaderLowGuid = newLeaderLowGuid;
-
-    uint8 numAccept = 0;
-    for (itPlayers = players.begin(); itPlayers != players.end(); ++itPlayers)
-    {
-        lowGuid = (*itPlayers)->GetGUIDLow();
-        ppPlayer = new LfgProposalPlayer();
-        Group* grp = (*itPlayers)->GetGroup();
-        if (grp)
-        {
-            ppPlayer->groupLowGuid = grp->GetLowGUID();
-            if (grp->GetLfgDungeonEntry() == selectedDungeon && ppPlayer->groupLowGuid == pProposal->groupLowGuid) // Player from existing group, autoaccept
-            {
-                ppPlayer->accept = LFG_ANSWER_AGREE;
-                ++numAccept;
-            }
-        }
-        ppPlayer->role = rolesMap[lowGuid];
-        pProposal->players[lowGuid] = ppPlayer;
-    }
-    if (numAccept == MAXGROUPSIZE)
-        pProposal->state = LFG_PROPOSAL_SUCCESS;
-
-    if (!proposals)
-        proposals = new LfgProposalList();
-    proposals->push_back(pProposal);
-
-    rolesMap.clear();
-    players.clear();
-    return true;
-}
-
-/// <summary>
-/// Update the Role check info with the player selected role.
-/// </summary>
-/// <param name="Group*">Group</param>
-/// <param name="Player*">Player (optional, default NULL)</param>
-void LFGMgr::UpdateRoleCheck(Group* grp, Player* plr /* = NULL*/)
-{
-    if (!grp)
-        return;
-
-    uint32 rolecheckId = grp->GetLowGUID();
-    LfgRoleCheck* pRoleCheck = NULL;
-    LfgRolesMap check_roles;
-    LfgRoleCheckMap::iterator itRoleCheck = m_RoleChecks.find(rolecheckId);   
-    bool newRoleCheck = itRoleCheck == m_RoleChecks.end();
-    if (newRoleCheck)
-    {
-        if (!plr || grp->GetLeaderGUID() != plr->GetGUID())
-            return;
-
-		LfgDungeonSet* dungeons = plr->GetLfgDungeons();
-        pRoleCheck = new LfgRoleCheck();
-        pRoleCheck->cancelTime = time_t(time(NULL)) + LFG_TIME_ROLECHECK;
-        pRoleCheck->result = LFG_ROLECHECK_INITIALITING;
-        pRoleCheck->leader = plr->GetGUIDLow();
-
-        for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-            if (Player* plrg = itr->getSource())
-                pRoleCheck->roles[plrg->GetGUIDLow()] = 0;
-
-        // Check if it's offer continue or trying to find a new instance after a random assigned (Join Random + LfgGroup)
-        if (grp->isLFGGroup() && dungeons->size() == 1 && isRandomDungeon(*dungeons->begin()) && grp->GetLfgDungeonEntry())
-            pRoleCheck->dungeons.insert(grp->GetLfgDungeonEntry());
-        else
-            for (LfgDungeonSet::const_iterator itDungeon = dungeons->begin(); itDungeon != dungeons->end(); ++itDungeon)
-                pRoleCheck->dungeons.insert(*itDungeon);
-    }
-    else
-        pRoleCheck = itRoleCheck->second;
-
-    LfgLockStatusMap* playersLockMap = NULL;
-    if (plr)
-    {
-        // Player selected no role.
-        if (plr->GetLfgRoles() < ROLE_TANK)
-            pRoleCheck->result = LFG_ROLECHECK_NO_ROLE;
-        else
-        {
-            // Check if all players have selected a role
-            pRoleCheck->roles[plr->GetGUIDLow()] = plr->GetLfgRoles();
-            uint8 size = 0;
-            for (LfgRolesMap::const_iterator itRoles = pRoleCheck->roles.begin(); itRoles != pRoleCheck->roles.end() && itRoles->second != ROLE_NONE; ++itRoles)
-                ++size;
-
-            if (pRoleCheck->roles.size() == size)
-            {
-                // use temporal var to check roles, CheckGroupRoles modifies the roles
-                check_roles = pRoleCheck->roles;
-                if (!CheckGroupRoles(check_roles))              // Group is not posible
-                    pRoleCheck->result = LFG_ROLECHECK_WRONG_ROLES;
-                else
-                {
-                    // Check if we can find a dungeon for that group
-                    pRoleCheck->result = LFG_ROLECHECK_FINISHED;
-                    if (pRoleCheck->dungeons.size() == 1 && isRandomDungeon(*pRoleCheck->dungeons.begin()))
-                    {
-                        // Random dungeon - select the compatible dungeons
-                        LfgDungeonSet* dungeons = GetDungeonsByRandom(*pRoleCheck->dungeons.begin());
-                        PlayerSet players;
-                        for (LfgRolesMap::const_iterator it = pRoleCheck->roles.begin(); it != pRoleCheck->roles.end(); ++it)
-                            if (Player* plr = sObjectMgr.GetPlayerByLowGUID(it->first))
-                                players.insert(plr);
-
-                        playersLockMap = CheckCompatibleDungeons(dungeons, &players);
-                        std::string dungeonstr = ConcatenateDungeons(dungeons);
-                        sLog.outDebug("LFGMgr::UpdateRoleCheck: [" UI64FMTD "] done. Dungeons: %s", plr->GetGUID(), dungeonstr.c_str());
-
-                        pRoleCheck->dungeons.clear();
-                        if (dungeons)
-                        {
-                            if (dungeons->empty())
-                                delete dungeons;
-                            else
-                            {
-                                for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
-                                    pRoleCheck->dungeons.insert(*it);
-                                if (playersLockMap)
-                                {
-                                    for (LfgLockStatusMap::iterator itMap = playersLockMap->begin(); itMap != playersLockMap->end(); ++itMap)
-                                    {
-                                        itMap->second->clear();
-                                        delete itMap->second;
-                                    }
-                                    playersLockMap->clear();
-                                    delete playersLockMap;
-                                    playersLockMap = NULL;
-                                }
-                            }
-                        }
-                    }
-                    else
-                        playersLockMap = GetPartyLockStatusDungeons(plr, &pRoleCheck->dungeons);
-                }
-            }
-        }
-    }
-    else
-        pRoleCheck->result = LFG_ROLECHECK_ABORTED;
-
-    WorldSession* session;
-    Player* plrg = NULL;
-    for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        plrg = itr->getSource();
-        if (!plrg)
-            continue;
-
-        session = plrg->GetSession();
-        if (!newRoleCheck && plr)
-            session->SendLfgRoleChosen(plr->GetGUID(), plr->GetLfgRoles());
-        session->SendLfgRoleCheckUpdate(pRoleCheck);
-
-        switch(pRoleCheck->result)
-        {
-        case LFG_ROLECHECK_INITIALITING:
-            continue;
-        case LFG_ROLECHECK_FINISHED:
-            if (!playersLockMap)
-                session->SendLfgUpdateParty(LFG_UPDATETYPE_ADDED_TO_QUEUE);
-            else
-            {
-                if (grp->GetLeaderGUID() == plrg->GetGUID())
-                    session->SendLfgJoinResult(LFG_JOIN_PARTY_NOT_MEET_REQS, 0, playersLockMap);
-                session->SendLfgUpdateParty(LFG_UPDATETYPE_ROLECHECK_FAILED);
-                plrg->GetLfgDungeons()->clear();
-                plrg->SetLfgRoles(ROLE_NONE);
-                if (!grp->isLFGGroup())
-                    plrg->SetLfgState(LFG_STATE_NONE);
-            }
-            break;
-        default:
-            if (grp->GetLeaderGUID() == plrg->GetGUID())
-                session->SendLfgJoinResult(LFG_JOIN_FAILED, pRoleCheck->result);
-            session->SendLfgUpdateParty(LFG_UPDATETYPE_ROLECHECK_FAILED);
-            plrg->GetLfgDungeons()->clear();
-            if (grp->isLFGGroup())
-                plrg->SetLfgRoles(ROLE_NONE);
-            plrg->SetLfgState(LFG_STATE_NONE);
-            break;
-        }
-    }
-
-    if (pRoleCheck->result == LFG_ROLECHECK_FINISHED && pRoleCheck->dungeons.size())
-    {
-        grp->SetLfgQueued(true);
-        AddToQueue(grp->GetGUID(), &pRoleCheck->roles, &pRoleCheck->dungeons);
-    }
-
-    if (pRoleCheck->result != LFG_ROLECHECK_INITIALITING)
-    {
-        pRoleCheck->dungeons.clear();
-        pRoleCheck->roles.clear();
-        delete pRoleCheck;
-        if (!newRoleCheck)
-            m_RoleChecks.erase(itRoleCheck);
-    }
-    else if (newRoleCheck)
-        m_RoleChecks[rolecheckId] = pRoleCheck;
-}
-
-/// <summary>
-/// Remove from cached compatible dungeons any entry that contains the given guid
-/// </summary>
-/// <param name="uint64">guid to remove from any list</param>
-void LFGMgr::RemoveFromCompatibles(uint64 guid)
-{
-    LfgGuidList lista;
-    lista.push_back(guid);
-    std::string strGuid = ConcatenateGuids(lista);
-    lista.clear();
-
-    sLog.outDebug("LFGMgr::RemoveFromCompatibles: Removing [" UI64FMTD "]", guid);
-    LfgCompatibleMap::iterator it;
-    for (LfgCompatibleMap::iterator itNext = m_CompatibleMap.begin(); itNext != m_CompatibleMap.end();)
-    {
-        it = itNext++;
-        if (it->first.find(strGuid) != std::string::npos)    // Found, remove it
-            m_CompatibleMap.erase(it);
-    }
-}
-
-/// <summary>
-/// Set the compatibility of a list of guids
-/// </summary>
-/// <param name="std::string">list of guids concatenated by |</param>
-/// <param name="bool">compatibles or not</param>
-void LFGMgr::SetCompatibles(std::string key, bool compatibles)
-{
-    m_CompatibleMap[key] = LfgAnswer(compatibles);
-}
-
-/// <summary>
-/// Get the compatible dungeons between two groups from cache
-/// </summary>
-/// <param name="std::string">list of guids concatenated by |</param>
-/// <returns>LfgAnswer,
-LfgAnswer LFGMgr::GetCompatibles(std::string key)
-{
-    LfgAnswer answer = LFG_ANSWER_PENDING;
-    LfgCompatibleMap::iterator it = m_CompatibleMap.find(key);
-    if (it != m_CompatibleMap.end())
-        answer = it->second;
-
-    return answer;
-}
-
-/// <summary>
-/// Given a list of dungeons remove the dungeons with restrictions.
-/// </summary>
-/// <param name="LfgDungeonSet*">dungeons to check</param>
-/// <param name="PlayerSet*">Players to check restrictions</param>
-/// <param name="LfgLockStatusMap*">Used to return the lockStatusMap</param>
-/// <param name="boot">Return lockMap or discard it</param>
-/// <returns>LfgLockStatusMap*</returns>
-LfgLockStatusMap* LFGMgr::CheckCompatibleDungeons(LfgDungeonSet* dungeons, PlayerSet* players, bool returnLockMap /* = true */)
-{
-    if (!dungeons)
-        return NULL;
-
-    LfgLockStatusMap* pLockDungeons = GetGroupLockStatusDungeons(players, dungeons, false);
-    if (pLockDungeons) // Found dungeons not compatible, remove them from the set
-    {
-        for (LfgLockStatusMap::const_iterator itLockMap = pLockDungeons->begin(); itLockMap != pLockDungeons->end() && dungeons->size(); ++itLockMap)
-        {
-            for(LfgLockStatusSet::const_iterator itLockSet = itLockMap->second->begin(); itLockSet != itLockMap->second->end(); ++itLockSet)
-            {
-                LfgDungeonSet::iterator itDungeon = dungeons->find((*itLockSet)->dungeon);
-                if (itDungeon != dungeons->end())
-                     dungeons->erase(itDungeon);
-            }
-            if (!returnLockMap)
-            {
-                itLockMap->second->clear();
-                delete itLockMap->second;
-            }
-        }
-        if (!returnLockMap)
-        {
-            pLockDungeons->clear();
-            delete pLockDungeons;
-            return NULL;
-        }
-    }
-    return pLockDungeons;
-}
-
-/// <summary>
-/// Given a list of groups checks the compatible dungeons. If players is not null also check restictions
-/// </summary>
-/// <param name="LfgDungeonMap*">dungeons to check</param>
-/// <param name="PlayerSet*">Players to check restrictions</param>
-/// <returns>LfgDungeonSet*</returns>
-LfgDungeonSet* LFGMgr::CheckCompatibleDungeons(LfgDungeonMap* dungeonsMap, PlayerSet* players)
-{
-    if (!dungeonsMap || dungeonsMap->empty())
-        return NULL;
-
-    LfgDungeonMap::const_iterator itMap = ++dungeonsMap->begin();
-    LfgDungeonSet* compatibleDungeons = new LfgDungeonSet();
-
-    bool compatibleDungeon;
-
-    // Get the first group and compare with the others to select all common dungeons
-    for (LfgDungeonSet::const_iterator itDungeon = dungeonsMap->begin()->second->begin(); itDungeon != dungeonsMap->begin()->second->end(); ++itDungeon)
-    {
-        compatibleDungeon = true;
-        for (LfgDungeonMap::const_iterator it = itMap; it != dungeonsMap->end() && compatibleDungeon; ++it)
-            if (it->second->find(*itDungeon) == it->second->end())
-                compatibleDungeon = false;
-        if (compatibleDungeon)
-            compatibleDungeons->insert(*itDungeon);
-    }
-
-    // if we have players remove restrictions
-    if (players && !players->empty())
-        CheckCompatibleDungeons(compatibleDungeons, players, false);
-
-    // Any compatible dungeon after checking restrictions?
-    if (compatibleDungeons && !compatibleDungeons->size())
-    {
-        delete compatibleDungeons;
-        compatibleDungeons = NULL;
-    }
-    return compatibleDungeons;
-}
-
-/// <summary>
-/// Check if a group can be formed with the given group
-/// </summary>
-/// <param name="LfgRolesMap &">Roles to check</param>
-/// <param name="bool">Used to remove ROLE_LEADER</param>
-/// <returns>bool</returns>
-bool LFGMgr::CheckGroupRoles(LfgRolesMap &groles, bool removeLeaderFlag /*= true*/)
-{
-    if (!groles.size())
-        return false;
-
-    uint8 damage = 0;
-    uint8 tank = 0;
-    uint8 healer = 0;
-
-    if (removeLeaderFlag)
-        for (LfgRolesMap::iterator it = groles.begin(); it != groles.end(); ++it)
-            it->second &= ~ROLE_LEADER;
-
-    for (LfgRolesMap::iterator it = groles.begin(); it != groles.end(); ++it)
-    {
-        switch(it->second)
-        {
-        case ROLE_NONE:
-            return false;
-        case ROLE_TANK:
-            if (tank == LFG_TANKS_NEEDED)
-                return false;
-            tank++;
-            break;
-        case ROLE_HEALER:
-            if (healer == LFG_HEALERS_NEEDED)
-                return false;
-            healer++;
-            break;
-        case ROLE_DAMAGE:
-            if (damage == LFG_DPS_NEEDED)
-                return false;
-            damage++;
-            break;
-        default:
-            if (it->second & ROLE_TANK)
-            {
-                it->second -= ROLE_TANK;
-                if (CheckGroupRoles(groles, false))
-                    return true;
-                it->second += ROLE_TANK;
-            }
-
-            if (it->second & ROLE_HEALER)
-            {
-                it->second -= ROLE_HEALER;
-                if (CheckGroupRoles(groles, false))
-                    return true;
-                it->second += ROLE_HEALER;
-            }
-
-            if (it->second & ROLE_DAMAGE)
-            {
-                it->second -= ROLE_DAMAGE;
-                return CheckGroupRoles(groles, false);
-            }
-            break;
-        }
-    }
-    return true;
-}
-
-/// <summary>
-/// Update Proposal info with player answer
-/// </summary>
-/// <param name="uint32">Id of the proposal</param>
-/// <param name="uint32">Player low guid</param>
-/// <param name="bool">Player answer</param>
-void LFGMgr::UpdateProposal(uint32 proposalId, uint32 lowGuid, bool accept)
-{
-    // Check if the proposal exists
-    LfgProposalMap::iterator itProposal = m_Proposals.find(proposalId);
-    if (itProposal == m_Proposals.end())
-        return;
-    LfgProposal* pProposal = itProposal->second;
-
-    // Check if proposal have the current player
-    LfgProposalPlayerMap::iterator itProposalPlayer = pProposal->players.find(lowGuid);
-    if (itProposalPlayer == pProposal->players.end())
-        return;
-    LfgProposalPlayer* ppPlayer = itProposalPlayer->second;
-
-    ppPlayer->accept = LfgAnswer(accept);
-    sLog.outDebug("LFGMgr::UpdateProposal: Player [" UI64FMTD "] of proposal %u selected: %u", MAKE_NEW_GUID(lowGuid, 0, HIGHGUID_PLAYER), proposalId, accept);
-    if (!accept)
-    {
-        RemoveProposal(itProposal, LFG_UPDATETYPE_PROPOSAL_DECLINED);
-        return;
-    }
-
-    LfgPlayerList players;
-    Player* plr;
-
-    // check if all have answered and reorder players (leader first)
-    bool allAnswered = true;
-    for (LfgProposalPlayerMap::const_iterator itPlayers = pProposal->players.begin(); itPlayers != pProposal->players.end(); ++itPlayers)
-    {
-        plr = sObjectMgr.GetPlayerByLowGUID(itPlayers->first);
-
-        if (plr)
-        {
-            if (itPlayers->first == pProposal->leaderLowGuid)
-                players.push_front(plr);
-            else
-                players.push_back(plr);
-        }
-
-        if (itPlayers->second->accept != LFG_ANSWER_AGREE)  // No answer (-1) or not accepted (0)
-            allAnswered = false;
-    }
-
-    if (!allAnswered)
-    {
-        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
-            (*it)->GetSession()->SendUpdateProposal(proposalId, pProposal);
-    }
-    else
-    {
-        bool sendUpdate = pProposal->state != LFG_PROPOSAL_SUCCESS;
-        pProposal->state = LFG_PROPOSAL_SUCCESS;
-        time_t joinTime = time_t(time(NULL));
-        std::map<uint64, int32> waitTimesMap;
-        // Save wait times before redoing groups
-        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
-        {
-            LfgProposalPlayer* pPlayer = pProposal->players[(*it)->GetGUIDLow()];
-            uint32 lowgroupguid = (*it)->GetGroup() ? (*it)->GetGroup()->GetLowGUID() : 0;
-            if (pPlayer->groupLowGuid != lowgroupguid)
-                sLog.outError("LFGMgr::UpdateProposal: [" UI64FMTD "] group mismatch: actual (%u) - queued (%u)", (*it)->GetGUID(), lowgroupguid, pPlayer->groupLowGuid);
-
-            uint64 guid = pPlayer->groupLowGuid ? MAKE_NEW_GUID(pPlayer->groupLowGuid, 0, HIGHGUID_GROUP) : (*it)->GetGUID();
-            LfgQueueInfoMap::iterator itQueue = m_QueueInfoMap.find(guid);
-            if (itQueue == m_QueueInfoMap.end())
-            {
-                sLog.outError("LFGMgr::UpdateProposal: Queue info for guid [" UI64FMTD "] not found!", guid);
-                waitTimesMap[(*it)->GetGUID()] = -1;
-            }
-            else
-                waitTimesMap[(*it)->GetGUID()] = int32(joinTime - itQueue->second->joinTime);
-        }
-
-        // Create a new group (if needed)
-        Group* grp = sObjectMgr.GetGroupByGUID(pProposal->groupLowGuid);
-        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
-        {
-            plr = (*it);
-            if (sendUpdate)
-                plr->GetSession()->SendUpdateProposal(proposalId, pProposal);
-            if (plr->GetGroup())
-            {
-                plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_GROUP_FOUND);
-		        plr->SetLfgUpdate(false);
-                if (plr->GetGroup() != grp)
-                {
-                    plr->GetGroup()->SetLfgQueued(false);
-                    plr->RemoveFromGroup();
-                }
-            }
-            else
-			{
-				plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_GROUP_FOUND);
-				plr->SetLfgUpdate(false);
-			}
-
-            if (!grp)
-            {
-                grp = new Group();
-                grp->Create(plr->GetGUID(), plr->GetName());
-                grp->ConvertToLFG();
-                sObjectMgr.AddGroup(grp);
-            }
-            else if (plr->GetGroup() != grp)
-            {
-                grp->SetLfgQueued(false);
-                SQLTransaction trans = CharacterDatabase.BeginTransaction();
-                grp->AddMember(plr->GetGUID(), plr->GetName(),trans);
-                CharacterDatabase.CommitTransaction(trans);
-            }
-            plr->SetLfgUpdate(true);
-
-            // Update timers
-            uint8 role = plr->GetLfgRoles();
-            if (role & ROLE_TANK)
-            {
-                if (role & ROLE_HEALER || role & ROLE_DAMAGE)
-                    m_WaitTimeAvg = int32((m_WaitTimeAvg * m_NumWaitTimeAvg + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeAvg);
-                else
-                    m_WaitTimeTank = int32((m_WaitTimeTank * m_NumWaitTimeTank + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeTank);
-            }
-            else if (role & ROLE_HEALER)
-            {
-                if (role & ROLE_DAMAGE)
-                    m_WaitTimeAvg = int32((m_WaitTimeAvg * m_NumWaitTimeAvg + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeAvg);
-                else
-                    m_WaitTimeHealer = int32((m_WaitTimeHealer * m_NumWaitTimeHealer + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeHealer);
-            }
-            else if (role & ROLE_DAMAGE)
-                m_WaitTimeDps = int32((m_WaitTimeDps * m_NumWaitTimeDps + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeDps);
-
-            grp->SetLfgRoles(plr->GetGUID(), pProposal->players[plr->GetGUIDLow()]->role);
-        }
-
-        // Set the dungeon difficulty
-        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(pProposal->dungeonId);
-        ASSERT(dungeon);
-        grp->SetDungeonDifficulty(Difficulty(dungeon->difficulty));
-        grp->SetLfgDungeonEntry(dungeon->Entry());
-        grp->SetLfgStatus(LFG_STATUS_NOT_SAVED);
-        grp->SendUpdate();
-
-        // Remove players/groups from Queue
-        for (LfgGuidList::const_iterator it = pProposal->queues.begin(); it != pProposal->queues.end(); ++it)
-            RemoveFromQueue(*it);
-
-        // Teleport Player
-        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
-            TeleportPlayer(*it, false);
-
-        for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
-            delete it->second;
-        pProposal->players.clear();
-        pProposal->queues.clear();
-        delete pProposal;
-        m_Proposals.erase(itProposal);
-    }
-    players.clear();
-}
-
-/// <summary>
-/// Remove a proposal from the pool, remove the group that didn't accept (if needed) and readd the other members to the queue
-/// </summary>
-/// <param name="LfgProposalMap::iterator">Proposal to remove</param>
-/// <param name="LfgUpdateType">Type of removal (LFG_UPDATETYPE_PROPOSAL_FAILED, LFG_UPDATETYPE_PROPOSAL_DECLINED)</param>
-void LFGMgr::RemoveProposal(LfgProposalMap::iterator itProposal, LfgUpdateType type)
-{
-    Player* plr;
-    uint64 guid;
-    LfgUpdateType updateType;
-    LfgQueueInfoMap::iterator itQueue;
-    LfgProposal* pProposal = itProposal->second;
-    pProposal->state = LFG_PROPOSAL_FAILED;
-
-    sLog.outDebug("LFGMgr::RemoveProposal: Proposal %u, state FAILED, UpdateType %u", itProposal->first, type);
-    // Mark all people that didn't answered as no accept
-    if (type == LFG_UPDATETYPE_PROPOSAL_FAILED)
-        for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
-            if (it->second->accept != LFG_ANSWER_AGREE)
-                it->second->accept = LFG_ANSWER_DENY;
-
-    // Inform players
-    for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
-    {
-        plr = sObjectMgr.GetPlayerByLowGUID(it->first);
-        if (!plr)
-            continue;
-        guid = it->second->groupLowGuid ? MAKE_NEW_GUID(it->second->groupLowGuid, 0, HIGHGUID_GROUP) : plr->GetGUID();
-
-        plr->GetSession()->SendUpdateProposal(itProposal->first, pProposal);
-        // Remove members that didn't accept
-        if (it->second->accept == LFG_ANSWER_DENY)
-        {
-            updateType = type;
-            plr->GetLfgDungeons()->clear();
-            plr->SetLfgRoles(ROLE_NONE);
-            if (!plr->GetGroup() || !plr->GetGroup()->isLFGGroup())
-                plr->SetLfgState(LFG_STATE_NONE);
-
-            sLog.outDebug("LFGMgr::RemoveProposal: [" UI64FMTD "] didn't accept. Removing from queue and compatible cache", guid);
-            RemoveFromQueue(guid);
-        }
-        else                                                // Readd to queue
-        {
-            itQueue = m_QueueInfoMap.find(guid);
-            if (itQueue == m_QueueInfoMap.end())            // Can't readd! misssing queue info!
-            {
-                sLog.outError("LFGMgr::RemoveProposal: Imposible to readd [" UI64FMTD "] to queue. Missing queue info!", guid);
-                updateType = LFG_UPDATETYPE_REMOVED_FROM_QUEUE;
-            }
-            else
-            {
-                sLog.outDebug("LFGMgr::RemoveProposal: Readding [" UI64FMTD "] to queue.", guid);
-                itQueue->second->joinTime = time_t(time(NULL));
-                AddGuidToNewQueue(guid);
-                updateType = LFG_UPDATETYPE_ADDED_TO_QUEUE;
-            }
-        }
-
-        if (plr->GetGroup())
-            plr->GetSession()->SendLfgUpdateParty(updateType);
-        else
-            plr->GetSession()->SendLfgUpdatePlayer(updateType);
-
-    }
-
-    for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
-        delete it->second;
-    pProposal->players.clear();
-    pProposal->queues.clear();
-    delete pProposal;
-    m_Proposals.erase(itProposal);
-}
-
-/// <summary>
-/// Initialize a boot kick vote
-/// </summary>
-/// <param name="Group*">Group</param>
-/// <param name="uint32">Player low guid who inits the vote kick</param>
-/// <param name="uint32">Player low guid to be kicked </param>
-/// <param name="std::string">kick reason</param>
-void LFGMgr::InitBoot(Group* grp, uint32 iLowGuid, uint32 vLowguid, std::string reason)
-{
-    if (!grp)
-        return;
-
-    LfgPlayerBoot* pBoot = new LfgPlayerBoot();
-    pBoot->inProgress = true;
-    pBoot->cancelTime = time_t(time(NULL)) + LFG_TIME_BOOT;
-    pBoot->reason = reason;
-    pBoot->victimLowGuid = vLowguid;
-    pBoot->votedNeeded = GROUP_LFG_KICK_VOTES_NEEDED;
-    PlayerSet players;
-
-    uint32 pLowGuid = 0;
-    for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        if (Player* plrg = itr->getSource())
-        {
-            pLowGuid = plrg->GetGUIDLow();
-            if (pLowGuid == vLowguid)
-                pBoot->votes[pLowGuid] = LFG_ANSWER_DENY;   // Victim auto vote NO
-            else if (pLowGuid == iLowGuid)
-                pBoot->votes[pLowGuid] = LFG_ANSWER_AGREE;  // Kicker auto vote YES
-            else
-            {
-                pBoot->votes[pLowGuid] = LFG_ANSWER_PENDING;// Other members need to vote
-                players.insert(plrg);
-            }
-        }
-    }
-
-    for (PlayerSet::const_iterator it = players.begin(); it != players.end(); ++it)
-        (*it)->GetSession()->SendLfgBootPlayer(pBoot);
-
-    grp->SetLfgKickActive(true);
-    m_Boots[grp->GetLowGUID()] = pBoot;
-}
-
-/// <summary>
-/// Update Boot info with player answer
-/// </summary>
-/// <param name="Player*">Player guid</param>
-/// <param name="bool">Player answer</param>
-void LFGMgr::UpdateBoot(Player* plr, bool accept)
-{
-    Group* grp = plr ? plr->GetGroup() : NULL;
-    if (!grp)
-        return;
-
-    uint32 bootId = grp->GetLowGUID();
-    uint32 lowGuid = plr->GetGUIDLow();
-
-    LfgPlayerBootMap::iterator itBoot = m_Boots.find(bootId);
-    if (itBoot == m_Boots.end())
-        return;
-
-    LfgPlayerBoot* pBoot = itBoot->second;
-    if (!pBoot)
-        return;
-
-    if (pBoot->votes[lowGuid] != LFG_ANSWER_PENDING)        // Cheat check: Player can't vote twice
-        return;
-
-    pBoot->votes[lowGuid] = LfgAnswer(accept);
-
-    uint8 votesNum = 0;
-    uint8 agreeNum = 0;
-    for (LfgAnswerMap::const_iterator itVotes = pBoot->votes.begin(); itVotes != pBoot->votes.end(); ++itVotes)
-    {
-        if (itVotes->second != LFG_ANSWER_PENDING)
-        {
-            ++votesNum;
-            if (itVotes->second == LFG_ANSWER_AGREE)
-                ++agreeNum;
-        }
-    }
-
-    if (agreeNum == pBoot->votedNeeded ||                   // Vote passed
-        votesNum == pBoot->votes.size() ||                  // All voted but not passed
-        (pBoot->votes.size() - votesNum + agreeNum) < pBoot->votedNeeded) // Vote didnt passed
-    {
-        // Send update info to all players
-        pBoot->inProgress = false;
-        for (LfgAnswerMap::const_iterator itVotes = pBoot->votes.begin(); itVotes != pBoot->votes.end(); ++itVotes)
-            if (Player* plrg = sObjectMgr.GetPlayerByLowGUID(itVotes->first))
-                if (plrg->GetGUIDLow() != pBoot->victimLowGuid)
-                    plrg->GetSession()->SendLfgBootPlayer(pBoot);
-
-        if (agreeNum == pBoot->votedNeeded)                 // Vote passed - Kick player
-        {
-            Player::RemoveFromGroup(grp, MAKE_NEW_GUID(pBoot->victimLowGuid, 0, HIGHGUID_PLAYER));
-            if (Player* victim = sObjectMgr.GetPlayerByLowGUID(pBoot->victimLowGuid))
-                TeleportPlayer(victim, true, false);
-            OfferContinue(grp);
-            grp->SetLfgKicks(grp->GetLfgKicks() + 1);
-        }
-        grp->SetLfgKickActive(false);
-        delete pBoot;
-        m_Boots.erase(itBoot);
-    }
-}
-
-/// <summary>
-/// Teleports the player in or out the dungeon
-/// </summary>
-/// <param name="Player*">Player</param>
-/// <param name="bool">Teleport out</param>
-/// <param name="bool">Automatic or manual teleport</param>
-void LFGMgr::TeleportPlayer(Player* plr, bool out, bool fromOpcode /*= false*/)
-{
-    sLog.outDebug("LFGMgr::TeleportPlayer: [" UI64FMTD "] is being teleported %s", plr->GetGUID(), out ? "out" : "in");
-    if (out)
-    {
-        plr->RemoveAurasDueToSpell(LFG_SPELL_LUCK_OF_THE_DRAW);
-        plr->TeleportToBGEntryPoint();
-        return;
-    }
-
-    // TODO Add support for LFG_TELEPORTERROR_FATIGUE
-    LfgTeleportError error = LFG_TELEPORTERROR_OK;
-    Group* grp = plr->GetGroup();
-
-    if (!grp || !grp->isLFGGroup()) // should never happen, but just in case...
-        error = LFG_TELEPORTERROR_INVALID_LOCATION;
-    else if (!plr->isAlive())
-        error = LFG_TELEPORTERROR_PLAYER_DEAD;
-    else if (plr->IsFalling() || plr->hasUnitState(UNIT_STAT_JUMPING))
-        error = LFG_TELEPORTERROR_FALLING;
-    else
-    {
-        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(grp->GetLfgDungeonEntry());
-
-        if (!dungeon)
-            error = LFG_TELEPORTERROR_INVALID_LOCATION;
-        else if (plr->GetMapId() != uint32(dungeon->map))    // Do not teleport players in dungeon to the entrance
-        {
-            uint32 mapid = 0;
-            float x = 0;
-            float y = 0;
-            float z = 0;
-            float orientation = 0;
-
-            if (!fromOpcode)
-            {
-                Player *plrg;
-                // Select a player inside to be teleported to
-                for (GroupReference* itr = grp->GetFirstMember(); itr != NULL && !mapid; itr = itr->next())
-                {
-                    plrg = itr->getSource();
-                    if (plrg && plrg != plr && plrg->GetMapId() == uint32(dungeon->map))
-                    {
-                        mapid = plrg->GetMapId();
-                        x = plrg->GetPositionX();
-                        y = plrg->GetPositionY();
-                        z = plrg->GetPositionZ();
-                        orientation = plrg->GetOrientation();
-                    }
-                }
-            }
-
-            if (!mapid)
-            {
-                AreaTrigger const* at = sObjectMgr.GetMapEntranceTrigger(dungeon->map);
-                if (!at)
-                {
-                    sLog.outError("LfgMgr::TeleportPlayer: Failed to teleport [" UI64FMTD "]: No areatrigger found for map: %u difficulty: %u", plr->GetGUID(), dungeon->map, dungeon->difficulty);
-                    error = LFG_TELEPORTERROR_INVALID_LOCATION;
-                }
-                else
-                {
-                    mapid = at->target_mapId;
-                    x = at->target_X;
-                    y = at->target_Y;
-                    z = at->target_Z;
-                    orientation = at->target_Orientation;
-                }
-            }
-           
-            if (error == LFG_TELEPORTERROR_OK)
-            {
-                if (!plr->GetMap()->IsDungeon() && !plr->GetMap()->IsRaid())
-                    plr->SetBattlegroundEntryPoint();
-
-                if (plr->isInFlight())
-                {
-                    plr->GetMotionMaster()->MovementExpired();
-                    plr->CleanupAfterTaxiFlight();
-                }
-
-                if (plr->TeleportTo(mapid, x, y, z, orientation))
-                    plr->RemoveAurasByType(SPELL_AURA_MOUNTED);
-                else
-                {
-                    error = LFG_TELEPORTERROR_INVALID_LOCATION;
-                    sLog.outError("LfgMgr::TeleportPlayer: Failed to teleport [" UI64FMTD "] to map %u: ", plr->GetGUID(), mapid);
-                }
-            }
-        }
-    }
-
-    if (error != LFG_TELEPORTERROR_OK)
-        plr->GetSession()->SendLfgTeleportError(error);
-}
-
-/// <summary>
-/// Give completion reward to player
-/// </summary>
-/// <param name="const uint32">dungeonId</param>
-/// <param name="Player*">player</param>
-void LFGMgr::RewardDungeonDoneFor(const uint32 dungeonId, Player* player)
-{
-    Group* group = player->GetGroup();
-    if ((!group || !group->isLFGGroup()) || !sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
-        return;
-
-    // Mark dungeon as finished
-    if (!group->isLfgDungeonComplete())
-        group->SetLfgStatus(LFG_STATUS_COMPLETE);
-
-    // Clear player related lfg stuff
-    uint32 rDungeonId = (*player->GetLfgDungeons()->begin());
-    player->GetLfgDungeons()->clear();
-    player->SetLfgRoles(ROLE_NONE);
-
-    // Give rewards only if its a random dungeon
-    LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId);
-    if (!dungeon || dungeon->type != LFG_TYPE_RANDOM)
-        return;
-
-    // Update achievements
-    if (dungeon->difficulty == DUNGEON_DIFFICULTY_HEROIC)
-        player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_USE_LFD_TO_GROUP_WITH_PLAYERS, 1);
-
-    LfgReward const* reward = GetRandomDungeonReward(rDungeonId, player->getLevel());
-    if (!reward)
-        return;
-
-    uint8 index = 0;
-    Quest const* qReward = sObjectMgr.GetQuestTemplate(reward->reward[index].questId);
-    if (!qReward)
-        return;
-
-    // if we can take the quest, means that we haven't done this kind of "run", IE: First Heroic Random of Day.
-    if (player->CanRewardQuest(qReward,false))
-        player->RewardQuest(qReward,0,NULL,false);
-    else
-    {
-        index = 1;
-        qReward = sObjectMgr.GetQuestTemplate(reward->reward[index].questId);
-        if (!qReward)
-            return;
-        // we give reward without informing client (retail does this)
-        player->RewardQuest(qReward,0,NULL,false);
-    }
-
-    // Give rewards
-    player->GetSession()->SendLfgPlayerReward(dungeon->Entry(), group->GetLfgDungeonEntry(false), index, reward, qReward);
-}
-
-// --------------------------------------------------------------------------//
-// Auxiliar Functions
-// --------------------------------------------------------------------------//
-
-/// <summary>
-/// Given a group get the dungeons that can't be done and reason
-/// </summary>
-/// <param name="PlayerSet*">Players to check lock status</param>
-/// <param name="LfgDungeonSet*">Dungeons to check</param>
-/// <param name="bool">Use dungeon entry (true) or id (false)</param>
-/// <returns>LfgLockStatusMap*</returns>
-LfgLockStatusMap* LFGMgr::GetGroupLockStatusDungeons(PlayerSet* pPlayers, LfgDungeonSet* dungeons, bool useEntry /* = true */)
-{
-    if (!pPlayers || !dungeons)
-        return NULL;
-
-    LfgLockStatusSet* dungeonSet = NULL;
-    LfgLockStatusMap* dungeonMap = new LfgLockStatusMap();
-    for (PlayerSet::const_iterator itr = pPlayers->begin(); itr != pPlayers->end(); ++itr)
-    {
-        dungeonSet = GetPlayerLockStatusDungeons(*itr, dungeons, useEntry);
-        if (dungeonSet)
-            (*dungeonMap)[(*itr)->GetGUIDLow()] = dungeonSet;
-    }
-
-    if (!dungeonMap->size())
-    {
-        delete dungeonMap;
-        dungeonMap = NULL;
-    }
-    return dungeonMap;
-}
-
-/// <summary>
-/// Get all Group members list of dungeons that can't be done and reason
-/// leader excluded as the list given is he list he can do
-/// </summary>
-/// <param name="Player*">Player to get Party Lock info</param>
-/// <param name="LfgDungeonSet*">Dungeons to check</param>
-/// <returns>LfgLockStatusMap*</returns>
-LfgLockStatusMap* LFGMgr::GetPartyLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons /* = NULL */)
-{
-    if (!plr)
-        return NULL;
-
-    if (!dungeons)
-        dungeons = GetAllDungeons();
-
-    Group* grp = plr->GetGroup();
-    if (!grp)
-        return NULL;
-
-    PlayerSet* pPlayers = new PlayerSet();
-    Player* plrg;
-    for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        plrg = itr->getSource();
-        if (plrg && plrg != plr)
-            pPlayers->insert(plrg);
-    }
-    LfgLockStatusMap* dungeonMap = GetGroupLockStatusDungeons(pPlayers, dungeons);
-    pPlayers->clear();
-    delete pPlayers;
-    return dungeonMap;
-}
-
-/// <summary>
-/// Get list of dungeons player can't do and reasons
-/// </summary>
-/// <param name="Player*">Player to check lock status</param>
-/// <param name="LfgDungeonSet*">Dungeons to check</param>
-/// <param name="bool">Use dungeon entry (true) or id (false)</param>
-/// <returns>LfgLockStatusSet*</returns>
-LfgLockStatusSet* LFGMgr::GetPlayerLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons /* = NULL */, bool useEntry /* = true */)
-{
-    LfgLockStatusSet* list = new LfgLockStatusSet();
-    LfgLockStatus* lockstatus = NULL;
-    LFGDungeonEntry const* dungeon;
-    LfgLockStatusType locktype;
-    uint8 level = plr->getLevel();
-    uint8 expansion = plr->GetSession()->Expansion();
-    AccessRequirement const* ar;
-
-    if (!dungeons)
-        dungeons = GetAllDungeons();
-
-    for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
-    {
-        dungeon = sLFGDungeonStore.LookupEntry(*it);
-        if (!dungeon) // should never happen - We provide a list from sLFGDungeonStore
-            continue;
-
-        ar = sObjectMgr.GetAccessRequirement(dungeon->map, Difficulty(dungeon->difficulty));
-
-        locktype = LFG_LOCKSTATUS_OK;
-        if (dungeon->expansion > expansion)
-            locktype = LFG_LOCKSTATUS_INSUFFICIENT_EXPANSION;
-        else if (sDisableMgr.IsDisabledFor(DISABLE_TYPE_MAP, dungeon->map, plr))
-            locktype = LFG_LOCKSTATUS_RAID_LOCKED;
-        else if (dungeon->difficulty > DUNGEON_DIFFICULTY_NORMAL && plr->GetBoundInstance(dungeon->map, Difficulty(dungeon->difficulty)))
-            locktype = LFG_LOCKSTATUS_RAID_LOCKED;
-        else if (dungeon->minlevel > level)
-            locktype = LFG_LOCKSTATUS_TOO_LOW_LEVEL;
-        else if (dungeon->maxlevel < level)
-            locktype = LFG_LOCKSTATUS_TOO_HIGH_LEVEL;
-        else if (locktype == LFG_LOCKSTATUS_OK && ar)
-        {
-            if (ar->achievement && !plr->GetAchievementMgr().HasAchieved(sAchievementStore.LookupEntry(ar->achievement)))
-                locktype = LFG_LOCKSTATUS_RAID_LOCKED; // FIXME: Check the correct lock value
-            else if (plr->GetTeam() == ALLIANCE && ar->quest_A && !plr->GetQuestRewardStatus(ar->quest_A))
-                locktype = LFG_LOCKSTATUS_QUEST_NOT_COMPLETED;
-            else if (plr->GetTeam() == HORDE && ar->quest_H && !plr->GetQuestRewardStatus(ar->quest_H))
-                locktype = LFG_LOCKSTATUS_QUEST_NOT_COMPLETED;
-            else
-                if (ar->item)
-                {
-                    if (!plr->HasItemCount(ar->item, 1) && (!ar->item2 || !plr->HasItemCount(ar->item2, 1)))
-                        locktype = LFG_LOCKSTATUS_MISSING_ITEM;
-                }
-                else if (ar->item2 && !plr->HasItemCount(ar->item2, 1))
-                    locktype = LFG_LOCKSTATUS_MISSING_ITEM;
-        }
-        /* TODO VoA closed if WG is not under team control (LFG_LOCKSTATUS_RAID_LOCKED)
-            locktype = LFG_LOCKSTATUS_TOO_LOW_GEAR_SCORE;
-            locktype = LFG_LOCKSTATUS_TOO_HIGH_GEAR_SCORE;
-            locktype = LFG_LOCKSTATUS_ATTUNEMENT_TOO_LOW_LEVEL;
-            locktype = LFG_LOCKSTATUS_ATTUNEMENT_TOO_HIGH_LEVEL;
-            locktype = LFG_LOCKSTATUS_NOT_IN_SEASON; // Need list of instances and needed season to open
-        */
-
-        if (locktype != LFG_LOCKSTATUS_OK)
-        {
-            lockstatus = new LfgLockStatus();
-            lockstatus->dungeon = useEntry ? dungeon->Entry(): dungeon->ID;
-            lockstatus->lockstatus = locktype;
-            list->insert(lockstatus);
-        }
-    }
-    if (!list->size())
-    {
-        delete list;
-        list = NULL;
-    }
-    return list;
-}
-
-/// <summary>
-/// Get the dungeon list that can be done.
-/// </summary>
-/// <returns>LfgDungeonSet*</returns>
-LfgDungeonSet* LFGMgr::GetAllDungeons()
-{
-    LfgDungeonSet* alldungeons = m_CachedDungeonMap[0];
-
-    if (alldungeons)
-        return alldungeons;
-
-    LfgDungeonSet* dungeons;
-    LFGDungeonEntry const* dungeon;
-
-    alldungeons = new LfgDungeonSet();
-    m_CachedDungeonMap[0] = alldungeons;
-    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
-    {
-        dungeon = sLFGDungeonStore.LookupEntry(i);
-        if (!dungeon || dungeon->type == LFG_TYPE_ZONE)
-            continue;
-        dungeons = m_CachedDungeonMap[dungeon->grouptype];
-        if (!dungeons)
-        {
-            dungeons = new LfgDungeonSet();
-            m_CachedDungeonMap[dungeon->grouptype] = dungeons;
-        }
-        if (dungeon->type != LFG_TYPE_RANDOM)
-            dungeons->insert(dungeon->ID);
-        alldungeons->insert(dungeon->ID);
-    }
-
-    return alldungeons;
-}
-
-/// <summary>
-/// Get the dungeon list that can be done given a random dungeon entry.
-/// Special case: randomdungeon == 0 then will return all dungeons
-/// </summary>
-/// <param name="uint32">Random dungeon entry</param>
-/// <returns>LfgDungeonSet*</returns>
-LfgDungeonSet* LFGMgr::GetDungeonsByRandom(uint32 randomdungeon)
-{
-    uint8 groupType = 0;
-    if (LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(randomdungeon))
-        groupType = dungeon->grouptype;
-
-    LfgDungeonMap::const_iterator itMap = m_CachedDungeonMap.find(groupType);
-    if (itMap == m_CachedDungeonMap.end())
-        return NULL;
-
-    LfgDungeonSet* dungeons = new LfgDungeonSet();
-    for (LfgDungeonSet::const_iterator it = itMap->second->begin(); it != itMap->second->end(); ++it)
-        dungeons->insert(*it);
-    return dungeons;
-}
-
-/// <summary>
-/// Get the random dungeon list that can be done at a certain level and expansion.
-/// </summary>
-/// <param name="uint8">Player level</param>
-/// <param name="uint8">Player account expansion</param>
-/// <returns>LfgDungeonSet*</returns>
-LfgDungeonSet* LFGMgr::GetRandomDungeons(uint8 level, uint8 expansion)
-{
-    LfgDungeonSet* list = new LfgDungeonSet();
-    LFGDungeonEntry const* dungeon;
-    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
-    {
-        dungeon = sLFGDungeonStore.LookupEntry(i);
-        if (dungeon && dungeon->expansion <= expansion && dungeon->type == LFG_TYPE_RANDOM &&
-            dungeon->minlevel <= level && level <= dungeon->maxlevel)
-            list->insert(dungeon->Entry());
-    }
-    return list;
-}
-
-/// <summary>
-/// Get the reward of a given random dungeon at a certain level
-/// </summary>
-/// <param name="uint32">random dungeon id</param>
-/// <param name="uint8">Player level</param>
-/// <returns>LfgReward const*</returns>
-LfgReward const* LFGMgr::GetRandomDungeonReward(uint32 dungeon, uint8 level)
-{
-    LfgReward const* rew = NULL;
-    LfgRewardMapBounds bounds = m_RewardMap.equal_range(dungeon & 0x00FFFFFF);
-    for (LfgRewardMap::const_iterator itr = bounds.first; itr != bounds.second; ++itr)
-    {
-        rew = itr->second;
-        // ordered properly at loading
-        if (itr->second->maxLevel >= level)
-            break;
-    }
-
-    return rew;
-}
-
-/// <summary>
-/// Given a Dungeon id returns the dungeon Group Type
-/// </summary>
-/// <param name="uint32">Dungeon id</param>
-/// <returns>uint8: GroupType</returns>
-uint8 LFGMgr::GetDungeonGroupType(uint32 dungeonId)
-{
-    LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId);
-    if (!dungeon)
-        return 0;
-
-    return dungeon->grouptype;
-}
-
-/// <summary>
-/// Given a Dungeon id returns if it's random
-/// </summary>
-/// <param name="uint32">Dungeon id</param>
-/// <returns>bool</returns>
-bool LFGMgr::isRandomDungeon(uint32 dungeonId)
-{
-    LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId);
-    if (!dungeon)
-        return false;
-
-    return dungeon->type == LFG_TYPE_RANDOM;
-}
-
-/// <summary>
-/// Given a guid returns if it recently joined queue
-/// </summary>
-/// <param name="uint64&">guid</param>
-/// <returns>bool</returns>
-bool LFGMgr::isJoining(uint64 guid)
-{
-    LfgQueueInfoMap::iterator itQueue = m_QueueInfoMap.find(guid);
-    return itQueue != m_QueueInfoMap.end() && itQueue->second->joinTime + LFG_TIME_JOIN_WARNING > time_t(time(NULL));
-}
-
-/// <summary>
-/// Given a Achievement id returns the related dungeon id
-/// </summary>
-/// <param name="uint32">Achievement id</param>
-/// <returns>uint32</returns>
-uint32 LFGMgr::GetDungeonIdForAchievement(uint32 achievementId)
-{
-    std::map<uint32, uint32>::iterator itr = m_EncountersByAchievement.find(achievementId);
-    if (itr != m_EncountersByAchievement.end())
-        return itr->second;
-
-    return 0;
-};
-
-/// <summary>
-/// Given a list of guids returns the concatenation using | as delimiter
-/// </summary>
-/// <param name="LfgGuidList ">list of guids</param>
-/// <returns>std::string</returns>
-std::string LFGMgr::ConcatenateGuids(LfgGuidList check)
-{
-    if (check.empty())
-        return "";
-
-    LfgGuidSet guidSet;
-    while (!check.empty())
-    {
-        guidSet.insert(check.front());
-        check.pop_front();
-    }
-
-    std::ostringstream o;
-    LfgGuidSet::const_iterator it = guidSet.begin();
-    o << (*it);
-    for (++it; it != guidSet.end(); ++it)
-        o << "|" << (*it);
-    guidSet.clear();
-    return o.str();
-}
-
-/// <summary>
-/// Given a list of dungeonIds returns the concatenation using , as delimiter
-/// </summary>
-/// <param name="LfgDungeonSet ">list of dungeons</param>
-/// <returns>std::string</returns>
-std::string LFGMgr::ConcatenateDungeons(LfgDungeonSet* dungeons)
-{
-    std::string dungeonstr = "";
-    if (dungeons && !dungeons->empty())
-    {
-        std::ostringstream o;
-        LfgDungeonSet::const_iterator it = dungeons->begin();
-        o << (*it);
-        for (++it; it != dungeons->end(); ++it)
-            o << ", " << (*it);
-        dungeonstr = o.str();
-    }
-    return dungeonstr;
-}
+﻿/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "SharedDefines.h"
+
+#include "DisableMgr.h"
+#include "ObjectMgr.h"
+#include "ProgressBar.h"
+#include "SocialMgr.h"
+#include "LFGMgr.h"
+
+#include "Group.h"
+#include "Player.h"
+
+// --- Temporal functions
+// Added to try to find bugs that leaves data inconsistent
+void LFGMgr::Cleaner()
+{
+    LfgQueueInfoMap::iterator itQueue;
+    LfgGuidList::iterator itGuidListRemove;
+    LfgGuidList eraseList;
+
+    for (LfgQueueInfoMap::iterator it = m_QueueInfoMap.begin(); it != m_QueueInfoMap.end();)
+    {
+        itQueue = it++;
+        // Remove empty queues
+        if (!itQueue->second)
+        {
+            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from QueueInfoMap, data is null", itQueue->first);
+            m_QueueInfoMap.erase(itQueue);
+        }
+        // Remove queue with empty players
+        else if(!itQueue->second->roles.size())
+        {
+            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from QueueInfoMap, no players in queue!", itQueue->first);
+            m_QueueInfoMap.erase(itQueue);
+        }
+    }
+
+    // Remove from NewToQueue those guids that do not exist in queueMap
+    for (LfgGuidList::iterator it = m_newToQueue.begin(); it != m_newToQueue.end();)
+    {
+        itGuidListRemove = it++;
+        if (m_QueueInfoMap.find(*itGuidListRemove) == m_QueueInfoMap.end())
+        {
+            eraseList.push_back(*itGuidListRemove);
+            m_newToQueue.erase(itGuidListRemove);
+            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from newToQueue, no queue info with that guid", (*itGuidListRemove));
+        }
+    }
+
+    // Remove from currentQueue those guids that do not exist in queueMap
+    for (LfgGuidList::iterator it = m_currentQueue.begin(); it != m_currentQueue.end();)
+    {
+        itGuidListRemove = it++;
+        if (m_QueueInfoMap.find(*itGuidListRemove) == m_QueueInfoMap.end())
+        {
+            eraseList.push_back(*itGuidListRemove);
+            m_newToQueue.erase(itGuidListRemove);
+            sLog.outError("LFGMgr::Cleaner: removing [" UI64FMTD "] from currentQueue, no queue info with that guid", (*itGuidListRemove));
+        }
+    }
+
+    for (LfgGuidList::iterator it = eraseList.begin(); it != eraseList.end(); ++it)
+    {
+        if (IS_GROUP(*it))
+        {
+            if (Group* grp = sObjectMgr.GetGroupByGUID(GUID_LOPART(*it)))
+                for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+                    if (Player* plr = itr->getSource())
+                        plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
+        }
+        else
+            if (Player* plr = sObjectMgr.GetPlayer(*it))
+                plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
+    }
+}
+
+LFGMgr::LFGMgr()
+{
+    m_QueueTimer = 0;
+    m_WaitTimeAvg = -1;
+    m_WaitTimeTank = -1;
+    m_WaitTimeHealer = -1;
+    m_WaitTimeDps = -1;
+    m_NumWaitTimeAvg = 0;
+    m_NumWaitTimeTank = 0;
+    m_NumWaitTimeHealer = 0;
+    m_NumWaitTimeDps = 0;
+    m_update = true;
+    m_lfgProposalId = 1;
+    GetAllDungeons();
+}
+
+LFGMgr::~LFGMgr()
+{
+    for (LfgRewardMap::iterator itr = m_RewardMap.begin(); itr != m_RewardMap.end(); ++itr)
+        delete itr->second;
+    m_RewardMap.clear();
+
+    m_EncountersByAchievement.clear();
+
+    for (LfgQueueInfoMap::iterator it = m_QueueInfoMap.begin(); it != m_QueueInfoMap.end(); ++it)
+        delete it->second;
+    m_QueueInfoMap.clear();
+
+    for (LfgProposalMap::iterator it = m_Proposals.begin(); it != m_Proposals.end(); ++it)
+        delete it->second;
+    m_Proposals.clear();
+
+    for (LfgPlayerBootMap::iterator it = m_Boots.begin(); it != m_Boots.end(); ++it)
+        delete it->second;
+    m_Boots.clear();
+
+    for (LfgRoleCheckMap::iterator it = m_RoleChecks.begin(); it != m_RoleChecks.end(); ++it)
+        delete it->second;
+    m_RoleChecks.clear();
+
+    for (LfgDungeonMap::iterator it = m_CachedDungeonMap.begin(); it != m_CachedDungeonMap.end(); ++it)
+        delete it->second;
+    m_CachedDungeonMap.clear();
+
+    m_CompatibleMap.clear();
+    m_QueueInfoMap.clear();
+    m_currentQueue.clear();
+    m_newToQueue.clear();
+}
+
+/// <summary>
+/// Load achievement <-> encounter associations
+/// </summary>
+void LFGMgr::LoadDungeonEncounters()
+{
+    m_EncountersByAchievement.clear();
+
+    uint32 count = 0;
+    QueryResult result = WorldDatabase.Query("SELECT achievementId, dungeonId FROM lfg_dungeon_encounters");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outErrorDb(">> Loaded 0 dungeon encounter lfg associations. DB table `lfg_dungeon_encounters` is empty!");
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    Field* fields = NULL;
+    do
+    {
+        bar.step();
+        fields = result->Fetch();
+        uint32 achievementId = fields[0].GetUInt32();
+        uint32 dungeonId = fields[1].GetUInt32();
+
+        if (AchievementEntry const* achievement = sAchievementStore.LookupEntry(achievementId))
+        {
+            if (!(achievement->flags & ACHIEVEMENT_FLAG_COUNTER))
+            {
+                sLog.outErrorDb("Achievement %u specified in table `lfg_dungeon_encounters` is not a statistic!", achievementId);
+                continue;
+            }
+        }
+        else
+        {
+            sLog.outErrorDb("Achievement %u specified in table `lfg_dungeon_encounters` does not exist!", achievementId);
+            continue;
+        }
+
+        if (!sLFGDungeonStore.LookupEntry(dungeonId))
+        {
+            sLog.outErrorDb("Dungeon %u specified in table `lfg_dungeon_encounters` does not exist!", dungeonId);
+            continue;
+        }
+
+        m_EncountersByAchievement[achievementId] = dungeonId;
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u dungeon encounter lfg associations.", count);
+}
+
+/// <summary>
+/// Load rewards for completing dungeons
+/// </summary>
+void LFGMgr::LoadRewards()
+{
+    for (LfgRewardMap::iterator itr = m_RewardMap.begin(); itr != m_RewardMap.end(); ++itr)
+        delete itr->second;
+    m_RewardMap.clear();
+
+    uint32 count = 0;
+    // ORDER BY is very important for GetRandomDungeonReward!
+    QueryResult result = WorldDatabase.Query("SELECT dungeonId, maxLevel, firstQuestId, firstMoneyVar, firstXPVar, otherQuestId, otherMoneyVar, otherXPVar FROM lfg_dungeon_rewards ORDER BY dungeonId, maxLevel ASC");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outErrorDb(">> Loaded 0 lfg dungeon rewards. DB table `lfg_dungeon_rewards` is empty!");
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    Field* fields = NULL;
+    do
+    {
+        bar.step();
+        fields = result->Fetch();
+        uint32 dungeonId = fields[0].GetUInt32();
+        uint32 maxLevel = fields[1].GetUInt8();
+        uint32 firstQuestId = fields[2].GetUInt32();
+        uint32 firstMoneyVar = fields[3].GetUInt32();
+        uint32 firstXPVar = fields[4].GetUInt32();
+        uint32 otherQuestId = fields[5].GetUInt32();
+        uint32 otherMoneyVar = fields[6].GetUInt32();
+        uint32 otherXPVar = fields[7].GetUInt32();
+
+        if (!sLFGDungeonStore.LookupEntry(dungeonId))
+        {
+            sLog.outErrorDb("Dungeon %u specified in table `lfg_dungeon_rewards` does not exist!", dungeonId);
+            continue;
+        }
+
+        if (!maxLevel || maxLevel > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        {
+            sLog.outErrorDb("Level %u specified for dungeon %u in table `lfg_dungeon_rewards` can never be reached!", maxLevel, dungeonId);
+            maxLevel = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+        }
+
+        if (firstQuestId && !sObjectMgr.GetQuestTemplate(firstQuestId))
+        {
+            sLog.outErrorDb("First quest %u specified for dungeon %u in table `lfg_dungeon_rewards` does not exist!", firstQuestId, dungeonId);
+            firstQuestId = 0;
+        }
+
+        if (otherQuestId && !sObjectMgr.GetQuestTemplate(otherQuestId))
+        {
+            sLog.outErrorDb("Other quest %u specified for dungeon %u in table `lfg_dungeon_rewards` does not exist!", otherQuestId, dungeonId);
+            otherQuestId = 0;
+        }
+
+        m_RewardMap.insert(LfgRewardMap::value_type(dungeonId, new LfgReward(maxLevel, firstQuestId, firstMoneyVar, firstXPVar, otherQuestId, otherMoneyVar, otherXPVar)));
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u lfg dungeon rewards.", count);
+}
+
+void LFGMgr::Update(uint32 diff)
+{
+    if (!m_update || !sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
+        return;
+
+    m_update = false;
+    time_t currTime = time(NULL);
+
+    // Remove obsolete role checks
+    LfgRoleCheckMap::iterator itRoleCheck;
+    LfgRoleCheck* pRoleCheck;
+    for (LfgRoleCheckMap::iterator it = m_RoleChecks.begin(); it != m_RoleChecks.end();)
+    {
+        itRoleCheck = it++;
+        pRoleCheck = itRoleCheck->second;
+        if (currTime < pRoleCheck->cancelTime)
+            continue;
+        pRoleCheck->result = LFG_ROLECHECK_MISSING_ROLE;
+
+        Player* plr = NULL;
+        for (LfgRolesMap::const_iterator itRoles = pRoleCheck->roles.begin(); itRoles != pRoleCheck->roles.end(); ++itRoles)
+        {
+            plr = sObjectMgr.GetPlayerByLowGUID(itRoles->first);
+            if (!plr)
+                continue;
+            plr->GetSession()->SendLfgRoleCheckUpdate(pRoleCheck);
+            plr->GetLfgDungeons()->clear();
+            plr->SetLfgRoles(ROLE_NONE);
+            if (!plr->GetGroup() || !plr->GetGroup()->isLFGGroup())
+                plr->SetLfgState(LFG_STATE_NONE);
+
+            if (itRoles->first == pRoleCheck->leader)
+                plr->GetSession()->SendLfgJoinResult(LFG_JOIN_FAILED, pRoleCheck->result);
+        }
+        delete pRoleCheck;
+        m_RoleChecks.erase(itRoleCheck);
+    }
+
+    // Remove obsolete proposals
+    LfgProposalMap::iterator itRemove;
+    for (LfgProposalMap::iterator it = m_Proposals.begin(); it != m_Proposals.end();)
+    {
+        itRemove = it++;
+        if (itRemove->second->cancelTime < currTime)
+            RemoveProposal(itRemove, LFG_UPDATETYPE_PROPOSAL_FAILED);
+    }
+
+    // Remove obsolete kicks
+    LfgPlayerBootMap::iterator itBoot;
+    LfgPlayerBoot* pBoot;
+    for (LfgPlayerBootMap::iterator it = m_Boots.begin(); it != m_Boots.end();)
+    {
+        itBoot = it++;
+        pBoot = itBoot->second;
+        if (pBoot->cancelTime < currTime)
+        {
+            Group* grp = sObjectMgr.GetGroupByGUID(itBoot->first);
+            pBoot->inProgress = false;
+            for (LfgAnswerMap::const_iterator itVotes = pBoot->votes.begin(); itVotes != pBoot->votes.end(); ++itVotes)
+                if (Player* plrg = sObjectMgr.GetPlayerByLowGUID(itVotes->first))
+                    if (plrg->GetGUIDLow() != pBoot->victimLowGuid)
+                        plrg->GetSession()->SendLfgBootPlayer(pBoot);
+            if (grp)
+                grp->SetLfgKickActive(false);
+            delete pBoot;
+            m_Boots.erase(itBoot);
+        }
+    }
+
+    // Consistency cleaner
+    Cleaner();
+
+    // Check if a proposal can be formed with the new groups being added
+    LfgProposal* pProposal = NULL;
+    LfgGuidList firstNew;
+    while (!m_newToQueue.empty())
+    {
+        sLog.outDebug("LFGMgr::Update: checking [" UI64FMTD "] m_newToQueue(%u), m_currentQueue(%u)", m_newToQueue.front(), uint32(m_newToQueue.size()), uint32(m_currentQueue.size()));
+        firstNew.push_back(m_newToQueue.front());
+        pProposal = FindNewGroups(firstNew, m_currentQueue);
+        if (pProposal)                                       // Group found!
+        {
+            // Remove groups in the proposal from new and current queues (not from queue map)
+            for (LfgGuidList::const_iterator it = pProposal->queues.begin(); it != pProposal->queues.end(); ++it)
+            {
+                m_currentQueue.remove(*it);
+                m_newToQueue.remove(*it);
+            }
+            m_Proposals[++m_lfgProposalId] = pProposal;
+
+            uint32 lowGuid = 0;
+            for (LfgProposalPlayerMap::const_iterator itPlayers = pProposal->players.begin(); itPlayers != pProposal->players.end(); ++itPlayers)
+            {
+                lowGuid = itPlayers->first;
+                if (Player* plr = sObjectMgr.GetPlayerByLowGUID(itPlayers->first))
+                {
+                    if (plr->GetGroup())
+                        plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_PROPOSAL_BEGIN);
+                    else
+                        plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_PROPOSAL_BEGIN);
+                    plr->GetSession()->SendUpdateProposal(m_lfgProposalId, pProposal);
+                }
+            }
+
+            if (pProposal->state == LFG_PROPOSAL_SUCCESS)
+                UpdateProposal(m_lfgProposalId, lowGuid, true);
+        }
+        else
+        {
+            m_currentQueue.push_back(m_newToQueue.front());  // Group not found, add this group to the queue.
+            m_newToQueue.pop_front();
+        }
+        firstNew.clear();
+    }
+
+    // Update all players status queue info
+    if (m_QueueTimer > LFG_QUEUEUPDATE_INTERVAL)
+    {
+        m_QueueTimer = 0;
+        time_t currTime = time(NULL);
+        int32 waitTime;
+        LfgQueueInfo* queue;
+        uint32 dungeonId;
+        uint32 queuedTime;
+        uint8 role;
+        for (LfgQueueInfoMap::const_iterator itQueue = m_QueueInfoMap.begin(); itQueue != m_QueueInfoMap.end(); ++itQueue)
+        {
+            queue = itQueue->second;
+            if (!queue)
+            {
+                sLog.outError("LFGMgr::Update: [" UI64FMTD "] queued with null queue info!", itQueue->first);
+                continue;
+            }
+            dungeonId = (*queue->dungeons.begin());
+            queuedTime = uint32(currTime - queue->joinTime);
+            role = ROLE_NONE;
+            for (LfgRolesMap::const_iterator itPlayer = queue->roles.begin(); itPlayer != queue->roles.end(); ++itPlayer)
+                role |= itPlayer->second;
+
+            waitTime = -1;
+            if (role & ROLE_TANK)
+            {
+                if (role & ROLE_HEALER || role & ROLE_DAMAGE)
+                    waitTime = m_WaitTimeAvg;
+                else
+                    waitTime = m_WaitTimeTank;
+            }
+            else if (role & ROLE_HEALER)
+            {
+                if (role & ROLE_DAMAGE)
+                    waitTime = m_WaitTimeAvg;
+                else
+                    waitTime = m_WaitTimeHealer;
+            }
+            else if (role & ROLE_DAMAGE)
+                waitTime = m_WaitTimeDps;
+
+            for (LfgRolesMap::const_iterator itPlayer = queue->roles.begin(); itPlayer != queue->roles.end(); ++itPlayer)
+                if (Player* plr = sObjectMgr.GetPlayerByLowGUID(itPlayer->first))
+                    plr->GetSession()->SendLfgQueueStatus(dungeonId, waitTime, m_WaitTimeAvg, m_WaitTimeTank, m_WaitTimeHealer, m_WaitTimeDps, queuedTime, queue->tanks, queue->healers, queue->dps);
+        }
+    }
+    else
+        m_QueueTimer += diff;
+    m_update = true;
+}
+
+/// <summary>
+/// Add a guid to new queue, checks consistency
+/// </summary>
+/// <param name="uint64">Player or group guid</param>
+void LFGMgr::AddGuidToNewQueue(uint64 guid)
+{
+    // Consistency check
+    LfgGuidList::iterator it = std::find(m_newToQueue.begin(), m_newToQueue.end(), guid);
+
+    if (it != m_newToQueue.end())
+    {
+        sLog.outError("LFGMgr::AddGuidToNewQueue: [" UI64FMTD "] being added to queue and it was already added. ignoring", guid);
+        return;
+    }
+
+    it = std::find(m_currentQueue.begin(), m_currentQueue.end(), guid);
+    if (it != m_currentQueue.end())
+    {
+        sLog.outError("LFGMgr::AddGuidToNewQueue: [" UI64FMTD "] being added to queue and already in current queue (removing to readd)", guid);
+        m_currentQueue.erase(it);
+    }
+
+    // Add to queue
+    m_newToQueue.push_back(guid);
+    sLog.outDebug("LFGMgr::AddGuidToNewQueue: [" UI64FMTD "] added to m_newToQueue (size: %u)", guid, uint32(m_newToQueue.size()));
+}
+
+/// <summary>
+/// Creates a QueueInfo and adds it to the queue. Tries to match a group before joining.
+/// </summary>
+/// <param name="uint64">Player or group guid</param>
+/// <param name="LfgRolesMap*">Player roles</param>
+/// <param name="LfgDungeonSet*">Selected dungeons</param>
+void LFGMgr::AddToQueue(uint64 guid, LfgRolesMap* roles, LfgDungeonSet* dungeons)
+{
+    if (!roles || !roles->size())
+    {
+        sLog.outError("LFGMgr::AddToQueue: [" UI64FMTD "] has no roles", guid);
+        return;
+    }
+
+    if (!dungeons || !dungeons->size())
+    {
+        sLog.outError("LFGMgr::AddToQueue: [" UI64FMTD "] has no dungeons", guid);
+        return;
+    }
+
+    LfgQueueInfo* pqInfo = new LfgQueueInfo();
+    pqInfo->joinTime = time_t(time(NULL));
+    for (LfgRolesMap::const_iterator it = roles->begin(); it != roles->end(); ++it)
+    {
+        if (pqInfo->tanks && it->second & ROLE_TANK)
+            --pqInfo->tanks;
+        else if (pqInfo->healers && it->second & ROLE_HEALER)
+            --pqInfo->healers;
+        else
+            --pqInfo->dps;
+    }
+    for (LfgRolesMap::const_iterator itRoles = roles->begin(); itRoles != roles->end(); ++itRoles)
+        pqInfo->roles[itRoles->first] = itRoles->second;
+
+    for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
+        pqInfo->dungeons.insert(*it);
+
+    sLog.outDebug("LFGMgr::AddToQueue: [" UI64FMTD "] joining with %u members", guid, uint32(pqInfo->roles.size()));
+    m_QueueInfoMap[guid] = pqInfo;
+    AddGuidToNewQueue(guid);
+}
+
+/// <summary>
+/// Removes the player/group from all queues
+/// </summary>
+/// <param name="uint64">Player or group guid</param>
+/// <returns>bool</returns>
+bool LFGMgr::RemoveFromQueue(uint64 guid)
+{
+    bool ret = false;
+    uint32 before = m_QueueInfoMap.size();
+
+    m_currentQueue.remove(guid);
+    m_newToQueue.remove(guid);
+    RemoveFromCompatibles(guid);
+
+    LfgQueueInfoMap::iterator it = m_QueueInfoMap.find(guid);
+    if (it != m_QueueInfoMap.end())
+    {
+        delete it->second;
+        m_QueueInfoMap.erase(it);
+        ret = true;
+    }
+    sLog.outDebug("LFGMgr::RemoveFromQueue: [" UI64FMTD "] %s - Queue(%u)", guid,
+        before != m_QueueInfoMap.size() ? "Removed" : "Not in queue", uint32(m_QueueInfoMap.size()));
+    return ret;
+}
+
+/// <summary>
+/// Adds the player/group to lfg queue
+/// </summary>
+/// <param name="Player*">Player</param>
+void LFGMgr::Join(Player* plr)
+{
+    LfgDungeonSet* dungeons = NULL;
+    Group* grp = plr->GetGroup();
+
+    if (grp && grp->GetLeaderGUID() != plr->GetGUID())
+        return;
+
+    uint64 guid = grp ? grp->GetGUID() : plr->GetGUID();
+
+    LfgJoinResult result = LFG_JOIN_OK;
+    // Previous checks before joining
+    LfgQueueInfoMap::iterator itQueue = m_QueueInfoMap.find(guid);
+    if (itQueue != m_QueueInfoMap.end())
+    {
+        time_t now = time_t(time(NULL));
+        time_t joinTime = itQueue->second->joinTime;
+        uint32 diff = uint32(now - joinTime);
+        sLog.outError("LFGMgr::Join: [" UI64FMTD "] trying to join but is already in queue! diff %u (" UI64FMTD " - " UI64FMTD ")", guid, diff, uint64(now), uint64(joinTime));
+        Leave(plr, grp);
+        result = LFG_JOIN_INTERNAL_ERROR;
+    }
+    else if (plr->InBattleground() || plr->InArena() || plr->InBattlegroundQueue())
+        result = LFG_JOIN_USING_BG_SYSTEM;
+    else if (plr->HasAura(LFG_SPELL_DUNGEON_DESERTER))
+        result = LFG_JOIN_DESERTER;
+    else if (plr->HasAura(LFG_SPELL_DUNGEON_COOLDOWN))
+        result = LFG_JOIN_RANDOM_COOLDOWN;
+    else
+    {
+        dungeons = plr->GetLfgDungeons();
+        if (!dungeons || !dungeons->size())
+            result = LFG_JOIN_NOT_MEET_REQS;
+        else // Check if all dungeons are valid
+            for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
+            {
+                if (!GetDungeonGroupType(*it))
+                {
+                    result = LFG_JOIN_DUNGEON_INVALID;
+                    break;
+                }
+            }
+    }
+
+    // Group checks
+    if (grp && result == LFG_JOIN_OK)
+    {
+        if (grp->GetMembersCount() > MAXGROUPSIZE)
+            result = LFG_JOIN_TOO_MUCH_MEMBERS;
+        else
+        {
+            Player* plrg;
+            uint8 memberCount = 0;
+            for (GroupReference* itr = grp->GetFirstMember(); itr != NULL && result == LFG_JOIN_OK; itr = itr->next())
+            {
+                plrg = itr->getSource();
+                if (plrg)
+                {
+                    if (plrg->HasAura(LFG_SPELL_DUNGEON_DESERTER))
+                        result = LFG_JOIN_PARTY_DESERTER;
+                    else if (plrg->HasAura(LFG_SPELL_DUNGEON_COOLDOWN))
+                        result = LFG_JOIN_PARTY_RANDOM_COOLDOWN;
+                    ++memberCount;
+                }
+            }
+            if (memberCount != grp->GetMembersCount())
+                result = LFG_JOIN_DISCONNECTED;
+        }
+    }
+
+    if (result != LFG_JOIN_OK)                               // Someone can't join. Clear all stuf
+    {
+        sLog.outDebug("LFGMgr::Join: [" UI64FMTD "] joining with %u members. result: %u", guid, grp ? grp->GetMembersCount() : 1, result);
+        plr->GetLfgDungeons()->clear();
+        plr->SetLfgRoles(ROLE_NONE);
+        if (grp && !grp->isLFGGroup())
+            plr->SetLfgState(LFG_STATE_NONE);
+        plr->GetSession()->SendLfgJoinResult(result);
+        plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_ROLECHECK_FAILED);
+        return;
+    }
+
+    if (grp)
+    {
+        Player* plrg = NULL;
+        for (GroupReference* itr = plr->GetGroup()->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            plrg = itr->getSource();                         // Not null, checked earlier
+            plrg->SetLfgState(LFG_STATE_LFG);
+            if (plrg != plr)
+            {
+                dungeons = plrg->GetLfgDungeons();
+                dungeons->clear();
+                for (LfgDungeonSet::const_iterator itDungeon = plr->GetLfgDungeons()->begin(); itDungeon != plr->GetLfgDungeons()->end(); ++itDungeon)
+                    dungeons->insert(*itDungeon);
+            }
+            plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_JOIN_PROPOSAL);
+        }
+        UpdateRoleCheck(grp, plr);
+    }
+    else
+    {
+        plr->SetLfgState(LFG_STATE_LFG);
+        LfgRolesMap roles;
+        roles[plr->GetGUIDLow()] = plr->GetLfgRoles();
+
+        // Expand random dungeons
+        LfgLockStatusMap* playersLockMap = NULL;
+        if (plr->GetLfgDungeons()->size() == 1 && isRandomDungeon(*plr->GetLfgDungeons()->begin()))
+        {
+            PlayerSet players;
+            players.insert(plr);
+            dungeons = GetDungeonsByRandom(*plr->GetLfgDungeons()->begin());
+            playersLockMap = CheckCompatibleDungeons(dungeons, &players);
+            if (dungeons && !dungeons->size())
+            {
+                delete dungeons;
+                dungeons = NULL;
+            }
+        }
+        else
+            dungeons = plr->GetLfgDungeons();
+
+        if (!dungeons || !dungeons->size())
+            plr->GetSession()->SendLfgJoinResult(LFG_JOIN_NOT_MEET_REQS, 0, playersLockMap);
+        else
+        {
+            plr->GetSession()->SendLfgJoinResult(LFG_JOIN_OK, 0);
+            plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_JOIN_PROPOSAL);
+            AddToQueue(plr->GetGUID(), &roles, dungeons);
+        }
+        roles.clear();
+    }
+    std::string dungeonsstr = ConcatenateDungeons(dungeons);
+    sLog.outDebug("LFGMgr::Join: [" UI64FMTD "] joined with %u members. dungeons: %s", guid, grp ? grp->GetMembersCount() : 1, dungeonsstr.c_str());
+}
+
+/// <summary>
+/// Leave the lfg queue
+/// </summary>
+/// <param name="Player*">Player (could be NULL)</param>
+/// <param name="Group*">Group (could be NULL)</param>
+void LFGMgr::Leave(Player* plr, Group* grp /* = NULL*/)
+{
+    if ((plr && (!plr->GetLfgUpdate() || !plr->isUsingLfg())) || !sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
+        return;
+
+    uint64 guid = grp ? grp->GetGUID() : plr ? plr->GetGUID() : 0;
+    sLog.outDebug("LFGMgr::Leave: [" UI64FMTD "]", guid);
+   
+    if (!guid)
+        return;
+
+    // Remove from Role Checks
+    if (grp)
+    {
+        grp->SetLfgQueued(false);
+        LfgRoleCheckMap::const_iterator itRoleCheck = m_RoleChecks.find(GUID_LOPART(guid));
+        if (itRoleCheck != m_RoleChecks.end())
+        {
+            UpdateRoleCheck(grp);                            // No player to update role = LFG_ROLECHECK_ABORTED
+            return;
+        }
+    }
+
+    // Remove from Proposals
+    bool proposalFound = false;
+    LfgProposalMap::iterator it = m_Proposals.begin();
+    while (it != m_Proposals.end() && !proposalFound)
+    {
+        // Mark the player/leader of group who left as didn't accept the proposal
+        for (LfgProposalPlayerMap::iterator itPlayer = it->second->players.begin(); itPlayer != it->second->players.end(); ++itPlayer)
+        {
+            if ((plr && itPlayer->first == plr->GetGUIDLow()) || (grp && itPlayer->first == GUID_LOPART(grp->GetLeaderGUID())))
+            {
+                itPlayer->second->accept = LFG_ANSWER_DENY;
+                proposalFound = true;
+            }
+        }
+        if (!proposalFound)
+            ++it;
+    }
+
+    // Remove from queue - if proposal is found, RemoveProposal will call RemoveFromQueue
+    if (proposalFound)
+        RemoveProposal(it, LFG_UPDATETYPE_PROPOSAL_DECLINED);
+    else
+        RemoveFromQueue(guid);
+
+    if (grp)
+    {
+        for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+            if (Player* plrg = itr->getSource())
+            {
+                plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
+                plrg->GetLfgDungeons()->clear();
+                plrg->SetLfgRoles(ROLE_NONE);
+                plrg->SetLfgState(LFG_STATE_NONE);
+            }
+    }
+    else
+    {
+        plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
+        plr->GetLfgDungeons()->clear();
+        plr->SetLfgRoles(ROLE_NONE);
+        plr->SetLfgState(LFG_STATE_NONE);
+        plr->RemoveAurasDueToSpell(LFG_SPELL_LUCK_OF_THE_DRAW);
+    }
+}
+
+/// <summary>
+/// Given a Lfg group checks if leader needs to be show the popup to select more players
+/// </summary>
+/// <param name="Group*">Group than needs new players</param>
+void LFGMgr::OfferContinue(Group* grp)
+{
+    if (!sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
+        return;
+
+    ASSERT(grp);
+    if (Player* leader = sObjectMgr.GetPlayer(grp->GetLeaderGUID()))
+        leader->GetSession()->SendLfgOfferContinue(grp->GetLfgDungeonEntry(false));
+}
+
+/// <summary>
+/// Check the queue to try to match groups. Returns all the possible matches
+/// </summary>
+/// <param name="LfgGuidList &">Guids we trying to match with the rest of groups</param>
+/// <param name="LfgGuidList">All guids in queue</param>
+/// <returns>LfgProposal*</returns>
+LfgProposal* LFGMgr::FindNewGroups(LfgGuidList check, LfgGuidList all)
+{
+    sLog.outDebug("LFGMgr::FindNewGroup: (%s) - all(%s)", ConcatenateGuids(check).c_str(), ConcatenateGuids(all).c_str());
+
+    LfgProposal* pProposal = NULL;
+    if (!check.size() || check.size() > MAXGROUPSIZE || !CheckCompatibility(check, pProposal))
+        return NULL;
+
+    // Try to match with queued groups
+    while (!pProposal && all.size() > 0)
+    {
+        check.push_back(all.front());        
+        all.pop_front();
+        pProposal = FindNewGroups(check, all);
+        check.pop_back();
+    }
+    return pProposal;
+}
+
+/// <summary>
+/// Check compatibilities between groups.
+/// </summary>
+/// <param name="LfgGuidList">Guids we checking compatibility</param>
+/// <returns>bool</returns>
+/// <param name="LfgProposal*&">Proposals found.</param>
+bool LFGMgr::CheckCompatibility(LfgGuidList check, LfgProposal*& pProposal)
+{
+    if (pProposal)                                           // Do not check anything if we already have a proposal
+        return false;
+
+    std::string strGuids = ConcatenateGuids(check);
+
+    if (check.size() > MAXGROUPSIZE || !check.size())
+    {
+        sLog.outDebug("LFGMgr::CheckCompatibility: (%s): Size wrong - Not compatibles", strGuids.c_str());
+        return false;
+    }
+
+    if (check.size() == 1 && IS_PLAYER_GUID(check.front())) // Player joining dungeon... compatible
+        return true;
+
+    // Previously cached?
+    LfgAnswer answer = GetCompatibles(strGuids);
+    if (answer != LFG_ANSWER_PENDING)
+    {
+        sLog.outDebug("LFGMgr::CheckCompatibility: (%s) compatibles (cached): %d", strGuids.c_str(), answer);
+        return bool(answer);
+    }
+   
+    // Check all but new compatiblitity
+    if (check.size() > 2)
+    {
+        uint64 frontGuid = check.front();
+        check.pop_front();
+
+        // Check all-but-new compatibilities (New,A,B,C,D) --> check(A,B,C,D)
+        if (!CheckCompatibility(check, pProposal))          // Group not compatible
+        {
+            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) not compatibles (%s not compatibles)", strGuids.c_str(), ConcatenateGuids(check).c_str());
+            SetCompatibles(strGuids, false);
+            return false;
+        }
+        check.push_front(frontGuid);
+        // all-but-new compatibles, now check with new
+    }
+
+    uint8 numPlayers = 0;
+    uint8 numLfgGroups = 0;
+    uint32 groupLowGuid = 0;
+    LfgQueueInfoMap pqInfoMap;
+    LfgQueueInfoMap::iterator itQueue;
+    for (LfgGuidList::const_iterator it = check.begin(); it != check.end() && numLfgGroups < 2 && numPlayers <= MAXGROUPSIZE; ++it)
+    {
+        itQueue = m_QueueInfoMap.find(*it);
+        if (itQueue == m_QueueInfoMap.end())
+        {
+            sLog.outError("LFGMgr::CheckCompatibility: [" UI64FMTD "] is not queued but listed as queued!", (*it));
+            RemoveFromQueue(*it);
+            return false;
+        }
+        pqInfoMap[*it] = itQueue->second;
+        numPlayers += itQueue->second->roles.size();
+
+        if (IS_GROUP(*it))
+        {
+            uint32 lowGuid = GUID_LOPART(*it);
+            if (Group* grp = sObjectMgr.GetGroupByGUID(lowGuid))
+                if (grp->isLFGGroup())
+                {
+                    if (!numLfgGroups)
+                        groupLowGuid = lowGuid;
+                    ++numLfgGroups;
+                }
+        }
+    }
+
+    if (check.size() == 1)
+    {
+        if (numPlayers != MAXGROUPSIZE)                      // Single group with less than MAXGROUPSIZE - Compatibles
+            return true;
+    }
+
+    // Do not match - groups already in a lfgDungeon or too much players
+    if (numLfgGroups > 1 || numPlayers > MAXGROUPSIZE)
+    {
+        pqInfoMap.clear();
+        SetCompatibles(strGuids, false);
+        if (numLfgGroups > 1)
+            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) More than one Lfggroup (%u)", strGuids.c_str(), numLfgGroups);
+        else
+            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Too much players (%u)", strGuids.c_str(), numPlayers);
+        return false;
+    }
+
+    // ----- Player checks -----
+    LfgRolesMap rolesMap;
+    uint32 newLeaderLowGuid = 0;
+    for (LfgQueueInfoMap::const_iterator it = pqInfoMap.begin(); it != pqInfoMap.end(); ++it)
+    {
+        for (LfgRolesMap::const_iterator itRoles = it->second->roles.begin(); itRoles != it->second->roles.end(); ++itRoles)
+        {
+            // Assign new leader
+            if (itRoles->second & ROLE_LEADER && (!newLeaderLowGuid || urand(0, 1)))
+                newLeaderLowGuid = itRoles->first;
+            if (rolesMap[itRoles->first])                    // Player already added!
+            {
+                // Find the other guid
+                uint64 guid1 = it->first;
+                uint64 guid2 = 0;
+                for (LfgQueueInfoMap::const_iterator it2 = pqInfoMap.begin(); it2 != it && !guid2; ++it2)
+                {
+                    if (it2->second->roles.find(itRoles->first) != it2->second->roles.end())
+                        guid2 = it2->first;
+                }
+                uint64 playerguid;
+
+                // store in guid2 the obsolete group
+                if (pqInfoMap[guid2]->joinTime > it->second->joinTime)
+                {
+                    playerguid = guid2;
+                    guid2 = guid1;
+                    guid1 = playerguid;
+                }
+                playerguid = MAKE_NEW_GUID(itRoles->first, 0, HIGHGUID_PLAYER);
+                sLog.outError("LFGMgr::CheckCompatibility: check(%s) player [" UI64FMTD "] in queue with [" UI64FMTD "] and OBSOLETE! [" UI64FMTD "]",
+                    strGuids.c_str(), playerguid, guid1, guid2);
+            }
+            rolesMap[itRoles->first] = itRoles->second;
+        }
+    }
+
+    if (rolesMap.size() != numPlayers)
+    {
+        pqInfoMap.clear();
+        rolesMap.clear();
+        return false;
+    }
+
+    Player* plr;
+    PlayerSet players;
+    for (LfgRolesMap::const_iterator it = rolesMap.begin(); it != rolesMap.end(); ++it)
+    {
+        plr = sObjectMgr.GetPlayerByLowGUID(it->first);
+        if (!plr)
+            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Warning! %u offline! Marking as not compatibles!", strGuids.c_str(), it->first);
+        else
+        {
+            for (PlayerSet::const_iterator itPlayer = players.begin(); itPlayer != players.end() && plr; ++itPlayer)
+            {
+                // Do not form a group with ignoring candidates
+                if (plr->GetSocial()->HasIgnore((*itPlayer)->GetGUIDLow()) || (*itPlayer)->GetSocial()->HasIgnore(plr->GetGUIDLow()))
+                {
+                    sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Players [" UI64FMTD "] and [" UI64FMTD "] ignoring", strGuids.c_str(), (*itPlayer)->GetGUID(), plr->GetGUID());
+                    plr = NULL;
+                }
+                // neither with diferent faction if it's not a mixed faction server
+                else if (plr->GetTeam() != (*itPlayer)->GetTeam() && !sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP))
+                {
+                    sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Players [" UI64FMTD "] and [" UI64FMTD "] are from diff sides", strGuids.c_str(), (*itPlayer)->GetGUID(), plr->GetGUID());
+                    plr = NULL;
+                }
+            }
+            if (plr)
+                players.insert(plr);
+        }
+    }
+
+    // if we dont have the same ammount of players then we have self ignoring candidates or different faction groups
+    // otherwise check if roles are compatible
+    if (players.size() != numPlayers || !CheckGroupRoles(rolesMap))
+    {
+        if (players.size() == numPlayers)
+            sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Roles not compatible", strGuids.c_str());
+        pqInfoMap.clear();
+        rolesMap.clear();
+        players.clear();
+        SetCompatibles(strGuids, false);
+        return false;
+    }
+
+    // ----- Selected Dungeon checks -----
+    // Check if there are any compatible dungeon from the selected dungeons
+    LfgDungeonMap dungeonMap;
+    for (LfgQueueInfoMap::const_iterator it = pqInfoMap.begin(); it != pqInfoMap.end(); ++it)
+        dungeonMap[it->first] = &it->second->dungeons;
+
+    LfgDungeonSet* compatibleDungeons = CheckCompatibleDungeons(&dungeonMap, &players);
+    dungeonMap.clear();
+    pqInfoMap.clear();
+    if (!compatibleDungeons || !compatibleDungeons->size())
+    {
+        if (compatibleDungeons)
+            delete compatibleDungeons;
+        players.clear();
+        rolesMap.clear();
+        SetCompatibles(strGuids, false);
+        return false;
+    }
+    SetCompatibles(strGuids, true);
+
+    // ----- Group is compatible, if we have MAXGROUPSIZE members then match is found
+    if (numPlayers != MAXGROUPSIZE)
+    {
+        players.clear();
+        rolesMap.clear();
+        sLog.outDebug("LFGMgr::CheckCompatibility: (%s) Compatibles but not match. Players(%u)", strGuids.c_str(), numPlayers);
+        return true;
+    }
+    sLog.outDebug("LFGMgr::CheckCompatibility: (%s) MATCH! Group formed", strGuids.c_str());
+
+    // GROUP FORMED!
+    // TODO - Improve algorithm to select proper group based on Item Level
+    // Do not match bad tank and bad healer on same group
+
+    // Select a random dungeon from the compatible list
+    // TODO - Select the dungeon based on group item Level, not just random
+    LfgDungeonSet::iterator itDungeon = compatibleDungeons->begin();
+    uint32 selectedDungeon = urand(0, compatibleDungeons->size() - 1);
+    while (selectedDungeon > 0)
+    {
+        ++itDungeon;
+        --selectedDungeon;
+    }
+    selectedDungeon = (*itDungeon);
+    compatibleDungeons->clear();
+    delete compatibleDungeons;
+
+    // Create a new proposal
+    pProposal = new LfgProposal(selectedDungeon);
+    pProposal->cancelTime = time_t(time(NULL)) + LFG_TIME_PROPOSAL;
+    pProposal->queues = check;
+    pProposal->groupLowGuid = groupLowGuid;
+
+    // Assign new roles to players and assign new leader
+    LfgProposalPlayer* ppPlayer;
+    uint32 lowGuid;
+    PlayerSet::const_iterator itPlayers = players.begin();
+    if (!newLeaderLowGuid)
+    {
+        uint8 pos = urand(0, players.size() - 1);
+        for (uint8 i = 0; i < pos; ++i)
+            ++itPlayers;
+        newLeaderLowGuid = (*itPlayers)->GetGUIDLow();
+    }
+    pProposal->leaderLowGuid = newLeaderLowGuid;
+
+    uint8 numAccept = 0;
+    for (itPlayers = players.begin(); itPlayers != players.end(); ++itPlayers)
+    {
+        lowGuid = (*itPlayers)->GetGUIDLow();
+        ppPlayer = new LfgProposalPlayer();
+        Group* grp = (*itPlayers)->GetGroup();
+        if (grp)
+        {
+            ppPlayer->groupLowGuid = grp->GetLowGUID();
+            if (grp->GetLfgDungeonEntry() == selectedDungeon && ppPlayer->groupLowGuid == pProposal->groupLowGuid) // Player from existing group, autoaccept
+            {
+                ppPlayer->accept = LFG_ANSWER_AGREE;
+                ++numAccept;
+            }
+        }
+        ppPlayer->role = rolesMap[lowGuid];
+        pProposal->players[lowGuid] = ppPlayer;
+    }
+    if (numAccept == MAXGROUPSIZE)
+        pProposal->state = LFG_PROPOSAL_SUCCESS;
+
+    rolesMap.clear();
+    players.clear();
+    return true;
+}
+
+/// <summary>
+/// Update the Role check info with the player selected role.
+/// </summary>
+/// <param name="Group*">Group</param>
+/// <param name="Player*">Player (optional, default NULL)</param>
+void LFGMgr::UpdateRoleCheck(Group* grp, Player* plr /* = NULL*/)
+{
+    if (!grp)
+        return;
+
+    uint32 rolecheckId = grp->GetLowGUID();
+    LfgRoleCheck* pRoleCheck = NULL;
+    LfgRolesMap check_roles;
+    LfgRoleCheckMap::iterator itRoleCheck = m_RoleChecks.find(rolecheckId);
+    bool newRoleCheck = itRoleCheck == m_RoleChecks.end();
+    if (newRoleCheck)
+    {
+        if (!plr || grp->GetLeaderGUID() != plr->GetGUID())
+            return;
+
+        LfgDungeonSet* dungeons = plr->GetLfgDungeons();
+        pRoleCheck = new LfgRoleCheck();
+        pRoleCheck->cancelTime = time_t(time(NULL)) + LFG_TIME_ROLECHECK;
+        pRoleCheck->result = LFG_ROLECHECK_INITIALITING;
+        pRoleCheck->leader = plr->GetGUIDLow();
+
+        for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+            if (Player* plrg = itr->getSource())
+                pRoleCheck->roles[plrg->GetGUIDLow()] = 0;
+
+        // Check if it's offer continue or trying to find a new instance after a random assigned (Join Random + LfgGroup)
+        if (grp->isLFGGroup() && dungeons->size() == 1 && isRandomDungeon(*dungeons->begin()) && grp->GetLfgDungeonEntry())
+            pRoleCheck->dungeons.insert(grp->GetLfgDungeonEntry());
+        else
+            for (LfgDungeonSet::const_iterator itDungeon = dungeons->begin(); itDungeon != dungeons->end(); ++itDungeon)
+                pRoleCheck->dungeons.insert(*itDungeon);
+    }
+    else
+        pRoleCheck = itRoleCheck->second;
+
+    LfgLockStatusMap* playersLockMap = NULL;
+    if (plr)
+    {
+        // Player selected no role.
+        if (plr->GetLfgRoles() < ROLE_TANK)
+            pRoleCheck->result = LFG_ROLECHECK_NO_ROLE;
+        else
+        {
+            // Check if all players have selected a role
+            pRoleCheck->roles[plr->GetGUIDLow()] = plr->GetLfgRoles();
+            uint8 size = 0;
+            for (LfgRolesMap::const_iterator itRoles = pRoleCheck->roles.begin(); itRoles != pRoleCheck->roles.end() && itRoles->second != ROLE_NONE; ++itRoles)
+                ++size;
+
+            if (pRoleCheck->roles.size() == size)
+            {
+                // use temporal var to check roles, CheckGroupRoles modifies the roles
+                check_roles = pRoleCheck->roles;
+                if (!CheckGroupRoles(check_roles))           // Group is not posible
+                    pRoleCheck->result = LFG_ROLECHECK_WRONG_ROLES;
+                else
+                {
+                    // Check if we can find a dungeon for that group
+                    pRoleCheck->result = LFG_ROLECHECK_FINISHED;
+                    if (pRoleCheck->dungeons.size() == 1 && isRandomDungeon(*pRoleCheck->dungeons.begin()))
+                    {
+                        // Random dungeon - select the compatible dungeons
+                        LfgDungeonSet* dungeons = GetDungeonsByRandom(*pRoleCheck->dungeons.begin());
+                        PlayerSet players;
+                        for (LfgRolesMap::const_iterator it = pRoleCheck->roles.begin(); it != pRoleCheck->roles.end(); ++it)
+                            if (Player* plr = sObjectMgr.GetPlayerByLowGUID(it->first))
+                                players.insert(plr);
+
+                        playersLockMap = CheckCompatibleDungeons(dungeons, &players);
+                        std::string dungeonstr = ConcatenateDungeons(dungeons);
+                        sLog.outDebug("LFGMgr::UpdateRoleCheck: [" UI64FMTD "] done. Dungeons: %s", plr->GetGUID(), dungeonstr.c_str());
+
+                        pRoleCheck->dungeons.clear();
+                        if (dungeons)
+                        {
+                            if (dungeons->empty())
+                                delete dungeons;
+                            else
+                            {
+                                for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
+                                    pRoleCheck->dungeons.insert(*it);
+                                if (playersLockMap)
+                                {
+                                    for (LfgLockStatusMap::iterator itMap = playersLockMap->begin(); itMap != playersLockMap->end(); ++itMap)
+                                    {
+                                        itMap->second->clear();
+                                        delete itMap->second;
+                                    }
+                                    playersLockMap->clear();
+                                    delete playersLockMap;
+                                    playersLockMap = NULL;
+                                }
+                            }
+                        }
+                    }
+                    else
+                        playersLockMap = GetPartyLockStatusDungeons(plr, &pRoleCheck->dungeons);
+                }
+            }
+        }
+    }
+    else
+        pRoleCheck->result = LFG_ROLECHECK_ABORTED;
+
+    WorldSession* session;
+    Player* plrg = NULL;
+    for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        plrg = itr->getSource();
+        if (!plrg)
+            continue;
+
+        session = plrg->GetSession();
+        if (!newRoleCheck && plr)
+            session->SendLfgRoleChosen(plr->GetGUID(), plr->GetLfgRoles());
+        session->SendLfgRoleCheckUpdate(pRoleCheck);
+
+        switch(pRoleCheck->result)
+        {
+        case LFG_ROLECHECK_INITIALITING:
+            continue;
+        case LFG_ROLECHECK_FINISHED:
+            if (!playersLockMap)
+                session->SendLfgUpdateParty(LFG_UPDATETYPE_ADDED_TO_QUEUE);
+            else
+            {
+                if (grp->GetLeaderGUID() == plrg->GetGUID())
+                    session->SendLfgJoinResult(LFG_JOIN_PARTY_NOT_MEET_REQS, 0, playersLockMap);
+                session->SendLfgUpdateParty(LFG_UPDATETYPE_ROLECHECK_FAILED);
+                plrg->GetLfgDungeons()->clear();
+                plrg->SetLfgRoles(ROLE_NONE);
+                if (!grp->isLFGGroup())
+                    plrg->SetLfgState(LFG_STATE_NONE);
+            }
+            break;
+        default:
+            if (grp->GetLeaderGUID() == plrg->GetGUID())
+                session->SendLfgJoinResult(LFG_JOIN_FAILED, pRoleCheck->result);
+            session->SendLfgUpdateParty(LFG_UPDATETYPE_ROLECHECK_FAILED);
+            plrg->GetLfgDungeons()->clear();
+            if (grp->isLFGGroup())
+                plrg->SetLfgRoles(ROLE_NONE);
+            plrg->SetLfgState(LFG_STATE_NONE);
+            break;
+        }
+    }
+
+    if (pRoleCheck->result == LFG_ROLECHECK_FINISHED && pRoleCheck->dungeons.size())
+    {
+        grp->SetLfgQueued(true);
+        AddToQueue(grp->GetGUID(), &pRoleCheck->roles, &pRoleCheck->dungeons);
+    }
+
+    if (pRoleCheck->result != LFG_ROLECHECK_INITIALITING)
+    {
+        pRoleCheck->dungeons.clear();
+        pRoleCheck->roles.clear();
+        delete pRoleCheck;
+        if (!newRoleCheck)
+            m_RoleChecks.erase(itRoleCheck);
+    }
+    else if (newRoleCheck)
+        m_RoleChecks[rolecheckId] = pRoleCheck;
+}
+
+/// <summary>
+/// Remove from cached compatible dungeons any entry that contains the given guid
+/// </summary>
+/// <param name="uint64">guid to remove from any list</param>
+void LFGMgr::RemoveFromCompatibles(uint64 guid)
+{
+    LfgGuidList lista;
+    lista.push_back(guid);
+    std::string strGuid = ConcatenateGuids(lista);
+    lista.clear();
+
+    sLog.outDebug("LFGMgr::RemoveFromCompatibles: Removing [" UI64FMTD "]", guid);
+    LfgCompatibleMap::iterator it;
+    for (LfgCompatibleMap::iterator itNext = m_CompatibleMap.begin(); itNext != m_CompatibleMap.end();)
+    {
+        it = itNext++;
+        if (it->first.find(strGuid) != std::string::npos)    // Found, remove it
+            m_CompatibleMap.erase(it);
+    }
+}
+
+/// <summary>
+/// Set the compatibility of a list of guids
+/// </summary>
+/// <param name="std::string">list of guids concatenated by |</param>
+/// <param name="bool">compatibles or not</param>
+void LFGMgr::SetCompatibles(std::string key, bool compatibles)
+{
+    m_CompatibleMap[key] = LfgAnswer(compatibles);
+}
+
+/// <summary>
+/// Get the compatible dungeons between two groups from cache
+/// </summary>
+/// <param name="std::string">list of guids concatenated by |</param>
+/// <returns>LfgAnswer,
+LfgAnswer LFGMgr::GetCompatibles(std::string key)
+{
+    LfgAnswer answer = LFG_ANSWER_PENDING;
+    LfgCompatibleMap::iterator it = m_CompatibleMap.find(key);
+    if (it != m_CompatibleMap.end())
+        answer = it->second;
+
+    return answer;
+}
+
+/// <summary>
+/// Given a list of dungeons remove the dungeons with restrictions.
+/// </summary>
+/// <param name="LfgDungeonSet*">dungeons to check</param>
+/// <param name="PlayerSet*">Players to check restrictions</param>
+/// <param name="LfgLockStatusMap*">Used to return the lockStatusMap</param>
+/// <param name="boot">Return lockMap or discard it</param>
+/// <returns>LfgLockStatusMap*</returns>
+LfgLockStatusMap* LFGMgr::CheckCompatibleDungeons(LfgDungeonSet* dungeons, PlayerSet* players, bool returnLockMap /* = true */)
+{
+    if (!dungeons)
+        return NULL;
+
+    LfgLockStatusMap* pLockDungeons = GetGroupLockStatusDungeons(players, dungeons, false);
+    if (pLockDungeons) // Found dungeons not compatible, remove them from the set
+    {
+        for (LfgLockStatusMap::const_iterator itLockMap = pLockDungeons->begin(); itLockMap != pLockDungeons->end() && dungeons->size(); ++itLockMap)
+        {
+            for(LfgLockStatusSet::const_iterator itLockSet = itLockMap->second->begin(); itLockSet != itLockMap->second->end(); ++itLockSet)
+            {
+                LfgDungeonSet::iterator itDungeon = dungeons->find((*itLockSet)->dungeon);
+                if (itDungeon != dungeons->end())
+                     dungeons->erase(itDungeon);
+            }
+            if (!returnLockMap)
+            {
+                itLockMap->second->clear();
+                delete itLockMap->second;
+            }
+        }
+        if (!returnLockMap)
+        {
+            pLockDungeons->clear();
+            delete pLockDungeons;
+            return NULL;
+        }
+    }
+    return pLockDungeons;
+}
+
+/// <summary>
+/// Given a list of groups checks the compatible dungeons. If players is not null also check restictions
+/// </summary>
+/// <param name="LfgDungeonMap*">dungeons to check</param>
+/// <param name="PlayerSet*">Players to check restrictions</param>
+/// <returns>LfgDungeonSet*</returns>
+LfgDungeonSet* LFGMgr::CheckCompatibleDungeons(LfgDungeonMap* dungeonsMap, PlayerSet* players)
+{
+    if (!dungeonsMap || dungeonsMap->empty())
+        return NULL;
+
+    LfgDungeonMap::const_iterator itMap = ++dungeonsMap->begin();
+    LfgDungeonSet* compatibleDungeons = new LfgDungeonSet();
+
+    bool compatibleDungeon;
+
+    // Get the first group and compare with the others to select all common dungeons
+    for (LfgDungeonSet::const_iterator itDungeon = dungeonsMap->begin()->second->begin(); itDungeon != dungeonsMap->begin()->second->end(); ++itDungeon)
+    {
+        compatibleDungeon = true;
+        for (LfgDungeonMap::const_iterator it = itMap; it != dungeonsMap->end() && compatibleDungeon; ++it)
+            if (it->second->find(*itDungeon) == it->second->end())
+                compatibleDungeon = false;
+        if (compatibleDungeon)
+            compatibleDungeons->insert(*itDungeon);
+    }
+
+    // if we have players remove restrictions
+    if (players && !players->empty())
+        CheckCompatibleDungeons(compatibleDungeons, players, false);
+
+    // Any compatible dungeon after checking restrictions?
+    if (compatibleDungeons && !compatibleDungeons->size())
+    {
+        delete compatibleDungeons;
+        compatibleDungeons = NULL;
+    }
+    return compatibleDungeons;
+}
+
+/// <summary>
+/// Check if a group can be formed with the given group
+/// </summary>
+/// <param name="LfgRolesMap &">Roles to check</param>
+/// <param name="bool">Used to remove ROLE_LEADER</param>
+/// <returns>bool</returns>
+bool LFGMgr::CheckGroupRoles(LfgRolesMap &groles, bool removeLeaderFlag /*= true*/)
+{
+    if (!groles.size())
+        return false;
+
+    uint8 damage = 0;
+    uint8 tank = 0;
+    uint8 healer = 0;
+
+    if (removeLeaderFlag)
+        for (LfgRolesMap::iterator it = groles.begin(); it != groles.end(); ++it)
+            it->second &= ~ROLE_LEADER;
+
+    for (LfgRolesMap::iterator it = groles.begin(); it != groles.end(); ++it)
+    {
+        switch(it->second)
+        {
+        case ROLE_NONE:
+            return false;
+        case ROLE_TANK:
+            if (tank == LFG_TANKS_NEEDED)
+                return false;
+            tank++;
+            break;
+        case ROLE_HEALER:
+            if (healer == LFG_HEALERS_NEEDED)
+                return false;
+            healer++;
+            break;
+        case ROLE_DAMAGE:
+            if (damage == LFG_DPS_NEEDED)
+                return false;
+            damage++;
+            break;
+        default:
+            if (it->second & ROLE_TANK)
+            {
+                it->second -= ROLE_TANK;
+                if (CheckGroupRoles(groles, false))
+                    return true;
+                it->second += ROLE_TANK;
+            }
+
+            if (it->second & ROLE_HEALER)
+            {
+                it->second -= ROLE_HEALER;
+                if (CheckGroupRoles(groles, false))
+                    return true;
+                it->second += ROLE_HEALER;
+            }
+
+            if (it->second & ROLE_DAMAGE)
+            {
+                it->second -= ROLE_DAMAGE;
+                return CheckGroupRoles(groles, false);
+            }
+            break;
+        }
+    }
+    return true;
+}
+
+/// <summary>
+/// Update Proposal info with player answer
+/// </summary>
+/// <param name="uint32">Id of the proposal</param>
+/// <param name="uint32">Player low guid</param>
+/// <param name="bool">Player answer</param>
+void LFGMgr::UpdateProposal(uint32 proposalId, uint32 lowGuid, bool accept)
+{
+    // Check if the proposal exists
+    LfgProposalMap::iterator itProposal = m_Proposals.find(proposalId);
+    if (itProposal == m_Proposals.end())
+        return;
+    LfgProposal* pProposal = itProposal->second;
+
+    // Check if proposal have the current player
+    LfgProposalPlayerMap::iterator itProposalPlayer = pProposal->players.find(lowGuid);
+    if (itProposalPlayer == pProposal->players.end())
+        return;
+    LfgProposalPlayer* ppPlayer = itProposalPlayer->second;
+
+    ppPlayer->accept = LfgAnswer(accept);
+    sLog.outDebug("LFGMgr::UpdateProposal: Player [" UI64FMTD "] of proposal %u selected: %u", MAKE_NEW_GUID(lowGuid, 0, HIGHGUID_PLAYER), proposalId, accept);
+    if (!accept)
+    {
+        RemoveProposal(itProposal, LFG_UPDATETYPE_PROPOSAL_DECLINED);
+        return;
+    }
+
+    LfgPlayerList players;
+    Player* plr;
+
+    // check if all have answered and reorder players (leader first)
+    bool allAnswered = true;
+    for (LfgProposalPlayerMap::const_iterator itPlayers = pProposal->players.begin(); itPlayers != pProposal->players.end(); ++itPlayers)
+    {
+        plr = sObjectMgr.GetPlayerByLowGUID(itPlayers->first);
+
+        if (plr)
+        {
+            if (itPlayers->first == pProposal->leaderLowGuid)
+                players.push_front(plr);
+            else
+                players.push_back(plr);
+        }
+
+        if (itPlayers->second->accept != LFG_ANSWER_AGREE)   // No answer (-1) or not accepted (0)
+            allAnswered = false;
+    }
+
+    if (!allAnswered)
+    {
+        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
+            (*it)->GetSession()->SendUpdateProposal(proposalId, pProposal);
+    }
+    else
+    {
+        bool sendUpdate = pProposal->state != LFG_PROPOSAL_SUCCESS;
+        pProposal->state = LFG_PROPOSAL_SUCCESS;
+        time_t joinTime = time_t(time(NULL));
+        std::map<uint64, int32> waitTimesMap;
+        // Save wait times before redoing groups
+        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
+        {
+            LfgProposalPlayer* pPlayer = pProposal->players[(*it)->GetGUIDLow()];
+            uint32 lowgroupguid = (*it)->GetGroup() ? (*it)->GetGroup()->GetLowGUID() : 0;
+            if (pPlayer->groupLowGuid != lowgroupguid)
+                sLog.outError("LFGMgr::UpdateProposal: [" UI64FMTD "] group mismatch: actual (%u) - queued (%u)", (*it)->GetGUID(), lowgroupguid, pPlayer->groupLowGuid);
+
+            uint64 guid = pPlayer->groupLowGuid ? MAKE_NEW_GUID(pPlayer->groupLowGuid, 0, HIGHGUID_GROUP) : (*it)->GetGUID();
+            LfgQueueInfoMap::iterator itQueue = m_QueueInfoMap.find(guid);
+            if (itQueue == m_QueueInfoMap.end())
+            {
+                sLog.outError("LFGMgr::UpdateProposal: Queue info for guid [" UI64FMTD "] not found!", guid);
+                waitTimesMap[(*it)->GetGUID()] = -1;
+            }
+            else
+                waitTimesMap[(*it)->GetGUID()] = int32(joinTime - itQueue->second->joinTime);
+        }
+
+        // Create a new group (if needed)
+        Group* grp = sObjectMgr.GetGroupByGUID(pProposal->groupLowGuid);
+        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
+        {
+            plr = (*it);
+            if (sendUpdate)
+                plr->GetSession()->SendUpdateProposal(proposalId, pProposal);
+            if (plr->GetGroup())
+            {
+                plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_GROUP_FOUND);
+                plr->SetLfgUpdate(false);
+                if (plr->GetGroup() != grp)
+                {
+                    plr->GetGroup()->SetLfgQueued(false);
+                    plr->RemoveFromGroup();
+                }
+            }
+            else
+            {
+                plr->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_GROUP_FOUND);
+                plr->SetLfgUpdate(false);
+            }
+
+            if (!grp)
+            {
+                grp = new Group();
+                grp->Create(plr->GetGUID(), plr->GetName());
+                grp->ConvertToLFG();
+                sObjectMgr.AddGroup(grp);
+            }
+            else if (plr->GetGroup() != grp)
+            {
+                grp->SetLfgQueued(false);
+                grp->AddMember(plr->GetGUID(), plr->GetName());
+            }
+            plr->SetLfgUpdate(true);
+
+            // Update timers
+            uint8 role = plr->GetLfgRoles();
+            if (role & ROLE_TANK)
+            {
+                if (role & ROLE_HEALER || role & ROLE_DAMAGE)
+                    m_WaitTimeAvg = int32((m_WaitTimeAvg * m_NumWaitTimeAvg + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeAvg);
+                else
+                    m_WaitTimeTank = int32((m_WaitTimeTank * m_NumWaitTimeTank + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeTank);
+            }
+            else if (role & ROLE_HEALER)
+            {
+                if (role & ROLE_DAMAGE)
+                    m_WaitTimeAvg = int32((m_WaitTimeAvg * m_NumWaitTimeAvg + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeAvg);
+                else
+                    m_WaitTimeHealer = int32((m_WaitTimeHealer * m_NumWaitTimeHealer + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeHealer);
+            }
+            else if (role & ROLE_DAMAGE)
+                m_WaitTimeDps = int32((m_WaitTimeDps * m_NumWaitTimeDps + waitTimesMap[plr->GetGUID()]) / ++m_NumWaitTimeDps);
+
+            grp->SetLfgRoles(plr->GetGUID(), pProposal->players[plr->GetGUIDLow()]->role);
+        }
+
+        // Set the dungeon difficulty
+        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(pProposal->dungeonId);
+        ASSERT(dungeon);
+        grp->SetDungeonDifficulty(Difficulty(dungeon->difficulty));
+        grp->SetLfgDungeonEntry(dungeon->Entry());
+        grp->SetLfgStatus(LFG_STATUS_NOT_SAVED);
+        grp->SendUpdate();
+
+        // Remove players/groups from Queue
+        for (LfgGuidList::const_iterator it = pProposal->queues.begin(); it != pProposal->queues.end(); ++it)
+            RemoveFromQueue(*it);
+
+        // Teleport Player
+        for (LfgPlayerList::const_iterator it = players.begin(); it != players.end(); ++it)
+            TeleportPlayer(*it, false);
+
+        for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
+            delete it->second;
+        pProposal->players.clear();
+        pProposal->queues.clear();
+        delete pProposal;
+        m_Proposals.erase(itProposal);
+    }
+    players.clear();
+}
+
+/// <summary>
+/// Remove a proposal from the pool, remove the group that didn't accept (if needed) and readd the other members to the queue
+/// </summary>
+/// <param name="LfgProposalMap::iterator">Proposal to remove</param>
+/// <param name="LfgUpdateType">Type of removal (LFG_UPDATETYPE_PROPOSAL_FAILED, LFG_UPDATETYPE_PROPOSAL_DECLINED)</param>
+void LFGMgr::RemoveProposal(LfgProposalMap::iterator itProposal, LfgUpdateType type)
+{
+    Player* plr;
+    uint64 guid;
+    LfgUpdateType updateType;
+    LfgQueueInfoMap::iterator itQueue;
+    LfgProposal* pProposal = itProposal->second;
+    pProposal->state = LFG_PROPOSAL_FAILED;
+
+    sLog.outDebug("LFGMgr::RemoveProposal: Proposal %u, state FAILED, UpdateType %u", itProposal->first, type);
+    // Mark all people that didn't answered as no accept
+    if (type == LFG_UPDATETYPE_PROPOSAL_FAILED)
+        for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
+            if (it->second->accept != LFG_ANSWER_AGREE)
+                it->second->accept = LFG_ANSWER_DENY;
+
+    // Inform players
+    for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
+    {
+        plr = sObjectMgr.GetPlayerByLowGUID(it->first);
+        if (!plr)
+            continue;
+        guid = it->second->groupLowGuid ? MAKE_NEW_GUID(it->second->groupLowGuid, 0, HIGHGUID_GROUP) : plr->GetGUID();
+
+        plr->GetSession()->SendUpdateProposal(itProposal->first, pProposal);
+        // Remove members that didn't accept
+        if (it->second->accept == LFG_ANSWER_DENY)
+        {
+            updateType = type;
+            plr->GetLfgDungeons()->clear();
+            plr->SetLfgRoles(ROLE_NONE);
+            if (!plr->GetGroup() || !plr->GetGroup()->isLFGGroup())
+                plr->SetLfgState(LFG_STATE_NONE);
+
+            sLog.outDebug("LFGMgr::RemoveProposal: [" UI64FMTD "] didn't accept. Removing from queue and compatible cache", guid);
+            RemoveFromQueue(guid);
+        }
+        else                                                 // Readd to queue
+        {
+            itQueue = m_QueueInfoMap.find(guid);
+            if (itQueue == m_QueueInfoMap.end())             // Can't readd! misssing queue info!
+            {
+                sLog.outError("LFGMgr::RemoveProposal: Imposible to readd [" UI64FMTD "] to queue. Missing queue info!", guid);
+                updateType = LFG_UPDATETYPE_REMOVED_FROM_QUEUE;
+            }
+            else
+            {
+                sLog.outDebug("LFGMgr::RemoveProposal: Readding [" UI64FMTD "] to queue.", guid);
+                itQueue->second->joinTime = time_t(time(NULL));
+                AddGuidToNewQueue(guid);
+                updateType = LFG_UPDATETYPE_ADDED_TO_QUEUE;
+            }
+        }
+
+        if (plr->GetGroup())
+            plr->GetSession()->SendLfgUpdateParty(updateType);
+        else
+            plr->GetSession()->SendLfgUpdatePlayer(updateType);
+
+    }
+
+    for (LfgProposalPlayerMap::const_iterator it = pProposal->players.begin(); it != pProposal->players.end(); ++it)
+        delete it->second;
+    pProposal->players.clear();
+    pProposal->queues.clear();
+    delete pProposal;
+    m_Proposals.erase(itProposal);
+}
+
+/// <summary>
+/// Initialize a boot kick vote
+/// </summary>
+/// <param name="Group*">Group</param>
+/// <param name="uint32">Player low guid who inits the vote kick</param>
+/// <param name="uint32">Player low guid to be kicked </param>
+/// <param name="std::string">kick reason</param>
+void LFGMgr::InitBoot(Group* grp, uint32 iLowGuid, uint32 vLowguid, std::string reason)
+{
+    if (!grp)
+        return;
+
+    LfgPlayerBoot* pBoot = new LfgPlayerBoot();
+    pBoot->inProgress = true;
+    pBoot->cancelTime = time_t(time(NULL)) + LFG_TIME_BOOT;
+    pBoot->reason = reason;
+    pBoot->victimLowGuid = vLowguid;
+    pBoot->votedNeeded = GROUP_LFG_KICK_VOTES_NEEDED;
+    PlayerSet players;
+
+    uint32 pLowGuid = 0;
+    for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        if (Player* plrg = itr->getSource())
+        {
+            pLowGuid = plrg->GetGUIDLow();
+            if (pLowGuid == vLowguid)
+                pBoot->votes[pLowGuid] = LFG_ANSWER_DENY;    // Victim auto vote NO
+            else if (pLowGuid == iLowGuid)
+                pBoot->votes[pLowGuid] = LFG_ANSWER_AGREE;   // Kicker auto vote YES
+            else
+            {
+                pBoot->votes[pLowGuid] = LFG_ANSWER_PENDING; // Other members need to vote
+                players.insert(plrg);
+            }
+        }
+    }
+
+    for (PlayerSet::const_iterator it = players.begin(); it != players.end(); ++it)
+        (*it)->GetSession()->SendLfgBootPlayer(pBoot);
+
+    grp->SetLfgKickActive(true);
+    m_Boots[grp->GetLowGUID()] = pBoot;
+}
+
+/// <summary>
+/// Update Boot info with player answer
+/// </summary>
+/// <param name="Player*">Player guid</param>
+/// <param name="bool">Player answer</param>
+void LFGMgr::UpdateBoot(Player* plr, bool accept)
+{
+    Group* grp = plr ? plr->GetGroup() : NULL;
+    if (!grp)
+        return;
+
+    uint32 bootId = grp->GetLowGUID();
+    uint32 lowGuid = plr->GetGUIDLow();
+
+    LfgPlayerBootMap::iterator itBoot = m_Boots.find(bootId);
+    if (itBoot == m_Boots.end())
+        return;
+
+    LfgPlayerBoot* pBoot = itBoot->second;
+    if (!pBoot)
+        return;
+
+    if (pBoot->votes[lowGuid] != LFG_ANSWER_PENDING)         // Cheat check: Player can't vote twice
+        return;
+
+    pBoot->votes[lowGuid] = LfgAnswer(accept);
+
+    uint8 votesNum = 0;
+    uint8 agreeNum = 0;
+    for (LfgAnswerMap::const_iterator itVotes = pBoot->votes.begin(); itVotes != pBoot->votes.end(); ++itVotes)
+    {
+        if (itVotes->second != LFG_ANSWER_PENDING)
+        {
+            ++votesNum;
+            if (itVotes->second == LFG_ANSWER_AGREE)
+                ++agreeNum;
+        }
+    }
+
+    if (agreeNum == pBoot->votedNeeded ||                    // Vote passed
+        votesNum == pBoot->votes.size() ||                   // All voted but not passed
+        (pBoot->votes.size() - votesNum + agreeNum) < pBoot->votedNeeded) // Vote didnt passed
+    {
+        // Send update info to all players
+        pBoot->inProgress = false;
+        for (LfgAnswerMap::const_iterator itVotes = pBoot->votes.begin(); itVotes != pBoot->votes.end(); ++itVotes)
+            if (Player* plrg = sObjectMgr.GetPlayerByLowGUID(itVotes->first))
+                if (plrg->GetGUIDLow() != pBoot->victimLowGuid)
+                    plrg->GetSession()->SendLfgBootPlayer(pBoot);
+
+        if (agreeNum == pBoot->votedNeeded)                  // Vote passed - Kick player
+        {
+            Player::RemoveFromGroup(grp, MAKE_NEW_GUID(pBoot->victimLowGuid, 0, HIGHGUID_PLAYER));
+            if (Player* victim = sObjectMgr.GetPlayerByLowGUID(pBoot->victimLowGuid))
+                TeleportPlayer(victim, true, false);
+            OfferContinue(grp);
+            grp->SetLfgKicks(grp->GetLfgKicks() + 1);
+        }
+        grp->SetLfgKickActive(false);
+        delete pBoot;
+        m_Boots.erase(itBoot);
+    }
+}
+
+/// <summary>
+/// Teleports the player in or out the dungeon
+/// </summary>
+/// <param name="Player*">Player</param>
+/// <param name="bool">Teleport out</param>
+/// <param name="bool">Automatic or manual teleport</param>
+void LFGMgr::TeleportPlayer(Player* plr, bool out, bool fromOpcode /*= false*/)
+{
+    sLog.outDebug("LFGMgr::TeleportPlayer: [" UI64FMTD "] is being teleported %s", plr->GetGUID(), out ? "out" : "in");
+    if (out)
+    {
+        plr->RemoveAurasDueToSpell(LFG_SPELL_LUCK_OF_THE_DRAW);
+        plr->TeleportToBGEntryPoint();
+        return;
+    }
+
+    // TODO Add support for LFG_TELEPORTERROR_FATIGUE
+    LfgTeleportError error = LFG_TELEPORTERROR_OK;
+    Group* grp = plr->GetGroup();
+
+    if (!grp || !grp->isLFGGroup())                          // should never happen, but just in case...
+        error = LFG_TELEPORTERROR_INVALID_LOCATION;
+    else if (!plr->isAlive())
+        error = LFG_TELEPORTERROR_PLAYER_DEAD;
+    else if (plr->IsFalling() || plr->hasUnitState(UNIT_STAT_JUMPING))
+        error = LFG_TELEPORTERROR_FALLING;
+    else
+    {
+        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(grp->GetLfgDungeonEntry());
+
+        if (!dungeon)
+            error = LFG_TELEPORTERROR_INVALID_LOCATION;
+        else if (plr->GetMapId() != uint32(dungeon->map))    // Do not teleport players in dungeon to the entrance
+        {
+            uint32 mapid = 0;
+            float x = 0;
+            float y = 0;
+            float z = 0;
+            float orientation = 0;
+
+            if (!fromOpcode)
+            {
+                Player *plrg;
+                // Select a player inside to be teleported to
+                for (GroupReference* itr = grp->GetFirstMember(); itr != NULL && !mapid; itr = itr->next())
+                {
+                    plrg = itr->getSource();
+                    if (plrg && plrg != plr && plrg->GetMapId() == uint32(dungeon->map))
+                    {
+                        mapid = plrg->GetMapId();
+                        x = plrg->GetPositionX();
+                        y = plrg->GetPositionY();
+                        z = plrg->GetPositionZ();
+                        orientation = plrg->GetOrientation();
+                    }
+                }
+            }
+
+            if (!mapid)
+            {
+                AreaTrigger const* at = sObjectMgr.GetMapEntranceTrigger(dungeon->map);
+                if (!at)
+                {
+                    sLog.outError("LfgMgr::TeleportPlayer: Failed to teleport [" UI64FMTD "]: No areatrigger found for map: %u difficulty: %u", plr->GetGUID(), dungeon->map, dungeon->difficulty);
+                    error = LFG_TELEPORTERROR_INVALID_LOCATION;
+                }
+                else
+                {
+                    mapid = at->target_mapId;
+                    x = at->target_X;
+                    y = at->target_Y;
+                    z = at->target_Z;
+                    orientation = at->target_Orientation;
+                }
+            }
+
+            if (error == LFG_TELEPORTERROR_OK)
+            {
+                if (!plr->GetMap()->IsDungeon() && !plr->GetMap()->IsRaid())
+                    plr->SetBattlegroundEntryPoint();
+
+                if (plr->isInFlight())
+                {
+                    plr->GetMotionMaster()->MovementExpired();
+                    plr->CleanupAfterTaxiFlight();
+                }
+
+                if (plr->TeleportTo(mapid, x, y, z, orientation))
+                    plr->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                else
+                {
+                    error = LFG_TELEPORTERROR_INVALID_LOCATION;
+                    sLog.outError("LfgMgr::TeleportPlayer: Failed to teleport [" UI64FMTD "] to map %u: ", plr->GetGUID(), mapid);
+                }
+            }
+        }
+    }
+
+    if (error != LFG_TELEPORTERROR_OK)
+        plr->GetSession()->SendLfgTeleportError(error);
+}
+
+/// <summary>
+/// Give completion reward to player
+/// </summary>
+/// <param name="const uint32">dungeonId</param>
+/// <param name="Player*">player</param>
+void LFGMgr::RewardDungeonDoneFor(const uint32 dungeonId, Player* player)
+{
+    Group* group = player->GetGroup();
+    if ((!group || !group->isLFGGroup()) || !sWorld.getBoolConfig(CONFIG_DUNGEON_FINDER_ENABLE))
+        return;
+
+    // Mark dungeon as finished
+    if (!group->isLfgDungeonComplete())
+        group->SetLfgStatus(LFG_STATUS_COMPLETE);
+
+    // Clear player related lfg stuff
+    uint32 rDungeonId = (*player->GetLfgDungeons()->begin());
+    player->GetLfgDungeons()->clear();
+    player->SetLfgRoles(ROLE_NONE);
+
+    // Give rewards only if its a random dungeon
+    LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId);
+    if (!dungeon || dungeon->type != LFG_TYPE_RANDOM)
+        return;
+
+    // Update achievements
+    if (dungeon->difficulty == DUNGEON_DIFFICULTY_HEROIC)
+        player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_USE_LFD_TO_GROUP_WITH_PLAYERS, 1);
+
+    LfgReward const* reward = GetRandomDungeonReward(rDungeonId, player->getLevel());
+    if (!reward)
+        return;
+
+    uint8 index = 0;
+    Quest const* qReward = sObjectMgr.GetQuestTemplate(reward->reward[index].questId);
+    if (!qReward)
+        return;
+
+    // if we can take the quest, means that we haven't done this kind of "run", IE: First Heroic Random of Day.
+    if (player->CanRewardQuest(qReward,false))
+        player->RewardQuest(qReward,0,NULL,false);
+    else
+    {
+        index = 1;
+        qReward = sObjectMgr.GetQuestTemplate(reward->reward[index].questId);
+        if (!qReward)
+            return;
+        // we give reward without informing client (retail does this)
+        player->RewardQuest(qReward,0,NULL,false);
+    }
+
+    // Give rewards
+    player->GetSession()->SendLfgPlayerReward(dungeon->Entry(), group->GetLfgDungeonEntry(false), index, reward, qReward);
+}
+
+// --------------------------------------------------------------------------//
+// Auxiliar Functions
+// --------------------------------------------------------------------------//
+
+/// <summary>
+/// Given a group get the dungeons that can't be done and reason
+/// </summary>
+/// <param name="PlayerSet*">Players to check lock status</param>
+/// <param name="LfgDungeonSet*">Dungeons to check</param>
+/// <param name="bool">Use dungeon entry (true) or id (false)</param>
+/// <returns>LfgLockStatusMap*</returns>
+LfgLockStatusMap* LFGMgr::GetGroupLockStatusDungeons(PlayerSet* pPlayers, LfgDungeonSet* dungeons, bool useEntry /* = true */)
+{
+    if (!pPlayers || !dungeons)
+        return NULL;
+
+    LfgLockStatusSet* dungeonSet = NULL;
+    LfgLockStatusMap* dungeonMap = new LfgLockStatusMap();
+    for (PlayerSet::const_iterator itr = pPlayers->begin(); itr != pPlayers->end(); ++itr)
+    {
+        dungeonSet = GetPlayerLockStatusDungeons(*itr, dungeons, useEntry);
+        if (dungeonSet)
+            (*dungeonMap)[(*itr)->GetGUIDLow()] = dungeonSet;
+    }
+
+    if (!dungeonMap->size())
+    {
+        delete dungeonMap;
+        dungeonMap = NULL;
+    }
+    return dungeonMap;
+}
+
+/// <summary>
+/// Get all Group members list of dungeons that can't be done and reason
+/// leader excluded as the list given is he list he can do
+/// </summary>
+/// <param name="Player*">Player to get Party Lock info</param>
+/// <param name="LfgDungeonSet*">Dungeons to check</param>
+/// <returns>LfgLockStatusMap*</returns>
+LfgLockStatusMap* LFGMgr::GetPartyLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons /* = NULL */)
+{
+    if (!plr)
+        return NULL;
+
+    if (!dungeons)
+        dungeons = GetAllDungeons();
+
+    Group* grp = plr->GetGroup();
+    if (!grp)
+        return NULL;
+
+    PlayerSet* pPlayers = new PlayerSet();
+    Player* plrg;
+    for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        plrg = itr->getSource();
+        if (plrg && plrg != plr)
+            pPlayers->insert(plrg);
+    }
+    LfgLockStatusMap* dungeonMap = GetGroupLockStatusDungeons(pPlayers, dungeons);
+    pPlayers->clear();
+    delete pPlayers;
+    return dungeonMap;
+}
+
+/// <summary>
+/// Get list of dungeons player can't do and reasons
+/// </summary>
+/// <param name="Player*">Player to check lock status</param>
+/// <param name="LfgDungeonSet*">Dungeons to check</param>
+/// <param name="bool">Use dungeon entry (true) or id (false)</param>
+/// <returns>LfgLockStatusSet*</returns>
+LfgLockStatusSet* LFGMgr::GetPlayerLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons /* = NULL */, bool useEntry /* = true */)
+{
+    LfgLockStatusSet* list = new LfgLockStatusSet();
+    LfgLockStatus* lockstatus = NULL;
+    LFGDungeonEntry const* dungeon;
+    LfgLockStatusType locktype;
+    uint8 level = plr->getLevel();
+    uint8 expansion = plr->GetSession()->Expansion();
+    AccessRequirement const* ar;
+
+    if (!dungeons)
+        dungeons = GetAllDungeons();
+
+    for (LfgDungeonSet::const_iterator it = dungeons->begin(); it != dungeons->end(); ++it)
+    {
+        dungeon = sLFGDungeonStore.LookupEntry(*it);
+        if (!dungeon) // should never happen - We provide a list from sLFGDungeonStore
+            continue;
+
+        ar = sObjectMgr.GetAccessRequirement(dungeon->map, Difficulty(dungeon->difficulty));
+
+        locktype = LFG_LOCKSTATUS_OK;
+        if (dungeon->expansion > expansion)
+            locktype = LFG_LOCKSTATUS_INSUFFICIENT_EXPANSION;
+        else if (sDisableMgr.IsDisabledFor(DISABLE_TYPE_MAP, dungeon->map, plr))
+            locktype = LFG_LOCKSTATUS_RAID_LOCKED;
+        else if (dungeon->difficulty > DUNGEON_DIFFICULTY_NORMAL && plr->GetBoundInstance(dungeon->map, Difficulty(dungeon->difficulty)))
+            locktype = LFG_LOCKSTATUS_RAID_LOCKED;
+        else if (dungeon->minlevel > level)
+            locktype = LFG_LOCKSTATUS_TOO_LOW_LEVEL;
+        else if (dungeon->maxlevel < level)
+            locktype = LFG_LOCKSTATUS_TOO_HIGH_LEVEL;
+        else if (locktype == LFG_LOCKSTATUS_OK && ar)
+        {
+            if (ar->achievement && !plr->GetAchievementMgr().HasAchieved(sAchievementStore.LookupEntry(ar->achievement)))
+                locktype = LFG_LOCKSTATUS_RAID_LOCKED;       // FIXME: Check the correct lock value
+            else if (plr->GetTeam() == ALLIANCE && ar->quest_A && !plr->GetQuestRewardStatus(ar->quest_A))
+                locktype = LFG_LOCKSTATUS_QUEST_NOT_COMPLETED;
+            else if (plr->GetTeam() == HORDE && ar->quest_H && !plr->GetQuestRewardStatus(ar->quest_H))
+                locktype = LFG_LOCKSTATUS_QUEST_NOT_COMPLETED;
+            else
+                if (ar->item)
+                {
+                    if (!plr->HasItemCount(ar->item, 1) && (!ar->item2 || !plr->HasItemCount(ar->item2, 1)))
+                        locktype = LFG_LOCKSTATUS_MISSING_ITEM;
+                }
+                else if (ar->item2 && !plr->HasItemCount(ar->item2, 1))
+                    locktype = LFG_LOCKSTATUS_MISSING_ITEM;
+        }
+        /* TODO VoA closed if WG is not under team control (LFG_LOCKSTATUS_RAID_LOCKED)
+            locktype = LFG_LOCKSTATUS_TOO_LOW_GEAR_SCORE;
+            locktype = LFG_LOCKSTATUS_TOO_HIGH_GEAR_SCORE;
+            locktype = LFG_LOCKSTATUS_ATTUNEMENT_TOO_LOW_LEVEL;
+            locktype = LFG_LOCKSTATUS_ATTUNEMENT_TOO_HIGH_LEVEL;
+            locktype = LFG_LOCKSTATUS_NOT_IN_SEASON; // Need list of instances and needed season to open
+        */
+
+        if (locktype != LFG_LOCKSTATUS_OK)
+        {
+            lockstatus = new LfgLockStatus();
+            lockstatus->dungeon = useEntry ? dungeon->Entry(): dungeon->ID;
+            lockstatus->lockstatus = locktype;
+            list->insert(lockstatus);
+        }
+    }
+    if (!list->size())
+    {
+        delete list;
+        list = NULL;
+    }
+    return list;
+}
+
+/// <summary>
+/// Get the dungeon list that can be done.
+/// </summary>
+/// <returns>LfgDungeonSet*</returns>
+LfgDungeonSet* LFGMgr::GetAllDungeons()
+{
+    LfgDungeonSet* alldungeons = m_CachedDungeonMap[0];
+
+    if (alldungeons)
+        return alldungeons;
+
+    LfgDungeonSet* dungeons;
+    LFGDungeonEntry const* dungeon;
+
+    alldungeons = new LfgDungeonSet();
+    m_CachedDungeonMap[0] = alldungeons;
+    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
+    {
+        dungeon = sLFGDungeonStore.LookupEntry(i);
+        if (!dungeon || dungeon->type == LFG_TYPE_ZONE)
+            continue;
+        dungeons = m_CachedDungeonMap[dungeon->grouptype];
+        if (!dungeons)
+        {
+            dungeons = new LfgDungeonSet();
+            m_CachedDungeonMap[dungeon->grouptype] = dungeons;
+        }
+        if (dungeon->type != LFG_TYPE_RANDOM)
+            dungeons->insert(dungeon->ID);
+        alldungeons->insert(dungeon->ID);
+    }
+
+    return alldungeons;
+}
+
+/// <summary>
+/// Get the dungeon list that can be done given a random dungeon entry.
+/// Special case: randomdungeon == 0 then will return all dungeons
+/// </summary>
+/// <param name="uint32">Random dungeon entry</param>
+/// <returns>LfgDungeonSet*</returns>
+LfgDungeonSet* LFGMgr::GetDungeonsByRandom(uint32 randomdungeon)
+{
+    uint8 groupType = 0;
+    if (LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(randomdungeon))
+        groupType = dungeon->grouptype;
+
+    LfgDungeonMap::const_iterator itMap = m_CachedDungeonMap.find(groupType);
+    if (itMap == m_CachedDungeonMap.end())
+        return NULL;
+
+    LfgDungeonSet* dungeons = new LfgDungeonSet();
+    for (LfgDungeonSet::const_iterator it = itMap->second->begin(); it != itMap->second->end(); ++it)
+        dungeons->insert(*it);
+    return dungeons;
+}
+
+/// <summary>
+/// Get the random dungeon list that can be done at a certain level and expansion.
+/// </summary>
+/// <param name="uint8">Player level</param>
+/// <param name="uint8">Player account expansion</param>
+/// <returns>LfgDungeonSet*</returns>
+LfgDungeonSet* LFGMgr::GetRandomDungeons(uint8 level, uint8 expansion)
+{
+    LfgDungeonSet* list = new LfgDungeonSet();
+    LFGDungeonEntry const* dungeon;
+    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
+    {
+        dungeon = sLFGDungeonStore.LookupEntry(i);
+        if (dungeon && dungeon->expansion <= expansion && dungeon->type == LFG_TYPE_RANDOM &&
+            dungeon->minlevel <= level && level <= dungeon->maxlevel)
+            list->insert(dungeon->Entry());
+    }
+    return list;
+}
+
+/// <summary>
+/// Get the reward of a given random dungeon at a certain level
+/// </summary>
+/// <param name="uint32">random dungeon id</param>
+/// <param name="uint8">Player level</param>
+/// <returns>LfgReward const*</returns>
+LfgReward const* LFGMgr::GetRandomDungeonReward(uint32 dungeon, uint8 level)
+{
+    LfgReward const* rew = NULL;
+    LfgRewardMapBounds bounds = m_RewardMap.equal_range(dungeon & 0x00FFFFFF);
+    for (LfgRewardMap::const_iterator itr = bounds.first; itr != bounds.second; ++itr)
+    {
+        rew = itr->second;
+        // ordered properly at loading
+        if (itr->second->maxLevel >= level)
+            break;
+    }
+
+    return rew;
+}
+
+/// <summary>
+/// Given a Dungeon id returns the dungeon Group Type
+/// </summary>
+/// <param name="uint32">Dungeon id</param>
+/// <returns>uint8: GroupType</returns>
+uint8 LFGMgr::GetDungeonGroupType(uint32 dungeonId)
+{
+    LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId);
+    if (!dungeon)
+        return 0;
+
+    return dungeon->grouptype;
+}
+
+/// <summary>
+/// Given a Dungeon id returns if it's random
+/// </summary>
+/// <param name="uint32">Dungeon id</param>
+/// <returns>bool</returns>
+bool LFGMgr::isRandomDungeon(uint32 dungeonId)
+{
+    LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(dungeonId);
+    if (!dungeon)
+        return false;
+
+    return dungeon->type == LFG_TYPE_RANDOM;
+}
+
+/// <summary>
+/// Given a guid returns if it recently joined queue
+/// </summary>
+/// <param name="uint64&">guid</param>
+/// <returns>bool</returns>
+bool LFGMgr::isJoining(uint64 guid)
+{
+    LfgQueueInfoMap::iterator itQueue = m_QueueInfoMap.find(guid);
+    return itQueue != m_QueueInfoMap.end() && itQueue->second->joinTime + LFG_TIME_JOIN_WARNING > time_t(time(NULL));
+}
+
+/// <summary>
+/// Given a Achievement id returns the related dungeon id
+/// </summary>
+/// <param name="uint32">Achievement id</param>
+/// <returns>uint32</returns>
+uint32 LFGMgr::GetDungeonIdForAchievement(uint32 achievementId)
+{
+    std::map<uint32, uint32>::iterator itr = m_EncountersByAchievement.find(achievementId);
+    if (itr != m_EncountersByAchievement.end())
+        return itr->second;
+
+    return 0;
+};
+
+/// <summary>
+/// Given a list of guids returns the concatenation using | as delimiter
+/// </summary>
+/// <param name="LfgGuidList ">list of guids</param>
+/// <returns>std::string</returns>
+std::string LFGMgr::ConcatenateGuids(LfgGuidList check)
+{
+    if (check.empty())
+        return "";
+
+    LfgGuidSet guidSet;
+    while (!check.empty())
+    {
+        guidSet.insert(check.front());
+        check.pop_front();
+    }
+
+    std::ostringstream o;
+    LfgGuidSet::const_iterator it = guidSet.begin();
+    o << (*it);
+    for (++it; it != guidSet.end(); ++it)
+        o << "|" << (*it);
+    guidSet.clear();
+    return o.str();
+}
+
+/// <summary>
+/// Given a list of dungeonIds returns the concatenation using , as delimiter
+/// </summary>
+/// <param name="LfgDungeonSet ">list of dungeons</param>
+/// <returns>std::string</returns>
+std::string LFGMgr::ConcatenateDungeons(LfgDungeonSet* dungeons)
+{
+    std::string dungeonstr = "";
+    if (dungeons && !dungeons->empty())
+    {
+        std::ostringstream o;
+        LfgDungeonSet::const_iterator it = dungeons->begin();
+        o << (*it);
+        for (++it; it != dungeons->end(); ++it)
+            o << ", " << (*it);
+        dungeonstr = o.str();
+    }
+    return dungeonstr;
+}
+
diff --git a/src/server/game/DungeonFinding/LFGMgr.h b/src/server/game/DungeonFinding/LFGMgr.h
--- a/src/server/game/DungeonFinding/LFGMgr.h
+++ b/src/server/game/DungeonFinding/LFGMgr.h
@@ -1,325 +1,324 @@
-﻿/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#ifndef _LFGMGR_H
-#define _LFGMGR_H
-
-#include "Common.h"
-#include <ace/Singleton.h>
-#include "LFG.h"
-
-class Group;
-class Player;
-
-enum LFGenum
-{
-    LFG_TIME_ROLECHECK         = 2*MINUTE,
-    LFG_TIME_BOOT              = 2*MINUTE,
-    LFG_TIME_PROPOSAL          = 2*MINUTE,
-    LFG_TIME_JOIN_WARNING      = 1*IN_MILLISECONDS,
-    LFG_TANKS_NEEDED           = 1,
-    LFG_HEALERS_NEEDED         = 1,
-    LFG_DPS_NEEDED             = 3,
-    LFG_QUEUEUPDATE_INTERVAL   = 15*IN_MILLISECONDS,
-    LFG_SPELL_DUNGEON_COOLDOWN = 71328,
-    LFG_SPELL_DUNGEON_DESERTER = 71041,
-    LFG_SPELL_LUCK_OF_THE_DRAW = 72221,
-};
-
-enum LfgType
-{
-    LFG_TYPE_DUNGEON = 1,
-    LFG_TYPE_RAID    = 2,
-    LFG_TYPE_QUEST   = 3,
-    LFG_TYPE_ZONE    = 4,
-    LFG_TYPE_HEROIC  = 5,
-    LFG_TYPE_RANDOM  = 6,
-};
-
-enum LfgProposalState
-{
-    LFG_PROPOSAL_INITIATING = 0,
-    LFG_PROPOSAL_FAILED     = 1,
-    LFG_PROPOSAL_SUCCESS    = 2,
-};
-
-enum LfgLockStatusType
-{
-    LFG_LOCKSTATUS_OK                        = 0,           // Internal use only
-    LFG_LOCKSTATUS_INSUFFICIENT_EXPANSION    = 1,
-    LFG_LOCKSTATUS_TOO_LOW_LEVEL             = 2,
-    LFG_LOCKSTATUS_TOO_HIGH_LEVEL            = 3,
-    LFG_LOCKSTATUS_TOO_LOW_GEAR_SCORE        = 4,
-    LFG_LOCKSTATUS_TOO_HIGH_GEAR_SCORE       = 5,
-    LFG_LOCKSTATUS_RAID_LOCKED               = 6,
-    LFG_LOCKSTATUS_ATTUNEMENT_TOO_LOW_LEVEL  = 1001,
-    LFG_LOCKSTATUS_ATTUNEMENT_TOO_HIGH_LEVEL = 1002,
-    LFG_LOCKSTATUS_QUEST_NOT_COMPLETED       = 1022,
-    LFG_LOCKSTATUS_MISSING_ITEM              = 1025,
-    LFG_LOCKSTATUS_NOT_IN_SEASON             = 1031,
-};
-
-enum LfgTeleportError
-{
-    LFG_TELEPORTERROR_OK               = 0,                 // Internal use
-    LFG_TELEPORTERROR_PLAYER_DEAD      = 1,
-    LFG_TELEPORTERROR_FALLING          = 2,
-    //LFG_TELEPORTERROR_UNK2           = 3,                 // You can't do that right now
-    LFG_TELEPORTERROR_FATIGUE          = 4,
-    //LFG_TELEPORTERROR_UNK3           = 5,                 // No reaction
-    LFG_TELEPORTERROR_INVALID_LOCATION = 6,
-    //LFG_TELEPORTERROR_UNK4           = 7,                 // You can't do that right now
-    //LFG_TELEPORTERROR_UNK5           = 8,                 // You can't do that right now
-};
-
-enum LfgJoinResult
-{
-    LFG_JOIN_OK                    = 0,                     // Joined (no client msg)
-    LFG_JOIN_FAILED                = 1,                     // RoleCheck Failed
-    LFG_JOIN_GROUPFULL             = 2,                     // Your group is full
-    //LFG_JOIN_UNK3                = 3,                     // No client reaction
-    LFG_JOIN_INTERNAL_ERROR        = 4,                     // Internal LFG Error
-    LFG_JOIN_NOT_MEET_REQS         = 5,                     // You do not meet the requirements for the chosen dungeons
-    LFG_JOIN_PARTY_NOT_MEET_REQS   = 6,                     // One or more party members do not meet the requirements for the chosen dungeons
-    LFG_JOIN_MIXED_RAID_DUNGEON    = 7,                     // You cannot mix dungeons, raids, and random when picking dungeons
-    LFG_JOIN_MULTI_REALM           = 8,                     // The dungeon you chose does not support players from multiple realms
-    LFG_JOIN_DISCONNECTED          = 9,                     // One or more party members are pending invites or disconnected
-    LFG_JOIN_PARTY_INFO_FAILED     = 10,                    // Could not retrieve information about some party members
-    LFG_JOIN_DUNGEON_INVALID       = 11,                    // One or more dungeons was not valid
-    LFG_JOIN_DESERTER              = 12,                    // You can not queue for dungeons until your deserter debuff wears off
-    LFG_JOIN_PARTY_DESERTER        = 13,                    // One or more party members has a deserter debuff
-    LFG_JOIN_RANDOM_COOLDOWN       = 14,                    // You can not queue for random dungeons while on random dungeon cooldown
-    LFG_JOIN_PARTY_RANDOM_COOLDOWN = 15,                    // One or more party members are on random dungeon cooldown
-    LFG_JOIN_TOO_MUCH_MEMBERS      = 16,                    // You can not enter dungeons with more that 5 party members
-    LFG_JOIN_USING_BG_SYSTEM       = 17,                    // You can not use the dungeon system while in BG or arenas
-    //LFG_JOIN_FAILED2             = 18,                    // RoleCheck Failed
-};
-
-enum LfgRoleCheckResult
-{
-    LFG_ROLECHECK_FINISHED     = 1,                         // Role check finished
-    LFG_ROLECHECK_INITIALITING = 2,                         // Role check begins
-    LFG_ROLECHECK_MISSING_ROLE = 3,                         // Someone didn't selected a role after 2 mins
-    LFG_ROLECHECK_WRONG_ROLES  = 4,                         // Can't form a group with that role selection
-    LFG_ROLECHECK_ABORTED      = 5,                         // Someone leave the group
-    LFG_ROLECHECK_NO_ROLE      = 6,                         // Someone selected no role
-};
-
-enum LfgAnswer
-{
-    LFG_ANSWER_PENDING = -1,
-    LFG_ANSWER_DENY    = 0,
-    LFG_ANSWER_AGREE   = 1,
-};
-
-// Dungeon and reason why player can't join
-struct LfgLockStatus
-{
-    uint32 dungeon;
-    LfgLockStatusType lockstatus;
-};
-
-// Reward info
-struct LfgReward
-{
-    uint32 maxLevel;
-    struct
-    {
-        uint32 questId;
-        uint32 variableMoney;
-        uint32 variableXP;
-    } reward[2];
-
-    LfgReward(uint32 _maxLevel, uint32 firstQuest, uint32 firstVarMoney, uint32 firstVarXp, uint32 otherQuest, uint32 otherVarMoney, uint32 otherVarXp)
-        : maxLevel(_maxLevel)
-    {
-        reward[0].questId = firstQuest;
-        reward[0].variableMoney = firstVarMoney;
-        reward[0].variableXP = firstVarXp;
-        reward[1].questId = otherQuest;
-        reward[1].variableMoney = otherVarMoney;
-        reward[1].variableXP = otherVarXp;
-    }
-};
-
-typedef std::map<uint32, uint8> LfgRolesMap;
-typedef std::map<uint32, LfgAnswer> LfgAnswerMap;
-typedef std::list<uint64> LfgGuidList;
-typedef std::map<uint64, LfgDungeonSet*> LfgDungeonMap;
-
-// Stores player or group queue info
-struct LfgQueueInfo
-{
-    LfgQueueInfo(): tanks(LFG_TANKS_NEEDED), healers(LFG_HEALERS_NEEDED), dps(LFG_DPS_NEEDED) {};
-    time_t joinTime;                                        // Player queue join time (to calculate wait times)
-    uint8 tanks;                                            // Tanks needed
-    uint8 healers;                                          // Healers needed
-    uint8 dps;                                              // Dps needed
-    LfgDungeonSet dungeons;                                 // Selected Player/Group Dungeon/s
-    LfgRolesMap roles;                                      // Selected Player Role/s
-};
-
-struct LfgProposalPlayer
-{
-    LfgProposalPlayer(): role(0), accept(LFG_ANSWER_PENDING), groupLowGuid(0) {};
-    uint8 role;                                             // Proposed role
-    LfgAnswer accept;                                       // Accept status (-1 not answer | 0 Not agree | 1 agree)
-    uint32 groupLowGuid;                                    // Original group guid (Low guid) 0 if no original group
-};
-
-typedef std::map<uint32, LfgProposalPlayer*> LfgProposalPlayerMap;
-
-// Stores all Dungeon Proposal after matching candidates
-struct LfgProposal
-{
-    LfgProposal(uint32 dungeon): dungeonId(dungeon), state(LFG_PROPOSAL_INITIATING), groupLowGuid(0), leaderLowGuid(0) {}
-
-    ~LfgProposal()
-    {
-        for (LfgProposalPlayerMap::iterator it = players.begin(); it != players.end(); ++it)
-            delete it->second;
-        players.clear();
-        queues.clear();
-    };
-    uint32 dungeonId;                                       // Dungeon to join
-    LfgProposalState state;                                 // State of the proposal
-    uint32 groupLowGuid;                                    // Proposal group (0 if new)
-    uint32 leaderLowGuid;                                   // Leader guid.
-    time_t cancelTime;                                      // Time when we will cancel this proposal
-    LfgGuidList queues;                                     // Queue Ids to remove/readd
-    LfgProposalPlayerMap players;                           // Player current groupId
-
-};
-
-// Stores all rolecheck info of a group that wants to join LFG
-struct LfgRoleCheck
-{
-    time_t cancelTime;
-    LfgRolesMap roles;
-    LfgRoleCheckResult result;
-    LfgDungeonSet dungeons;
-    uint32 leader;
-};
-
-// Stores information of a current vote to kick someone from a group
-struct LfgPlayerBoot
-{
-    time_t cancelTime;                                      // Time left to vote
-    bool inProgress;                                        // Vote in progress
-    LfgAnswerMap votes;                                     // Player votes (-1 not answer | 0 Not agree | 1 agree)
-    uint32 victimLowGuid;                                   // Player guid to be kicked (can't vote)
-    uint8 votedNeeded;                                      // Votes needed to kick the player
-    std::string reason;                                     // kick reason
-};
-
-typedef std::set<Player*> PlayerSet;
-typedef std::set<LfgLockStatus*> LfgLockStatusSet;
-typedef std::vector<LfgProposal*> LfgProposalList;
-typedef std::map<uint32, LfgLockStatusSet*> LfgLockStatusMap;
-typedef std::map<uint64, LfgQueueInfo*> LfgQueueInfoMap;
-typedef std::map<uint32, LfgRoleCheck*> LfgRoleCheckMap;
-typedef std::map<uint32, LfgProposal*> LfgProposalMap;
-typedef std::map<uint32, LfgPlayerBoot*> LfgPlayerBootMap;
-typedef std::multimap<uint32, LfgReward const*> LfgRewardMap;
-typedef std::pair<LfgRewardMap::const_iterator, LfgRewardMap::const_iterator> LfgRewardMapBounds;
-typedef std::list<Player*> LfgPlayerList;
-typedef std::set<uint64> LfgGuidSet;
-typedef std::map<std::string, LfgAnswer> LfgCompatibleMap;
-
-
-class LFGMgr
-{
-    friend class ACE_Singleton<LFGMgr, ACE_Null_Mutex>;
-    public:
-        LFGMgr();
-        ~LFGMgr();
-
-        void Join(Player* plr);
-        void Leave(Player* plr, Group* grp = NULL);
-        void OfferContinue(Group* grp);
-        void TeleportPlayer(Player* plr, bool out, bool fromOpcode = false);
-        void UpdateProposal(uint32 proposalId, uint32 lowGuid, bool accept);
-        void UpdateBoot(Player* plr, bool accept);
-        void UpdateRoleCheck(Group* grp, Player* plr = NULL);
-        void Update(uint32 diff);
-
-        bool isRandomDungeon(uint32 dungeonId);
-        void InitBoot(Group* grp, uint32 plowGuid, uint32 vlowGuid, std::string reason);
-
-        void LoadDungeonEncounters();
-        void LoadRewards();
-        void RewardDungeonDoneFor(const uint32 dungeonId, Player* player);
-        uint32 GetDungeonIdForAchievement(uint32 achievementId);
-
-        LfgLockStatusMap* GetPartyLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons = NULL);
-        LfgDungeonSet* GetRandomDungeons(uint8 level, uint8 expansion);
-        LfgLockStatusSet* GetPlayerLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons = NULL, bool useEntry = true);
-        LfgReward const* GetRandomDungeonReward(uint32 dungeon, uint8 level);
-
-        bool isJoining(uint64 guid);
-
-    private:
-        void Cleaner();
-        void AddGuidToNewQueue(uint64 guid);
-        void AddToQueue(uint64 guid, LfgRolesMap* roles, LfgDungeonSet* dungeons);
-
-        bool RemoveFromQueue(uint64 guid);
-        void RemoveProposal(LfgProposalMap::iterator itProposal, LfgUpdateType type);
-
-        void FindNewGroups(LfgGuidList &check, LfgGuidList all, LfgProposalList* proposals);
-
-        bool CheckGroupRoles(LfgRolesMap &groles, bool removeLeaderFlag = true);
-        bool CheckCompatibility(LfgGuidList check, LfgProposalList* proposals);
-        LfgDungeonSet* CheckCompatibleDungeons(LfgDungeonMap* dungeonsMap, PlayerSet* players);
-        LfgLockStatusMap* CheckCompatibleDungeons(LfgDungeonSet* dungeons, PlayerSet* players, bool returnLockMap = true);
-        void SetCompatibles(std::string concatenatedGuids, bool compatibles);
-        LfgAnswer GetCompatibles(std::string concatenatedGuids);
-        void RemoveFromCompatibles(uint64 guid);
-        std::string ConcatenateGuids(LfgGuidList check);
-        std::string ConcatenateDungeons(LfgDungeonSet* dungeons);
-
-        LfgLockStatusMap* GetGroupLockStatusDungeons(PlayerSet* pPlayers, LfgDungeonSet* dungeons, bool useEntry = true);
-        LfgDungeonSet* GetDungeonsByRandom(uint32 randomdungeon);
-        LfgDungeonSet* GetAllDungeons();
-        uint8 GetDungeonGroupType(uint32 dungeon);
-
-        LfgRewardMap m_RewardMap;                           // Stores rewards for random dungeons
-        std::map<uint32, uint32> m_EncountersByAchievement; // Stores dungeon ids associated with achievements (for rewards)
-        LfgDungeonMap m_CachedDungeonMap;                   // Stores all dungeons by groupType
-        LfgQueueInfoMap m_QueueInfoMap;                     // Queued groups
-        LfgGuidList m_currentQueue;                         // Ordered list. Used to find groups
-        LfgGuidList m_newToQueue;                           // New groups to add to queue
-        LfgCompatibleMap m_CompatibleMap;                   // Compatible dungeons
-        LfgProposalMap m_Proposals;                         // Current Proposals
-        LfgPlayerBootMap m_Boots;                           // Current player kicks
-        LfgRoleCheckMap m_RoleChecks;                       // Current Role checks
-        uint32 m_QueueTimer;                                // used to check interval of update
-        uint32 m_lfgProposalId;                             // used as internal counter for proposals
-        int32 m_WaitTimeAvg;
-        int32 m_WaitTimeTank;
-        int32 m_WaitTimeHealer;
-        int32 m_WaitTimeDps;
-        uint32 m_NumWaitTimeAvg;
-        uint32 m_NumWaitTimeTank;
-        uint32 m_NumWaitTimeHealer;
-        uint32 m_NumWaitTimeDps;
-        bool m_update;
-};
-
-#define sLFGMgr (*ACE_Singleton<LFGMgr, ACE_Null_Mutex>::instance())
-#endif
+﻿/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _LFGMGR_H
+#define _LFGMGR_H
+
+#include "Common.h"
+#include <ace/Singleton.h>
+#include "LFG.h"
+
+class Group;
+class Player;
+
+enum LFGenum
+{
+    LFG_TIME_ROLECHECK         = 2*MINUTE,
+    LFG_TIME_BOOT              = 2*MINUTE,
+    LFG_TIME_PROPOSAL          = 2*MINUTE,
+    LFG_TIME_JOIN_WARNING      = 1*IN_MILLISECONDS,
+    LFG_TANKS_NEEDED           = 1,
+    LFG_HEALERS_NEEDED         = 1,
+    LFG_DPS_NEEDED             = 3,
+    LFG_QUEUEUPDATE_INTERVAL   = 15*IN_MILLISECONDS,
+    LFG_SPELL_DUNGEON_COOLDOWN = 71328,
+    LFG_SPELL_DUNGEON_DESERTER = 71041,
+    LFG_SPELL_LUCK_OF_THE_DRAW = 72221,
+};
+
+enum LfgType
+{
+    LFG_TYPE_DUNGEON = 1,
+    LFG_TYPE_RAID    = 2,
+    LFG_TYPE_QUEST   = 3,
+    LFG_TYPE_ZONE    = 4,
+    LFG_TYPE_HEROIC  = 5,
+    LFG_TYPE_RANDOM  = 6,
+};
+
+enum LfgProposalState
+{
+    LFG_PROPOSAL_INITIATING = 0,
+    LFG_PROPOSAL_FAILED     = 1,
+    LFG_PROPOSAL_SUCCESS    = 2,
+};
+
+enum LfgLockStatusType
+{
+    LFG_LOCKSTATUS_OK                        = 0,           // Internal use only
+    LFG_LOCKSTATUS_INSUFFICIENT_EXPANSION    = 1,
+    LFG_LOCKSTATUS_TOO_LOW_LEVEL             = 2,
+    LFG_LOCKSTATUS_TOO_HIGH_LEVEL            = 3,
+    LFG_LOCKSTATUS_TOO_LOW_GEAR_SCORE        = 4,
+    LFG_LOCKSTATUS_TOO_HIGH_GEAR_SCORE       = 5,
+    LFG_LOCKSTATUS_RAID_LOCKED               = 6,
+    LFG_LOCKSTATUS_ATTUNEMENT_TOO_LOW_LEVEL  = 1001,
+    LFG_LOCKSTATUS_ATTUNEMENT_TOO_HIGH_LEVEL = 1002,
+    LFG_LOCKSTATUS_QUEST_NOT_COMPLETED       = 1022,
+    LFG_LOCKSTATUS_MISSING_ITEM              = 1025,
+    LFG_LOCKSTATUS_NOT_IN_SEASON             = 1031,
+};
+
+enum LfgTeleportError
+{
+    LFG_TELEPORTERROR_OK               = 0,                 // Internal use
+    LFG_TELEPORTERROR_PLAYER_DEAD      = 1,
+    LFG_TELEPORTERROR_FALLING          = 2,
+    //LFG_TELEPORTERROR_UNK2           = 3,                 // You can't do that right now
+    LFG_TELEPORTERROR_FATIGUE          = 4,
+    //LFG_TELEPORTERROR_UNK3           = 5,                 // No reaction
+    LFG_TELEPORTERROR_INVALID_LOCATION = 6,
+    //LFG_TELEPORTERROR_UNK4           = 7,                 // You can't do that right now
+    //LFG_TELEPORTERROR_UNK5           = 8,                 // You can't do that right now
+};
+
+enum LfgJoinResult
+{
+    LFG_JOIN_OK                    = 0,                     // Joined (no client msg)
+    LFG_JOIN_FAILED                = 1,                     // RoleCheck Failed
+    LFG_JOIN_GROUPFULL             = 2,                     // Your group is full
+    //LFG_JOIN_UNK3                = 3,                     // No client reaction
+    LFG_JOIN_INTERNAL_ERROR        = 4,                     // Internal LFG Error
+    LFG_JOIN_NOT_MEET_REQS         = 5,                     // You do not meet the requirements for the chosen dungeons
+    LFG_JOIN_PARTY_NOT_MEET_REQS   = 6,                     // One or more party members do not meet the requirements for the chosen dungeons
+    LFG_JOIN_MIXED_RAID_DUNGEON    = 7,                     // You cannot mix dungeons, raids, and random when picking dungeons
+    LFG_JOIN_MULTI_REALM           = 8,                     // The dungeon you chose does not support players from multiple realms
+    LFG_JOIN_DISCONNECTED          = 9,                     // One or more party members are pending invites or disconnected
+    LFG_JOIN_PARTY_INFO_FAILED     = 10,                    // Could not retrieve information about some party members
+    LFG_JOIN_DUNGEON_INVALID       = 11,                    // One or more dungeons was not valid
+    LFG_JOIN_DESERTER              = 12,                    // You can not queue for dungeons until your deserter debuff wears off
+    LFG_JOIN_PARTY_DESERTER        = 13,                    // One or more party members has a deserter debuff
+    LFG_JOIN_RANDOM_COOLDOWN       = 14,                    // You can not queue for random dungeons while on random dungeon cooldown
+    LFG_JOIN_PARTY_RANDOM_COOLDOWN = 15,                    // One or more party members are on random dungeon cooldown
+    LFG_JOIN_TOO_MUCH_MEMBERS      = 16,                    // You can not enter dungeons with more that 5 party members
+    LFG_JOIN_USING_BG_SYSTEM       = 17,                    // You can not use the dungeon system while in BG or arenas
+    //LFG_JOIN_FAILED2             = 18,                    // RoleCheck Failed
+};
+
+enum LfgRoleCheckResult
+{
+    LFG_ROLECHECK_FINISHED     = 1,                         // Role check finished
+    LFG_ROLECHECK_INITIALITING = 2,                         // Role check begins
+    LFG_ROLECHECK_MISSING_ROLE = 3,                         // Someone didn't selected a role after 2 mins
+    LFG_ROLECHECK_WRONG_ROLES  = 4,                         // Can't form a group with that role selection
+    LFG_ROLECHECK_ABORTED      = 5,                         // Someone leave the group
+    LFG_ROLECHECK_NO_ROLE      = 6,                         // Someone selected no role
+};
+
+enum LfgAnswer
+{
+    LFG_ANSWER_PENDING = -1,
+    LFG_ANSWER_DENY    = 0,
+    LFG_ANSWER_AGREE   = 1,
+};
+
+// Dungeon and reason why player can't join
+struct LfgLockStatus
+{
+    uint32 dungeon;
+    LfgLockStatusType lockstatus;
+};
+
+// Reward info
+struct LfgReward
+{
+    uint32 maxLevel;
+    struct
+    {
+        uint32 questId;
+        uint32 variableMoney;
+        uint32 variableXP;
+    } reward[2];
+
+    LfgReward(uint32 _maxLevel, uint32 firstQuest, uint32 firstVarMoney, uint32 firstVarXp, uint32 otherQuest, uint32 otherVarMoney, uint32 otherVarXp)
+        : maxLevel(_maxLevel)
+    {
+        reward[0].questId = firstQuest;
+        reward[0].variableMoney = firstVarMoney;
+        reward[0].variableXP = firstVarXp;
+        reward[1].questId = otherQuest;
+        reward[1].variableMoney = otherVarMoney;
+        reward[1].variableXP = otherVarXp;
+    }
+};
+
+typedef std::map<uint32, uint8> LfgRolesMap;
+typedef std::map<uint32, LfgAnswer> LfgAnswerMap;
+typedef std::list<uint64> LfgGuidList;
+typedef std::map<uint64, LfgDungeonSet*> LfgDungeonMap;
+
+// Stores player or group queue info
+struct LfgQueueInfo
+{
+    LfgQueueInfo(): tanks(LFG_TANKS_NEEDED), healers(LFG_HEALERS_NEEDED), dps(LFG_DPS_NEEDED) {};
+    time_t joinTime;                                        // Player queue join time (to calculate wait times)
+    uint8 tanks;                                            // Tanks needed
+    uint8 healers;                                          // Healers needed
+    uint8 dps;                                              // Dps needed
+    LfgDungeonSet dungeons;                                 // Selected Player/Group Dungeon/s
+    LfgRolesMap roles;                                      // Selected Player Role/s
+};
+
+struct LfgProposalPlayer
+{
+    LfgProposalPlayer(): role(0), accept(LFG_ANSWER_PENDING), groupLowGuid(0) {};
+    uint8 role;                                             // Proposed role
+    LfgAnswer accept;                                       // Accept status (-1 not answer | 0 Not agree | 1 agree)
+    uint32 groupLowGuid;                                    // Original group guid (Low guid) 0 if no original group
+};
+
+typedef std::map<uint32, LfgProposalPlayer*> LfgProposalPlayerMap;
+
+// Stores all Dungeon Proposal after matching candidates
+struct LfgProposal
+{
+    LfgProposal(uint32 dungeon): dungeonId(dungeon), state(LFG_PROPOSAL_INITIATING), groupLowGuid(0), leaderLowGuid(0) {}
+
+    ~LfgProposal()
+    {
+        for (LfgProposalPlayerMap::iterator it = players.begin(); it != players.end(); ++it)
+            delete it->second;
+        players.clear();
+        queues.clear();
+    };
+    uint32 dungeonId;                                       // Dungeon to join
+    LfgProposalState state;                                 // State of the proposal
+    uint32 groupLowGuid;                                    // Proposal group (0 if new)
+    uint32 leaderLowGuid;                                   // Leader guid.
+    time_t cancelTime;                                      // Time when we will cancel this proposal
+    LfgGuidList queues;                                     // Queue Ids to remove/readd
+    LfgProposalPlayerMap players;                           // Player current groupId
+
+};
+
+// Stores all rolecheck info of a group that wants to join LFG
+struct LfgRoleCheck
+{
+    time_t cancelTime;
+    LfgRolesMap roles;
+    LfgRoleCheckResult result;
+    LfgDungeonSet dungeons;
+    uint32 leader;
+};
+
+// Stores information of a current vote to kick someone from a group
+struct LfgPlayerBoot
+{
+    time_t cancelTime;                                      // Time left to vote
+    bool inProgress;                                        // Vote in progress
+    LfgAnswerMap votes;                                     // Player votes (-1 not answer | 0 Not agree | 1 agree)
+    uint32 victimLowGuid;                                   // Player guid to be kicked (can't vote)
+    uint8 votedNeeded;                                      // Votes needed to kick the player
+    std::string reason;                                     // kick reason
+};
+
+typedef std::set<Player*> PlayerSet;
+typedef std::set<LfgLockStatus*> LfgLockStatusSet;
+typedef std::map<uint32, LfgLockStatusSet*> LfgLockStatusMap;
+typedef std::map<uint64, LfgQueueInfo*> LfgQueueInfoMap;
+typedef std::map<uint32, LfgRoleCheck*> LfgRoleCheckMap;
+typedef std::map<uint32, LfgProposal*> LfgProposalMap;
+typedef std::map<uint32, LfgPlayerBoot*> LfgPlayerBootMap;
+typedef std::multimap<uint32, LfgReward const*> LfgRewardMap;
+typedef std::pair<LfgRewardMap::const_iterator, LfgRewardMap::const_iterator> LfgRewardMapBounds;
+typedef std::list<Player*> LfgPlayerList;
+typedef std::set<uint64> LfgGuidSet;
+typedef std::map<std::string, LfgAnswer> LfgCompatibleMap;
+
+
+class LFGMgr
+{
+    friend class ACE_Singleton<LFGMgr, ACE_Null_Mutex>;
+    public:
+        LFGMgr();
+        ~LFGMgr();
+
+        void Join(Player* plr);
+        void Leave(Player* plr, Group* grp = NULL);
+        void OfferContinue(Group* grp);
+        void TeleportPlayer(Player* plr, bool out, bool fromOpcode = false);
+        void UpdateProposal(uint32 proposalId, uint32 lowGuid, bool accept);
+        void UpdateBoot(Player* plr, bool accept);
+        void UpdateRoleCheck(Group* grp, Player* plr = NULL);
+        void Update(uint32 diff);
+
+        bool isRandomDungeon(uint32 dungeonId);
+        void InitBoot(Group* grp, uint32 plowGuid, uint32 vlowGuid, std::string reason);
+
+        void LoadDungeonEncounters();
+        void LoadRewards();
+        void RewardDungeonDoneFor(const uint32 dungeonId, Player* player);
+        uint32 GetDungeonIdForAchievement(uint32 achievementId);
+
+        LfgLockStatusMap* GetPartyLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons = NULL);
+        LfgDungeonSet* GetRandomDungeons(uint8 level, uint8 expansion);
+        LfgLockStatusSet* GetPlayerLockStatusDungeons(Player* plr, LfgDungeonSet* dungeons = NULL, bool useEntry = true);
+        LfgReward const* GetRandomDungeonReward(uint32 dungeon, uint8 level);
+
+        bool isJoining(uint64 guid);
+
+    private:
+        void Cleaner();
+        void AddGuidToNewQueue(uint64 guid);
+        void AddToQueue(uint64 guid, LfgRolesMap* roles, LfgDungeonSet* dungeons);
+
+        bool RemoveFromQueue(uint64 guid);
+        void RemoveProposal(LfgProposalMap::iterator itProposal, LfgUpdateType type);
+
+        LfgProposal* FindNewGroups(LfgGuidList check, LfgGuidList all);
+
+        bool CheckGroupRoles(LfgRolesMap &groles, bool removeLeaderFlag = true);
+        bool CheckCompatibility(LfgGuidList check, LfgProposal*& pProposal);
+        LfgDungeonSet* CheckCompatibleDungeons(LfgDungeonMap* dungeonsMap, PlayerSet* players);
+        LfgLockStatusMap* CheckCompatibleDungeons(LfgDungeonSet* dungeons, PlayerSet* players, bool returnLockMap = true);
+        void SetCompatibles(std::string concatenatedGuids, bool compatibles);
+        LfgAnswer GetCompatibles(std::string concatenatedGuids);
+        void RemoveFromCompatibles(uint64 guid);
+        std::string ConcatenateGuids(LfgGuidList check);
+        std::string ConcatenateDungeons(LfgDungeonSet* dungeons);
+
+        LfgLockStatusMap* GetGroupLockStatusDungeons(PlayerSet* pPlayers, LfgDungeonSet* dungeons, bool useEntry = true);
+        LfgDungeonSet* GetDungeonsByRandom(uint32 randomdungeon);
+        LfgDungeonSet* GetAllDungeons();
+        uint8 GetDungeonGroupType(uint32 dungeon);
+
+        LfgRewardMap m_RewardMap;                           // Stores rewards for random dungeons
+        std::map<uint32, uint32> m_EncountersByAchievement; // Stores dungeon ids associated with achievements (for rewards)
+        LfgDungeonMap m_CachedDungeonMap;                   // Stores all dungeons by groupType
+        LfgQueueInfoMap m_QueueInfoMap;                     // Queued groups
+        LfgGuidList m_currentQueue;                         // Ordered list. Used to find groups
+        LfgGuidList m_newToQueue;                           // New groups to add to queue
+        LfgCompatibleMap m_CompatibleMap;                   // Compatible dungeons
+        LfgProposalMap m_Proposals;                         // Current Proposals
+        LfgPlayerBootMap m_Boots;                           // Current player kicks
+        LfgRoleCheckMap m_RoleChecks;                       // Current Role checks
+        uint32 m_QueueTimer;                                // used to check interval of update
+        uint32 m_lfgProposalId;                             // used as internal counter for proposals
+        int32 m_WaitTimeAvg;
+        int32 m_WaitTimeTank;
+        int32 m_WaitTimeHealer;
+        int32 m_WaitTimeDps;
+        uint32 m_NumWaitTimeAvg;
+        uint32 m_NumWaitTimeTank;
+        uint32 m_NumWaitTimeHealer;
+        uint32 m_NumWaitTimeDps;
+        bool m_update;
+};
+
+#define sLFGMgr (*ACE_Singleton<LFGMgr, ACE_Null_Mutex>::instance())
+#endif
+
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -1,1918 +1,1890 @@
-﻿/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Common.h"
-#include "Opcodes.h"
-#include "WorldPacket.h"
-#include "WorldSession.h"
-#include "Player.h"
-#include "World.h"
-#include "ObjectMgr.h"
-#include "Group.h"
-#include "Formulas.h"
-#include "ObjectAccessor.h"
-#include "Battleground.h"
-#include "BattlegroundMgr.h"
-#include "MapManager.h"
-#include "InstanceSaveMgr.h"
-#include "MapInstanced.h"
-#include "Util.h"
-#include "LFGMgr.h"
-
-Group::Group()
-{
-    m_leaderGuid        = 0;
-    m_groupType         = GroupType(0);
-    m_bgGroup           = NULL;
-    m_lootMethod        = LootMethod(0);
-    m_looterGuid        = 0;
-    m_lootThreshold     = ITEM_QUALITY_UNCOMMON;
-    m_subGroupsCounts   = NULL;
-    m_guid              = 0;
-    m_counter           = 0;
-    m_maxEnchantingLevel= 0;
-    m_LfgQueued         = false;
-    m_LfgStatus         = LFG_STATUS_NOT_SAVED;
-    m_LfgDungeonEntry   = 0;
-    m_Lfgkicks          = 0;
-    m_LfgkicksActive    = false;
-
-    for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
-        m_targetIcons[i] = 0;
-}
-
-Group::~Group()
-{
-    if (m_bgGroup)
-    {
-        sLog.outDebug("Group::~Group: battleground group being deleted.");
-        if (m_bgGroup->GetBgRaid(ALLIANCE) == this) m_bgGroup->SetBgRaid(ALLIANCE, NULL);
-        else if (m_bgGroup->GetBgRaid(HORDE) == this) m_bgGroup->SetBgRaid(HORDE, NULL);
-        else sLog.outError("Group::~Group: battleground group is not linked to the correct battleground.");
-    }
-    Rolls::iterator itr;
-    while (!RollId.empty())
-    {
-        itr = RollId.begin();
-        Roll *r = *itr;
-        RollId.erase(itr);
-        delete(r);
-    }
-
-    // it is undefined whether objectmgr (which stores the groups) or instancesavemgr
-    // will be unloaded first so we must be prepared for both cases
-    // this may unload some instance saves
-    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
-        for (BoundInstancesMap::iterator itr2 = m_boundInstances[i].begin(); itr2 != m_boundInstances[i].end(); ++itr2)
-            itr2->second.save->RemoveGroup(this);
-
-    // Sub group counters clean up
-    delete[] m_subGroupsCounts;
-}
-
-bool Group::Create(const uint64 &guid, const char * name)
-{
-    uint32 lowguid = sObjectMgr.GenerateLowGuid(HIGHGUID_GROUP);
-    m_guid = MAKE_NEW_GUID(lowguid, 0, HIGHGUID_GROUP);
-    m_leaderGuid = guid;
-    m_leaderName = name;
-
-    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
-
-    if (m_groupType & GROUPTYPE_RAID)
-        _initRaidSubGroupsCounter();
-
-    m_lootMethod = GROUP_LOOT;
-    m_lootThreshold = ITEM_QUALITY_UNCOMMON;
-    m_looterGuid = guid;
-
-    m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
-    m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
-    SQLTransaction trans = CharacterDatabase.BeginTransaction();
-
-    if (!isBGGroup())
-    {
-        Player *leader = sObjectMgr.GetPlayer(guid);
-        if (leader)
-        {
-            m_dungeonDifficulty = leader->GetDungeonDifficulty();
-            m_raidDifficulty = leader->GetRaidDifficulty();
-        }
-
-        Player::ConvertInstancesToGroup(leader, this, guid);
-
-        // store group in database
-        trans->PAppend("DELETE FROM groups WHERE guid ='%u'", lowguid);
-        trans->PAppend("DELETE FROM group_member WHERE guid ='%u'", lowguid);
-        trans->PAppend("INSERT INTO groups (guid,leaderGuid,lootMethod,looterGuid,lootThreshold,icon1,icon2,icon3,icon4,icon5,icon6,icon7,icon8,groupType,difficulty,raiddifficulty) "
-            "VALUES ('%u','%u','%u','%u','%u','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','%u','%u','%u')",
-            lowguid, GUID_LOPART(m_leaderGuid), uint32(m_lootMethod),
-            GUID_LOPART(m_looterGuid), uint32(m_lootThreshold), m_targetIcons[0], m_targetIcons[1], m_targetIcons[2], m_targetIcons[3], m_targetIcons[4], m_targetIcons[5], m_targetIcons[6], m_targetIcons[7], uint8(m_groupType), uint32(m_dungeonDifficulty), m_raidDifficulty);
-
-    }
-
-    if (!AddMember(guid, name, trans))
-        return false;
-
-    if (!isBGGroup())
-        CharacterDatabase.CommitTransaction(trans);
-
-    return true;
-}
-
-bool Group::LoadGroupFromDB(const uint32 &groupGuid, QueryResult result, bool loadMembers)
-{
-    if (isBGGroup())
-        return false;
-
-    Field *fields = result->Fetch();
-    m_guid = MAKE_NEW_GUID(groupGuid, 0, HIGHGUID_GROUP);
-    m_leaderGuid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
-
-    // group leader not exist
-    if (!sObjectMgr.GetPlayerNameByGUID(fields[0].GetUInt32(), m_leaderName))
-        return false;
-
-    m_lootMethod = LootMethod(fields[1].GetUInt8());
-    m_looterGuid = MAKE_NEW_GUID(fields[2].GetUInt32(), 0, HIGHGUID_PLAYER);
-    m_lootThreshold = ItemQualities(fields[3].GetUInt16());
-
-    for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
-        m_targetIcons[i] = fields[4+i].GetUInt64();
-
-    m_groupType  = GroupType(fields[12].GetUInt8());
-    if (m_groupType & GROUPTYPE_RAID)
-        _initRaidSubGroupsCounter();
-
-    uint32 diff = fields[13].GetUInt8();
-    if (diff >= MAX_DUNGEON_DIFFICULTY)
-        m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
-    else
-        m_dungeonDifficulty = Difficulty(diff);
-
-    uint32 r_diff = fields[14].GetUInt8();
-    if (r_diff >= MAX_RAID_DIFFICULTY)
-       m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
-    else
-       m_raidDifficulty = Difficulty(r_diff);
-
-    if (loadMembers)
-    {
-        //                                        0           1            2         3
-        result = CharacterDatabase.PQuery("SELECT memberGuid, memberFlags, subgroup, roles FROM group_member WHERE guid=%u", groupGuid);
-        if (!result)
-            return false;
-
-        do
-        {
-            fields = result->Fetch();
-            LoadMemberFromDB(fields[0].GetUInt32(), fields[1].GetUInt8(), fields[2].GetUInt8(), fields[3].GetUInt8());
-        } while (result->NextRow());
-
-        if (GetMembersCount() < 2)                          // group too small
-            return false;
-    }
-
-    return true;
-}
-
-bool Group::LoadMemberFromDB(uint32 guidLow, uint8 memberFlags, uint8 subgroup, uint8 roles)
-{
-    MemberSlot member;
-    member.guid = MAKE_NEW_GUID(guidLow, 0, HIGHGUID_PLAYER);
-
-    // skip non-existed member
-    if (!sObjectMgr.GetPlayerNameByGUID(member.guid, member.name))
-    {
-        CharacterDatabase.PQuery("DELETE FROM group_member WHERE memberGuid=%u", guidLow);
-        return false;
-    }
-
-    member.group = subgroup;
-    member.flags = memberFlags;
-    member.roles = roles;
-
-    m_memberSlots.push_back(member);
-
-    SubGroupCounterIncrease(subgroup);
-
-    return true;
-}
-
-void Group::ConvertToLFG()
-{
-    m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
-    m_lootMethod = NEED_BEFORE_GREED;
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), GUID_LOPART(m_guid));
-    SendUpdate();
-}
-
-void Group::ConvertToRaid()
-{
-    m_groupType = GroupType(m_groupType | GROUPTYPE_RAID);
-
-    _initRaidSubGroupsCounter();
-
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), GUID_LOPART(m_guid));
-    SendUpdate();
-
-    // update quest related GO states (quest activity dependent from raid membership)
-    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
-        if (Player* player = sObjectMgr.GetPlayer(citr->guid))
-            player->UpdateForQuestWorldObjects();
-}
-
-bool Group::AddInvite(Player *player)
-{
-    if (!player || player->GetGroupInvite())
-        return false;
-    Group* group = player->GetGroup();
-    if (group && group->isBGGroup())
-        group = player->GetOriginalGroup();
-    if (group)
-        return false;
-
-    RemoveInvite(player);
-
-    m_invitees.insert(player);
-
-    player->SetGroupInvite(this);
-
-    sScriptMgr.OnGroupInviteMember(this, player->GetGUID());
-
-    return true;
-}
-
-bool Group::AddLeaderInvite(Player *player)
-{
-    if (!AddInvite(player))
-        return false;
-
-    m_leaderGuid = player->GetGUID();
-    m_leaderName = player->GetName();
-    return true;
-}
-
-uint32 Group::RemoveInvite(Player *player)
-{
-    if (player)
-	{
-		m_invitees.erase(player);
-		player->SetGroupInvite(NULL);
-	}
-    return GetMembersCount();
-}
-
-void Group::RemoveAllInvites()
-{
-    for (InvitesList::iterator itr=m_invitees.begin(); itr != m_invitees.end(); ++itr)
-        if (*itr)
-			(*itr)->SetGroupInvite(NULL);
-
-    m_invitees.clear();
-}
-
-Player* Group::GetInvited(const uint64& guid) const
-{
-    for (InvitesList::const_iterator itr = m_invitees.begin(); itr != m_invitees.end(); ++itr)
-    {
-        if ((*itr) && (*itr)->GetGUID() == guid)
-            return (*itr);
-    }
-    return NULL;
-}
-
-Player* Group::GetInvited(const std::string& name) const
-{
-    for (InvitesList::const_iterator itr = m_invitees.begin(); itr != m_invitees.end(); ++itr)
-    {
-        if ((*itr) && (*itr)->GetName() == name)
-            return (*itr);
-    }
-    return NULL;
-}
-
-bool Group::AddMember(const uint64 &guid, const char* name, SQLTransaction& trans)
-{
-    if (isLfgQueued())
-        sLFGMgr.Leave(NULL, this);
-
-    if (!_addMember(guid, name, trans))
-        return false;
-
-    SendUpdate();
-    sScriptMgr.OnGroupAddMember(this, guid);
-
-    Player *player = sObjectMgr.GetPlayer(guid);
-    if (player)
-    {
-        if (player->isUsingLfg())
-            sLFGMgr.Leave(player);
-        if (!IsLeader(player->GetGUID()) && !isBGGroup())
-        {
-            // reset the new member's instances, unless he is currently in one of them
-            // including raid/heroic instances that they are not permanently bound to!
-            player->ResetInstances(INSTANCE_RESET_GROUP_JOIN,false);
-            player->ResetInstances(INSTANCE_RESET_GROUP_JOIN,true);
-
-            if (player->getLevel() >= LEVELREQUIREMENT_HEROIC)
-            {
-                if (player->GetDungeonDifficulty() != GetDungeonDifficulty())
-                {
-                    player->SetDungeonDifficulty(GetDungeonDifficulty());
-                    player->SendDungeonDifficulty(true);
-                }
-                if (player->GetRaidDifficulty() != GetRaidDifficulty())
-                {
-                    player->SetRaidDifficulty(GetRaidDifficulty());
-                    player->SendRaidDifficulty(true);
-                }
-            }
-        }
-        player->SetGroupUpdateFlag(GROUP_UPDATE_FULL);
-        UpdatePlayerOutOfRange(player);
-
-        // quest related GO state dependent from raid membership
-        if (isRaidGroup())
-            player->UpdateForQuestWorldObjects();
-
-        if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
-            m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
-    }
-
-    return true;
-}
-
-uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method)
-{
-    BroadcastGroupUpdate();
-
-    if (isLfgQueued())
-        sLFGMgr.Leave(NULL, this);
-    else if (isLFGGroup() && !isLfgDungeonComplete())
-        sLFGMgr.OfferContinue(this);
-
-    sScriptMgr.OnGroupRemoveMember(this, guid, method);
-
-    // remove member and change leader (if need) only if strong more 2 members _before_ member remove
-    // BG or LFG groups allow 1 member group
-    if (GetMembersCount() > ((isBGGroup() || isLFGGroup()) ? 1u : 2u))
-    {
-        bool leaderChanged = _removeMember(guid);
-
-        if (Player *player = sObjectMgr.GetPlayer(guid))
-        {
-            // quest related GO state dependent from raid membership
-            if (isRaidGroup())
-                player->UpdateForQuestWorldObjects();
-
-            WorldPacket data;
-
-            if (method == GROUP_REMOVEMETHOD_KICK)
-            {
-                data.Initialize(SMSG_GROUP_UNINVITE, 0);
-                player->GetSession()->SendPacket(&data);
-            }
-
-            player->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_LEADER);
-            if (isLFGGroup() && player->GetMap()->IsDungeon())
-                player->TeleportToBGEntryPoint();
-
-            //we already removed player from group and in player->GetGroup() is his original group!
-            if (Group* group = player->GetGroup())
-            {
-                group->SendUpdate();
-            }
-            else
-            {
-                data.Initialize(SMSG_GROUP_LIST, 1+1+1+1+8+4+4+8);
-                data << uint8(0x10) << uint8(0) << uint8(0) << uint8(0);
-                data << uint64(m_guid) << uint32(m_counter) << uint32(0) << uint64(0);
-                player->GetSession()->SendPacket(&data);
-            }
-
-            _homebindIfInstance(player);
-        }
-
-        if (leaderChanged)
-        {
-            WorldPacket data(SMSG_GROUP_SET_LEADER, (m_memberSlots.front().name.size()+1));
-            data << m_memberSlots.front().name;
-            BroadcastPacket(&data, true);
-        }
-
-        SendUpdate();
-        ResetMaxEnchantingLevel();
-    }
-    // if group before remove <= 2 disband it
-    else
-        Disband();
-
-    return m_memberSlots.size();
-}
-
-void Group::ChangeLeader(const uint64 &guid)
-{
-    member_citerator slot = _getMemberCSlot(guid);
-
-    if (slot == m_memberSlots.end())
-        return;
-
-    _setLeader(guid);
-
-    WorldPacket data(SMSG_GROUP_SET_LEADER, slot->name.size()+1);
-    data << slot->name;
-    BroadcastPacket(&data, true);
-    SendUpdate();
-}
-
-void Group::Disband(bool hideDestroy /* = false */)
-{
-    sScriptMgr.OnGroupDisband(this);
-
-    Player *player;
-    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
-    {
-        player = sObjectMgr.GetPlayer(citr->guid);
-        if (!player)
-            continue;
-
-        //we cannot call _removeMember because it would invalidate member iterator
-        //if we are removing player from battleground raid
-        if (isBGGroup())
-            player->RemoveFromBattlegroundRaid();
-        else
-        {
-            //we can remove player who is in battleground from his original group
-            if (player->GetOriginalGroup() == this)
-                player->SetOriginalGroup(NULL);
-            else
-                player->SetGroup(NULL);
-
-            if (isLFGGroup() && player->GetMap()->IsDungeon())
-                player->TeleportToBGEntryPoint();
-            player->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_GROUP_DISBAND);
-            player->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_LEADER);
-        }
-
-        // quest related GO state dependent from raid membership
-        if (isRaidGroup())
-            player->UpdateForQuestWorldObjects();
-
-        if (!player->GetSession())
-            continue;
-
-        WorldPacket data;
-        if (!hideDestroy)
-        {
-            data.Initialize(SMSG_GROUP_DESTROYED, 0);
-            player->GetSession()->SendPacket(&data);
-        }
-
-        //we already removed player from group and in player->GetGroup() is his original group, send update
-        if (Group* group = player->GetGroup())
-        {
-            group->SendUpdate();
-        }
-        else
-        {
-            data.Initialize(SMSG_GROUP_LIST, 1+1+1+1+8+4+4+8);
-            data << uint8(0x10) << uint8(0) << uint8(0) << uint8(0);
-            data << uint64(m_guid) << uint32(m_counter) << uint32(0) << uint64(0);
-            player->GetSession()->SendPacket(&data);
-        }
-
-        _homebindIfInstance(player);
-    }
-    RollId.clear();
-    m_memberSlots.clear();
-
-    RemoveAllInvites();
-
-    if (!isBGGroup())
-    {
-        uint32 lowguid = GUID_LOPART(m_guid);
-        SQLTransaction trans = CharacterDatabase.BeginTransaction();
-        trans->PAppend("DELETE FROM groups WHERE guid=%u", lowguid);
-        trans->PAppend("DELETE FROM group_member WHERE guid=%u", lowguid);
-        CharacterDatabase.CommitTransaction(trans);
-        ResetInstances(INSTANCE_RESET_GROUP_DISBAND, false, NULL);
-        ResetInstances(INSTANCE_RESET_GROUP_DISBAND, true, NULL);
-    }
-
-    m_guid = 0;
-    m_leaderGuid = 0;
-    m_leaderName = "";
-}
-
-/*********************************************************/
-/***                   LOOT SYSTEM                     ***/
-/*********************************************************/
-
-void Group::SendLootStartRoll(uint32 CountDown, uint32 mapid, const Roll &r)
-{
-    WorldPacket data(SMSG_LOOT_START_ROLL, (8+4+4+4+4+4+4+1));
-    data << uint64(r.itemGUID);                             // guid of rolled item
-    data << uint32(mapid);                                  // 3.3.3 mapid
-    data << uint32(r.totalPlayersRolling);                  // maybe the number of players rolling for it???
-    data << uint32(r.itemid);                               // the itemEntryId for the item that shall be rolled for
-    data << uint32(r.itemRandomSuffix);                     // randomSuffix
-    data << uint32(r.itemRandomPropId);                     // item random property ID
-    data << uint32(r.itemCount);                            // items in stack
-    data << uint32(CountDown);                              // the countdown time to choose "need" or "greed"
-    data << uint8(r.rollVoteMask);                          // roll type mask
-
-    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
-    {
-        Player *p = sObjectMgr.GetPlayer(itr->first);
-        if (!p || !p->GetSession())
-            continue;
-
-        if (itr->second == NOT_EMITED_YET)
-            p->GetSession()->SendPacket(&data);
-    }
-}
-
-void Group::SendLootRoll(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r)
-{
-    WorldPacket data(SMSG_LOOT_ROLL, (8+4+8+4+4+4+1+1+1));
-    data << uint64(SourceGuid);                             // guid of the item rolled
-    data << uint32(0);                                      // unknown, maybe amount of players
-    data << uint64(TargetGuid);
-    data << uint32(r.itemid);                               // the itemEntryId for the item that shall be rolled for
-    data << uint32(r.itemRandomSuffix);                     // randomSuffix
-    data << uint32(r.itemRandomPropId);                     // Item random property ID
-    data << uint8(RollNumber);                              // 0: "Need for: [item name]" > 127: "you passed on: [item name]"      Roll number
-    data << uint8(RollType);                                // 0: "Need for: [item name]" 0: "You have selected need for [item name] 1: need roll 2: greed roll
-    data << uint8(0);                                       // auto pass on NeedBeforeGreed loot because player cannot use the object
-
-    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
-    {
-        Player *p = sObjectMgr.GetPlayer(itr->first);
-        if (!p || !p->GetSession())
-            continue;
-
-        if (itr->second != NOT_VALID)
-            p->GetSession()->SendPacket(&data);
-    }
-}
-
-void Group::SendLootRollWon(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r)
-{
-    WorldPacket data(SMSG_LOOT_ROLL_WON, (8+4+4+4+4+8+1+1));
-    data << uint64(SourceGuid);                             // guid of the item rolled
-    data << uint32(0);                                      // unknown, maybe amount of players
-    data << uint32(r.itemid);                               // the itemEntryId for the item that shall be rolled for
-    data << uint32(r.itemRandomSuffix);                     // randomSuffix
-    data << uint32(r.itemRandomPropId);                     // Item random property
-    data << uint64(TargetGuid);                             // guid of the player who won.
-    data << uint8(RollNumber);                              // rollnumber realted to SMSG_LOOT_ROLL
-    data << uint8(RollType);                                // Rolltype related to SMSG_LOOT_ROLL
-
-    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
-    {
-        Player *p = sObjectMgr.GetPlayer(itr->first);
-        if (!p || !p->GetSession())
-            continue;
-
-        if (itr->second != NOT_VALID)
-            p->GetSession()->SendPacket(&data);
-    }
-}
-
-void Group::SendLootAllPassed(uint32 NumberOfPlayers, const Roll &r)
-{
-    WorldPacket data(SMSG_LOOT_ALL_PASSED, (8+4+4+4+4));
-    data << uint64(r.itemGUID);                             // Guid of the item rolled
-    data << uint32(NumberOfPlayers);                        // The number of players rolling for it???
-    data << uint32(r.itemid);                               // The itemEntryId for the item that shall be rolled for
-    data << uint32(r.itemRandomPropId);                     // Item random property ID
-    data << uint32(r.itemRandomSuffix);                     // Item random suffix ID
-
-    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
-    {
-        Player *p = sObjectMgr.GetPlayer(itr->first);
-        if (!p || !p->GetSession())
-            continue;
-
-        if (itr->second != NOT_VALID)
-            p->GetSession()->SendPacket(&data);
-    }
-}
-
-// notify group members which player is the allowed looter for the given creature
-void Group::SendLooter(Creature *pCreature, Player *pLooter)
-{
-    ASSERT(pCreature);
-
-    WorldPacket data(SMSG_LOOT_LIST, (8+8));
-    data << uint64(pCreature->GetGUID());
-    data << uint8(0); // unk1
-
-    if (pLooter)
-        data.append(pLooter->GetPackGUID());
-    else
-        data << uint8(0);
-
-    BroadcastPacket(&data, false);
-}
-
-void Group::GroupLoot(Loot *loot, WorldObject* pLootedObject)
-{
-    std::vector<LootItem>::iterator i;
-    ItemPrototype const *item;
-    uint8 itemSlot = 0;
-
-    for (i = loot->items.begin(); i != loot->items.end(); ++i, ++itemSlot)
-    {
-        if (i->freeforall)
-            continue;
-
-        item = sObjectMgr.GetItemPrototype(i->itemid);
-        if (!item)
-        {
-            //sLog.outDebug("Group::GroupLoot: missing item prototype for item with id: %d", i->itemid);
-            continue;
-        }
-
-        //roll for over-threshold item if it's one-player loot
-        if (item->Quality >= uint32(m_lootThreshold))
-        {
-            uint64 newitemGUID = MAKE_NEW_GUID(sObjectMgr.GenerateLowGuid(HIGHGUID_ITEM),0,HIGHGUID_ITEM);
-            Roll* r = new Roll(newitemGUID,*i);
-
-            //a vector is filled with only near party members
-            for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player *member = itr->getSource();
-                if (!member || !member->GetSession())
-                    continue;
-                if (i->AllowedForPlayer(member))
-                {
-                    if (member->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
-                    {
-
-                        r->totalPlayersRolling++;
-
-                        if (member->GetPassOnGroupLoot())
-                        {
-                            r->playerVote[member->GetGUID()] = PASS;
-                            r->totalPass++;
-                            // can't broadcast the pass now. need to wait until all rolling players are known.
-                        }
-                        else
-                            r->playerVote[member->GetGUID()] = NOT_EMITED_YET;
-                    }
-                }
-            }
-
-            if (r->totalPlayersRolling > 0)
-            {
-                r->setLoot(loot);
-                r->itemSlot = itemSlot;
-                if (item->DisenchantID && m_maxEnchantingLevel >= item->RequiredDisenchantSkill)
-                    r->rollVoteMask |= ROLL_FLAG_TYPE_DISENCHANT;
-
-                loot->items[itemSlot].is_blocked = true;
-
-                // If there is any "auto pass", broadcast the pass now.
-                if (r->totalPass)
-                {
-                    for (Roll::PlayerVote::const_iterator itr=r->playerVote.begin(); itr != r->playerVote.end(); ++itr)
-                    {
-                        Player *p = sObjectMgr.GetPlayer(itr->first);
-                        if (!p || !p->GetSession())
-                            continue;
-
-                        if (itr->second == PASS)
-                            SendLootRoll(newitemGUID, p->GetGUID(), 128, ROLL_PASS, *r);
-                    }
-                }
-
-                SendLootStartRoll(60000, pLootedObject->GetMapId(), *r);
-
-                RollId.push_back(r);
-
-                if (Creature* creature = dynamic_cast<Creature *>(pLootedObject))
-                {
-                    creature->m_groupLootTimer = 60000;
-                    creature->lootingGroupLowGUID = GetLowGUID();
-                }
-                else if (GameObject* go = dynamic_cast<GameObject *>(pLootedObject))
-                {
-                    go->m_groupLootTimer = 60000;
-                    go->lootingGroupLowGUID = GetLowGUID();
-                }
-            }
-            else
-                delete r;
-        }
-        else
-            i->is_underthreshold = true;
-    }
-}
-
-void Group::NeedBeforeGreed(Loot *loot, WorldObject* pLootedObject)
-{
-    ItemPrototype const *item;
-    uint8 itemSlot = 0;
-    for (std::vector<LootItem>::iterator i=loot->items.begin(); i != loot->items.end(); ++i, ++itemSlot)
-    {
-        if (i->freeforall)
-            continue;
-
-        item = sObjectMgr.GetItemPrototype(i->itemid);
-
-        //roll for over-threshold item if it's one-player loot
-        if (item->Quality >= uint32(m_lootThreshold))
-        {
-            uint64 newitemGUID = MAKE_NEW_GUID(sObjectMgr.GenerateLowGuid(HIGHGUID_ITEM),0,HIGHGUID_ITEM);
-            Roll* r=new Roll(newitemGUID,*i);
-
-            for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player *playerToRoll = itr->getSource();
-                if (!playerToRoll || !playerToRoll->GetSession())
-                    continue;
-
-                bool allowedForPlayer = i->AllowedForPlayer(playerToRoll);
-                if (playerToRoll->CanUseItem(item) == EQUIP_ERR_OK && allowedForPlayer)
-                {
-                    if (playerToRoll->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
-                    {
-                        r->totalPlayersRolling++;
-
-                        if (playerToRoll->GetPassOnGroupLoot())
-                        {
-                            r->playerVote[playerToRoll->GetGUID()] = PASS;
-                            r->totalPass++;
-                            // can't broadcast the pass now. need to wait until all rolling players are known.
-                        }
-                        else
-                            r->playerVote[playerToRoll->GetGUID()] = NOT_EMITED_YET;
-                    }
-                }
-            }
-
-            if (r->totalPlayersRolling > 0)
-            {
-                r->setLoot(loot);
-                r->itemSlot = itemSlot;
-                if (item->DisenchantID && m_maxEnchantingLevel >= item->RequiredDisenchantSkill)
-                    r->rollVoteMask |= ROLL_FLAG_TYPE_DISENCHANT;
-
-                if (item->Flags2 & ITEM_FLAGS_EXTRA_NEED_ROLL_DISABLED)
-                    r->rollVoteMask &= ~ROLL_FLAG_TYPE_NEED;
-
-                loot->items[itemSlot].is_blocked = true;
-
-                // If there is any "auto pass", broadcast the pass now.
-                if (r->totalPass)
-                {
-                    for (Roll::PlayerVote::const_iterator itr=r->playerVote.begin(); itr != r->playerVote.end(); ++itr)
-                    {
-                        Player *p = sObjectMgr.GetPlayer(itr->first);
-                        if (!p || !p->GetSession())
-                            continue;
-
-                        if (itr->second == PASS)
-                            SendLootRoll(newitemGUID, p->GetGUID(), 128, ROLL_PASS, *r);
-                    }
-                }
-
-                SendLootStartRoll(60000, pLootedObject->GetMapId(), *r);
-
-                RollId.push_back(r);
-
-                if (Creature* creature = dynamic_cast<Creature *>(pLootedObject))
-                {
-                    creature->m_groupLootTimer = 60000;
-                    creature->lootingGroupLowGUID = GetLowGUID();
-                }
-            }
-            else
-                delete r;
-        }
-        else
-            i->is_underthreshold = true;
-    }
-}
-
-void Group::MasterLoot(Loot* /*loot*/, WorldObject* pLootedObject)
-{
-    sLog.outDebug("Group::MasterLoot (SMSG_LOOT_MASTER_LIST, 330)");
-
-    uint32 real_count = 0;
-
-    WorldPacket data(SMSG_LOOT_MASTER_LIST, 330);
-    data << (uint8)GetMembersCount();
-
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player *looter = itr->getSource();
-        if (!looter->IsInWorld())
-            continue;
-
-        if (looter->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
-        {
-            data << uint64(looter->GetGUID());
-            ++real_count;
-        }
-    }
-
-    data.put<uint8>(0,real_count);
-
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player *looter = itr->getSource();
-        if (looter->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
-            looter->GetSession()->SendPacket(&data);
-    }
-}
-
-void Group::CountRollVote(const uint64& playerGUID, const uint64& Guid, uint32 NumberOfPlayers, uint8 Choice)
-{
-    Rolls::iterator rollI = GetRoll(Guid);
-    if (rollI == RollId.end())
-        return;
-    Roll* roll = *rollI;
-
-    Roll::PlayerVote::iterator itr = roll->playerVote.find(playerGUID);
-    // this condition means that player joins to the party after roll begins
-    if (itr == roll->playerVote.end())
-        return;
-
-    if (roll->getLoot())
-        if (roll->getLoot()->items.empty())
-            return;
-
-    switch (Choice)
-    {
-        case ROLL_PASS:                                     // Player choose pass
-            SendLootRoll(0, playerGUID, 128, ROLL_PASS, *roll);
-            ++roll->totalPass;
-            itr->second = PASS;
-            break;
-        case ROLL_NEED:                                     // player choose Need
-            SendLootRoll(0, playerGUID, 0, 0, *roll);
-            ++roll->totalNeed;
-            itr->second = NEED;
-            break;
-        case ROLL_GREED:                                    // player choose Greed
-            SendLootRoll(0, playerGUID, 128, ROLL_GREED, *roll);
-            ++roll->totalGreed;
-            itr->second = GREED;
-            break;
-        case ROLL_DISENCHANT:                               // player choose Disenchant
-            SendLootRoll(0, playerGUID, 128, ROLL_DISENCHANT, *roll);
-            ++roll->totalGreed;
-            itr->second = DISENCHANT;
-            break;
-    }
-
-    if (roll->totalPass + roll->totalNeed + roll->totalGreed >= roll->totalPlayersRolling)
-        CountTheRoll(rollI, NumberOfPlayers);
-}
-
-//called when roll timer expires
-void Group::EndRoll(Loot *pLoot)
-{
-    for (Rolls::iterator itr = RollId.begin(); itr != RollId.end();)
-    {
-        if ((*itr)->getLoot() == pLoot) {
-            CountTheRoll(itr, GetMembersCount());           //i don't have to edit player votes, who didn't vote ... he will pass
-            itr = RollId.begin();
-        }
-        else
-            itr++;
-    }
-}
-
-void Group::CountTheRoll(Rolls::iterator rollI, uint32 NumberOfPlayers)
-{
-    Roll* roll = *rollI;
-    if (!roll->isValid())                                   // is loot already deleted ?
-    {
-        RollId.erase(rollI);
-        delete roll;
-        return;
-    }
-
-    //end of the roll
-    if (roll->totalNeed > 0)
-    {
-        if (!roll->playerVote.empty())
-        {
-            uint8 maxresul = 0;
-            uint64 maxguid  = (*roll->playerVote.begin()).first;
-            Player *player;
-
-            for (Roll::PlayerVote::const_iterator itr=roll->playerVote.begin(); itr != roll->playerVote.end(); ++itr)
-            {
-                if (itr->second != NEED)
-                    continue;
-
-                uint8 randomN = urand(1, 100);
-                SendLootRoll(0, itr->first, randomN, ROLL_NEED, *roll);
-                if (maxresul < randomN)
-                {
-                    maxguid  = itr->first;
-                    maxresul = randomN;
-                }
-            }
-            SendLootRollWon(0, maxguid, maxresul, ROLL_NEED, *roll);
-            player = sObjectMgr.GetPlayer(maxguid);
-
-            if (player && player->GetSession())
-            {
-                player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED_ON_LOOT, roll->itemid, maxresul);
-
-                ItemPosCountVec dest;
-                LootItem *item = &(roll->getLoot()->items[roll->itemSlot]);
-                uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, roll->itemid, item->count);
-                if (msg == EQUIP_ERR_OK)
-                {
-                    item->is_looted = true;
-                    roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
-                    roll->getLoot()->unlootedCount--;
-                    AllowedLooterSet* looters = item->GetAllowedLooters();
-                    player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, (looters->size() > 1) ? looters : NULL);
-                }
-                else
-                {
-                    item->is_blocked = false;
-                    player->SendEquipError(msg, NULL, NULL, roll->itemid);
-                }
-            }
-        }
-    }
-    else if (roll->totalGreed > 0)
-    {
-        if (!roll->playerVote.empty())
-        {
-            uint8 maxresul = 0;
-            uint64 maxguid = (*roll->playerVote.begin()).first;
-            Player *player;
-            RollVote rollvote = NOT_VALID;
-
-            Roll::PlayerVote::iterator itr;
-            for (itr = roll->playerVote.begin(); itr != roll->playerVote.end(); ++itr)
-            {
-                if (itr->second != GREED && itr->second != DISENCHANT)
-                    continue;
-
-                uint8 randomN = urand(1, 100);
-                SendLootRoll(0, itr->first, randomN, itr->second, *roll);
-                if (maxresul < randomN)
-                {
-                    maxguid  = itr->first;
-                    maxresul = randomN;
-                    rollvote = itr->second;
-                }
-            }
-            SendLootRollWon(0, maxguid, maxresul, rollvote, *roll);
-            player = sObjectMgr.GetPlayer(maxguid);
-
-            if (player && player->GetSession())
-            {
-                player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED_ON_LOOT, roll->itemid, maxresul);
-
-                LootItem *item = &(roll->getLoot()->items[roll->itemSlot]);
-
-                if (rollvote == GREED)
-                {
-                    ItemPosCountVec dest;
-                    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, roll->itemid, item->count);
-                    if (msg == EQUIP_ERR_OK)
-                    {
-                        item->is_looted = true;
-                        roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
-                        roll->getLoot()->unlootedCount--;
-                        AllowedLooterSet* looters = item->GetAllowedLooters();
-                        player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, (looters->size() > 1) ? looters : NULL);
-                    }
-                    else
-                    {
-                        item->is_blocked = false;
-                        player->SendEquipError(msg, NULL, NULL, roll->itemid);
-                    }
-                }
-                else if (rollvote == DISENCHANT)
-                {
-                    item->is_looted = true;
-                    roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
-                    roll->getLoot()->unlootedCount--;
-                    ItemPrototype const *pProto = ObjectMgr::GetItemPrototype(roll->itemid);
-                    player->AutoStoreLoot(pProto->DisenchantID, LootTemplates_Disenchant, true);
-                }
-            }
-        }
-    }
-    else
-    {
-        SendLootAllPassed(NumberOfPlayers, *roll);
-
-        // remove is_blocked so that the item is lootable by all players
-        LootItem *item = &(roll->getLoot()->items[roll->itemSlot]);
-        if (item)
-            item->is_blocked = false;
-    }
-
-    RollId.erase(rollI);
-    delete roll;
-}
-
-void Group::SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid)
-{
-    if (id >= TARGETICONCOUNT)
-        return;
-
-    // clean other icons
-    if (targetGuid != 0)
-        for (int i=0; i<TARGETICONCOUNT; ++i)
-            if (m_targetIcons[i] == targetGuid)
-                SetTargetIcon(i, 0, 0);
-
-    m_targetIcons[id] = targetGuid;
-
-    WorldPacket data(MSG_RAID_TARGET_UPDATE, (1+8+1+8));
-    data << uint8(0);                                       // set targets
-    data << uint64(whoGuid);
-    data << uint8(id);
-    data << uint64(targetGuid);
-    BroadcastPacket(&data, true);
-}
-
-void Group::GetDataForXPAtKill(Unit const* victim, uint32& count,uint32& sum_level, Player* & member_with_max_level, Player* & not_gray_member_with_max_level)
-{
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player* member = itr->getSource();
-        if (!member || !member->isAlive())                   // only for alive
-            continue;
-
-        if (!member->IsAtGroupRewardDistance(victim))        // at req. distance
-            continue;
-
-        ++count;
-        sum_level += member->getLevel();
-        if (!member_with_max_level || member_with_max_level->getLevel() < member->getLevel())
-            member_with_max_level = member;
-
-        uint32 gray_level = Trinity::XP::GetGrayLevel(member->getLevel());
-        if (victim->getLevel() > gray_level && (!not_gray_member_with_max_level || not_gray_member_with_max_level->getLevel() < member->getLevel()))
-            not_gray_member_with_max_level = member;
-    }
-}
-
-void Group::SendTargetIconList(WorldSession *session)
-{
-    if (!session)
-        return;
-
-    WorldPacket data(MSG_RAID_TARGET_UPDATE, (1+TARGETICONCOUNT*9));
-    data << uint8(1);                                       // list targets
-
-    for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
-    {
-        if (m_targetIcons[i] == 0)
-            continue;
-
-        data << uint8(i);
-        data << uint64(m_targetIcons[i]);
-    }
-
-    session->SendPacket(&data);
-}
-
-void Group::SendUpdate()
-{
-    Player *player;
-    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
-    {
-        player = sObjectMgr.GetPlayer(citr->guid);
-        if (!player || !player->GetSession() || player->GetGroup() != this)
-            continue;
-
-        WorldPacket data(SMSG_GROUP_LIST, (1+1+1+1+1+4+8+4+4+(GetMembersCount()-1)*(13+8+1+1+1+1)+8+1+8+1+1+1+1));
-        data << uint8(m_groupType);                         // group type (flags in 3.3)
-        data << uint8(citr->group);
-        data << uint8(citr->flags);
-        data << uint8(citr->roles);
-        if (isLFGGroup())
-        {            
-            data << uint8(m_LfgStatus);
-            data << uint32(m_LfgDungeonEntry);
-        }
-
-        data << uint64(m_guid);
-        data << uint32(m_counter++);                        // 3.3, value increases every time this packet gets sent
-        data << uint32(GetMembersCount()-1);
-        for (member_citerator citr2 = m_memberSlots.begin(); citr2 != m_memberSlots.end(); ++citr2)
-        {
-            if (citr->guid == citr2->guid)
-                continue;
-
-            Player* member = sObjectMgr.GetPlayer(citr2->guid);
-
-            uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
-            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
-
-            data << citr2->name;
-            data << uint64(citr2->guid);                    // guid
-            data << uint8(onlineState);                     // online-state
-            data << uint8(citr2->group);                    // groupid
-            data << uint8(citr2->flags);                    // See enum GroupMemberFlags
-            data << uint8(citr2->roles);                    // Lfg Roles
-        }
-
-        data << uint64(m_leaderGuid);                       // leader guid
-
-        if (GetMembersCount() - 1)
-        {
-            data << uint8(m_lootMethod);                    // loot method
-            data << uint64(m_looterGuid);                   // looter guid
-            data << uint8(m_lootThreshold);                 // loot threshold
-            data << uint8(m_dungeonDifficulty);             // Dungeon Difficulty
-            data << uint8(m_raidDifficulty);                // Raid Difficulty
-            data << uint8(0);                               // 3.3
-        }
-
-        player->GetSession()->SendPacket(&data);
-    }
-}
-
-void Group::UpdatePlayerOutOfRange(Player* pPlayer)
-{
-    if (!pPlayer || !pPlayer->IsInWorld())
-        return;
-
-    Player *player;
-    WorldPacket data;
-    pPlayer->GetSession()->BuildPartyMemberStatsChangedPacket(pPlayer, &data);
-
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        player = itr->getSource();
-        if (player && player != pPlayer && !pPlayer->isVisibleFor(player))
-            player->GetSession()->SendPacket(&data);
-    }
-}
-
-void Group::BroadcastPacket(WorldPacket *packet, bool ignorePlayersInBGRaid, int group, uint64 ignore)
-{
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player *pl = itr->getSource();
-        if (!pl || (ignore != 0 && pl->GetGUID() == ignore) || (ignorePlayersInBGRaid && pl->GetGroup() != this))
-            continue;
-
-        if (pl->GetSession() && (group == -1 || itr->getSubGroup() == group))
-            pl->GetSession()->SendPacket(packet);
-    }
-}
-
-void Group::BroadcastReadyCheck(WorldPacket *packet)
-{
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player *pl = itr->getSource();
-        if (pl && pl->GetSession())
-            if (IsLeader(pl->GetGUID()) || IsAssistant(pl->GetGUID()))
-                pl->GetSession()->SendPacket(packet);
-    }
-}
-
-void Group::OfflineReadyCheck()
-{
-    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
-    {
-        Player *pl = sObjectMgr.GetPlayer(citr->guid);
-        if (!pl || !pl->GetSession())
-        {
-            WorldPacket data(MSG_RAID_READY_CHECK_CONFIRM, 9);
-            data << uint64(citr->guid);
-            data << uint8(0);
-            BroadcastReadyCheck(&data);
-        }
-    }
-}
-
-bool Group::_addMember(const uint64 &guid, const char* name, SQLTransaction& trans)
-{
-    // get first not-full group
-    uint8 groupid = 0;
-    if (m_subGroupsCounts)
-    {
-        bool groupFound = false;
-        for (; groupid < MAX_RAID_SUBGROUPS; ++groupid)
-        {
-            if (m_subGroupsCounts[groupid] < MAXGROUPSIZE)
-            {
-                groupFound = true;
-                break;
-            }
-        }
-        // We are raid group and no one slot is free
-        if (!groupFound)
-            return false;
-    }
-
-    return _addMember(guid, name, groupid, trans);
-}
-
-bool Group::_addMember(const uint64 &guid, const char* name, uint8 group, SQLTransaction& trans)
-{
-    if (IsFull())
-        return false;
-
-    if (!guid)
-        return false;
-
-    Player *player = sObjectMgr.GetPlayer(guid);
-
-    MemberSlot member;
-    member.guid      = guid;
-    member.name      = name;
-    member.group     = group;
-    member.flags     = 0;
-    member.roles     = 0;
-    m_memberSlots.push_back(member);
-
-    SubGroupCounterIncrease(group);
-
-    if (player)
-    {
-        player->SetGroupInvite(NULL);
-        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
-            player->SetBattlegroundRaid(this, group);
-        else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
-            player->SetOriginalGroup(this, group);
-        else //if player is not in group, then call set group
-            player->SetGroup(this, group);
-
-        // if the same group invites the player back, cancel the homebind timer
-        InstanceGroupBind *bind = GetBoundInstance(player);
-        if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
-            player->m_InstanceValid = true;
-    }
-
-    if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
-    {
-        for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
-            m_targetIcons[i] = 0;
-    }
-
-    // insert into the table if we're not a battleground group
-    if (!isBGGroup())
-        trans->PAppend("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)", GUID_LOPART(m_guid), GUID_LOPART(member.guid), member.flags, member.group, member.roles);
-
-    return true;
-}
-
-bool Group::_removeMember(const uint64 &guid)
-{
-    Player *player = sObjectMgr.GetPlayer(guid);
-    if (player)
-    {
-        //if we are removing player from battleground raid
-        if (isBGGroup())
-            player->RemoveFromBattlegroundRaid();
-        else
-        {
-            //we can remove player who is in battleground from his original group
-            if (player->GetOriginalGroup() == this)
-                player->SetOriginalGroup(NULL);
-            else
-                player->SetGroup(NULL);
-
-            player->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_LEADER);
-        }
-    }
-
-    _removeRolls(guid);
-
-    member_witerator slot = _getMemberWSlot(guid);
-    if (slot != m_memberSlots.end())
-    {
-        SubGroupCounterDecrease(slot->group);
-        m_memberSlots.erase(slot);
-    }
-
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
-
-    if (m_leaderGuid == guid)                                // leader was removed
-    {
-        if (GetMembersCount() > 0)
-            _setLeader(m_memberSlots.front().guid);
-        return true;
-    }
-
-    return false;
-}
-
-void Group::_setLeader(const uint64 &guid)
-{
-    member_witerator slot = _getMemberWSlot(guid);
-    if (slot == m_memberSlots.end())
-        return;
-
-    sScriptMgr.OnGroupChangeLeader(this, m_leaderGuid, guid);
-
-    if (!isBGGroup())
-    {
-        // TODO: set a time limit to have this function run rarely cause it can be slow
-        SQLTransaction trans = CharacterDatabase.BeginTransaction();
-
-        // update the group's bound instances when changing leaders
-        // remove all permanent binds from the group
-        // in the DB also remove solo binds that will be replaced with permbinds
-        // from the new leader
-        trans->PAppend(
-            "DELETE FROM group_instance WHERE guid=%u AND (permanent = 1 OR "
-            "instance IN (SELECT instance FROM character_instance WHERE guid = '%u')"
-            ")", GUID_LOPART(m_guid), GUID_LOPART(slot->guid)
-        );
-
-        Player *player = sObjectMgr.GetPlayer(slot->guid);
-        if (player)
-        {
-            for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
-            {
-                for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end();)
-                {
-                    if (itr->second.perm)
-                    {
-                        itr->second.save->RemoveGroup(this);
-                        m_boundInstances[i].erase(itr++);
-                    }
-                    else
-                        ++itr;
-                }
-            }
-        }
-
-        // copy the permanent binds from the new leader to the group
-        // overwriting the solo binds with permanent ones if necessary
-        // in the DB those have been deleted already
-        Player::ConvertInstancesToGroup(player, this, slot->guid);
-
-        // update the group leader
-        trans->PAppend("UPDATE groups SET leaderGuid='%u' WHERE guid='%u'", GUID_LOPART(slot->guid), GUID_LOPART(m_guid));
-        CharacterDatabase.CommitTransaction(trans);
-    }
-
-    m_leaderGuid = slot->guid;
-    m_leaderName = slot->name;
-    ToggleGroupMemberFlag(slot, MEMBER_FLAG_ASSISTANT, false);
-}
-
-void Group::_removeRolls(const uint64 &guid)
-{
-    for (Rolls::iterator it = RollId.begin(); it != RollId.end(); ++it)
-    {
-        Roll* roll = *it;
-        Roll::PlayerVote::iterator itr2 = roll->playerVote.find(guid);
-        if (itr2 == roll->playerVote.end())
-            continue;
-
-        if (itr2->second == GREED || itr2->second == DISENCHANT)
-            --roll->totalGreed;
-        else if (itr2->second == NEED)
-            --roll->totalNeed;
-        else if (itr2->second == PASS)
-            --roll->totalPass;
-
-        if (itr2->second != NOT_VALID)
-            --roll->totalPlayersRolling;
-
-        roll->playerVote.erase(itr2);
-
-        CountRollVote(guid, roll->itemGUID, GetMembersCount()-1, MAX_ROLL_TYPE);
-    }
-}
-
-bool Group::_setMembersGroup(const uint64 &guid, const uint8 &group)
-{
-    member_witerator slot = _getMemberWSlot(guid);
-    if (slot == m_memberSlots.end())
-        return false;
-
-    slot->group = group;
-
-    SubGroupCounterIncrease(group);
-
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
-
-    return true;
-}
-
-bool Group::_setAssistantFlag(const uint64 &guid, const bool &apply)
-{
-    member_witerator slot = _getMemberWSlot(guid);
-    if (slot == m_memberSlots.end())
-        return false;
-
-    ToggleGroupMemberFlag(slot, MEMBER_FLAG_ASSISTANT, apply);
-
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
-
-    return true;
-}
-
-bool Group::_setMainTank(const uint64 &guid, const bool &apply)
-{
-    member_witerator slot = _getMemberWSlot(guid);  // First check member slots to see if the target exists
-    if (slot == m_memberSlots.end())
-        return false;
-
-    RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINTANK);          // Remove main tank flag from current if any.
-    ToggleGroupMemberFlag(slot, MEMBER_FLAG_MAINTANK, apply);   // And apply main tank flag on new main tank.
-
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
-
-    return true;
-}
-
-bool Group::_setMainAssistant(const uint64 &guid, const bool &apply)
-{
-    member_witerator slot = _getMemberWSlot(guid);
-    if (slot == m_memberSlots.end())
-        return false;
-
-    RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINASSIST);         // Remove main assist flag from current if any.
-    ToggleGroupMemberFlag(slot, MEMBER_FLAG_MAINASSIST, apply);  // Apply main assist flag on new main assist.
-
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
-
-    return true;
-}
-
-bool Group::SameSubGroup(Player const* member1, Player const* member2) const
-{
-    if (!member1 || !member2)
-        return false;
-    if (member1->GetGroup() != this || member2->GetGroup() != this)
-        return false;
-    else
-        return member1->GetSubGroup() == member2->GetSubGroup();
-}
-
-// allows setting subgroup for offline members
-void Group::ChangeMembersGroup(const uint64 &guid, const uint8 &group)
-{
-    if (!isRaidGroup())
-        return;
-
-    Player *player = sObjectMgr.GetPlayer(guid);
-
-    if (!player)
-    {
-        uint8 prevSubGroup = GetMemberGroup(guid);
-        if (prevSubGroup == group)
-            return;
-
-        if (_setMembersGroup(guid, group))
-        {
-            SubGroupCounterDecrease(prevSubGroup);
-            SendUpdate();
-        }
-    }
-    else
-        // This methods handles itself groupcounter decrease
-        ChangeMembersGroup(player, group);
-}
-
-// only for online members
-void Group::ChangeMembersGroup(Player *player, const uint8 &group)
-{
-    if (!player || !isRaidGroup())
-        return;
-
-    uint8 prevSubGroup = player->GetSubGroup();
-    if (prevSubGroup == group)
-        return;
-
-    if (_setMembersGroup(player->GetGUID(), group))
-    {
-        if (player->GetGroup() == this)
-            player->GetGroupRef().setSubGroup(group);
-        else
-        {
-            //if player is in BG raid, it is possible that he is also in normal raid - and that normal raid is stored in m_originalGroup reference
-            prevSubGroup = player->GetOriginalSubGroup();
-            player->GetOriginalGroupRef().setSubGroup(group);
-        }
-
-        SubGroupCounterDecrease(prevSubGroup);
-        SendUpdate();
-    }
-}
-
-// Retrieve the next Round-Roubin player for the group
-//
-// No update done if loot method is Master or FFA.
-//
-// If the RR player is not yet set for the group, the first group member becomes the round-robin player.
-// If the RR player is set, the next player in group becomes the round-robin player.
-//
-// If ifneed is true,
-//      the current RR player is checked to be near the looted object.
-//      if yes, no update done.
-//      if not, he looses his turn.
-void Group::UpdateLooterGuid(WorldObject* pLootedObject, bool ifneed)
-{
-    switch (GetLootMethod())
-    {
-        case MASTER_LOOT:
-        case FREE_FOR_ALL:
-            return;
-        default:
-            // round robin style looting applies for all low
-            // quality items in each loot method except free for all and master loot
-            break;
-    }
-
-    uint64 oldLooterGUID = GetLooterGuid();
-    member_citerator guid_itr = _getMemberCSlot(oldLooterGUID);
-    if (guid_itr != m_memberSlots.end())
-    {
-        if (ifneed)
-        {
-            // not update if only update if need and ok
-            Player* looter = ObjectAccessor::FindPlayer(guid_itr->guid);
-            if (looter && looter->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
-                return;
-        }
-        ++guid_itr;
-    }
-
-    // search next after current
-    Player *pNewLooter = NULL;
-    for (member_citerator itr = guid_itr; itr != m_memberSlots.end(); ++itr)
-    {
-        if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
-            if (pl->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
-            {
-                pNewLooter = pl;
-                break;
-            }
-    }
-
-    if (!pNewLooter)
-    {
-        // search from start
-        for (member_citerator itr = m_memberSlots.begin(); itr != guid_itr; ++itr)
-        {
-            if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
-                if (pl->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
-                {
-                    pNewLooter = pl;
-                    break;
-                }
-        }
-    }
-
-    if (pNewLooter)
-    {
-        if (oldLooterGUID != pNewLooter->GetGUID())
-        {
-            SetLooterGuid(pNewLooter->GetGUID());
-            SendUpdate();
-        }
-    }
-    else
-    {
-        SetLooterGuid(0);
-        SendUpdate();
-    }
-}
-
-GroupJoinBattlegroundResult Group::CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 /*MaxPlayerCount*/, bool isRated, uint32 arenaSlot)
-{
-    BattlemasterListEntry const* bgEntry = sBattlemasterListStore.LookupEntry(bgOrTemplate->GetTypeID());
-    if (!bgEntry)
-        return ERR_GROUP_JOIN_BATTLEGROUND_FAIL;            // shouldn't happen
-
-    // check for min / max count
-    uint32 memberscount = GetMembersCount();
-
-    if (memberscount > bgEntry->maxGroupSize)                // no MinPlayerCount for battlegrounds
-        return ERR_BATTLEGROUND_NONE;                        // ERR_GROUP_JOIN_BATTLEGROUND_TOO_MANY handled on client side
-
-    // get a player as reference, to compare other players' stats to (arena team id, queue id based on level, etc.)
-    Player * reference = GetFirstMember()->getSource();
-    // no reference found, can't join this way
-    if (!reference)
-        return ERR_BATTLEGROUND_JOIN_FAILED;
-
-    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bgOrTemplate->GetMapId(),reference->getLevel());
-    if (!bracketEntry)
-        return ERR_BATTLEGROUND_JOIN_FAILED;
-
-    uint32 arenaTeamId = reference->GetArenaTeamId(arenaSlot);
-    uint32 team = reference->GetTeam();
-
-    BattlegroundQueueTypeId bgQueueTypeIdRandom = BattlegroundMgr::BGQueueTypeId(BATTLEGROUND_RB, 0);
-
-    // check every member of the group to be able to join
-    memberscount = 0;
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next(), ++memberscount)
-    {
-        Player *member = itr->getSource();
-        // offline member? don't let join
-        if (!member)
-            return ERR_BATTLEGROUND_JOIN_FAILED;
-        // don't allow cross-faction join as group
-        if (member->GetTeam() != team)
-            return ERR_BATTLEGROUND_JOIN_TIMED_OUT;
-        // not in the same battleground level braket, don't let join
-        PvPDifficultyEntry const* memberBracketEntry = GetBattlegroundBracketByLevel(bracketEntry->mapId,member->getLevel());
-        if (memberBracketEntry != bracketEntry)
-            return ERR_BATTLEGROUND_JOIN_RANGE_INDEX;
-        // don't let join rated matches if the arena team id doesn't match
-        if (isRated && member->GetArenaTeamId(arenaSlot) != arenaTeamId)
-            return ERR_BATTLEGROUND_JOIN_FAILED;
-        // don't let join if someone from the group is already in that bg queue
-        if (member->InBattlegroundQueueForBattlegroundQueueType(bgQueueTypeId))
-            return ERR_BATTLEGROUND_JOIN_FAILED;            // not blizz-like
-        // don't let join if someone from the group is in bg queue random
-        if (member->InBattlegroundQueueForBattlegroundQueueType(bgQueueTypeIdRandom))
-            return ERR_IN_RANDOM_BG;
-        // don't let join to bg queue random if someone from the group is already in bg queue
-        if (bgOrTemplate->GetTypeID() == BATTLEGROUND_RB && member->InBattlegroundQueue())
-            return ERR_IN_NON_RANDOM_BG;
-        // check for deserter debuff in case not arena queue
-        if (bgOrTemplate->GetTypeID() != BATTLEGROUND_AA && !member->CanJoinToBattleground())
-            return ERR_GROUP_JOIN_BATTLEGROUND_DESERTERS;
-        // check if member can join any more battleground queues
-        if (!member->HasFreeBattlegroundQueueId())
-            return ERR_BATTLEGROUND_TOO_MANY_QUEUES;        // not blizz-like
-    }
-
-    // only check for MinPlayerCount since MinPlayerCount == MaxPlayerCount for arenas...
-    if (bgOrTemplate->isArena() && memberscount != MinPlayerCount)
-        return ERR_ARENA_TEAM_PARTY_SIZE;
-
-    return GroupJoinBattlegroundResult(bgOrTemplate->GetTypeID());
-}
-
-//===================================================
-//============== Roll ===============================
-//===================================================
-
-void Roll::targetObjectBuildLink()
-{
-    // called from link()
-    getTarget()->addLootValidatorRef(this);
-}
-
-void Group::SetDungeonDifficulty(Difficulty difficulty)
-{
-    m_dungeonDifficulty = difficulty;
-    if (!isBGGroup())
-       CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, GUID_LOPART(m_guid));
-
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player *player = itr->getSource();
-        if (!player->GetSession() || player->getLevel() < LEVELREQUIREMENT_HEROIC)
-            continue;
-
-        player->SetDungeonDifficulty(difficulty);
-        player->SendDungeonDifficulty(true);
-    }
-}
-
-void Group::SetRaidDifficulty(Difficulty difficulty)
-{
-    m_raidDifficulty = difficulty;
-    if (!isBGGroup())
-        CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, GUID_LOPART(m_guid));
-
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player *player = itr->getSource();
-        if (!player->GetSession() || player->getLevel() < LEVELREQUIREMENT_HEROIC)
-            continue;
-
-        player->SetRaidDifficulty(difficulty);
-        player->SendRaidDifficulty(true);
-    }
-}
-
-bool Group::InCombatToInstance(uint32 instanceId)
-{
-    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
-    {
-        Player *pPlayer = itr->getSource();
-        if (pPlayer && pPlayer->getAttackers().size() && pPlayer->GetInstanceId() == instanceId && (pPlayer->GetMap()->IsRaidOrHeroicDungeon()))
-            for (std::set<Unit*>::const_iterator i = pPlayer->getAttackers().begin(); i != pPlayer->getAttackers().end(); ++i)
-                if ((*i) && (*i)->GetTypeId() == TYPEID_UNIT && (*i)->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
-                    return true;
-    }
-    return false;
-}
-
-void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
-{
-    if (isBGGroup())
-        return;
-
-    // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
-
-    // we assume that when the difficulty changes, all instances that can be reset will be
-    Difficulty diff = GetDifficulty(isRaid);
-
-    for (BoundInstancesMap::iterator itr = m_boundInstances[diff].begin(); itr != m_boundInstances[diff].end();)
-    {
-        InstanceSave *p = itr->second.save;
-        const MapEntry *entry = sMapStore.LookupEntry(itr->first);
-        if (!entry || entry->IsRaid() != isRaid || (!p->CanReset() && method != INSTANCE_RESET_GROUP_DISBAND))
-        {
-            ++itr;
-            continue;
-        }
-
-        if (method == INSTANCE_RESET_ALL)
-        {
-            // the "reset all instances" method can only reset normal maps
-            if (entry->map_type == MAP_RAID || diff == DUNGEON_DIFFICULTY_HEROIC)
-            {
-                ++itr;
-                continue;
-            }
-        }
-
-        bool isEmpty = true;
-        // if the map is loaded, reset it
-        Map *map = sMapMgr.FindMap(p->GetMapId(), p->GetInstanceId());
-        if (map && map->IsDungeon() && !(method == INSTANCE_RESET_GROUP_DISBAND && !p->CanReset()))
-        {
-            if (p->CanReset())
-                isEmpty = ((InstanceMap*)map)->Reset(method);
-            else
-                isEmpty = !map->HavePlayers();
-        }
-
-        if (SendMsgTo)
-        {
-            if (isEmpty)
-                SendMsgTo->SendResetInstanceSuccess(p->GetMapId());
-            else
-                SendMsgTo->SendResetInstanceFailed(0, p->GetMapId());
-        }
-
-        if (isEmpty || method == INSTANCE_RESET_GROUP_DISBAND || method == INSTANCE_RESET_CHANGE_DIFFICULTY)
-        {
-            // do not reset the instance, just unbind if others are permanently bound to it
-            if (p->CanReset())
-                p->DeleteFromDB();
-            else
-                CharacterDatabase.PExecute("DELETE FROM group_instance WHERE instance = '%u'", p->GetInstanceId());
-
-            // i don't know for sure if hash_map iterators
-            m_boundInstances[diff].erase(itr);
-            itr = m_boundInstances[diff].begin();
-            // this unloads the instance save unless online players are bound to it
-            // (eg. permanent binds or GM solo binds)
-            p->RemoveGroup(this);
-        }
-        else
-            ++itr;
-    }
-}
-
-InstanceGroupBind* Group::GetBoundInstance(Player* player)
-{
-    uint32 mapid = player->GetMapId();
-    MapEntry const* mapEntry = sMapStore.LookupEntry(mapid);
-    return GetBoundInstance(mapEntry);
-}
-
-InstanceGroupBind* Group::GetBoundInstance(Map* aMap)
-{
-    // Currently spawn numbering not different from map difficulty
-    Difficulty difficulty = GetDifficulty(aMap->IsRaid());
-
-    // some instances only have one difficulty
-    GetDownscaledMapDifficultyData(aMap->GetId(),difficulty);
-
-    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(aMap->GetId());
-    if (itr != m_boundInstances[difficulty].end())
-        return &itr->second;
-    else
-        return NULL;
-}
-
-InstanceGroupBind* Group::GetBoundInstance(MapEntry const* mapEntry)
-{
-    if (!mapEntry)
-        return NULL;
-
-    Difficulty difficulty = GetDifficulty(mapEntry->IsRaid());
-
-    // some instances only have one difficulty
-    GetDownscaledMapDifficultyData(mapEntry->MapID,difficulty);
-
-    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapEntry->MapID);
-    if (itr != m_boundInstances[difficulty].end())
-        return &itr->second;
-    else
-        return NULL;
-}
-
-
-InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
-{
-    if (!save || isBGGroup())
-        return NULL;
-
-    InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
-    if (!load && (!bind.save || permanent != bind.perm || save != bind.save))
-        CharacterDatabase.PExecute("REPLACE INTO group_instance (guid, instance, permanent) VALUES (%u, %u, %u)", GUID_LOPART(GetGUID()), save->GetInstanceId(), permanent);
-
-    if (bind.save != save)
-    {
-        if (bind.save)
-            bind.save->RemoveGroup(this);
-        save->AddGroup(this);
-    }
-
-    bind.save = save;
-    bind.perm = permanent;
-    if (!load)
-        sLog.outDebug("Group::BindToInstance: %d is now bound to map %d, instance %d, difficulty %d", GUID_LOPART(GetGUID()), save->GetMapId(), save->GetInstanceId(), save->GetDifficulty());
-    return &bind;
-}
-
-void Group::UnbindInstance(uint32 mapid, uint8 difficulty, bool unload)
-{
-    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
-    if (itr != m_boundInstances[difficulty].end())
-    {
-        if (!unload)
-            CharacterDatabase.PExecute("DELETE FROM group_instance WHERE guid=%u AND instance=%u", GUID_LOPART(GetGUID()), itr->second.save->GetInstanceId());
-        itr->second.save->RemoveGroup(this);                // save can become invalid
-        m_boundInstances[difficulty].erase(itr);
-    }
-}
-
-void Group::_homebindIfInstance(Player *player)
-{
-    if (player && !player->isGameMaster() && sMapStore.LookupEntry(player->GetMapId())->IsDungeon())
-        player->m_InstanceValid = false;
-}
-
-void Group::BroadcastGroupUpdate(void)
-{
-    // FG: HACK: force flags update on group leave - for values update hack
-    // -- not very efficient but safe
-    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
-    {
-
-        Player *pp = sObjectMgr.GetPlayer(citr->guid);
-        if (pp && pp->IsInWorld())
-        {
-            pp->ForceValuesUpdateAtIndex(UNIT_FIELD_BYTES_2);
-            pp->ForceValuesUpdateAtIndex(UNIT_FIELD_FACTIONTEMPLATE);
-            sLog.outStaticDebug("-- Forced group value update for '%s'", pp->GetName());
-        }
-    }
-}
-
-void Group::ResetMaxEnchantingLevel()
-{
-    m_maxEnchantingLevel = 0;
-    Player *pMember = NULL;
-    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
-    {
-        pMember = sObjectMgr.GetPlayer(citr->guid);
-        if (pMember && m_maxEnchantingLevel < pMember->GetSkillValue(SKILL_ENCHANTING))
-            m_maxEnchantingLevel = pMember->GetSkillValue(SKILL_ENCHANTING);
-    }
-}
+﻿/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "Opcodes.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "Player.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "Group.h"
+#include "Formulas.h"
+#include "ObjectAccessor.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "MapManager.h"
+#include "InstanceSaveMgr.h"
+#include "MapInstanced.h"
+#include "Util.h"
+
+Group::Group()
+{
+    m_leaderGuid        = 0;
+    m_groupType         = GroupType(0);
+    m_bgGroup           = NULL;
+    m_lootMethod        = LootMethod(0);
+    m_looterGuid        = 0;
+    m_lootThreshold     = ITEM_QUALITY_UNCOMMON;
+    m_subGroupsCounts   = NULL;
+    m_guid              = 0;
+    m_counter           = 0;
+    m_maxEnchantingLevel= 0;
+    m_LfgQueued         = false;
+    m_LfgStatus         = LFG_STATUS_NOT_SAVED;
+    m_LfgDungeonEntry   = 0;
+    m_Lfgkicks          = 0;
+    m_LfgkicksActive    = false;
+
+    for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
+        m_targetIcons[i] = 0;
+}
+
+Group::~Group()
+{
+    if (m_bgGroup)
+    {
+        sLog.outDebug("Group::~Group: battleground group being deleted.");
+        if (m_bgGroup->GetBgRaid(ALLIANCE) == this) m_bgGroup->SetBgRaid(ALLIANCE, NULL);
+        else if (m_bgGroup->GetBgRaid(HORDE) == this) m_bgGroup->SetBgRaid(HORDE, NULL);
+        else sLog.outError("Group::~Group: battleground group is not linked to the correct battleground.");
+    }
+    Rolls::iterator itr;
+    while (!RollId.empty())
+    {
+        itr = RollId.begin();
+        Roll *r = *itr;
+        RollId.erase(itr);
+        delete(r);
+    }
+
+    // it is undefined whether objectmgr (which stores the groups) or instancesavemgr
+    // will be unloaded first so we must be prepared for both cases
+    // this may unload some instance saves
+    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+        for (BoundInstancesMap::iterator itr2 = m_boundInstances[i].begin(); itr2 != m_boundInstances[i].end(); ++itr2)
+            itr2->second.save->RemoveGroup(this);
+
+    // Sub group counters clean up
+    delete[] m_subGroupsCounts;
+}
+
+bool Group::Create(const uint64 &guid, const char * name)
+{
+    uint32 lowguid = sObjectMgr.GenerateLowGuid(HIGHGUID_GROUP);
+    m_guid = MAKE_NEW_GUID(lowguid, 0, HIGHGUID_GROUP);
+    m_leaderGuid = guid;
+    m_leaderName = name;
+
+    m_groupType  = isBGGroup() ? GROUPTYPE_BGRAID : GROUPTYPE_NORMAL;
+
+    if (m_groupType & GROUPTYPE_RAID)
+        _initRaidSubGroupsCounter();
+
+    m_lootMethod = GROUP_LOOT;
+    m_lootThreshold = ITEM_QUALITY_UNCOMMON;
+    m_looterGuid = guid;
+
+    m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
+    m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
+    if (!isBGGroup())
+    {
+        Player *leader = sObjectMgr.GetPlayer(guid);
+        if (leader)
+        {
+            m_dungeonDifficulty = leader->GetDungeonDifficulty();
+            m_raidDifficulty = leader->GetRaidDifficulty();
+        }
+
+        Player::ConvertInstancesToGroup(leader, this, guid);
+
+        if (!AddMember(guid, name))
+            return false;
+
+        // store group in database
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        trans->PAppend("DELETE FROM groups WHERE guid ='%u'", lowguid);
+        trans->PAppend("DELETE FROM group_member WHERE guid ='%u'", lowguid);
+        trans->PAppend("INSERT INTO groups (guid,leaderGuid,lootMethod,looterGuid,lootThreshold,icon1,icon2,icon3,icon4,icon5,icon6,icon7,icon8,groupType,difficulty,raiddifficulty) "
+            "VALUES ('%u','%u','%u','%u','%u','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','" UI64FMTD "','%u','%u','%u')",
+            lowguid, GUID_LOPART(m_leaderGuid), uint32(m_lootMethod),
+            GUID_LOPART(m_looterGuid), uint32(m_lootThreshold), m_targetIcons[0], m_targetIcons[1], m_targetIcons[2], m_targetIcons[3], m_targetIcons[4], m_targetIcons[5], m_targetIcons[6], m_targetIcons[7], uint8(m_groupType), uint32(m_dungeonDifficulty), m_raidDifficulty);
+
+        CharacterDatabase.CommitTransaction(trans);
+    }
+    else if (!AddMember(guid, name))
+        return false;
+
+    return true;
+}
+
+bool Group::LoadGroupFromDB(const uint32 &groupGuid, QueryResult result, bool loadMembers)
+{
+    if (isBGGroup())
+        return false;
+
+    Field *fields = result->Fetch();
+    m_guid = MAKE_NEW_GUID(groupGuid, 0, HIGHGUID_GROUP);
+    m_leaderGuid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+
+    // group leader not exist
+    if (!sObjectMgr.GetPlayerNameByGUID(fields[0].GetUInt32(), m_leaderName))
+        return false;
+
+    m_lootMethod = LootMethod(fields[1].GetUInt8());
+    m_looterGuid = MAKE_NEW_GUID(fields[2].GetUInt32(), 0, HIGHGUID_PLAYER);
+    m_lootThreshold = ItemQualities(fields[3].GetUInt16());
+
+    for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
+        m_targetIcons[i] = fields[4+i].GetUInt64();
+
+    m_groupType  = GroupType(fields[12].GetUInt8());
+    if (m_groupType & GROUPTYPE_RAID)
+        _initRaidSubGroupsCounter();
+
+    uint32 diff = fields[13].GetUInt8();
+    if (diff >= MAX_DUNGEON_DIFFICULTY)
+        m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
+    else
+        m_dungeonDifficulty = Difficulty(diff);
+
+    uint32 r_diff = fields[14].GetUInt8();
+    if (r_diff >= MAX_RAID_DIFFICULTY)
+       m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
+    else
+       m_raidDifficulty = Difficulty(r_diff);
+
+    if (loadMembers)
+    {
+        //                                        0           1            2         3
+        result = CharacterDatabase.PQuery("SELECT memberGuid, memberFlags, subgroup, roles FROM group_member WHERE guid=%u", groupGuid);
+        if (!result)
+            return false;
+
+        do
+        {
+            fields = result->Fetch();
+            LoadMemberFromDB(fields[0].GetUInt32(), fields[1].GetUInt8(), fields[2].GetUInt8(), fields[3].GetUInt8());
+        } while (result->NextRow());
+
+        if (GetMembersCount() < 2)                          // group too small
+            return false;
+    }
+
+    return true;
+}
+
+bool Group::LoadMemberFromDB(uint32 guidLow, uint8 memberFlags, uint8 subgroup, uint8 roles)
+{
+    MemberSlot member;
+    member.guid = MAKE_NEW_GUID(guidLow, 0, HIGHGUID_PLAYER);
+
+    // skip non-existed member
+    if (!sObjectMgr.GetPlayerNameByGUID(member.guid, member.name))
+    {
+        CharacterDatabase.PQuery("DELETE FROM group_member WHERE memberGuid=%u", guidLow);
+        return false;
+    }
+
+    member.group = subgroup;
+    member.flags = memberFlags;
+    member.roles = roles;
+
+    m_memberSlots.push_back(member);
+
+    SubGroupCounterIncrease(subgroup);
+
+    return true;
+}
+
+void Group::ConvertToLFG()
+{
+    m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_UNK1);
+    m_lootMethod = NEED_BEFORE_GREED;
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), GUID_LOPART(m_guid));
+    SendUpdate();
+}
+
+void Group::ConvertToRaid()
+{
+    m_groupType = GroupType(m_groupType | GROUPTYPE_RAID);
+
+    _initRaidSubGroupsCounter();
+
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("UPDATE groups SET groupType='%u' WHERE guid='%u'", uint8(m_groupType), GUID_LOPART(m_guid));
+    SendUpdate();
+
+    // update quest related GO states (quest activity dependent from raid membership)
+    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
+        if (Player* player = sObjectMgr.GetPlayer(citr->guid))
+            player->UpdateForQuestWorldObjects();
+}
+
+bool Group::AddInvite(Player *player)
+{
+    if (!player || player->GetGroupInvite())
+        return false;
+    Group* group = player->GetGroup();
+    if (group && group->isBGGroup())
+        group = player->GetOriginalGroup();
+    if (group)
+        return false;
+
+    RemoveInvite(player);
+
+    m_invitees.insert(player);
+
+    player->SetGroupInvite(this);
+
+    sScriptMgr.OnGroupInviteMember(this, player->GetGUID());
+
+    return true;
+}
+
+bool Group::AddLeaderInvite(Player *player)
+{
+    if (!AddInvite(player))
+        return false;
+
+    m_leaderGuid = player->GetGUID();
+    m_leaderName = player->GetName();
+    return true;
+}
+
+uint32 Group::RemoveInvite(Player *player)
+{
+    if (player)
+    {
+        m_invitees.erase(player);
+        player->SetGroupInvite(NULL);
+    }
+    return GetMembersCount();
+}
+
+void Group::RemoveAllInvites()
+{
+    for (InvitesList::iterator itr=m_invitees.begin(); itr != m_invitees.end(); ++itr)
+        if (*itr)
+            (*itr)->SetGroupInvite(NULL);
+
+    m_invitees.clear();
+}
+
+Player* Group::GetInvited(const uint64& guid) const
+{
+    for (InvitesList::const_iterator itr = m_invitees.begin(); itr != m_invitees.end(); ++itr)
+    {
+        if ((*itr) && (*itr)->GetGUID() == guid)
+            return (*itr);
+    }
+    return NULL;
+}
+
+Player* Group::GetInvited(const std::string& name) const
+{
+    for (InvitesList::const_iterator itr = m_invitees.begin(); itr != m_invitees.end(); ++itr)
+    {
+        if ((*itr) && (*itr)->GetName() == name)
+            return (*itr);
+    }
+    return NULL;
+}
+
+bool Group::AddMember(const uint64 &guid, const char* name)
+{
+    if (!_addMember(guid, name))
+        return false;
+
+    SendUpdate();
+    sScriptMgr.OnGroupAddMember(this, guid);
+
+    Player *player = sObjectMgr.GetPlayer(guid);
+    if (player)
+    {
+        if (!IsLeader(player->GetGUID()) && !isBGGroup())
+        {
+            // reset the new member's instances, unless he is currently in one of them
+            // including raid/heroic instances that they are not permanently bound to!
+            player->ResetInstances(INSTANCE_RESET_GROUP_JOIN,false);
+            player->ResetInstances(INSTANCE_RESET_GROUP_JOIN,true);
+
+            if (player->getLevel() >= LEVELREQUIREMENT_HEROIC)
+            {
+                if (player->GetDungeonDifficulty() != GetDungeonDifficulty())
+                {
+                    player->SetDungeonDifficulty(GetDungeonDifficulty());
+                    player->SendDungeonDifficulty(true);
+                }
+                if (player->GetRaidDifficulty() != GetRaidDifficulty())
+                {
+                    player->SetRaidDifficulty(GetRaidDifficulty());
+                    player->SendRaidDifficulty(true);
+                }
+            }
+        }
+        player->SetGroupUpdateFlag(GROUP_UPDATE_FULL);
+        UpdatePlayerOutOfRange(player);
+
+        // quest related GO state dependent from raid membership
+        if (isRaidGroup())
+            player->UpdateForQuestWorldObjects();
+
+        if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
+            m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    }
+
+    return true;
+}
+
+uint32 Group::RemoveMember(const uint64 &guid, const RemoveMethod &method)
+{
+    BroadcastGroupUpdate();
+
+    sScriptMgr.OnGroupRemoveMember(this, guid, method);
+
+    // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG allow 1 member group)
+    if (GetMembersCount() > (isBGGroup() ? 1u : 2u))
+    {
+        bool leaderChanged = _removeMember(guid);
+
+        if (Player *player = sObjectMgr.GetPlayer(guid))
+        {
+            // quest related GO state dependent from raid membership
+            if (isRaidGroup())
+                player->UpdateForQuestWorldObjects();
+
+            WorldPacket data;
+
+            if (method == GROUP_REMOVEMETHOD_KICK)
+            {
+                data.Initialize(SMSG_GROUP_UNINVITE, 0);
+                player->GetSession()->SendPacket(&data);
+            }
+
+            //we already removed player from group and in player->GetGroup() is his original group!
+            if (Group* group = player->GetGroup())
+                group->SendUpdate();
+            else
+            {
+                data.Initialize(SMSG_GROUP_LIST, 1+1+1+1+8+4+4+8);
+                data << uint8(0x10) << uint8(0) << uint8(0) << uint8(0);
+                data << uint64(m_guid) << uint32(m_counter) << uint32(0) << uint64(0);
+                player->GetSession()->SendPacket(&data);
+            }
+
+            _homebindIfInstance(player);
+        }
+
+        if (leaderChanged)
+        {
+            WorldPacket data(SMSG_GROUP_SET_LEADER, (m_memberSlots.front().name.size()+1));
+            data << m_memberSlots.front().name;
+            BroadcastPacket(&data, true);
+        }
+
+        SendUpdate();
+        ResetMaxEnchantingLevel();
+    }
+    // if group before remove <= 2 disband it
+    else
+        Disband();
+
+    return m_memberSlots.size();
+}
+
+void Group::ChangeLeader(const uint64 &guid)
+{
+    member_citerator slot = _getMemberCSlot(guid);
+
+    if (slot == m_memberSlots.end())
+        return;
+
+    _setLeader(guid);
+
+    WorldPacket data(SMSG_GROUP_SET_LEADER, slot->name.size()+1);
+    data << slot->name;
+    BroadcastPacket(&data, true);
+    SendUpdate();
+}
+
+void Group::Disband(bool hideDestroy /* = false */)
+{
+    sScriptMgr.OnGroupDisband(this);
+
+    Player *player;
+    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
+    {
+        player = sObjectMgr.GetPlayer(citr->guid);
+        if (!player)
+            continue;
+
+        //we cannot call _removeMember because it would invalidate member iterator
+        //if we are removing player from battleground raid
+        if (isBGGroup())
+            player->RemoveFromBattlegroundRaid();
+        else
+        {
+            //we can remove player who is in battleground from his original group
+            if (player->GetOriginalGroup() == this)
+                player->SetOriginalGroup(NULL);
+            else
+                player->SetGroup(NULL);
+        }
+
+        // quest related GO state dependent from raid membership
+        if (isRaidGroup())
+            player->UpdateForQuestWorldObjects();
+
+        if (!player->GetSession())
+            continue;
+
+        WorldPacket data;
+        if (!hideDestroy)
+        {
+            data.Initialize(SMSG_GROUP_DESTROYED, 0);
+            player->GetSession()->SendPacket(&data);
+        }
+
+        //we already removed player from group and in player->GetGroup() is his original group, send update
+        if (Group* group = player->GetGroup())
+        {
+            group->SendUpdate();
+        }
+        else
+        {
+            data.Initialize(SMSG_GROUP_LIST, 1+1+1+1+8+4+4+8);
+            data << uint8(0x10) << uint8(0) << uint8(0) << uint8(0);
+            data << uint64(m_guid) << uint32(m_counter) << uint32(0) << uint64(0);
+            player->GetSession()->SendPacket(&data);
+        }
+
+        _homebindIfInstance(player);
+    }
+    RollId.clear();
+    m_memberSlots.clear();
+
+    RemoveAllInvites();
+
+    if (!isBGGroup())
+    {
+        uint32 lowguid = GUID_LOPART(m_guid);
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        trans->PAppend("DELETE FROM groups WHERE guid=%u", lowguid);
+        trans->PAppend("DELETE FROM group_member WHERE guid=%u", lowguid);
+        CharacterDatabase.CommitTransaction(trans);
+        ResetInstances(INSTANCE_RESET_GROUP_DISBAND, false, NULL);
+        ResetInstances(INSTANCE_RESET_GROUP_DISBAND, true, NULL);
+    }
+
+    m_guid = 0;
+    m_leaderGuid = 0;
+    m_leaderName = "";
+}
+
+/*********************************************************/
+/***                   LOOT SYSTEM                     ***/
+/*********************************************************/
+
+void Group::SendLootStartRoll(uint32 CountDown, uint32 mapid, const Roll &r)
+{
+    WorldPacket data(SMSG_LOOT_START_ROLL, (8+4+4+4+4+4+4+1));
+    data << uint64(r.itemGUID);                             // guid of rolled item
+    data << uint32(mapid);                                  // 3.3.3 mapid
+    data << uint32(r.totalPlayersRolling);                  // maybe the number of players rolling for it???
+    data << uint32(r.itemid);                               // the itemEntryId for the item that shall be rolled for
+    data << uint32(r.itemRandomSuffix);                     // randomSuffix
+    data << uint32(r.itemRandomPropId);                     // item random property ID
+    data << uint32(r.itemCount);                            // items in stack
+    data << uint32(CountDown);                              // the countdown time to choose "need" or "greed"
+    data << uint8(r.rollVoteMask);                          // roll type mask
+
+    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
+    {
+        Player *p = sObjectMgr.GetPlayer(itr->first);
+        if (!p || !p->GetSession())
+            continue;
+
+        if (itr->second == NOT_EMITED_YET)
+            p->GetSession()->SendPacket(&data);
+    }
+}
+
+void Group::SendLootRoll(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r)
+{
+    WorldPacket data(SMSG_LOOT_ROLL, (8+4+8+4+4+4+1+1+1));
+    data << uint64(SourceGuid);                             // guid of the item rolled
+    data << uint32(0);                                      // unknown, maybe amount of players
+    data << uint64(TargetGuid);
+    data << uint32(r.itemid);                               // the itemEntryId for the item that shall be rolled for
+    data << uint32(r.itemRandomSuffix);                     // randomSuffix
+    data << uint32(r.itemRandomPropId);                     // Item random property ID
+    data << uint8(RollNumber);                              // 0: "Need for: [item name]" > 127: "you passed on: [item name]"      Roll number
+    data << uint8(RollType);                                // 0: "Need for: [item name]" 0: "You have selected need for [item name] 1: need roll 2: greed roll
+    data << uint8(0);                                       // auto pass on NeedBeforeGreed loot because player cannot use the object
+
+    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
+    {
+        Player *p = sObjectMgr.GetPlayer(itr->first);
+        if (!p || !p->GetSession())
+            continue;
+
+        if (itr->second != NOT_VALID)
+            p->GetSession()->SendPacket(&data);
+    }
+}
+
+void Group::SendLootRollWon(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r)
+{
+    WorldPacket data(SMSG_LOOT_ROLL_WON, (8+4+4+4+4+8+1+1));
+    data << uint64(SourceGuid);                             // guid of the item rolled
+    data << uint32(0);                                      // unknown, maybe amount of players
+    data << uint32(r.itemid);                               // the itemEntryId for the item that shall be rolled for
+    data << uint32(r.itemRandomSuffix);                     // randomSuffix
+    data << uint32(r.itemRandomPropId);                     // Item random property
+    data << uint64(TargetGuid);                             // guid of the player who won.
+    data << uint8(RollNumber);                              // rollnumber realted to SMSG_LOOT_ROLL
+    data << uint8(RollType);                                // Rolltype related to SMSG_LOOT_ROLL
+
+    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
+    {
+        Player *p = sObjectMgr.GetPlayer(itr->first);
+        if (!p || !p->GetSession())
+            continue;
+
+        if (itr->second != NOT_VALID)
+            p->GetSession()->SendPacket(&data);
+    }
+}
+
+void Group::SendLootAllPassed(uint32 NumberOfPlayers, const Roll &r)
+{
+    WorldPacket data(SMSG_LOOT_ALL_PASSED, (8+4+4+4+4));
+    data << uint64(r.itemGUID);                             // Guid of the item rolled
+    data << uint32(NumberOfPlayers);                        // The number of players rolling for it???
+    data << uint32(r.itemid);                               // The itemEntryId for the item that shall be rolled for
+    data << uint32(r.itemRandomPropId);                     // Item random property ID
+    data << uint32(r.itemRandomSuffix);                     // Item random suffix ID
+
+    for (Roll::PlayerVote::const_iterator itr=r.playerVote.begin(); itr != r.playerVote.end(); ++itr)
+    {
+        Player *p = sObjectMgr.GetPlayer(itr->first);
+        if (!p || !p->GetSession())
+            continue;
+
+        if (itr->second != NOT_VALID)
+            p->GetSession()->SendPacket(&data);
+    }
+}
+
+// notify group members which player is the allowed looter for the given creature
+void Group::SendLooter(Creature *pCreature, Player *pLooter)
+{
+    ASSERT(pCreature);
+
+    WorldPacket data(SMSG_LOOT_LIST, (8+8));
+    data << uint64(pCreature->GetGUID());
+    data << uint8(0); // unk1
+
+    if (pLooter)
+        data.append(pLooter->GetPackGUID());
+    else
+        data << uint8(0);
+
+    BroadcastPacket(&data, false);
+}
+
+void Group::GroupLoot(Loot *loot, WorldObject* pLootedObject)
+{
+    std::vector<LootItem>::iterator i;
+    ItemPrototype const *item;
+    uint8 itemSlot = 0;
+
+    for (i = loot->items.begin(); i != loot->items.end(); ++i, ++itemSlot)
+    {
+        if (i->freeforall)
+            continue;
+
+        item = sObjectMgr.GetItemPrototype(i->itemid);
+        if (!item)
+        {
+            //sLog.outDebug("Group::GroupLoot: missing item prototype for item with id: %d", i->itemid);
+            continue;
+        }
+
+        //roll for over-threshold item if it's one-player loot
+        if (item->Quality >= uint32(m_lootThreshold))
+        {
+            uint64 newitemGUID = MAKE_NEW_GUID(sObjectMgr.GenerateLowGuid(HIGHGUID_ITEM),0,HIGHGUID_ITEM);
+            Roll* r = new Roll(newitemGUID,*i);
+
+            //a vector is filled with only near party members
+            for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player *member = itr->getSource();
+                if (!member || !member->GetSession())
+                    continue;
+                if (i->AllowedForPlayer(member))
+                {
+                    if (member->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
+                    {
+
+                        r->totalPlayersRolling++;
+
+                        if (member->GetPassOnGroupLoot())
+                        {
+                            r->playerVote[member->GetGUID()] = PASS;
+                            r->totalPass++;
+                            // can't broadcast the pass now. need to wait until all rolling players are known.
+                        }
+                        else
+                            r->playerVote[member->GetGUID()] = NOT_EMITED_YET;
+                    }
+                }
+            }
+
+            if (r->totalPlayersRolling > 0)
+            {
+                r->setLoot(loot);
+                r->itemSlot = itemSlot;
+                if (item->DisenchantID && m_maxEnchantingLevel >= item->RequiredDisenchantSkill)
+                    r->rollVoteMask |= ROLL_FLAG_TYPE_DISENCHANT;
+
+                loot->items[itemSlot].is_blocked = true;
+
+                // If there is any "auto pass", broadcast the pass now.
+                if (r->totalPass)
+                {
+                    for (Roll::PlayerVote::const_iterator itr=r->playerVote.begin(); itr != r->playerVote.end(); ++itr)
+                    {
+                        Player *p = sObjectMgr.GetPlayer(itr->first);
+                        if (!p || !p->GetSession())
+                            continue;
+
+                        if (itr->second == PASS)
+                            SendLootRoll(newitemGUID, p->GetGUID(), 128, ROLL_PASS, *r);
+                    }
+                }
+
+                SendLootStartRoll(60000, pLootedObject->GetMapId(), *r);
+
+                RollId.push_back(r);
+
+                if (Creature* creature = dynamic_cast<Creature *>(pLootedObject))
+                {
+                    creature->m_groupLootTimer = 60000;
+                    creature->lootingGroupLowGUID = GetLowGUID();
+                }
+                else if (GameObject* go = dynamic_cast<GameObject *>(pLootedObject))
+                {
+                    go->m_groupLootTimer = 60000;
+                    go->lootingGroupLowGUID = GetLowGUID();
+                }
+            }
+            else
+                delete r;
+        }
+        else
+            i->is_underthreshold = true;
+    }
+}
+
+void Group::NeedBeforeGreed(Loot *loot, WorldObject* pLootedObject)
+{
+    ItemPrototype const *item;
+    uint8 itemSlot = 0;
+    for (std::vector<LootItem>::iterator i=loot->items.begin(); i != loot->items.end(); ++i, ++itemSlot)
+    {
+        if (i->freeforall)
+            continue;
+
+        item = sObjectMgr.GetItemPrototype(i->itemid);
+
+        //roll for over-threshold item if it's one-player loot
+        if (item->Quality >= uint32(m_lootThreshold))
+        {
+            uint64 newitemGUID = MAKE_NEW_GUID(sObjectMgr.GenerateLowGuid(HIGHGUID_ITEM),0,HIGHGUID_ITEM);
+            Roll* r=new Roll(newitemGUID,*i);
+
+            for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player *playerToRoll = itr->getSource();
+                if (!playerToRoll || !playerToRoll->GetSession())
+                    continue;
+
+                bool allowedForPlayer = i->AllowedForPlayer(playerToRoll);
+                if (playerToRoll->CanUseItem(item) == EQUIP_ERR_OK && allowedForPlayer)
+                {
+                    if (playerToRoll->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
+                    {
+                        r->totalPlayersRolling++;
+
+                        if (playerToRoll->GetPassOnGroupLoot())
+                        {
+                            r->playerVote[playerToRoll->GetGUID()] = PASS;
+                            r->totalPass++;
+                            // can't broadcast the pass now. need to wait until all rolling players are known.
+                        }
+                        else
+                            r->playerVote[playerToRoll->GetGUID()] = NOT_EMITED_YET;
+                    }
+                }
+            }
+
+            if (r->totalPlayersRolling > 0)
+            {
+                r->setLoot(loot);
+                r->itemSlot = itemSlot;
+                if (item->DisenchantID && m_maxEnchantingLevel >= item->RequiredDisenchantSkill)
+                    r->rollVoteMask |= ROLL_FLAG_TYPE_DISENCHANT;
+
+                if (item->Flags2 & ITEM_FLAGS_EXTRA_NEED_ROLL_DISABLED)
+                    r->rollVoteMask &= ~ROLL_FLAG_TYPE_NEED;
+
+                loot->items[itemSlot].is_blocked = true;
+
+                // If there is any "auto pass", broadcast the pass now.
+                if (r->totalPass)
+                {
+                    for (Roll::PlayerVote::const_iterator itr=r->playerVote.begin(); itr != r->playerVote.end(); ++itr)
+                    {
+                        Player *p = sObjectMgr.GetPlayer(itr->first);
+                        if (!p || !p->GetSession())
+                            continue;
+
+                        if (itr->second == PASS)
+                            SendLootRoll(newitemGUID, p->GetGUID(), 128, ROLL_PASS, *r);
+                    }
+                }
+
+                SendLootStartRoll(60000, pLootedObject->GetMapId(), *r);
+
+                RollId.push_back(r);
+
+                if (Creature* creature = dynamic_cast<Creature *>(pLootedObject))
+                {
+                    creature->m_groupLootTimer = 60000;
+                    creature->lootingGroupLowGUID = GetLowGUID();
+                }
+            }
+            else
+                delete r;
+        }
+        else
+            i->is_underthreshold = true;
+    }
+}
+
+void Group::MasterLoot(Loot* /*loot*/, WorldObject* pLootedObject)
+{
+    sLog.outDebug("Group::MasterLoot (SMSG_LOOT_MASTER_LIST, 330)");
+
+    uint32 real_count = 0;
+
+    WorldPacket data(SMSG_LOOT_MASTER_LIST, 330);
+    data << (uint8)GetMembersCount();
+
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *looter = itr->getSource();
+        if (!looter->IsInWorld())
+            continue;
+
+        if (looter->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
+        {
+            data << uint64(looter->GetGUID());
+            ++real_count;
+        }
+    }
+
+    data.put<uint8>(0,real_count);
+
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *looter = itr->getSource();
+        if (looter->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
+            looter->GetSession()->SendPacket(&data);
+    }
+}
+
+void Group::CountRollVote(const uint64& playerGUID, const uint64& Guid, uint32 NumberOfPlayers, uint8 Choice)
+{
+    Rolls::iterator rollI = GetRoll(Guid);
+    if (rollI == RollId.end())
+        return;
+    Roll* roll = *rollI;
+
+    Roll::PlayerVote::iterator itr = roll->playerVote.find(playerGUID);
+    // this condition means that player joins to the party after roll begins
+    if (itr == roll->playerVote.end())
+        return;
+
+    if (roll->getLoot())
+        if (roll->getLoot()->items.empty())
+            return;
+
+    switch (Choice)
+    {
+        case ROLL_PASS:                                     // Player choose pass
+            SendLootRoll(0, playerGUID, 128, ROLL_PASS, *roll);
+            ++roll->totalPass;
+            itr->second = PASS;
+            break;
+        case ROLL_NEED:                                     // player choose Need
+            SendLootRoll(0, playerGUID, 0, 0, *roll);
+            ++roll->totalNeed;
+            itr->second = NEED;
+            break;
+        case ROLL_GREED:                                    // player choose Greed
+            SendLootRoll(0, playerGUID, 128, ROLL_GREED, *roll);
+            ++roll->totalGreed;
+            itr->second = GREED;
+            break;
+        case ROLL_DISENCHANT:                               // player choose Disenchant
+            SendLootRoll(0, playerGUID, 128, ROLL_DISENCHANT, *roll);
+            ++roll->totalGreed;
+            itr->second = DISENCHANT;
+            break;
+    }
+
+    if (roll->totalPass + roll->totalNeed + roll->totalGreed >= roll->totalPlayersRolling)
+        CountTheRoll(rollI, NumberOfPlayers);
+}
+
+//called when roll timer expires
+void Group::EndRoll(Loot *pLoot)
+{
+    for (Rolls::iterator itr = RollId.begin(); itr != RollId.end();)
+    {
+        if ((*itr)->getLoot() == pLoot) {
+            CountTheRoll(itr, GetMembersCount());           //i don't have to edit player votes, who didn't vote ... he will pass
+            itr = RollId.begin();
+        }
+        else
+            itr++;
+    }
+}
+
+void Group::CountTheRoll(Rolls::iterator rollI, uint32 NumberOfPlayers)
+{
+    Roll* roll = *rollI;
+    if (!roll->isValid())                                   // is loot already deleted ?
+    {
+        RollId.erase(rollI);
+        delete roll;
+        return;
+    }
+
+    //end of the roll
+    if (roll->totalNeed > 0)
+    {
+        if (!roll->playerVote.empty())
+        {
+            uint8 maxresul = 0;
+            uint64 maxguid  = (*roll->playerVote.begin()).first;
+            Player *player;
+
+            for (Roll::PlayerVote::const_iterator itr=roll->playerVote.begin(); itr != roll->playerVote.end(); ++itr)
+            {
+                if (itr->second != NEED)
+                    continue;
+
+                uint8 randomN = urand(1, 100);
+                SendLootRoll(0, itr->first, randomN, ROLL_NEED, *roll);
+                if (maxresul < randomN)
+                {
+                    maxguid  = itr->first;
+                    maxresul = randomN;
+                }
+            }
+            SendLootRollWon(0, maxguid, maxresul, ROLL_NEED, *roll);
+            player = sObjectMgr.GetPlayer(maxguid);
+
+            if (player && player->GetSession())
+            {
+                player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED_ON_LOOT, roll->itemid, maxresul);
+
+                ItemPosCountVec dest;
+                LootItem *item = &(roll->getLoot()->items[roll->itemSlot]);
+                uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, roll->itemid, item->count);
+                if (msg == EQUIP_ERR_OK)
+                {
+                    item->is_looted = true;
+                    roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
+                    roll->getLoot()->unlootedCount--;
+                    AllowedLooterSet* looters = item->GetAllowedLooters();
+                    player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, (looters->size() > 1) ? looters : NULL);
+                }
+                else
+                {
+                    item->is_blocked = false;
+                    player->SendEquipError(msg, NULL, NULL, roll->itemid);
+                }
+            }
+        }
+    }
+    else if (roll->totalGreed > 0)
+    {
+        if (!roll->playerVote.empty())
+        {
+            uint8 maxresul = 0;
+            uint64 maxguid = (*roll->playerVote.begin()).first;
+            Player *player;
+            RollVote rollvote = NOT_VALID;
+
+            Roll::PlayerVote::iterator itr;
+            for (itr = roll->playerVote.begin(); itr != roll->playerVote.end(); ++itr)
+            {
+                if (itr->second != GREED && itr->second != DISENCHANT)
+                    continue;
+
+                uint8 randomN = urand(1, 100);
+                SendLootRoll(0, itr->first, randomN, itr->second, *roll);
+                if (maxresul < randomN)
+                {
+                    maxguid  = itr->first;
+                    maxresul = randomN;
+                    rollvote = itr->second;
+                }
+            }
+            SendLootRollWon(0, maxguid, maxresul, rollvote, *roll);
+            player = sObjectMgr.GetPlayer(maxguid);
+
+            if (player && player->GetSession())
+            {
+                player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED_ON_LOOT, roll->itemid, maxresul);
+
+                LootItem *item = &(roll->getLoot()->items[roll->itemSlot]);
+
+                if (rollvote == GREED)
+                {
+                    ItemPosCountVec dest;
+                    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, roll->itemid, item->count);
+                    if (msg == EQUIP_ERR_OK)
+                    {
+                        item->is_looted = true;
+                        roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
+                        roll->getLoot()->unlootedCount--;
+                        AllowedLooterSet* looters = item->GetAllowedLooters();
+                        player->StoreNewItem(dest, roll->itemid, true, item->randomPropertyId, (looters->size() > 1) ? looters : NULL);
+                    }
+                    else
+                    {
+                        item->is_blocked = false;
+                        player->SendEquipError(msg, NULL, NULL, roll->itemid);
+                    }
+                }
+                else if (rollvote == DISENCHANT)
+                {
+                    item->is_looted = true;
+                    roll->getLoot()->NotifyItemRemoved(roll->itemSlot);
+                    roll->getLoot()->unlootedCount--;
+                    ItemPrototype const *pProto = ObjectMgr::GetItemPrototype(roll->itemid);
+                    player->AutoStoreLoot(pProto->DisenchantID, LootTemplates_Disenchant, true);
+                }
+            }
+        }
+    }
+    else
+    {
+        SendLootAllPassed(NumberOfPlayers, *roll);
+
+        // remove is_blocked so that the item is lootable by all players
+        LootItem *item = &(roll->getLoot()->items[roll->itemSlot]);
+        if (item)
+            item->is_blocked = false;
+    }
+
+    RollId.erase(rollI);
+    delete roll;
+}
+
+void Group::SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid)
+{
+    if (id >= TARGETICONCOUNT)
+        return;
+
+    // clean other icons
+    if (targetGuid != 0)
+        for (int i=0; i<TARGETICONCOUNT; ++i)
+            if (m_targetIcons[i] == targetGuid)
+                SetTargetIcon(i, 0, 0);
+
+    m_targetIcons[id] = targetGuid;
+
+    WorldPacket data(MSG_RAID_TARGET_UPDATE, (1+8+1+8));
+    data << uint8(0);                                       // set targets
+    data << uint64(whoGuid);
+    data << uint8(id);
+    data << uint64(targetGuid);
+    BroadcastPacket(&data, true);
+}
+
+void Group::GetDataForXPAtKill(Unit const* victim, uint32& count,uint32& sum_level, Player* & member_with_max_level, Player* & not_gray_member_with_max_level)
+{
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* member = itr->getSource();
+        if (!member || !member->isAlive())                   // only for alive
+            continue;
+
+        if (!member->IsAtGroupRewardDistance(victim))        // at req. distance
+            continue;
+
+        ++count;
+        sum_level += member->getLevel();
+        if (!member_with_max_level || member_with_max_level->getLevel() < member->getLevel())
+            member_with_max_level = member;
+
+        uint32 gray_level = Trinity::XP::GetGrayLevel(member->getLevel());
+        if (victim->getLevel() > gray_level && (!not_gray_member_with_max_level || not_gray_member_with_max_level->getLevel() < member->getLevel()))
+            not_gray_member_with_max_level = member;
+    }
+}
+
+void Group::SendTargetIconList(WorldSession *session)
+{
+    if (!session)
+        return;
+
+    WorldPacket data(MSG_RAID_TARGET_UPDATE, (1+TARGETICONCOUNT*9));
+    data << uint8(1);                                       // list targets
+
+    for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
+    {
+        if (m_targetIcons[i] == 0)
+            continue;
+
+        data << uint8(i);
+        data << uint64(m_targetIcons[i]);
+    }
+
+    session->SendPacket(&data);
+}
+
+void Group::SendUpdate()
+{
+    Player *player;
+    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
+    {
+        player = sObjectMgr.GetPlayer(citr->guid);
+        if (!player || !player->GetSession() || player->GetGroup() != this)
+            continue;
+
+        WorldPacket data(SMSG_GROUP_LIST, (1+1+1+1+1+4+8+4+4+(GetMembersCount()-1)*(13+8+1+1+1+1)+8+1+8+1+1+1+1));
+        data << uint8(m_groupType);                         // group type (flags in 3.3)
+        data << uint8(citr->group);
+        data << uint8(citr->flags);
+        data << uint8(citr->roles);
+        if (isLFGGroup())
+        {
+            data << uint8(m_LfgStatus);
+            data << uint32(m_LfgDungeonEntry);
+        }
+
+        data << uint64(m_guid);
+        data << uint32(m_counter++);                        // 3.3, value increases every time this packet gets sent
+        data << uint32(GetMembersCount()-1);
+        for (member_citerator citr2 = m_memberSlots.begin(); citr2 != m_memberSlots.end(); ++citr2)
+        {
+            if (citr->guid == citr2->guid)
+                continue;
+
+            Player* member = sObjectMgr.GetPlayer(citr2->guid);
+
+            uint8 onlineState = (member) ? MEMBER_STATUS_ONLINE : MEMBER_STATUS_OFFLINE;
+            onlineState = onlineState | ((isBGGroup()) ? MEMBER_STATUS_PVP : 0);
+
+            data << citr2->name;
+            data << uint64(citr2->guid);                    // guid
+            data << uint8(onlineState);                     // online-state
+            data << uint8(citr2->group);                    // groupid
+            data << uint8(citr2->flags);                    // See enum GroupMemberFlags
+            data << uint8(citr2->roles);                    // Lfg Roles
+        }
+
+        data << uint64(m_leaderGuid);                       // leader guid
+
+        if (GetMembersCount() - 1)
+        {
+            data << uint8(m_lootMethod);                    // loot method
+            data << uint64(m_looterGuid);                   // looter guid
+            data << uint8(m_lootThreshold);                 // loot threshold
+            data << uint8(m_dungeonDifficulty);             // Dungeon Difficulty
+            data << uint8(m_raidDifficulty);                // Raid Difficulty
+            data << uint8(0);                               // 3.3
+        }
+
+        player->GetSession()->SendPacket(&data);
+    }
+}
+
+void Group::UpdatePlayerOutOfRange(Player* pPlayer)
+{
+    if (!pPlayer || !pPlayer->IsInWorld())
+        return;
+
+    Player *player;
+    WorldPacket data;
+    pPlayer->GetSession()->BuildPartyMemberStatsChangedPacket(pPlayer, &data);
+
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        player = itr->getSource();
+        if (player && player != pPlayer && !pPlayer->isVisibleFor(player))
+            player->GetSession()->SendPacket(&data);
+    }
+}
+
+void Group::BroadcastPacket(WorldPacket *packet, bool ignorePlayersInBGRaid, int group, uint64 ignore)
+{
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *pl = itr->getSource();
+        if (!pl || (ignore != 0 && pl->GetGUID() == ignore) || (ignorePlayersInBGRaid && pl->GetGroup() != this))
+            continue;
+
+        if (pl->GetSession() && (group == -1 || itr->getSubGroup() == group))
+            pl->GetSession()->SendPacket(packet);
+    }
+}
+
+void Group::BroadcastReadyCheck(WorldPacket *packet)
+{
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *pl = itr->getSource();
+        if (pl && pl->GetSession())
+            if (IsLeader(pl->GetGUID()) || IsAssistant(pl->GetGUID()))
+                pl->GetSession()->SendPacket(packet);
+    }
+}
+
+void Group::OfflineReadyCheck()
+{
+    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
+    {
+        Player *pl = sObjectMgr.GetPlayer(citr->guid);
+        if (!pl || !pl->GetSession())
+        {
+            WorldPacket data(MSG_RAID_READY_CHECK_CONFIRM, 9);
+            data << uint64(citr->guid);
+            data << uint8(0);
+            BroadcastReadyCheck(&data);
+        }
+    }
+}
+
+bool Group::_addMember(const uint64 &guid, const char* name)
+{
+    // get first not-full group
+    uint8 groupid = 0;
+    if (m_subGroupsCounts)
+    {
+        bool groupFound = false;
+        for (; groupid < MAX_RAID_SUBGROUPS; ++groupid)
+        {
+            if (m_subGroupsCounts[groupid] < MAXGROUPSIZE)
+            {
+                groupFound = true;
+                break;
+            }
+        }
+        // We are raid group and no one slot is free
+        if (!groupFound)
+            return false;
+    }
+
+    return _addMember(guid, name, groupid);
+}
+
+bool Group::_addMember(const uint64 &guid, const char* name, uint8 group)
+{
+    if (IsFull())
+        return false;
+
+    if (!guid)
+        return false;
+
+    Player *player = sObjectMgr.GetPlayer(guid);
+
+    MemberSlot member;
+    member.guid      = guid;
+    member.name      = name;
+    member.group     = group;
+    member.flags     = 0;
+    member.roles     = 0;
+    m_memberSlots.push_back(member);
+
+    SubGroupCounterIncrease(group);
+
+    if (player)
+    {
+        player->SetGroupInvite(NULL);
+        if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
+            player->SetBattlegroundRaid(this, group);
+        else if (player->GetGroup()) //if player is in bg raid and we are adding him to normal group, then call SetOriginalGroup()
+            player->SetOriginalGroup(this, group);
+        else //if player is not in group, then call set group
+            player->SetGroup(this, group);
+
+        // if the same group invites the player back, cancel the homebind timer
+        InstanceGroupBind *bind = GetBoundInstance(player);
+        if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
+            player->m_InstanceValid = true;
+    }
+
+    if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
+    {
+        for (uint8 i = 0; i < TARGETICONCOUNT; ++i)
+            m_targetIcons[i] = 0;
+    }
+
+    // insert into the table if we're not a battleground group
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)", GUID_LOPART(m_guid), GUID_LOPART(member.guid), member.flags, member.group, member.roles);
+
+    return true;
+}
+
+bool Group::_removeMember(const uint64 &guid)
+{
+    Player *player = sObjectMgr.GetPlayer(guid);
+    if (player)
+    {
+        //if we are removing player from battleground raid
+        if (isBGGroup())
+            player->RemoveFromBattlegroundRaid();
+        else
+        {
+            //we can remove player who is in battleground from his original group
+            if (player->GetOriginalGroup() == this)
+                player->SetOriginalGroup(NULL);
+            else
+                player->SetGroup(NULL);
+        }
+    }
+
+    _removeRolls(guid);
+
+    member_witerator slot = _getMemberWSlot(guid);
+    if (slot != m_memberSlots.end())
+    {
+        SubGroupCounterDecrease(slot->group);
+        m_memberSlots.erase(slot);
+    }
+
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
+
+    if (m_leaderGuid == guid)                                // leader was removed
+    {
+        if (GetMembersCount() > 0)
+            _setLeader(m_memberSlots.front().guid);
+        return true;
+    }
+
+    return false;
+}
+
+void Group::_setLeader(const uint64 &guid)
+{
+    member_witerator slot = _getMemberWSlot(guid);
+    if (slot == m_memberSlots.end())
+        return;
+
+    sScriptMgr.OnGroupChangeLeader(this, m_leaderGuid, guid);
+
+    if (!isBGGroup())
+    {
+        // TODO: set a time limit to have this function run rarely cause it can be slow
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+        // update the group's bound instances when changing leaders
+        // remove all permanent binds from the group
+        // in the DB also remove solo binds that will be replaced with permbinds
+        // from the new leader
+        trans->PAppend(
+            "DELETE FROM group_instance WHERE guid=%u AND (permanent = 1 OR "
+            "instance IN (SELECT instance FROM character_instance WHERE guid = '%u')"
+            ")", GUID_LOPART(m_guid), GUID_LOPART(slot->guid)
+        );
+
+        Player *player = sObjectMgr.GetPlayer(slot->guid);
+        if (player)
+        {
+            for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
+            {
+                for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end();)
+                {
+                    if (itr->second.perm)
+                    {
+                        itr->second.save->RemoveGroup(this);
+                        m_boundInstances[i].erase(itr++);
+                    }
+                    else
+                        ++itr;
+                }
+            }
+        }
+
+        // copy the permanent binds from the new leader to the group
+        // overwriting the solo binds with permanent ones if necessary
+        // in the DB those have been deleted already
+        Player::ConvertInstancesToGroup(player, this, slot->guid);
+
+        // update the group leader
+        trans->PAppend("UPDATE groups SET leaderGuid='%u' WHERE guid='%u'", GUID_LOPART(slot->guid), GUID_LOPART(m_guid));
+        CharacterDatabase.CommitTransaction(trans);
+    }
+
+    m_leaderGuid = slot->guid;
+    m_leaderName = slot->name;
+    ToggleGroupMemberFlag(slot, MEMBER_FLAG_ASSISTANT, false);
+}
+
+void Group::_removeRolls(const uint64 &guid)
+{
+    for (Rolls::iterator it = RollId.begin(); it != RollId.end(); ++it)
+    {
+        Roll* roll = *it;
+        Roll::PlayerVote::iterator itr2 = roll->playerVote.find(guid);
+        if (itr2 == roll->playerVote.end())
+            continue;
+
+        if (itr2->second == GREED || itr2->second == DISENCHANT)
+            --roll->totalGreed;
+        else if (itr2->second == NEED)
+            --roll->totalNeed;
+        else if (itr2->second == PASS)
+            --roll->totalPass;
+
+        if (itr2->second != NOT_VALID)
+            --roll->totalPlayersRolling;
+
+        roll->playerVote.erase(itr2);
+
+        CountRollVote(guid, roll->itemGUID, GetMembersCount()-1, MAX_ROLL_TYPE);
+    }
+}
+
+bool Group::_setMembersGroup(const uint64 &guid, const uint8 &group)
+{
+    member_witerator slot = _getMemberWSlot(guid);
+    if (slot == m_memberSlots.end())
+        return false;
+
+    slot->group = group;
+
+    SubGroupCounterIncrease(group);
+
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("UPDATE group_member SET subgroup='%u' WHERE memberGuid='%u'", group, GUID_LOPART(guid));
+
+    return true;
+}
+
+bool Group::_setAssistantFlag(const uint64 &guid, const bool &apply)
+{
+    member_witerator slot = _getMemberWSlot(guid);
+    if (slot == m_memberSlots.end())
+        return false;
+
+    ToggleGroupMemberFlag(slot, MEMBER_FLAG_ASSISTANT, apply);
+
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
+
+    return true;
+}
+
+bool Group::_setMainTank(const uint64 &guid, const bool &apply)
+{
+    member_witerator slot = _getMemberWSlot(guid);  // First check member slots to see if the target exists
+    if (slot == m_memberSlots.end())
+        return false;
+
+    RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINTANK);          // Remove main tank flag from current if any.
+    ToggleGroupMemberFlag(slot, MEMBER_FLAG_MAINTANK, apply);   // And apply main tank flag on new main tank.
+
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
+
+    return true;
+}
+
+bool Group::_setMainAssistant(const uint64 &guid, const bool &apply)
+{
+    member_witerator slot = _getMemberWSlot(guid);
+    if (slot == m_memberSlots.end())
+        return false;
+
+    RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINASSIST);         // Remove main assist flag from current if any.
+    ToggleGroupMemberFlag(slot, MEMBER_FLAG_MAINASSIST, apply);  // Apply main assist flag on new main assist.
+
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
+
+    return true;
+}
+
+bool Group::SameSubGroup(Player const* member1, Player const* member2) const
+{
+    if (!member1 || !member2)
+        return false;
+    if (member1->GetGroup() != this || member2->GetGroup() != this)
+        return false;
+    else
+        return member1->GetSubGroup() == member2->GetSubGroup();
+}
+
+// allows setting subgroup for offline members
+void Group::ChangeMembersGroup(const uint64 &guid, const uint8 &group)
+{
+    if (!isRaidGroup())
+        return;
+
+    Player *player = sObjectMgr.GetPlayer(guid);
+
+    if (!player)
+    {
+        uint8 prevSubGroup = GetMemberGroup(guid);
+        if (prevSubGroup == group)
+            return;
+
+        if (_setMembersGroup(guid, group))
+        {
+            SubGroupCounterDecrease(prevSubGroup);
+            SendUpdate();
+        }
+    }
+    else
+        // This methods handles itself groupcounter decrease
+        ChangeMembersGroup(player, group);
+}
+
+// only for online members
+void Group::ChangeMembersGroup(Player *player, const uint8 &group)
+{
+    if (!player || !isRaidGroup())
+        return;
+
+    uint8 prevSubGroup = player->GetSubGroup();
+    if (prevSubGroup == group)
+        return;
+
+    if (_setMembersGroup(player->GetGUID(), group))
+    {
+        if (player->GetGroup() == this)
+            player->GetGroupRef().setSubGroup(group);
+        else
+        {
+            //if player is in BG raid, it is possible that he is also in normal raid - and that normal raid is stored in m_originalGroup reference
+            prevSubGroup = player->GetOriginalSubGroup();
+            player->GetOriginalGroupRef().setSubGroup(group);
+        }
+
+        SubGroupCounterDecrease(prevSubGroup);
+        SendUpdate();
+    }
+}
+
+// Retrieve the next Round-Roubin player for the group
+//
+// No update done if loot method is Master or FFA.
+//
+// If the RR player is not yet set for the group, the first group member becomes the round-robin player.
+// If the RR player is set, the next player in group becomes the round-robin player.
+//
+// If ifneed is true,
+//      the current RR player is checked to be near the looted object.
+//      if yes, no update done.
+//      if not, he looses his turn.
+void Group::UpdateLooterGuid(WorldObject* pLootedObject, bool ifneed)
+{
+    switch (GetLootMethod())
+    {
+        case MASTER_LOOT:
+        case FREE_FOR_ALL:
+            return;
+        default:
+            // round robin style looting applies for all low
+            // quality items in each loot method except free for all and master loot
+            break;
+    }
+
+    uint64 oldLooterGUID = GetLooterGuid();
+    member_citerator guid_itr = _getMemberCSlot(oldLooterGUID);
+    if (guid_itr != m_memberSlots.end())
+    {
+        if (ifneed)
+        {
+            // not update if only update if need and ok
+            Player* looter = ObjectAccessor::FindPlayer(guid_itr->guid);
+            if (looter && looter->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
+                return;
+        }
+        ++guid_itr;
+    }
+
+    // search next after current
+    Player *pNewLooter = NULL;
+    for (member_citerator itr = guid_itr; itr != m_memberSlots.end(); ++itr)
+    {
+        if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+            if (pl->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
+            {
+                pNewLooter = pl;
+                break;
+            }
+    }
+
+    if (!pNewLooter)
+    {
+        // search from start
+        for (member_citerator itr = m_memberSlots.begin(); itr != guid_itr; ++itr)
+        {
+            if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+                if (pl->IsWithinDistInMap(pLootedObject,sWorld.getFloatConfig(CONFIG_GROUP_XP_DISTANCE),false))
+                {
+                    pNewLooter = pl;
+                    break;
+                }
+        }
+    }
+
+    if (pNewLooter)
+    {
+        if (oldLooterGUID != pNewLooter->GetGUID())
+        {
+            SetLooterGuid(pNewLooter->GetGUID());
+            SendUpdate();
+        }
+    }
+    else
+    {
+        SetLooterGuid(0);
+        SendUpdate();
+    }
+}
+
+GroupJoinBattlegroundResult Group::CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 /*MaxPlayerCount*/, bool isRated, uint32 arenaSlot)
+{
+    BattlemasterListEntry const* bgEntry = sBattlemasterListStore.LookupEntry(bgOrTemplate->GetTypeID());
+    if (!bgEntry)
+        return ERR_GROUP_JOIN_BATTLEGROUND_FAIL;            // shouldn't happen
+
+    // check for min / max count
+    uint32 memberscount = GetMembersCount();
+
+    if (memberscount > bgEntry->maxGroupSize)                // no MinPlayerCount for battlegrounds
+        return ERR_BATTLEGROUND_NONE;                        // ERR_GROUP_JOIN_BATTLEGROUND_TOO_MANY handled on client side
+
+    // get a player as reference, to compare other players' stats to (arena team id, queue id based on level, etc.)
+    Player * reference = GetFirstMember()->getSource();
+    // no reference found, can't join this way
+    if (!reference)
+        return ERR_BATTLEGROUND_JOIN_FAILED;
+
+    PvPDifficultyEntry const* bracketEntry = GetBattlegroundBracketByLevel(bgOrTemplate->GetMapId(),reference->getLevel());
+    if (!bracketEntry)
+        return ERR_BATTLEGROUND_JOIN_FAILED;
+
+    uint32 arenaTeamId = reference->GetArenaTeamId(arenaSlot);
+    uint32 team = reference->GetTeam();
+
+    BattlegroundQueueTypeId bgQueueTypeIdRandom = BattlegroundMgr::BGQueueTypeId(BATTLEGROUND_RB, 0);
+
+    // check every member of the group to be able to join
+    memberscount = 0;
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next(), ++memberscount)
+    {
+        Player *member = itr->getSource();
+        // offline member? don't let join
+        if (!member)
+            return ERR_BATTLEGROUND_JOIN_FAILED;
+        // don't allow cross-faction join as group
+        if (member->GetTeam() != team)
+            return ERR_BATTLEGROUND_JOIN_TIMED_OUT;
+        // not in the same battleground level braket, don't let join
+        PvPDifficultyEntry const* memberBracketEntry = GetBattlegroundBracketByLevel(bracketEntry->mapId,member->getLevel());
+        if (memberBracketEntry != bracketEntry)
+            return ERR_BATTLEGROUND_JOIN_RANGE_INDEX;
+        // don't let join rated matches if the arena team id doesn't match
+        if (isRated && member->GetArenaTeamId(arenaSlot) != arenaTeamId)
+            return ERR_BATTLEGROUND_JOIN_FAILED;
+        // don't let join if someone from the group is already in that bg queue
+        if (member->InBattlegroundQueueForBattlegroundQueueType(bgQueueTypeId))
+            return ERR_BATTLEGROUND_JOIN_FAILED;            // not blizz-like
+        // don't let join if someone from the group is in bg queue random
+        if (member->InBattlegroundQueueForBattlegroundQueueType(bgQueueTypeIdRandom))
+            return ERR_IN_RANDOM_BG;
+        // don't let join to bg queue random if someone from the group is already in bg queue
+        if (bgOrTemplate->GetTypeID() == BATTLEGROUND_RB && member->InBattlegroundQueue())
+            return ERR_IN_NON_RANDOM_BG;
+        // check for deserter debuff in case not arena queue
+        if (bgOrTemplate->GetTypeID() != BATTLEGROUND_AA && !member->CanJoinToBattleground())
+            return ERR_GROUP_JOIN_BATTLEGROUND_DESERTERS;
+        // check if member can join any more battleground queues
+        if (!member->HasFreeBattlegroundQueueId())
+            return ERR_BATTLEGROUND_TOO_MANY_QUEUES;        // not blizz-like
+    }
+
+    // only check for MinPlayerCount since MinPlayerCount == MaxPlayerCount for arenas...
+    if (bgOrTemplate->isArena() && memberscount != MinPlayerCount)
+        return ERR_ARENA_TEAM_PARTY_SIZE;
+
+    return GroupJoinBattlegroundResult(bgOrTemplate->GetTypeID());
+}
+
+//===================================================
+//============== Roll ===============================
+//===================================================
+
+void Roll::targetObjectBuildLink()
+{
+    // called from link()
+    getTarget()->addLootValidatorRef(this);
+}
+
+void Group::SetDungeonDifficulty(Difficulty difficulty)
+{
+    m_dungeonDifficulty = difficulty;
+    if (!isBGGroup())
+       CharacterDatabase.PExecute("UPDATE groups SET difficulty = %u WHERE guid ='%u'", m_dungeonDifficulty, GUID_LOPART(m_guid));
+
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *player = itr->getSource();
+        if (!player->GetSession() || player->getLevel() < LEVELREQUIREMENT_HEROIC)
+            continue;
+
+        player->SetDungeonDifficulty(difficulty);
+        player->SendDungeonDifficulty(true);
+    }
+}
+
+void Group::SetRaidDifficulty(Difficulty difficulty)
+{
+    m_raidDifficulty = difficulty;
+    if (!isBGGroup())
+        CharacterDatabase.PExecute("UPDATE groups SET raiddifficulty = %u WHERE guid ='%u'", m_raidDifficulty, GUID_LOPART(m_guid));
+
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *player = itr->getSource();
+        if (!player->GetSession() || player->getLevel() < LEVELREQUIREMENT_HEROIC)
+            continue;
+
+        player->SetRaidDifficulty(difficulty);
+        player->SendRaidDifficulty(true);
+    }
+}
+
+bool Group::InCombatToInstance(uint32 instanceId)
+{
+    for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *pPlayer = itr->getSource();
+        if (pPlayer && pPlayer->getAttackers().size() && pPlayer->GetInstanceId() == instanceId && (pPlayer->GetMap()->IsRaidOrHeroicDungeon()))
+            for (std::set<Unit*>::const_iterator i = pPlayer->getAttackers().begin(); i != pPlayer->getAttackers().end(); ++i)
+                if ((*i) && (*i)->GetTypeId() == TYPEID_UNIT && (*i)->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
+                    return true;
+    }
+    return false;
+}
+
+void Group::ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo)
+{
+    if (isBGGroup())
+        return;
+
+    // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_DISBAND
+
+    // we assume that when the difficulty changes, all instances that can be reset will be
+    Difficulty diff = GetDifficulty(isRaid);
+
+    for (BoundInstancesMap::iterator itr = m_boundInstances[diff].begin(); itr != m_boundInstances[diff].end();)
+    {
+        InstanceSave *p = itr->second.save;
+        const MapEntry *entry = sMapStore.LookupEntry(itr->first);
+        if (!entry || entry->IsRaid() != isRaid || (!p->CanReset() && method != INSTANCE_RESET_GROUP_DISBAND))
+        {
+            ++itr;
+            continue;
+        }
+
+        if (method == INSTANCE_RESET_ALL)
+        {
+            // the "reset all instances" method can only reset normal maps
+            if (entry->map_type == MAP_RAID || diff == DUNGEON_DIFFICULTY_HEROIC)
+            {
+                ++itr;
+                continue;
+            }
+        }
+
+        bool isEmpty = true;
+        // if the map is loaded, reset it
+        Map *map = sMapMgr.FindMap(p->GetMapId(), p->GetInstanceId());
+        if (map && map->IsDungeon() && !(method == INSTANCE_RESET_GROUP_DISBAND && !p->CanReset()))
+        {
+            if (p->CanReset())
+                isEmpty = ((InstanceMap*)map)->Reset(method);
+            else
+                isEmpty = !map->HavePlayers();
+        }
+
+        if (SendMsgTo)
+        {
+            if (isEmpty)
+                SendMsgTo->SendResetInstanceSuccess(p->GetMapId());
+            else
+                SendMsgTo->SendResetInstanceFailed(0, p->GetMapId());
+        }
+
+        if (isEmpty || method == INSTANCE_RESET_GROUP_DISBAND || method == INSTANCE_RESET_CHANGE_DIFFICULTY)
+        {
+            // do not reset the instance, just unbind if others are permanently bound to it
+            if (p->CanReset())
+                p->DeleteFromDB();
+            else
+                CharacterDatabase.PExecute("DELETE FROM group_instance WHERE instance = '%u'", p->GetInstanceId());
+
+            // i don't know for sure if hash_map iterators
+            m_boundInstances[diff].erase(itr);
+            itr = m_boundInstances[diff].begin();
+            // this unloads the instance save unless online players are bound to it
+            // (eg. permanent binds or GM solo binds)
+            p->RemoveGroup(this);
+        }
+        else
+            ++itr;
+    }
+}
+
+InstanceGroupBind* Group::GetBoundInstance(Player* player)
+{
+    uint32 mapid = player->GetMapId();
+    MapEntry const* mapEntry = sMapStore.LookupEntry(mapid);
+    return GetBoundInstance(mapEntry);
+}
+
+InstanceGroupBind* Group::GetBoundInstance(Map* aMap)
+{
+    // Currently spawn numbering not different from map difficulty
+    Difficulty difficulty = GetDifficulty(aMap->IsRaid());
+
+    // some instances only have one difficulty
+    GetDownscaledMapDifficultyData(aMap->GetId(),difficulty);
+
+    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(aMap->GetId());
+    if (itr != m_boundInstances[difficulty].end())
+        return &itr->second;
+    else
+        return NULL;
+}
+
+InstanceGroupBind* Group::GetBoundInstance(MapEntry const* mapEntry)
+{
+    if (!mapEntry)
+        return NULL;
+
+    Difficulty difficulty = GetDifficulty(mapEntry->IsRaid());
+
+    // some instances only have one difficulty
+    GetDownscaledMapDifficultyData(mapEntry->MapID,difficulty);
+
+    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapEntry->MapID);
+    if (itr != m_boundInstances[difficulty].end())
+        return &itr->second;
+    else
+        return NULL;
+}
+
+
+InstanceGroupBind* Group::BindToInstance(InstanceSave *save, bool permanent, bool load)
+{
+    if (!save || isBGGroup())
+        return NULL;
+
+    InstanceGroupBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
+    if (!load && (!bind.save || permanent != bind.perm || save != bind.save))
+        CharacterDatabase.PExecute("REPLACE INTO group_instance (guid, instance, permanent) VALUES (%u, %u, %u)", GUID_LOPART(GetGUID()), save->GetInstanceId(), permanent);
+
+    if (bind.save != save)
+    {
+        if (bind.save)
+            bind.save->RemoveGroup(this);
+        save->AddGroup(this);
+    }
+
+    bind.save = save;
+    bind.perm = permanent;
+    if (!load)
+        sLog.outDebug("Group::BindToInstance: %d is now bound to map %d, instance %d, difficulty %d", GUID_LOPART(GetGUID()), save->GetMapId(), save->GetInstanceId(), save->GetDifficulty());
+    return &bind;
+}
+
+void Group::UnbindInstance(uint32 mapid, uint8 difficulty, bool unload)
+{
+    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
+    if (itr != m_boundInstances[difficulty].end())
+    {
+        if (!unload)
+            CharacterDatabase.PExecute("DELETE FROM group_instance WHERE guid=%u AND instance=%u", GUID_LOPART(GetGUID()), itr->second.save->GetInstanceId());
+        itr->second.save->RemoveGroup(this);                // save can become invalid
+        m_boundInstances[difficulty].erase(itr);
+    }
+}
+
+void Group::_homebindIfInstance(Player *player)
+{
+    if (player && !player->isGameMaster() && sMapStore.LookupEntry(player->GetMapId())->IsDungeon())
+        player->m_InstanceValid = false;
+}
+
+void Group::BroadcastGroupUpdate(void)
+{
+    // FG: HACK: force flags update on group leave - for values update hack
+    // -- not very efficient but safe
+    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
+    {
+
+        Player *pp = sObjectMgr.GetPlayer(citr->guid);
+        if (pp && pp->IsInWorld())
+        {
+            pp->ForceValuesUpdateAtIndex(UNIT_FIELD_BYTES_2);
+            pp->ForceValuesUpdateAtIndex(UNIT_FIELD_FACTIONTEMPLATE);
+            sLog.outStaticDebug("-- Forced group value update for '%s'", pp->GetName());
+        }
+    }
+}
+
+void Group::ResetMaxEnchantingLevel()
+{
+    m_maxEnchantingLevel = 0;
+    Player *pMember = NULL;
+    for (member_citerator citr = m_memberSlots.begin(); citr != m_memberSlots.end(); ++citr)
+    {
+        pMember = sObjectMgr.GetPlayer(citr->guid);
+        if (pMember && m_maxEnchantingLevel < pMember->GetSkillValue(SKILL_ENCHANTING))
+            m_maxEnchantingLevel = pMember->GetSkillValue(SKILL_ENCHANTING);
+    }
+}
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -1,515 +1,513 @@
-﻿/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#ifndef TRINITYCORE_GROUP_H
-#define TRINITYCORE_GROUP_H
-
-#include "GroupReference.h"
-#include "GroupRefManager.h"
-#include "DBCEnums.h"
-#include "Battleground.h"
-
-#include <map>
-#include <vector>
-
-#define MAXGROUPSIZE 5
-#define MAXRAIDSIZE 40
-#define MAX_RAID_SUBGROUPS MAXRAIDSIZE/MAXGROUPSIZE
-#define TARGETICONCOUNT 8
-#define GROUP_MAX_LFG_KICKS 3
-#define GROUP_LFG_KICK_VOTES_NEEDED 3
-
-class InstanceSave;
-class Player;
-class Unit;
-class WorldSession;
-
-enum RollVote
-{
-    PASS              = 0,
-    NEED              = 1,
-    GREED             = 2,
-    DISENCHANT        = 3,
-    NOT_EMITED_YET    = 4,
-    NOT_VALID         = 5
-};
-
-enum LfgDungeonStatus
-{
-    LFG_STATUS_SAVED     = 0,
-    LFG_STATUS_NOT_SAVED = 1,
-    LFG_STATUS_COMPLETE  = 2,
-};
-
-enum GroupMemberOnlineStatus
-{
-    MEMBER_STATUS_OFFLINE   = 0x0000,
-    MEMBER_STATUS_ONLINE    = 0x0001,
-    MEMBER_STATUS_PVP       = 0x0002,
-    MEMBER_STATUS_UNK0      = 0x0004,                       // dead? (health=0)
-    MEMBER_STATUS_UNK1      = 0x0008,                       // ghost? (health=1)
-    MEMBER_STATUS_UNK2      = 0x0010,                       // never seen
-    MEMBER_STATUS_UNK3      = 0x0020,                       // never seen
-    MEMBER_STATUS_UNK4      = 0x0040,                       // appears with dead and ghost flags
-    MEMBER_STATUS_UNK5      = 0x0080,                       // never seen
-};
-
-enum GroupMemberFlags
-{
-    MEMBER_FLAG_ASSISTANT   = 0x01,
-    MEMBER_FLAG_MAINTANK    = 0x02,
-    MEMBER_FLAG_MAINASSIST  = 0x04,
-};
-
-enum GroupType
-{
-    GROUPTYPE_NORMAL = 0x00,
-    GROUPTYPE_BG     = 0x01,
-    GROUPTYPE_RAID   = 0x02,
-    GROUPTYPE_BGRAID = GROUPTYPE_BG | GROUPTYPE_RAID,       // mask
-    GROUPTYPE_UNK1   = 0x04,
-    GROUPTYPE_LFG    = 0x08,
-    // 0x10, leave/change group?, I saw this flag when leaving group and after leaving BG while in group
-};
-
-enum GroupUpdateFlags
-{
-    GROUP_UPDATE_FLAG_NONE              = 0x00000000,       // nothing
-    GROUP_UPDATE_FLAG_STATUS            = 0x00000001,       // uint16, flags
-    GROUP_UPDATE_FLAG_CUR_HP            = 0x00000002,       // uint32
-    GROUP_UPDATE_FLAG_MAX_HP            = 0x00000004,       // uint32
-    GROUP_UPDATE_FLAG_POWER_TYPE        = 0x00000008,       // uint8
-    GROUP_UPDATE_FLAG_CUR_POWER         = 0x00000010,       // uint16
-    GROUP_UPDATE_FLAG_MAX_POWER         = 0x00000020,       // uint16
-    GROUP_UPDATE_FLAG_LEVEL             = 0x00000040,       // uint16
-    GROUP_UPDATE_FLAG_ZONE              = 0x00000080,       // uint16
-    GROUP_UPDATE_FLAG_POSITION          = 0x00000100,       // uint16, uint16
-    GROUP_UPDATE_FLAG_AURAS             = 0x00000200,       // uint64 mask, for each bit set uint32 spellid + uint8 unk
-    GROUP_UPDATE_FLAG_PET_GUID          = 0x00000400,       // uint64 pet guid
-    GROUP_UPDATE_FLAG_PET_NAME          = 0x00000800,       // pet name, NULL terminated string
-    GROUP_UPDATE_FLAG_PET_MODEL_ID      = 0x00001000,       // uint16, model id
-    GROUP_UPDATE_FLAG_PET_CUR_HP        = 0x00002000,       // uint32 pet cur health
-    GROUP_UPDATE_FLAG_PET_MAX_HP        = 0x00004000,       // uint32 pet max health
-    GROUP_UPDATE_FLAG_PET_POWER_TYPE    = 0x00008000,       // uint8 pet power type
-    GROUP_UPDATE_FLAG_PET_CUR_POWER     = 0x00010000,       // uint16 pet cur power
-    GROUP_UPDATE_FLAG_PET_MAX_POWER     = 0x00020000,       // uint16 pet max power
-    GROUP_UPDATE_FLAG_PET_AURAS         = 0x00040000,       // uint64 mask, for each bit set uint32 spellid + uint8 unk, pet auras...
-    GROUP_UPDATE_FLAG_VEHICLE_SEAT      = 0x00080000,       // uint32 vehicle_seat_id (index from VehicleSeat.dbc)
-    GROUP_UPDATE_PET                    = 0x0007FC00,       // all pet flags
-    GROUP_UPDATE_FULL                   = 0x0007FFFF,       // all known flags
-};
-
-enum RemoveMethod
-{
-    GROUP_REMOVEMETHOD_DEFAULT = 0,
-    GROUP_REMOVEMETHOD_KICK    = 1,
-    GROUP_REMOVEMETHOD_LEAVE   = 2,
-};
-
-#define GROUP_UPDATE_FLAGS_COUNT          20
-                                                                // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13,14,15,16,17,18,19
-static const uint8 GroupUpdateLength[GROUP_UPDATE_FLAGS_COUNT] = { 0, 2, 2, 2, 1, 2, 2, 2, 2, 4, 8, 8, 1, 2, 2, 2, 1, 2, 2, 8};
-
-class Roll : public LootValidatorRef
-{
-    public:
-        Roll(uint64 _guid, LootItem const& li)
-            : itemGUID(_guid), itemid(li.itemid), itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
-            totalPlayersRolling(0), totalNeed(0), totalGreed(0), totalPass(0), itemSlot(0), rollVoteMask(ROLL_ALL_TYPE_NO_DISENCHANT) {}
-        ~Roll() { }
-        void setLoot(Loot *pLoot) { link(pLoot, this); }
-        Loot *getLoot() { return getTarget(); }
-        void targetObjectBuildLink();
-
-        uint64 itemGUID;
-        uint32 itemid;
-        int32  itemRandomPropId;
-        uint32 itemRandomSuffix;
-        uint8 itemCount;
-        typedef std::map<uint64, RollVote> PlayerVote;
-        PlayerVote playerVote;                              //vote position correspond with player position (in group)
-        uint8 totalPlayersRolling;
-        uint8 totalNeed;
-        uint8 totalGreed;
-        uint8 totalPass;
-        uint8 itemSlot;
-        uint8 rollVoteMask;
-};
-
-struct InstanceGroupBind
-{
-    InstanceSave *save;
-    bool perm;
-    /* permanent InstanceGroupBinds exist if the leader has a permanent
-       PlayerInstanceBind for the same instance. */
-    InstanceGroupBind() : save(NULL), perm(false) {}
-};
-
-/** request member stats checken **/
-/** todo: uninvite people that not accepted invite **/
-class Group
-{
-    public:
-        struct MemberSlot
-        {
-            uint64      guid;
-            std::string name;
-            uint8       group;
-            uint8       flags;
-            uint8       roles;
-        };
-        typedef std::list<MemberSlot> MemberSlotList;
-        typedef MemberSlotList::const_iterator member_citerator;
-
-        typedef UNORDERED_MAP< uint32 /*mapId*/, InstanceGroupBind> BoundInstancesMap;
-    protected:
-        typedef MemberSlotList::iterator member_witerator;
-        typedef std::set<Player*> InvitesList;
-
-        typedef std::vector<Roll*> Rolls;
-
-    public:
-        Group();
-        ~Group();
-
-        // group manipulation methods
-        bool   Create(const uint64 &guid, const char * name);
-        bool   LoadGroupFromDB(const uint32 &guid, QueryResult result, bool loadMembers = true);
-        bool   LoadMemberFromDB(uint32 guidLow, uint8 memberFlags, uint8 subgroup, uint8 roles);
-        bool   AddInvite(Player *player);
-        uint32 RemoveInvite(Player *player);
-        void   RemoveAllInvites();
-        bool   AddLeaderInvite(Player *player);
-        bool   AddMember(const uint64 &guid, const char* name, SQLTransaction& trans);
-        uint32 RemoveMember(const uint64 &guid, const RemoveMethod &method = GROUP_REMOVEMETHOD_DEFAULT);
-        void   ChangeLeader(const uint64 &guid);
-        void   SetLootMethod(LootMethod method) { m_lootMethod = method; }
-        void   SetLooterGuid(const uint64 &guid) { m_looterGuid = guid; }
-        void   UpdateLooterGuid(WorldObject* pLootedObject, bool ifneed = false);
-        void   SetLootThreshold(ItemQualities threshold) { m_lootThreshold = threshold; }
-        void   Disband(bool hideDestroy=false);
-
-        // Dungeon Finder
-        void   SetLfgQueued(bool queued) { m_LfgQueued = queued; }
-        bool   isLfgQueued() { return m_LfgQueued; }
-        void   SetLfgStatus(uint8 status) { m_LfgStatus = status; }
-        uint8  GetLfgStatus() { return m_LfgStatus; }
-        bool   isLfgDungeonComplete() const { return m_LfgStatus == LFG_STATUS_COMPLETE; }
-        void   SetLfgDungeonEntry(uint32 dungeonEntry) { m_LfgDungeonEntry = dungeonEntry; }
-        uint32 GetLfgDungeonEntry(bool id = true)
-        {
-            if (id)
-                return (m_LfgDungeonEntry & 0x00FFFFFF);
-            else
-                return m_LfgDungeonEntry;
-        }
-        bool   isLfgKickActive() const { return m_LfgkicksActive; }
-        void   SetLfgKickActive(bool active) { m_LfgkicksActive = active; }
-        uint8  GetLfgKicks() const { return m_Lfgkicks; }
-        void   SetLfgKicks(uint8 kicks) { m_Lfgkicks = kicks; }
-        void   SetLfgRoles(uint64 guid, const uint8 roles)
-        {
-            member_witerator slot = _getMemberWSlot(guid);
-            if (slot == m_memberSlots.end())
-                return;
-
-            slot->roles = roles;
-            SendUpdate();
-        }
-
-        // properties accessories
-        bool IsFull() const { return isRaidGroup() ? (m_memberSlots.size() >= MAXRAIDSIZE) : (m_memberSlots.size() >= MAXGROUPSIZE); }
-        bool isLFGGroup()  const { return m_groupType & GROUPTYPE_LFG; }
-        bool isRaidGroup() const { return m_groupType & GROUPTYPE_RAID; }
-        bool isBGGroup()   const { return m_bgGroup != NULL; }
-        bool IsCreated()   const { return GetMembersCount() > 0; }
-        const uint64& GetLeaderGUID() const { return m_leaderGuid; }
-        const uint64& GetGUID() const { return m_guid; }
-        uint32 GetLowGUID() const { return GUID_LOPART(m_guid); }
-        const char * GetLeaderName() const { return m_leaderName.c_str(); }
-        LootMethod    GetLootMethod() const { return m_lootMethod; }
-        const uint64& GetLooterGuid() const { return m_looterGuid; }
-        ItemQualities GetLootThreshold() const { return m_lootThreshold; }
-
-        // member manipulation methods
-        bool IsMember(const uint64& guid) const { return _getMemberCSlot(guid) != m_memberSlots.end(); }
-        bool IsLeader(const uint64& guid) const { return (GetLeaderGUID() == guid); }
-        uint64 GetMemberGUID(const std::string& name)
-        {
-            for (member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
-            {
-                if (itr->name == name)
-                {
-                    return itr->guid;
-                }
-            }
-            return 0;
-        }
-        bool IsAssistant(uint64 guid) const
-        {
-            member_citerator mslot = _getMemberCSlot(guid);
-            if (mslot == m_memberSlots.end())
-                return false;
-
-            return mslot->flags & MEMBER_FLAG_ASSISTANT;
-        }
-        Player* GetInvited(const uint64& guid) const;
-        Player* GetInvited(const std::string& name) const;
-
-        bool SameSubGroup(uint64 guid1,const uint64& guid2) const
-        {
-            member_citerator mslot2 = _getMemberCSlot(guid2);
-            if (mslot2 == m_memberSlots.end())
-                return false;
-
-            return SameSubGroup(guid1,&*mslot2);
-        }
-
-        bool SameSubGroup(uint64 guid1, MemberSlot const* slot2) const
-        {
-            member_citerator mslot1 = _getMemberCSlot(guid1);
-            if (mslot1 == m_memberSlots.end() || !slot2)
-                return false;
-
-            return (mslot1->group == slot2->group);
-        }
-
-        bool HasFreeSlotSubGroup(uint8 subgroup) const
-        {
-            return (m_subGroupsCounts && m_subGroupsCounts[subgroup] < MAXGROUPSIZE);
-        }
-
-        bool SameSubGroup(Player const* member1, Player const* member2) const;
-
-        MemberSlotList const& GetMemberSlots() const { return m_memberSlots; }
-        GroupReference* GetFirstMember() { return m_memberMgr.getFirst(); }
-        uint32 GetMembersCount() const { return m_memberSlots.size(); }
-        void GetDataForXPAtKill(Unit const* victim, uint32& count,uint32& sum_level, Player* & member_with_max_level, Player* & not_gray_member_with_max_level);
-        uint8  GetMemberGroup(uint64 guid) const
-        {
-            member_citerator mslot = _getMemberCSlot(guid);
-            if (mslot == m_memberSlots.end())
-                return (MAX_RAID_SUBGROUPS+1);
-
-            return mslot->group;
-        }
-
-        void ConvertToLFG();
-        // some additional raid methods
-        void ConvertToRaid();
-
-        void SetBattlegroundGroup(Battleground *bg) { m_bgGroup = bg; }
-        GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
-
-        void ChangeMembersGroup(const uint64 &guid, const uint8 &group);
-        void ChangeMembersGroup(Player *player, const uint8 &group);
-
-        void SetAssistant(uint64 guid, const bool &apply)
-        {
-            if (!isRaidGroup())
-                return;
-            if (_setAssistantFlag(guid, apply))
-                SendUpdate();
-        }
-        void SetMainTank(uint64 guid, const bool &apply)
-        {
-            if (!isRaidGroup())
-                return;
-
-            if (_setMainTank(guid, apply))
-                SendUpdate();
-        }
-        void SetMainAssistant(uint64 guid, const bool &apply)
-        {
-            if (!isRaidGroup())
-                return;
-
-            if (_setMainAssistant(guid, apply))
-                SendUpdate();
-        }
-
-        void SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid);
-
-        Difficulty GetDifficulty(bool isRaid) const { return isRaid ? m_raidDifficulty : m_dungeonDifficulty; }
-        Difficulty GetDungeonDifficulty() const { return m_dungeonDifficulty; }
-        Difficulty GetRaidDifficulty() const { return m_raidDifficulty; }
-        void SetDungeonDifficulty(Difficulty difficulty);
-        void SetRaidDifficulty(Difficulty difficulty);
-        uint16 InInstance();
-        bool InCombatToInstance(uint32 instanceId);
-        void ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo);
-
-        // -no description-
-        //void SendInit(WorldSession *session);
-        void SendTargetIconList(WorldSession *session);
-        void SendUpdate();
-        void UpdatePlayerOutOfRange(Player* pPlayer);
-                                                            // ignore: GUID of player that will be ignored
-        void BroadcastPacket(WorldPacket *packet, bool ignorePlayersInBGRaid, int group=-1, uint64 ignore=0);
-        void BroadcastReadyCheck(WorldPacket *packet);
-        void OfflineReadyCheck();
-
-        /*********************************************************/
-        /***                   LOOT SYSTEM                     ***/
-        /*********************************************************/
-
-        bool isRollLootActive() const { return !RollId.empty(); }
-        void SendLootStartRoll(uint32 CountDown, uint32 mapid, const Roll &r);
-        void SendLootRoll(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r);
-        void SendLootRollWon(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r);
-        void SendLootAllPassed(uint32 NumberOfPlayers, const Roll &r);
-        void SendLooter(Creature *pCreature, Player *pLooter);
-        void GroupLoot(Loot *loot, WorldObject* pLootedObject);
-        void NeedBeforeGreed(Loot *loot, WorldObject* pLootedObject);
-        void MasterLoot(Loot *loot, WorldObject* pLootedObject);
-        Rolls::iterator GetRoll(uint64 Guid)
-        {
-            Rolls::iterator iter;
-            for (iter=RollId.begin(); iter != RollId.end(); ++iter)
-            {
-                if ((*iter)->itemGUID == Guid && (*iter)->isValid())
-                {
-                    return iter;
-                }
-            }
-            return RollId.end();
-        }
-        void CountTheRoll(Rolls::iterator roll, uint32 NumberOfPlayers);
-        void CountRollVote(const uint64& playerGUID, const uint64& Guid, uint32 NumberOfPlayers, uint8 Choise);
-        void EndRoll(Loot *loot);
-
-        // related to disenchant rolls
-        void ResetMaxEnchantingLevel();
-
-        void LinkMember(GroupReference *pRef) { m_memberMgr.insertFirst(pRef); }
-        void DelinkMember(GroupReference* /*pRef*/) { }
-
-        InstanceGroupBind* BindToInstance(InstanceSave *save, bool permanent, bool load = false);
-        void UnbindInstance(uint32 mapid, uint8 difficulty, bool unload = false);
-        InstanceGroupBind* GetBoundInstance(Player* player);
-        InstanceGroupBind* GetBoundInstance(Map* aMap);
-        InstanceGroupBind* GetBoundInstance(MapEntry const* mapEntry);
-        BoundInstancesMap& GetBoundInstances(Difficulty difficulty) { return m_boundInstances[difficulty]; }
-
-        // FG: evil hacks
-        void BroadcastGroupUpdate(void);
-
-    protected:
-        bool _addMember(const uint64 &guid, const char* name, SQLTransaction& trans);
-        bool _addMember(const uint64 &guid, const char* name, uint8 group, SQLTransaction& trans);
-        bool _removeMember(const uint64 &guid);             // returns true if leader has changed
-        void _setLeader(const uint64 &guid);
-
-        void _removeRolls(const uint64 &guid);
-
-        bool _setMembersGroup(const uint64 &guid, const uint8 &group);
-        bool _setAssistantFlag(const uint64 &guid, const bool &apply);
-        bool _setMainTank(const uint64 &guid, const bool &apply);
-        bool _setMainAssistant(const uint64 &guid, const bool &apply);
-
-        void _homebindIfInstance(Player *player);
-
-        void _initRaidSubGroupsCounter()
-        {
-            // Sub group counters initialization
-            if (!m_subGroupsCounts)
-                m_subGroupsCounts = new uint8[MAX_RAID_SUBGROUPS];
-
-            memset((void*)m_subGroupsCounts, 0, (MAX_RAID_SUBGROUPS)*sizeof(uint8));
-
-            for (member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
-                ++m_subGroupsCounts[itr->group];
-        }
-
-        member_citerator _getMemberCSlot(uint64 Guid) const
-        {
-            for (member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
-            {
-                if (itr->guid == Guid)
-                    return itr;
-            }
-            return m_memberSlots.end();
-        }
-
-        member_witerator _getMemberWSlot(uint64 Guid)
-        {
-            for (member_witerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
-            {
-                if (itr->guid == Guid)
-                    return itr;
-            }
-            return m_memberSlots.end();
-        }
-
-        void SubGroupCounterIncrease(uint8 subgroup)
-        {
-            if (m_subGroupsCounts)
-                ++m_subGroupsCounts[subgroup];
-        }
-
-        void SubGroupCounterDecrease(uint8 subgroup)
-        {
-            if (m_subGroupsCounts)
-                --m_subGroupsCounts[subgroup];
-        }
-
-        void RemoveUniqueGroupMemberFlag(GroupMemberFlags flag)
-        {
-            for (member_witerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
-            {
-                if (itr->flags & flag)
-                    itr->flags &= ~flag;
-            }
-        }
-
-        void ToggleGroupMemberFlag(member_witerator slot, uint8 flag, bool apply)
-        {
-            if (apply)
-                slot->flags |= flag;
-            else
-                slot->flags &= ~flag;
-        }
-
-        MemberSlotList      m_memberSlots;
-        GroupRefManager     m_memberMgr;
-        InvitesList         m_invitees;
-        uint64              m_leaderGuid;
-        std::string         m_leaderName;
-        GroupType           m_groupType;
-        Difficulty          m_dungeonDifficulty;
-        Difficulty          m_raidDifficulty;
-        Battleground*       m_bgGroup;
-        uint64              m_targetIcons[TARGETICONCOUNT];
-        LootMethod          m_lootMethod;
-        ItemQualities       m_lootThreshold;
-        uint64              m_looterGuid;
-        Rolls               RollId;
-        BoundInstancesMap   m_boundInstances[MAX_DIFFICULTY];
-        uint8*              m_subGroupsCounts;
-        uint64              m_guid;
-        uint32              m_counter;                      // used only in SMSG_GROUP_LIST
-        uint32              m_maxEnchantingLevel;
-        bool                m_LfgQueued;
-        uint8               m_LfgStatus;
-        uint32              m_LfgDungeonEntry;
-        uint8               m_Lfgkicks;
-        bool                m_LfgkicksActive;
-};
-#endif
+﻿/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITYCORE_GROUP_H
+#define TRINITYCORE_GROUP_H
+
+#include "GroupReference.h"
+#include "GroupRefManager.h"
+#include "DBCEnums.h"
+#include "Battleground.h"
+
+#include <map>
+#include <vector>
+
+#define MAXGROUPSIZE 5
+#define MAXRAIDSIZE 40
+#define MAX_RAID_SUBGROUPS MAXRAIDSIZE/MAXGROUPSIZE
+#define TARGETICONCOUNT 8
+#define GROUP_MAX_LFG_KICKS 3
+#define GROUP_LFG_KICK_VOTES_NEEDED 3
+
+class InstanceSave;
+class Player;
+class Unit;
+class WorldSession;
+
+enum RollVote
+{
+    PASS              = 0,
+    NEED              = 1,
+    GREED             = 2,
+    DISENCHANT        = 3,
+    NOT_EMITED_YET    = 4,
+    NOT_VALID         = 5
+};
+
+enum LfgDungeonStatus
+{
+    LFG_STATUS_SAVED     = 0,
+    LFG_STATUS_NOT_SAVED = 1,
+    LFG_STATUS_COMPLETE  = 2,
+};
+
+enum GroupMemberOnlineStatus
+{
+    MEMBER_STATUS_OFFLINE   = 0x0000,
+    MEMBER_STATUS_ONLINE    = 0x0001,
+    MEMBER_STATUS_PVP       = 0x0002,
+    MEMBER_STATUS_UNK0      = 0x0004,                       // dead? (health=0)
+    MEMBER_STATUS_UNK1      = 0x0008,                       // ghost? (health=1)
+    MEMBER_STATUS_UNK2      = 0x0010,                       // never seen
+    MEMBER_STATUS_UNK3      = 0x0020,                       // never seen
+    MEMBER_STATUS_UNK4      = 0x0040,                       // appears with dead and ghost flags
+    MEMBER_STATUS_UNK5      = 0x0080,                       // never seen
+};
+
+enum GroupMemberFlags
+{
+    MEMBER_FLAG_ASSISTANT   = 0x01,
+    MEMBER_FLAG_MAINTANK    = 0x02,
+    MEMBER_FLAG_MAINASSIST  = 0x04,
+};
+
+enum GroupType
+{
+    GROUPTYPE_NORMAL = 0x00,
+    GROUPTYPE_BG     = 0x01,
+    GROUPTYPE_RAID   = 0x02,
+    GROUPTYPE_BGRAID = GROUPTYPE_BG | GROUPTYPE_RAID,       // mask
+    GROUPTYPE_UNK1   = 0x04,
+    GROUPTYPE_LFG    = 0x08,
+    // 0x10, leave/change group?, I saw this flag when leaving group and after leaving BG while in group
+};
+
+enum GroupUpdateFlags
+{
+    GROUP_UPDATE_FLAG_NONE              = 0x00000000,       // nothing
+    GROUP_UPDATE_FLAG_STATUS            = 0x00000001,       // uint16, flags
+    GROUP_UPDATE_FLAG_CUR_HP            = 0x00000002,       // uint32
+    GROUP_UPDATE_FLAG_MAX_HP            = 0x00000004,       // uint32
+    GROUP_UPDATE_FLAG_POWER_TYPE        = 0x00000008,       // uint8
+    GROUP_UPDATE_FLAG_CUR_POWER         = 0x00000010,       // uint16
+    GROUP_UPDATE_FLAG_MAX_POWER         = 0x00000020,       // uint16
+    GROUP_UPDATE_FLAG_LEVEL             = 0x00000040,       // uint16
+    GROUP_UPDATE_FLAG_ZONE              = 0x00000080,       // uint16
+    GROUP_UPDATE_FLAG_POSITION          = 0x00000100,       // uint16, uint16
+    GROUP_UPDATE_FLAG_AURAS             = 0x00000200,       // uint64 mask, for each bit set uint32 spellid + uint8 unk
+    GROUP_UPDATE_FLAG_PET_GUID          = 0x00000400,       // uint64 pet guid
+    GROUP_UPDATE_FLAG_PET_NAME          = 0x00000800,       // pet name, NULL terminated string
+    GROUP_UPDATE_FLAG_PET_MODEL_ID      = 0x00001000,       // uint16, model id
+    GROUP_UPDATE_FLAG_PET_CUR_HP        = 0x00002000,       // uint32 pet cur health
+    GROUP_UPDATE_FLAG_PET_MAX_HP        = 0x00004000,       // uint32 pet max health
+    GROUP_UPDATE_FLAG_PET_POWER_TYPE    = 0x00008000,       // uint8 pet power type
+    GROUP_UPDATE_FLAG_PET_CUR_POWER     = 0x00010000,       // uint16 pet cur power
+    GROUP_UPDATE_FLAG_PET_MAX_POWER     = 0x00020000,       // uint16 pet max power
+    GROUP_UPDATE_FLAG_PET_AURAS         = 0x00040000,       // uint64 mask, for each bit set uint32 spellid + uint8 unk, pet auras...
+    GROUP_UPDATE_FLAG_VEHICLE_SEAT      = 0x00080000,       // uint32 vehicle_seat_id (index from VehicleSeat.dbc)
+    GROUP_UPDATE_PET                    = 0x0007FC00,       // all pet flags
+    GROUP_UPDATE_FULL                   = 0x0007FFFF,       // all known flags
+};
+
+enum RemoveMethod
+{
+    GROUP_REMOVEMETHOD_DEFAULT = 0,
+    GROUP_REMOVEMETHOD_KICK    = 1,
+    GROUP_REMOVEMETHOD_LEAVE   = 2,
+};
+
+#define GROUP_UPDATE_FLAGS_COUNT          20
+                                                                // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13,14,15,16,17,18,19
+static const uint8 GroupUpdateLength[GROUP_UPDATE_FLAGS_COUNT] = { 0, 2, 2, 2, 1, 2, 2, 2, 2, 4, 8, 8, 1, 2, 2, 2, 1, 2, 2, 8};
+
+class Roll : public LootValidatorRef
+{
+    public:
+        Roll(uint64 _guid, LootItem const& li)
+            : itemGUID(_guid), itemid(li.itemid), itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
+            totalPlayersRolling(0), totalNeed(0), totalGreed(0), totalPass(0), itemSlot(0), rollVoteMask(ROLL_ALL_TYPE_NO_DISENCHANT) {}
+        ~Roll() { }
+        void setLoot(Loot *pLoot) { link(pLoot, this); }
+        Loot *getLoot() { return getTarget(); }
+        void targetObjectBuildLink();
+
+        uint64 itemGUID;
+        uint32 itemid;
+        int32  itemRandomPropId;
+        uint32 itemRandomSuffix;
+        uint8 itemCount;
+        typedef std::map<uint64, RollVote> PlayerVote;
+        PlayerVote playerVote;                              //vote position correspond with player position (in group)
+        uint8 totalPlayersRolling;
+        uint8 totalNeed;
+        uint8 totalGreed;
+        uint8 totalPass;
+        uint8 itemSlot;
+        uint8 rollVoteMask;
+};
+
+struct InstanceGroupBind
+{
+    InstanceSave *save;
+    bool perm;
+    /* permanent InstanceGroupBinds exist if the leader has a permanent
+       PlayerInstanceBind for the same instance. */
+    InstanceGroupBind() : save(NULL), perm(false) {}
+};
+
+/** request member stats checken **/
+/** todo: uninvite people that not accepted invite **/
+class Group
+{
+    public:
+        struct MemberSlot
+        {
+            uint64      guid;
+            std::string name;
+            uint8       group;
+            uint8       flags;
+            uint8       roles;
+        };
+        typedef std::list<MemberSlot> MemberSlotList;
+        typedef MemberSlotList::const_iterator member_citerator;
+
+        typedef UNORDERED_MAP< uint32 /*mapId*/, InstanceGroupBind> BoundInstancesMap;
+    protected:
+        typedef MemberSlotList::iterator member_witerator;
+        typedef std::set<Player*> InvitesList;
+
+        typedef std::vector<Roll*> Rolls;
+
+    public:
+        Group();
+        ~Group();
+
+        // group manipulation methods
+        bool   Create(const uint64 &guid, const char * name);
+        bool   LoadGroupFromDB(const uint32 &guid, QueryResult result, bool loadMembers = true);
+        bool   LoadMemberFromDB(uint32 guidLow, uint8 memberFlags, uint8 subgroup, uint8 roles);
+        bool   AddInvite(Player *player);
+        uint32 RemoveInvite(Player *player);
+        void   RemoveAllInvites();
+        bool   AddLeaderInvite(Player *player);
+        bool   AddMember(const uint64 &guid, const char* name);
+        uint32 RemoveMember(const uint64 &guid, const RemoveMethod &method = GROUP_REMOVEMETHOD_DEFAULT);
+        void   ChangeLeader(const uint64 &guid);
+        void   SetLootMethod(LootMethod method) { m_lootMethod = method; }
+        void   SetLooterGuid(const uint64 &guid) { m_looterGuid = guid; }
+        void   UpdateLooterGuid(WorldObject* pLootedObject, bool ifneed = false);
+        void   SetLootThreshold(ItemQualities threshold) { m_lootThreshold = threshold; }
+        void   Disband(bool hideDestroy=false);
+
+        // Dungeon Finder
+        void   SetLfgQueued(bool queued) { m_LfgQueued = queued; }
+        bool   isLfgQueued() { return m_LfgQueued; }
+        void   SetLfgStatus(uint8 status) { m_LfgStatus = status; }
+        uint8  GetLfgStatus() { return m_LfgStatus; }
+        bool   isLfgDungeonComplete() const { return m_LfgStatus == LFG_STATUS_COMPLETE; }
+        void   SetLfgDungeonEntry(uint32 dungeonEntry) { m_LfgDungeonEntry = dungeonEntry; }
+        uint32 GetLfgDungeonEntry(bool id = true)
+        {
+            if (id)
+                return (m_LfgDungeonEntry & 0x00FFFFFF);
+            else
+                return m_LfgDungeonEntry;
+        }
+        bool   isLfgKickActive() const { return m_LfgkicksActive; }
+        void   SetLfgKickActive(bool active) { m_LfgkicksActive = active; }
+        uint8  GetLfgKicks() const { return m_Lfgkicks; }
+        void   SetLfgKicks(uint8 kicks) { m_Lfgkicks = kicks; }
+        void   SetLfgRoles(uint64 guid, const uint8 roles)
+        {
+            member_witerator slot = _getMemberWSlot(guid);
+            if (slot == m_memberSlots.end())
+                return;
+
+            slot->roles = roles;
+            SendUpdate();
+        }
+
+        // properties accessories
+        bool IsFull() const { return isRaidGroup() ? (m_memberSlots.size() >= MAXRAIDSIZE) : (m_memberSlots.size() >= MAXGROUPSIZE); }
+        bool isLFGGroup()  const { return m_groupType & GROUPTYPE_LFG; }
+        bool isRaidGroup() const { return m_groupType & GROUPTYPE_RAID; }
+        bool isBGGroup()   const { return m_bgGroup != NULL; }
+        bool IsCreated()   const { return GetMembersCount() > 0; }
+        const uint64& GetLeaderGUID() const { return m_leaderGuid; }
+        const uint64& GetGUID() const { return m_guid; }
+        uint32 GetLowGUID() const { return GUID_LOPART(m_guid); }
+        const char * GetLeaderName() const { return m_leaderName.c_str(); }
+        LootMethod    GetLootMethod() const { return m_lootMethod; }
+        const uint64& GetLooterGuid() const { return m_looterGuid; }
+        ItemQualities GetLootThreshold() const { return m_lootThreshold; }
+
+        // member manipulation methods
+        bool IsMember(const uint64& guid) const { return _getMemberCSlot(guid) != m_memberSlots.end(); }
+        bool IsLeader(const uint64& guid) const { return (GetLeaderGUID() == guid); }
+        uint64 GetMemberGUID(const std::string& name)
+        {
+            for (member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
+            {
+                if (itr->name == name)
+                {
+                    return itr->guid;
+                }
+            }
+            return 0;
+        }
+        bool IsAssistant(uint64 guid) const
+        {
+            member_citerator mslot = _getMemberCSlot(guid);
+            if (mslot == m_memberSlots.end())
+                return false;
+
+            return mslot->flags & MEMBER_FLAG_ASSISTANT;
+        }
+        Player* GetInvited(const uint64& guid) const;
+        Player* GetInvited(const std::string& name) const;
+
+        bool SameSubGroup(uint64 guid1,const uint64& guid2) const
+        {
+            member_citerator mslot2 = _getMemberCSlot(guid2);
+            if (mslot2 == m_memberSlots.end())
+                return false;
+
+            return SameSubGroup(guid1,&*mslot2);
+        }
+
+        bool SameSubGroup(uint64 guid1, MemberSlot const* slot2) const
+        {
+            member_citerator mslot1 = _getMemberCSlot(guid1);
+            if (mslot1 == m_memberSlots.end() || !slot2)
+                return false;
+
+            return (mslot1->group == slot2->group);
+        }
+
+        bool HasFreeSlotSubGroup(uint8 subgroup) const
+        {
+            return (m_subGroupsCounts && m_subGroupsCounts[subgroup] < MAXGROUPSIZE);
+        }
+
+        bool SameSubGroup(Player const* member1, Player const* member2) const;
+
+        MemberSlotList const& GetMemberSlots() const { return m_memberSlots; }
+        GroupReference* GetFirstMember() { return m_memberMgr.getFirst(); }
+        uint32 GetMembersCount() const { return m_memberSlots.size(); }
+        void GetDataForXPAtKill(Unit const* victim, uint32& count,uint32& sum_level, Player* & member_with_max_level, Player* & not_gray_member_with_max_level);
+        uint8  GetMemberGroup(uint64 guid) const
+        {
+            member_citerator mslot = _getMemberCSlot(guid);
+            if (mslot == m_memberSlots.end())
+                return (MAX_RAID_SUBGROUPS+1);
+
+            return mslot->group;
+        }
+
+        void ConvertToLFG();
+        // some additional raid methods
+        void ConvertToRaid();
+
+        void SetBattlegroundGroup(Battleground *bg) { m_bgGroup = bg; }
+        GroupJoinBattlegroundResult CanJoinBattlegroundQueue(Battleground const* bgOrTemplate, BattlegroundQueueTypeId bgQueueTypeId, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
+
+        void ChangeMembersGroup(const uint64 &guid, const uint8 &group);
+        void ChangeMembersGroup(Player *player, const uint8 &group);
+
+        void SetAssistant(uint64 guid, const bool &apply)
+        {
+            if (!isRaidGroup())
+                return;
+            if (_setAssistantFlag(guid, apply))
+                SendUpdate();
+        }
+        void SetMainTank(uint64 guid, const bool &apply)
+        {
+            if (!isRaidGroup())
+                return;
+
+            if (_setMainTank(guid, apply))
+                SendUpdate();
+        }
+        void SetMainAssistant(uint64 guid, const bool &apply)
+        {
+            if (!isRaidGroup())
+                return;
+
+            if (_setMainAssistant(guid, apply))
+                SendUpdate();
+        }
+
+        void SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid);
+
+        Difficulty GetDifficulty(bool isRaid) const { return isRaid ? m_raidDifficulty : m_dungeonDifficulty; }
+        Difficulty GetDungeonDifficulty() const { return m_dungeonDifficulty; }
+        Difficulty GetRaidDifficulty() const { return m_raidDifficulty; }
+        void SetDungeonDifficulty(Difficulty difficulty);
+        void SetRaidDifficulty(Difficulty difficulty);
+        uint16 InInstance();
+        bool InCombatToInstance(uint32 instanceId);
+        void ResetInstances(uint8 method, bool isRaid, Player* SendMsgTo);
+
+        // -no description-
+        //void SendInit(WorldSession *session);
+        void SendTargetIconList(WorldSession *session);
+        void SendUpdate();
+        void UpdatePlayerOutOfRange(Player* pPlayer);
+                                                            // ignore: GUID of player that will be ignored
+        void BroadcastPacket(WorldPacket *packet, bool ignorePlayersInBGRaid, int group=-1, uint64 ignore=0);
+        void BroadcastReadyCheck(WorldPacket *packet);
+        void OfflineReadyCheck();
+
+        /*********************************************************/
+        /***                   LOOT SYSTEM                     ***/
+        /*********************************************************/
+
+        bool isRollLootActive() const { return !RollId.empty(); }
+        void SendLootStartRoll(uint32 CountDown, uint32 mapid, const Roll &r);
+        void SendLootRoll(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r);
+        void SendLootRollWon(const uint64& SourceGuid, const uint64& TargetGuid, uint8 RollNumber, uint8 RollType, const Roll &r);
+        void SendLootAllPassed(uint32 NumberOfPlayers, const Roll &r);
+        void SendLooter(Creature *pCreature, Player *pLooter);
+        void GroupLoot(Loot *loot, WorldObject* pLootedObject);
+        void NeedBeforeGreed(Loot *loot, WorldObject* pLootedObject);
+        void MasterLoot(Loot *loot, WorldObject* pLootedObject);
+        Rolls::iterator GetRoll(uint64 Guid)
+        {
+            Rolls::iterator iter;
+            for (iter=RollId.begin(); iter != RollId.end(); ++iter)
+            {
+                if ((*iter)->itemGUID == Guid && (*iter)->isValid())
+                {
+                    return iter;
+                }
+            }
+            return RollId.end();
+        }
+        void CountTheRoll(Rolls::iterator roll, uint32 NumberOfPlayers);
+        void CountRollVote(const uint64& playerGUID, const uint64& Guid, uint32 NumberOfPlayers, uint8 Choise);
+        void EndRoll(Loot *loot);
+
+        // related to disenchant rolls
+        void ResetMaxEnchantingLevel();
+
+        void LinkMember(GroupReference *pRef) { m_memberMgr.insertFirst(pRef); }
+        void DelinkMember(GroupReference* /*pRef*/) { }
+
+        InstanceGroupBind* BindToInstance(InstanceSave *save, bool permanent, bool load = false);
+        void UnbindInstance(uint32 mapid, uint8 difficulty, bool unload = false);
+        InstanceGroupBind* GetBoundInstance(Player* player);
+        InstanceGroupBind* GetBoundInstance(Map* aMap);
+        InstanceGroupBind* GetBoundInstance(MapEntry const* mapEntry);
+        BoundInstancesMap& GetBoundInstances(Difficulty difficulty) { return m_boundInstances[difficulty]; }
+
+        // FG: evil hacks
+        void BroadcastGroupUpdate(void);
+
+    protected:
+        bool _addMember(const uint64 &guid, const char* name);
+        bool _addMember(const uint64 &guid, const char* name, uint8 group);
+        bool _removeMember(const uint64 &guid);             // returns true if leader has changed
+        void _setLeader(const uint64 &guid);
+
+        void _removeRolls(const uint64 &guid);
+
+        bool _setMembersGroup(const uint64 &guid, const uint8 &group);
+        bool _setAssistantFlag(const uint64 &guid, const bool &apply);
+        bool _setMainTank(const uint64 &guid, const bool &apply);
+        bool _setMainAssistant(const uint64 &guid, const bool &apply);
+
+        void _homebindIfInstance(Player *player);
+
+        void _initRaidSubGroupsCounter()
+        {
+            // Sub group counters initialization
+            if (!m_subGroupsCounts)
+                m_subGroupsCounts = new uint8[MAX_RAID_SUBGROUPS];
+
+            memset((void*)m_subGroupsCounts, 0, (MAX_RAID_SUBGROUPS)*sizeof(uint8));
+
+            for (member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
+                ++m_subGroupsCounts[itr->group];
+        }
+
+        member_citerator _getMemberCSlot(uint64 Guid) const
+        {
+            for (member_citerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
+            {
+                if (itr->guid == Guid)
+                    return itr;
+            }
+            return m_memberSlots.end();
+        }
+
+        member_witerator _getMemberWSlot(uint64 Guid)
+        {
+            for (member_witerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
+            {
+                if (itr->guid == Guid)
+                    return itr;
+            }
+            return m_memberSlots.end();
+        }
+
+        void SubGroupCounterIncrease(uint8 subgroup)
+        {
+            if (m_subGroupsCounts)
+                ++m_subGroupsCounts[subgroup];
+        }
+
+        void SubGroupCounterDecrease(uint8 subgroup)
+        {
+            if (m_subGroupsCounts)
+                --m_subGroupsCounts[subgroup];
+        }
+
+        void RemoveUniqueGroupMemberFlag(GroupMemberFlags flag)
+        {
+            for (member_witerator itr = m_memberSlots.begin(); itr != m_memberSlots.end(); ++itr)
+            {
+                if (itr->flags & flag)
+                    itr->flags &= ~flag;
+            }
+        }
+
+        void ToggleGroupMemberFlag(member_witerator slot, uint8 flag, bool apply)
+        {
+            if (apply)
+                slot->flags |= flag;
+            else
+                slot->flags &= ~flag;
+        }
+
+        MemberSlotList      m_memberSlots;
+        GroupRefManager     m_memberMgr;
+        InvitesList         m_invitees;
+        uint64              m_leaderGuid;
+        std::string         m_leaderName;
+        GroupType           m_groupType;
+        Difficulty          m_dungeonDifficulty;
+        Difficulty          m_raidDifficulty;
+        Battleground*       m_bgGroup;
+        uint64              m_targetIcons[TARGETICONCOUNT];
+        LootMethod          m_lootMethod;
+        ItemQualities       m_lootThreshold;
+        uint64              m_looterGuid;
+        Rolls               RollId;
+        BoundInstancesMap   m_boundInstances[MAX_DIFFICULTY];
+        uint8*              m_subGroupsCounts;
+        uint64              m_guid;
+        uint32              m_counter;                      // used only in SMSG_GROUP_LIST
+        uint32              m_maxEnchantingLevel;
+        bool                m_LfgQueued;
+        uint8               m_LfgStatus;
+        uint32              m_LfgDungeonEntry;
+        uint8               m_Lfgkicks;
+        bool                m_LfgkicksActive;
+};
+#endif
diff --git a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
@@ -1,969 +1,952 @@
-﻿/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "Opcodes.h"
-#include "Log.h"
-#include "WorldPacket.h"
-#include "WorldSession.h"
-#include "World.h"
-#include "ObjectMgr.h"
-#include "Player.h"
-#include "Group.h"
-#include "SocialMgr.h"
-#include "Util.h"
-#include "SpellAuras.h"
-#include "Vehicle.h"
-#include "LFGMgr.h"
-
-class Aura;
-
-/* differeces from off:
-    -you can uninvite yourself - is is useful
-    -you can accept invitation even if leader went offline
-*/
-/* todo:
-    -group_destroyed msg is sent but not shown
-    -reduce xp gaining when in raid group
-    -quest sharing has to be corrected
-    -FIX sending PartyMemberStats
-*/
-
-void WorldSession::SendPartyResult(PartyOperation operation, const std::string& member, PartyResult res, uint32 val /* = 0 */)
-{
-    WorldPacket data(SMSG_PARTY_COMMAND_RESULT, 4 + member.size() + 1 + 4 + 4);
-    data << uint32(operation);
-    data << member;
-    data << uint32(res);
-    data << uint32(val);                                    // LFD cooldown related (used with ERR_PARTY_LFG_BOOT_COOLDOWN_S and ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S)
-
-    SendPacket(&data);
-}
-
-void WorldSession::HandleGroupInviteOpcode(WorldPacket & recv_data)
-{
-    std::string membername;
-    recv_data >> membername;
-
-    // attempt add selected player
-
-    // cheating
-    if (!normalizePlayerName(membername))
-    {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
-        return;
-    }
-
-    Player *player = sObjectMgr.GetPlayer(membername.c_str());
-
-    // no player
-    if (!player)
-    {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
-        return;
-    }
-
-    // restrict invite to GMs
-    if (!sWorld.getBoolConfig(CONFIG_ALLOW_GM_GROUP) && !GetPlayer()->isGameMaster() && player->isGameMaster())
-        return;
-
-    // can't group with
-    if (!sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP) && GetPlayer()->GetTeam() != player->GetTeam())
-    {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_PLAYER_WRONG_FACTION);
-        return;
-    }
-    if (GetPlayer()->GetInstanceId() != 0 && player->GetInstanceId() != 0 && GetPlayer()->GetInstanceId() != player->GetInstanceId() && GetPlayer()->GetMapId() == player->GetMapId())
-    {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_TARGET_NOT_IN_INSTANCE_S);
-        return;
-    }
-    // just ignore us
-    if (player->GetInstanceId() != 0 && player->GetDungeonDifficulty() != GetPlayer()->GetDungeonDifficulty())
-    {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_IGNORING_YOU_S);
-        return;
-    }
-
-    if (player->GetSocial()->HasIgnore(GetPlayer()->GetGUIDLow()))
-    {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_IGNORING_YOU_S);
-        return;
-    }
-
-    Group *group = GetPlayer()->GetGroup();
-    if (group && group->isBGGroup())
-        group = GetPlayer()->GetOriginalGroup();
-
-    Group *group2 = player->GetGroup();
-    if (group2 && group2->isBGGroup())
-        group2 = player->GetOriginalGroup();
-    // player already in another group or invited
-    if (group2 || player->GetGroupInvite())
-    {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_ALREADY_IN_GROUP_S);
-
-        if (group2)
-        {
-            // tell the player that they were invited but it failed as they were already in a group
-            WorldPacket data(SMSG_GROUP_INVITE, 10);                // guess size
-            data << uint8(0);                                       // invited/already in group flag
-            data << GetPlayer()->GetName();                         // max len 48
-            data << uint32(0);                                      // unk
-            data << uint8(0);                                       // count
-            data << uint32(0);                                      // unk
-            player->GetSession()->SendPacket(&data);
-        }
-
-        return;
-    }
-
-    if (group)
-    {
-        // not have permissions for invite
-        if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
-        {
-            SendPartyResult(PARTY_OP_INVITE, "", ERR_NOT_LEADER);
-            return;
-        }
-        // not have place
-        if (group->IsFull())
-        {
-            SendPartyResult(PARTY_OP_INVITE, "", ERR_GROUP_FULL);
-            return;
-        }
-    }
-
-    // ok, but group not exist, start a new group
-    // but don't create and save the group to the DB until
-    // at least one person joins
-    if (!group)
-    {
-        group = new Group;
-        // new group: if can't add then delete
-        if (!group->AddLeaderInvite(GetPlayer()))
-        {
-            delete group;
-            return;
-        }
-        if (!group->AddInvite(player))
-        {
-            delete group;
-            return;
-        }
-    }
-    else
-    {
-        // already existed group: if can't add then just leave
-        if (!group->AddInvite(player))
-        {
-            return;
-        }
-    }
-
-    // ok, we do it
-    WorldPacket data(SMSG_GROUP_INVITE, 10);                // guess size
-    data << uint8(1);                                       // invited/already in group flag
-    data << GetPlayer()->GetName();                         // max len 48
-    data << uint32(0);                                      // unk
-    data << uint8(0);                                       // count
-    data << uint32(0);                                      // unk
-    player->GetSession()->SendPacket(&data);
-
-    SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-    SendLfgUpdateParty(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-    SendPartyResult(PARTY_OP_INVITE, membername, ERR_PARTY_RESULT_OK);
-}
-
-void WorldSession::HandleGroupAcceptOpcode(WorldPacket & /*recv_data*/)
-{
-    Group *group = GetPlayer()->GetGroupInvite();
-    if (!group) return;
-
-    if (group->GetLeaderGUID() == GetPlayer()->GetGUID())
-    {
-        sLog.outError("HandleGroupAcceptOpcode: player %s(%d) tried to accept an invite to his own group", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
-        return;
-    }
-
-    // remove in from ivites in any case
-    group->RemoveInvite(GetPlayer());
-
-    /** error handling **/
-    /********************/
-
-    // not have place
-    if (group->IsFull())
-    {
-        SendPartyResult(PARTY_OP_INVITE, "", ERR_GROUP_FULL);
-        return;
-    }
-
-    Player* leader = sObjectMgr.GetPlayer(group->GetLeaderGUID());
-
-    // forming a new group, create it
-    if (!group->IsCreated())
-    {
-        if (leader)
-            group->RemoveInvite(leader);
-
-        group->Create(group->GetLeaderGUID(), group->GetLeaderName());
-        sObjectMgr.AddGroup(group);
-    }
-
-    // everything's fine, do it, PLAYER'S GROUP IS SET IN ADDMEMBER!!!
-    SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    if (!group->AddMember(GetPlayer()->GetGUID(), GetPlayer()->GetName(), trans))
-        return;
-    CharacterDatabase.CommitTransaction(trans);
-
-
-    SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
-    for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
-        if (Player *plrg = itr->getSource())
-        {
-            plrg->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_CLEAR_LOCK_LIST);
-            plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_CLEAR_LOCK_LIST);
-        }
-
-    group->BroadcastGroupUpdate();
-}
-
-void WorldSession::HandleGroupDeclineOpcode(WorldPacket & /*recv_data*/)
-{
-    Group  *group  = GetPlayer()->GetGroupInvite();
-    if (!group) return;
-
-
-    // uninvite, group can be deleted
-    GetPlayer()->UninviteFromGroup();
-
-	 // remember leader if online
-	Player *leader = sObjectMgr.GetPlayer(group->GetLeaderGUID());
-
-    if (!leader || !leader->GetSession())
-        return;
-
-    // report
-    std::string name = std::string(GetPlayer()->GetName());
-    WorldPacket data(SMSG_GROUP_DECLINE, name.length());
-	data << name.c_str();
-    leader->GetSession()->SendPacket(&data);
-}
-
-void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket & recv_data)
-{
-    uint64 guid;
-    std::string reason;
-    recv_data >> guid;
-    recv_data >> reason;
-
-    //can't uninvite yourself
-    if (guid == GetPlayer()->GetGUID())
-    {
-        sLog.outError("WorldSession::HandleGroupUninviteGuidOpcode: leader %s(%d) tried to uninvite himself from the group.", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
-        return;
-    }
-
-    PartyResult res = GetPlayer()->CanUninviteFromGroup();
-    if (res != ERR_PARTY_RESULT_OK)
-    {
-        SendPartyResult(PARTY_OP_UNINVITE, "", res);
-        return;
-    }
-
-    Group* grp = GetPlayer()->GetGroup();
-    if (!grp)
-        return;
-
-    if (grp->IsMember(guid))
-    {
-        if (grp->isLFGGroup())
-            sLFGMgr.InitBoot(grp, GUID_LOPART(GetPlayer()->GetGUID()), GUID_LOPART(guid), reason);
-        else
-            Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK);
-        return;
-    }
-
-    if (Player* plr = grp->GetInvited(guid))
-    {
-        plr->UninviteFromGroup();
-        return;
-    }
-
-    SendPartyResult(PARTY_OP_UNINVITE, "", ERR_TARGET_NOT_IN_GROUP_S);
-}
-
-void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
-{
-    std::string membername;
-    recv_data >> membername;
-
-    // player not found
-    if (!normalizePlayerName(membername))
-        return;
-
-    // can't uninvite yourself
-    if (GetPlayer()->GetName() == membername)
-    {
-        sLog.outError("WorldSession::HandleGroupUninviteOpcode: leader %s(%d) tried to uninvite himself from the group.", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
-        return;
-    }
-
-    PartyResult res = GetPlayer()->CanUninviteFromGroup();
-    if (res != ERR_PARTY_RESULT_OK)
-    {
-        SendPartyResult(PARTY_OP_UNINVITE, "", res);
-        return;
-    }
-
-    Group* grp = GetPlayer()->GetGroup();
-    if (!grp)
-        return;
-
-    if (uint64 guid = grp->GetMemberGUID(membername))
-    {
-        if (grp->isLFGGroup())
-            sLFGMgr.InitBoot(grp, GUID_LOPART(GetPlayer()->GetGUID()), GUID_LOPART(guid), "");
-        else
-            Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK);
-        return;
-    }
-
-    if (Player* plr = grp->GetInvited(membername))
-    {
-        plr->UninviteFromGroup();
-        return;
-    }
-
-    SendPartyResult(PARTY_OP_UNINVITE, membername, ERR_TARGET_NOT_IN_GROUP_S);
-}
-
-void WorldSession::HandleGroupSetLeaderOpcode(WorldPacket & recv_data)
-{
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    uint64 guid;
-    recv_data >> guid;
-
-    Player *player = sObjectMgr.GetPlayer(guid);
-
-    /** error handling **/
-    if (!player || !group->IsLeader(GetPlayer()->GetGUID()) || player->GetGroup() != group)
-        return;
-    /********************/
-
-    // everything's fine, do it
-    group->ChangeLeader(guid);
-}
-
-void WorldSession::HandleGroupDisbandOpcode(WorldPacket & /*recv_data*/)
-{
-    Group *grp = GetPlayer()->GetGroup();
-    if (!grp)
-        return;
-
-    if (_player->InBattleground())
-    {
-        SendPartyResult(PARTY_OP_INVITE, "", ERR_INVITE_RESTRICTED);
-        return;
-    }
-
-    /** error handling **/
-    /********************/
-
-    // everything's fine, do it
-    SendPartyResult(PARTY_OP_LEAVE, GetPlayer()->GetName(), ERR_PARTY_RESULT_OK);
-
-    GetPlayer()->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
-}
-
-void WorldSession::HandleLootMethodOpcode(WorldPacket & recv_data)
-{
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    uint32 lootMethod;
-    uint64 lootMaster;
-    uint32 lootThreshold;
-    recv_data >> lootMethod >> lootMaster >> lootThreshold;
-
-    /** error handling **/
-    if (!group->IsLeader(GetPlayer()->GetGUID()))
-        return;
-    /********************/
-
-    // everything's fine, do it
-    group->SetLootMethod((LootMethod)lootMethod);
-    group->SetLooterGuid(lootMaster);
-    group->SetLootThreshold((ItemQualities)lootThreshold);
-    group->SendUpdate();
-}
-
-void WorldSession::HandleLootRoll(WorldPacket &recv_data)
-{
-    if (!GetPlayer()->GetGroup())
-        return;
-
-    uint64 Guid;
-    uint32 NumberOfPlayers;
-    uint8  rollType;
-    recv_data >> Guid;                                      //guid of the item rolled
-    recv_data >> NumberOfPlayers;
-    recv_data >> rollType;                                    //0: pass, 1: need, 2: greed
-
-    //sLog.outDebug("WORLD RECIEVE CMSG_LOOT_ROLL, From:%u, Numberofplayers:%u, Choise:%u", (uint32)Guid, NumberOfPlayers, Choise);
-
-    Group* group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    // everything's fine, do it
-    group->CountRollVote(GetPlayer()->GetGUID(), Guid, NumberOfPlayers, rollType);
-
-    switch (rollType)
-    {
-        case ROLL_NEED:
-            GetPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED, 1);
-            break;
-        case ROLL_GREED:
-            GetPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED, 1);
-            break;
-    }
-}
-
-void WorldSession::HandleMinimapPingOpcode(WorldPacket& recv_data)
-{
-    if (!GetPlayer()->GetGroup())
-        return;
-
-    float x, y;
-    recv_data >> x;
-    recv_data >> y;
-
-    //sLog.outDebug("Received opcode MSG_MINIMAP_PING X: %f, Y: %f", x, y);
-
-    /** error handling **/
-    /********************/
-
-    // everything's fine, do it
-    WorldPacket data(MSG_MINIMAP_PING, (8+4+4));
-    data << uint64(GetPlayer()->GetGUID());
-    data << float(x);
-    data << float(y);
-    GetPlayer()->GetGroup()->BroadcastPacket(&data, true, -1, GetPlayer()->GetGUID());
-}
-
-void WorldSession::HandleRandomRollOpcode(WorldPacket& recv_data)
-{
-    uint32 minimum, maximum, roll;
-    recv_data >> minimum;
-    recv_data >> maximum;
-
-    /** error handling **/
-    if (minimum > maximum || maximum > 10000)                // < 32768 for urand call
-        return;
-    /********************/
-
-    // everything's fine, do it
-    roll = urand(minimum, maximum);
-
-    //sLog.outDebug("ROLL: MIN: %u, MAX: %u, ROLL: %u", minimum, maximum, roll);
-
-    WorldPacket data(MSG_RANDOM_ROLL, 4+4+4+8);
-    data << uint32(minimum);
-    data << uint32(maximum);
-    data << uint32(roll);
-    data << uint64(GetPlayer()->GetGUID());
-    if (GetPlayer()->GetGroup())
-        GetPlayer()->GetGroup()->BroadcastPacket(&data, false);
-    else
-        SendPacket(&data);
-}
-
-void WorldSession::HandleRaidTargetUpdateOpcode(WorldPacket & recv_data)
-{
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    uint8  x;
-    recv_data >> x;
-
-    /** error handling **/
-    /********************/
-
-    // everything's fine, do it
-    if (x == 0xFF)                                           // target icon request
-    {
-        group->SendTargetIconList(this);
-    }
-    else                                                    // target icon update
-    {
-        if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
-            return;
-
-        uint64 guid;
-        recv_data >> guid;
-        group->SetTargetIcon(x, _player->GetGUID(), guid);
-    }
-}
-
-void WorldSession::HandleGroupRaidConvertOpcode(WorldPacket & /*recv_data*/)
-{
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    if (_player->InBattleground())
-        return;
-
-    /** error handling **/
-    if (!group->IsLeader(GetPlayer()->GetGUID()) || group->GetMembersCount() < 2)
-        return;
-    /********************/
-
-    // everything's fine, do it (is it 0 (PARTY_OP_INVITE) correct code)
-    SendPartyResult(PARTY_OP_INVITE, "", ERR_PARTY_RESULT_OK);
-    group->ConvertToRaid();
-}
-
-void WorldSession::HandleGroupChangeSubGroupOpcode(WorldPacket & recv_data)
-{
-    // we will get correct pointer for group here, so we don't have to check if group is BG raid
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    std::string name;
-    uint8 groupNr;
-    recv_data >> name;
-    recv_data >> groupNr;
-
-    if (groupNr >= MAX_RAID_SUBGROUPS)
-        return;
-
-    /** error handling **/
-    uint64 senderGuid = GetPlayer()->GetGUID();
-    if (!group->IsLeader(senderGuid) && !group->IsAssistant(senderGuid))
-        return;
-
-    if (!group->HasFreeSlotSubGroup(groupNr))
-        return;
-    /********************/
-
-    Player *movedPlayer = sObjectMgr.GetPlayer(name.c_str());
-    if (movedPlayer)
-    {
-        //Do not allow leader to change group of player in combat
-        if (movedPlayer->isInCombat())
-            return;
-
-        // everything's fine, do it
-        group->ChangeMembersGroup(movedPlayer, groupNr);
-    }
-    else
-        group->ChangeMembersGroup(sObjectMgr.GetPlayerGUIDByName(name.c_str()), groupNr);
-}
-
-void WorldSession::HandleGroupAssistantLeaderOpcode(WorldPacket & recv_data)
-{
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    uint64 guid;
-    uint8 flag;
-    recv_data >> guid;
-    recv_data >> flag;
-
-    /** error handling **/
-    if (!group->IsLeader(GetPlayer()->GetGUID()))
-        return;
-    /********************/
-
-    // everything's fine, do it
-    group->SetAssistant(guid, (flag != 0));
-}
-
-void WorldSession::HandlePartyAssignmentOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("MSG_PARTY_ASSIGNMENT");
-
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    uint8 flag, apply;
-    uint64 guid;
-    recv_data >> flag >> apply;
-    recv_data >> guid;
-
-    /** error handling **/
-    uint64 senderGuid = GetPlayer()->GetGUID();
-    if (!group->IsLeader(senderGuid) && !group->IsAssistant(senderGuid))
-        return;
-    /********************/
-
-    // everything's fine, do it
-    if (flag == 0)
-        group->SetMainTank(guid, apply);
-
-    else if (flag == 1)
-        group->SetMainAssistant(guid, apply);
-}
-
-void WorldSession::HandleRaidReadyCheckOpcode(WorldPacket & recv_data)
-{
-    Group *group = GetPlayer()->GetGroup();
-    if (!group)
-        return;
-
-    if (recv_data.empty())                                   // request
-    {
-        /** error handling **/
-        if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
-            return;
-        /********************/
-
-        // everything's fine, do it
-        WorldPacket data(MSG_RAID_READY_CHECK, 8);
-        data << GetPlayer()->GetGUID();
-        group->BroadcastPacket(&data, false, -1);
-
-        group->OfflineReadyCheck();
-    }
-    else                                                    // answer
-    {
-        uint8 state;
-        recv_data >> state;
-
-        // everything's fine, do it
-        WorldPacket data(MSG_RAID_READY_CHECK_CONFIRM, 9);
-        data << uint64(GetPlayer()->GetGUID());
-        data << uint8(state);
-        group->BroadcastReadyCheck(&data);
-    }
-}
-
-void WorldSession::HandleRaidReadyCheckFinishedOpcode(WorldPacket & /*recv_data*/)
-{
-    //Group* group = GetPlayer()->GetGroup();
-    //if (!group)
-    //    return;
-
-    //if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
-    //    return;
-
-    // Is any reaction need?
-}
-
-void WorldSession::BuildPartyMemberStatsChangedPacket(Player *player, WorldPacket *data)
-{
-    uint32 mask = player->GetGroupUpdateFlag();
-
-    if (mask == GROUP_UPDATE_FLAG_NONE)
-        return;
-
-    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)                // if update power type, update current/max power also
-        mask |= (GROUP_UPDATE_FLAG_CUR_POWER | GROUP_UPDATE_FLAG_MAX_POWER);
-
-    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)            // same for pets
-        mask |= (GROUP_UPDATE_FLAG_PET_CUR_POWER | GROUP_UPDATE_FLAG_PET_MAX_POWER);
-
-    uint32 byteCount = 0;
-    for (int i = 1; i < GROUP_UPDATE_FLAGS_COUNT; ++i)
-        if (mask & (1 << i))
-            byteCount += GroupUpdateLength[i];
-
-    data->Initialize(SMSG_PARTY_MEMBER_STATS, 8 + 4 + byteCount);
-    data->append(player->GetPackGUID());
-    *data << (uint32) mask;
-
-    if (mask & GROUP_UPDATE_FLAG_STATUS)
-    {
-        if (player)
-        {
-            if (player->IsPvP())
-                *data << (uint16) (MEMBER_STATUS_ONLINE | MEMBER_STATUS_PVP);
-            else
-                *data << (uint16) MEMBER_STATUS_ONLINE;
-        }
-        else
-            *data << (uint16) MEMBER_STATUS_OFFLINE;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_CUR_HP)
-        *data << (uint32) player->GetHealth();
-
-    if (mask & GROUP_UPDATE_FLAG_MAX_HP)
-        *data << (uint32) player->GetMaxHealth();
-
-    Powers powerType = player->getPowerType();
-    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)
-        *data << (uint8) powerType;
-
-    if (mask & GROUP_UPDATE_FLAG_CUR_POWER)
-        *data << (uint16) player->GetPower(powerType);
-
-    if (mask & GROUP_UPDATE_FLAG_MAX_POWER)
-        *data << (uint16) player->GetMaxPower(powerType);
-
-    if (mask & GROUP_UPDATE_FLAG_LEVEL)
-        *data << (uint16) player->getLevel();
-
-    if (mask & GROUP_UPDATE_FLAG_ZONE)
-        *data << (uint16) player->GetZoneId();
-
-    if (mask & GROUP_UPDATE_FLAG_POSITION)
-        *data << (uint16) player->GetPositionX() << (uint16) player->GetPositionY();
-
-    if (mask & GROUP_UPDATE_FLAG_AURAS)
-    {
-        const uint64& auramask = player->GetAuraUpdateMaskForRaid();
-        *data << uint64(auramask);
-        for (uint32 i = 0; i < MAX_AURAS; ++i)
-        {
-            if (auramask & (uint64(1) << i))
-            {
-                AuraApplication const * aurApp = player->GetVisibleAura(i);
-                *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
-                *data << uint8(1);
-            }
-        }
-    }
-
-    Pet *pet = player->GetPet();
-    if (mask & GROUP_UPDATE_FLAG_PET_GUID)
-    {
-        if (pet)
-            *data << (uint64) pet->GetGUID();
-        else
-            *data << (uint64) 0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_NAME)
-    {
-        if (pet)
-            *data << pet->GetName();
-        else
-            *data << (uint8)  0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_MODEL_ID)
-    {
-        if (pet)
-            *data << (uint16) pet->GetDisplayId();
-        else
-            *data << (uint16) 0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_CUR_HP)
-    {
-        if (pet)
-            *data << (uint32) pet->GetHealth();
-        else
-            *data << (uint32) 0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_MAX_HP)
-    {
-        if (pet)
-            *data << (uint32) pet->GetMaxHealth();
-        else
-            *data << (uint32) 0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)
-    {
-        if (pet)
-            *data << (uint8)  pet->getPowerType();
-        else
-            *data << (uint8)  0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_CUR_POWER)
-    {
-        if (pet)
-            *data << (uint16) pet->GetPower(pet->getPowerType());
-        else
-            *data << (uint16) 0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_MAX_POWER)
-    {
-        if (pet)
-            *data << (uint16) pet->GetMaxPower(pet->getPowerType());
-        else
-            *data << (uint16) 0;
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
-    {
-        if (player->GetVehicle()){
-            Vehicle* vv=player->GetVehicle();
-            *data << (uint32) vv->GetVehicleInfo()->m_seatID[player->m_movementInfo.t_seat];
-        }
-    }
-
-    if (mask & GROUP_UPDATE_FLAG_PET_AURAS)
-    {
-        if (pet)
-        {
-            const uint64& auramask = pet->GetAuraUpdateMaskForRaid();
-            *data << uint64(auramask);
-            for (uint32 i = 0; i < MAX_AURAS; ++i)
-            {
-                if (auramask & (uint64(1) << i))
-                {
-                    AuraApplication const * aurApp = player->GetVisibleAura(i);
-                    *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
-                    *data << uint8(1);
-                }
-            }
-        }
-        else
-            *data << (uint64) 0;
-    }
-}
-
-/*this procedure handles clients CMSG_REQUEST_PARTY_MEMBER_STATS request*/
-void WorldSession::HandleRequestPartyMemberStatsOpcode(WorldPacket &recv_data)
-{
-    sLog.outDebug("WORLD: Received CMSG_REQUEST_PARTY_MEMBER_STATS");
-    uint64 Guid;
-    recv_data >> Guid;
-
-    Player *player = sObjectMgr.GetPlayer(Guid);
-    if (!player)
-    {
-        WorldPacket data(SMSG_PARTY_MEMBER_STATS_FULL, 3+4+2);
-        data << uint8(0);                                   // only for SMSG_PARTY_MEMBER_STATS_FULL, probably arena/bg related
-        data.appendPackGUID(Guid);
-        data << (uint32) GROUP_UPDATE_FLAG_STATUS;
-        data << (uint16) MEMBER_STATUS_OFFLINE;
-        SendPacket(&data);
-        return;
-    }
-
-    Pet *pet = player->GetPet();
-
-    WorldPacket data(SMSG_PARTY_MEMBER_STATS_FULL, 4+2+2+2+1+2*6+8+1+8);
-    data << uint8(0);                                       // only for SMSG_PARTY_MEMBER_STATS_FULL, probably arena/bg related
-    data.append(player->GetPackGUID());
-
-    uint32 mask1 = 0x00040BFF;                              // common mask, real flags used 0x000040BFF
-    if (pet)
-        mask1 = 0x7FFFFFFF;                                 // for hunters and other classes with pets
-
-    Powers powerType = player->getPowerType();
-    data << (uint32) mask1;                                 // group update mask
-    data << (uint16) MEMBER_STATUS_ONLINE;                  // member's online status
-    data << (uint32) player->GetHealth();                   // GROUP_UPDATE_FLAG_CUR_HP
-    data << (uint32) player->GetMaxHealth();                // GROUP_UPDATE_FLAG_MAX_HP
-    data << (uint8)  powerType;                             // GROUP_UPDATE_FLAG_POWER_TYPE
-    data << (uint16) player->GetPower(powerType);           // GROUP_UPDATE_FLAG_CUR_POWER
-    data << (uint16) player->GetMaxPower(powerType);        // GROUP_UPDATE_FLAG_MAX_POWER
-    data << (uint16) player->getLevel();                    // GROUP_UPDATE_FLAG_LEVEL
-    data << (uint16) player->GetZoneId();                   // GROUP_UPDATE_FLAG_ZONE
-    data << (uint16) player->GetPositionX();                // GROUP_UPDATE_FLAG_POSITION
-    data << (uint16) player->GetPositionY();                // GROUP_UPDATE_FLAG_POSITION
-
-    uint64 auramask = 0;
-    size_t maskPos = data.wpos();
-    data << (uint64) auramask;                              // placeholder
-    for (uint8 i = 0; i < MAX_AURAS; ++i)
-    {
-        if (AuraApplication * aurApp = player->GetVisibleAura(i))
-        {
-            auramask |= (uint64(1) << i);
-            data << (uint32) aurApp->GetBase()->GetId();
-            data << (uint8)  1;
-        }
-    }
-    data.put<uint64>(maskPos,auramask);                     // GROUP_UPDATE_FLAG_AURAS
-
-    if (pet)
-    {
-        Powers petpowertype = pet->getPowerType();
-        data << (uint64) pet->GetGUID();                    // GROUP_UPDATE_FLAG_PET_GUID
-        data << pet->GetName();                             // GROUP_UPDATE_FLAG_PET_NAME
-        data << (uint16) pet->GetDisplayId();               // GROUP_UPDATE_FLAG_PET_MODEL_ID
-        data << (uint32) pet->GetHealth();                  // GROUP_UPDATE_FLAG_PET_CUR_HP
-        data << (uint32) pet->GetMaxHealth();               // GROUP_UPDATE_FLAG_PET_MAX_HP
-        data << (uint8)  petpowertype;                      // GROUP_UPDATE_FLAG_PET_POWER_TYPE
-        data << (uint16) pet->GetPower(petpowertype);       // GROUP_UPDATE_FLAG_PET_CUR_POWER
-        data << (uint16) pet->GetMaxPower(petpowertype);    // GROUP_UPDATE_FLAG_PET_MAX_POWER
-
-        uint64 petauramask = 0;
-        size_t petMaskPos = data.wpos();
-        data << (uint64) petauramask;                       // placeholder
-        for (uint8 i = 0; i < MAX_AURAS; ++i)
-        {
-            if (AuraApplication * auraApp = pet->GetVisibleAura(i))
-            {
-                petauramask |= (uint64(1) << i);
-                data << (uint32) auraApp->GetBase()->GetId();
-                data << (uint8)  1;
-            }
-        }
-        data.put<uint64>(petMaskPos,petauramask);           // GROUP_UPDATE_FLAG_PET_AURAS
-    }
-    else
-    {
-        data << (uint8)  0;                                 // GROUP_UPDATE_FLAG_PET_NAME
-        data << (uint64) 0;                                 // GROUP_UPDATE_FLAG_PET_AURAS
-    }
-
-    SendPacket(&data);
-}
-
-/*!*/void WorldSession::HandleRequestRaidInfoOpcode(WorldPacket & /*recv_data*/)
-{
-    // every time the player checks the character screen
-    _player->SendRaidInfo();
-}
-
-/*void WorldSession::HandleGroupCancelOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: got CMSG_GROUP_CANCEL.");
-}*/
-
-void WorldSession::HandleOptOutOfLootOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: Received CMSG_OPT_OUT_OF_LOOT");
-
-    uint32 passOnLoot;
-    recv_data >> passOnLoot; // 1 always pass, 0 do not pass
-
-    // ignore if player not loaded
-    if (!GetPlayer())                                        // needed because STATUS_AUTHED
-    {
-        if (passOnLoot != 0)
-            sLog.outError("CMSG_OPT_OUT_OF_LOOT value<>0 for not-loaded character!");
-        return;
-    }
-
-    GetPlayer()->SetPassOnGroupLoot(passOnLoot);
-}
+﻿/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Common.h"
+#include "DatabaseEnv.h"
+#include "Opcodes.h"
+#include "Log.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "Group.h"
+#include "SocialMgr.h"
+#include "Util.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "LFGMgr.h"
+
+class Aura;
+
+/* differeces from off:
+    -you can uninvite yourself - is is useful
+    -you can accept invitation even if leader went offline
+*/
+/* todo:
+    -group_destroyed msg is sent but not shown
+    -reduce xp gaining when in raid group
+    -quest sharing has to be corrected
+    -FIX sending PartyMemberStats
+*/
+
+void WorldSession::SendPartyResult(PartyOperation operation, const std::string& member, PartyResult res, uint32 val /* = 0 */)
+{
+    WorldPacket data(SMSG_PARTY_COMMAND_RESULT, 4 + member.size() + 1 + 4 + 4);
+    data << uint32(operation);
+    data << member;
+    data << uint32(res);
+    data << uint32(val);                                    // LFD cooldown related (used with ERR_PARTY_LFG_BOOT_COOLDOWN_S and ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S)
+
+    SendPacket(&data);
+}
+
+void WorldSession::HandleGroupInviteOpcode(WorldPacket & recv_data)
+{
+    std::string membername;
+    recv_data >> membername;
+
+    // attempt add selected player
+
+    // cheating
+    if (!normalizePlayerName(membername))
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
+        return;
+    }
+
+    Player *player = sObjectMgr.GetPlayer(membername.c_str());
+
+    // no player
+    if (!player)
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
+        return;
+    }
+
+    // restrict invite to GMs
+    if (!sWorld.getBoolConfig(CONFIG_ALLOW_GM_GROUP) && !GetPlayer()->isGameMaster() && player->isGameMaster())
+        return;
+
+    // can't group with
+    if (!sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP) && GetPlayer()->GetTeam() != player->GetTeam())
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_PLAYER_WRONG_FACTION);
+        return;
+    }
+    if (GetPlayer()->GetInstanceId() != 0 && player->GetInstanceId() != 0 && GetPlayer()->GetInstanceId() != player->GetInstanceId() && GetPlayer()->GetMapId() == player->GetMapId())
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_TARGET_NOT_IN_INSTANCE_S);
+        return;
+    }
+    // just ignore us
+    if (player->GetInstanceId() != 0 && player->GetDungeonDifficulty() != GetPlayer()->GetDungeonDifficulty())
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_IGNORING_YOU_S);
+        return;
+    }
+
+    if (player->GetSocial()->HasIgnore(GetPlayer()->GetGUIDLow()))
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_IGNORING_YOU_S);
+        return;
+    }
+
+    Group *group = GetPlayer()->GetGroup();
+    if (group && group->isBGGroup())
+        group = GetPlayer()->GetOriginalGroup();
+
+    Group *group2 = player->GetGroup();
+    if (group2 && group2->isBGGroup())
+        group2 = player->GetOriginalGroup();
+    // player already in another group or invited
+    if (group2 || player->GetGroupInvite())
+    {
+        SendPartyResult(PARTY_OP_INVITE, membername, ERR_ALREADY_IN_GROUP_S);
+
+        if (group2)
+        {
+            // tell the player that they were invited but it failed as they were already in a group
+            WorldPacket data(SMSG_GROUP_INVITE, 10);                // guess size
+            data << uint8(0);                                       // invited/already in group flag
+            data << GetPlayer()->GetName();                         // max len 48
+            data << uint32(0);                                      // unk
+            data << uint8(0);                                       // count
+            data << uint32(0);                                      // unk
+            player->GetSession()->SendPacket(&data);
+        }
+
+        return;
+    }
+
+    if (group)
+    {
+        // not have permissions for invite
+        if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
+        {
+            SendPartyResult(PARTY_OP_INVITE, "", ERR_NOT_LEADER);
+            return;
+        }
+        // not have place
+        if (group->IsFull())
+        {
+            SendPartyResult(PARTY_OP_INVITE, "", ERR_GROUP_FULL);
+            return;
+        }
+    }
+
+    // ok, but group not exist, start a new group
+    // but don't create and save the group to the DB until
+    // at least one person joins
+    if (!group)
+    {
+        group = new Group;
+        // new group: if can't add then delete
+        if (!group->AddLeaderInvite(GetPlayer()))
+        {
+            delete group;
+            return;
+        }
+        if (!group->AddInvite(player))
+        {
+            delete group;
+            return;
+        }
+    }
+    else
+    {
+        // already existed group: if can't add then just leave
+        if (!group->AddInvite(player))
+        {
+            return;
+        }
+    }
+
+    // ok, we do it
+    WorldPacket data(SMSG_GROUP_INVITE, 10);                // guess size
+    data << uint8(1);                                       // invited/already in group flag
+    data << GetPlayer()->GetName();                         // max len 48
+    data << uint32(0);                                      // unk
+    data << uint8(0);                                       // count
+    data << uint32(0);                                      // unk
+    player->GetSession()->SendPacket(&data);
+
+    SendPartyResult(PARTY_OP_INVITE, membername, ERR_PARTY_RESULT_OK);
+}
+
+void WorldSession::HandleGroupAcceptOpcode(WorldPacket & /*recv_data*/)
+{
+    Group *group = GetPlayer()->GetGroupInvite();
+    if (!group) return;
+
+    if (group->GetLeaderGUID() == GetPlayer()->GetGUID())
+    {
+        sLog.outError("HandleGroupAcceptOpcode: player %s(%d) tried to accept an invite to his own group", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
+        return;
+    }
+
+    // remove in from ivites in any case
+    group->RemoveInvite(GetPlayer());
+
+    /** error handling **/
+    /********************/
+
+    // not have place
+    if (group->IsFull())
+    {
+        SendPartyResult(PARTY_OP_INVITE, "", ERR_GROUP_FULL);
+        return;
+    }
+
+    Player* leader = sObjectMgr.GetPlayer(group->GetLeaderGUID());
+
+    // forming a new group, create it
+    if (!group->IsCreated())
+    {
+        if (leader)
+            group->RemoveInvite(leader);
+        group->Create(group->GetLeaderGUID(), group->GetLeaderName());
+        sObjectMgr.AddGroup(group);
+    }
+
+    // everything's fine, do it, PLAYER'S GROUP IS SET IN ADDMEMBER!!!
+    if (!group->AddMember(GetPlayer()->GetGUID(), GetPlayer()->GetName()))
+        return;
+
+    group->BroadcastGroupUpdate();
+}
+
+void WorldSession::HandleGroupDeclineOpcode(WorldPacket & /*recv_data*/)
+{
+    Group  *group  = GetPlayer()->GetGroupInvite();
+    if (!group) return;
+
+    // uninvite, group can be deleted
+    GetPlayer()->UninviteFromGroup();
+
+    // remember leader if online
+    Player *leader = sObjectMgr.GetPlayer(group->GetLeaderGUID());
+    if (!leader || !leader->GetSession())
+        return;
+
+    // report
+    std::string name = std::string(GetPlayer()->GetName());
+    WorldPacket data(SMSG_GROUP_DECLINE, name.length());
+    data << name.c_str();
+    leader->GetSession()->SendPacket(&data);
+}
+
+void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket & recv_data)
+{
+    uint64 guid;
+    std::string reason;
+    recv_data >> guid;
+    recv_data >> reason;
+
+    //can't uninvite yourself
+    if (guid == GetPlayer()->GetGUID())
+    {
+        sLog.outError("WorldSession::HandleGroupUninviteGuidOpcode: leader %s(%d) tried to uninvite himself from the group.", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
+        return;
+    }
+
+    PartyResult res = GetPlayer()->CanUninviteFromGroup();
+    if (res != ERR_PARTY_RESULT_OK)
+    {
+        SendPartyResult(PARTY_OP_UNINVITE, "", res);
+        return;
+    }
+
+    Group* grp = GetPlayer()->GetGroup();
+    if (!grp)
+        return;
+
+    if (grp->IsMember(guid))
+    {
+        if (grp->isLFGGroup())
+            sLFGMgr.InitBoot(grp, GUID_LOPART(GetPlayer()->GetGUID()), GUID_LOPART(guid), reason);
+        else
+            Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK);
+        return;
+    }
+
+    if (Player* plr = grp->GetInvited(guid))
+    {
+        plr->UninviteFromGroup();
+        return;
+    }
+
+    SendPartyResult(PARTY_OP_UNINVITE, "", ERR_TARGET_NOT_IN_GROUP_S);
+}
+
+void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
+{
+    std::string membername;
+    recv_data >> membername;
+
+    // player not found
+    if (!normalizePlayerName(membername))
+        return;
+
+    // can't uninvite yourself
+    if (GetPlayer()->GetName() == membername)
+    {
+        sLog.outError("WorldSession::HandleGroupUninviteOpcode: leader %s(%d) tried to uninvite himself from the group.", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
+        return;
+    }
+
+    PartyResult res = GetPlayer()->CanUninviteFromGroup();
+    if (res != ERR_PARTY_RESULT_OK)
+    {
+        SendPartyResult(PARTY_OP_UNINVITE, "", res);
+        return;
+    }
+
+    Group* grp = GetPlayer()->GetGroup();
+    if (!grp)
+        return;
+
+    if (uint64 guid = grp->GetMemberGUID(membername))
+    {
+        if (grp->isLFGGroup())
+            sLFGMgr.InitBoot(grp, GUID_LOPART(GetPlayer()->GetGUID()), GUID_LOPART(guid), "");
+        else
+            Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK);
+        return;
+    }
+
+    if (Player* plr = grp->GetInvited(membername))
+    {
+        plr->UninviteFromGroup();
+        return;
+    }
+
+    SendPartyResult(PARTY_OP_UNINVITE, membername, ERR_TARGET_NOT_IN_GROUP_S);
+}
+
+void WorldSession::HandleGroupSetLeaderOpcode(WorldPacket & recv_data)
+{
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    uint64 guid;
+    recv_data >> guid;
+
+    Player *player = sObjectMgr.GetPlayer(guid);
+
+    /** error handling **/
+    if (!player || !group->IsLeader(GetPlayer()->GetGUID()) || player->GetGroup() != group)
+        return;
+    /********************/
+
+    // everything's fine, do it
+    group->ChangeLeader(guid);
+}
+
+void WorldSession::HandleGroupDisbandOpcode(WorldPacket & /*recv_data*/)
+{
+    Group *grp = GetPlayer()->GetGroup();
+    if (!grp)
+        return;
+
+    if (_player->InBattleground())
+    {
+        SendPartyResult(PARTY_OP_INVITE, "", ERR_INVITE_RESTRICTED);
+        return;
+    }
+
+    /** error handling **/
+    /********************/
+
+    // everything's fine, do it
+    SendPartyResult(PARTY_OP_LEAVE, GetPlayer()->GetName(), ERR_PARTY_RESULT_OK);
+
+    GetPlayer()->RemoveFromGroup(GROUP_REMOVEMETHOD_LEAVE);
+}
+
+void WorldSession::HandleLootMethodOpcode(WorldPacket & recv_data)
+{
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    uint32 lootMethod;
+    uint64 lootMaster;
+    uint32 lootThreshold;
+    recv_data >> lootMethod >> lootMaster >> lootThreshold;
+
+    /** error handling **/
+    if (!group->IsLeader(GetPlayer()->GetGUID()))
+        return;
+    /********************/
+
+    // everything's fine, do it
+    group->SetLootMethod((LootMethod)lootMethod);
+    group->SetLooterGuid(lootMaster);
+    group->SetLootThreshold((ItemQualities)lootThreshold);
+    group->SendUpdate();
+}
+
+void WorldSession::HandleLootRoll(WorldPacket &recv_data)
+{
+    if (!GetPlayer()->GetGroup())
+        return;
+
+    uint64 Guid;
+    uint32 NumberOfPlayers;
+    uint8  rollType;
+    recv_data >> Guid;                                      //guid of the item rolled
+    recv_data >> NumberOfPlayers;
+    recv_data >> rollType;                                    //0: pass, 1: need, 2: greed
+
+    //sLog.outDebug("WORLD RECIEVE CMSG_LOOT_ROLL, From:%u, Numberofplayers:%u, Choise:%u", (uint32)Guid, NumberOfPlayers, Choise);
+
+    Group* group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    // everything's fine, do it
+    group->CountRollVote(GetPlayer()->GetGUID(), Guid, NumberOfPlayers, rollType);
+
+    switch (rollType)
+    {
+        case ROLL_NEED:
+            GetPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED, 1);
+            break;
+        case ROLL_GREED:
+            GetPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED, 1);
+            break;
+    }
+}
+
+void WorldSession::HandleMinimapPingOpcode(WorldPacket& recv_data)
+{
+    if (!GetPlayer()->GetGroup())
+        return;
+
+    float x, y;
+    recv_data >> x;
+    recv_data >> y;
+
+    //sLog.outDebug("Received opcode MSG_MINIMAP_PING X: %f, Y: %f", x, y);
+
+    /** error handling **/
+    /********************/
+
+    // everything's fine, do it
+    WorldPacket data(MSG_MINIMAP_PING, (8+4+4));
+    data << uint64(GetPlayer()->GetGUID());
+    data << float(x);
+    data << float(y);
+    GetPlayer()->GetGroup()->BroadcastPacket(&data, true, -1, GetPlayer()->GetGUID());
+}
+
+void WorldSession::HandleRandomRollOpcode(WorldPacket& recv_data)
+{
+    uint32 minimum, maximum, roll;
+    recv_data >> minimum;
+    recv_data >> maximum;
+
+    /** error handling **/
+    if (minimum > maximum || maximum > 10000)                // < 32768 for urand call
+        return;
+    /********************/
+
+    // everything's fine, do it
+    roll = urand(minimum, maximum);
+
+    //sLog.outDebug("ROLL: MIN: %u, MAX: %u, ROLL: %u", minimum, maximum, roll);
+
+    WorldPacket data(MSG_RANDOM_ROLL, 4+4+4+8);
+    data << uint32(minimum);
+    data << uint32(maximum);
+    data << uint32(roll);
+    data << uint64(GetPlayer()->GetGUID());
+    if (GetPlayer()->GetGroup())
+        GetPlayer()->GetGroup()->BroadcastPacket(&data, false);
+    else
+        SendPacket(&data);
+}
+
+void WorldSession::HandleRaidTargetUpdateOpcode(WorldPacket & recv_data)
+{
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    uint8  x;
+    recv_data >> x;
+
+    /** error handling **/
+    /********************/
+
+    // everything's fine, do it
+    if (x == 0xFF)                                           // target icon request
+    {
+        group->SendTargetIconList(this);
+    }
+    else                                                    // target icon update
+    {
+        if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
+            return;
+
+        uint64 guid;
+        recv_data >> guid;
+        group->SetTargetIcon(x, _player->GetGUID(), guid);
+    }
+}
+
+void WorldSession::HandleGroupRaidConvertOpcode(WorldPacket & /*recv_data*/)
+{
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    if (_player->InBattleground())
+        return;
+
+    /** error handling **/
+    if (!group->IsLeader(GetPlayer()->GetGUID()) || group->GetMembersCount() < 2)
+        return;
+    /********************/
+
+    // everything's fine, do it (is it 0 (PARTY_OP_INVITE) correct code)
+    SendPartyResult(PARTY_OP_INVITE, "", ERR_PARTY_RESULT_OK);
+    group->ConvertToRaid();
+}
+
+void WorldSession::HandleGroupChangeSubGroupOpcode(WorldPacket & recv_data)
+{
+    // we will get correct pointer for group here, so we don't have to check if group is BG raid
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    std::string name;
+    uint8 groupNr;
+    recv_data >> name;
+    recv_data >> groupNr;
+
+    if (groupNr >= MAX_RAID_SUBGROUPS)
+        return;
+
+    /** error handling **/
+    uint64 senderGuid = GetPlayer()->GetGUID();
+    if (!group->IsLeader(senderGuid) && !group->IsAssistant(senderGuid))
+        return;
+
+    if (!group->HasFreeSlotSubGroup(groupNr))
+        return;
+    /********************/
+
+    Player *movedPlayer = sObjectMgr.GetPlayer(name.c_str());
+    if (movedPlayer)
+    {
+        //Do not allow leader to change group of player in combat
+        if (movedPlayer->isInCombat())
+            return;
+
+        // everything's fine, do it
+        group->ChangeMembersGroup(movedPlayer, groupNr);
+    }
+    else
+        group->ChangeMembersGroup(sObjectMgr.GetPlayerGUIDByName(name.c_str()), groupNr);
+}
+
+void WorldSession::HandleGroupAssistantLeaderOpcode(WorldPacket & recv_data)
+{
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    uint64 guid;
+    uint8 flag;
+    recv_data >> guid;
+    recv_data >> flag;
+
+    /** error handling **/
+    if (!group->IsLeader(GetPlayer()->GetGUID()))
+        return;
+    /********************/
+
+    // everything's fine, do it
+    group->SetAssistant(guid, (flag != 0));
+}
+
+void WorldSession::HandlePartyAssignmentOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("MSG_PARTY_ASSIGNMENT");
+
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    uint8 flag, apply;
+    uint64 guid;
+    recv_data >> flag >> apply;
+    recv_data >> guid;
+
+    /** error handling **/
+    uint64 senderGuid = GetPlayer()->GetGUID();
+    if (!group->IsLeader(senderGuid) && !group->IsAssistant(senderGuid))
+        return;
+    /********************/
+
+    // everything's fine, do it
+    if (flag == 0)
+        group->SetMainTank(guid, apply);
+
+    else if (flag == 1)
+        group->SetMainAssistant(guid, apply);
+}
+
+void WorldSession::HandleRaidReadyCheckOpcode(WorldPacket & recv_data)
+{
+    Group *group = GetPlayer()->GetGroup();
+    if (!group)
+        return;
+
+    if (recv_data.empty())                                   // request
+    {
+        /** error handling **/
+        if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
+            return;
+        /********************/
+
+        // everything's fine, do it
+        WorldPacket data(MSG_RAID_READY_CHECK, 8);
+        data << GetPlayer()->GetGUID();
+        group->BroadcastPacket(&data, false, -1);
+
+        group->OfflineReadyCheck();
+    }
+    else                                                    // answer
+    {
+        uint8 state;
+        recv_data >> state;
+
+        // everything's fine, do it
+        WorldPacket data(MSG_RAID_READY_CHECK_CONFIRM, 9);
+        data << uint64(GetPlayer()->GetGUID());
+        data << uint8(state);
+        group->BroadcastReadyCheck(&data);
+    }
+}
+
+void WorldSession::HandleRaidReadyCheckFinishedOpcode(WorldPacket & /*recv_data*/)
+{
+    //Group* group = GetPlayer()->GetGroup();
+    //if (!group)
+    //    return;
+
+    //if (!group->IsLeader(GetPlayer()->GetGUID()) && !group->IsAssistant(GetPlayer()->GetGUID()))
+    //    return;
+
+    // Is any reaction need?
+}
+
+void WorldSession::BuildPartyMemberStatsChangedPacket(Player *player, WorldPacket *data)
+{
+    uint32 mask = player->GetGroupUpdateFlag();
+
+    if (mask == GROUP_UPDATE_FLAG_NONE)
+        return;
+
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)                // if update power type, update current/max power also
+        mask |= (GROUP_UPDATE_FLAG_CUR_POWER | GROUP_UPDATE_FLAG_MAX_POWER);
+
+    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)            // same for pets
+        mask |= (GROUP_UPDATE_FLAG_PET_CUR_POWER | GROUP_UPDATE_FLAG_PET_MAX_POWER);
+
+    uint32 byteCount = 0;
+    for (int i = 1; i < GROUP_UPDATE_FLAGS_COUNT; ++i)
+        if (mask & (1 << i))
+            byteCount += GroupUpdateLength[i];
+
+    data->Initialize(SMSG_PARTY_MEMBER_STATS, 8 + 4 + byteCount);
+    data->append(player->GetPackGUID());
+    *data << (uint32) mask;
+
+    if (mask & GROUP_UPDATE_FLAG_STATUS)
+    {
+        if (player)
+        {
+            if (player->IsPvP())
+                *data << (uint16) (MEMBER_STATUS_ONLINE | MEMBER_STATUS_PVP);
+            else
+                *data << (uint16) MEMBER_STATUS_ONLINE;
+        }
+        else
+            *data << (uint16) MEMBER_STATUS_OFFLINE;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_HP)
+        *data << (uint32) player->GetHealth();
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_HP)
+        *data << (uint32) player->GetMaxHealth();
+
+    Powers powerType = player->getPowerType();
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)
+        *data << (uint8) powerType;
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_POWER)
+        *data << (uint16) player->GetPower(powerType);
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_POWER)
+        *data << (uint16) player->GetMaxPower(powerType);
+
+    if (mask & GROUP_UPDATE_FLAG_LEVEL)
+        *data << (uint16) player->getLevel();
+
+    if (mask & GROUP_UPDATE_FLAG_ZONE)
+        *data << (uint16) player->GetZoneId();
+
+    if (mask & GROUP_UPDATE_FLAG_POSITION)
+        *data << (uint16) player->GetPositionX() << (uint16) player->GetPositionY();
+
+    if (mask & GROUP_UPDATE_FLAG_AURAS)
+    {
+        const uint64& auramask = player->GetAuraUpdateMaskForRaid();
+        *data << uint64(auramask);
+        for (uint32 i = 0; i < MAX_AURAS; ++i)
+        {
+            if (auramask & (uint64(1) << i))
+            {
+                AuraApplication const * aurApp = player->GetVisibleAura(i);
+                *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
+                *data << uint8(1);
+            }
+        }
+    }
+
+    Pet *pet = player->GetPet();
+    if (mask & GROUP_UPDATE_FLAG_PET_GUID)
+    {
+        if (pet)
+            *data << (uint64) pet->GetGUID();
+        else
+            *data << (uint64) 0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_NAME)
+    {
+        if (pet)
+            *data << pet->GetName();
+        else
+            *data << (uint8)  0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_MODEL_ID)
+    {
+        if (pet)
+            *data << (uint16) pet->GetDisplayId();
+        else
+            *data << (uint16) 0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_CUR_HP)
+    {
+        if (pet)
+            *data << (uint32) pet->GetHealth();
+        else
+            *data << (uint32) 0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_MAX_HP)
+    {
+        if (pet)
+            *data << (uint32) pet->GetMaxHealth();
+        else
+            *data << (uint32) 0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)
+    {
+        if (pet)
+            *data << (uint8)  pet->getPowerType();
+        else
+            *data << (uint8)  0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_CUR_POWER)
+    {
+        if (pet)
+            *data << (uint16) pet->GetPower(pet->getPowerType());
+        else
+            *data << (uint16) 0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_MAX_POWER)
+    {
+        if (pet)
+            *data << (uint16) pet->GetMaxPower(pet->getPowerType());
+        else
+            *data << (uint16) 0;
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
+    {
+        if (player->GetVehicle()){
+            Vehicle* vv=player->GetVehicle();
+            *data << (uint32) vv->GetVehicleInfo()->m_seatID[player->m_movementInfo.t_seat];
+        }
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_PET_AURAS)
+    {
+        if (pet)
+        {
+            const uint64& auramask = pet->GetAuraUpdateMaskForRaid();
+            *data << uint64(auramask);
+            for (uint32 i = 0; i < MAX_AURAS; ++i)
+            {
+                if (auramask & (uint64(1) << i))
+                {
+                    AuraApplication const * aurApp = player->GetVisibleAura(i);
+                    *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
+                    *data << uint8(1);
+                }
+            }
+        }
+        else
+            *data << (uint64) 0;
+    }
+}
+
+/*this procedure handles clients CMSG_REQUEST_PARTY_MEMBER_STATS request*/
+void WorldSession::HandleRequestPartyMemberStatsOpcode(WorldPacket &recv_data)
+{
+    sLog.outDebug("WORLD: Received CMSG_REQUEST_PARTY_MEMBER_STATS");
+    uint64 Guid;
+    recv_data >> Guid;
+
+    Player *player = sObjectMgr.GetPlayer(Guid);
+    if (!player)
+    {
+        WorldPacket data(SMSG_PARTY_MEMBER_STATS_FULL, 3+4+2);
+        data << uint8(0);                                   // only for SMSG_PARTY_MEMBER_STATS_FULL, probably arena/bg related
+        data.appendPackGUID(Guid);
+        data << (uint32) GROUP_UPDATE_FLAG_STATUS;
+        data << (uint16) MEMBER_STATUS_OFFLINE;
+        SendPacket(&data);
+        return;
+    }
+
+    Pet *pet = player->GetPet();
+
+    WorldPacket data(SMSG_PARTY_MEMBER_STATS_FULL, 4+2+2+2+1+2*6+8+1+8);
+    data << uint8(0);                                       // only for SMSG_PARTY_MEMBER_STATS_FULL, probably arena/bg related
+    data.append(player->GetPackGUID());
+
+    uint32 mask1 = 0x00040BFF;                              // common mask, real flags used 0x000040BFF
+    if (pet)
+        mask1 = 0x7FFFFFFF;                                 // for hunters and other classes with pets
+
+    Powers powerType = player->getPowerType();
+    data << (uint32) mask1;                                 // group update mask
+    data << (uint16) MEMBER_STATUS_ONLINE;                  // member's online status
+    data << (uint32) player->GetHealth();                   // GROUP_UPDATE_FLAG_CUR_HP
+    data << (uint32) player->GetMaxHealth();                // GROUP_UPDATE_FLAG_MAX_HP
+    data << (uint8)  powerType;                             // GROUP_UPDATE_FLAG_POWER_TYPE
+    data << (uint16) player->GetPower(powerType);           // GROUP_UPDATE_FLAG_CUR_POWER
+    data << (uint16) player->GetMaxPower(powerType);        // GROUP_UPDATE_FLAG_MAX_POWER
+    data << (uint16) player->getLevel();                    // GROUP_UPDATE_FLAG_LEVEL
+    data << (uint16) player->GetZoneId();                   // GROUP_UPDATE_FLAG_ZONE
+    data << (uint16) player->GetPositionX();                // GROUP_UPDATE_FLAG_POSITION
+    data << (uint16) player->GetPositionY();                // GROUP_UPDATE_FLAG_POSITION
+
+    uint64 auramask = 0;
+    size_t maskPos = data.wpos();
+    data << (uint64) auramask;                              // placeholder
+    for (uint8 i = 0; i < MAX_AURAS; ++i)
+    {
+        if (AuraApplication * aurApp = player->GetVisibleAura(i))
+        {
+            auramask |= (uint64(1) << i);
+            data << (uint32) aurApp->GetBase()->GetId();
+            data << (uint8)  1;
+        }
+    }
+    data.put<uint64>(maskPos,auramask);                     // GROUP_UPDATE_FLAG_AURAS
+
+    if (pet)
+    {
+        Powers petpowertype = pet->getPowerType();
+        data << (uint64) pet->GetGUID();                    // GROUP_UPDATE_FLAG_PET_GUID
+        data << pet->GetName();                             // GROUP_UPDATE_FLAG_PET_NAME
+        data << (uint16) pet->GetDisplayId();               // GROUP_UPDATE_FLAG_PET_MODEL_ID
+        data << (uint32) pet->GetHealth();                  // GROUP_UPDATE_FLAG_PET_CUR_HP
+        data << (uint32) pet->GetMaxHealth();               // GROUP_UPDATE_FLAG_PET_MAX_HP
+        data << (uint8)  petpowertype;                      // GROUP_UPDATE_FLAG_PET_POWER_TYPE
+        data << (uint16) pet->GetPower(petpowertype);       // GROUP_UPDATE_FLAG_PET_CUR_POWER
+        data << (uint16) pet->GetMaxPower(petpowertype);    // GROUP_UPDATE_FLAG_PET_MAX_POWER
+
+        uint64 petauramask = 0;
+        size_t petMaskPos = data.wpos();
+        data << (uint64) petauramask;                       // placeholder
+        for (uint8 i = 0; i < MAX_AURAS; ++i)
+        {
+            if (AuraApplication * auraApp = pet->GetVisibleAura(i))
+            {
+                petauramask |= (uint64(1) << i);
+                data << (uint32) auraApp->GetBase()->GetId();
+                data << (uint8)  1;
+            }
+        }
+        data.put<uint64>(petMaskPos,petauramask);           // GROUP_UPDATE_FLAG_PET_AURAS
+    }
+    else
+    {
+        data << (uint8)  0;                                 // GROUP_UPDATE_FLAG_PET_NAME
+        data << (uint64) 0;                                 // GROUP_UPDATE_FLAG_PET_AURAS
+    }
+
+    SendPacket(&data);
+}
+
+/*!*/void WorldSession::HandleRequestRaidInfoOpcode(WorldPacket & /*recv_data*/)
+{
+    // every time the player checks the character screen
+    _player->SendRaidInfo();
+}
+
+/*void WorldSession::HandleGroupCancelOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: got CMSG_GROUP_CANCEL.");
+}*/
+
+void WorldSession::HandleOptOutOfLootOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: Received CMSG_OPT_OUT_OF_LOOT");
+
+    uint32 passOnLoot;
+    recv_data >> passOnLoot; // 1 always pass, 0 do not pass
+
+    // ignore if player not loaded
+    if (!GetPlayer())                                        // needed because STATUS_AUTHED
+    {
+        if (passOnLoot != 0)
+            sLog.outError("CMSG_OPT_OUT_OF_LOOT value<>0 for not-loaded character!");
+        return;
+    }
+
+    GetPlayer()->SetPassOnGroupLoot(passOnLoot);
+}
+
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   
 )
diff --git a/src/server/scripts/EasternKingdoms/CMakeLists.txt b/src/server/scripts/EasternKingdoms/CMakeLists.txt
--- a/src/server/scripts/EasternKingdoms/CMakeLists.txt
+++ b/src/server/scripts/EasternKingdoms/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   EasternKingdoms/ghostlands.cpp
   EasternKingdoms/eversong_woods.cpp
diff --git a/src/server/scripts/Examples/CMakeLists.txt b/src/server/scripts/Examples/CMakeLists.txt
--- a/src/server/scripts/Examples/CMakeLists.txt
+++ b/src/server/scripts/Examples/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Examples/example_misc.cpp
   Examples/example_gossip_codebox.cpp
diff --git a/src/server/scripts/Kalimdor/CMakeLists.txt b/src/server/scripts/Kalimdor/CMakeLists.txt
--- a/src/server/scripts/Kalimdor/CMakeLists.txt
+++ b/src/server/scripts/Kalimdor/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Kalimdor/stonetalon_mountains.cpp
   Kalimdor/silithus.cpp
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Northrend/storm_peaks.cpp
   Northrend/isle_of_conquest.cpp
diff --git a/src/server/scripts/OutdoorPvP/CMakeLists.txt b/src/server/scripts/OutdoorPvP/CMakeLists.txt
--- a/src/server/scripts/OutdoorPvP/CMakeLists.txt
+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   OutdoorPvP/OutdoorPvPTF.cpp
   OutdoorPvP/OutdoorPvPSI.cpp
diff --git a/src/server/scripts/Outland/CMakeLists.txt b/src/server/scripts/Outland/CMakeLists.txt
--- a/src/server/scripts/Outland/CMakeLists.txt
+++ b/src/server/scripts/Outland/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Outland/nagrand.cpp
   Outland/HellfireCitadel/MagtheridonsLair/magtheridons_lair.h
diff --git a/src/server/scripts/Spells/CMakeLists.txt b/src/server/scripts/Spells/CMakeLists.txt
--- a/src/server/scripts/Spells/CMakeLists.txt
+++ b/src/server/scripts/Spells/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Spells/spell_shaman.cpp
   Spells/spell_hunter.cpp
diff --git a/src/server/scripts/World/CMakeLists.txt b/src/server/scripts/World/CMakeLists.txt
--- a/src/server/scripts/World/CMakeLists.txt
+++ b/src/server/scripts/World/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿set(scripts_STAT_SRCS
+set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   World/npc_professions.cpp
   World/mob_generic_creature.cpp
@@ -16,6 +16,7 @@
   World/npc_mount.cpp
   World/go_scripts.cpp
   World/npc_innkeeper.cpp
+  World/dungeon_finder.cpp
   World/achievement_scripts.cpp
 )
 
diff --git a/src/server/scripts/World/dungeon_finder.cpp b/src/server/scripts/World/dungeon_finder.cpp
--- a/src/server/scripts/World/dungeon_finder.cpp
+++ b/src/server/scripts/World/dungeon_finder.cpp
@@ -152,4 +152,3 @@
 {
     new DungeonFinderScript();
 }
-
diff --git a/src/server/scripts/World/npc_innkeeper.cpp b/src/server/scripts/World/npc_innkeeper.cpp
--- a/src/server/scripts/World/npc_innkeeper.cpp
+++ b/src/server/scripts/World/npc_innkeeper.cpp
@@ -1,4 +1,4 @@
-﻿/*
+/*
  * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
  * This program is free software; you can redistribute it and/or modify it
@@ -31,11 +31,11 @@
 
 #define LOCALE_TRICK_OR_TREAT_0 "Trick or Treat!"
 #define LOCALE_TRICK_OR_TREAT_2 "Des bonbons ou des blagues!"
-#define LOCALE_TRICK_OR_TREAT_3 "Süßes oder Saures!"
-#define LOCALE_TRICK_OR_TREAT_6 "¡Truco o trato!"
+#define LOCALE_TRICK_OR_TREAT_3 "Su?es oder Saures!"
+#define LOCALE_TRICK_OR_TREAT_6 "?Truco o trato!"
 
 #define LOCALE_INNKEEPER_0 "Make this inn my home."
-#define LOCALE_INNKEEPER_3 "Ich möchte dieses Gasthaus zu meinem Heimatort machen."
+#define LOCALE_INNKEEPER_3 "Ich mochte dieses Gasthaus zu meinem Heimatort machen."
 
 class npc_innkeeper : public CreatureScript
 {
diff --git a/src/server/shared/CMakeLists.txt b/src/server/shared/CMakeLists.txt
--- a/src/server/shared/CMakeLists.txt
+++ b/src/server/shared/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/tools/CMakeLists.txt b/src/tools/CMakeLists.txt
--- a/src/tools/CMakeLists.txt
+++ b/src/tools/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+# Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
 # unlimited permission to copy and/or distribute it, with or without
diff --git a/src/tools/map_extractor/CMakeLists.txt b/src/tools/map_extractor/CMakeLists.txt
--- a/src/tools/map_extractor/CMakeLists.txt
+++ b/src/tools/map_extractor/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2005-2009 MaNGOS project <http://getmangos.com/>
+# Copyright (C) 2005-2009 MaNGOS project <http://getmangos.com/>
 # Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
diff --git a/src/tools/vmap3_assembler/CMakeLists.txt b/src/tools/vmap3_assembler/CMakeLists.txt
--- a/src/tools/vmap3_assembler/CMakeLists.txt
+++ b/src/tools/vmap3_assembler/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2005-2009 MaNGOS project <http://getmangos.com/>
+# Copyright (C) 2005-2009 MaNGOS project <http://getmangos.com/>
 # Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
diff --git a/src/tools/vmap3_extractor/CMakeLists.txt b/src/tools/vmap3_extractor/CMakeLists.txt
--- a/src/tools/vmap3_extractor/CMakeLists.txt
+++ b/src/tools/vmap3_extractor/CMakeLists.txt
@@ -1,4 +1,4 @@
-﻿# Copyright (C) 2005-2009 MaNGOS project <http://getmangos.com/>
+# Copyright (C) 2005-2009 MaNGOS project <http://getmangos.com/>
 # Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
 #
 # This file is free software; as a special exception the author gives
