# HG changeset patch
# User asniker
# Date 1286608035 -21600
# Node ID 37b78c02343d9242acf54ced15d6c376e0db9362
# Parent  58649e1e6998ebf7ef35bc7f4c01ac38b55afba4
fix many warnings

diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundIC.cpp
@@ -932,7 +932,7 @@
         plr->SetTransport(m_GunshipA);
         plr->m_movementInfo.t_pos.m_positionX=7.305609f;
         plr->m_movementInfo.t_pos.m_positionY=-0.095246f;
-        plr->m_movementInfo.t_pos.m_positionZ=34.51022;
+        plr->m_movementInfo.t_pos.m_positionZ=34.51022f;
         plr->m_movementInfo.t_guid=m_GunshipA->GetGUID();
         plr->TeleportTo(GetMapId(),661,-1244,288,0,TELE_TO_NOT_LEAVE_TRANSPORT);
         }       
@@ -944,7 +944,7 @@
         plr->SetTransport(m_GunshipH);
         plr->m_movementInfo.t_pos.m_positionX=7.305609f;
         plr->m_movementInfo.t_pos.m_positionY=-0.095246f;
-        plr->m_movementInfo.t_pos.m_positionZ=34.51022;
+        plr->m_movementInfo.t_pos.m_positionZ=34.51022f;
         plr->m_movementInfo.t_guid=m_GunshipH->GetGUID();
         plr->TeleportTo(GetMapId(),661,-1244,288,0,TELE_TO_NOT_LEAVE_TRANSPORT);
         }
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundIC.h b/src/server/game/Battlegrounds/Zones/BattlegroundIC.h
--- a/src/server/game/Battlegrounds/Zones/BattlegroundIC.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundIC.h
@@ -517,66 +517,66 @@
 
 const ICNpc BG_IC_NPC[MAX_BG_IC_NPC]=
 {    
-    {BG_IC_TOWER_A_GUN_1,415.277,-911.552,87.9619,4.64663    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_2,406.047,-755.747,87.7159,1.60951    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_3,416.925,-754.642,87.7161,1.66841    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_4,428.073,-781.504,87.7164,5.87029    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_5,402.085,-910.381,87.9619,4.60793    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_6,424.651,-880.262,87.9622,0.389539    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_7,408.402,-911.213,87.9619,4.58045    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_8,425.612,-786.81,87.7164,5.84336    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_9,426.734,-885.28,87.9622,0.408575    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_10,429.368,-891.332,87.9622,0.413433    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_11,411.235,-755.277,87.7156,1.64348    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_A_GUN_12,430.576,-776.358,87.7164,5.84359    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},    
-    {BG_IC_TOWER_H_GUN_1,1135.32,-841.482,87.8928,2.33312    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_2,1143.94,-833.972,87.8754,2.3565    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_3,1138.4,-836.268,88.3325,2.33312    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_4,1166.1,-858.237,87.8699,5.37732    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_5,1157.07,-865.976,87.8623,5.44565    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_6,1159.59,-660.741,87.9104,0.775668    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_7,1166.99,-668.854,87.9144,0.775668    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_8,1162.51,-863.159,88.3046,5.44565    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_9,1164.02,-664.332,88.2895,0.736398    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_10,1141.85,-691.039,87.9605,3.78012    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_11,1135.28,-682.692,87.859,3.78012    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
-    {BG_IC_TOWER_H_GUN_12,1137.99,-688.115,88.3004,3.85473    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_1,415.277f,-911.552f,87.9619f,4.64663f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_2,406.047f,-755.747f,87.7159f,1.60951f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_3,416.925f,-754.642f,87.7161f,1.66841f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_4,428.073f,-781.504f,87.7164f,5.87029f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_5,402.085f,-910.381f,87.9619f,4.60793f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_6,424.651f,-880.262f,87.9622f,0.389539f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_7,408.402f,-911.213f,87.9619f,4.58045f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_8,425.612f,-786.81f,87.7164f,5.84336f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_9,426.734f,-885.28f,87.9622f,0.408575f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_10,429.368f,-891.332f,87.9622f,0.413433f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_11,411.235f,-755.277f,87.7156f,1.64348f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_A_GUN_12,430.576f,-776.358f,87.7164f,5.84359f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_ALLIANCE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},    
+    {BG_IC_TOWER_H_GUN_1,1135.32f,-841.482f,87.8928f,2.33312f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_2,1143.94f,-833.972f,87.8754f,2.3565f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_3,1138.4f,-836.268f,88.3325f,2.33312f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_4,1166.1f,-858.237f,87.8699f,5.37732f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_5,1157.07f,-865.976f,87.8623f,5.44565f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_6,1159.59f,-660.741f,87.9104f,0.775668f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_7,1166.99f,-668.854f,87.9144f,0.775668f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_8,1162.51f,-863.159f,88.3046f,5.44565f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_9,1164.02f,-664.332f,88.2895f,0.736398f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_10,1141.85f,-691.039f,87.9605f,3.78012f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_11,1135.28f,-682.692f,87.859f,3.78012f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
+    {BG_IC_TOWER_H_GUN_12,1137.99f,-688.115f,88.3004f,3.85473f    ,BG_IC_NPCID_KEEP_CANNON,FACTION_HORDE,IC_TYPE_KEEP_GUN,RESPAWN_ONE_DAY},
     //Boss horde + 4 add
-    {BG_IC_NPC_OVERLORD_AGMAR,1295.29,-769.952,69.9586,0.311803    ,BG_IC_NPCID_OVERLORD_AGMAR,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_H_ADD_1,1296.01,-773.256,69.958,0.292168            ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_H_ADD_2,1295.94,-757.756,69.9587,6.02165            ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_H_ADD_3,1295.09,-760.927,69.9587,5.94311            ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_H_ADD_4,1295.67,-765.636,69.9745,0.048692        ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_OVERLORD_AGMAR,1295.29f,-769.952f,69.9586f,0.311803f    ,BG_IC_NPCID_OVERLORD_AGMAR,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_H_ADD_1,1296.01f,-773.256f,69.958f,0.292168f            ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_H_ADD_2,1295.94f,-757.756f,69.9587f,6.02165f            ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_H_ADD_3,1295.09f,-760.927f,69.9587f,5.94311f            ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_H_ADD_4,1295.67f,-765.636f,69.9745f,0.048692f       ,BG_IC_NPCID_KORKRON_GUARD,FACTION_HORDE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
     //Boss alliance + 4 add
-    {BG_IC_NPC_HIGH_COMMANDER_HALFORD_WYRMBANE,224.159,-831.012,60.8201,0.0191563,BG_IC_NPCID_HIGH_COMMANDER_HALFORD_WYRMBANE,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_A_ADD_1,223.969,-822.958,60.8151,0.46337            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_A_ADD_2,224.211,-826.952,60.8188,6.25961            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_A_ADD_3,223.119,-838.386,60.8145,5.64857            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
-    {BG_IC_NPC_A_ADD_4,223.889,-835.102,60.8201,6.21642            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_HIGH_COMMANDER_HALFORD_WYRMBANE,224.159f,-831.012f,60.8201f,0.0191563f,BG_IC_NPCID_HIGH_COMMANDER_HALFORD_WYRMBANE,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_A_ADD_1,223.969f,-822.958f,60.8151f,0.46337f            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_A_ADD_2,224.211f,-826.952f,60.8188f,6.25961f            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_A_ADD_3,223.119f,-838.386f,60.8145f,5.64857f            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
+    {BG_IC_NPC_A_ADD_4,223.889f,-835.102f,60.8201f,6.21642f            ,BG_IC_NPCID_SEVENTH_LEGION_INFANTRY,FACTION_ALLIANCE,IC_TYPE_NONE,RESPAWN_ONE_DAY},
     //Dock
-    {BG_IC_CATAPULT_1_H,803.944, -343.237, 12.609,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
-    {BG_IC_CATAPULT_2_H,797.233, -343.237, 12.083,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
-    {BG_IC_CATAPULT_3_H,774.005, -343.237, 12.115,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
-    {BG_IC_CATAPULT_4_H,766.961, -343.237, 12.094,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
-    {BG_IC_GLAIVE_THROWER_1_H,788.516,-343.237,12.598,4.71239    ,BG_IC_NPCID_GLAIVE_THROWER_H,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
-    {BG_IC_GLAIVE_THROWER_2_H,782.273,-343.237,12.602,4.71239    ,BG_IC_NPCID_GLAIVE_THROWER_H,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
-    {BG_IC_CATAPULT_1_A,803.944, -343.237, 12.609,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
-    {BG_IC_CATAPULT_2_A,797.233, -343.237, 12.083,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
-    {BG_IC_CATAPULT_3_A,774.005, -343.237, 12.115,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
-    {BG_IC_CATAPULT_4_A,766.961, -343.237, 12.094,4.71239        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
-    {BG_IC_GLAIVE_THROWER_1_A,788.516,-343.237,12.598,4.71239    ,BG_IC_NPCID_GLAIVE_THROWER_A,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
-    {BG_IC_GLAIVE_THROWER_2_A,782.273,-343.237,12.602,4.71239    ,BG_IC_NPCID_GLAIVE_THROWER_A,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_1_H,803.944f, -343.237f, 12.609f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_2_H,797.233f, -343.237f, 12.083f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_3_H,774.005f, -343.237f, 12.115f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_4_H,766.961f, -343.237f, 12.094f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
+    {BG_IC_GLAIVE_THROWER_1_H,788.516f,-343.237f,12.598f,4.71239f    ,BG_IC_NPCID_GLAIVE_THROWER_H,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
+    {BG_IC_GLAIVE_THROWER_2_H,782.273f,-343.237f,12.602f,4.71239f    ,BG_IC_NPCID_GLAIVE_THROWER_H,FACTION_HORDE,IC_TYPE_DOCKVEHICLE_H,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_1_A,803.944f, -343.237f, 12.609f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_2_A,797.233f, -343.237f, 12.083f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_3_A,774.005f, -343.237f, 12.115f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
+    {BG_IC_CATAPULT_4_A,766.961f, -343.237f, 12.094f,4.71239f        ,BG_IC_NPCID_CATAPULT,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
+    {BG_IC_GLAIVE_THROWER_1_A,788.516f,-343.237f,12.598f,4.71239f    ,BG_IC_NPCID_GLAIVE_THROWER_A,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
+    {BG_IC_GLAIVE_THROWER_2_A,782.273f,-343.237f,12.602f,4.71239f    ,BG_IC_NPCID_GLAIVE_THROWER_A,FACTION_ALLIANCE,IC_TYPE_DOCKVEHICLE_A,RESPAWN_ONE_DAY},
     // Workshop
-    {BG_IC_DEMOLISHER_H_1,760.571,-853.102,12.4412,1.65484        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
-    {BG_IC_DEMOLISHER_H_2,752.082,-853.817,12.4412,1.65484        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
-    {BG_IC_DEMOLISHER_H_3,791.213,-853.526,12.4596,1.5174        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
-    {BG_IC_DEMOLISHER_H_4,783.065,-852.904,12.4552,1.5174        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
-    {BG_IC_DEMOLISHER_A_1,760.571,-853.102,12.4412,1.65484        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
-    {BG_IC_DEMOLISHER_A_2,752.082,-853.817,12.4412,1.65484        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
-    {BG_IC_DEMOLISHER_A_3,791.213,-853.526,12.4596,1.5174        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
-    {BG_IC_DEMOLISHER_A_4,783.065,-852.904,12.4552,1.5174        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
-    {BG_IC_SIEGE_ENGINE_H,773.623, -884.381, 16.725, 1.530        ,BG_IC_NPCID_SIEGE_ENGINE_H,FACTION_HORDE,IC_TYPE_SIEGE_H,0},
-    {BG_IC_SIEGE_ENGINE_A,773.623, -884.381, 16.725, 1.530        ,BG_IC_NPCID_SIEGE_ENGINE_A,FACTION_ALLIANCE,IC_TYPE_SIEGE_A,0},
+    {BG_IC_DEMOLISHER_H_1,760.571f,-853.102f,12.4412f,1.65484f        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
+    {BG_IC_DEMOLISHER_H_2,752.082f,-853.817f,12.4412f,1.65484f        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
+    {BG_IC_DEMOLISHER_H_3,791.213f,-853.526f,12.4596f,1.5174f        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
+    {BG_IC_DEMOLISHER_H_4,783.065f,-852.904f,12.4552f,1.5174f        ,BG_IC_NPCID_DEMOLISHER,FACTION_HORDE,IC_TYPE_DEMOLISSER_H,0},
+    {BG_IC_DEMOLISHER_A_1,760.571f,-853.102f,12.4412f,1.65484f        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
+    {BG_IC_DEMOLISHER_A_2,752.082f,-853.817f,12.4412f,1.65484f        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
+    {BG_IC_DEMOLISHER_A_3,791.213f,-853.526f,12.4596f,1.5174f        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
+    {BG_IC_DEMOLISHER_A_4,783.065f,-852.904f,12.4552f,1.5174f        ,BG_IC_NPCID_DEMOLISHER,FACTION_ALLIANCE,IC_TYPE_DEMOLISSER_A,0},
+    {BG_IC_SIEGE_ENGINE_H,773.623f, -884.381f, 16.725f, 1.530f        ,BG_IC_NPCID_SIEGE_ENGINE_H,FACTION_HORDE,IC_TYPE_SIEGE_H,0},
+    {BG_IC_SIEGE_ENGINE_A,773.623f, -884.381f, 16.725f, 1.530f        ,BG_IC_NPCID_SIEGE_ENGINE_A,FACTION_ALLIANCE,IC_TYPE_SIEGE_A,0},
 };
 
 /*
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -18130,7 +18130,8 @@
  	    continue;
  	
           Bag *container = item->GetContainer();
-          uint32 bag_guid = container && container->isokbag() ? container->GetGUIDLow() : 0;
+          uint32 bag_guid = container ? container->GetGUIDLow() : 0;
+
   
           if (item->GetState() != ITEM_REMOVED)
           {
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -356,11 +356,10 @@
 void AddSC_boss_anubarak_trial();        //Trial of the Crusader
 void AddSC_boss_faction_champions();
 void AddSC_boss_jaraxxus();
-void AddSC_boss_northrend_beasts();
 void AddSC_boss_twin_valkyr();
 void AddSC_trial_of_the_crusader();
 void AddSC_instance_trial_of_the_crusader();
-void AddSC_boss_beasts_of_northrend);
+void AddSC_boss_beasts_of_northrend();
 void AddSC_boss_anubrekhan();            //Naxxramas
 void AddSC_boss_maexxna();
 void AddSC_boss_patchwerk();
@@ -1038,9 +1037,8 @@
     AddSC_boss_jaraxxus();
     AddSC_trial_of_the_crusader();
     AddSC_boss_twin_valkyr();
-    AddSC_boss_northrend_beasts();
     AddSC_instance_trial_of_the_crusader();
-	AddSC_boss_beasts_of_northrend);
+	AddSC_boss_beasts_of_northrend();
     AddSC_boss_krik_thir();             //Azjol-Nerub Azjol-Nerub
     AddSC_boss_hadronox();
     AddSC_boss_anub_arak();
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -165,6 +165,19 @@
     CONFIG_AUTOBROADCAST,
     CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED,
     CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR,
+	CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD,
+	CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME,
+	CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME,
+	CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL,
+	CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE,
+	CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE,
+	CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER,
+	CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER,
+	CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING,
+	CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING,
+	CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE,
+	CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK,
+	CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF,
     BOOL_CONFIG_VALUE_COUNT
 };
 
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -77,7 +77,6 @@
   Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_faction_champions.cpp
   Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_lord_jaraxxus.cpp
   Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.h
-  Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_northrend_beasts.cpp
   Northrend/CrusadersColiseum/TrialOfTheCrusader/trial_of_the_crusader.cpp
   Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_twin_valkyr.cpp
   Northrend/CrusadersColiseum/TrialOfTheCrusader/instance_trial_of_the_crusader.cpp
diff --git a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_northrend_beasts.cpp b/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_northrend_beasts.cpp
deleted file mode 100644
--- a/src/server/scripts/Northrend/CrusadersColiseum/TrialOfTheCrusader/boss_northrend_beasts.cpp
+++ /dev/null
@@ -1,910 +0,0 @@
-/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* ScriptData
-SDName: northrend_beasts
-SD%Complete: 90%
-SDComment: based on /dev/rsa
-SDCategory:
-EndScriptData */
-
-// Known bugs:
-// Gormok - Not implemented as a vehicle
-//        - Snobold Firebomb
-//        - Snobolled (creature at back)
-// Snakes - miss the 1-hitkill from emerging
-//        - visual changes between mobile and stationary models seems not to work sometimes
-
-#include "ScriptPCH.h"
-#include "trial_of_the_crusader.h"
-
-enum Yells
-{
-    //Gormok
-    SAY_SNOBOLLED        = -1649000,
-    //Acidmaw & Dreadscale
-    SAY_SUBMERGE         = -1649010,
-    SAY_EMERGE           = -1649011,
-    SAY_BERSERK          = -1649012,
-    //Icehowl
-    SAY_TRAMPLE_STARE    = -1649020,
-    SAY_TRAMPLE_FAIL     = -1649021,
-    SAY_TRAMPLE_START    = -1649022,
-};
-
-enum Equipment
-{
-    EQUIP_MAIN           = 50760,
-    EQUIP_OFFHAND        = 48040,
-    EQUIP_RANGED         = 47267,
-    EQUIP_DONE           = EQUIP_NO_CHANGE,
-};
-
-enum Model
-{
-    MODEL_ACIDMAW_STATIONARY     = 29815,
-    MODEL_ACIDMAW_MOBILE         = 29816,
-    MODEL_DREADSCALE_STATIONARY  = 26935,
-    MODEL_DREADSCALE_MOBILE      = 24564,
-};
-
-enum Summons
-{
-    NPC_SNOBOLD_VASSAL   = 34800,
-    NPC_SLIME_POOL       = 35176,
-};
-
-enum BossSpells
-{
-    //Gormok
-    SPELL_IMPALE            = 66331,
-    SPELL_STAGGERING_STOMP  = 67648,
-    SPELL_RISING_ANGER      = 66636,
-    //Snobold
-    SPELL_SNOBOLLED         = 66406,
-    SPELL_BATTER            = 66408,
-    SPELL_FIRE_BOMB         = 66313,
-    SPELL_FIRE_BOMB_1       = 66317,
-    SPELL_FIRE_BOMB_DOT     = 66318,
-    SPELL_HEAD_CRACK        = 66407,
-
-    //Acidmaw & Dreadscale
-    SPELL_ACID_SPIT         = 66880,
-    SPELL_PARALYTIC_SPRAY   = 66901,
-    SPELL_ACID_SPEW         = 66819,
-    SPELL_PARALYTIC_BITE    = 66824,
-    SPELL_SWEEP_0           = 66794,
-    SUMMON_SLIME_POOL       = 66883,
-    SPELL_FIRE_SPIT         = 66796,
-    SPELL_MOLTEN_SPEW       = 66821,
-    SPELL_BURNING_BITE      = 66879,
-    SPELL_BURNING_SPRAY     = 66902,
-    SPELL_SWEEP_1           = 67646,
-    SPELL_EMERGE_0          = 66947,
-    SPELL_SUBMERGE_0        = 53421,
-    SPELL_ENRAGE            = 68335,
-    SPELL_SLIME_POOL_EFFECT = 66882, //In 60s it diameter grows from 10y to 40y (r=r+0.25 per second)
-
-    //Icehowl
-    SPELL_FEROCIOUS_BUTT    = 66770,
-    SPELL_MASSIVE_CRASH     = 66683,
-    SPELL_WHIRL             = 67345,
-    SPELL_ARCTIC_BREATH     = 66689,
-    SPELL_TRAMPLE           = 66734,
-    SPELL_FROTHING_RAGE     = 66759,
-    SPELL_STAGGERED_DAZE    = 66758,
-};
-class boss_gormok : public CreatureScript
-{
-public:
-    boss_gormok() : CreatureScript("boss_gormok") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new boss_gormokAI(pCreature);
-    }
-
-    struct boss_gormokAI : public ScriptedAI
-    {
-        boss_gormokAI(Creature* pCreature) : ScriptedAI(pCreature), Summons(me)
-        {
-            m_pInstance = (InstanceScript*)pCreature->GetInstanceScript();
-        }
-
-        InstanceScript* m_pInstance;
-
-        uint32 m_uiImpaleTimer;
-        uint32 m_uiStaggeringStompTimer;
-        SummonList Summons;
-        uint32 m_uiSummonTimer;
-        uint32 m_uiSummonCount;
-
-        void Reset()
-        {
-            m_uiImpaleTimer = urand(8*IN_MILLISECONDS,10*IN_MILLISECONDS);
-            m_uiStaggeringStompTimer = 15*IN_MILLISECONDS;
-            m_uiSummonTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);;
-
-            if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL ||
-                getDifficulty() == RAID_DIFFICULTY_25MAN_HEROIC)
-                m_uiSummonCount = 5;
-            else
-                m_uiSummonCount = 4;
-
-            Summons.DespawnAll();
-        }
-
-        void JustDied(Unit* /*pKiller*/)
-        {
-            if (m_pInstance)
-                m_pInstance->SetData(TYPE_NORTHREND_BEASTS,GORMOK_DONE);
-        }
-
-        void JustReachedHome()
-        {
-            if (m_pInstance)
-                m_pInstance->SetData(TYPE_NORTHREND_BEASTS,FAIL);
-            me->ForcedDespawn();
-        }
-
-        void EnterCombat(Unit* /*pWho*/)
-        {
-            me->SetInCombatWithZone();
-            m_pInstance->SetData(TYPE_NORTHREND_BEASTS,GORMOK_IN_PROGRESS);
-        }
-
-        void JustSummoned(Creature* pSummoned)
-        {
-            Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM,0);
-            switch(pSummoned->GetEntry())
-            {
-                case NPC_SNOBOLD_VASSAL:
-                    pSummoned->GetMotionMaster()->MoveJump(pTarget->GetPositionX(),pTarget->GetPositionY(),pTarget->GetPositionZ(),10.0f,20.0f);
-                    DoCast(me, SPELL_RISING_ANGER);
-                    --m_uiSummonCount;
-                    break;
-            }
-            pSummoned->AI()->AttackStart(pTarget);
-            Summons.Summon(pSummoned);
-        }
-
-        void SummonedCreatureDespawn(Creature* pSummoned)
-        {
-            switch(pSummoned->GetEntry())
-            {
-                case NPC_SNOBOLD_VASSAL:
-                    if (pSummoned->isAlive()) ++m_uiSummonCount;
-                    break;
-            }
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            if (m_uiImpaleTimer <= uiDiff)
-            {
-                DoCast(me->getVictim(),SPELL_IMPALE);
-                m_uiImpaleTimer = urand(8*IN_MILLISECONDS,10*IN_MILLISECONDS);
-            } else m_uiImpaleTimer -= uiDiff;
-
-            if (m_uiStaggeringStompTimer <= uiDiff)
-            {
-                DoCast(me->getVictim(),SPELL_STAGGERING_STOMP);
-                m_uiStaggeringStompTimer = urand(20*IN_MILLISECONDS,25*IN_MILLISECONDS);
-            } else m_uiStaggeringStompTimer -= uiDiff;
-
-            if (m_uiSummonTimer <= uiDiff)
-            {
-                if (m_uiSummonCount > 0)
-                {
-                    me->SummonCreature(NPC_SNOBOLD_VASSAL,me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),0,TEMPSUMMON_CORPSE_DESPAWN);
-                    DoScriptText(SAY_SNOBOLLED,me);
-                }
-                m_uiSummonTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-            } else m_uiSummonTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
-};
-
-class mob_snobold_vassal : public CreatureScript
-{
-public:
-    mob_snobold_vassal() : CreatureScript("mob_snobold_vassal") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new mob_snobold_vassalAI(pCreature);
-    }
-
-    struct mob_snobold_vassalAI : public ScriptedAI
-    {
-        mob_snobold_vassalAI(Creature* pCreature) : ScriptedAI(pCreature)
-        {
-            m_pInstance = (InstanceScript*)pCreature->GetInstanceScript();
-            if (m_pInstance)
-                m_pInstance->SetData(DATA_SNOBOLD_COUNT, INCREASE);
-        }
-
-        InstanceScript* m_pInstance;
-        uint32 m_uiFireBombTimer;
-        uint32 m_uiBatterTimer;
-        uint32 m_uiHeadCrackTimer;
-        uint64 m_uiBossGUID;
-        uint64 m_uiTargetGUID;
-        bool   m_bTargetDied;
-
-        void Reset()
-        {
-            m_uiFireBombTimer = 15000;
-            m_uiBatterTimer = 5000;
-            m_uiHeadCrackTimer = 25000;
-
-            m_uiTargetGUID = 0;
-            m_bTargetDied = false;
-            if (m_pInstance)
-                m_uiBossGUID = m_pInstance->GetData64(NPC_GORMOK);
-            //Workaround for Snobold
-            me->RemoveFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE);
-        }
-
-        void EnterCombat(Unit *pWho)
-        {
-            m_uiTargetGUID = pWho->GetGUID();
-            me->TauntApply(pWho);
-            DoCast(pWho, SPELL_SNOBOLLED);
-        }
-
-        void DamageTaken(Unit* pDoneBy, uint32 &uiDamage)
-        {
-            if (pDoneBy->GetGUID()==m_uiTargetGUID)
-                uiDamage = 0;
-        }
-
-        void MovementInform(uint32 uiType, uint32 uiId)
-        {
-            if (uiType != POINT_MOTION_TYPE) return;
-
-            switch (uiId)
-            {
-                case 0: // JUMP!? Fuck! THAT'S BEEZARR! Would someone PLEASE make MotionMaster->Move* work better?
-                    if (m_bTargetDied)
-                        me->ForcedDespawn();
-                    break;
-            }
-        }
-
-        void JustDied(Unit* /*pKiller*/)
-        {
-            if (Unit *pTarget = Unit::GetPlayer(*me,m_uiTargetGUID))
-                if (pTarget->isAlive())
-                    pTarget->RemoveAurasDueToSpell(SPELL_SNOBOLLED);
-            if (m_pInstance)
-                m_pInstance->SetData(DATA_SNOBOLD_COUNT, DECREASE);
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            if (m_bTargetDied || !UpdateVictim())
-                return;
-
-            if (Unit* pTarget = Unit::GetPlayer(*me,m_uiTargetGUID))
-                if (!pTarget->isAlive())
-                    if (m_pInstance)
-                        if (Unit* pGormok = Unit::GetCreature(*me,m_pInstance->GetData64(NPC_GORMOK)))
-                        {
-                            if (pGormok->isAlive())
-                            {
-                                SetCombatMovement(false);
-                                m_bTargetDied = true;
-                                me->GetMotionMaster()->MoveJump(pGormok->GetPositionX(),pGormok->GetPositionY(),pGormok->GetPositionZ(),15.0f,15.0f);
-                            }
-                            else
-                            {
-                                if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
-                                {
-                                    m_uiTargetGUID = pTarget->GetGUID();
-                                    me->GetMotionMaster()->MoveJump(pTarget->GetPositionX(),pTarget->GetPositionY(),pTarget->GetPositionZ(),15.0f,15.0f);
-                                }
-                            }
-                        }
-
-            if (m_uiFireBombTimer < uiDiff)
-            {
-                if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
-                    DoCast(pTarget, SPELL_FIRE_BOMB);
-                m_uiFireBombTimer = 20000;
-            }
-            else m_uiFireBombTimer -= uiDiff;
-
-            if (m_uiBatterTimer < uiDiff)
-            {
-                if (Unit *pTarget = Unit::GetPlayer(*me,m_uiTargetGUID))
-                    DoCast(pTarget, SPELL_BATTER);
-                m_uiBatterTimer = 10000;
-            }
-            else m_uiBatterTimer -= uiDiff;
-
-            if (m_uiHeadCrackTimer < uiDiff)
-            {
-                if (Unit *pTarget = Unit::GetPlayer(*me,m_uiTargetGUID))
-                    DoCast(pTarget, SPELL_HEAD_CRACK);
-                m_uiHeadCrackTimer = 35000;
-            }
-            else m_uiHeadCrackTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
-};
-
-
-struct boss_jormungarAI : public ScriptedAI
-{
-    boss_jormungarAI(Creature* pCreature) : ScriptedAI(pCreature)
-    {
-        m_pInstance = (InstanceScript*)pCreature->GetInstanceScript();
-    }
-
-    InstanceScript* m_pInstance;
-
-    uint32 m_uiSisterID;
-
-    uint32 m_uiModelStationary;
-    uint32 m_uiModelMobile;
-
-    uint32 m_uiBiteSpell;
-    uint32 m_uiSpewSpell;
-    uint32 m_uiSpitSpell;
-    uint32 m_uiSpraySpell;
-
-    uint32 m_uiBiteTimer;
-    uint32 m_uiSpewTimer;
-    uint32 m_uiSlimePoolTimer;
-    uint32 m_uiSpitTimer;
-    uint32 m_uiSprayTimer;
-    uint32 m_uiSweepTimer;
-    uint32 m_uiSubmergeTimer;
-    uint8  m_uiStage;
-    bool   m_bEnraged;
-
-    void Reset()
-    {
-        m_bEnraged = false;
-        m_uiBiteTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-        m_uiSpewTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-        m_uiSlimePoolTimer = 15*IN_MILLISECONDS;
-        m_uiSpitTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-        m_uiSprayTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-        m_uiSweepTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-    }
-
-    void JustDied(Unit* /*pKiller*/)
-    {
-        if (m_pInstance)
-        {
-            if (Creature* pSister = Unit::GetCreature((*me),m_pInstance->GetData64(m_uiSisterID)))
-            {
-                if (!pSister->isAlive())
-                    m_pInstance->SetData(TYPE_NORTHREND_BEASTS, SNAKES_DONE);
-                else
-                    m_pInstance->SetData(TYPE_NORTHREND_BEASTS, SNAKES_SPECIAL);
-            }
-        }
-    }
-
-    void JustReachedHome()
-    {
-        if (m_pInstance && m_pInstance->GetData(TYPE_NORTHREND_BEASTS) != FAIL)
-            m_pInstance->SetData(TYPE_NORTHREND_BEASTS, FAIL);
-        me->ForcedDespawn();
-    }
-
-    void KilledUnit(Unit *pWho)
-    {
-        if (pWho->GetTypeId() == TYPEID_PLAYER)
-        {
-            if (m_pInstance)
-                m_pInstance->SetData(DATA_TRIBUTE_TO_IMMORTALITY_ELEGIBLE, 0);
-        }
-    }
-
-    void EnterCombat(Unit* /*pWho*/)
-    {
-        me->SetInCombatWithZone();
-        if (m_pInstance)
-            m_pInstance->SetData(TYPE_NORTHREND_BEASTS, SNAKES_IN_PROGRESS);
-    }
-
-    void UpdateAI(const uint32 uiDiff)
-    {
-        if (!UpdateVictim()) return;
-
-        if (m_pInstance && m_pInstance->GetData(TYPE_NORTHREND_BEASTS) == SNAKES_SPECIAL && !m_bEnraged)
-        {
-            DoScriptText(SAY_EMERGE,me);
-            me->RemoveAurasDueToSpell(SPELL_SUBMERGE_0);
-            me->RemoveFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE);
-            DoCast(SPELL_ENRAGE);
-            m_bEnraged = true;
-            DoScriptText(SAY_BERSERK,me);
-            switch (m_uiStage)
-            {
-                case 0: break;
-                case 4:
-                    m_uiStage = 5;
-                    m_uiSubmergeTimer = 5*IN_MILLISECONDS;
-                default:
-                    m_uiStage = 7;
-            }
-        }
-
-        switch (m_uiStage)
-        {
-            case 0: // Mobile
-                if (m_uiBiteTimer <= uiDiff)
-                {
-                    DoCastVictim(m_uiBiteSpell);
-                    m_uiBiteTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-                } else m_uiBiteTimer -= uiDiff;
-
-                if (m_uiSpewTimer <= uiDiff)
-                {
-                    DoCastAOE(m_uiSpewSpell);
-                    m_uiSpewTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-                } else m_uiSpewTimer -= uiDiff;
-
-                if (m_uiSlimePoolTimer <= uiDiff)
-                {
-                    /* Spell summon has only 30s duration */
-                    //DoCast(SUMMON_SLIME_POOL);
-                    me->SummonCreature(NPC_SLIME_POOL,me->GetPositionX(),me->GetPositionY(),me->GetPositionZ(),0);
-                    m_uiSlimePoolTimer = 30*IN_MILLISECONDS;
-                } else m_uiSlimePoolTimer -= uiDiff;
-
-                if (m_uiSubmergeTimer <= uiDiff && !m_bEnraged)
-                {
-                    m_uiStage = 1;
-                    m_uiSubmergeTimer = 5*IN_MILLISECONDS;
-                } else m_uiSubmergeTimer -= uiDiff;
-
-                DoMeleeAttackIfReady();
-                break;
-            case 1: // Submerge
-                me->SetFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE);
-                DoCast(me,SPELL_SUBMERGE_0);
-                DoScriptText(SAY_SUBMERGE,me);
-                me->GetMotionMaster()->MovePoint(0,ToCCommonLoc[1].GetPositionX()+urand(0,80)-40,ToCCommonLoc[1].GetPositionY()+urand(0,80)-40,ToCCommonLoc[1].GetPositionZ());
-                m_uiStage = 2;
-            case 2: // Wait til emerge
-                if (m_uiSubmergeTimer <= uiDiff)
-                {
-                    m_uiStage = 3;
-                    m_uiSubmergeTimer = 50*IN_MILLISECONDS;
-                } else m_uiSubmergeTimer -= uiDiff;
-                break;
-            case 3: // Emerge
-                me->SetDisplayId(m_uiModelStationary);
-                DoScriptText(SAY_EMERGE,me);
-                me->RemoveAurasDueToSpell(SPELL_SUBMERGE_0);
-                DoCast(me,SPELL_EMERGE_0);
-                me->RemoveFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE);
-                me->SetFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_DISABLE_MOVE);
-                SetCombatMovement(false);
-                me->GetMotionMaster()->MoveIdle();
-                m_uiStage = 4;
-                break;
-            case 4: // Stationary
-                if (m_uiSprayTimer <= uiDiff)
-                {
-                    if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
-                        DoCast(pTarget,m_uiSpraySpell);
-                    m_uiSprayTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-                } else m_uiSprayTimer -= uiDiff;
-
-                if (m_uiSweepTimer <= uiDiff)
-                {
-                    DoCastAOE(SPELL_SWEEP_0);
-                    m_uiSweepTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-                } else m_uiSweepTimer -= uiDiff;
-
-                if (m_uiSubmergeTimer <= uiDiff)
-                {
-                    m_uiStage = 5;
-                    m_uiSubmergeTimer = 10*IN_MILLISECONDS;
-                } else m_uiSubmergeTimer -= uiDiff;
-
-                DoSpellAttackIfReady(m_uiSpitSpell);
-                break;
-            case 5: // Submerge
-                me->SetFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE);
-                DoCast(me,SPELL_SUBMERGE_0);
-                DoScriptText(SAY_SUBMERGE,me);
-                me->GetMotionMaster()->MovePoint(0,ToCCommonLoc[1].GetPositionX()+urand(0,80)-40,ToCCommonLoc[1].GetPositionY()+urand(0,80)-40,ToCCommonLoc[1].GetPositionZ());
-                m_uiStage = 6;
-            case 6: // Wait til emerge
-                if (m_uiSubmergeTimer <= uiDiff)
-                {
-                    m_uiStage = 7;
-                    m_uiSubmergeTimer = 45*IN_MILLISECONDS;
-                } else m_uiSubmergeTimer -= uiDiff;
-                break;
-            case 7: // Emerge
-                me->SetDisplayId(m_uiModelMobile);
-                DoScriptText(SAY_EMERGE,me);
-                me->RemoveAurasDueToSpell(SPELL_SUBMERGE_0);
-                DoCast(me,SPELL_EMERGE_0);
-                me->RemoveFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_NON_ATTACKABLE|UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_NOT_SELECTABLE);
-                me->RemoveFlag(UNIT_FIELD_FLAGS,UNIT_FLAG_DISABLE_MOVE);
-                SetCombatMovement(true);
-                me->GetMotionMaster()->MoveChase(me->getVictim());
-                m_uiStage = 0;
-                break;
-        }
-    }
-};
-
-class boss_acidmaw : public CreatureScript
-{
-    public:
-    boss_acidmaw() : CreatureScript("boss_acidmaw") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new boss_acidmawAI(pCreature);
-    }
-
-    struct boss_acidmawAI : public boss_jormungarAI
-    {
-        boss_acidmawAI(Creature* pCreature) : boss_jormungarAI(pCreature) { }
-
-        void Reset()
-        {
-            boss_jormungarAI::Reset();
-            m_uiBiteSpell = SPELL_PARALYTIC_BITE;
-            m_uiSpewSpell = SPELL_ACID_SPEW;
-            m_uiSpitSpell = SPELL_ACID_SPIT;
-            m_uiSpraySpell = SPELL_PARALYTIC_SPRAY;
-            m_uiModelStationary = MODEL_ACIDMAW_STATIONARY;
-            m_uiModelMobile = MODEL_ACIDMAW_MOBILE;
-            m_uiSisterID = NPC_DREADSCALE;
-
-            m_uiSubmergeTimer = 500;
-            DoCast(me,SPELL_SUBMERGE_0);
-            m_uiStage = 2;
-        }
-    };
-
-};
-
-class boss_dreadscale : public CreatureScript
-{
-public:
-    boss_dreadscale() : CreatureScript("boss_dreadscale") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new boss_dreadscaleAI(pCreature);
-    }
-
-    struct boss_dreadscaleAI : public boss_jormungarAI
-    {
-        boss_dreadscaleAI(Creature* pCreature) : boss_jormungarAI(pCreature) { }
-
-        void Reset()
-        {
-            boss_jormungarAI::Reset();
-            m_uiBiteSpell = SPELL_BURNING_BITE;
-            m_uiSpewSpell = SPELL_MOLTEN_SPEW;
-            m_uiSpitSpell = SPELL_FIRE_SPIT;
-            m_uiSpraySpell = SPELL_BURNING_SPRAY;
-            m_uiModelStationary = MODEL_DREADSCALE_STATIONARY;
-            m_uiModelMobile = MODEL_DREADSCALE_MOBILE;
-            m_uiSisterID = NPC_ACIDMAW;
-
-            m_uiSubmergeTimer = 45*IN_MILLISECONDS;
-            m_uiStage = 0;
-        }
-    };
-
-};
-
-class mob_slime_pool : public CreatureScript
-{
-public:
-    mob_slime_pool() : CreatureScript("mob_slime_pool") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new mob_slime_poolAI(pCreature);
-    }
-
-    struct mob_slime_poolAI : public ScriptedAI
-    {
-        mob_slime_poolAI(Creature *pCreature) : ScriptedAI(pCreature)
-        {
-        }
-
-        bool casted;
-        void Reset()
-        {
-            casted = false;
-            me->SetReactState(REACT_PASSIVE);
-            me->ForcedDespawn(60*IN_MILLISECONDS);
-        }
-
-        void UpdateAI(const uint32 /*uiDiff*/)
-        {
-            if (!casted)
-            {
-                casted = true;
-                DoCast(me,SPELL_SLIME_POOL_EFFECT);
-            }
-        }
-    };
-
-};
-class boss_icehowl : public CreatureScript
-{
-public:
-    boss_icehowl() : CreatureScript("boss_icehowl") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new boss_icehowlAI(pCreature);
-    }
-
-    struct boss_icehowlAI : public ScriptedAI
-    {
-        boss_icehowlAI(Creature* pCreature) : ScriptedAI(pCreature)
-        {
-            m_pInstance = (InstanceScript*)pCreature->GetInstanceScript();
-        }
-
-        InstanceScript* m_pInstance;
-
-        uint32 m_uiFerociousButtTimer;
-        uint32 m_uiArticBreathTimer;
-        uint32 m_uiWhirlTimer;
-        uint32 m_uiMassiveCrashTimer;
-        uint32 m_uiTrampleTimer;
-        float  m_fTrampleTargetX,m_fTrampleTargetY,m_fTrampleTargetZ;
-        uint64 m_uiTrampleTargetGUID;
-        bool   m_bMovementStarted;
-        bool   m_bMovementFinish;
-        bool   m_bTrampleCasted;
-        uint8  m_uiStage;
-        Unit*  pTarget;
-
-        void Reset()
-        {
-            m_uiFerociousButtTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-            m_uiArticBreathTimer = urand(25*IN_MILLISECONDS,40*IN_MILLISECONDS);
-            m_uiWhirlTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-            m_uiMassiveCrashTimer = 30*IN_MILLISECONDS;
-            m_uiTrampleTimer = IN_MILLISECONDS;
-            m_bMovementStarted = false;
-            m_bMovementFinish = false;
-            m_bTrampleCasted = false;
-            m_uiTrampleTargetGUID = 0;
-            m_fTrampleTargetX = 0;
-            m_fTrampleTargetY = 0;
-            m_fTrampleTargetZ = 0;
-            m_uiStage = 0;
-        }
-
-        void JustDied(Unit* /*pKiller*/)
-        {
-            if (m_pInstance)
-                m_pInstance->SetData(TYPE_NORTHREND_BEASTS, ICEHOWL_DONE);
-        }
-
-        void MovementInform(uint32 uiType, uint32 uiId)
-        {
-            if (uiType != POINT_MOTION_TYPE) return;
-
-            switch (uiId)
-            {
-                case 0: // JUMP!? Fuck! THAT'S BEEZARR! Would someone PLEASE make MotionMaster->Move* work better?
-                    if (me->GetDistance2d(ToCCommonLoc[1].GetPositionX(),ToCCommonLoc[1].GetPositionY()) < 6.0f)
-                    {
-                        // Middle of the room
-                        m_uiStage = 1;
-                    }
-                    else
-                    {
-                        // Landed from Hop backwards (start trample)
-                        if (Unit::GetPlayer(*me,m_uiTrampleTargetGUID))
-                        {
-                            m_uiStage = 4;
-                        } else m_uiStage = 6;
-                    }
-                    break;
-                case 1: // Finish trample
-                    m_bMovementFinish = true;
-                    break;
-            }
-        }
-
-        void JustReachedHome()
-        {
-            if (m_pInstance)
-                m_pInstance->SetData(TYPE_NORTHREND_BEASTS, FAIL);
-            me->ForcedDespawn();
-        }
-
-        void KilledUnit(Unit *pWho)
-        {
-            if (pWho->GetTypeId() == TYPEID_PLAYER)
-            {
-                if (m_pInstance)
-                    m_pInstance->SetData(DATA_TRIBUTE_TO_IMMORTALITY_ELEGIBLE, 0);
-            }
-        }
-
-        void EnterCombat(Unit* /*pWho*/)
-        {
-            if (m_pInstance)
-                m_pInstance->SetData(TYPE_NORTHREND_BEASTS, ICEHOWL_IN_PROGRESS);
-            me->SetInCombatWithZone();
-        }
-
-        void SpellHitTarget(Unit* target, const SpellEntry* spell)
-        {
-            if (spell->Id == SPELL_TRAMPLE && target->GetTypeId() == TYPEID_PLAYER)
-            {
-                if (!m_bTrampleCasted)
-                {
-                    DoCast(me, SPELL_FROTHING_RAGE, true);
-                    m_bTrampleCasted = true;
-                }
-            }
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            switch (m_uiStage)
-            {
-                case 0:
-                    if (m_uiFerociousButtTimer <= uiDiff)
-                    {
-                        DoCastVictim(SPELL_FEROCIOUS_BUTT);
-                        m_uiFerociousButtTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-                    } else m_uiFerociousButtTimer -= uiDiff;
-
-                    if (m_uiArticBreathTimer <= uiDiff)
-                    {
-                        if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
-                            DoCast(pTarget,SPELL_ARCTIC_BREATH);
-                        m_uiArticBreathTimer = urand(25*IN_MILLISECONDS,40*IN_MILLISECONDS);
-                    } else m_uiArticBreathTimer -= uiDiff;
-
-                    if (m_uiWhirlTimer <= uiDiff)
-                    {
-                        DoCastAOE(SPELL_WHIRL);
-                        m_uiWhirlTimer = urand(15*IN_MILLISECONDS,30*IN_MILLISECONDS);
-                    } else m_uiWhirlTimer -= uiDiff;
-
-                    if (m_uiMassiveCrashTimer <= uiDiff)
-                    {
-                        me->GetMotionMaster()->MoveJump(ToCCommonLoc[1].GetPositionX(),ToCCommonLoc[1].GetPositionY(),ToCCommonLoc[1].GetPositionZ(),10.0f,20.0f); // 1: Middle of the room
-                        m_uiStage = 7; //Invalid (Do nothing more than move)
-                        m_uiMassiveCrashTimer = 30*IN_MILLISECONDS;
-                    } else m_uiMassiveCrashTimer -= uiDiff;
-
-                    DoMeleeAttackIfReady();
-                    break;
-                case 1:
-                    DoCastAOE(SPELL_MASSIVE_CRASH);
-                    m_uiStage = 2;
-                    break;
-                case 2:
-                    if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
-                    {
-                        m_uiTrampleTargetGUID = pTarget->GetGUID();
-                        me->SetUInt64Value(UNIT_FIELD_TARGET, m_uiTrampleTargetGUID);
-                        DoScriptText(SAY_TRAMPLE_STARE,me,pTarget);
-                        m_bTrampleCasted = false;
-                        SetCombatMovement(false);
-                        me->GetMotionMaster()->MoveIdle();
-                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                        m_uiTrampleTimer = 4*IN_MILLISECONDS;
-                        m_uiStage = 3;
-                    } else m_uiStage = 6;
-                    break;
-                case 3:
-                    if (m_uiTrampleTimer <= uiDiff)
-                    {
-                        if (Unit* pTarget = Unit::GetPlayer(*me,m_uiTrampleTargetGUID))
-                        {
-                            m_bTrampleCasted = false;
-                            m_bMovementStarted = true;
-                            m_fTrampleTargetX = pTarget->GetPositionX();
-                            m_fTrampleTargetY = pTarget->GetPositionY();
-                            m_fTrampleTargetZ = pTarget->GetPositionZ();
-                            me->GetMotionMaster()->MoveJump(2*me->GetPositionX()-m_fTrampleTargetX,
-                                2*me->GetPositionY()-m_fTrampleTargetY,
-                                me->GetPositionZ(),
-                                10.0f,20.0f); // 2: Hop Backwards
-                            m_uiStage = 7; //Invalid (Do nothing more than move)
-                        } else m_uiStage = 6;
-                    } else m_uiTrampleTimer -= uiDiff;
-                    break;
-                case 4:
-                    DoScriptText(SAY_TRAMPLE_START,me);
-                    me->GetMotionMaster()->MoveCharge(m_fTrampleTargetX,m_fTrampleTargetY,m_fTrampleTargetZ+2, 42, 1);
-                    me->SetUInt64Value(UNIT_FIELD_TARGET, 0);
-                    m_uiStage = 5;
-                    break;
-                case 5:
-                    if (m_bMovementFinish)
-                    {
-                        if (m_uiTrampleTimer <= uiDiff) DoCastAOE(SPELL_TRAMPLE);
-                        m_bMovementFinish = false;
-                        m_uiStage = 6;
-                        return;
-                    }
-                    if (m_uiTrampleTimer <= uiDiff)
-                    {
-                        Map::PlayerList const &lPlayers = me->GetMap()->GetPlayers();
-                        for (Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
-                        {
-                            if (Unit* pPlayer = itr->getSource())
-                                if (pPlayer->isAlive() && pPlayer->IsWithinDistInMap(me, 6.0f))
-                                {
-                                    DoCastAOE(SPELL_TRAMPLE);
-                                    m_uiTrampleTimer = IN_MILLISECONDS;
-                                    break;
-                                }
-                        }
-                    } else m_uiTrampleTimer -= uiDiff;
-                    break;
-                case 6:
-                    if (!m_bTrampleCasted)
-                    {
-                        DoCast(me,SPELL_STAGGERED_DAZE);
-                        DoScriptText(SAY_TRAMPLE_FAIL,me);
-                    }
-                    m_bMovementStarted = false;
-                    me->GetMotionMaster()->MovementExpired();
-                    me->GetMotionMaster()->MoveChase(me->getVictim());
-                    SetCombatMovement(true);
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                    m_uiStage = 0;
-                    break;
-            }
-        }
-    };
-
-};
-
-
-void AddSC_boss_northrend_beasts()
-{
-    new boss_gormok();
-    new mob_snobold_vassal();
-    new boss_acidmaw();
-    new boss_dreadscale();
-    new mob_slime_pool();
-    new boss_icehowl();
-}
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
 
 /*
 *Need implantet Tentacle stalker
@@ -65,12 +65,14 @@
     SPELL_MALLEABLE_GOO         = 72296,
     SPELL_MUTATED_PLAGUE        = 72672,
     SPELL_OOZE_ERUPTION         = 70492,
-    SPELL_VOLATILE_OOZE         = 72838,
+    SPELL_VOLATILE_OOZE         = 70447,
     SPELL_CHOKING_GAS           = 71278,
     SPELL_SLIME_PUDDLE          = 70341,
     SPELL_SLIME_PUDDLE_AURA     = 70346,
     SPELL_CHOKING_GAS_EXPLOSION = 71279,
     SPELL_CHOKING_GAS_BOMB      = 71273,
+    SPELL_CHOKING_GAS_BOMB_1    = 71275,
+    SPELL_CHOKING_GAS_BOMB_2    = 71276,
     SPELL_CHOKING_GAS_AURA      = 71278,
     SPELL_SUMMON_OOZE           = 71413,
     SPELL_GASEOUS_BLOAT         = 70215,
@@ -108,8 +110,6 @@
     {4486.825f, 3213.452f, 389.385f, 0.0f}
 };
 
-static const uint32 gaseousBlight[3]        = {69157, 69162, 69164};
-
 class boss_professor_putricide : public CreatureScript
 {
     public:
@@ -143,7 +143,6 @@
                 count = RAID_MODE(1,2,1,2);
 
                 fBaseSpeed = me->GetSpeedRate(MOVE_RUN);
-                SetSonPhase(PHASE_READY);
 
                 if (pInstance && me->isAlive())
                     pInstance->SetData(DATA_PROFESSOR_PUTRICIDE_EVENT, NOT_STARTED);
@@ -224,17 +223,10 @@
                         break;
                     case ACTION_FESTERGUT_GAS:
                         DoScriptText(SAY_FESTERGUT_GASEOUS_BLIGHT, me);
-                        if (Creature* bfestergut = Unit::GetCreature(*me, instance->GetData64(DATA_FESTERGUT)))
+                         if (Creature* bfestergut = Unit::GetCreature(*me, instance->GetData64(DATA_FESTERGURT)))
                         {
                             bfestergut->CastSpell(bfestergut, SPELL_RELEASE_GAS_VISUAL, false, NULL, NULL, me->GetGUID());
                         }
-                        if (Creature* gasDummy = GetClosestCreatureWithEntry(me, CREATURE_ORANGE_GAS_STALKER, 500.0f, true))
-                        {
-                            for (uint8 i = 0; i < 3; ++i)
-                            {
-                                gasDummy->CastSpell(gasDummy,gaseousBlight[i], true);
-                            }
-                        }
                         break;
                     //case ACTION_ROTFACE_GAS:
                     case ACTION_FESTERGUT_DEATH:
@@ -319,83 +311,71 @@
                         m_uiPhaseSwitchTimer = 9000;
                         break;
                     case 2:
-                    {
                         if(m_uiPhase == 1)
-                        {
                             DoCast(SPELL_CREATE_CONCOTION);
-                        }
                         if(m_uiPhase == 2)
-                        {
                             DoCast(SPELL_GUZZLE_POTIONS);
-                        }
+                        ++phaseswitch;
                         m_uiPhaseSwitchTimer = 3000;
-                        ++phaseswitch;
-                    }
-                    break;
+                        break;
                     case 3:
+                        if(m_uiPhase == 1)
+                            m_uiPhase = 2;
+                        if(m_uiPhase == 2)
+                            m_uiPhase = 3;
                         pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_TEAR_GAS);
                         ++phaseswitch;
-                        m_uiPhase = 2;
                         break;
                     }
             }
 
             void UpdateAI(const uint32 uiDiff)
             {
-                if (phase == PHASE_READY)
-                    return;
+                if(phase == PHASE_FESTERGUT)
+                {
+                    if (m_uiMalleableGooTimer < uiDiff)
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            DoCast(pTarget, SPELL_MALLABLE_GOO_H);
+                        m_uiMalleableGooTimer = urand(16000, 20000);
+                    } else m_uiMalleableGooTimer -= uiDiff;
 
-                if(phase != PHASE_COMBAT)
+                    if (m_uiSayDieTimer < uiDiff)
+                    {
+                        if(fDie)
+                        {
+                            DoScriptText(SAY_FESTERGUT_DEATH, me);
+                            EnterEvadeMode();
+                            fDie = false;
+                        }
+                        m_uiSayDieTimer = 4000;
+                    } else m_uiSayDieTimer -= uiDiff;
+                }
+
+                if(phase == PHASE_ROTFACE)
                 {
-                    if(phase == PHASE_FESTERGUT)
+                    if (m_uiVileGasTimer < uiDiff)
                     {
-                        if (m_uiMalleableGooTimer < uiDiff)
+                        for (uint8 i = 1; i <= 3; i++)
                         {
-                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                                DoCast(pTarget, SPELL_MALLABLE_GOO_H);
-                            m_uiMalleableGooTimer = urand(16000, 20000);
-                        } else m_uiMalleableGooTimer -= uiDiff;
+                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            {
+                                DoCast(pTarget, SPELL_VILE_GAS);
+                            }
+                        }
+                        m_uiVileGasTimer = urand (16000, 20000);
+                    } else m_uiVileGasTimer -= uiDiff;
 
-                        if (m_uiSayDieTimer < uiDiff)
+                    if (m_uiSayDieTimer < uiDiff)
+                    {
+                        if(rDie)
                         {
-                            if(fDie)
-                            {
-                                DoScriptText(SAY_FESTERGUT_DEATH, me);
-                                me->GetMotionMaster()->MovePoint(0, professorStartPos);
-                                SetSonPhase(PHASE_READY);
-                                fDie = false;
-                            }
+                            DoScriptText(SAY_ROTFACE_DEATH, me);
                             EnterEvadeMode();
-                            m_uiSayDieTimer = 4000;
-                        } else m_uiSayDieTimer -= uiDiff;
-                    }
-                    else if(phase == PHASE_ROTFACE)
-                    {
-                        if (m_uiVileGasTimer < uiDiff)
-                        {
-                            for (uint8 i = 1; i <= 3; i++)
-                            {
-                                if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                                {
-                                    DoCast(pTarget, SPELL_VILE_GAS);
-                                }
-                            }
-                            m_uiVileGasTimer = urand (16000, 20000);
-                        } else m_uiVileGasTimer -= uiDiff;
-
-                        if (m_uiSayDieTimer < uiDiff)
-                        {
-                            if(rDie)
-                            {
-                                DoScriptText(SAY_ROTFACE_DEATH, me);
-                                me->GetMotionMaster()->MovePoint(0, professorStartPos);
-                                SetSonPhase(PHASE_READY);
-                                rDie = false;
-                            }
-                            EnterEvadeMode();
-                            m_uiSayDieTimer = 4000;
-                        } else m_uiSayDieTimer -= uiDiff;
-                    }
+                            rDie = false;
+                        }
+                        m_uiSayDieTimer = 4000;
+                    } else m_uiSayDieTimer -= uiDiff;
                 }
 
                 if(phase == PHASE_COMBAT)
@@ -424,9 +404,7 @@
                         for (uint8 i = 1; i <= count; i++)
                         {
                             if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                            {
-                                DoCast(pTarget, SPELL_SLIME_PUDDLE);
-                            }
+                                DoCast(pTarget, SPELL_SLIME_PUDDLE, true);
                         }
                         m_uiPuddleTimer = 19000;
                     } else m_uiPuddleTimer -= uiDiff;
@@ -454,16 +432,16 @@
 
                         if (m_uiMalleableTimer < uiDiff)
                         {
-                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_FARTHEST, 1))
-                            {
+                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
                                 DoCast(pTarget, SPELL_MALLEABLE_GOO);
-                                m_uiMalleableTimer = 16000;
-                            }
+                            m_uiMalleableTimer = 16000;
                         } else m_uiMalleableTimer -= uiDiff;
 
                         if (m_uiBombTimer < uiDiff)
                         {
                             DoCast(SPELL_CHOKING_GAS_BOMB);
+                            DoCast(SPELL_CHOKING_GAS_BOMB_1);
+                            DoCast(SPELL_CHOKING_GAS_BOMB_2);
                             m_uiBombTimer = 21000;
                         } else m_uiBombTimer -= uiDiff;
                     }
@@ -476,11 +454,9 @@
 
                         if (m_uiMalleableTimer < uiDiff)
                         {
-                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_FARTHEST,1))
-                            {
+                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
                                 DoCast(pTarget, SPELL_MALLEABLE_GOO);
-                                m_uiMalleableTimer = 16000;
-                            }
+                            m_uiMalleableTimer = 16000;
                         } else m_uiMalleableTimer -= uiDiff;
 
                         if (m_uiBombTimer < uiDiff)
@@ -736,7 +712,7 @@
             {
                 if (m_uiGrabTimer < uiDiff)
                 {
-                    if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                    Unit* target = SelectUnit(SELECT_TARGET_NEAREST, 0);
                     {
                         if(target && !bVehicle && target->IsFriendlyTo(me))
                         {
@@ -769,4 +745,4 @@
     new npc_gas_cloud_icc();
     new npc_bomb_icc();
     new npc_abomination();
-}
\ No newline at end of file
+}
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
@@ -88,6 +88,7 @@
     DATA_SPINESTALKER,
     DATA_RIMEFANG,
     DATA_LICH_KING,
+	DATA_FESTERGURT,
     DATA_SAURFANG_EVENT_NPC,
 
     COMMAND_FAIL_BONED
diff --git a/src/server/scripts/Northrend/icecrown.cpp b/src/server/scripts/Northrend/icecrown.cpp
index a2bab9d5a1b047e443b02087e120e5e85dc9b798..c5fe7ed922993a0c69df5dff428d74dda5e5b437
GIT binary patch
literal 93648
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

diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
--- a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
@@ -1,2129 +1,2129 @@
-/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
- */
-
-#include "OutdoorPvPWG.h"
-#include "SpellAuras.h"
-#include "Vehicle.h"
-#include "ObjectMgr.h"
-#include "World.h"
-#include "Chat.h"
-#include "MapManager.h"
-#include "ScriptedCreature.h"
-#include "ScriptPCH.h"
-
-Creature* FortressSpirit;
-uint32 entry;
-uint32 guide_entry;
-uint32 guide_entry_fortress_horde;
-uint32 guide_entry_fortress_alliance;
-
-OutdoorPvPWG::OutdoorPvPWG()
-{
-    m_TypeId = OUTDOOR_PVP_WG;
-    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
-}
-
-void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
-{
-    while((*pair)[0])
-    {
-        pairMap[(*pair)[0]] = (*pair)[1];
-        pairMap[(*pair)[1]] = (*pair)[0];
-        ++pair;
-    }
-}
-
-void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
-{
-    if (cr)
-    {
-        cr->SetOriginalEntry(entry);
-        if (entry != cr->GetEntry() || !cr->isAlive())
-            cr->Respawn(true);
-        cr->SetVisibility(VISIBILITY_ON);
-    }
-}
-
-bool OutdoorPvPWG::SetupOutdoorPvP()
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-    {
-        sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
-        return false;
-    }
-
-    //load worlstates
-    QueryResult result = CharacterDatabase.PQuery("SELECT `entry`, `value` from `worldstates` where `entry` in ('31001','31002','31003') order by `entry`");
-    
-    m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
-
-    if (result)
-    {
-        do
-        {
-            Field *fields = result->Fetch();
-            switch (fields[0].GetUInt32())
-            {
-                case 31001:
-                    m_wartime = fields[1].GetBool();
-                    break;
-                case 31002:
-                    m_timer = fields[1].GetUInt32();
-                    break;
-                case 31003:
-                    m_defender = TeamId(fields[1].GetUInt32());
-                    break;
-            }
-        }while(result->NextRow());
-    }
-    else
-    {
-        m_wartime = false;
-        m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
-        m_defender = TeamId(rand()%2);
-    }
-
-    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
-    m_changeDefender = false;
-    m_workshopCount[TEAM_ALLIANCE] = 0;
-    m_workshopCount[TEAM_HORDE] = 0;
-    m_tenacityStack = 0;
-    m_gate = NULL;
-
-    std::list<uint32> engGuids;
-    std::list<uint32> spiritGuids;
-
-    // Store Eng, spirit guide guids and questgiver for later use
-    result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
-         " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
-         CRE_ENG_A, CRE_ENG_H, CRE_SPI_A, CRE_SPI_H, 31101, 31051, 31102, 31052,
-         31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
-    if (!result)
-        sLog.outError("Cannot find siege workshop master or spirit guides in creature!");
-    else
-    {
-        do
-        {
-            Position posHorde, posAlli;
-            Field *fields = result->Fetch();
-            switch(fields[1].GetUInt32())
-            {
-                case CRE_ENG_A:
-                case CRE_ENG_H:
-                    engGuids.push_back(fields[0].GetUInt32());
-                    break;
-                case CRE_SPI_A:
-                case CRE_SPI_H:
-                    spiritGuids.push_back(fields[0].GetUInt32());
-                    break;
-                case 31051:
-                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
-                    posAlli.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31101:
-                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
-                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31052:
-                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
-                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31102:
-                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
-                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31109:
-                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
-                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31107:
-                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
-                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31153:
-                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
-                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31151:
-                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
-                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31108:
-                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
-                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31106:
-                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
-                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31054:
-                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
-                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31053:
-                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
-                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31036:
-                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
-                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31091:
-                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
-                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                default:
-                    break;
-            }
-        }while(result->NextRow());
-    }
-
-    // Select POI
-    AreaPOIList areaPOIs;
-    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
-    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
-    {
-        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
-        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
-        {
-            areaPOIs.push_back(poiInfo);
-            if (minX > poiInfo->x) minX = poiInfo->x;
-            if (minY > poiInfo->y) minY = poiInfo->y;
-            if (maxX < poiInfo->x) maxX = poiInfo->x;
-            if (maxY < poiInfo->y) maxY = poiInfo->y;
-        }
-    }
-    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
-
-    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
-    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
-        " WHERE gameobject.map=571"
-        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
-        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
-        " AND gameobject_template.type=33"
-        " AND gameobject.id=gameobject_template.entry",
-        minX, minY, maxX, maxY);
-    if (!result)
-        return false;
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        uint32 guid = fields[0].GetUInt32();
-        GameObjectData const * goData = sObjectMgr.GetGOData(guid);
-        if (!goData) // this should not happen
-            continue;
-
-        float x = goData->posX, y = goData->posY;
-        float minDist = 100;
-        AreaPOIList::iterator poi = areaPOIs.end();
-        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
-        {
-            if (!(*itr)->icon[1]) // note: may for other use
-                continue;
-
-            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
-            if (minDist > dist)
-            {
-                minDist = dist;
-                poi = itr;
-            }
-        }
-
-        if (poi == areaPOIs.end())
-            continue;
-
-        // add building to the list
-        TeamId teamId = x > POS_X_CENTER ? getDefenderTeam() : getAttackerTeam();
-        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
-        if ((*poi)->id == 2246)
-            m_gate = m_buildingStates[guid];
-        areaPOIs.erase(poi);
-
-        // add capture point
-        uint32 capturePointEntry = 0;
-
-        switch(goData->id)
-        {    
-            //West Goblin Workshops
-            case 192028: // NW
-            case 192030: // W
-            case 192032: // SW
-                capturePointEntry = 190475;
-                break;
-            //East Goblin Workshops
-            case 192029: // NE
-            case 192031: // E
-            case 192033: // SE
-                capturePointEntry = 190487;
-                break;
-        }
-
-        if (capturePointEntry)
-        {
-            uint32 engGuid = 0;
-            uint32 spiritGuid = 0;
-            // Find closest Eng to Workshop
-            float minDist = 100;
-            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
-            {
-                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
-                if (!creData)
-                    continue;
-
-                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
-                if (minDist > dist)
-                {
-                    minDist = dist;
-                    engGuid = *itr;
-                }
-            }
-
-            if (!engGuid)
-            {
-                sLog.outError("Cannot find nearby siege workshop master!");
-                continue;
-            }
-            else
-                engGuids.remove(engGuid);
-            // Find closest Spirit Guide to Workshop
-            minDist = 255;
-            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
-            {
-                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
-                if (!creData)
-                    continue;
-
-                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
-                if (minDist > dist)
-                {
-                    minDist = dist;
-                    spiritGuid = *itr;
-                }
-            }
-
-            // Inside fortress won't be capturable
-            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
-            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
-            {
-                delete workshop;
-                sLog.outError("Cannot add capture point!");
-                continue;
-            }
-
-            const CreatureData *creData = sObjectMgr.GetCreatureData(engGuid);
-            if (!creData)
-                continue;
-
-            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
-            const_cast<CreatureData*>(creData)->displayid = 0;
-            workshop->m_engGuid = engGuid;
-
-            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
-            if (spiritGuid)
-            {
-                spiritGuids.remove(spiritGuid);
-
-                const CreatureData *spiritData = sObjectMgr.GetCreatureData(spiritGuid);
-                if (!spiritData)
-                    continue;
-
-                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
-                const_cast<CreatureData*>(spiritData)->displayid = 0;
-                workshop->m_spiGuid = spiritGuid;
-            }
-            else
-                workshop->m_spiGuid = 0;
-            workshop->m_workshopGuid = guid;
-            AddCapturePoint(workshop);
-            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
-            workshop->SetTeamByBuildingState();
-        }
-    }while(result->NextRow());
-
-    engGuids.clear();
-    spiritGuids.clear();
-
-    if (!m_gate)
-    {
-        sLog.outError("Cannot find wintergrasp fortress gate!");
-        return false;
-    }
-
-    // Load Graveyard
-    GraveYardMap::const_iterator graveLow  = sObjectMgr.mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
-    GraveYardMap::const_iterator graveUp   = sObjectMgr.mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
-    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
-    {
-        if ((*itr)->icon[1] == 8)
-        {
-            // find or create grave yard
-            const WorldSafeLocsEntry *loc = sObjectMgr.GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
-            if (!loc)
-            {
-                ++itr;
-                continue;
-            }
-
-            GraveYardMap::const_iterator graveItr;
-            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
-                if (graveItr->second.safeLocId == loc->ID)
-                    break;
-            if (graveItr == graveUp)
-            {
-                GraveYardData graveData;
-                graveData.safeLocId = loc->ID;
-                graveData.team = 0;
-                graveItr = sObjectMgr.mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
-            }
-
-            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
-            {
-                if (stateItr->second->worldState == (*itr)->worldState)
-                {
-                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
-                    break;
-                }
-            }
-            areaPOIs.erase(itr++);
-        }
-        else
-            ++itr;
-    }
-
-    //Titan Relic
-    sObjectMgr.AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
-
-    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
-    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
-
-    sWorld.SendWintergraspState();
-    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
-    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
-    m_towerDamagedCount[TEAM_HORDE] = 0;
-    m_towerDestroyedCount[TEAM_HORDE] = 0;
-
-    RemoveOfflinePlayerWGAuras();
-
-    RegisterZone(ZONE_WINTERGRASP);
-
-    if (m_wartime)
-    {
-        uint32 m_WSTimer = m_timer;
-        StartBattle();
-        m_timer = m_WSTimer;
-    }
-
-    return true;
-}
-
-void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
-{	
-    if (obj->GetEntry() == 192829) // Titan Relic
-    {
-        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && m_gate && m_gate->damageState == DAMAGE_DESTROYED)
-        {
-            m_changeDefender = true;
-            m_timer = 0;
-        }
-    }
-    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
-        if (itr == m_buildingStates.end())
-            return;
-
-        std::string msgStr;
-        switch(eventId)
-        { // TODO - Localized msgs of GO names
-            case 19672: case 19675: // Flamewatch Tower
-                msgStr = "Flamewatch";
-                break;
-            case 18553: case 19677: // Shadowsight Tower
-                msgStr = "Shadowsight";
-                break;
-            case 19673: case 19676: // Winter's Edge Tower
-                msgStr = "Winter's Edge";
-                break;
-            case 19776: case 19778: // E Workshop damaged
-                msgStr = "Sunken Ring";
-                break;
-            case 19777: case 19779: // W Workshop damaged
-                msgStr = "Broken Temple";
-                break;
-            case 19782: case 19786: // NW Workshop damaged
-                msgStr = "north-western";
-                break;
-            case 19783: case 19787: // NE Workshop damaged
-                msgStr = "north-eastern";
-                break;
-            case 19784: case 19788: // SW Workshop damaged
-                msgStr = "Westpark";
-                break;
-            case 19785: case 19789: // SE Workshop damaged
-                msgStr = "Eastpark";
-                break;
-            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
-                msgStr = "north-western";
-                break;
-            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
-                msgStr = "north-eastern";
-                break;
-            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
-                msgStr = "south-western";
-                break;
-            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
-                msgStr = "south-eastern";
-                break;
-            default:
-                msgStr = "";
-        }
-
-        BuildingState *state = itr->second;
-        if (eventId == obj->GetGOInfo()->building.damagedEvent)
-        {
-            state->damageState = DAMAGE_DAMAGED;
-            switch(state->type)
-            {
-                case BUILDING_WORKSHOP:
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-                    break;
-                case BUILDING_WALL:
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
-	           for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
-	                  }
-                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
-	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
-	                  (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                  }
-		break;
-                case BUILDING_TOWER:
-                    ++m_towerDamagedCount[state->GetTeam()];
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-			   for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                  }
-                     else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                  }
-                    break;
-            }
-        }
-        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
-        {
-            state->damageState = DAMAGE_DESTROYED;
-
-            switch(state->type)
-            {
-                case BUILDING_WORKSHOP:
-                    ModifyWorkshopCount(state->GetTeam(), false);
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-                    break;
-                case BUILDING_WALL:
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
-			    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                  }
-                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-		          (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                  }
-                    break;
-                case BUILDING_TOWER:
-                    --m_towerDamagedCount[state->GetTeam()];
-                    ++m_towerDestroyedCount[state->GetTeam()];
-                    if (state->GetTeam() == getAttackerTeam())
-                    {
-                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
-                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
-                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
-
-                        if (m_towerDestroyedCount[getAttackerTeam()])
-                        {
-                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                                if ((*itr)->getLevel() > 74)
-                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
-                        }
-
-                        if (attStack)
-                        {
-                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                                if ((*itr)->getLevel() > 74)
-                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
-                        }
-                        else
-                        {
-                            if (m_timer < 600000)
-                                m_timer = 0;
-                            else
-                                m_timer = m_timer - 600000; // - 10 mins
-                        }
-                    }
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-	    	    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
-	                  }
-                    else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
-	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
-			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
-                  }
-                    break;
-            }
-            BroadcastStateChange(state);
-        }
-    }
-}
-
-void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
-{
-    // if server crashed while in battle there could be players with rank or tenacity
-    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
-        SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
-}
-
-void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
-{
-    if (team == TEAM_NEUTRAL)
-        return;
-
-    if (add)
-        ++m_workshopCount[team];
-    else if (m_workshopCount[team])
-        --m_workshopCount[team];
-    else
-        sLog.outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
-
-    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
-}
-
-uint32 OutdoorPvPWG::GetCreatureEntry(uint32 guidlow, const CreatureData *data)
-{
-    if (getDefenderTeam() == TEAM_ALLIANCE)
-    {
-        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
-        if (itr != m_creEntryPair.end())
-        {
-            const_cast<CreatureData*>(data)->displayid = 0;
-            return itr->second;
-        }
-    }
-    return data->id;
-}
-
-OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
-{
-    // VEHICLES, GUARDS and TURRETS gives kill credit
-    // OTHER Not in wartime
-    // TURRET Only during wartime
-    // SPECIAL like "OTHER" but no despawn conditions
-    // Entries like Case A: Case: B have their own despawn function
-    switch(entry)
-    {
-        case 27881: // Catapult
-        case 28094: // Demolisher
-        case 28312: // Alliance Siege Engine
-        case 32627: // Horde Siege Engine
-        case 28319: // Siege turret
-        case 32629: // Siege turret
-            return CREATURE_SIEGE_VEHICLE;
-        case 28366: // Wintergrasp Tower cannon
-            return CREATURE_TURRET;
-        case CRE_ENG_A: // Alliance Engineer
-        case CRE_ENG_H: // Horde Engineer
-            return CREATURE_ENGINEER;
-        case 30739:case 30740: // Champions
-        case 32307:case 32308: // Guards
-            return CREATURE_GUARD;
-        case CRE_SPI_A: // Dwarven Spirit Guide
-        case CRE_SPI_H: // Taunka Spirit Guide
-            return CREATURE_SPIRIT_GUIDE;
-        case 6491: // Spirit Healers
-            return CREATURE_SPIRIT_HEALER;
-        case 31101:case 31051: // Hoodoo Master & Sorceress
-        case 31102:case 31052: // Vieron Blazefeather & Bowyer
-        case 31107:case 31109: // Lieutenant & Senior Demolitionist
-        case 31151:case 31153: // Tactical Officer
-        case 31106:case 31108: // Siegesmith & Siege Master
-        case 31053:case 31054: // Primalist & Anchorite
-        case 31091:case 31036: // Commander
-            return CREATURE_QUESTGIVER;
-        case 32615:case 32626: // Warbringer && Brigadier General
-        case 32296:case 32294: // Quartermaster
-        case 39173:case 39172: // Ros'slai && Marshal Magruder
-        case 30870:case 30869: // Flight Masters
-            return CREATURE_SPECIAL;
-        default:
-            return CREATURE_OTHER; // Revenants, Elementals, etc
-    }
-}
-
-void OutdoorPvPWG::OnCreatureCreate(Creature *creature, bool add)
-{
-    uint32 entry = creature->GetEntry();
-    switch(GetCreatureType(entry))
-    {
-        case CREATURE_SIEGE_VEHICLE:
-        {
-            if (!creature->isSummon())
-                return;
-
-            TeamId team;
-            if (add)
-            {
-                if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
-                    team = TEAM_ALLIANCE;
-                else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
-                    team = TEAM_HORDE;
-                else
-                    return;
-
-                if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
-                {
-                    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
-                    {
-                        if (CanBuildVehicle(workshop))
-                        {
-                            m_vehicles[team].insert(creature);
-                            //workshop->m_vehicles.insert(creature);
-                        }
-                        else
-                        {
-                            creature->setDeathState(DEAD);
-                            creature->SetRespawnTime(DAY);
-                            return;
-                        }
-                    }
-                }
-
-                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
-                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
-                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
-                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
-            }
-            else // the faction may be changed in uncharm
-            {
-                // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
-                if (m_vehicles[TEAM_ALLIANCE].erase(creature))
-                    team = TEAM_ALLIANCE;
-                else if (m_vehicles[TEAM_HORDE].erase(creature))
-                    team = TEAM_HORDE;
-                else
-                    return;
-            }
-            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
-            break;
-        }
-        case CREATURE_QUESTGIVER:
-            if (add)
-                m_questgivers[creature->GetDBTableGUIDLow()] = creature;
-            else
-                m_questgivers.erase(creature->GetDBTableGUIDLow());
-            break;
-        case CREATURE_ENGINEER:
-            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-            {
-                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
-                    {
-                        workshop->m_engineer = add ? creature : NULL;
-                        break;
-                    }
-            }
-            break;
-        case CREATURE_SPIRIT_GUIDE:
-            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-            {
-                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
-                    {
-                        workshop->m_spiritguide = add ? creature : NULL;
-                        break;
-                    }
-            }
-            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
-        case CREATURE_SPIRIT_HEALER:
-        case CREATURE_TURRET:
-        case CREATURE_OTHER:
-            if (add)
-                UpdateCreatureInfo(creature);
-        default:
-            if (add)
-                m_creatures.insert(creature);
-            else
-                m_creatures.erase(creature);
-            break;
-    }
-}
-
-void OutdoorPvPWG::OnGameObjectCreate(GameObject *go, bool add)
-{
-    OutdoorPvP::OnGameObjectCreate(go, add);
-
-    if (UpdateGameObjectInfo(go))
-    {
-        if (add) m_gobjects.insert(go);
-        else m_gobjects.erase(go);
-    }
-    //do we need to store building?
-    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
-        if (itr != m_buildingStates.end())
-        {
-            itr->second->building = add ? go : NULL;
-            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
-                itr->second->type = BUILDING_TOWER;
-            if (!add || itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
-            {
-                itr->second->health = go->GetGOValue()->building.health;
-                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-            }
-            else
-            {
-                go->GetGOValue()->building.health = itr->second->health;
-                if (itr->second->damageState == DAMAGE_DAMAGED)
-                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-                else if (itr->second->damageState == DAMAGE_DESTROYED)
-                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-            }
-        }
-    }
-}
-
-void OutdoorPvPWG::UpdateAllWorldObject()
-{
-    // update cre and go factions
-    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
-        UpdateGameObjectInfo(*itr);
-    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
-        UpdateCreatureInfo(*itr);
-    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
-        UpdateQuestGiverPosition((*itr).first, (*itr).second);
-
-    // rebuild and update building states
-    RebuildAllBuildings();
-
-    // update capture points
-    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-            workshop->SetTeamByBuildingState();
-}
-
-void OutdoorPvPWG::RebuildAllBuildings()
-{
-    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
-    {
-        if (itr->second->building)
-        {
-            UpdateGameObjectInfo(itr->second->building);
-            itr->second->building->Rebuild();
-            itr->second->health = itr->second->building->GetGOValue()->building.health;
-        }
-        else
-            itr->second->health = 0;
-
-        if (itr->second->damageState == DAMAGE_DESTROYED)
-        {
-            if (itr->second->type == BUILDING_WORKSHOP)
-                ModifyWorkshopCount(itr->second->GetTeam(), true);
-        }
-
-        itr->second->damageState = DAMAGE_INTACT;
-        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
-    }
-    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
-    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
-    m_towerDamagedCount[TEAM_HORDE] = 0;
-    m_towerDestroyedCount[TEAM_HORDE] = 0;
-}
-
-void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
-{
-    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
-    data << uint32(571);
-    data << uint32(ZONE_WINTERGRASP);
-    data << uint32(0);
-    data << uint16(4+2+4+m_buildingStates.size());
-
-    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
-    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
-
-    for (uint32 i = 0; i < 2; ++i)
-        data << ClockWorldState[i] << m_clock[i];
-
-    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
-    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
-    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
-    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
-
-    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
-        itr->second->FillData(data);
-
-    if (player)
-        player->GetSession()->SendPacket(&data);
-    else
-        BroadcastPacket(data);
-}
-
-void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
-{
-    if (m_sendUpdate)
-        for (uint32 team = 0; team < 2; ++team)
-            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
-                state->SendUpdate(*p_itr);
-}
-
-// Called at Start and Battle End
-bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
-{
-    if (!creature)
-        return false;
-    uint32 entry = creature->GetEntry();
-    switch(GetCreatureType(entry))
-    {
-        case CREATURE_TURRET:
-            if (isWarTime())
-            {
-                if (!creature->isAlive())
-                    creature->Respawn(true);
-                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
-                creature->SetVisibility(VISIBILITY_ON);
-            }
-            else
-            {
-                if (creature->IsVehicle() && creature->GetVehicleKit())
-                    creature->GetVehicleKit()->RemoveAllPassengers();
-                creature->SetVisibility(VISIBILITY_OFF);
-                creature->setFaction(35);
-            }
-            return false;
-        case CREATURE_OTHER:
-            if (isWarTime())
-            {
-                creature->SetVisibility(VISIBILITY_OFF);
-                creature->setFaction(35);
-            }
-            else
-            {
-                creature->RestoreFaction();
-                creature->SetVisibility(VISIBILITY_ON);
-            }
-            return false;
-        case CREATURE_SPIRIT_GUIDE:
-            if (isWarTime())
-            {
-               if (creature->GetAreaId() == 4575) // Select Fortress Spirit
-               {
-                 FortressSpirit = creature;
-                 if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
-                 {
-                    FortressSpirit->UpdateEntry(CRE_SPI_A);
-                 }
-                 if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
-                 {
-                    FortressSpirit->UpdateEntry(CRE_SPI_H);
-                 }
-               }
-                creature->SetVisibility(VISIBILITY_ON);
-                //creature->setDeathState(ALIVE);
-            }
-            else
-            {
-                creature->SetVisibility(VISIBILITY_OFF);
-                //creature->setDeathState(DEAD);
-            }
-            return false;
-        case CREATURE_SPIRIT_HEALER:
-            creature->SetVisibility(isWarTime() ? VISIBILITY_OFF : VISIBILITY_ON);
-            return false;
-        case CREATURE_ENGINEER:
-            return false;
-        case CREATURE_SIEGE_VEHICLE:
-            //creature->DisappearAndDie();
-            return false;
-        case CREATURE_GUARD:
-        case CREATURE_SPECIAL:
-        {
-            TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
-            if (itr != m_creEntryPair.end())
-            {
-                entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
-                _RespawnCreatureIfNeeded(creature, entry);
-            }
-            return false;
-        }
-        default:
-            return false;
-    }
-}
-
-bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
-{
-    assert(guid);
-    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
-
-    if (creature && creature->IsInWorld())
-    {
-        // if not questgiver or position is the same, do nothing
-        if (creature->GetPositionX() == pos.GetPositionX() &&
-            creature->GetPositionY() == pos.GetPositionY() &&
-            creature->GetPositionZ() == pos.GetPositionZ())
-            return false;
-
-        if (creature->isAlive() && creature->isInCombat())
-        {
-            creature->CombatStop(true);
-            creature->getHostileRefManager().deleteReferences();
-        }
-        creature->SetHomePosition(pos);
-        creature->DestroyForNearbyPlayers();
-        if (!creature->GetMap()->IsLoaded(pos.GetPositionX(), pos.GetPositionY()))
-            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
-        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
-        if (!creature->isAlive())
-            creature->Respawn(true);
-    }
-    else
-        sObjectMgr.MoveCreData(guid, 571, pos);
-
-    return true;
-}
-
-// Return false = Need to rebuild at battle End/Start
-//        true  = no need to rebuild (ie: Banners or teleporters)
-bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
-{
-    uint32 attFaction = 35;
-    uint32 defFaction = 35;
-
-    if (isWarTime())
-    {
-        attFaction = WintergraspFaction[getAttackerTeam()];
-        defFaction = WintergraspFaction[getDefenderTeam()];
-    }
-
-    switch(go->GetGOInfo()->displayId)
-    {
-        case 8244: // Defender's Portal - Vehicle Teleporter
-            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
-            return true;
-        case 7967: // Titan relic
-            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
-            return true;
-
-        case 8165: // Wintergrasp Keep Door
-        case 7877: // Wintergrasp Fortress Wall
-        case 7878: // Wintergrasp Keep Tower
-        case 7906: // Wintergrasp Fortress Gate
-        case 7909: // Wintergrasp Wall
-            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
-            return false;
-        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
-            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
-            return false;
-        case 8208: // Goblin Workshop
-            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
-            if (workshop)
-                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
-            return false;
-    }
-
-    // Note: this is only for test, still need db support
-    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
-    if (itr != m_goDisplayPair.end())
-    {
-        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
-            itr->second : itr->first);
-        return true;
-    }
-    return false;
-}
-
-void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return;
-
-    if (isWarTime())
-    {
-		if (plr->getLevel() < 75) 
-		{
-		plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
-		return;
-		}
-        if (plr->getLevel() > 74)
-        {
-            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
-                && !plr->HasAura(SPELL_LIEUTENANT))
-                plr->CastSpell(plr, SPELL_RECRUIT, true);
-            if (plr->GetTeamId() == getAttackerTeam())
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
-            }
-            else
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()])
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
-            }
-        }
-    }
-
-    SendInitWorldStatesTo(plr);
-    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
-    UpdateTenacityStack();
-}
-
-// Reapply Auras if needed
-void OutdoorPvPWG::HandlePlayerResurrects(Player * plr, uint32 zone)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return;
-
-    if (isWarTime())
-    {
-        if (plr->getLevel() > 74)
-        {
-            // Tenacity
-            if (plr->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
-                plr->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
-            {
-                if (plr->HasAura(SPELL_TENACITY))
-                    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
-
-                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
-                if (newStack > 20)
-                    newStack = 20;
-                plr->SetAuraStack(SPELL_TENACITY, plr, newStack);
-            }
-
-            // Tower Control
-            if (plr->GetTeamId() == getAttackerTeam())
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
-            }
-            else
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()])
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
-            }
-        }
-    }
-    OutdoorPvP::HandlePlayerResurrects(plr, zone);
-}
-
-void OutdoorPvPWG::HandlePlayerLeaveZone(Player * plr, uint32 zone)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return;
-
-    if (!plr->GetSession()->PlayerLogout())
-    {
-        if (plr->GetVehicle()) // dismiss in change zone case
-            plr->GetVehicle()->Dismiss();
-        plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
-        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
-        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-    }
-    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
-    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
-    UpdateTenacityStack();
-}
-
-void OutdoorPvPWG::PromotePlayer(Player *killer) const
-{
-    Aura * aur;
-    if (aur = killer->GetAura(SPELL_RECRUIT))
-    {
-        if (aur->GetStackAmount() >= 5)
-        {
-            killer->RemoveAura(SPELL_RECRUIT);
-            killer->CastSpell(killer, SPELL_CORPORAL, true);
-            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
-        }
-        else
-            killer->CastSpell(killer, SPELL_RECRUIT, true);
-    }
-    else if (aur = killer->GetAura(SPELL_CORPORAL))
-    {
-        if (aur->GetStackAmount() >= 5)
-        {
-            killer->RemoveAura(SPELL_CORPORAL);
-            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
-            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
-        }
-        else
-            killer->CastSpell(killer, SPELL_CORPORAL, true);
-    }
-}
-
-void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
-        return;
-
-    bool ok = false;
-    if (victim->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (victim->getLevel() >= 70)
-            ok = true;
-        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
-    }
-    else
-    {
-        switch(GetCreatureType(victim->GetEntry()))
-        {
-            case CREATURE_SIEGE_VEHICLE:
-                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
-                ok = true;
-                break;
-            case CREATURE_GUARD:
-                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
-                ok = true;
-                break;
-            case CREATURE_TURRET:
-                ok = true;
-                break;
-        }
-    }
-
-    if (ok)
-    {
-        if (Group *pGroup = killer->GetGroup())
-        {
-            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
-                    PromotePlayer(itr->getSource());
-        }
-        else if (killer->getLevel() > 74)
-            PromotePlayer(killer);
-    }
-}
-
-// Recalculates Tenacity and applies it to Players / Vehicles
-void OutdoorPvPWG::UpdateTenacityStack()
-{
-    if (!isWarTime())
-        return;
-
-    TeamId team = TEAM_NEUTRAL;
-    uint32 allianceNum = 0;
-    uint32 hordeNum = 0;
-    int32 newStack = 0;
-
-    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
-        if ((*itr)->getLevel() > 74)
-            ++allianceNum;
-
-    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
-        if ((*itr)->getLevel() > 74)
-            ++hordeNum;
-
-    if (allianceNum && hordeNum)
-    {
-        if (allianceNum < hordeNum)
-            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
-        else if (allianceNum > hordeNum)
-            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
-    }
-
-    if (newStack == m_tenacityStack)
-        return;
-
-    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
-        team = TEAM_ALLIANCE;
-    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
-        team = TEAM_HORDE;
-
-    m_tenacityStack = newStack;
-
-    // Remove old buff
-    if (team != TEAM_NEUTRAL)
-    {
-        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            if ((*itr)->getLevel() > 74)
-                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
-
-        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
-    }
-
-    // Apply new buff
-    if (newStack)
-    {
-        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
-        if (newStack < 0)
-            newStack = -newStack;
-        if (newStack > 20)
-            newStack = 20;
-
-        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            if ((*itr)->getLevel() > 74)
-                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
-
-        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
-    }
-}
-
-void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
-{
-    uint32 value = timer%mod;
-    if (m_clock[digit] != value)
-    {
-        m_clock[digit] = value;
-        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
-        sWorld.SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
-    }
-}
-
-void OutdoorPvPWG::UpdateClock()
-{
-    uint32 timer = m_timer / 1000;
-    if (!isWarTime())
-        UpdateClockDigit(timer, 1, 10);
-    else
-        UpdateClockDigit(timer, 0, 10);
-
-//Announce in all world, comment it if you don't like/need it
-	 // Announce 30 minutes left
- 	 if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false)) 
-        sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
- 
- 	 // Announce 10 minutes left
-	 if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false)) 
-       sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
-}
-
-bool OutdoorPvPWG::Update(uint32 diff)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return false;
-
-    if (m_timer > diff)
-    {
-        m_timer -= diff;
-
-        if (isWarTime())
-        {
-            OutdoorPvP::Update(diff); // update capture points
-
-            /*********************************************************/
-            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
-            /*********************************************************/
-
-            //this should be handled by spell system
-            m_LastResurrectTime += diff;
-            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
-            {
-                if (GetReviveQueueSize())
-                {
-                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
-                    {
-                        Creature* sh = NULL;
-                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
-                        {
-                            Player *plr = sObjectMgr.GetPlayer(*itr2);
-                            if (!plr)
-                                continue;
-
-                            if (!sh && plr->IsInWorld())
-                            {
-                                sh = plr->GetMap()->GetCreature(itr->first);
-                                // only for visual effect
-                                if (sh)
-                                    // Spirit Heal, effect 117
-                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
-                            }
-
-                            // Resurrection visual
-                         if (plr->GetDistance2d(sh) <= 18.0f)
-                           {
-                            plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
-                            m_ResurrectQueue.push_back(*itr2);
-                           }
-                        }
-                        (itr->second).clear();
-                    }
-
-                    m_ReviveQueue.clear();
-                    m_LastResurrectTime = 0;
-                }
-                else
-                    // queue is clear and time passed, just update last resurrection time
-                    m_LastResurrectTime = 0;
-            }
-            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
-            {
-                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
-                {
-                    Player *plr = sObjectMgr.GetPlayer(*itr);
-                    if (!plr)
-                        continue;
-                    plr->ResurrectPlayer(1.0f);
-                    plr->CastSpell(plr, 6962, true);
-                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
-                    sObjectAccessor.ConvertCorpseForPlayer(*itr);
-                }
-                m_ResurrectQueue.clear();
-            }
-        }
-        UpdateClock();
-    }
-    else
-    {
-        m_sendUpdate = false;
-        int32 entry = LANG_BG_WG_DEFENDED;
-
-        if (m_changeDefender)
-        {
-            m_changeDefender = false;
-            m_defender = getAttackerTeam();
-            entry = LANG_BG_WG_CAPTURED;
-        }
-
-        if (isWarTime())
-        {
-            if (m_timer != 1) // 1 = forceStopBattle
-                sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(entry), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
-            EndBattle();
-        }
-        else
-        {
-            if (m_timer != 1) // 1 = forceStartBattle
-                sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
-            StartBattle();
-        }
-
-        UpdateAllWorldObject();
-        UpdateClock();
-
-        SendInitWorldStatesTo();
-        m_sendUpdate = true;
-    }
-
-    if (m_WSSaveTimer < diff)
-    {
-        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31001', `value`='%d', `comment`='wg m_wartime'",m_wartime);
-        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31002', `value`='%d', `comment`='wg m_timer'",m_timer);
-        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31003', `value`='%d', `comment`='wg m_defender'",m_defender);
-        m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
-    } else m_WSSaveTimer -= diff;
-
-
-    return false;
-}
-
-void OutdoorPvPWG::forceStartBattle()
-{ // Uptime will do all the work
-    m_wartime = false;
-
-    if (m_timer != 1)
-    {
-        m_timer = 1;
-        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
-    }
-		sWorld.SendWintergraspState();
-}
-
-void OutdoorPvPWG::forceStopBattle()
-{ // Uptime will do all the work.
-
-    if (!isWarTime())
-        m_wartime = true;
-
-    if (m_timer != 1)
-    {
-        m_timer = 1;
-        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
-    }
-	sWorld.SendWintergraspState();
-}
-
-void OutdoorPvPWG::forceChangeTeam()
-{
-    m_changeDefender = true;
-    m_timer = 1;
-    sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr.GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
-    if (isWarTime())
-        forceStartBattle();
-    else
-        forceStopBattle();
-}
-
-// Can be forced by gm's while in battle so have to reset in case it was wartime
-void OutdoorPvPWG::StartBattle()
-{
-	uint32 CountDef=0;
-	uint32 CountAtk=0;
-    m_wartime = true;
-    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
-
-    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-    {
-       if ((*itr)->getLevel() < 75)
-        {
-          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
-        }
-       else
-        {
-          CountDef++;
-          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
-          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
-          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
-          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
-        }
-    }
-
-    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-    {
-        if ((*itr)->getLevel() < 75)
-        {
-          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
-        }
-        else
-        {
-          CountAtk++;
-          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
-          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
-          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
-          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
-        }
-    }
-
-if (sWorld.getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
- {
- if ((CountAtk < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
-  {
-   if (CountAtk<=CountDef)
-	   sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
-   if (CountDef<CountAtk)
-     {  
-	 sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
-	 m_changeDefender=true;
-     }
-   forceStopBattle();
-   return;
-  }
- }
-
-//    TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
-
-    // Remove Essence of Wintergrasp to all players
-    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
-    sWorld.UpdateAreaDependentAuras();
-
-    // destroyed all vehicles
-    for (uint32 team = 0; team < 2; ++team)
-    {
-        while(!m_vehicles[team].empty())
-        {
-            Creature *veh = *m_vehicles[team].begin();
-            m_vehicles[team].erase(m_vehicles[team].begin());
-            veh->setDeathState(JUST_DIED);
-        }
-    }
-
-    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
-    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-    {
-        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-        if ((*itr)->getLevel() > 74)
-        {
-            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
-            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
-        }
-    }
-
-    // Remove All Wintergrasp auras. Add Recruit rank
-    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-    {
-        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-        if ((*itr)->getLevel() > 74)
-            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
-    }
-    UpdateTenacityStack();
-	// Update timer in players battlegrounds tab
-    sWorld.SendWintergraspState();
-}
-
-void OutdoorPvPWG::EndBattle()
-{
-    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
-    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
-    sWorld.UpdateAreaDependentAuras();
-//Sound on End Battle
-for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-{
-	if (getDefenderTeam()==TEAM_ALLIANCE)
-	{
-    TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
-	}
-    else TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
-	(*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
-}
-for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-{
-   (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
-}
-
-    for (uint32 team = 0; team < 2; ++team)
-    {
-        // destroyed all vehicles
-        while(!m_vehicles[team].empty())
-        {
-            Creature *veh = *m_vehicles[team].begin();
-            m_vehicles[team].erase(m_vehicles[team].begin());
-            veh->setDeathState(JUST_DIED);
-        }
-
-        if (m_players[team].empty())
-            continue;
-
-        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-        {
-            // When WG ends the zone is cleaned including corpses, revive all players if dead
-            if ((*itr)->isDead())
-            {
-                (*itr)->ResurrectPlayer(1.0f);
-				sObjectAccessor.ConvertCorpseForPlayer((*itr)->GetGUID());
-                //ObjectAccessor::Instance().ConvertCorpseForPlayer((*itr)->GetGUID());
-            }
-            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
-            (*itr)->CombatStop(true);
-            (*itr)->getHostileRefManager().deleteReferences();
-        }
-
-        if (m_timer == 1) // Battle End was forced so no reward.
-        {
-            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            {
-                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-            }
-            continue;
-        }
-
-        // calculate rewards
-        uint32 intactNum = 0;
-        uint32 damagedNum = 0;
-        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-                if (workshop->m_buildingState->GetTeam() == team)
-                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
-                        ++damagedNum;
-                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
-                        ++intactNum;
-
-        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
-        uint32 baseHonor = 0;
-        uint32 marks = 0;
-        uint32 playersWithRankNum = 0;
-        uint32 honor = 0;
-
-        if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
-        {
-            // Calculate Level 70+ with Corporal or Lieutenant rank
-            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
-                    ++playersWithRankNum;
-
-            baseHonor = team == getDefenderTeam() ? sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
-            if (playersWithRankNum)
-                baseHonor /= playersWithRankNum;
-        }
-
-        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-        {
-
-            if ((*itr)->getLevel() < 75)
-                continue; // No rewards for level <75
-
-            // give rewards
-            if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
-            {
-                if (team == getDefenderTeam())
-                {
-                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
-                    {
-                        marks = 3;
-                        honor = baseHonor;
-                    }
-                    else if ((*itr)->HasAura(SPELL_CORPORAL))
-                    {
-                        marks = 2;
-                        honor = baseHonor;
-                    }
-                    else
-                    {
-                        marks = 1;
-                        honor = 0;
-                    }
-                }
-                else
-                {
-                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
-                    {
-                        marks = 1;
-                        honor = baseHonor;
-                    }
-                    else if ((*itr)->HasAura(SPELL_CORPORAL))
-                    {
-                        marks = 1;
-                        honor = baseHonor;
-                    }
-                    else
-                    {
-                        marks = 0;
-                        honor = 0;
-                    }
-                }
-                (*itr)->RewardHonor(NULL, 1, honor);
-                RewardMarkOfHonor(*itr, marks);
-                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
-            }
-            else
-            {
-                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
-                {
-                    // TODO - Honor from SpellReward should be shared by team players
-                    // TODO - Marks should be given depending on Rank but 3 are given
-                    // each time so Won't give any to recruits
-                    (*itr)->CastSpell(*itr, spellRewardId, true);
-                    for (uint32 i = 0; i < intactNum; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
-                    for (uint32 i = 0; i < damagedNum; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
-                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
-                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
-                }
-            }
-            if (team == getDefenderTeam())
-            {
-                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
-                {
-                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
-                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
-                }
-            }
-            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-        }
-    }
-
-    m_wartime = false;
-    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
-    RemoveOfflinePlayerWGAuras();
-    // Update timer in players battlegrounds tab
-    sWorld.SendWintergraspState();
-}
-
-bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
-{
-    TeamId team = workshop->m_buildingState->GetTeam();
-    if (team == TEAM_NEUTRAL)
-        return false;
-
-    return isWarTime()
-        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
-        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
-}
-
-uint32 OutdoorPvPWG::GetData(uint32 id)
-{
-    // if can build more vehicles
-    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
-        return CanBuildVehicle(workshop) ? 1 : 0;
-
-    return 0;
-}
-
-void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
-{
-    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
-    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
-        return;
-    if (count == 0)
-        return;
-
-    ItemPosCountVec dest;
-    uint32 no_space_count = 0;
-    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
-
-    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
-    {
-        sLog.outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
-        return;
-    }
-
-    if (msg != EQUIP_ERR_OK) // convert to possible store amount
-        count -= no_space_count;
-
-    if (count != 0 && !dest.empty()) // can add some
-        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
-            plr->SendNewItem(item, count, true, false);
-}
-
-void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
-{
-    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
-    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
-    m_questgivers[guid] = NULL;
-    if (getDefenderTeam() == TEAM_ALLIANCE)
-        sObjectMgr.MoveCreData(guid, 571, posAlli);
-}
-
-OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
-{
-    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
-        return dynamic_cast<OPvPCapturePointWG*>(cp);
-    return NULL;
-}
-
-OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
-{
-    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-            if (workshop->m_engGuid == lowguid)
-                return workshop;
-    return NULL;
-}
-
-OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
-{
-    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-            if (workshop->m_workshopGuid == lowguid)
-                return workshop;
-    return NULL;
-}
-
-/*########################################################
- * Copy of Battleground system to make Spirit Guides Work
- *#######################################################*/
-void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
-{
-    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
-    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
-    if (time_ == uint32(-1))
-        time_ = 0;
-    data << guid << time_;
-    pl->GetSession()->SendPacket(&data);
-}
-
-void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
-{
-    m_ReviveQueue[npc_guid].push_back(player_guid);
-
-    Player *plr = sObjectMgr.GetPlayer(player_guid);
-    if (!plr)
-        return;
-
-    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
-}
-
-void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
-{
-    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
-    {
-        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
-        {
-            if (*itr2 == player_guid)
-            {
-                (itr->second).erase(itr2);
-
-                Player *plr = sObjectMgr.GetPlayer(player_guid);
-                if (!plr)
-                    return;
-
-                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
-
-                return;
-            }
-        }
-    }
-}
-
-void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
-{
-    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
-        return;
-
-    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
-    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
-    if (!ghost_list.empty())
-    {
-        WorldSafeLocsEntry const *ClosestGrave = NULL;
-        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
-        {
-            Player* plr = sObjectMgr.GetPlayer(*itr);
-			if (!plr)
-                continue;
-
-			if (plr->getFaction() == ALLIANCE)
-			{
-            if (!ClosestGrave)
-                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
-
-            if (ClosestGrave)
-                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
-			}
-        }
-    }
-}
-
-void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
-{
-    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
-        return;
-
-    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
-    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
-    if (!ghost_list.empty())
-    {
-        WorldSafeLocsEntry const *ClosestGrave = NULL;
-        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
-        {
-            Player* plr = sObjectMgr.GetPlayer(*itr);
-			if (!plr)
-                continue;
-
-			if (plr->getFaction() == HORDE)
-			{
-            if (!ClosestGrave)
-                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
-
-            if (ClosestGrave)
-                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
-			}
-        }
-    }
-}
-
-/*######
-##OPvPCapturePointWG
-######*/
-
-OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state)
-: OPvPCapturePoint(opvp), m_buildingState(state), m_wintergrasp(opvp)
-, m_engineer(NULL), m_engGuid(0), m_spiritguide(NULL)
-, m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_spiGuid(0)
-{
-}
-
-void OPvPCapturePointWG::SetTeamByBuildingState()
-{
-    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
-    {
-        m_value = m_maxValue;
-        m_State = OBJECTIVESTATE_ALLIANCE;
-    }
-    else if (m_buildingState->GetTeam() == TEAM_HORDE)
-    {
-        m_value = -m_maxValue;
-        m_State = OBJECTIVESTATE_HORDE;
-    }
-    else
-    {
-        m_value = 0;
-        m_State = OBJECTIVESTATE_NEUTRAL;
-    }
-
-    if (m_team != m_buildingState->GetTeam())
-    {
-        TeamId oldTeam = m_team;
-        m_team = m_buildingState->GetTeam();
-        ChangeTeam(oldTeam);
-    }
-
-    SendChangePhase();
-}
-
-void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
-{
-   entry = 0;
-   guide_entry = 0;
-   guide_entry_fortress_horde = 0;
-   guide_entry_fortress_alliance = 0;
-
-    if (oldTeam != TEAM_NEUTRAL)
-        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
-
-    if (m_team != TEAM_NEUTRAL)
-    {
-        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
-        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
-        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
-        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
-        m_wintergrasp->ModifyWorkshopCount(m_team, true);
-    }
-
-    if (m_capturePoint)
-        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
-
-    m_buildingState->SetTeam(m_team);
-    // TODO: this may be sent twice
-    m_wintergrasp->BroadcastStateChange(m_buildingState);
-
-    if (m_buildingState->building)
-        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
-
-    if (entry)
-    {
-        if (m_engGuid)
-        {
-            *m_engEntry = entry;
-            _RespawnCreatureIfNeeded(m_engineer, entry);
-        }
-        if (m_spiGuid)
-        {
-         if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
-         {
-            *m_spiEntry = guide_entry;
-            _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
-            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
-            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
-            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
-         }
-         else
-         {
-            *m_spiEntry = guide_entry;
-            _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
-            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
-            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
-            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
-         }
-        }
-    }
-    else if (m_engineer)
-        m_engineer->SetVisibility(VISIBILITY_OFF);
-
-    sLog.outDebug("Wintergrasp workshop now belongs to %u.", (uint32)m_buildingState->GetTeam());
-}
-
-class OutdoorPvP_wintergrasp : public OutdoorPvPScript
-{
-    public:
-
-        OutdoorPvP_wintergrasp()
-            : OutdoorPvPScript("outdoorpvp_wg")
-        {
-        }
-
-        OutdoorPvP* GetOutdoorPvP() const
-        {
-            return new OutdoorPvPWG();
-        }
-};
-
-void AddSC_outdoorpvp_wg()
-{
-    new OutdoorPvP_wintergrasp();
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ */
+
+#include "OutdoorPvPWG.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "ObjectMgr.h"
+#include "World.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "ScriptedCreature.h"
+#include "ScriptPCH.h"
+
+Creature* FortressSpirit;
+uint32 entry;
+uint32 guide_entry;
+uint32 guide_entry_fortress_horde;
+uint32 guide_entry_fortress_alliance;
+
+OutdoorPvPWG::OutdoorPvPWG()
+{
+    m_TypeId = OUTDOOR_PVP_WG;
+    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
+}
+
+void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
+{
+    while((*pair)[0])
+    {
+        pairMap[(*pair)[0]] = (*pair)[1];
+        pairMap[(*pair)[1]] = (*pair)[0];
+        ++pair;
+    }
+}
+
+void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
+{
+    if (cr)
+    {
+        cr->SetOriginalEntry(entry);
+        if (entry != cr->GetEntry() || !cr->isAlive())
+            cr->Respawn(true);
+        cr->SetVisibility(VISIBILITY_ON);
+    }
+}
+
+bool OutdoorPvPWG::SetupOutdoorPvP()
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+        return false;
+    }
+
+    //load worlstates
+    QueryResult result = CharacterDatabase.PQuery("SELECT `entry`, `value` from `worldstates` where `entry` in ('31001','31002','31003') order by `entry`");
+    
+    m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+
+    if (result)
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+            switch (fields[0].GetUInt32())
+            {
+                case 31001:
+                    m_wartime = fields[1].GetBool();
+                    break;
+                case 31002:
+                    m_timer = fields[1].GetUInt32();
+                    break;
+                case 31003:
+                    m_defender = TeamId(fields[1].GetUInt32());
+                    break;
+            }
+        }while(result->NextRow());
+    }
+    else
+    {
+        m_wartime = false;
+        m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
+        m_defender = TeamId(rand()%2);
+    }
+
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    m_changeDefender = false;
+    m_workshopCount[TEAM_ALLIANCE] = 0;
+    m_workshopCount[TEAM_HORDE] = 0;
+    m_tenacityStack = 0;
+    m_gate = NULL;
+
+    std::list<uint32> engGuids;
+    std::list<uint32> spiritGuids;
+
+    // Store Eng, spirit guide guids and questgiver for later use
+    result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
+         " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
+         CRE_ENG_A, CRE_ENG_H, CRE_SPI_A, CRE_SPI_H, 31101, 31051, 31102, 31052,
+         31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
+    if (!result)
+        sLog.outError("Cannot find siege workshop master or spirit guides in creature!");
+    else
+    {
+        do
+        {
+            Position posHorde, posAlli;
+            Field *fields = result->Fetch();
+            switch(fields[1].GetUInt32())
+            {
+                case CRE_ENG_A:
+                case CRE_ENG_H:
+                    engGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case CRE_SPI_A:
+                case CRE_SPI_H:
+                    spiritGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case 31051:
+                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
+                    posAlli.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31101:
+                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31052:
+                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
+                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31102:
+                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31109:
+                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
+                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31107:
+                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31153:
+                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
+                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31151:
+                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31108:
+                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
+                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31106:
+                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31054:
+                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
+                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31053:
+                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31036:
+                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
+                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31091:
+                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                default:
+                    break;
+            }
+        }while(result->NextRow());
+    }
+
+    // Select POI
+    AreaPOIList areaPOIs;
+    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
+    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
+    {
+        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
+        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
+        {
+            areaPOIs.push_back(poiInfo);
+            if (minX > poiInfo->x) minX = poiInfo->x;
+            if (minY > poiInfo->y) minY = poiInfo->y;
+            if (maxX < poiInfo->x) maxX = poiInfo->x;
+            if (maxY < poiInfo->y) maxY = poiInfo->y;
+        }
+    }
+    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
+
+    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
+    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
+        " WHERE gameobject.map=571"
+        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
+        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
+        " AND gameobject_template.type=33"
+        " AND gameobject.id=gameobject_template.entry",
+        minX, minY, maxX, maxY);
+    if (!result)
+        return false;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        uint32 guid = fields[0].GetUInt32();
+        GameObjectData const * goData = sObjectMgr.GetGOData(guid);
+        if (!goData) // this should not happen
+            continue;
+
+        float x = goData->posX, y = goData->posY;
+        float minDist = 100;
+        AreaPOIList::iterator poi = areaPOIs.end();
+        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
+        {
+            if (!(*itr)->icon[1]) // note: may for other use
+                continue;
+
+            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
+            if (minDist > dist)
+            {
+                minDist = dist;
+                poi = itr;
+            }
+        }
+
+        if (poi == areaPOIs.end())
+            continue;
+
+        // add building to the list
+        TeamId teamId = x > POS_X_CENTER ? getDefenderTeam() : getAttackerTeam();
+        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
+        if ((*poi)->id == 2246)
+            m_gate = m_buildingStates[guid];
+        areaPOIs.erase(poi);
+
+        // add capture point
+        uint32 capturePointEntry = 0;
+
+        switch(goData->id)
+        {    
+            //West Goblin Workshops
+            case 192028: // NW
+            case 192030: // W
+            case 192032: // SW
+                capturePointEntry = 190475;
+                break;
+            //East Goblin Workshops
+            case 192029: // NE
+            case 192031: // E
+            case 192033: // SE
+                capturePointEntry = 190487;
+                break;
+        }
+
+        if (capturePointEntry)
+        {
+            uint32 engGuid = 0;
+            uint32 spiritGuid = 0;
+            // Find closest Eng to Workshop
+            float minDist = 100;
+            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    engGuid = *itr;
+                }
+            }
+
+            if (!engGuid)
+            {
+                sLog.outError("Cannot find nearby siege workshop master!");
+                continue;
+            }
+            else
+                engGuids.remove(engGuid);
+            // Find closest Spirit Guide to Workshop
+            minDist = 255;
+            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    spiritGuid = *itr;
+                }
+            }
+
+            // Inside fortress won't be capturable
+            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
+            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
+            {
+                delete workshop;
+                sLog.outError("Cannot add capture point!");
+                continue;
+            }
+
+            const CreatureData *creData = sObjectMgr.GetCreatureData(engGuid);
+            if (!creData)
+                continue;
+
+            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
+            const_cast<CreatureData*>(creData)->displayid = 0;
+            workshop->m_engGuid = engGuid;
+
+            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
+            if (spiritGuid)
+            {
+                spiritGuids.remove(spiritGuid);
+
+                const CreatureData *spiritData = sObjectMgr.GetCreatureData(spiritGuid);
+                if (!spiritData)
+                    continue;
+
+                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
+                const_cast<CreatureData*>(spiritData)->displayid = 0;
+                workshop->m_spiGuid = spiritGuid;
+            }
+            else
+                workshop->m_spiGuid = 0;
+            workshop->m_workshopGuid = guid;
+            AddCapturePoint(workshop);
+            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
+            workshop->SetTeamByBuildingState();
+        }
+    }while(result->NextRow());
+
+    engGuids.clear();
+    spiritGuids.clear();
+
+    if (!m_gate)
+    {
+        sLog.outError("Cannot find wintergrasp fortress gate!");
+        return false;
+    }
+
+    // Load Graveyard
+    GraveYardMap::const_iterator graveLow  = sObjectMgr.mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
+    GraveYardMap::const_iterator graveUp   = sObjectMgr.mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
+    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
+    {
+        if ((*itr)->icon[1] == 8)
+        {
+            // find or create grave yard
+            const WorldSafeLocsEntry *loc = sObjectMgr.GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
+            if (!loc)
+            {
+                ++itr;
+                continue;
+            }
+
+            GraveYardMap::const_iterator graveItr;
+            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
+                if (graveItr->second.safeLocId == loc->ID)
+                    break;
+            if (graveItr == graveUp)
+            {
+                GraveYardData graveData;
+                graveData.safeLocId = loc->ID;
+                graveData.team = 0;
+                graveItr = sObjectMgr.mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
+            }
+
+            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
+            {
+                if (stateItr->second->worldState == (*itr)->worldState)
+                {
+                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
+                    break;
+                }
+            }
+            areaPOIs.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+
+    //Titan Relic
+    sObjectMgr.AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
+
+    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
+    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
+
+    sWorld.SendWintergraspState();
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+
+    RemoveOfflinePlayerWGAuras();
+
+    RegisterZone(ZONE_WINTERGRASP);
+
+    if (m_wartime)
+    {
+        uint32 m_WSTimer = m_timer;
+        StartBattle();
+        m_timer = m_WSTimer;
+    }
+
+    return true;
+}
+
+void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
+{	
+    if (obj->GetEntry() == 192829) // Titan Relic
+    {
+        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && m_gate && m_gate->damageState == DAMAGE_DESTROYED)
+        {
+            m_changeDefender = true;
+            m_timer = 0;
+        }
+    }
+    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
+        if (itr == m_buildingStates.end())
+            return;
+
+        std::string msgStr;
+        switch(eventId)
+        { // TODO - Localized msgs of GO names
+            case 19672: case 19675: // Flamewatch Tower
+                msgStr = "Flamewatch";
+                break;
+            case 18553: case 19677: // Shadowsight Tower
+                msgStr = "Shadowsight";
+                break;
+            case 19673: case 19676: // Winter's Edge Tower
+                msgStr = "Winter's Edge";
+                break;
+            case 19776: case 19778: // E Workshop damaged
+                msgStr = "Sunken Ring";
+                break;
+            case 19777: case 19779: // W Workshop damaged
+                msgStr = "Broken Temple";
+                break;
+            case 19782: case 19786: // NW Workshop damaged
+                msgStr = "north-western";
+                break;
+            case 19783: case 19787: // NE Workshop damaged
+                msgStr = "north-eastern";
+                break;
+            case 19784: case 19788: // SW Workshop damaged
+                msgStr = "Westpark";
+                break;
+            case 19785: case 19789: // SE Workshop damaged
+                msgStr = "Eastpark";
+                break;
+            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
+                msgStr = "north-western";
+                break;
+            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
+                msgStr = "north-eastern";
+                break;
+            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
+                msgStr = "south-western";
+                break;
+            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
+                msgStr = "south-eastern";
+                break;
+            default:
+                msgStr = "";
+        }
+
+        BuildingState *state = itr->second;
+        if (eventId == obj->GetGOInfo()->building.damagedEvent)
+        {
+            state->damageState = DAMAGE_DAMAGED;
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+	           for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+	                  (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+		break;
+                case BUILDING_TOWER:
+                    ++m_towerDamagedCount[state->GetTeam()];
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+			   for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                  }
+                     else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+                    break;
+            }
+        }
+        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
+        {
+            state->damageState = DAMAGE_DESTROYED;
+
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    ModifyWorkshopCount(state->GetTeam(), false);
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+			    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+		          (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+                    break;
+                case BUILDING_TOWER:
+                    --m_towerDamagedCount[state->GetTeam()];
+                    ++m_towerDestroyedCount[state->GetTeam()];
+                    if (state->GetTeam() == getAttackerTeam())
+                    {
+                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
+                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
+                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
+
+                        if (m_towerDestroyedCount[getAttackerTeam()])
+                        {
+                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
+                        }
+
+                        if (attStack)
+                        {
+                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
+                        }
+                        else
+                        {
+                            if (m_timer < 600000)
+                                m_timer = 0;
+                            else
+                                m_timer = m_timer - 600000; // - 10 mins
+                        }
+                    }
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+	    	    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
+                  }
+                    break;
+            }
+            BroadcastStateChange(state);
+        }
+    }
+}
+
+void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
+{
+    // if server crashed while in battle there could be players with rank or tenacity
+    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
+        SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
+}
+
+void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
+{
+    if (team == TEAM_NEUTRAL)
+        return;
+
+    if (add)
+        ++m_workshopCount[team];
+    else if (m_workshopCount[team])
+        --m_workshopCount[team];
+    else
+        sLog.outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
+
+    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
+}
+
+uint32 OutdoorPvPWG::GetCreatureEntry(uint32 guidlow, const CreatureData *data)
+{
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+    {
+        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
+        if (itr != m_creEntryPair.end())
+        {
+            const_cast<CreatureData*>(data)->displayid = 0;
+            return itr->second;
+        }
+    }
+    return data->id;
+}
+
+OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
+{
+    // VEHICLES, GUARDS and TURRETS gives kill credit
+    // OTHER Not in wartime
+    // TURRET Only during wartime
+    // SPECIAL like "OTHER" but no despawn conditions
+    // Entries like Case A: Case: B have their own despawn function
+    switch(entry)
+    {
+        case 27881: // Catapult
+        case 28094: // Demolisher
+        case 28312: // Alliance Siege Engine
+        case 32627: // Horde Siege Engine
+        case 28319: // Siege turret
+        case 32629: // Siege turret
+            return CREATURE_SIEGE_VEHICLE;
+        case 28366: // Wintergrasp Tower cannon
+            return CREATURE_TURRET;
+        case CRE_ENG_A: // Alliance Engineer
+        case CRE_ENG_H: // Horde Engineer
+            return CREATURE_ENGINEER;
+        case 30739:case 30740: // Champions
+        case 32307:case 32308: // Guards
+            return CREATURE_GUARD;
+        case CRE_SPI_A: // Dwarven Spirit Guide
+        case CRE_SPI_H: // Taunka Spirit Guide
+            return CREATURE_SPIRIT_GUIDE;
+        case 6491: // Spirit Healers
+            return CREATURE_SPIRIT_HEALER;
+        case 31101:case 31051: // Hoodoo Master & Sorceress
+        case 31102:case 31052: // Vieron Blazefeather & Bowyer
+        case 31107:case 31109: // Lieutenant & Senior Demolitionist
+        case 31151:case 31153: // Tactical Officer
+        case 31106:case 31108: // Siegesmith & Siege Master
+        case 31053:case 31054: // Primalist & Anchorite
+        case 31091:case 31036: // Commander
+            return CREATURE_QUESTGIVER;
+        case 32615:case 32626: // Warbringer && Brigadier General
+        case 32296:case 32294: // Quartermaster
+        case 39173:case 39172: // Ros'slai && Marshal Magruder
+        case 30870:case 30869: // Flight Masters
+            return CREATURE_SPECIAL;
+        default:
+            return CREATURE_OTHER; // Revenants, Elementals, etc
+    }
+}
+
+void OutdoorPvPWG::OnCreatureCreate(Creature *creature, bool add)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            if (add)
+            {
+                if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                    team = TEAM_ALLIANCE;
+                else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                    team = TEAM_HORDE;
+                else
+                    return;
+
+                if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
+                {
+                    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
+                    {
+                        if (CanBuildVehicle(workshop))
+                        {
+                            m_vehicles[team].insert(creature);
+                            //workshop->m_vehicles.insert(creature);
+                        }
+                        else
+                        {
+                            creature->setDeathState(DEAD);
+                            creature->SetRespawnTime(DAY);
+                            return;
+                        }
+                    }
+                }
+
+                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
+                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
+            }
+            else // the faction may be changed in uncharm
+            {
+                // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
+                if (m_vehicles[TEAM_ALLIANCE].erase(creature))
+                    team = TEAM_ALLIANCE;
+                else if (m_vehicles[TEAM_HORDE].erase(creature))
+                    team = TEAM_HORDE;
+                else
+                    return;
+            }
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            if (add)
+                m_questgivers[creature->GetDBTableGUIDLow()] = creature;
+            else
+                m_questgivers.erase(creature->GetDBTableGUIDLow());
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = add ? creature : NULL;
+                        break;
+                    }
+            }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = add ? creature : NULL;
+                        break;
+                    }
+            }
+            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
+        case CREATURE_SPIRIT_HEALER:
+        case CREATURE_TURRET:
+        case CREATURE_OTHER:
+            if (add)
+                UpdateCreatureInfo(creature);
+        default:
+            if (add)
+                m_creatures.insert(creature);
+            else
+                m_creatures.erase(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectCreate(GameObject *go, bool add)
+{
+    OutdoorPvP::OnGameObjectCreate(go, add);
+
+    if (UpdateGameObjectInfo(go))
+    {
+        if (add) m_gobjects.insert(go);
+        else m_gobjects.erase(go);
+    }
+    //do we need to store building?
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+        {
+            itr->second->building = add ? go : NULL;
+            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
+                itr->second->type = BUILDING_TOWER;
+            if (!add || itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
+            {
+                itr->second->health = go->GetGOValue()->building.health;
+                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+            else
+            {
+                go->GetGOValue()->building.health = itr->second->health;
+                if (itr->second->damageState == DAMAGE_DAMAGED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                else if (itr->second->damageState == DAMAGE_DESTROYED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::UpdateAllWorldObject()
+{
+    // update cre and go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+        UpdateGameObjectInfo(*itr);
+    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
+        UpdateCreatureInfo(*itr);
+    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
+        UpdateQuestGiverPosition((*itr).first, (*itr).second);
+
+    // rebuild and update building states
+    RebuildAllBuildings();
+
+    // update capture points
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            workshop->SetTeamByBuildingState();
+}
+
+void OutdoorPvPWG::RebuildAllBuildings()
+{
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+    {
+        if (itr->second->building)
+        {
+            UpdateGameObjectInfo(itr->second->building);
+            itr->second->building->Rebuild();
+            itr->second->health = itr->second->building->GetGOValue()->building.health;
+        }
+        else
+            itr->second->health = 0;
+
+        if (itr->second->damageState == DAMAGE_DESTROYED)
+        {
+            if (itr->second->type == BUILDING_WORKSHOP)
+                ModifyWorkshopCount(itr->second->GetTeam(), true);
+        }
+
+        itr->second->damageState = DAMAGE_INTACT;
+        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
+    }
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+}
+
+void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
+    data << uint32(571);
+    data << uint32(ZONE_WINTERGRASP);
+    data << uint32(0);
+    data << uint16(4+2+4+m_buildingStates.size());
+
+    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << m_clock[i];
+
+    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
+    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
+    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
+    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
+
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+        itr->second->FillData(data);
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        BroadcastPacket(data);
+}
+
+void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
+{
+    if (m_sendUpdate)
+        for (uint32 team = 0; team < 2; ++team)
+            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+                state->SendUpdate(*p_itr);
+}
+
+// Called at Start and Battle End
+bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
+{
+    if (!creature)
+        return false;
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_TURRET:
+            if (isWarTime())
+            {
+                if (!creature->isAlive())
+                    creature->Respawn(true);
+                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
+                creature->SetVisibility(VISIBILITY_ON);
+            }
+            else
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->SetVisibility(VISIBILITY_OFF);
+                creature->setFaction(35);
+            }
+            return false;
+        case CREATURE_OTHER:
+            if (isWarTime())
+            {
+                creature->SetVisibility(VISIBILITY_OFF);
+                creature->setFaction(35);
+            }
+            else
+            {
+                creature->RestoreFaction();
+                creature->SetVisibility(VISIBILITY_ON);
+            }
+            return false;
+        case CREATURE_SPIRIT_GUIDE:
+            if (isWarTime())
+            {
+               if (creature->GetAreaId() == 4575) // Select Fortress Spirit
+               {
+                 FortressSpirit = creature;
+                 if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
+                 {
+                    FortressSpirit->UpdateEntry(CRE_SPI_A);
+                 }
+                 if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
+                 {
+                    FortressSpirit->UpdateEntry(CRE_SPI_H);
+                 }
+               }
+                creature->SetVisibility(VISIBILITY_ON);
+                //creature->setDeathState(ALIVE);
+            }
+            else
+            {
+                creature->SetVisibility(VISIBILITY_OFF);
+                //creature->setDeathState(DEAD);
+            }
+            return false;
+        case CREATURE_SPIRIT_HEALER:
+            creature->SetVisibility(isWarTime() ? VISIBILITY_OFF : VISIBILITY_ON);
+            return false;
+        case CREATURE_ENGINEER:
+            return false;
+        case CREATURE_SIEGE_VEHICLE:
+            //creature->DisappearAndDie();
+            return false;
+        case CREATURE_GUARD:
+        case CREATURE_SPECIAL:
+        {
+            TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
+            if (itr != m_creEntryPair.end())
+            {
+                entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
+                _RespawnCreatureIfNeeded(creature, entry);
+            }
+            return false;
+        }
+        default:
+            return false;
+    }
+}
+
+bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
+{
+    assert(guid);
+    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
+
+    if (creature && creature->IsInWorld())
+    {
+        // if not questgiver or position is the same, do nothing
+        if (creature->GetPositionX() == pos.GetPositionX() &&
+            creature->GetPositionY() == pos.GetPositionY() &&
+            creature->GetPositionZ() == pos.GetPositionZ())
+            return false;
+
+        if (creature->isAlive() && creature->isInCombat())
+        {
+            creature->CombatStop(true);
+            creature->getHostileRefManager().deleteReferences();
+        }
+        creature->SetHomePosition(pos);
+        creature->DestroyForNearbyPlayers();
+        if (!creature->GetMap()->IsLoaded(pos.GetPositionX(), pos.GetPositionY()))
+            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
+        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+        if (!creature->isAlive())
+            creature->Respawn(true);
+    }
+    else
+        sObjectMgr.MoveCreData(guid, 571, pos);
+
+    return true;
+}
+
+// Return false = Need to rebuild at battle End/Start
+//        true  = no need to rebuild (ie: Banners or teleporters)
+bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
+{
+    uint32 attFaction = 35;
+    uint32 defFaction = 35;
+
+    if (isWarTime())
+    {
+        attFaction = WintergraspFaction[getAttackerTeam()];
+        defFaction = WintergraspFaction[getDefenderTeam()];
+    }
+
+    switch(go->GetGOInfo()->displayId)
+    {
+        case 8244: // Defender's Portal - Vehicle Teleporter
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
+            return true;
+        case 7967: // Titan relic
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
+            return true;
+
+        case 8165: // Wintergrasp Keep Door
+        case 7877: // Wintergrasp Fortress Wall
+        case 7878: // Wintergrasp Keep Tower
+        case 7906: // Wintergrasp Fortress Gate
+        case 7909: // Wintergrasp Wall
+            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
+            return false;
+        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
+            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
+            return false;
+        case 8208: // Goblin Workshop
+            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
+            if (workshop)
+                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
+            return false;
+    }
+
+    // Note: this is only for test, still need db support
+    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
+    if (itr != m_goDisplayPair.end())
+    {
+        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
+            itr->second : itr->first);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+		if (plr->getLevel() < 75) 
+		{
+		plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
+		return;
+		}
+        if (plr->getLevel() > 74)
+        {
+            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
+                && !plr->HasAura(SPELL_LIEUTENANT))
+                plr->CastSpell(plr, SPELL_RECRUIT, true);
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            }
+            else
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+            }
+        }
+    }
+
+    SendInitWorldStatesTo(plr);
+    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+// Reapply Auras if needed
+void OutdoorPvPWG::HandlePlayerResurrects(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() > 74)
+        {
+            // Tenacity
+            if (plr->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
+                plr->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
+            {
+                if (plr->HasAura(SPELL_TENACITY))
+                    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
+                if (newStack > 20)
+                    newStack = 20;
+                plr->SetAuraStack(SPELL_TENACITY, plr, newStack);
+            }
+
+            // Tower Control
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            }
+            else
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+            }
+        }
+    }
+    OutdoorPvP::HandlePlayerResurrects(plr, zone);
+}
+
+void OutdoorPvPWG::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (!plr->GetSession()->PlayerLogout())
+    {
+        if (plr->GetVehicle()) // dismiss in change zone case
+            plr->GetVehicle()->Dismiss();
+        plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    }
+    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::PromotePlayer(Player *killer) const
+{
+    Aura * aur;
+    if (aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
+        }
+        else
+            killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
+        }
+        else
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
+        return;
+
+    bool ok = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->getLevel() >= 70)
+            ok = true;
+        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+    }
+    else
+    {
+        switch(GetCreatureType(victim->GetEntry()))
+        {
+            case CREATURE_SIEGE_VEHICLE:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
+                ok = true;
+                break;
+            case CREATURE_GUARD:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+                ok = true;
+                break;
+            case CREATURE_TURRET:
+                ok = true;
+                break;
+        }
+    }
+
+    if (ok)
+    {
+        if (Group *pGroup = killer->GetGroup())
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
+                    PromotePlayer(itr->getSource());
+        }
+        else if (killer->getLevel() > 74)
+            PromotePlayer(killer);
+    }
+}
+
+// Recalculates Tenacity and applies it to Players / Vehicles
+void OutdoorPvPWG::UpdateTenacityStack()
+{
+    if (!isWarTime())
+        return;
+
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = 0;
+    uint32 hordeNum = 0;
+    int32 newStack = 0;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++allianceNum;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++hordeNum;
+
+    if (allianceNum && hordeNum)
+    {
+        if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+    }
+
+    if (newStack == m_tenacityStack)
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
+    }
+}
+
+void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
+{
+    uint32 value = timer%mod;
+    if (m_clock[digit] != value)
+    {
+        m_clock[digit] = value;
+        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
+        sWorld.SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
+    }
+}
+
+void OutdoorPvPWG::UpdateClock()
+{
+    uint32 timer = m_timer / 1000;
+    if (!isWarTime())
+        UpdateClockDigit(timer, 1, 10);
+    else
+        UpdateClockDigit(timer, 0, 10);
+
+//Announce in all world, comment it if you don't like/need it
+	 // Announce 30 minutes left
+ 	 if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false)) 
+        sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
+ 
+ 	 // Announce 10 minutes left
+	 if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false)) 
+       sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
+}
+
+bool OutdoorPvPWG::Update(uint32 diff)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return false;
+
+    if (m_timer > diff)
+    {
+        m_timer -= diff;
+
+        if (isWarTime())
+        {
+            OutdoorPvP::Update(diff); // update capture points
+
+            /*********************************************************/
+            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
+            /*********************************************************/
+
+            //this should be handled by spell system
+            m_LastResurrectTime += diff;
+            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+            {
+                if (GetReviveQueueSize())
+                {
+                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+                    {
+                        Creature* sh = NULL;
+                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                        {
+                            Player *plr = sObjectMgr.GetPlayer(*itr2);
+                            if (!plr)
+                                continue;
+
+                            if (!sh && plr->IsInWorld())
+                            {
+                                sh = plr->GetMap()->GetCreature(itr->first);
+                                // only for visual effect
+                                if (sh)
+                                    // Spirit Heal, effect 117
+                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                            }
+
+                            // Resurrection visual
+                         if (plr->GetDistance2d(sh) <= 18.0f)
+                           {
+                            plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+                            m_ResurrectQueue.push_back(*itr2);
+                           }
+                        }
+                        (itr->second).clear();
+                    }
+
+                    m_ReviveQueue.clear();
+                    m_LastResurrectTime = 0;
+                }
+                else
+                    // queue is clear and time passed, just update last resurrection time
+                    m_LastResurrectTime = 0;
+            }
+            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+            {
+                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+                {
+                    Player *plr = sObjectMgr.GetPlayer(*itr);
+                    if (!plr)
+                        continue;
+                    plr->ResurrectPlayer(1.0f);
+                    plr->CastSpell(plr, 6962, true);
+                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+                    sObjectAccessor.ConvertCorpseForPlayer(*itr);
+                }
+                m_ResurrectQueue.clear();
+            }
+        }
+        UpdateClock();
+    }
+    else
+    {
+        m_sendUpdate = false;
+        int32 entry = LANG_BG_WG_DEFENDED;
+
+        if (m_changeDefender)
+        {
+            m_changeDefender = false;
+            m_defender = getAttackerTeam();
+            entry = LANG_BG_WG_CAPTURED;
+        }
+
+        if (isWarTime())
+        {
+            if (m_timer != 1) // 1 = forceStopBattle
+                sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(entry), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+            EndBattle();
+        }
+        else
+        {
+            if (m_timer != 1) // 1 = forceStartBattle
+                sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
+            StartBattle();
+        }
+
+        UpdateAllWorldObject();
+        UpdateClock();
+
+        SendInitWorldStatesTo();
+        m_sendUpdate = true;
+    }
+
+    if (m_WSSaveTimer < diff)
+    {
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31001', `value`='%d', `comment`='wg m_wartime'",m_wartime);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31002', `value`='%d', `comment`='wg m_timer'",m_timer);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31003', `value`='%d', `comment`='wg m_defender'",m_defender);
+        m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+    } else m_WSSaveTimer -= diff;
+
+
+    return false;
+}
+
+void OutdoorPvPWG::forceStartBattle()
+{ // Uptime will do all the work
+    m_wartime = false;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
+    }
+		sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceStopBattle()
+{ // Uptime will do all the work.
+
+    if (!isWarTime())
+        m_wartime = true;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
+    }
+	sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceChangeTeam()
+{
+    m_changeDefender = true;
+    m_timer = 1;
+    sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr.GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+    if (isWarTime())
+        forceStartBattle();
+    else
+        forceStopBattle();
+}
+
+// Can be forced by gm's while in battle so have to reset in case it was wartime
+void OutdoorPvPWG::StartBattle()
+{
+	uint32 CountDef=0;
+	uint32 CountAtk=0;
+    m_wartime = true;
+    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
+
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+       if ((*itr)->getLevel() < 75)
+        {
+          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        }
+       else
+        {
+          CountDef++;
+          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        if ((*itr)->getLevel() < 75)
+        {
+          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        }
+        else
+        {
+          CountAtk++;
+          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+if (sWorld.getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
+ {
+ if ((CountAtk < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
+  {
+   if (CountAtk<=CountDef)
+	   sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
+   if (CountDef<CountAtk)
+     {  
+	 sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
+	 m_changeDefender=true;
+     }
+   forceStopBattle();
+   return;
+  }
+ }
+
+//    TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
+
+    // Remove Essence of Wintergrasp to all players
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+    sWorld.UpdateAreaDependentAuras();
+
+    // destroyed all vehicles
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+        {
+            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+    }
+    UpdateTenacityStack();
+	// Update timer in players battlegrounds tab
+    sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::EndBattle()
+{
+    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    sWorld.UpdateAreaDependentAuras();
+//Sound on End Battle
+for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+{
+	if (getDefenderTeam()==TEAM_ALLIANCE)
+	{
+    TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
+	}
+    else TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
+	(*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
+}
+for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+{
+   (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
+}
+
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // destroyed all vehicles
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+
+        if (m_players[team].empty())
+            continue;
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            // When WG ends the zone is cleaned including corpses, revive all players if dead
+            if ((*itr)->isDead())
+            {
+                (*itr)->ResurrectPlayer(1.0f);
+				sObjectAccessor.ConvertCorpseForPlayer((*itr)->GetGUID());
+                //ObjectAccessor::Instance().ConvertCorpseForPlayer((*itr)->GetGUID());
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+            (*itr)->CombatStop(true);
+            (*itr)->getHostileRefManager().deleteReferences();
+        }
+
+        if (m_timer == 1) // Battle End was forced so no reward.
+        {
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+            continue;
+        }
+
+        // calculate rewards
+        uint32 intactNum = 0;
+        uint32 damagedNum = 0;
+        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                if (workshop->m_buildingState->GetTeam() == team)
+                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
+                        ++damagedNum;
+                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
+                        ++intactNum;
+
+        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
+        uint32 baseHonor = 0;
+        uint32 marks = 0;
+        uint32 playersWithRankNum = 0;
+        uint32 honor = 0;
+
+        if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+        {
+            // Calculate Level 70+ with Corporal or Lieutenant rank
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
+                    ++playersWithRankNum;
+
+            baseHonor = team == getDefenderTeam() ? sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
+            if (playersWithRankNum)
+                baseHonor /= playersWithRankNum;
+        }
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+
+            if ((*itr)->getLevel() < 75)
+                continue; // No rewards for level <75
+
+            // give rewards
+            if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+            {
+                if (team == getDefenderTeam())
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 3;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 2;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 1;
+                        honor = 0;
+                    }
+                }
+                else
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 0;
+                        honor = 0;
+                    }
+                }
+                (*itr)->RewardHonor(NULL, 1, honor);
+                RewardMarkOfHonor(*itr, marks);
+                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
+            }
+            else
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    // TODO - Honor from SpellReward should be shared by team players
+                    // TODO - Marks should be given depending on Rank but 3 are given
+                    // each time so Won't give any to recruits
+                    (*itr)->CastSpell(*itr, spellRewardId, true);
+                    for (uint32 i = 0; i < intactNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
+                    for (uint32 i = 0; i < damagedNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
+                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
+                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
+                }
+            }
+            if (team == getDefenderTeam())
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
+                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
+                }
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        }
+    }
+
+    m_wartime = false;
+    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
+    RemoveOfflinePlayerWGAuras();
+    // Update timer in players battlegrounds tab
+    sWorld.SendWintergraspState();
+}
+
+bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
+{
+    TeamId team = workshop->m_buildingState->GetTeam();
+    if (team == TEAM_NEUTRAL)
+        return false;
+
+    return isWarTime()
+        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
+        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
+}
+
+uint32 OutdoorPvPWG::GetData(uint32 id)
+{
+    // if can build more vehicles
+    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
+        return CanBuildVehicle(workshop) ? 1 : 0;
+
+    return 0;
+}
+
+void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return;
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        sLog.outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
+{
+    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
+    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
+    m_questgivers[guid] = NULL;
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+        sObjectMgr.MoveCreData(guid, 571, posAlli);
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
+{
+    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
+        return dynamic_cast<OPvPCapturePointWG*>(cp);
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_engGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_workshopGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+/*########################################################
+ * Copy of Battleground system to make Spirit Guides Work
+ *#######################################################*/
+void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    pl->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player *plr = sObjectMgr.GetPlayer(player_guid);
+    if (!plr)
+        return;
+
+    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+
+                Player *plr = sObjectMgr.GetPlayer(player_guid);
+                if (!plr)
+                    return;
+
+                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+
+                return;
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr.GetPlayer(*itr);
+			if (!plr)
+                continue;
+
+			if (plr->getFaction() == ALLIANCE)
+			{
+            if (!ClosestGrave)
+                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+			}
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr.GetPlayer(*itr);
+			if (!plr)
+                continue;
+
+			if (plr->getFaction() == HORDE)
+			{
+            if (!ClosestGrave)
+                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+			}
+        }
+    }
+}
+
+/*######
+##OPvPCapturePointWG
+######*/
+
+OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state)
+: OPvPCapturePoint(opvp), m_buildingState(state), m_wintergrasp(opvp)
+, m_engineer(NULL), m_engGuid(0), m_spiritguide(NULL)
+, m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_spiGuid(0)
+{
+}
+
+void OPvPCapturePointWG::SetTeamByBuildingState()
+{
+    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
+    {
+        m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+    }
+    else if (m_buildingState->GetTeam() == TEAM_HORDE)
+    {
+        m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+    }
+    else
+    {
+        m_value = 0;
+        m_State = OBJECTIVESTATE_NEUTRAL;
+    }
+
+    if (m_team != m_buildingState->GetTeam())
+    {
+        TeamId oldTeam = m_team;
+        m_team = m_buildingState->GetTeam();
+        ChangeTeam(oldTeam);
+    }
+
+    SendChangePhase();
+}
+
+void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
+{
+   entry = 0;
+   guide_entry = 0;
+   guide_entry_fortress_horde = 0;
+   guide_entry_fortress_alliance = 0;
+
+    if (oldTeam != TEAM_NEUTRAL)
+        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
+
+    if (m_team != TEAM_NEUTRAL)
+    {
+        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
+        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
+        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
+        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
+        m_wintergrasp->ModifyWorkshopCount(m_team, true);
+    }
+
+    if (m_capturePoint)
+        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
+
+    m_buildingState->SetTeam(m_team);
+    // TODO: this may be sent twice
+    m_wintergrasp->BroadcastStateChange(m_buildingState);
+
+    if (m_buildingState->building)
+        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
+
+    if (entry)
+    {
+        if (m_engGuid)
+        {
+            *m_engEntry = entry;
+            _RespawnCreatureIfNeeded(m_engineer, entry);
+        }
+        if (m_spiGuid)
+        {
+         if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
+         {
+            *m_spiEntry = guide_entry;
+            _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
+            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
+            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
+         }
+         else
+         {
+            *m_spiEntry = guide_entry;
+            _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
+            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
+            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
+         }
+        }
+    }
+    else if (m_engineer)
+        m_engineer->SetVisibility(VISIBILITY_OFF);
+
+    sLog.outDebug("Wintergrasp workshop now belongs to %u.", (uint32)m_buildingState->GetTeam());
+}
+
+class OutdoorPvP_wintergrasp : public OutdoorPvPScript
+{
+    public:
+
+        OutdoorPvP_wintergrasp()
+            : OutdoorPvPScript("outdoorpvp_wg")
+        {
+        }
+
+        OutdoorPvP* GetOutdoorPvP() const
+        {
+            return new OutdoorPvPWG();
+        }
+};
+
+void AddSC_outdoorpvp_wg()
+{
+    new OutdoorPvP_wintergrasp();
 }
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
--- a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
@@ -1,351 +1,351 @@
-/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
- */
-
-#ifndef OUTDOOR_PVP_WG_
-#define OUTDOOR_PVP_WG_
-
-#include "OutdoorPvP.h"
-#include "BattlegroundMgr.h"
-#include "Player.h"
-
-#define ZONE_DALARAN             4395
-#define ZONE_WINTERGRASP         4197
-#define POS_X_CENTER             5100
-#define MAX_VEHICLE_PER_WORKSHOP    4
-
-const uint32 WintergraspFaction[3] = {1802, 1801, 35};
-const uint32 WG_MARK_OF_HONOR = 43589;
-const uint32 VehNumWorldState[2] = {3680,3490};
-const uint32 MaxVehNumWorldState[2] = {3681,3491};
-const uint32 ClockWorldState[2] = {3781,4354};
-
-enum OutdoorPvPWGSpell
-{
-    // Wartime auras
-    SPELL_RECRUIT                                = 37795,
-    SPELL_CORPORAL                               = 33280,
-    SPELL_LIEUTENANT                             = 55629,
-    SPELL_TENACITY                               = 58549,
-    SPELL_TENACITY_VEHICLE                       = 59911,
-    SPELL_TOWER_CONTROL                          = 62064,
-    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
-
-    // Reward spells
-    SPELL_VICTORY_REWARD                         = 56902,
-    SPELL_DEFEAT_REWARD                          = 58494,
-    SPELL_DAMAGED_TOWER                          = 59135,
-    SPELL_DESTROYED_TOWER                        = 59136,
-    SPELL_DAMAGED_BUILDING                       = 59201,
-    SPELL_INTACT_BUILDING                        = 59203,
-
-	SPELL_TELEPORT_ALLIENCE_CAMP                 = 58632,
-	SPELL_TELEPORT_HORDE_CAMP                    = 58633,
-    SPELL_TELEPORT_FORTRESS                      = 59096,
-
-    SPELL_TELEPORT_DALARAN                       = 53360,
-    SPELL_VICTORY_AURA                           = 60044,
-};
-
-const uint16 GameEventWintergraspDefender[2] = {50, 51};
-
-enum OutdoorPvP_WG_Sounds
-{
-    OutdoorPvP_WG_SOUND_KEEP_CLAIMED            = 8192,
-    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE  = 8173,
-    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE     = 8213,
-    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE = 8212,
-    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE    = 8174,
-    OutdoorPvP_WG_SOUND_NEAR_VICTORY            = 8456,
-    OutdoorPvP_WG_SOUND_HORDE_WINS              = 8454,
-    OutdoorPvP_WG_SOUND_ALLIANCE_WINS           = 8455,
-    OutdoorPvP_WG_SOUND_WORKSHOP_Horde          = 6205, //   
-    OutdoorPvP_WG_SOUND_WORKSHOP_ALLIANCE       = 6298, //   
-    OutdoorPvP_WG_HORDE_CAPTAIN                 = 8333,
-    OutdoorPvP_WG_ALLIANCE_CAPTAIN              = 8232,
-//    OutdoorPvP_WG_SOUND_START_BATTLE            = 11803,   //L70ETC Concert
-    OutdoorPvP_WG_SOUND_START_BATTLE            = 3439, //Standart BG Start sound
-};
-
-enum DataId
-{
-    DATA_ENGINEER_DIE,
-};
-
-enum OutdoorPvP_WG_KeepStatus
-{
-    OutdoorPvP_WG_KEEP_TYPE_NEUTRAL             = 0,
-    OutdoorPvP_WG_KEEP_TYPE_CONTESTED           = 1,
-    OutdoorPvP_WG_KEEP_STATUS_ALLY_CONTESTED    = 1,
-    OutdoorPvP_WG_KEEP_STATUS_HORDE_CONTESTED   = 2,
-    OutdoorPvP_WG_KEEP_TYPE_OCCUPIED            = 3,
-    OutdoorPvP_WG_KEEP_STATUS_ALLY_OCCUPIED     = 3,
-    OutdoorPvP_WG_KEEP_STATUS_HORDE_OCCUPIED    = 4
-};
-
-
-enum OutdoorPVPWGStatus
-{
- WORLDSTATE_WINTERGRASP_CONTROLING_FACTION,
- WORLDSTATE_VALUE_COUNT,
-};
-
-enum OutdoorPvPWGCreType
-{
-    CREATURE_OTHER,
-    CREATURE_SIEGE_VEHICLE,
-    CREATURE_TURRET,
-    CREATURE_ENGINEER,
-    CREATURE_GUARD,
-    CREATURE_SPECIAL,
-    CREATURE_SPIRIT_GUIDE,
-    CREATURE_SPIRIT_HEALER,
-    CREATURE_QUESTGIVER,
-};
-
-enum OutdoorPvPWGBuildingType
-{
-    BUILDING_WALL,
-    BUILDING_WORKSHOP,
-    BUILDING_TOWER,
-};
-
-enum OutdoorPvPWGDamageState
-{ // Do not change order
-    DAMAGE_INTACT,
-    DAMAGE_DAMAGED,
-    DAMAGE_DESTROYED,
-};
-
-typedef uint32 TeamPair[2];
-
-enum OutdoorPvPWGQuest
-{
-    A_VICTORY_IN_WG                              = 13181,
-    H_VICTORY_IN_WG                              = 13183,
-    CRE_PVP_KILL                                 = 31086, //Quest Objective - Fixme: this should be handled by DB
-    CRE_PVP_KILL_V                               = 31093, //Quest Objective - Fixme: this should be handled by DB
-};
-
-enum OutdoorPvPWGCreEntry
-{
-    CRE_ENG_A                                    = 30499,
-    CRE_ENG_H                                    = 30400,
-    CRE_SPI_A                                    = 31842,
-    CRE_SPI_H                                    = 31841,
-};
-
-const TeamPair OutdoorPvPWGCreEntryPair[] =
-{
-    {32307, 32308}, // Guards
-    {30739, 30740}, // Champions
-    {32296, 32294}, // Quartermaster
-    {39173, 39172}, // Ros'slai & Marshal Magruder
-    {32615, 32626}, // Warbringer & Brigadier General
-    {0,0} // Do not delete Used in LoadTeamPair
-};
-
-const TeamPair OutdoorPvPWGGODisplayPair[] =
-{
-    {5651, 5652},
-    {8256, 8257},
-    {0,0} // Do not delete Used in LoadTeamPair
-};
-
-const uint32 AreaPOIIconId[3][3] = {{7,8,9},{4,5,6},{1,2,3}};
-typedef std::list<const AreaPOIEntry *> AreaPOIList;
-
-struct BuildingState
-{
-    explicit BuildingState(uint32 _worldState, TeamId _team, bool asDefault)
-        : worldState(_worldState), health(0)
-        , defaultTeam(asDefault ? _team : OTHER_TEAM(_team)), team(_team), damageState(DAMAGE_INTACT)
-        , building(NULL), type(BUILDING_WALL), graveTeam(NULL)
-    {}
-    uint32 worldState;
-    uint32 health;
-    TeamId defaultTeam;
-    OutdoorPvPWGDamageState damageState;
-    GameObject *building;
-    uint32 *graveTeam;
-    OutdoorPvPWGBuildingType type;
-
-    void SendUpdate(Player *player) const
-    {
-        player->SendUpdateWorldState(worldState, AreaPOIIconId[team][damageState]);
-    }
-
-    void FillData(WorldPacket &data) const
-    {
-        data << worldState << AreaPOIIconId[team][damageState];
-    }
-
-    TeamId GetTeam() const { return team; }
-    void SetTeam(TeamId t)
-    {
-        team = t;
-        if(graveTeam)
-            if (uint32 newTeam = TeamId2Team[t])
-                *graveTeam = newTeam;
-    }
-
-private:
-    TeamId team;
-};
-
-typedef std::map<uint32, uint32> TeamPairMap;
-
-class OPvPCapturePointWG;
-
-class OutdoorPvPWG : public OutdoorPvP
-{
-    protected:
-        typedef std::map<uint32, BuildingState *> BuildingStateMap;
-        typedef std::set<Creature*> CreatureSet;
-        typedef std::set<GameObject*> GameObjectSet;
-        typedef std::map<std::pair<uint32, bool>, Position> QuestGiverPositionMap;
-        typedef std::map<uint32, Creature*> QuestGiverMap;
-    public:
-        OutdoorPvPWG();
-        bool SetupOutdoorPvP();
-        int TeamIDsound;
-        uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data);
-
-        void OnCreatureCreate(Creature *creature, bool add);
-        void OnGameObjectCreate(GameObject *go, bool add);
-
-        void ProcessEvent(GameObject *obj, uint32 eventId);
-
-        void HandlePlayerEnterZone(Player *plr, uint32 zone);
-        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
-        void HandlePlayerResurrects(Player * plr, uint32 zone);
-        void HandleKill(Player *killer, Unit *victim);
-
-        bool Update(uint32 diff);
-
-        void BroadcastStateChange(BuildingState *state) const;
-
-        uint32 GetData(uint32 id);
-        void SetData(uint32 id, uint32 value) {};
-
-        void ModifyWorkshopCount(TeamId team, bool add);
-        uint32 GetTimer() const { return m_timer / 1000; };
-        bool isWarTime() const { return m_wartime; };
-        void setTimer(uint32 timer) { if (timer >= 0) m_timer = timer; };
-        uint32 GetNumPlayersA() const { return m_players[TEAM_ALLIANCE].size(); };
-        uint32 GetNumPlayersH() const { return m_players[TEAM_HORDE].size(); };
-        TeamId getDefenderTeam() const { return m_defender; };
-        TeamId getAttackerTeam() const { return OTHER_TEAM(m_defender); };
-        void forceChangeTeam();
-        void forceStopBattle();
-        void forceStartBattle();
-
-        // Temporal BG specific till 3.2
-        void SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid);
-        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
-        void RemovePlayerFromResurrectQueue(uint64 player_guid);
-        void RelocateAllianceDeadPlayers(Creature *cr);
-        void RelocateHordeDeadPlayers(Creature *cr);
-        // BG end
-        void SendInitWorldStatesTo(Player *player = NULL) const;
-        uint32 m_timer;
-    protected:
-        // Temporal BG specific till 3.2
-        std::vector<uint64> m_ResurrectQueue;               // Player GUID
-        uint32 m_LastResurrectTime;
-        // Spirit Guide guid + Player list GUIDS
-        std::map<uint64, std::vector<uint64> >  m_ReviveQueue;
-
-        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
-        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
-        // BG end
-
-        TeamId m_defender;
-        int32 m_tenacityStack;
-
-        BuildingStateMap m_buildingStates;
-        BuildingState *m_gate;
-
-        CreatureSet m_creatures;
-        CreatureSet m_vehicles[2];
-        GameObjectSet m_gobjects;
-        QuestGiverMap m_questgivers;
-
-        TeamPairMap m_creEntryPair, m_goDisplayPair;
-        QuestGiverPositionMap m_qgPosMap;
-
-        bool m_wartime;
-        bool m_changeDefender;
-        uint32 m_clock[2];
-        uint32 m_workshopCount[2];
-        uint32 m_towerDestroyedCount[2];
-        uint32 m_towerDamagedCount[2];
-		uint32 m_WSSaveTimer;
-
-        OPvPCapturePointWG *GetWorkshop(uint32 lowguid) const;
-        OPvPCapturePointWG *GetWorkshopByEngGuid(uint32 lowguid) const;
-        OPvPCapturePointWG *GetWorkshopByGOGuid(uint64 lowguid) const;
-
-        void StartBattle();
-        void EndBattle();
-
-        void UpdateClock();
-        void UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod);
-        void PromotePlayer(Player *player) const;
-        void UpdateTenacityStack();
-        void UpdateAllWorldObject();
-        bool UpdateCreatureInfo(Creature *creature);
-        bool UpdateGameObjectInfo(GameObject *go) const;
-
-        bool CanBuildVehicle(OPvPCapturePointWG *workshop) const;
-        OutdoorPvPWGCreType GetCreatureType(uint32 entry) const;
-
-        void RebuildAllBuildings();
-
-        void RemoveOfflinePlayerWGAuras();
-        void RewardMarkOfHonor(Player *player, uint32 count);
-        void MoveQuestGiver(uint32 guid);
-        void LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli);
-        bool UpdateQuestGiverPosition(uint32 guid, Creature *creature);
-};
-
-class OPvPCapturePointWG : public OPvPCapturePoint
-{
-    public:
-        explicit OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state);
-        void SetTeamByBuildingState();
-        void ChangeState() {}
-        void ChangeTeam(TeamId oldteam);
-
-        uint32 *m_spiEntry;
-        uint32 m_spiGuid;
-        Creature *m_spiritguide;
-        Creature *m_spiritguide_horde;
-        Creature *m_spiritguide_alliance;
-
-        uint32 *m_engEntry;
-        uint32 m_engGuid;
-        Creature *m_engineer;
-        uint32 m_workshopGuid;
-        BuildingState *m_buildingState;
-    protected:
-        OutdoorPvPWG *m_wintergrasp;
-};
-
-#endif
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ */
+
+#ifndef OUTDOOR_PVP_WG_
+#define OUTDOOR_PVP_WG_
+
+#include "OutdoorPvP.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+
+#define ZONE_DALARAN             4395
+#define ZONE_WINTERGRASP         4197
+#define POS_X_CENTER             5100
+#define MAX_VEHICLE_PER_WORKSHOP    4
+
+const uint32 WintergraspFaction[3] = {1802, 1801, 35};
+const uint32 WG_MARK_OF_HONOR = 43589;
+const uint32 VehNumWorldState[2] = {3680,3490};
+const uint32 MaxVehNumWorldState[2] = {3681,3491};
+const uint32 ClockWorldState[2] = {3781,4354};
+
+enum OutdoorPvPWGSpell
+{
+    // Wartime auras
+    SPELL_RECRUIT                                = 37795,
+    SPELL_CORPORAL                               = 33280,
+    SPELL_LIEUTENANT                             = 55629,
+    SPELL_TENACITY                               = 58549,
+    SPELL_TENACITY_VEHICLE                       = 59911,
+    SPELL_TOWER_CONTROL                          = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                         = 56902,
+    SPELL_DEFEAT_REWARD                          = 58494,
+    SPELL_DAMAGED_TOWER                          = 59135,
+    SPELL_DESTROYED_TOWER                        = 59136,
+    SPELL_DAMAGED_BUILDING                       = 59201,
+    SPELL_INTACT_BUILDING                        = 59203,
+
+	SPELL_TELEPORT_ALLIENCE_CAMP                 = 58632,
+	SPELL_TELEPORT_HORDE_CAMP                    = 58633,
+    SPELL_TELEPORT_FORTRESS                      = 59096,
+
+    SPELL_TELEPORT_DALARAN                       = 53360,
+    SPELL_VICTORY_AURA                           = 60044,
+};
+
+const uint16 GameEventWintergraspDefender[2] = {50, 51};
+
+enum OutdoorPvP_WG_Sounds
+{
+    OutdoorPvP_WG_SOUND_KEEP_CLAIMED            = 8192,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE  = 8173,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE     = 8213,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE = 8212,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE    = 8174,
+    OutdoorPvP_WG_SOUND_NEAR_VICTORY            = 8456,
+    OutdoorPvP_WG_SOUND_HORDE_WINS              = 8454,
+    OutdoorPvP_WG_SOUND_ALLIANCE_WINS           = 8455,
+    OutdoorPvP_WG_SOUND_WORKSHOP_Horde          = 6205, //   
+    OutdoorPvP_WG_SOUND_WORKSHOP_ALLIANCE       = 6298, //   
+    OutdoorPvP_WG_HORDE_CAPTAIN                 = 8333,
+    OutdoorPvP_WG_ALLIANCE_CAPTAIN              = 8232,
+//    OutdoorPvP_WG_SOUND_START_BATTLE            = 11803,   //L70ETC Concert
+    OutdoorPvP_WG_SOUND_START_BATTLE            = 3439, //Standart BG Start sound
+};
+
+enum DataId
+{
+    DATA_ENGINEER_DIE,
+};
+
+enum OutdoorPvP_WG_KeepStatus
+{
+    OutdoorPvP_WG_KEEP_TYPE_NEUTRAL             = 0,
+    OutdoorPvP_WG_KEEP_TYPE_CONTESTED           = 1,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_CONTESTED    = 1,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_CONTESTED   = 2,
+    OutdoorPvP_WG_KEEP_TYPE_OCCUPIED            = 3,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_OCCUPIED     = 3,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_OCCUPIED    = 4
+};
+
+
+enum OutdoorPVPWGStatus
+{
+ WORLDSTATE_WINTERGRASP_CONTROLING_FACTION,
+ WORLDSTATE_VALUE_COUNT,
+};
+
+enum OutdoorPvPWGCreType
+{
+    CREATURE_OTHER,
+    CREATURE_SIEGE_VEHICLE,
+    CREATURE_TURRET,
+    CREATURE_ENGINEER,
+    CREATURE_GUARD,
+    CREATURE_SPECIAL,
+    CREATURE_SPIRIT_GUIDE,
+    CREATURE_SPIRIT_HEALER,
+    CREATURE_QUESTGIVER,
+};
+
+enum OutdoorPvPWGBuildingType
+{
+    BUILDING_WALL,
+    BUILDING_WORKSHOP,
+    BUILDING_TOWER,
+};
+
+enum OutdoorPvPWGDamageState
+{ // Do not change order
+    DAMAGE_INTACT,
+    DAMAGE_DAMAGED,
+    DAMAGE_DESTROYED,
+};
+
+typedef uint32 TeamPair[2];
+
+enum OutdoorPvPWGQuest
+{
+    A_VICTORY_IN_WG                              = 13181,
+    H_VICTORY_IN_WG                              = 13183,
+    CRE_PVP_KILL                                 = 31086, //Quest Objective - Fixme: this should be handled by DB
+    CRE_PVP_KILL_V                               = 31093, //Quest Objective - Fixme: this should be handled by DB
+};
+
+enum OutdoorPvPWGCreEntry
+{
+    CRE_ENG_A                                    = 30499,
+    CRE_ENG_H                                    = 30400,
+    CRE_SPI_A                                    = 31842,
+    CRE_SPI_H                                    = 31841,
+};
+
+const TeamPair OutdoorPvPWGCreEntryPair[] =
+{
+    {32307, 32308}, // Guards
+    {30739, 30740}, // Champions
+    {32296, 32294}, // Quartermaster
+    {39173, 39172}, // Ros'slai & Marshal Magruder
+    {32615, 32626}, // Warbringer & Brigadier General
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const TeamPair OutdoorPvPWGGODisplayPair[] =
+{
+    {5651, 5652},
+    {8256, 8257},
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const uint32 AreaPOIIconId[3][3] = {{7,8,9},{4,5,6},{1,2,3}};
+typedef std::list<const AreaPOIEntry *> AreaPOIList;
+
+struct BuildingState
+{
+    explicit BuildingState(uint32 _worldState, TeamId _team, bool asDefault)
+        : worldState(_worldState), health(0)
+        , defaultTeam(asDefault ? _team : OTHER_TEAM(_team)), team(_team), damageState(DAMAGE_INTACT)
+        , building(NULL), type(BUILDING_WALL), graveTeam(NULL)
+    {}
+    uint32 worldState;
+    uint32 health;
+    TeamId defaultTeam;
+    OutdoorPvPWGDamageState damageState;
+    GameObject *building;
+    uint32 *graveTeam;
+    OutdoorPvPWGBuildingType type;
+
+    void SendUpdate(Player *player) const
+    {
+        player->SendUpdateWorldState(worldState, AreaPOIIconId[team][damageState]);
+    }
+
+    void FillData(WorldPacket &data) const
+    {
+        data << worldState << AreaPOIIconId[team][damageState];
+    }
+
+    TeamId GetTeam() const { return team; }
+    void SetTeam(TeamId t)
+    {
+        team = t;
+        if(graveTeam)
+            if (uint32 newTeam = TeamId2Team[t])
+                *graveTeam = newTeam;
+    }
+
+private:
+    TeamId team;
+};
+
+typedef std::map<uint32, uint32> TeamPairMap;
+
+class OPvPCapturePointWG;
+
+class OutdoorPvPWG : public OutdoorPvP
+{
+    protected:
+        typedef std::map<uint32, BuildingState *> BuildingStateMap;
+        typedef std::set<Creature*> CreatureSet;
+        typedef std::set<GameObject*> GameObjectSet;
+        typedef std::map<std::pair<uint32, bool>, Position> QuestGiverPositionMap;
+        typedef std::map<uint32, Creature*> QuestGiverMap;
+    public:
+        OutdoorPvPWG();
+        bool SetupOutdoorPvP();
+        int TeamIDsound;
+        uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data);
+
+        void OnCreatureCreate(Creature *creature, bool add);
+        void OnGameObjectCreate(GameObject *go, bool add);
+
+        void ProcessEvent(GameObject *obj, uint32 eventId);
+
+        void HandlePlayerEnterZone(Player *plr, uint32 zone);
+        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+        void HandlePlayerResurrects(Player * plr, uint32 zone);
+        void HandleKill(Player *killer, Unit *victim);
+
+        bool Update(uint32 diff);
+
+        void BroadcastStateChange(BuildingState *state) const;
+
+        uint32 GetData(uint32 id);
+        void SetData(uint32 id, uint32 value) {};
+
+        void ModifyWorkshopCount(TeamId team, bool add);
+        uint32 GetTimer() const { return m_timer / 1000; };
+        bool isWarTime() const { return m_wartime; };
+        void setTimer(uint32 timer) { if (timer >= 0) m_timer = timer; };
+        uint32 GetNumPlayersA() const { return m_players[TEAM_ALLIANCE].size(); };
+        uint32 GetNumPlayersH() const { return m_players[TEAM_HORDE].size(); };
+        TeamId getDefenderTeam() const { return m_defender; };
+        TeamId getAttackerTeam() const { return OTHER_TEAM(m_defender); };
+        void forceChangeTeam();
+        void forceStopBattle();
+        void forceStartBattle();
+
+        // Temporal BG specific till 3.2
+        void SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid);
+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+        void RemovePlayerFromResurrectQueue(uint64 player_guid);
+        void RelocateAllianceDeadPlayers(Creature *cr);
+        void RelocateHordeDeadPlayers(Creature *cr);
+        // BG end
+        void SendInitWorldStatesTo(Player *player = NULL) const;
+        uint32 m_timer;
+    protected:
+        // Temporal BG specific till 3.2
+        std::vector<uint64> m_ResurrectQueue;               // Player GUID
+        uint32 m_LastResurrectTime;
+        // Spirit Guide guid + Player list GUIDS
+        std::map<uint64, std::vector<uint64> >  m_ReviveQueue;
+
+        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
+        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
+        // BG end
+
+        TeamId m_defender;
+        int32 m_tenacityStack;
+
+        BuildingStateMap m_buildingStates;
+        BuildingState *m_gate;
+
+        CreatureSet m_creatures;
+        CreatureSet m_vehicles[2];
+        GameObjectSet m_gobjects;
+        QuestGiverMap m_questgivers;
+
+        TeamPairMap m_creEntryPair, m_goDisplayPair;
+        QuestGiverPositionMap m_qgPosMap;
+
+        bool m_wartime;
+        bool m_changeDefender;
+        uint32 m_clock[2];
+        uint32 m_workshopCount[2];
+        uint32 m_towerDestroyedCount[2];
+        uint32 m_towerDamagedCount[2];
+		uint32 m_WSSaveTimer;
+
+        OPvPCapturePointWG *GetWorkshop(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByEngGuid(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByGOGuid(uint64 lowguid) const;
+
+        void StartBattle();
+        void EndBattle();
+
+        void UpdateClock();
+        void UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod);
+        void PromotePlayer(Player *player) const;
+        void UpdateTenacityStack();
+        void UpdateAllWorldObject();
+        bool UpdateCreatureInfo(Creature *creature);
+        bool UpdateGameObjectInfo(GameObject *go) const;
+
+        bool CanBuildVehicle(OPvPCapturePointWG *workshop) const;
+        OutdoorPvPWGCreType GetCreatureType(uint32 entry) const;
+
+        void RebuildAllBuildings();
+
+        void RemoveOfflinePlayerWGAuras();
+        void RewardMarkOfHonor(Player *player, uint32 count);
+        void MoveQuestGiver(uint32 guid);
+        void LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli);
+        bool UpdateQuestGiverPosition(uint32 guid, Creature *creature);
+};
+
+class OPvPCapturePointWG : public OPvPCapturePoint
+{
+    public:
+        explicit OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state);
+        void SetTeamByBuildingState();
+        void ChangeState() {}
+        void ChangeTeam(TeamId oldteam);
+
+        uint32 *m_spiEntry;
+        uint32 m_spiGuid;
+        Creature *m_spiritguide;
+        Creature *m_spiritguide_horde;
+        Creature *m_spiritguide_alliance;
+
+        uint32 *m_engEntry;
+        uint32 m_engGuid;
+        Creature *m_engineer;
+        uint32 m_workshopGuid;
+        BuildingState *m_buildingState;
+    protected:
+        OutdoorPvPWG *m_wintergrasp;
+};
+
+#endif
