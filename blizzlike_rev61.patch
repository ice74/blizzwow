# HG changeset patch
# User asniker
# Date 1286812790 -21600
# Node ID a9316a14d4df8be6855f2b3e9476d6c8f002fe3c
# Parent  eb66c890d6503ace3b1b4a63c596f2e9cad2f2c5
оло антифарм

diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
--- a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
@@ -1,2129 +1,2129 @@
-/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
- * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
- */
-
-#include "OutdoorPvPWG.h"
-#include "SpellAuras.h"
-#include "Vehicle.h"
-#include "ObjectMgr.h"
-#include "World.h"
-#include "Chat.h"
-#include "MapManager.h"
-#include "ScriptedCreature.h"
-#include "ScriptPCH.h"
-
-Creature* FortressSpirit;
-uint32 entry;
-uint32 guide_entry;
-uint32 guide_entry_fortress_horde;
-uint32 guide_entry_fortress_alliance;
-
-OutdoorPvPWG::OutdoorPvPWG()
-{
-    m_TypeId = OUTDOOR_PVP_WG;
-    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
-}
-
-void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
-{
-    while((*pair)[0])
-    {
-        pairMap[(*pair)[0]] = (*pair)[1];
-        pairMap[(*pair)[1]] = (*pair)[0];
-        ++pair;
-    }
-}
-
-void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
-{
-    if (cr)
-    {
-        cr->SetOriginalEntry(entry);
-        if (entry != cr->GetEntry() || !cr->isAlive())
-            cr->Respawn(true);
-        cr->SetVisibility(VISIBILITY_ON);
-    }
-}
-
-bool OutdoorPvPWG::SetupOutdoorPvP()
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-    {
-        sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
-        return false;
-    }
-
-    //load worlstates
-    QueryResult result = CharacterDatabase.PQuery("SELECT `entry`, `value` from `worldstates` where `entry` in ('31001','31002','31003') order by `entry`");
-    
-    m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
-
-    if (result)
-    {
-        do
-        {
-            Field *fields = result->Fetch();
-            switch (fields[0].GetUInt32())
-            {
-                case 31001:
-                    m_wartime = fields[1].GetBool();
-                    break;
-                case 31002:
-                    m_timer = fields[1].GetUInt32();
-                    break;
-                case 31003:
-                    m_defender = TeamId(fields[1].GetUInt32());
-                    break;
-            }
-        }while(result->NextRow());
-    }
-    else
-    {
-        m_wartime = false;
-        m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
-        m_defender = TeamId(rand()%2);
-    }
-
-    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
-    m_changeDefender = false;
-    m_workshopCount[TEAM_ALLIANCE] = 0;
-    m_workshopCount[TEAM_HORDE] = 0;
-    m_tenacityStack = 0;
-    m_gate = NULL;
-
-    std::list<uint32> engGuids;
-    std::list<uint32> spiritGuids;
-
-    // Store Eng, spirit guide guids and questgiver for later use
-    result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
-         " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
-         CRE_ENG_A, CRE_ENG_H, CRE_SPI_A, CRE_SPI_H, 31101, 31051, 31102, 31052,
-         31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
-    if (!result)
-        sLog.outError("Cannot find siege workshop master or spirit guides in creature!");
-    else
-    {
-        do
-        {
-            Position posHorde, posAlli;
-            Field *fields = result->Fetch();
-            switch(fields[1].GetUInt32())
-            {
-                case CRE_ENG_A:
-                case CRE_ENG_H:
-                    engGuids.push_back(fields[0].GetUInt32());
-                    break;
-                case CRE_SPI_A:
-                case CRE_SPI_H:
-                    spiritGuids.push_back(fields[0].GetUInt32());
-                    break;
-                case 31051:
-                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
-                    posAlli.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31101:
-                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
-                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31052:
-                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
-                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31102:
-                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
-                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31109:
-                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
-                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31107:
-                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
-                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31153:
-                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
-                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31151:
-                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
-                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31108:
-                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
-                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31106:
-                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
-                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31054:
-                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
-                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31053:
-                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
-                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31036:
-                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
-                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                case 31091:
-                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
-                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
-                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
-                    break;
-                default:
-                    break;
-            }
-        }while(result->NextRow());
-    }
-
-    // Select POI
-    AreaPOIList areaPOIs;
-    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
-    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
-    {
-        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
-        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
-        {
-            areaPOIs.push_back(poiInfo);
-            if (minX > poiInfo->x) minX = poiInfo->x;
-            if (minY > poiInfo->y) minY = poiInfo->y;
-            if (maxX < poiInfo->x) maxX = poiInfo->x;
-            if (maxY < poiInfo->y) maxY = poiInfo->y;
-        }
-    }
-    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
-
-    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
-    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
-        " WHERE gameobject.map=571"
-        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
-        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
-        " AND gameobject_template.type=33"
-        " AND gameobject.id=gameobject_template.entry",
-        minX, minY, maxX, maxY);
-    if (!result)
-        return false;
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        uint32 guid = fields[0].GetUInt32();
-        GameObjectData const * goData = sObjectMgr.GetGOData(guid);
-        if (!goData) // this should not happen
-            continue;
-
-        float x = goData->posX, y = goData->posY;
-        float minDist = 100;
-        AreaPOIList::iterator poi = areaPOIs.end();
-        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
-        {
-            if (!(*itr)->icon[1]) // note: may for other use
-                continue;
-
-            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
-            if (minDist > dist)
-            {
-                minDist = dist;
-                poi = itr;
-            }
-        }
-
-        if (poi == areaPOIs.end())
-            continue;
-
-        // add building to the list
-        TeamId teamId = x > POS_X_CENTER ? getDefenderTeam() : getAttackerTeam();
-        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
-        if ((*poi)->id == 2246)
-            m_gate = m_buildingStates[guid];
-        areaPOIs.erase(poi);
-
-        // add capture point
-        uint32 capturePointEntry = 0;
-
-        switch(goData->id)
-        {    
-            //West Goblin Workshops
-            case 192028: // NW
-            case 192030: // W
-            case 192032: // SW
-                capturePointEntry = 190475;
-                break;
-            //East Goblin Workshops
-            case 192029: // NE
-            case 192031: // E
-            case 192033: // SE
-                capturePointEntry = 190487;
-                break;
-        }
-
-        if (capturePointEntry)
-        {
-            uint32 engGuid = 0;
-            uint32 spiritGuid = 0;
-            // Find closest Eng to Workshop
-            float minDist = 100;
-            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
-            {
-                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
-                if (!creData)
-                    continue;
-
-                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
-                if (minDist > dist)
-                {
-                    minDist = dist;
-                    engGuid = *itr;
-                }
-            }
-
-            if (!engGuid)
-            {
-                sLog.outError("Cannot find nearby siege workshop master!");
-                continue;
-            }
-            else
-                engGuids.remove(engGuid);
-            // Find closest Spirit Guide to Workshop
-            minDist = 255;
-            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
-            {
-                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
-                if (!creData)
-                    continue;
-
-                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
-                if (minDist > dist)
-                {
-                    minDist = dist;
-                    spiritGuid = *itr;
-                }
-            }
-
-            // Inside fortress won't be capturable
-            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
-            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
-            {
-                delete workshop;
-                sLog.outError("Cannot add capture point!");
-                continue;
-            }
-
-            const CreatureData *creData = sObjectMgr.GetCreatureData(engGuid);
-            if (!creData)
-                continue;
-
-            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
-            const_cast<CreatureData*>(creData)->displayid = 0;
-            workshop->m_engGuid = engGuid;
-
-            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
-            if (spiritGuid)
-            {
-                spiritGuids.remove(spiritGuid);
-
-                const CreatureData *spiritData = sObjectMgr.GetCreatureData(spiritGuid);
-                if (!spiritData)
-                    continue;
-
-                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
-                const_cast<CreatureData*>(spiritData)->displayid = 0;
-                workshop->m_spiGuid = spiritGuid;
-            }
-            else
-                workshop->m_spiGuid = 0;
-            workshop->m_workshopGuid = guid;
-            AddCapturePoint(workshop);
-            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
-            workshop->SetTeamByBuildingState();
-        }
-    }while(result->NextRow());
-
-    engGuids.clear();
-    spiritGuids.clear();
-
-    if (!m_gate)
-    {
-        sLog.outError("Cannot find wintergrasp fortress gate!");
-        return false;
-    }
-
-    // Load Graveyard
-    GraveYardMap::const_iterator graveLow  = sObjectMgr.mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
-    GraveYardMap::const_iterator graveUp   = sObjectMgr.mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
-    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
-    {
-        if ((*itr)->icon[1] == 8)
-        {
-            // find or create grave yard
-            const WorldSafeLocsEntry *loc = sObjectMgr.GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
-            if (!loc)
-            {
-                ++itr;
-                continue;
-            }
-
-            GraveYardMap::const_iterator graveItr;
-            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
-                if (graveItr->second.safeLocId == loc->ID)
-                    break;
-            if (graveItr == graveUp)
-            {
-                GraveYardData graveData;
-                graveData.safeLocId = loc->ID;
-                graveData.team = 0;
-                graveItr = sObjectMgr.mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
-            }
-
-            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
-            {
-                if (stateItr->second->worldState == (*itr)->worldState)
-                {
-                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
-                    break;
-                }
-            }
-            areaPOIs.erase(itr++);
-        }
-        else
-            ++itr;
-    }
-
-    //Titan Relic
-    sObjectMgr.AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
-
-    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
-    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
-
-    sWorld.SendWintergraspState();
-    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
-    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
-    m_towerDamagedCount[TEAM_HORDE] = 0;
-    m_towerDestroyedCount[TEAM_HORDE] = 0;
-
-    RemoveOfflinePlayerWGAuras();
-
-    RegisterZone(ZONE_WINTERGRASP);
-
-    if (m_wartime)
-    {
-        uint32 m_WSTimer = m_timer;
-        StartBattle();
-        m_timer = m_WSTimer;
-    }
-
-    return true;
-}
-
-void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
-{	
-    if (obj->GetEntry() == 192829) // Titan Relic
-    {
-        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && m_gate && m_gate->damageState == DAMAGE_DESTROYED)
-        {
-            m_changeDefender = true;
-            m_timer = 0;
-        }
-    }
-    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
-        if (itr == m_buildingStates.end())
-            return;
-
-        std::string msgStr;
-        switch(eventId)
-        { // TODO - Localized msgs of GO names
-            case 19672: case 19675: // Flamewatch Tower
-                msgStr = "Flamewatch";
-                break;
-            case 18553: case 19677: // Shadowsight Tower
-                msgStr = "Shadowsight";
-                break;
-            case 19673: case 19676: // Winter's Edge Tower
-                msgStr = "Winter's Edge";
-                break;
-            case 19776: case 19778: // E Workshop damaged
-                msgStr = "Sunken Ring";
-                break;
-            case 19777: case 19779: // W Workshop damaged
-                msgStr = "Broken Temple";
-                break;
-            case 19782: case 19786: // NW Workshop damaged
-                msgStr = "north-western";
-                break;
-            case 19783: case 19787: // NE Workshop damaged
-                msgStr = "north-eastern";
-                break;
-            case 19784: case 19788: // SW Workshop damaged
-                msgStr = "Westpark";
-                break;
-            case 19785: case 19789: // SE Workshop damaged
-                msgStr = "Eastpark";
-                break;
-            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
-                msgStr = "north-western";
-                break;
-            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
-                msgStr = "north-eastern";
-                break;
-            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
-                msgStr = "south-western";
-                break;
-            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
-                msgStr = "south-eastern";
-                break;
-            default:
-                msgStr = "";
-        }
-
-        BuildingState *state = itr->second;
-        if (eventId == obj->GetGOInfo()->building.damagedEvent)
-        {
-            state->damageState = DAMAGE_DAMAGED;
-            switch(state->type)
-            {
-                case BUILDING_WORKSHOP:
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-                    break;
-                case BUILDING_WALL:
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
-	           for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
-	                  }
-                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
-	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
-	                  (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                  }
-		break;
-                case BUILDING_TOWER:
-                    ++m_towerDamagedCount[state->GetTeam()];
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-			   for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                  }
-                     else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                  }
-                    break;
-            }
-        }
-        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
-        {
-            state->damageState = DAMAGE_DESTROYED;
-
-            switch(state->type)
-            {
-                case BUILDING_WORKSHOP:
-                    ModifyWorkshopCount(state->GetTeam(), false);
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-                    break;
-                case BUILDING_WALL:
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
-			    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                  }
-                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
-		          (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                  }
-                    break;
-                case BUILDING_TOWER:
-                    --m_towerDamagedCount[state->GetTeam()];
-                    ++m_towerDestroyedCount[state->GetTeam()];
-                    if (state->GetTeam() == getAttackerTeam())
-                    {
-                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
-                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
-                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
-
-                        if (m_towerDestroyedCount[getAttackerTeam()])
-                        {
-                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                                if ((*itr)->getLevel() > 74)
-                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
-                        }
-
-                        if (attStack)
-                        {
-                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                                if ((*itr)->getLevel() > 74)
-                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
-                        }
-                        else
-                        {
-                            if (m_timer < 600000)
-                                m_timer = 0;
-                            else
-                                m_timer = m_timer - 600000; // - 10 mins
-                        }
-                    }
-                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
-                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
-	    	    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-                   {
-	                if (getDefenderTeam()==TEAM_ALLIANCE)
-	                  {
-                      TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
-	                  }
-                    else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
-	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
-                    }
-                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-                  {
-	               if (getDefenderTeam()==TEAM_ALLIANCE)
-	                 {
-                     TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
-	                 }
-                   else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
-			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
-                  }
-                    break;
-            }
-            BroadcastStateChange(state);
-        }
-    }
-}
-
-void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
-{
-    // if server crashed while in battle there could be players with rank or tenacity
-    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
-        SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
-}
-
-void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
-{
-    if (team == TEAM_NEUTRAL)
-        return;
-
-    if (add)
-        ++m_workshopCount[team];
-    else if (m_workshopCount[team])
-        --m_workshopCount[team];
-    else
-        sLog.outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
-
-    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
-}
-
-uint32 OutdoorPvPWG::GetCreatureEntry(uint32 guidlow, const CreatureData *data)
-{
-    if (getDefenderTeam() == TEAM_ALLIANCE)
-    {
-        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
-        if (itr != m_creEntryPair.end())
-        {
-            const_cast<CreatureData*>(data)->displayid = 0;
-            return itr->second;
-        }
-    }
-    return data->id;
-}
-
-OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
-{
-    // VEHICLES, GUARDS and TURRETS gives kill credit
-    // OTHER Not in wartime
-    // TURRET Only during wartime
-    // SPECIAL like "OTHER" but no despawn conditions
-    // Entries like Case A: Case: B have their own despawn function
-    switch(entry)
-    {
-        case 27881: // Catapult
-        case 28094: // Demolisher
-        case 28312: // Alliance Siege Engine
-        case 32627: // Horde Siege Engine
-        case 28319: // Siege turret
-        case 32629: // Siege turret
-            return CREATURE_SIEGE_VEHICLE;
-        case 28366: // Wintergrasp Tower cannon
-            return CREATURE_TURRET;
-        case CRE_ENG_A: // Alliance Engineer
-        case CRE_ENG_H: // Horde Engineer
-            return CREATURE_ENGINEER;
-        case 30739:case 30740: // Champions
-        case 32307:case 32308: // Guards
-            return CREATURE_GUARD;
-        case CRE_SPI_A: // Dwarven Spirit Guide
-        case CRE_SPI_H: // Taunka Spirit Guide
-            return CREATURE_SPIRIT_GUIDE;
-        case 6491: // Spirit Healers
-            return CREATURE_SPIRIT_HEALER;
-        case 31101:case 31051: // Hoodoo Master & Sorceress
-        case 31102:case 31052: // Vieron Blazefeather & Bowyer
-        case 31107:case 31109: // Lieutenant & Senior Demolitionist
-        case 31151:case 31153: // Tactical Officer
-        case 31106:case 31108: // Siegesmith & Siege Master
-        case 31053:case 31054: // Primalist & Anchorite
-        case 31091:case 31036: // Commander
-            return CREATURE_QUESTGIVER;
-        case 32615:case 32626: // Warbringer && Brigadier General
-        case 32296:case 32294: // Quartermaster
-        case 39173:case 39172: // Ros'slai && Marshal Magruder
-        case 30870:case 30869: // Flight Masters
-            return CREATURE_SPECIAL;
-        default:
-            return CREATURE_OTHER; // Revenants, Elementals, etc
-    }
-}
-
-void OutdoorPvPWG::OnCreatureCreate(Creature *creature, bool add)
-{
-    uint32 entry = creature->GetEntry();
-    switch(GetCreatureType(entry))
-    {
-        case CREATURE_SIEGE_VEHICLE:
-        {
-            if (!creature->isSummon())
-                return;
-
-            TeamId team;
-            if (add)
-            {
-                if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
-                    team = TEAM_ALLIANCE;
-                else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
-                    team = TEAM_HORDE;
-                else
-                    return;
-
-                if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
-                {
-                    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
-                    {
-                        if (CanBuildVehicle(workshop))
-                        {
-                            m_vehicles[team].insert(creature);
-                            //workshop->m_vehicles.insert(creature);
-                        }
-                        else
-                        {
-                            creature->setDeathState(DEAD);
-                            creature->SetRespawnTime(DAY);
-                            return;
-                        }
-                    }
-                }
-
-                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
-                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
-                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
-                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
-            }
-            else // the faction may be changed in uncharm
-            {
-                // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
-                if (m_vehicles[TEAM_ALLIANCE].erase(creature))
-                    team = TEAM_ALLIANCE;
-                else if (m_vehicles[TEAM_HORDE].erase(creature))
-                    team = TEAM_HORDE;
-                else
-                    return;
-            }
-            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
-            break;
-        }
-        case CREATURE_QUESTGIVER:
-            if (add)
-                m_questgivers[creature->GetDBTableGUIDLow()] = creature;
-            else
-                m_questgivers.erase(creature->GetDBTableGUIDLow());
-            break;
-        case CREATURE_ENGINEER:
-            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-            {
-                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
-                    {
-                        workshop->m_engineer = add ? creature : NULL;
-                        break;
-                    }
-            }
-            break;
-        case CREATURE_SPIRIT_GUIDE:
-            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-            {
-                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
-                    {
-                        workshop->m_spiritguide = add ? creature : NULL;
-                        break;
-                    }
-            }
-            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
-        case CREATURE_SPIRIT_HEALER:
-        case CREATURE_TURRET:
-        case CREATURE_OTHER:
-            if (add)
-                UpdateCreatureInfo(creature);
-        default:
-            if (add)
-                m_creatures.insert(creature);
-            else
-                m_creatures.erase(creature);
-            break;
-    }
-}
-
-void OutdoorPvPWG::OnGameObjectCreate(GameObject *go, bool add)
-{
-    OutdoorPvP::OnGameObjectCreate(go, add);
-
-    if (UpdateGameObjectInfo(go))
-    {
-        if (add) m_gobjects.insert(go);
-        else m_gobjects.erase(go);
-    }
-    //do we need to store building?
-    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
-        if (itr != m_buildingStates.end())
-        {
-            itr->second->building = add ? go : NULL;
-            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
-                itr->second->type = BUILDING_TOWER;
-            if (!add || itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
-            {
-                itr->second->health = go->GetGOValue()->building.health;
-                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-            }
-            else
-            {
-                go->GetGOValue()->building.health = itr->second->health;
-                if (itr->second->damageState == DAMAGE_DAMAGED)
-                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
-                else if (itr->second->damageState == DAMAGE_DESTROYED)
-                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
-            }
-        }
-    }
-}
-
-void OutdoorPvPWG::UpdateAllWorldObject()
-{
-    // update cre and go factions
-    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
-        UpdateGameObjectInfo(*itr);
-    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
-        UpdateCreatureInfo(*itr);
-    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
-        UpdateQuestGiverPosition((*itr).first, (*itr).second);
-
-    // rebuild and update building states
-    RebuildAllBuildings();
-
-    // update capture points
-    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-            workshop->SetTeamByBuildingState();
-}
-
-void OutdoorPvPWG::RebuildAllBuildings()
-{
-    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
-    {
-        if (itr->second->building)
-        {
-            UpdateGameObjectInfo(itr->second->building);
-            itr->second->building->Rebuild();
-            itr->second->health = itr->second->building->GetGOValue()->building.health;
-        }
-        else
-            itr->second->health = 0;
-
-        if (itr->second->damageState == DAMAGE_DESTROYED)
-        {
-            if (itr->second->type == BUILDING_WORKSHOP)
-                ModifyWorkshopCount(itr->second->GetTeam(), true);
-        }
-
-        itr->second->damageState = DAMAGE_INTACT;
-        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
-    }
-    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
-    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
-    m_towerDamagedCount[TEAM_HORDE] = 0;
-    m_towerDestroyedCount[TEAM_HORDE] = 0;
-}
-
-void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
-{
-    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
-    data << uint32(571);
-    data << uint32(ZONE_WINTERGRASP);
-    data << uint32(0);
-    data << uint16(4+2+4+m_buildingStates.size());
-
-    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
-    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
-    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
-
-    for (uint32 i = 0; i < 2; ++i)
-        data << ClockWorldState[i] << m_clock[i];
-
-    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
-    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
-    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
-    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
-
-    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
-        itr->second->FillData(data);
-
-    if (player)
-        player->GetSession()->SendPacket(&data);
-    else
-        BroadcastPacket(data);
-}
-
-void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
-{
-    if (m_sendUpdate)
-        for (uint32 team = 0; team < 2; ++team)
-            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
-                state->SendUpdate(*p_itr);
-}
-
-// Called at Start and Battle End
-bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
-{
-    if (!creature)
-        return false;
-    uint32 entry = creature->GetEntry();
-    switch(GetCreatureType(entry))
-    {
-        case CREATURE_TURRET:
-            if (isWarTime())
-            {
-                if (!creature->isAlive())
-                    creature->Respawn(true);
-                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
-                creature->SetVisibility(VISIBILITY_ON);
-            }
-            else
-            {
-                if (creature->IsVehicle() && creature->GetVehicleKit())
-                    creature->GetVehicleKit()->RemoveAllPassengers();
-                creature->SetVisibility(VISIBILITY_OFF);
-                creature->setFaction(35);
-            }
-            return false;
-        case CREATURE_OTHER:
-            if (isWarTime())
-            {
-                creature->SetVisibility(VISIBILITY_OFF);
-                creature->setFaction(35);
-            }
-            else
-            {
-                creature->RestoreFaction();
-                creature->SetVisibility(VISIBILITY_ON);
-            }
-            return false;
-        case CREATURE_SPIRIT_GUIDE:
-            if (isWarTime())
-            {
-               if (creature->GetAreaId() == 4575) // Select Fortress Spirit
-               {
-                 FortressSpirit = creature;
-                 if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
-                 {
-                    FortressSpirit->UpdateEntry(CRE_SPI_A);
-                 }
-                 if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
-                 {
-                    FortressSpirit->UpdateEntry(CRE_SPI_H);
-                 }
-               }
-                creature->SetVisibility(VISIBILITY_ON);
-                //creature->setDeathState(ALIVE);
-            }
-            else
-            {
-                creature->SetVisibility(VISIBILITY_OFF);
-                //creature->setDeathState(DEAD);
-            }
-            return false;
-        case CREATURE_SPIRIT_HEALER:
-            creature->SetVisibility(isWarTime() ? VISIBILITY_OFF : VISIBILITY_ON);
-            return false;
-        case CREATURE_ENGINEER:
-            return false;
-        case CREATURE_SIEGE_VEHICLE:
-            //creature->DisappearAndDie();
-            return false;
-        case CREATURE_GUARD:
-        case CREATURE_SPECIAL:
-        {
-            TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
-            if (itr != m_creEntryPair.end())
-            {
-                entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
-                _RespawnCreatureIfNeeded(creature, entry);
-            }
-            return false;
-        }
-        default:
-            return false;
-    }
-}
-
-bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
-{
-    assert(guid);
-    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
-
-    if (creature && creature->IsInWorld())
-    {
-        // if not questgiver or position is the same, do nothing
-        if (creature->GetPositionX() == pos.GetPositionX() &&
-            creature->GetPositionY() == pos.GetPositionY() &&
-            creature->GetPositionZ() == pos.GetPositionZ())
-            return false;
-
-        if (creature->isAlive() && creature->isInCombat())
-        {
-            creature->CombatStop(true);
-            creature->getHostileRefManager().deleteReferences();
-        }
-        creature->SetHomePosition(pos);
-        creature->DestroyForNearbyPlayers();
-        if (!creature->GetMap()->IsLoaded(pos.GetPositionX(), pos.GetPositionY()))
-            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
-        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
-        if (!creature->isAlive())
-            creature->Respawn(true);
-    }
-    else
-        sObjectMgr.MoveCreData(guid, 571, pos);
-
-    return true;
-}
-
-// Return false = Need to rebuild at battle End/Start
-//        true  = no need to rebuild (ie: Banners or teleporters)
-bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
-{
-    uint32 attFaction = 35;
-    uint32 defFaction = 35;
-
-    if (isWarTime())
-    {
-        attFaction = WintergraspFaction[getAttackerTeam()];
-        defFaction = WintergraspFaction[getDefenderTeam()];
-    }
-
-    switch(go->GetGOInfo()->displayId)
-    {
-        case 8244: // Defender's Portal - Vehicle Teleporter
-            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
-            return true;
-        case 7967: // Titan relic
-            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
-            return true;
-
-        case 8165: // Wintergrasp Keep Door
-        case 7877: // Wintergrasp Fortress Wall
-        case 7878: // Wintergrasp Keep Tower
-        case 7906: // Wintergrasp Fortress Gate
-        case 7909: // Wintergrasp Wall
-            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
-            return false;
-        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
-            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
-            return false;
-        case 8208: // Goblin Workshop
-            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
-            if (workshop)
-                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
-            return false;
-    }
-
-    // Note: this is only for test, still need db support
-    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
-    if (itr != m_goDisplayPair.end())
-    {
-        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
-            itr->second : itr->first);
-        return true;
-    }
-    return false;
-}
-
-void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return;
-
-    if (isWarTime())
-    {
-		if (plr->getLevel() < 75) 
-		{
-		plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
-		return;
-		}
-        if (plr->getLevel() > 74)
-        {
-            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
-                && !plr->HasAura(SPELL_LIEUTENANT))
-                plr->CastSpell(plr, SPELL_RECRUIT, true);
-            if (plr->GetTeamId() == getAttackerTeam())
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
-            }
-            else
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()])
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
-            }
-        }
-    }
-
-    SendInitWorldStatesTo(plr);
-    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
-    UpdateTenacityStack();
-}
-
-// Reapply Auras if needed
-void OutdoorPvPWG::HandlePlayerResurrects(Player * plr, uint32 zone)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return;
-
-    if (isWarTime())
-    {
-        if (plr->getLevel() > 74)
-        {
-            // Tenacity
-            if (plr->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
-                plr->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
-            {
-                if (plr->HasAura(SPELL_TENACITY))
-                    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
-
-                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
-                if (newStack > 20)
-                    newStack = 20;
-                plr->SetAuraStack(SPELL_TENACITY, plr, newStack);
-            }
-
-            // Tower Control
-            if (plr->GetTeamId() == getAttackerTeam())
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
-            }
-            else
-            {
-                if (m_towerDestroyedCount[getAttackerTeam()])
-                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
-            }
-        }
-    }
-    OutdoorPvP::HandlePlayerResurrects(plr, zone);
-}
-
-void OutdoorPvPWG::HandlePlayerLeaveZone(Player * plr, uint32 zone)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return;
-
-    if (!plr->GetSession()->PlayerLogout())
-    {
-        if (plr->GetVehicle()) // dismiss in change zone case
-            plr->GetVehicle()->Dismiss();
-        plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
-        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
-        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-    }
-    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
-    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
-    UpdateTenacityStack();
-}
-
-void OutdoorPvPWG::PromotePlayer(Player *killer) const
-{
-    Aura * aur;
-    if (aur = killer->GetAura(SPELL_RECRUIT))
-    {
-        if (aur->GetStackAmount() >= 5)
-        {
-            killer->RemoveAura(SPELL_RECRUIT);
-            killer->CastSpell(killer, SPELL_CORPORAL, true);
-            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
-        }
-        else
-            killer->CastSpell(killer, SPELL_RECRUIT, true);
-    }
-    else if (aur = killer->GetAura(SPELL_CORPORAL))
-    {
-        if (aur->GetStackAmount() >= 5)
-        {
-            killer->RemoveAura(SPELL_CORPORAL);
-            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
-            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
-        }
-        else
-            killer->CastSpell(killer, SPELL_CORPORAL, true);
-    }
-}
-
-void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
-        return;
-
-    bool ok = false;
-    if (victim->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (victim->getLevel() >= 70)
-            ok = true;
-        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
-    }
-    else
-    {
-        switch(GetCreatureType(victim->GetEntry()))
-        {
-            case CREATURE_SIEGE_VEHICLE:
-                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
-                ok = true;
-                break;
-            case CREATURE_GUARD:
-                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
-                ok = true;
-                break;
-            case CREATURE_TURRET:
-                ok = true;
-                break;
-        }
-    }
-
-    if (ok)
-    {
-        if (Group *pGroup = killer->GetGroup())
-        {
-            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
-                    PromotePlayer(itr->getSource());
-        }
-        else if (killer->getLevel() > 74)
-            PromotePlayer(killer);
-    }
-}
-
-// Recalculates Tenacity and applies it to Players / Vehicles
-void OutdoorPvPWG::UpdateTenacityStack()
-{
-    if (!isWarTime())
-        return;
-
-    TeamId team = TEAM_NEUTRAL;
-    uint32 allianceNum = 0;
-    uint32 hordeNum = 0;
-    int32 newStack = 0;
-
-    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
-        if ((*itr)->getLevel() > 74)
-            ++allianceNum;
-
-    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
-        if ((*itr)->getLevel() > 74)
-            ++hordeNum;
-
-    if (allianceNum && hordeNum)
-    {
-        if (allianceNum < hordeNum)
-            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
-        else if (allianceNum > hordeNum)
-            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
-    }
-
-    if (newStack == m_tenacityStack)
-        return;
-
-    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
-        team = TEAM_ALLIANCE;
-    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
-        team = TEAM_HORDE;
-
-    m_tenacityStack = newStack;
-
-    // Remove old buff
-    if (team != TEAM_NEUTRAL)
-    {
-        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            if ((*itr)->getLevel() > 74)
-                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
-
-        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
-    }
-
-    // Apply new buff
-    if (newStack)
-    {
-        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
-        if (newStack < 0)
-            newStack = -newStack;
-        if (newStack > 20)
-            newStack = 20;
-
-        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            if ((*itr)->getLevel() > 74)
-                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
-
-        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
-            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
-    }
-}
-
-void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
-{
-    uint32 value = timer%mod;
-    if (m_clock[digit] != value)
-    {
-        m_clock[digit] = value;
-        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
-        sWorld.SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
-    }
-}
-
-void OutdoorPvPWG::UpdateClock()
-{
-    uint32 timer = m_timer / 1000;
-    if (!isWarTime())
-        UpdateClockDigit(timer, 1, 10);
-    else
-        UpdateClockDigit(timer, 0, 10);
-
-//Announce in all world, comment it if you don't like/need it
-	 // Announce 30 minutes left
- 	 if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false)) 
-        sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
- 
- 	 // Announce 10 minutes left
-	 if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false)) 
-       sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
-}
-
-bool OutdoorPvPWG::Update(uint32 diff)
-{
-    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-        return false;
-
-    if (m_timer > diff)
-    {
-        m_timer -= diff;
-
-        if (isWarTime())
-        {
-            OutdoorPvP::Update(diff); // update capture points
-
-            /*********************************************************/
-            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
-            /*********************************************************/
-
-            //this should be handled by spell system
-            m_LastResurrectTime += diff;
-            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
-            {
-                if (GetReviveQueueSize())
-                {
-                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
-                    {
-                        Creature* sh = NULL;
-                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
-                        {
-                            Player *plr = sObjectMgr.GetPlayer(*itr2);
-                            if (!plr)
-                                continue;
-
-                            if (!sh && plr->IsInWorld())
-                            {
-                                sh = plr->GetMap()->GetCreature(itr->first);
-                                // only for visual effect
-                                if (sh)
-                                    // Spirit Heal, effect 117
-                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
-                            }
-
-                            // Resurrection visual
-                         if (plr->GetDistance2d(sh) <= 18.0f)
-                           {
-                            plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
-                            m_ResurrectQueue.push_back(*itr2);
-                           }
-                        }
-                        (itr->second).clear();
-                    }
-
-                    m_ReviveQueue.clear();
-                    m_LastResurrectTime = 0;
-                }
-                else
-                    // queue is clear and time passed, just update last resurrection time
-                    m_LastResurrectTime = 0;
-            }
-            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
-            {
-                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
-                {
-                    Player *plr = sObjectMgr.GetPlayer(*itr);
-                    if (!plr)
-                        continue;
-                    plr->ResurrectPlayer(1.0f);
-                    plr->CastSpell(plr, 6962, true);
-                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
-                    sObjectAccessor.ConvertCorpseForPlayer(*itr);
-                }
-                m_ResurrectQueue.clear();
-            }
-        }
-        UpdateClock();
-    }
-    else
-    {
-        m_sendUpdate = false;
-        int32 entry = LANG_BG_WG_DEFENDED;
-
-        if (m_changeDefender)
-        {
-            m_changeDefender = false;
-            m_defender = getAttackerTeam();
-            entry = LANG_BG_WG_CAPTURED;
-        }
-
-        if (isWarTime())
-        {
-            if (m_timer != 1) // 1 = forceStopBattle
-                sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(entry), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
-            EndBattle();
-        }
-        else
-        {
-            if (m_timer != 1) // 1 = forceStartBattle
-                sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
-            StartBattle();
-        }
-
-        UpdateAllWorldObject();
-        UpdateClock();
-
-        SendInitWorldStatesTo();
-        m_sendUpdate = true;
-    }
-
-    if (m_WSSaveTimer < diff)
-    {
-        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31001', `value`='%d', `comment`='wg m_wartime'",m_wartime);
-        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31002', `value`='%d', `comment`='wg m_timer'",m_timer);
-        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31003', `value`='%d', `comment`='wg m_defender'",m_defender);
-        m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
-    } else m_WSSaveTimer -= diff;
-
-
-    return false;
-}
-
-void OutdoorPvPWG::forceStartBattle()
-{ // Uptime will do all the work
-    m_wartime = false;
-
-    if (m_timer != 1)
-    {
-        m_timer = 1;
-        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
-    }
-		sWorld.SendWintergraspState();
-}
-
-void OutdoorPvPWG::forceStopBattle()
-{ // Uptime will do all the work.
-
-    if (!isWarTime())
-        m_wartime = true;
-
-    if (m_timer != 1)
-    {
-        m_timer = 1;
-        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
-    }
-	sWorld.SendWintergraspState();
-}
-
-void OutdoorPvPWG::forceChangeTeam()
-{
-    m_changeDefender = true;
-    m_timer = 1;
-    sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr.GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
-    if (isWarTime())
-        forceStartBattle();
-    else
-        forceStopBattle();
-}
-
-// Can be forced by gm's while in battle so have to reset in case it was wartime
-void OutdoorPvPWG::StartBattle()
-{
-	uint32 CountDef=0;
-	uint32 CountAtk=0;
-    m_wartime = true;
-    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
-
-    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-    {
-       if ((*itr)->getLevel() < 75)
-        {
-          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
-        }
-       else
-        {
-          CountDef++;
-          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
-          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
-          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
-          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
-        }
-    }
-
-    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-    {
-        if ((*itr)->getLevel() < 75)
-        {
-          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
-        }
-        else
-        {
-          CountAtk++;
-          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
-          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
-          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
-          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
-        }
-    }
-
-if (sWorld.getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
- {
- if ((CountAtk < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
-  {
-   if (CountAtk<=CountDef)
-	   sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
-   if (CountDef<CountAtk)
-     {  
-	 sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
-	 m_changeDefender=true;
-     }
-   forceStopBattle();
-   return;
-  }
- }
-
-//    TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
-
-    // Remove Essence of Wintergrasp to all players
-    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
-    sWorld.UpdateAreaDependentAuras();
-
-    // destroyed all vehicles
-    for (uint32 team = 0; team < 2; ++team)
-    {
-        while(!m_vehicles[team].empty())
-        {
-            Creature *veh = *m_vehicles[team].begin();
-            m_vehicles[team].erase(m_vehicles[team].begin());
-            veh->setDeathState(JUST_DIED);
-        }
-    }
-
-    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
-    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-    {
-        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-        if ((*itr)->getLevel() > 74)
-        {
-            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
-            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
-        }
-    }
-
-    // Remove All Wintergrasp auras. Add Recruit rank
-    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-    {
-        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-        if ((*itr)->getLevel() > 74)
-            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
-    }
-    UpdateTenacityStack();
-	// Update timer in players battlegrounds tab
-    sWorld.SendWintergraspState();
-}
-
-void OutdoorPvPWG::EndBattle()
-{
-    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
-    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
-    sWorld.UpdateAreaDependentAuras();
-//Sound on End Battle
-for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
-{
-	if (getDefenderTeam()==TEAM_ALLIANCE)
-	{
-    TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
-	}
-    else TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
-	(*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
-}
-for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
-{
-   (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
-}
-
-    for (uint32 team = 0; team < 2; ++team)
-    {
-        // destroyed all vehicles
-        while(!m_vehicles[team].empty())
-        {
-            Creature *veh = *m_vehicles[team].begin();
-            m_vehicles[team].erase(m_vehicles[team].begin());
-            veh->setDeathState(JUST_DIED);
-        }
-
-        if (m_players[team].empty())
-            continue;
-
-        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-        {
-            // When WG ends the zone is cleaned including corpses, revive all players if dead
-            if ((*itr)->isDead())
-            {
-                (*itr)->ResurrectPlayer(1.0f);
-				sObjectAccessor.ConvertCorpseForPlayer((*itr)->GetGUID());
-                //ObjectAccessor::Instance().ConvertCorpseForPlayer((*itr)->GetGUID());
-            }
-            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
-            (*itr)->CombatStop(true);
-            (*itr)->getHostileRefManager().deleteReferences();
-        }
-
-        if (m_timer == 1) // Battle End was forced so no reward.
-        {
-            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-            {
-                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-            }
-            continue;
-        }
-
-        // calculate rewards
-        uint32 intactNum = 0;
-        uint32 damagedNum = 0;
-        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-                if (workshop->m_buildingState->GetTeam() == team)
-                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
-                        ++damagedNum;
-                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
-                        ++intactNum;
-
-        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
-        uint32 baseHonor = 0;
-        uint32 marks = 0;
-        uint32 playersWithRankNum = 0;
-        uint32 honor = 0;
-
-        if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
-        {
-            // Calculate Level 70+ with Corporal or Lieutenant rank
-            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
-                    ++playersWithRankNum;
-
-            baseHonor = team == getDefenderTeam() ? sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
-            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
-            if (playersWithRankNum)
-                baseHonor /= playersWithRankNum;
-        }
-
-        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
-        {
-
-            if ((*itr)->getLevel() < 75)
-                continue; // No rewards for level <75
-
-            // give rewards
-            if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
-            {
-                if (team == getDefenderTeam())
-                {
-                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
-                    {
-                        marks = 3;
-                        honor = baseHonor;
-                    }
-                    else if ((*itr)->HasAura(SPELL_CORPORAL))
-                    {
-                        marks = 2;
-                        honor = baseHonor;
-                    }
-                    else
-                    {
-                        marks = 1;
-                        honor = 0;
-                    }
-                }
-                else
-                {
-                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
-                    {
-                        marks = 1;
-                        honor = baseHonor;
-                    }
-                    else if ((*itr)->HasAura(SPELL_CORPORAL))
-                    {
-                        marks = 1;
-                        honor = baseHonor;
-                    }
-                    else
-                    {
-                        marks = 0;
-                        honor = 0;
-                    }
-                }
-                (*itr)->RewardHonor(NULL, 1, honor);
-                RewardMarkOfHonor(*itr, marks);
-                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
-            }
-            else
-            {
-                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
-                {
-                    // TODO - Honor from SpellReward should be shared by team players
-                    // TODO - Marks should be given depending on Rank but 3 are given
-                    // each time so Won't give any to recruits
-                    (*itr)->CastSpell(*itr, spellRewardId, true);
-                    for (uint32 i = 0; i < intactNum; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
-                    for (uint32 i = 0; i < damagedNum; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
-                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
-                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
-                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
-                }
-            }
-            if (team == getDefenderTeam())
-            {
-                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
-                {
-                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
-                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
-                }
-            }
-            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
-            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
-            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
-            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
-            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
-        }
-    }
-
-    m_wartime = false;
-    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
-    RemoveOfflinePlayerWGAuras();
-    // Update timer in players battlegrounds tab
-    sWorld.SendWintergraspState();
-}
-
-bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
-{
-    TeamId team = workshop->m_buildingState->GetTeam();
-    if (team == TEAM_NEUTRAL)
-        return false;
-
-    return isWarTime()
-        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
-        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
-}
-
-uint32 OutdoorPvPWG::GetData(uint32 id)
-{
-    // if can build more vehicles
-    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
-        return CanBuildVehicle(workshop) ? 1 : 0;
-
-    return 0;
-}
-
-void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
-{
-    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
-    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
-        return;
-    if (count == 0)
-        return;
-
-    ItemPosCountVec dest;
-    uint32 no_space_count = 0;
-    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
-
-    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
-    {
-        sLog.outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
-        return;
-    }
-
-    if (msg != EQUIP_ERR_OK) // convert to possible store amount
-        count -= no_space_count;
-
-    if (count != 0 && !dest.empty()) // can add some
-        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
-            plr->SendNewItem(item, count, true, false);
-}
-
-void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
-{
-    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
-    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
-    m_questgivers[guid] = NULL;
-    if (getDefenderTeam() == TEAM_ALLIANCE)
-        sObjectMgr.MoveCreData(guid, 571, posAlli);
-}
-
-OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
-{
-    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
-        return dynamic_cast<OPvPCapturePointWG*>(cp);
-    return NULL;
-}
-
-OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
-{
-    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-            if (workshop->m_engGuid == lowguid)
-                return workshop;
-    return NULL;
-}
-
-OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
-{
-    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
-        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
-            if (workshop->m_workshopGuid == lowguid)
-                return workshop;
-    return NULL;
-}
-
-/*########################################################
- * Copy of Battleground system to make Spirit Guides Work
- *#######################################################*/
-void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
-{
-    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
-    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
-    if (time_ == uint32(-1))
-        time_ = 0;
-    data << guid << time_;
-    pl->GetSession()->SendPacket(&data);
-}
-
-void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
-{
-    m_ReviveQueue[npc_guid].push_back(player_guid);
-
-    Player *plr = sObjectMgr.GetPlayer(player_guid);
-    if (!plr)
-        return;
-
-    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
-}
-
-void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
-{
-    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
-    {
-        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
-        {
-            if (*itr2 == player_guid)
-            {
-                (itr->second).erase(itr2);
-
-                Player *plr = sObjectMgr.GetPlayer(player_guid);
-                if (!plr)
-                    return;
-
-                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
-
-                return;
-            }
-        }
-    }
-}
-
-void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
-{
-    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
-        return;
-
-    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
-    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
-    if (!ghost_list.empty())
-    {
-        WorldSafeLocsEntry const *ClosestGrave = NULL;
-        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
-        {
-            Player* plr = sObjectMgr.GetPlayer(*itr);
-			if (!plr)
-                continue;
-
-			if (plr->getFaction() == ALLIANCE)
-			{
-            if (!ClosestGrave)
-                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
-
-            if (ClosestGrave)
-                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
-			}
-        }
-    }
-}
-
-void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
-{
-    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
-        return;
-
-    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
-    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
-    if (!ghost_list.empty())
-    {
-        WorldSafeLocsEntry const *ClosestGrave = NULL;
-        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
-        {
-            Player* plr = sObjectMgr.GetPlayer(*itr);
-			if (!plr)
-                continue;
-
-			if (plr->getFaction() == HORDE)
-			{
-            if (!ClosestGrave)
-                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
-
-            if (ClosestGrave)
-                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
-			}
-        }
-    }
-}
-
-/*######
-##OPvPCapturePointWG
-######*/
-
-OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state)
-: OPvPCapturePoint(opvp), m_buildingState(state), m_wintergrasp(opvp)
-, m_engineer(NULL), m_engGuid(0), m_spiritguide(NULL)
-, m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_spiGuid(0)
-{
-}
-
-void OPvPCapturePointWG::SetTeamByBuildingState()
-{
-    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
-    {
-        m_value = m_maxValue;
-        m_State = OBJECTIVESTATE_ALLIANCE;
-    }
-    else if (m_buildingState->GetTeam() == TEAM_HORDE)
-    {
-        m_value = -m_maxValue;
-        m_State = OBJECTIVESTATE_HORDE;
-    }
-    else
-    {
-        m_value = 0;
-        m_State = OBJECTIVESTATE_NEUTRAL;
-    }
-
-    if (m_team != m_buildingState->GetTeam())
-    {
-        TeamId oldTeam = m_team;
-        m_team = m_buildingState->GetTeam();
-        ChangeTeam(oldTeam);
-    }
-
-    SendChangePhase();
-}
-
-void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
-{
-   entry = 0;
-   guide_entry = 0;
-   guide_entry_fortress_horde = 0;
-   guide_entry_fortress_alliance = 0;
-
-    if (oldTeam != TEAM_NEUTRAL)
-        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
-
-    if (m_team != TEAM_NEUTRAL)
-    {
-        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
-        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
-        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
-        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
-        m_wintergrasp->ModifyWorkshopCount(m_team, true);
-    }
-
-    if (m_capturePoint)
-        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
-
-    m_buildingState->SetTeam(m_team);
-    // TODO: this may be sent twice
-    m_wintergrasp->BroadcastStateChange(m_buildingState);
-
-    if (m_buildingState->building)
-        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
-
-    if (entry)
-    {
-        if (m_engGuid)
-        {
-            *m_engEntry = entry;
-            _RespawnCreatureIfNeeded(m_engineer, entry);
-        }
-        if (m_spiGuid)
-        {
-         if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
-         {
-            *m_spiEntry = guide_entry;
-            _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
-            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
-            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
-            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
-         }
-         else
-         {
-            *m_spiEntry = guide_entry;
-            _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
-            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
-            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
-            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
-         }
-        }
-    }
-    else if (m_engineer)
-        m_engineer->SetVisibility(VISIBILITY_OFF);
-
-    sLog.outDebug("Wintergrasp workshop now belongs to %u.", (uint32)m_buildingState->GetTeam());
-}
-
-class OutdoorPvP_wintergrasp : public OutdoorPvPScript
-{
-    public:
-
-        OutdoorPvP_wintergrasp()
-            : OutdoorPvPScript("outdoorpvp_wg")
-        {
-        }
-
-        OutdoorPvP* GetOutdoorPvP() const
-        {
-            return new OutdoorPvPWG();
-        }
-};
-
-void AddSC_outdoorpvp_wg()
-{
-    new OutdoorPvP_wintergrasp();
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ */
+
+#include "OutdoorPvPWG.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "ObjectMgr.h"
+#include "World.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "ScriptedCreature.h"
+#include "ScriptPCH.h"
+
+Creature* FortressSpirit;
+uint32 entry;
+uint32 guide_entry;
+uint32 guide_entry_fortress_horde;
+uint32 guide_entry_fortress_alliance;
+
+OutdoorPvPWG::OutdoorPvPWG()
+{
+    m_TypeId = OUTDOOR_PVP_WG;
+    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
+}
+
+void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
+{
+    while((*pair)[0])
+    {
+        pairMap[(*pair)[0]] = (*pair)[1];
+        pairMap[(*pair)[1]] = (*pair)[0];
+        ++pair;
+    }
+}
+
+void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
+{
+    if (cr)
+    {
+        cr->SetOriginalEntry(entry);
+        if (entry != cr->GetEntry() || !cr->isAlive())
+            cr->Respawn(true);
+        cr->SetVisibility(VISIBILITY_ON);
+    }
+}
+
+bool OutdoorPvPWG::SetupOutdoorPvP()
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+        return false;
+    }
+
+    //load worlstates
+    QueryResult result = CharacterDatabase.PQuery("SELECT `entry`, `value` from `worldstates` where `entry` in ('31001','31002','31003') order by `entry`");
+    
+    m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+
+    if (result)
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+            switch (fields[0].GetUInt32())
+            {
+                case 31001:
+                    m_wartime = fields[1].GetBool();
+                    break;
+                case 31002:
+                    m_timer = fields[1].GetUInt32();
+                    break;
+                case 31003:
+                    m_defender = TeamId(fields[1].GetUInt32());
+                    break;
+            }
+        }while(result->NextRow());
+    }
+    else
+    {
+        m_wartime = false;
+        m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
+        m_defender = TeamId(rand()%2);
+    }
+
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    m_changeDefender = false;
+    m_workshopCount[TEAM_ALLIANCE] = 0;
+    m_workshopCount[TEAM_HORDE] = 0;
+    m_tenacityStack = 0;
+    m_gate = NULL;
+
+    std::list<uint32> engGuids;
+    std::list<uint32> spiritGuids;
+
+    // Store Eng, spirit guide guids and questgiver for later use
+    result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
+         " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
+         CRE_ENG_A, CRE_ENG_H, CRE_SPI_A, CRE_SPI_H, 31101, 31051, 31102, 31052,
+         31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
+    if (!result)
+        sLog.outError("Cannot find siege workshop master or spirit guides in creature!");
+    else
+    {
+        do
+        {
+            Position posHorde, posAlli;
+            Field *fields = result->Fetch();
+            switch(fields[1].GetUInt32())
+            {
+                case CRE_ENG_A:
+                case CRE_ENG_H:
+                    engGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case CRE_SPI_A:
+                case CRE_SPI_H:
+                    spiritGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case 31051:
+                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
+                    posAlli.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31101:
+                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31052:
+                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
+                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31102:
+                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31109:
+                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
+                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31107:
+                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31153:
+                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
+                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31151:
+                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31108:
+                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
+                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31106:
+                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31054:
+                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
+                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31053:
+                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31036:
+                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
+                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31091:
+                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                default:
+                    break;
+            }
+        }while(result->NextRow());
+    }
+
+    // Select POI
+    AreaPOIList areaPOIs;
+    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
+    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
+    {
+        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
+        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
+        {
+            areaPOIs.push_back(poiInfo);
+            if (minX > poiInfo->x) minX = poiInfo->x;
+            if (minY > poiInfo->y) minY = poiInfo->y;
+            if (maxX < poiInfo->x) maxX = poiInfo->x;
+            if (maxY < poiInfo->y) maxY = poiInfo->y;
+        }
+    }
+    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
+
+    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
+    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
+        " WHERE gameobject.map=571"
+        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
+        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
+        " AND gameobject_template.type=33"
+        " AND gameobject.id=gameobject_template.entry",
+        minX, minY, maxX, maxY);
+    if (!result)
+        return false;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        uint32 guid = fields[0].GetUInt32();
+        GameObjectData const * goData = sObjectMgr.GetGOData(guid);
+        if (!goData) // this should not happen
+            continue;
+
+        float x = goData->posX, y = goData->posY;
+        float minDist = 100;
+        AreaPOIList::iterator poi = areaPOIs.end();
+        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
+        {
+            if (!(*itr)->icon[1]) // note: may for other use
+                continue;
+
+            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
+            if (minDist > dist)
+            {
+                minDist = dist;
+                poi = itr;
+            }
+        }
+
+        if (poi == areaPOIs.end())
+            continue;
+
+        // add building to the list
+        TeamId teamId = x > POS_X_CENTER ? getDefenderTeam() : getAttackerTeam();
+        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
+        if ((*poi)->id == 2246)
+            m_gate = m_buildingStates[guid];
+        areaPOIs.erase(poi);
+
+        // add capture point
+        uint32 capturePointEntry = 0;
+
+        switch(goData->id)
+        {    
+            //West Goblin Workshops
+            case 192028: // NW
+            case 192030: // W
+            case 192032: // SW
+                capturePointEntry = 190475;
+                break;
+            //East Goblin Workshops
+            case 192029: // NE
+            case 192031: // E
+            case 192033: // SE
+                capturePointEntry = 190487;
+                break;
+        }
+
+        if (capturePointEntry)
+        {
+            uint32 engGuid = 0;
+            uint32 spiritGuid = 0;
+            // Find closest Eng to Workshop
+            float minDist = 100;
+            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    engGuid = *itr;
+                }
+            }
+
+            if (!engGuid)
+            {
+                sLog.outError("Cannot find nearby siege workshop master!");
+                continue;
+            }
+            else
+                engGuids.remove(engGuid);
+            // Find closest Spirit Guide to Workshop
+            minDist = 255;
+            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    spiritGuid = *itr;
+                }
+            }
+
+            // Inside fortress won't be capturable
+            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
+            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
+            {
+                delete workshop;
+                sLog.outError("Cannot add capture point!");
+                continue;
+            }
+
+            const CreatureData *creData = sObjectMgr.GetCreatureData(engGuid);
+            if (!creData)
+                continue;
+
+            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
+            const_cast<CreatureData*>(creData)->displayid = 0;
+            workshop->m_engGuid = engGuid;
+
+            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
+            if (spiritGuid)
+            {
+                spiritGuids.remove(spiritGuid);
+
+                const CreatureData *spiritData = sObjectMgr.GetCreatureData(spiritGuid);
+                if (!spiritData)
+                    continue;
+
+                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
+                const_cast<CreatureData*>(spiritData)->displayid = 0;
+                workshop->m_spiGuid = spiritGuid;
+            }
+            else
+                workshop->m_spiGuid = 0;
+            workshop->m_workshopGuid = guid;
+            AddCapturePoint(workshop);
+            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
+            workshop->SetTeamByBuildingState();
+        }
+    }while(result->NextRow());
+
+    engGuids.clear();
+    spiritGuids.clear();
+
+    if (!m_gate)
+    {
+        sLog.outError("Cannot find wintergrasp fortress gate!");
+        return false;
+    }
+
+    // Load Graveyard
+    GraveYardMap::const_iterator graveLow  = sObjectMgr.mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
+    GraveYardMap::const_iterator graveUp   = sObjectMgr.mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
+    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
+    {
+        if ((*itr)->icon[1] == 8)
+        {
+            // find or create grave yard
+            const WorldSafeLocsEntry *loc = sObjectMgr.GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
+            if (!loc)
+            {
+                ++itr;
+                continue;
+            }
+
+            GraveYardMap::const_iterator graveItr;
+            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
+                if (graveItr->second.safeLocId == loc->ID)
+                    break;
+            if (graveItr == graveUp)
+            {
+                GraveYardData graveData;
+                graveData.safeLocId = loc->ID;
+                graveData.team = 0;
+                graveItr = sObjectMgr.mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
+            }
+
+            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
+            {
+                if (stateItr->second->worldState == (*itr)->worldState)
+                {
+                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
+                    break;
+                }
+            }
+            areaPOIs.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+
+    //Titan Relic
+    sObjectMgr.AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
+
+    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
+    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
+
+    sWorld.SendWintergraspState();
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+
+    RemoveOfflinePlayerWGAuras();
+
+    RegisterZone(ZONE_WINTERGRASP);
+
+    if (m_wartime)
+    {
+        uint32 m_WSTimer = m_timer;
+        StartBattle();
+        m_timer = m_WSTimer;
+    }
+
+    return true;
+}
+
+void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
+{	
+    if (obj->GetEntry() == 192829) // Titan Relic
+    {
+        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && m_gate && m_gate->damageState == DAMAGE_DESTROYED)
+        {
+            m_changeDefender = true;
+            m_timer = 0;
+        }
+    }
+    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
+        if (itr == m_buildingStates.end())
+            return;
+
+        std::string msgStr;
+        switch(eventId)
+        { // TODO - Localized msgs of GO names
+            case 19672: case 19675: // Flamewatch Tower
+                msgStr = "Flamewatch";
+                break;
+            case 18553: case 19677: // Shadowsight Tower
+                msgStr = "Shadowsight";
+                break;
+            case 19673: case 19676: // Winter's Edge Tower
+                msgStr = "Winter's Edge";
+                break;
+            case 19776: case 19778: // E Workshop damaged
+                msgStr = "Sunken Ring";
+                break;
+            case 19777: case 19779: // W Workshop damaged
+                msgStr = "Broken Temple";
+                break;
+            case 19782: case 19786: // NW Workshop damaged
+                msgStr = "north-western";
+                break;
+            case 19783: case 19787: // NE Workshop damaged
+                msgStr = "north-eastern";
+                break;
+            case 19784: case 19788: // SW Workshop damaged
+                msgStr = "Westpark";
+                break;
+            case 19785: case 19789: // SE Workshop damaged
+                msgStr = "Eastpark";
+                break;
+            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
+                msgStr = "north-western";
+                break;
+            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
+                msgStr = "north-eastern";
+                break;
+            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
+                msgStr = "south-western";
+                break;
+            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
+                msgStr = "south-eastern";
+                break;
+            default:
+                msgStr = "";
+        }
+
+        BuildingState *state = itr->second;
+        if (eventId == obj->GetGOInfo()->building.damagedEvent)
+        {
+            state->damageState = DAMAGE_DAMAGED;
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+	           for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+	                  (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+		break;
+                case BUILDING_TOWER:
+                    ++m_towerDamagedCount[state->GetTeam()];
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+			   for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                  }
+                     else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+                    break;
+            }
+        }
+        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
+        {
+            state->damageState = DAMAGE_DESTROYED;
+
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    ModifyWorkshopCount(state->GetTeam(), false);
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+			    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+		          (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+                    break;
+                case BUILDING_TOWER:
+                    --m_towerDamagedCount[state->GetTeam()];
+                    ++m_towerDestroyedCount[state->GetTeam()];
+                    if (state->GetTeam() == getAttackerTeam())
+                    {
+                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
+                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
+                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
+
+                        if (m_towerDestroyedCount[getAttackerTeam()])
+                        {
+                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
+                        }
+
+                        if (attStack)
+                        {
+                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
+                        }
+                        else
+                        {
+                            if (m_timer < 600000)
+                                m_timer = 0;
+                            else
+                                m_timer = m_timer - 600000; // - 10 mins
+                        }
+                    }
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+	    	    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
+                  }
+                    break;
+            }
+            BroadcastStateChange(state);
+        }
+    }
+}
+
+void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
+{
+    // if server crashed while in battle there could be players with rank or tenacity
+    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
+        SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
+}
+
+void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
+{
+    if (team == TEAM_NEUTRAL)
+        return;
+
+    if (add)
+        ++m_workshopCount[team];
+    else if (m_workshopCount[team])
+        --m_workshopCount[team];
+    else
+        sLog.outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
+
+    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
+}
+
+uint32 OutdoorPvPWG::GetCreatureEntry(uint32 guidlow, const CreatureData *data)
+{
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+    {
+        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
+        if (itr != m_creEntryPair.end())
+        {
+            const_cast<CreatureData*>(data)->displayid = 0;
+            return itr->second;
+        }
+    }
+    return data->id;
+}
+
+OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
+{
+    // VEHICLES, GUARDS and TURRETS gives kill credit
+    // OTHER Not in wartime
+    // TURRET Only during wartime
+    // SPECIAL like "OTHER" but no despawn conditions
+    // Entries like Case A: Case: B have their own despawn function
+    switch(entry)
+    {
+        case 27881: // Catapult
+        case 28094: // Demolisher
+        case 28312: // Alliance Siege Engine
+        case 32627: // Horde Siege Engine
+        case 28319: // Siege turret
+        case 32629: // Siege turret
+            return CREATURE_SIEGE_VEHICLE;
+        case 28366: // Wintergrasp Tower cannon
+            return CREATURE_TURRET;
+        case CRE_ENG_A: // Alliance Engineer
+        case CRE_ENG_H: // Horde Engineer
+            return CREATURE_ENGINEER;
+        case 30739:case 30740: // Champions
+        case 32307:case 32308: // Guards
+            return CREATURE_GUARD;
+        case CRE_SPI_A: // Dwarven Spirit Guide
+        case CRE_SPI_H: // Taunka Spirit Guide
+            return CREATURE_SPIRIT_GUIDE;
+        case 6491: // Spirit Healers
+            return CREATURE_SPIRIT_HEALER;
+        case 31101:case 31051: // Hoodoo Master & Sorceress
+        case 31102:case 31052: // Vieron Blazefeather & Bowyer
+        case 31107:case 31109: // Lieutenant & Senior Demolitionist
+        case 31151:case 31153: // Tactical Officer
+        case 31106:case 31108: // Siegesmith & Siege Master
+        case 31053:case 31054: // Primalist & Anchorite
+        case 31091:case 31036: // Commander
+            return CREATURE_QUESTGIVER;
+        case 32615:case 32626: // Warbringer && Brigadier General
+        case 32296:case 32294: // Quartermaster
+        case 39173:case 39172: // Ros'slai && Marshal Magruder
+        case 30870:case 30869: // Flight Masters
+            return CREATURE_SPECIAL;
+        default:
+            return CREATURE_OTHER; // Revenants, Elementals, etc
+    }
+}
+
+void OutdoorPvPWG::OnCreatureCreate(Creature *creature, bool add)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            if (add)
+            {
+                if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                    team = TEAM_ALLIANCE;
+                else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                    team = TEAM_HORDE;
+                else
+                    return;
+
+                if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
+                {
+                    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
+                    {
+                        if (CanBuildVehicle(workshop))
+                        {
+                            m_vehicles[team].insert(creature);
+                            //workshop->m_vehicles.insert(creature);
+                        }
+                        else
+                        {
+                            creature->setDeathState(DEAD);
+                            creature->SetRespawnTime(DAY);
+                            return;
+                        }
+                    }
+                }
+
+                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
+                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
+            }
+            else // the faction may be changed in uncharm
+            {
+                // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
+                if (m_vehicles[TEAM_ALLIANCE].erase(creature))
+                    team = TEAM_ALLIANCE;
+                else if (m_vehicles[TEAM_HORDE].erase(creature))
+                    team = TEAM_HORDE;
+                else
+                    return;
+            }
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            if (add)
+                m_questgivers[creature->GetDBTableGUIDLow()] = creature;
+            else
+                m_questgivers.erase(creature->GetDBTableGUIDLow());
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = add ? creature : NULL;
+                        break;
+                    }
+            }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = add ? creature : NULL;
+                        break;
+                    }
+            }
+            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
+        case CREATURE_SPIRIT_HEALER:
+        case CREATURE_TURRET:
+        case CREATURE_OTHER:
+            if (add)
+                UpdateCreatureInfo(creature);
+        default:
+            if (add)
+                m_creatures.insert(creature);
+            else
+                m_creatures.erase(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectCreate(GameObject *go, bool add)
+{
+    OutdoorPvP::OnGameObjectCreate(go, add);
+
+    if (UpdateGameObjectInfo(go))
+    {
+        if (add) m_gobjects.insert(go);
+        else m_gobjects.erase(go);
+    }
+    //do we need to store building?
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+        {
+            itr->second->building = add ? go : NULL;
+            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
+                itr->second->type = BUILDING_TOWER;
+            if (!add || itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
+            {
+                itr->second->health = go->GetGOValue()->building.health;
+                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+            else
+            {
+                go->GetGOValue()->building.health = itr->second->health;
+                if (itr->second->damageState == DAMAGE_DAMAGED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                else if (itr->second->damageState == DAMAGE_DESTROYED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::UpdateAllWorldObject()
+{
+    // update cre and go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+        UpdateGameObjectInfo(*itr);
+    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
+        UpdateCreatureInfo(*itr);
+    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
+        UpdateQuestGiverPosition((*itr).first, (*itr).second);
+
+    // rebuild and update building states
+    RebuildAllBuildings();
+
+    // update capture points
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            workshop->SetTeamByBuildingState();
+}
+
+void OutdoorPvPWG::RebuildAllBuildings()
+{
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+    {
+        if (itr->second->building)
+        {
+            UpdateGameObjectInfo(itr->second->building);
+            itr->second->building->Rebuild();
+            itr->second->health = itr->second->building->GetGOValue()->building.health;
+        }
+        else
+            itr->second->health = 0;
+
+        if (itr->second->damageState == DAMAGE_DESTROYED)
+        {
+            if (itr->second->type == BUILDING_WORKSHOP)
+                ModifyWorkshopCount(itr->second->GetTeam(), true);
+        }
+
+        itr->second->damageState = DAMAGE_INTACT;
+        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
+    }
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+}
+
+void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
+    data << uint32(571);
+    data << uint32(ZONE_WINTERGRASP);
+    data << uint32(0);
+    data << uint16(4+2+4+m_buildingStates.size());
+
+    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << m_clock[i];
+
+    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
+    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
+    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
+    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
+
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+        itr->second->FillData(data);
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        BroadcastPacket(data);
+}
+
+void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
+{
+    if (m_sendUpdate)
+        for (uint32 team = 0; team < 2; ++team)
+            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+                state->SendUpdate(*p_itr);
+}
+
+// Called at Start and Battle End
+bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
+{
+    if (!creature)
+        return false;
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_TURRET:
+            if (isWarTime())
+            {
+                if (!creature->isAlive())
+                    creature->Respawn(true);
+                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
+                creature->SetVisibility(VISIBILITY_ON);
+            }
+            else
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->SetVisibility(VISIBILITY_OFF);
+                creature->setFaction(35);
+            }
+            return false;
+        case CREATURE_OTHER:
+            if (isWarTime())
+            {
+                creature->SetVisibility(VISIBILITY_OFF);
+                creature->setFaction(35);
+            }
+            else
+            {
+                creature->RestoreFaction();
+                creature->SetVisibility(VISIBILITY_ON);
+            }
+            return false;
+        case CREATURE_SPIRIT_GUIDE:
+            if (isWarTime())
+            {
+               if (creature->GetAreaId() == 4575) // Select Fortress Spirit
+               {
+                 FortressSpirit = creature;
+                 if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
+                 {
+                    FortressSpirit->UpdateEntry(CRE_SPI_A);
+                 }
+                 if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
+                 {
+                    FortressSpirit->UpdateEntry(CRE_SPI_H);
+                 }
+               }
+                creature->SetVisibility(VISIBILITY_ON);
+                //creature->setDeathState(ALIVE);
+            }
+            else
+            {
+                creature->SetVisibility(VISIBILITY_OFF);
+                //creature->setDeathState(DEAD);
+            }
+            return false;
+        case CREATURE_SPIRIT_HEALER:
+            creature->SetVisibility(isWarTime() ? VISIBILITY_OFF : VISIBILITY_ON);
+            return false;
+        case CREATURE_ENGINEER:
+            return false;
+        case CREATURE_SIEGE_VEHICLE:
+            //creature->DisappearAndDie();
+            return false;
+        case CREATURE_GUARD:
+        case CREATURE_SPECIAL:
+        {
+            TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
+            if (itr != m_creEntryPair.end())
+            {
+                entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
+                _RespawnCreatureIfNeeded(creature, entry);
+            }
+            return false;
+        }
+        default:
+            return false;
+    }
+}
+
+bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
+{
+    assert(guid);
+    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
+
+    if (creature && creature->IsInWorld())
+    {
+        // if not questgiver or position is the same, do nothing
+        if (creature->GetPositionX() == pos.GetPositionX() &&
+            creature->GetPositionY() == pos.GetPositionY() &&
+            creature->GetPositionZ() == pos.GetPositionZ())
+            return false;
+
+        if (creature->isAlive() && creature->isInCombat())
+        {
+            creature->CombatStop(true);
+            creature->getHostileRefManager().deleteReferences();
+        }
+        creature->SetHomePosition(pos);
+        creature->DestroyForNearbyPlayers();
+        if (!creature->GetMap()->IsLoaded(pos.GetPositionX(), pos.GetPositionY()))
+            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
+        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+        if (!creature->isAlive())
+            creature->Respawn(true);
+    }
+    else
+        sObjectMgr.MoveCreData(guid, 571, pos);
+
+    return true;
+}
+
+// Return false = Need to rebuild at battle End/Start
+//        true  = no need to rebuild (ie: Banners or teleporters)
+bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
+{
+    uint32 attFaction = 35;
+    uint32 defFaction = 35;
+
+    if (isWarTime())
+    {
+        attFaction = WintergraspFaction[getAttackerTeam()];
+        defFaction = WintergraspFaction[getDefenderTeam()];
+    }
+
+    switch(go->GetGOInfo()->displayId)
+    {
+        case 8244: // Defender's Portal - Vehicle Teleporter
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
+            return true;
+        case 7967: // Titan relic
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
+            return true;
+
+        case 8165: // Wintergrasp Keep Door
+        case 7877: // Wintergrasp Fortress Wall
+        case 7878: // Wintergrasp Keep Tower
+        case 7906: // Wintergrasp Fortress Gate
+        case 7909: // Wintergrasp Wall
+            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
+            return false;
+        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
+            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
+            return false;
+        case 8208: // Goblin Workshop
+            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
+            if (workshop)
+                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
+            return false;
+    }
+
+    // Note: this is only for test, still need db support
+    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
+    if (itr != m_goDisplayPair.end())
+    {
+        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
+            itr->second : itr->first);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+		if (plr->getLevel() < 75) 
+		{
+		plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
+		return;
+		}
+        if (plr->getLevel() > 74)
+        {
+            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
+                && !plr->HasAura(SPELL_LIEUTENANT))
+                plr->CastSpell(plr, SPELL_RECRUIT, true);
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            }
+            else
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+            }
+        }
+    }
+
+    SendInitWorldStatesTo(plr);
+    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+// Reapply Auras if needed
+void OutdoorPvPWG::HandlePlayerResurrects(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() > 74)
+        {
+            // Tenacity
+            if (plr->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
+                plr->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
+            {
+                if (plr->HasAura(SPELL_TENACITY))
+                    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
+                if (newStack > 20)
+                    newStack = 20;
+                plr->SetAuraStack(SPELL_TENACITY, plr, newStack);
+            }
+
+            // Tower Control
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            }
+            else
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+            }
+        }
+    }
+    OutdoorPvP::HandlePlayerResurrects(plr, zone);
+}
+
+void OutdoorPvPWG::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (!plr->GetSession()->PlayerLogout())
+    {
+        if (plr->GetVehicle()) // dismiss in change zone case
+            plr->GetVehicle()->Dismiss();
+        plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    }
+    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::PromotePlayer(Player *killer) const
+{
+    Aura * aur;
+    if (aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
+        }
+        else
+            killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
+        }
+        else
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
+        return;
+
+    bool ok = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->getLevel() >= 70)
+            ok = true;
+        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+    }
+    else
+    {
+        switch(GetCreatureType(victim->GetEntry()))
+        {
+            case CREATURE_SIEGE_VEHICLE:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
+                ok = true;
+                break;
+            case CREATURE_GUARD:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+                ok = true;
+                break;
+            case CREATURE_TURRET:
+                ok = true;
+                break;
+        }
+    }
+
+    if (ok)
+    {
+        if (Group *pGroup = killer->GetGroup())
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
+                    PromotePlayer(itr->getSource());
+        }
+        else if (killer->getLevel() > 74)
+            PromotePlayer(killer);
+    }
+}
+
+// Recalculates Tenacity and applies it to Players / Vehicles
+void OutdoorPvPWG::UpdateTenacityStack()
+{
+    if (!isWarTime())
+        return;
+
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = 0;
+    uint32 hordeNum = 0;
+    int32 newStack = 0;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++allianceNum;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++hordeNum;
+
+    if (allianceNum && hordeNum)
+    {
+        if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+    }
+
+    if (newStack == m_tenacityStack)
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
+    }
+}
+
+void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
+{
+    uint32 value = timer%mod;
+    if (m_clock[digit] != value)
+    {
+        m_clock[digit] = value;
+        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
+        sWorld.SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
+    }
+}
+
+void OutdoorPvPWG::UpdateClock()
+{
+    uint32 timer = m_timer / 1000;
+    if (!isWarTime())
+        UpdateClockDigit(timer, 1, 10);
+    else
+        UpdateClockDigit(timer, 0, 10);
+
+//Announce in all world, comment it if you don't like/need it
+	 // Announce 30 minutes left
+ 	 if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false)) 
+        sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
+ 
+ 	 // Announce 10 minutes left
+	 if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false)) 
+       sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
+}
+
+bool OutdoorPvPWG::Update(uint32 diff)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return false;
+
+    if (m_timer > diff)
+    {
+        m_timer -= diff;
+
+        if (isWarTime())
+        {
+            OutdoorPvP::Update(diff); // update capture points
+
+            /*********************************************************/
+            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
+            /*********************************************************/
+
+            //this should be handled by spell system
+            m_LastResurrectTime += diff;
+            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+            {
+                if (GetReviveQueueSize())
+                {
+                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+                    {
+                        Creature* sh = NULL;
+                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                        {
+                            Player *plr = sObjectMgr.GetPlayer(*itr2);
+                            if (!plr)
+                                continue;
+
+                            if (!sh && plr->IsInWorld())
+                            {
+                                sh = plr->GetMap()->GetCreature(itr->first);
+                                // only for visual effect
+                                if (sh)
+                                    // Spirit Heal, effect 117
+                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                            }
+
+                            // Resurrection visual
+                         if (plr->GetDistance2d(sh) <= 18.0f)
+                           {
+                            plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+                            m_ResurrectQueue.push_back(*itr2);
+                           }
+                        }
+                        (itr->second).clear();
+                    }
+
+                    m_ReviveQueue.clear();
+                    m_LastResurrectTime = 0;
+                }
+                else
+                    // queue is clear and time passed, just update last resurrection time
+                    m_LastResurrectTime = 0;
+            }
+            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+            {
+                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+                {
+                    Player *plr = sObjectMgr.GetPlayer(*itr);
+                    if (!plr)
+                        continue;
+                    plr->ResurrectPlayer(1.0f);
+                    plr->CastSpell(plr, 6962, true);
+                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+                    sObjectAccessor.ConvertCorpseForPlayer(*itr);
+                }
+                m_ResurrectQueue.clear();
+            }
+        }
+        UpdateClock();
+    }
+    else
+    {
+        m_sendUpdate = false;
+        int32 entry = LANG_BG_WG_DEFENDED;
+
+        if (m_changeDefender)
+        {
+            m_changeDefender = false;
+            m_defender = getAttackerTeam();
+            entry = LANG_BG_WG_CAPTURED;
+        }
+
+        if (isWarTime())
+        {
+            if (m_timer != 1) // 1 = forceStopBattle
+                sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(entry), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+            EndBattle();
+        }
+        else
+        {
+            if (m_timer != 1) // 1 = forceStartBattle
+                sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
+            StartBattle();
+        }
+
+        UpdateAllWorldObject();
+        UpdateClock();
+
+        SendInitWorldStatesTo();
+        m_sendUpdate = true;
+    }
+
+    if (m_WSSaveTimer < diff)
+    {
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31001', `value`='%d', `comment`='wg m_wartime'",m_wartime);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31002', `value`='%d', `comment`='wg m_timer'",m_timer);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31003', `value`='%d', `comment`='wg m_defender'",m_defender);
+        m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+    } else m_WSSaveTimer -= diff;
+
+
+    return false;
+}
+
+void OutdoorPvPWG::forceStartBattle()
+{ // Uptime will do all the work
+    m_wartime = false;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
+    }
+		sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceStopBattle()
+{ // Uptime will do all the work.
+
+    if (!isWarTime())
+        m_wartime = true;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
+    }
+	sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceChangeTeam()
+{
+    m_changeDefender = true;
+    m_timer = 1;
+    sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr.GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+    if (isWarTime())
+        forceStartBattle();
+    else
+        forceStopBattle();
+}
+
+// Can be forced by gm's while in battle so have to reset in case it was wartime
+void OutdoorPvPWG::StartBattle()
+{
+	uint32 CountDef=0;
+	uint32 CountAtk=0;
+    m_wartime = true;
+    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
+
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+       if ((*itr)->getLevel() < 75)
+        {
+          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        }
+       else
+        {
+          CountDef++;
+          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        if ((*itr)->getLevel() < 75)
+        {
+          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        }
+        else
+        {
+          CountAtk++;
+          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+if (sWorld.getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
+ {
+ if ((CountAtk < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
+  {
+   if (CountAtk<=CountDef)
+	   sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
+   if (CountDef<CountAtk)
+     {  
+	 sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
+	 m_changeDefender=true;
+     }
+   forceStopBattle();
+   return;
+  }
+ }
+
+//    TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
+
+    // Remove Essence of Wintergrasp to all players
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+    sWorld.UpdateAreaDependentAuras();
+
+    // destroyed all vehicles
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+        {
+            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+    }
+    UpdateTenacityStack();
+	// Update timer in players battlegrounds tab
+    sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::EndBattle()
+{
+    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    sWorld.UpdateAreaDependentAuras();
+//Sound on End Battle
+for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+{
+	if (getDefenderTeam()==TEAM_ALLIANCE)
+	{
+    TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
+	}
+    else TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
+	(*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
+}
+for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+{
+   (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
+}
+
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // destroyed all vehicles
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+
+        if (m_players[team].empty())
+            continue;
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            // When WG ends the zone is cleaned including corpses, revive all players if dead
+            if ((*itr)->isDead())
+            {
+                (*itr)->ResurrectPlayer(1.0f);
+				sObjectAccessor.ConvertCorpseForPlayer((*itr)->GetGUID());
+                //ObjectAccessor::Instance().ConvertCorpseForPlayer((*itr)->GetGUID());
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+            (*itr)->CombatStop(true);
+            (*itr)->getHostileRefManager().deleteReferences();
+        }
+
+        if (m_timer == 1) // Battle End was forced so no reward.
+        {
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+            continue;
+        }
+
+        // calculate rewards
+        uint32 intactNum = 0;
+        uint32 damagedNum = 0;
+        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                if (workshop->m_buildingState->GetTeam() == team)
+                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
+                        ++damagedNum;
+                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
+                        ++intactNum;
+
+        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
+        uint32 baseHonor = 0;
+        uint32 marks = 0;
+        uint32 playersWithRankNum = 0;
+        uint32 honor = 0;
+
+        if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+        {
+            // Calculate Level 70+ with Corporal or Lieutenant rank
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
+                    ++playersWithRankNum;
+
+            baseHonor = team == getDefenderTeam() ? sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
+            if (playersWithRankNum)
+                baseHonor /= playersWithRankNum;
+        }
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+
+            if ((*itr)->getLevel() < 75)
+                continue; // No rewards for level <75
+
+            // give rewards
+            if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+            {
+                if (team == getDefenderTeam())
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 3;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 2;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 1;
+                        honor = 0;
+                    }
+                }
+                else
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 0;
+                        honor = 0;
+                    }
+                }
+                (*itr)->RewardHonor(NULL, 1, honor);
+                RewardMarkOfHonor(*itr, marks);
+                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
+            }
+            else
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    // TODO - Honor from SpellReward should be shared by team players
+                    // TODO - Marks should be given depending on Rank but 3 are given
+                    // each time so Won't give any to recruits
+                    (*itr)->CastSpell(*itr, spellRewardId, true);
+                    for (uint32 i = 0; i < intactNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
+                    for (uint32 i = 0; i < damagedNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
+                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
+                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
+                }
+            }
+            if (team == getDefenderTeam())
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
+                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
+                }
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        }
+    }
+
+    m_wartime = false;
+    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
+    RemoveOfflinePlayerWGAuras();
+    // Update timer in players battlegrounds tab
+    sWorld.SendWintergraspState();
+}
+
+bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
+{
+    TeamId team = workshop->m_buildingState->GetTeam();
+    if (team == TEAM_NEUTRAL)
+        return false;
+
+    return isWarTime()
+        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
+        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
+}
+
+uint32 OutdoorPvPWG::GetData(uint32 id)
+{
+    // if can build more vehicles
+    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
+        return CanBuildVehicle(workshop) ? 1 : 0;
+
+    return 0;
+}
+
+void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return;
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        sLog.outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
+{
+    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
+    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
+    m_questgivers[guid] = NULL;
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+        sObjectMgr.MoveCreData(guid, 571, posAlli);
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
+{
+    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
+        return dynamic_cast<OPvPCapturePointWG*>(cp);
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_engGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_workshopGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+/*########################################################
+ * Copy of Battleground system to make Spirit Guides Work
+ *#######################################################*/
+void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    pl->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player *plr = sObjectMgr.GetPlayer(player_guid);
+    if (!plr)
+        return;
+
+    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+
+                Player *plr = sObjectMgr.GetPlayer(player_guid);
+                if (!plr)
+                    return;
+
+                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+
+                return;
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr.GetPlayer(*itr);
+			if (!plr)
+                continue;
+
+			if (plr->getFaction() == ALLIANCE)
+			{
+            if (!ClosestGrave)
+                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+			}
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr.GetPlayer(*itr);
+			if (!plr)
+                continue;
+
+			if (plr->getFaction() == HORDE)
+			{
+            if (!ClosestGrave)
+                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+			}
+        }
+    }
+}
+
+/*######
+##OPvPCapturePointWG
+######*/
+
+OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state)
+: OPvPCapturePoint(opvp), m_buildingState(state), m_wintergrasp(opvp)
+, m_engineer(NULL), m_engGuid(0), m_spiritguide(NULL)
+, m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_spiGuid(0)
+{
+}
+
+void OPvPCapturePointWG::SetTeamByBuildingState()
+{
+    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
+    {
+        m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+    }
+    else if (m_buildingState->GetTeam() == TEAM_HORDE)
+    {
+        m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+    }
+    else
+    {
+        m_value = 0;
+        m_State = OBJECTIVESTATE_NEUTRAL;
+    }
+
+    if (m_team != m_buildingState->GetTeam())
+    {
+        TeamId oldTeam = m_team;
+        m_team = m_buildingState->GetTeam();
+        ChangeTeam(oldTeam);
+    }
+
+    SendChangePhase();
+}
+
+void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
+{
+   entry = 0;
+   guide_entry = 0;
+   guide_entry_fortress_horde = 0;
+   guide_entry_fortress_alliance = 0;
+
+    if (oldTeam != TEAM_NEUTRAL)
+        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
+
+    if (m_team != TEAM_NEUTRAL)
+    {
+        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
+        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
+        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
+        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
+        m_wintergrasp->ModifyWorkshopCount(m_team, true);
+    }
+
+    if (m_capturePoint)
+        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
+
+    m_buildingState->SetTeam(m_team);
+    // TODO: this may be sent twice
+    m_wintergrasp->BroadcastStateChange(m_buildingState);
+
+    if (m_buildingState->building)
+        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
+
+    if (entry)
+    {
+        if (m_engGuid)
+        {
+            *m_engEntry = entry;
+            _RespawnCreatureIfNeeded(m_engineer, entry);
+        }
+        if (m_spiGuid)
+        {
+         if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
+         {
+            *m_spiEntry = guide_entry;
+            _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
+            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
+            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
+         }
+         else
+         {
+            *m_spiEntry = guide_entry;
+            _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
+            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
+            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
+         }
+        }
+    }
+    else if (m_engineer)
+        m_engineer->SetVisibility(VISIBILITY_OFF);
+
+    sLog.outDebug("Wintergrasp workshop now belongs to %u.", (uint32)m_buildingState->GetTeam());
+}
+
+class OutdoorPvP_wintergrasp : public OutdoorPvPScript
+{
+    public:
+
+        OutdoorPvP_wintergrasp()
+            : OutdoorPvPScript("outdoorpvp_wg")
+        {
+        }
+
+        OutdoorPvP* GetOutdoorPvP() const
+        {
+            return new OutdoorPvPWG();
+        }
+};
+
+void AddSC_outdoorpvp_wg()
+{
+    new OutdoorPvP_wintergrasp();
 }
\ No newline at end of file
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -1,2670 +1,2673 @@
-################################################
-# Trinity@Greedy-core World Server configuration file #
-################################################
-[worldserver]
-
-# Note to devs, line breaks should be at column 80
-###############################################################################
-# CONNECTIONS AND DIRECTORIES
-#
-#    RealmID
-#        RealmID must match the realmlist inside the realmd database
-#
-#    DataDir
-#        Data directory setting.
-#        Important: DataDir needs to be quoted, as it is a string which may
-#         contain space characters.
-#        Example: "@prefix@/share/trinitycore"
-#
-#    LogsDir
-#        Logs directory setting.
-#        Important: Logs dir must exists, or all logs need to be disabled
-#        Default: "" - no log directory prefix, if used log names isn't
-#         absolute path then logs will be stored in current directory.
-#
-#    LoginDatabaseInfo
-#    WorldDatabaseInfo
-#    CharacterDatabaseInfo
-#        Database connection settings for the world server.
-#        Default:
-#                    hostname;port;username;password;database
-#                    .;somenumber;username;password;database
-#                     - use named pipes in Windows
-#                    Named pipes: mySQL required adding
-#                        "enable-named-pipe" to [mysqld] section my.ini
-#                    .;/path/to/unix_socket;username;password;database
-#                     - use Unix sockets in Unix/Linux
-#
-#    LoginDatabase.WorkerThreads
-#    WorldDatabase.WorkerThreads
-#    CharacterDatabase.WorkerThreads
-#        The amount of worker threads spawned to handle
-#        asynchronous (delayed) MySQL statements.
-#        Each worker thread is mirrored with its own
-#        connection to the MySQL server and their own
-#        thread on the MySQL server.
-#        Default: 1
-#
-#    LoginDatabase.SynchThreads
-#    WorldDatabase.SynchThreads
-#    CharacterDatabase.SynchThreads
-#        The amount of MySQL connections spawned to handle
-#        synchronous (blocking) MySQL statements.
-#        Default: 1, 1, 2
-#
-#    MaxPingTime
-#        Settings for maximum database-ping interval (seconds between pings)
-#        Default: 1800 (30 minutes)
-#
-#    WorldServerPort
-#        Default WorldServerPort
-#
-#    BindIP
-#        Bind World Server to IP/hostname
-#
-###############################################################################
-
-RealmID = 1
-DataDir = "."
-LogsDir = ""
-LoginDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;auth"
-WorldDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;world"
-CharacterDatabaseInfo = "127.0.0.1;3306;trinity;trinity;characters"
-LoginDatabase.WorkerThreads = 1
-WorldDatabase.WorkerThreads = 1
-CharacterDatabase.WorkerThreads = 1
-LoginDatabase.SynchThreads = 1
-WorldDatabase.SynchThreads = 1
-CharacterDatabase.SynchThreads = 2
-MaxPingTime = 1800
-WorldServerPort = 8085
-BindIP = "0.0.0.0"
-
-###############################################################################
-# SCRIPTING SETTINGS
-#
-#    Locale
-#        Setting for current (DBC) locale to use
-#
-#    EventAI Error reporting
-#        Default: 0 - Only startup
-#                 1 - Startup errors and Runtime event errors
-#                 2 - Startup errors, Runtime event errors, and Creation errors
-#
-###############################################################################
-
-Locale = 0
-EAIErrorLevel = 2
-
-###############################################################################
-# PERFORMANCE SETINGS
-#
-#    UseProcessors
-#        Processors mask for multi-processor system (Used only in Windows)
-#        Default: 0 (selected by OS)
-#                 number (bitmask value of selected processors)
-#
-#    ProcessPriority
-#        Process priority setting (Used only at Windows)
-#        Default: 1 (HIGH)
-#                 0 (Normal)
-#
-#    Compression
-#        Compression level for update packages sent to client (1..9)
-#        Default: 1 (speed)
-#                 9 (best compression)
-#
-#    PlayerLimit
-#        Maximum number of players in the world. Excluding Mods, GMs and Admins
-#        Default: 100
-#                 0 (for infinite players)
-#                 If you want to block players and enable Mods, GMs or Admins use
-#                 DB field realmd.realmlist.allowedSecurityLevel
-#
-#    SaveRespawnTimeImmediately
-#        Save respawn time for creatures at death and gameobjects at use/open
-#        Default: 1 (save creature/gameobject respawn time immediately)
-#                 0 (save creature/gameobject respawn time at grid unload)
-#
-#    MaxOverspeedPings
-#        Maximum overspeed ping count before player kick
-#         (minimum is 2, 0 used for disable check)
-#        Default: 2
-#
-#    GridUnload
-#        Unload grids
-#         (if you have lot memory you can disable it to speed up
-#         player move to new grids second time)
-#        Default: 1 (unload grids)
-#                 0 (do not unload grids)
-#
-#    SocketSelectTime
-#        Socket select time (in milliseconds)
-#        Default: 10000 (10 secs)
-#
-#    SocketTimeOutTime
-#        Time in milliseconds afer which a connection sitting idle on the character
-#        selection screen is disconnected.
-#        Default: 900000 (15 minutes)
-#
-#    SessionAddDelay
-#        Time in microseconds that a network thread will sleep after authentication
-#        protocol and adding a connection to the world session map.
-#        Default: 10000 (10 milliseconds, 0,01 second)
-#
-#    GridCleanUpDelay
-#        Grid clean up delay (in milliseconds)
-#        Default: 300000 (5 min)
-#
-#    MapUpdateInterval
-#        Map update interval (in milliseconds)
-#        Default: 100
-#
-#    ChangeWeatherInterval
-#        Weather update interval (in milliseconds)
-#        Default: 600000 (10 min)
-#
-#    PlayerSaveInterval
-#        Player save interval (in milliseconds)
-#        Default: 900000 (15 min)
-#
-#    PlayerSave.Stats.MinLevel
-#        Minimum level for saving character stats for external usage in database    
-#        Default: 0  (do not save character stats)    
-#                 1+ (save stats for characters with level 1+)    
-#
-#    PlayerSave.Stats.SaveOnlyOnLogout    
-#        Enable/Disable saving of character stats only on logout
-#        Default: 1 (only save on logout)
-#                 0 (save on every player save)
-#
-#    vmap.enableLOS
-#    vmap.enableHeight
-#        Enable/Disable VMmap support for line of sight and height calculation
-#                 0 (disable)
-#        Default: 1 (enable)
-#
-#    vmap.ignoreMapIds
-#        Map id that will be ignored by VMaps
-#         List of ids with delimiter ','
-#         If more then one id is defined and spaces are included, the string
-#         has to be enclosed by "
-#        Example: "369,0,1,530"
-#
-#    vmap.ignoreSpellIds
-#        These spells are ignored for LoS calculation
-#         List of ids with delimiter ','
-#
-#    vmap.petLOS
-#        Check LOS for pets, to avoid them going through walls etc.
-#                 0 (disable, somewhat less CPU usage)
-#        Default: 1 (enable, each pet attack command will check for LOS)
-#
-#    vmap.enableIndoorCheck
-#        Enable/Disable VMap based indoor check to remove outdoor-only auras (mounts etc.)
-#                 0 (disabled, somewhat less CPU usage)
-#        Default: 1 (enabled)
-#
-#    DetectPosCollision
-#        Check final move position, summon position, etc for visible collision
-#         with other objects or wall (wall only if vmaps are enabled)
-#        Default: 1 (enable, required more CPU usage)
-#                 0 (disable, less position precision but will use less CPU)
-#
-#    TargetPosRecalculateRange
-#        Max distance from movement target point (+moving unit size) and
-#         targeted object (+size) after that new target movement point
-#         calculated. Max: melee attack range (5), min: contact range (0.5)
-#         More distance let have better performence, less distance let have
-#         more sensitive reaction at target move.
-#        Default: 1.5
-#
-#    UpdateUptimeInterval
-#        Update realm uptime period in minutes. Must be > 0
-#        Default: 10 (minutes)
-#
-#    LogDB.Opt.ClearInterval
-#        Time for the WUPDATE_CLEANDB timer that clears the `logs` table
-#         of old entries. Must be > 0.
-#        Default: 10 (minutes)
-#
-#    LogDB.Opt.ClearTime
-#        The maximum time in seconds of old `logs` table entries to keep.
-#        Default: 1209600 (14 days)
-#                 0 - don't clear
-#
-#    MaxCoreStuckTime
-#        Periodically check if the process is frozen, if this is the case
-#         force crash after the specified amount of seconds. Must be > 0.
-#         Recommended > 10 secs if you use this.
-#        Default: 0 (Disabled)
-#
-#    AddonChannel
-#        Permit/disable the use of the addon channel through the server
-#         (some client side addons will not work correctly with disabled
-#         addon channel)
-#        Default: 1 (permit addon channel)
-#                 0 (do not permit addon channel)
-#
-#    MapUpdate.Threads
-#    Number of threads to update maps.
-#    Default: 1
-#
-#    CleanCharacterDB
-#        Perform character db clean ups on start up
-#        Default: 0 (Disabled)
-#                 1 (Enable)
-#
-###############################################################################
-
-UseProcessors = 0
-ProcessPriority = 1
-Compression = 1
-PlayerLimit = 100
-SaveRespawnTimeImmediately = 1
-MaxOverspeedPings = 2
-GridUnload = 1
-SocketSelectTime = 10000
-SocketTimeOutTime = 900000
-SessionAddDelay = 10000
-GridCleanUpDelay = 300000
-MapUpdateInterval = 100
-ChangeWeatherInterval = 600000
-PlayerSaveInterval = 900000
-PlayerSave.Stats.MinLevel = 0
-PlayerSave.Stats.SaveOnlyOnLogout = 1
-vmap.enableLOS = 1
-vmap.enableHeight = 1
-vmap.ignoreMapIds = ""
-vmap.ignoreSpellIds = "7720"
-vmap.petLOS = 1
-vmap.enableIndoorCheck = 1
-DetectPosCollision = 1
-TargetPosRecalculateRange = 1.5
-UpdateUptimeInterval = 10
-LogDB.Opt.ClearInterval = 10
-LogDB.Opt.ClearTime = 1209600
-MaxCoreStuckTime = 0
-AddonChannel = 1
-MapUpdate.Threads = 1
-CleanCharacterDB = 0
-
-###############################################################################
-# SERVER LOGGING
-#
-#    LogSQL
-#        Enable logging of SQL commands from in game
-#         All commands are written to a file: YYYY-MM-DD_logSQL.sql
-#         If a new day starts (00:00:00) then a new file is created
-#         the old file will not be deleted.
-#        Default: 1 - Write SQL code to logfile
-#                 0 - Do not log
-#
-#    PidFile
-#        World daemon PID file
-#        Default: ""             - do not create PID file
-#                 "./worldd.pid" - create PID file (recommended name)
-#
-#    LogLevel
-#        Server console level of logging
-#                 0 = Minimum
-#        Default: 1 = Basic
-#                 2 = Detail
-#                 3 = Full/Debug
-#
-#    LogFile
-#        Logfile name
-#        Default: "Server.log"
-#                 "" - Empty name disable creating log file
-#
-#    ChatLogFile
-#        Log file for chat logs
-#        Default: "chat.log"
-#                 "" - Empty name for disable
-#
-#    LogTimestamp
-#        Logfile with timestamp of server start in name
-#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
-#        Default: 0 - no timestamp in name
-#                 1 - add timestamp in name
-#
-#    LogFileLevel
-#        Server file level of logging
-#        Default: 0 = Minimum
-#                 1 = Basic
-#                 2 = Detail
-#                 3 = Full/Debug
-#
-#    LogFilter_AchievementUpdates
-#    LogFilter_CreatureMoves
-#    LogFilter_TransportMoves
-#    LogFilter_VisibilityChanges
-#        Log filters
-#        Default: 1 - not include with any log level
-#                 0 - include in log if log level permit
-#
-#    WorldLogFile
-#        Packet logging file for the worldserver
-#        Default: "world.log"
-#
-#    DBErrorLogFile
-#        Log file of DB errors detected at server run
-#        Default: "DBErrors.log"
-#
-#    CharLogFile
-#        Character operations logfile name
-#        Default: "Char.log"
-#                 "" - Empty name disable creating log file
-#
-#    CharLogTimestamp
-#        Logfile with timestamp of server start in name
-#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
-#        Default: 0 - no timestamp in name
-#                 1 - add timestamp in name
-#
-#    CharLogDump
-#        Write character dump before deleting in Char.log
-#         For restoration, cut character data from log starting from
-#         line == START DUMP == to line == END DUMP == (exclusive) in file
-#         and load it using the loadpdump command
-#        Default: 0 - don't include dumping chars to log
-#                 1 - include dumping chars to log
-#
-#    CharLogDump.Separate
-#        Write character dump to separate file
-#        Default: 0 - don't write dump to separate file
-#                 1 - write each dump to separate file
-#
-#    CharLogDump.SeparateDir
-#        Subdirectory within logs dir for separate char dumps.
-#
-#    GmLogFile
-#        Log file of gm commands
-#        Default: "gm_commands.log"
-#                 "" - Empty name for disable
-#
-#    GmLogTimestamp
-#        GM Logfile with timestamp of server start in name
-#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
-#        Default: 0 - no timestamp in name
-#                 1 - add timestamp in name
-#
-#    GmLogPerAccount
-#        GM Logfiles with GM account id
-#         (Note: logs not created if GmLogFile not set)
-#        Default: 0 - add gm log data to single log file
-#                 1 - add gm log data to account specific log files with name
-#                     in form Logname_#ID_YYYY-MM-DD_HH-MM-SS.Ext
-#                     or form Logname_#ID.Ext
-#
-#    RaLogFile
-#        Log file of RA commands
-#        Default: "Ra.log"
-#                 "" - Empty name for disable
-#
-#    ArenaLogFile
-#        Log file of arena fights and arena team creations
-#        Default: "" - do not create arena log file
-#
-#    ArenaLog.ExtendedInfo
-#        Include extended info for each player after rated arena (guid, name, team, IP, healing/damage done, killing blows)
-#        Default: 0 - disabled
-#                 1 - enabled
-#
-#    SQLDriverLogFile
-#        Log file of SQL driver events.
-#        For effective query logging you need to build in debug configuration.
-#        Default: "" - Empty name for disable
-#
-#    LogColors
-#        Color for messages (format "normal basic detail debug")
-#        Default: "" - no colors
-#        Colors: 0  - BLACK
-#                1  - RED
-#                2  - GREEN
-#                3  - BROWN
-#                4  - BLUE
-#                5  - MAGENTA
-#                6  - CYAN
-#                7  - GREY
-#                8  - YELLOW
-#                9  - LRED
-#                10 - LGREEN
-#                11 - LBLUE
-#                12 - LMAGENTA
-#                13 - LCYAN
-#                14 - WHITE
-#        Example: "13 11 9 5"
-#
-#    EnableLogDB
-#        Enable/disable logging to database (LogDatabaseInfo).
-#        Default: 0 - disabled
-#                 1 - enabled
-#
-#    DBLogLevel
-#        Log level of DB logging.
-#                 0 = Minimum
-#                 1 = Basic
-#                 2 = Detail
-#        Default: 3 = Full/Debug
-#
-#    LogDB.Char
-#        Enable/disable logging character outputs to DB.
-#        Default: 0 - off
-#                 1 - on
-#
-#    LogDB.GM
-#        Enable/disable logging GM commands to DB.
-#        Default: 0 - off
-#                 1 - on
-#
-#    LogDB.RA
-#        Enable/disable logging remote access events to DB.
-#        Default: 0 - off
-#                 1 - on
-#
-#    LogDB.World
-#        Enable/disable logging world packets to DB.
-#        Default: 0 - off
-#                 1 - on (very heavy)
-#
-#    LogDB.Chat
-#        Enable/disable logging chat messages to the database.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.Channel
-#        Enable logging chatting in custom channels.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.Whisper
-#        Enable logging whispers between players.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.Party
-#        Enable logging party messages.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.Raid
-#        Enable logging raid messages.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.Guild
-#        Enable logging guild messages.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.Public
-#        Enable logging public chat events (say/yell/emote).
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.Addon
-#        Enable logging addon messages.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogs.BattleGround
-#        Enable logging battleground chats.
-#        Default: 0 - off
-#                 1 - on
-#
-#    ChatLogTimestamp
-#        Chat Logfile with timestamp of server start in name
-#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
-#        Default: 0 - no timestamp in name
-#                 1 - add timestamp in name
-#
-###############################################################################
-
-LogSQL = 1
-PidFile = ""
-LogLevel = 1
-LogFile = "Server.log"
-ChatLogFile = "chat.log"
-LogTimestamp = 0
-LogFileLevel = 0
-LogFilter_AchievementUpdates = 1
-LogFilter_CreatureMoves = 1
-LogFilter_TransportMoves = 1
-LogFilter_VisibilityChanges = 1
-WorldLogFile = ""
-DBErrorLogFile = "db_errors.log"
-CharLogFile = "characters.log"
-CharLogTimestamp = 0
-CharLogDump = 0
-CharLogDump.Separate = 0
-CharLogDump.SeparateDir = ""
-GmLogFile = "gm_commands.log"
-GmLogTimestamp = 0
-GmLogPerAccount = 0
-RaLogFile = "ra_commands.log"
-ArenaLogFile = ""
-ArenaLog.ExtendedInfo = 0
-SQLDriverLogFile = ""
-LogColors = ""
-EnableLogDB = 0
-DBLogLevel = 2
-LogDB.Char   = 0
-LogDB.GM     = 0
-LogDB.RA     = 0
-LogDB.World  = 0
-LogDB.Chat   = 0
-ChatLogs.Channel      = 0
-ChatLogs.SysChan      = 0
-ChatLogs.Whisper      = 0
-ChatLogs.Party        = 0
-ChatLogs.Raid         = 0
-ChatLogs.Guild        = 0
-ChatLogs.Public       = 0
-ChatLogs.Addon        = 0
-ChatLogs.BattleGround = 0
-ChatLogTimestamp = 0
-
-###############################################################################
-# CHAT LOGGING AND LEXICS CUTTER
-#
-#    ChatLog.Enable
-#        Enable system of chat logging.
-#        Default: 1 - on
-#                 0 - off
-#
-#    ChatLog.DateSplit
-#        Split log files by date (filename must include $d as date placeholder).
-#        Default: 1 - split
-#                 0 - do not split
-#
-#    ChatLog.UTFHeader
-#        Add UTF8 header at the beginning of new file.
-#        Default: 1 - add
-#                 0 - do not add
-#
-#    ChatLog.Ignore.Unprintable
-#        Ignore messages with unprintable characters.
-#        Default: 1 - ignore
-#                 0 - do not ignore
-#
-#    ChatLog.Lexics.Enable
-#        Enable lexics cutter in chats.
-#        Default: 1 - on
-#                 0 - off
-#
-#    ChatLog.Lexics.Cut.Enable
-#        Cut innormative lexics in chat.
-#        Default: 1 - cut
-#                 0 - do not cut
-#
-#    ChatLog.Lexics.Cut.Replacement
-#        Text shown instead of message with innormative lexics.
-#
-#    ChatLog.Lexics.WordsFile
-#        Path to the file with words considered as innormative.
-#
-#    ChatLog.Lexics.AnalogsFile
-#        Path to the file with letter analogs.
-#
-#    ChatLog.Lexics.Ignore.Spaces
-#        Ignore spaces in filtered words. Example: W O R D
-#        Default: 1 - ignore
-#                 0 - do not ignore
-#
-#    ChatLog.Lexics.Ignore.Repeats
-#        Ignore repeating symbols in filtered words. Example: WWWOOOORRRRRRDDD
-#        Default: 1 - ignore
-#                 0 - do not ignore
-#
-#    ChatLog.Lexics.Ignore.GM
-#        Ignore (do not filter) messages from GM.
-#        Default: 1 - ignore
-#                 0 - do not ignore
-#
-#    ChatLog.Lexics.Action
-#        Action taken when bad lexics is found.
-#        Default: 0 - log only
-#                 1 - polymorph
-#                 2 - stun
-#                 3 - instant kill
-#                 4 - leave 5 health
-#                 5 - mute
-#                 6 - stuck (works as stun + 50% health) [by KAPATEJIb]
-#                 7 - resurrection sickness [by Koshei]
-#                 8 - shear [by Koshei]
-#
-#    ChatLog.Lexics.Action.Duration
-#        Duration of action in milliseconds.
-#        Default: 0 - no duration
-#
-#    SETTINGS FOR DIFFERENT CHAT TYPES
-#    Available types:
-#        * Chat - common chat
-#        * Party - party chat
-#        * Guild - guild chat
-#        * Whisper - whispers
-#        * Channel - channels
-#        * Raid - raid chat
-#        * BattleGround - battleground chat
-#        * Lexics.Innormative - messages filtered by lexics cutter
-#
-#    ChatLog.*.File
-#        Log file name for given chat type.
-#
-#    ChatLog.*.Screen
-#        Output message in server console for given chat type.
-#        Default: 0 - do not show
-#                 1 - show
-#
-#    ChatLog.Lexics.*.Cut
-#        Cut lexics for given chat type (except Innormative).
-#        Default: 1 - cut
-#                 0 - do not cut
-#
-###############################################################################
-
-ChatLog.Enable = 1
-ChatLog.DateSplit = 1
-ChatLog.UTFHeader = 1
-ChatLog.Ignore.Unprintable = 1
-
-ChatLog.Lexics.Enable = 1
-ChatLog.Lexics.Cut.Enable = 1
-ChatLog.Lexics.Cut.Replacement = &!@^%!^&*!!!
-ChatLog.Lexics.AnalogsFile = letter_analogs.txt
-ChatLog.Lexics.WordsFile = innormative_words.txt
-ChatLog.Lexics.Ignore.Spaces = 1
-ChatLog.Lexics.Ignore.Repeats = 1
-ChatLog.Lexics.Ignore.GM = 1
-ChatLog.Lexics.Action = 0
-ChatLog.Lexics.Action.Duration = 0
-
-ChatLog.Chat.File = "main_chat-$d.log"
-ChatLog.Chat.Screen = 0
-ChatLog.Lexics.Chat.Cut = 1
-
-ChatLog.Party.File = "party_chat-$d.log"
-ChatLog.Party.Screen = 0
-ChatLog.Lexics.Party.Cut = 1
-
-ChatLog.Guild.File = "guild_chat-$d.log"
-ChatLog.Guild.Screen = 0
-ChatLog.Lexics.Guild.Cut = 1
-
-ChatLog.Whisper.File = "whisper_chat-$d.log"
-ChatLog.Whisper.Screen = 0
-ChatLog.Lexics.Whisper.Cut = 1
-
-ChatLog.Channel.File = "channel_chat-$d.log"
-ChatLog.Channel.Screen = 0
-ChatLog.Lexics.Channel.Cut = 1
-
-ChatLog.Raid.File = "raid_chat-$d.log"
-ChatLog.Raid.Screen = 0
-ChatLog.Lexics.Raid.Cut = 1
-
-ChatLog.BattleGround.File = "bg_chat-$d.log"
-ChatLog.BattleGround.Screen = 0
-ChatLog.Lexics.BattleGround.Cut = 1
-
-ChatLog.Lexics.Innormative.File = "innormative-$d.log"
-ChatLog.Lexics.Innormative.Screen = 0
-
-###############################################################################
-# SERVER SETTINGS
-#
-#    GameType
-#        Server realm style
-#        Default: 0 = NORMAL
-#                 1 = PVP
-#                 4 = NORMAL
-#                 6 = RP
-#                 8 = RPPVP
-#                 16 FFA_PVP (free for all pvp mode like arena PvP in all
-#                     zones except rest activated places and sanctuaries)
-#
-#    RealmZone
-#        Server realm zone (set allowed alphabet in character names/etc)
-#         See also Strict*Names options.
-#        Default: 1 Development    - any language
-#                 2 United States  - extended-Latin
-#                 3 Oceanic        - extended-Latin
-#                 4 Latin America  - extended-Latin
-#                 5 Tournament     - basic-Latin at create, any at login
-#                 6 Korea          - East-Asian
-#                 7 Tournament     - basic-Latin at create, any at login
-#                 8 English        - extended-Latin
-#                 9 German         - extended-Latin
-#                 10 French        - extended-Latin
-#                 11 Spanish       - extended-Latin
-#                 12 Russian       - Cyrillic
-#                 13 Tournament    - basic-Latin at create, any at login
-#                 14 Taiwan        - East-Asian
-#                 15 Tournament    - basic-Latin at create, any at login
-#                 16 China         - East-Asian
-#                 17 CN1           - basic-Latin at create, any at login
-#                 18 CN2           - basic-Latin at create, any at login
-#                 19 CN3           - basic-Latin at create, any at login
-#                 20 CN4           - basic-Latin at create, any at login
-#                 21 CN5           - basic-Latin at create, any at login
-#                 22 CN6           - basic-Latin at create, any at login
-#                 23 CN7           - basic-Latin at create, any at login
-#                 24 CN8           - basic-Latin at create, any at login
-#                 25 Tournament    - basic-Latin at create, any at login
-#                 26 Test Server   - any language
-#                 27 Tournament    - basic-Latin at create, any at login
-#                 28 QA Server     - any language
-#                 29 CN9           - basic-Latin at create, any at login
-#
-#    Expansion
-#        Allow server use content from expansion
-#        Default: 2 - check expansion 2 maps existence, and if client support
-#                      expansion 2 and account have expansion 2 setting then
-#                      allow visit expansion 2 maps, allow create new class
-#                      character)
-#                 1 - check expansion 1 maps existence, and if client support
-#                      expansion 1 and account have expansion 1 setting then
-#                      allow visit expansion 1 maps, allow create new races
-#                      character)
-#                 0 - don't check expansion maps existence, don't allow visit
-#                      maps, don't allow create new race or new class
-#                      characters, ignore account expansion setting)
-#
-#    DBC.Locale
-#        DBC Language Settings
-#        Default: 255 = Auto Detect
-#                 0   = English
-#                 1   = Korean
-#                 2   = French
-#                 3   = German
-#                 4   = Chinese
-#                 5   = Taiwanese
-#                 6   = Spanish
-#                 7   = Spanish Mexico
-#                 8   = Russian
-#
-#    DeclinedNames
-#        Allow russian clients to set and use declined names
-#        Default: 0 - do not use declined names, except when
-#                      the Russian RealmZone is set
-#                 1 - use declined names
-#
-#    StrictPlayerNames
-#        Limit player name to language specific symbol set, don't allow
-#         character creation, and set rename request and disconnect at not
-#         allowed symbols name
-#        Default: 0 disable (limited server timezone dependent client check)
-#                 1 basic latin characters  (strict)
-#                 2 realm zone specific (strict). See RealmZone setting.
-#                   Note: In any case if you want correctly see character
-#                   name at client this client must have appropriate fonts
-#                   (included in client by default, with active official
-#                   localization or custom localization fonts in
-#                   clientdir/Fonts).
-#                 3 basic latin characters + server timezone specific
-#
-#    StrictCharterNames
-#        Limit guild/arena team charter names to language specific symbol set,
-#          don't allow charter creation with unallowed symbols in name
-#        Default: 0 disable
-#                 1 basic latin characters  (strict)
-#                 2 realm zone specific (strict). See RealmZone setting.
-#                   Note: In any case if you want correctly see character
-#                   name at client this client must have appropriate fonts
-#                   (included in client by default, with active official
-#                   localization or custom localization fonts in
-#                   clientdir/Fonts).
-#                 3 basic latin characters + server timezone specific
-#
-#    StrictPetNames
-#        Limit pet names to language specific symbols set
-#        Default: 0 disable
-#                 1 basic latin characters  (strict)
-#                 2 realm zone specific (strict). See RealmZone setting.
-#                   Note: In any case if you want correctly see character
-#                   name at client this client must have appropriate fonts
-#                   (included in client by default, with active official
-#                   localization or custom localization fonts in
-#                   clientdir/Fonts).
-#                 3 basic latin characters + server timezone specific
-#
-#    MinPlayerName
-#        Minimal name length (1..12)
-#        Default: 2
-#
-#    MinCharterName
-#        Minimal name length (1..24)
-#        Default: 2
-#
-#    MinPetName
-#        Minimal name length (1..12)
-#        Default: 2
-#
-#    MaxWhoListReturns
-#        Set the max number of players returned in the /who list and interface.
-#        Default: 49 (stable)
-#
-#    CharacterCreating.Disabled
-#        Disable characters creating for specific team or any
-#         (non-player accounts not affected)
-#        Default: 0 - enabled
-#                 1 - disabled only for Alliance
-#                 2 - disabled only for Horde
-#                 3 - disabled for both teams
-#
-#    CharacterCreating.Disabled.RaceMask
-#        Mask of races which cannot be created (ignored for GM accounts).
-#        Default: 0 - all races are enabled
-#                 Check http://www.trinitycore.info/index.php/Characters_tc2#race 
-#                 for race mask values.
-#        Example: 1536 = 1024 + 512 - Blood Elf and Draenei races are disabled.
-#
-#    CharacterCreating.Disabled.ClassMask
-#        Mask of classes which cannot be created (ignored for GM accounts).
-#        Default: 0 - all classes are enabled
-#                 Check http://www.trinitycore.info/index.php/Characters_tc2#class 
-#                 for class mask values.
-#        Example: 288 = 32 + 256 - Death Knight and Warlock classes are disabled.
-#
-#    CharactersPerAccount
-#        Limit numbers of characters per account (at all realms).
-#         Note: this setting limit character creating at _current_ realm base
-#         at characters amount at all realms
-#        Default: 50
-#                The number must be >= CharactersPerRealm
-#
-#    CharactersPerRealm
-#        Limit numbers of characters for account at realm
-#        Default: 10 (client limitation)
-#                The number must be between 1 and 10
-#
-#    HeroicCharactersPerRealm
-#        Limit numbers of heroic class characters for account at realm
-#        Default: 1
-#                The number must be between 0 (not allowed) and 10
-#
-#    CharacterCreating.MinLevelForHeroicCharacter
-#        Limit creating heroic characters only for account with another
-#         character of specific level (ignored for GM accounts)
-#                 0  - not require any existed chaarcter
-#                 1  - require at least any character existed
-#        Default: 55 - default requirement
-#
-#    SkipCinematics
-#        Disable in-game script movie at first character's login
-#         (allows to prevent buggy intro in case of custom start
-#         location coordinates)
-#        Default: 0 - show intro for each new characrer
-#                 1 - show intro only for first character of selected race
-#                 2 - disable intro show in all cases
-#
-#    MaxPlayerLevel
-#        Max level that can be reached by player for experience
-#         (in range from 1 to 100). Going past 100 voids your warranty
-#         and you will not receive support for bugs you encounter.
-#        Change not recommended
-#        Default: 80
-#
-#    MinDualSpecLevel
-#        Min level at which players can use Dual Spec functionality
-#        Default: 40
-#
-#    StartPlayerLevel
-#        Staring level that have character upon creation
-#         (in range 1 to MaxPlayerLevel)
-#        Default: 1
-#
-#    StartHeroicPlayerLevel
-#        Staring level that have character of heroic class upon creation
-#         (in range 1 to MaxPlayerLevel)
-#        Default: 55
-#
-#    StartPlayerMoney
-#        Amount of money that new players will start with.
-#         If you want to start with silver, use for example 100
-#         (100 copper = 1 silver)
-#        Default: 0
-#
-#    MaxHonorPoints
-#        Max honor points that player can have.
-#        Default: 75000
-#
-#    StartHonorPoints
-#        Amount of honor that new players will start with
-#        Default: 0
-#
-#    MaxArenaPoints
-#        Max arena points that player can have.
-#        Default: 10000
-#
-#    StartArenaPoints
-#        Amount of arena points that new players will start with
-#        Default: 0
-#
-#    RecruitAFriend.MaxLevel
-#        Highest level at which a player can benefit from the Recruit-A-Friend
-#         XP multiplier
-#        Default: 60
-#
-#    RecruitAFriend.MaxDifference = 3
-#        Highest level difference between linked players for both players to 
-#         benefit from the Recruit-A-Friend XP multiplier
-#        Default: 3
-#
-#    InstantLogout
-#        Enable or disable instant logout for security level (0..4) or higher
-#        (NOT in combat/while dueling/while falling)
-#        Default: 1 (Mods/GMs/Admins)
-#
-#    DisableWaterBreath
-#        Disable/enable waterbreathing for security level (0..4) or higher
-#        Default: 4 (None)
-#
-#    AllFlightPaths
-#        Players will start with all flight paths
-#         (Note: ALL flight paths, not only player's team)
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    InstantFlightPaths
-#        Flight paths will take players to their destination instantly, instead
-#         of making them wait to fly there.
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    AlwaysMaxSkillForLevel
-#        Players will automatically gain max level dependent (weapon/defense)
-#         skill when logging in, leveling up etc.
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    ActivateWeather
-#        Activate weather system
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    CastUnstuck
-#        Allow cast or not Unstuck spell at .start or client Help option use
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    Instance.IgnoreLevel
-#        Ignore level requirement to enter instance
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    Instance.IgnoreRaid
-#        Ignore raid requirement to enter instance
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    Instance.ResetTimeHour
-#        The hour of the day (0-23) when the global instance resets occur.
-#        Default: 4
-#
-#    Instance.UnloadDelay
-#        Unload the instance map from memory after some time
-#         if no players are inside.
-#        Default: 1800000 (miliseconds 30 minutes)
-#                 0 (instance maps are kept in memory until they are reset)
-#
-#    Quests.LowLevelHideDiff
-#        Quest level difference to hide for player low level quests:
-#         if player_level > quest_level + LowLevelQuestsHideDiff then quest
-#         "!" mark not show for quest giver
-#        Default: 4
-#                -1 (show all available quests marks)
-#
-#    Quests.HighLevelHideDiff
-#        Quest level difference to hide for player high level quests:
-#         if player_level < quest_min_level - HighLevelQuestsHideDiff then
-#         quest "!" mark not show for quest giver
-#        Default: 7
-#                -1 (show all available quests marks)
-#
-#    Quests.IgnoreRaid
-#        Allow non-raid quests to be completed when in raid group
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    Guild.EventLogRecordsCount
-#        Count of guild event log records stored in guild_eventlog table
-#         Increase to store more guild events in table, minimum is 100
-#         You can set it to very high value to prevent oldest guild events to
-#         be rewritten by latest guild events; can slow down performance
-#        Default: 100
-#
-#    Guild.BankEventLogRecordsCount
-#        Count of guild_bank event log records stored in
-#         guild_bank_eventlog table
-#         Increase to store more guild_bank events in table - minimum is 25
-#         (GUILD_BANK_MAX_LOGS) for each guild_bank tab
-#         Useful when you don't want old log events to be overwritten by new,
-#         but increasing can slow down performance
-#        Default: 25
-#
-#    MaxPrimaryTradeSkill
-#        Max count that player can learn the primary trade skill.
-#        Default: 2
-#        Max : 10
-#
-#    MinPetitionSigns
-#        Min signatures count to creating guild (0..9).
-#        Default: 9
-#
-#    MaxGroupXPDistance
-#        Max distance to creature for group member to get XP at creature death.
-#        Default: 74
-#
-#    MaxRecruitAFriendBonusDistance
-#        Max distance to player for group member to get RaF bonus for XP.
-#        Default: 100
-#
-#    MailDeliveryDelay
-#        Mail delivery delay time for item sending
-#        Default: 3600 sec (1 hour)
-#
-#    SkillChance.Prospecting
-#        For prospecting skillup impossible by default,
-#         but can be allowed as custom setting
-#        Default: 0 - no skilups
-#                 1 - skilups possible
-#
-#    SkillChance.Milling
-#        For milling skillup impossible by default,
-#         but can be allowed as custom setting
-#        Default: 0 - no skilups
-#                 1 - skilups possible
-#
-#    OffhandCheckAtSpellUnlearn
-#        Unlearning certain spells can change offhand weapon restrictions
-#         for equip slots.
-#        Default: 1 - recheck offhand slot weapon at unlearning a spell
-#                 0 - recheck offhand slot weapon only at zone update
-#
-#    ClientCacheVersion
-#        Client cache version for client cache data reset. Use any different
-#         from DB value and not recently used for triggering reset.
-#        Default: 0 (use DB value from world DB db_version.cache_id field)
-#
-#    Event.Announce
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    BeepAtStart
-#        Beep at core start finished (mostly work only at Unix/Linux systems)
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    Motd
-#        Message of the Day. Displayed at worldlogin for every user
-#         Use '@' for a newline, and be sure to escape special characters.
-#        Example: "Welcome to John\'s Server@WinterGrasp is closed."
-#
-#    Server.LoginInfo
-#        Enable/disable sending server info (core version) on login.
-#        Default: 0 - disable
-#                 1 - enable
-#
-#    Command.LookupMaxResults
-#        The maximum number of results a .lookup command can return
-#        Default: 0 - unlimited
-#
-###############################################################################
-
-GameType = 0
-RealmZone = 1
-Expansion = 2
-DBC.Locale = 255
-DeclinedNames = 0
-StrictPlayerNames = 0
-StrictCharterNames = 0
-StrictPetNames = 0
-MaxWhoListReturns = 49
-MinPlayerName = 2
-MinCharterName = 2
-MinPetName = 2
-CharacterCreating.Disabled = 0
-CharacterCreating.Disabled.RaceMask = 0
-CharacterCreating.Disabled.ClassMask = 0
-CharactersPerAccount = 50
-CharactersPerRealm = 10
-HeroicCharactersPerRealm = 1
-CharacterCreating.MinLevelForHeroicCharacter = 55
-SkipCinematics = 0
-MaxPlayerLevel = 80
-MinDualSpecLevel = 40
-StartPlayerLevel = 1
-StartHeroicPlayerLevel = 55
-StartPlayerMoney = 0
-MaxHonorPoints = 75000
-StartHonorPoints = 0
-MaxArenaPoints = 10000
-StartArenaPoints = 0
-RecruitAFriend.MaxLevel = 60
-RecruitAFriend.MaxDifference = 3
-InstantLogout = 1
-DisableWaterBreath = 4
-AllFlightPaths = 0
-InstantFlightPaths = 0
-AlwaysMaxSkillForLevel = 0
-ActivateWeather = 1
-CastUnstuck = 1
-Instance.IgnoreLevel = 0
-Instance.IgnoreRaid = 0
-Instance.ResetTimeHour = 4
-Instance.UnloadDelay = 1800000
-Quests.LowLevelHideDiff = 4
-Quests.HighLevelHideDiff = 7
-Quests.IgnoreRaid = 0
-Guild.EventLogRecordsCount = 100
-Guild.BankEventLogRecordsCount = 25
-MaxPrimaryTradeSkill = 2
-MinPetitionSigns = 9
-MaxGroupXPDistance = 74
-MaxRecruitAFriendBonusDistance = 100
-MailDeliveryDelay = 3600
-SkillChance.Prospecting = 0
-SkillChance.Milling = 0
-OffhandCheckAtSpellUnlearn = 1
-ClientCacheVersion = 0
-Event.Announce = 0
-BeepAtStart = 1
-Motd = "Welcome to a Trinity Core server."
-Server.LoginInfo = 0
-Command.LookupMaxResults = 0
-
-###############################################################################
-# PLAYER INTERACTION
-#
-#    AllowTwoSide.Accounts
-#        Allow or not accounts to create characters in the 2 teams
-#         in any game type.
-#        Default: 1 (Allowed)
-#                 0 (Not allowed)
-#
-#    AllowTwoSide.Interaction.Chat
-#    AllowTwoSide.Interaction.Channel
-#    AllowTwoSide.Interaction.Group
-#    AllowTwoSide.Interaction.Guild
-#    AllowTwoSide.Interaction.Auction
-#    AllowTwoSide.Interaction.Mail
-#        Allow or not common :chat(say,yell)
-#                             channel(chat)
-#                             group(join)
-#                             guild(join)
-#                             merge all auction houses for players from
-#                             different teams
-#                             send mail to other team.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    AllowTwoSide.WhoList
-#        Allow or not show player from both team in who list.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    AllowTwoSide.AddFriend
-#        Allow or not adding friends from other team in friend list.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    AllowTwoSide.Trade
-#        Allow or not trading with other team in party.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    TalentsInspecting
-#        Allow other players see character talents in inspect dialog
-#         (Characters in Gamemaster mode can inspect talents always)
-#        Default: 1 (allow)
-#                 0 (not allow)
-#
-###############################################################################
-
-AllowTwoSide.Accounts = 1
-AllowTwoSide.Interaction.Chat = 0
-AllowTwoSide.Interaction.Channel = 0
-AllowTwoSide.Interaction.Group = 0
-AllowTwoSide.Interaction.Guild = 0
-AllowTwoSide.Interaction.Auction = 0
-AllowTwoSide.Interaction.Mail = 0
-AllowTwoSide.WhoList = 0
-AllowTwoSide.AddFriend = 0
-AllowTwoSide.Trade = 0
-TalentsInspecting = 1
-
-###############################################################################
-# CREATURE SETTINGS
-#
-#    ThreatRadius
-#        Radius for creature to evade after being
-#         pulled away from combat start point
-#         If ThreatRadius is less than creature aggro radius
-#         then aggro radius will be used
-#        Default: 60 yards
-#
-#    Rate.Creature.Aggro
-#        Aggro radius percent or off.
-#        Default: 1   - 100%
-#                 1.5 - 150%
-#                 0   - off (0%)
-#
-#    CreatureFamilyFleeAssistanceRadius
-#        Radius which creature will use to seek for a nearby creature
-#         for assistance. Creature will flee to this creature.
-#        Default: 30
-#                 0   - off
-#
-#    CreatureFamilyAssistanceRadius
-#        Radius which creature will use to call assistance without moving
-#        Default: 10
-#                 0   - off
-#
-#    CreatureFamilyAssistanceDelay
-#        Reaction time for creature assistance call
-#        Default: 1500 (1.5s)
-#
-#    CreatureFamilyFleeDelay
-#        Time during which creature can flee when no assistant found
-#        Default: 7000 (7s)
-#
-#    WorldBossLevelDiff
-#        Difference for boss dynamic level with target
-#        Default: 3
-#
-#    Corpse.Decay.NORMAL
-#    Corpse.Decay.RARE
-#    Corpse.Decay.ELITE
-#    Corpse.Decay.RAREELITE
-#    Corpse.Decay.WORLDBOSS
-#        Seconds until creature corpse will decay if not looted or skinned.
-#        Default: 60, 300, 300, 300, 3600
-#
-#    Rate.Corpse.Decay.Looted
-#         Controls how long the creature corpse stays after it had been looted,
-#          as a multiplier of its Corpse.Decay.* config.
-#         Default: 0.5
-#
-#    Rate.Creature.Normal.Damage
-#    Rate.Creature.Elite.Elite.Damage
-#    Rate.Creature.Elite.RAREELITE.Damage
-#    Rate.Creature.Elite.WORLDBOSS.Damage
-#    Rate.Creature.Elite.RARE.Damage
-#        Creature Damage Rates.
-#        Examples: 2 - creatures will damage 2x, 1.7 - 1.7x.
-#
-#    Rate.Creature.Normal.SpellDamage
-#    Rate.Creature.Elite.Elite.SpellDamage
-#    Rate.Creature.Elite.RAREELITE.SpellDamage
-#    Rate.Creature.Elite.WORLDBOSS.SpellDamag
-#    Rate.Creature.Elite.RARE.SpellDamage
-#        Creature Spell Damage Rates.
-#        Examples: 2 - creatures will damage with spells 2x, 1.7 - 1.7x.
-#
-#    Rate.Creature.Normal.HP
-#    Rate.Creature.Elite.Elite.HP
-#    Rate.Creature.Elite.RAREELITE.HP
-#    Rate.Creature.Elite.WORLDBOSS.HP
-#    Rate.Creature.Elite.RARE.HP
-#        Creature Health Ammount Modifier.
-#        Examples: 2 - creatures have 2x health, 1.7 - 1.7x.
-#
-#    ListenRange.Say
-#        Distance from player to listen text that creature
-#         (or other world object) says
-#        Default: 40
-#
-#    ListenRange.TextEmote
-#        Distance from player to listen textemote that creature
-#         (or other world object) says
-#        Default: 40
-#
-#    ListenRange.Yell
-#        Distance from player to listen text that creature
-#         (or other world object) yells
-#        Default: 300
-#
-###############################################################################
-
-ThreatRadius = 60
-Rate.Creature.Aggro = 1
-CreatureFamilyFleeAssistanceRadius = 30
-CreatureFamilyAssistanceRadius = 10
-CreatureFamilyAssistanceDelay = 1500
-CreatureFamilyFleeDelay = 7000
-WorldBossLevelDiff = 3
-Corpse.Decay.NORMAL = 60
-Corpse.Decay.RARE = 300
-Corpse.Decay.ELITE = 300
-Corpse.Decay.RAREELITE = 300
-Corpse.Decay.WORLDBOSS = 3600
-Rate.Corpse.Decay.Looted = 0.5
-Rate.Creature.Normal.Damage = 1
-Rate.Creature.Elite.Elite.Damage = 1
-Rate.Creature.Elite.RAREELITE.Damage = 1
-Rate.Creature.Elite.WORLDBOSS.Damage = 1
-Rate.Creature.Elite.RARE.Damage = 1
-Rate.Creature.Normal.SpellDamage = 1
-Rate.Creature.Elite.Elite.SpellDamage = 1
-Rate.Creature.Elite.RAREELITE.SpellDamage = 1
-Rate.Creature.Elite.WORLDBOSS.SpellDamage = 1
-Rate.Creature.Elite.RARE.SpellDamage = 1
-Rate.Creature.Normal.HP = 1
-Rate.Creature.Elite.Elite.HP = 1
-Rate.Creature.Elite.RAREELITE.HP = 1
-Rate.Creature.Elite.WORLDBOSS.HP = 1
-Rate.Creature.Elite.RARE.HP = 1
-ListenRange.Say = 40
-ListenRange.TextEmote = 40
-ListenRange.Yell = 300
-
-###############################################################################
-# CHAT SETTINGS
-#
-#    ChatFakeMessagePreventing
-#        Chat protection from creating fake messages using a lot spaces
-#         (other invisible symbols),
-#         not applied to addon language messages, but can cause old addons
-#         that use normal languages for sending data to another clients.
-#        Default: 0 (disible fake messages preventing)
-#                 1 (enabled fake messages preventing)
-#
-#    ChatStrictLinkChecking.Severity
-#        Check chat messages for ingame links to
-#         spells, items, quests, achievements etc.
-#        Default: 0 (disable link checking)
-#                 1 (check if only valid pipe commands are used.
-#                    This prevents posting pictures for example)
-#                 2 (verifiy that pipe commands are used in a correct order)
-#                 3 (check if color, entry and name don't contradict
-#                    each other. For correct work, please assure
-#                    that you have extracted locale DBCs of every language
-#                    specific client playing on this server.)
-#
-#    ChatStrictLinkChecking.Kick
-#        Defines what should be done if a message is considered to contain
-#         invalid pipe commands.
-#        Default: 0 (silently ignore message)
-#                 1 (kick players who sent invalid formed messages)
-#
-#    ChatFlood.MessageCount
-#        Chat anti-flood protection, haste message count to activate protection
-#        Default: 10
-#                 0 (disible anti-flood protection)
-#
-#    ChatFlood.MessageDelay
-#        Chat anti-flood protection, minimum message delay to count message
-#        Default: 1 (in secs)
-#
-#    ChatFlood.MuteTime
-#        Chat anti-flood protection, mute time at activation flood protection
-#        Default: 10 (in secs)
-#
-#    Channel.RestrictedLfg
-#        Restrict LookupForGroup channel to registered in LFG tool players
-#        Default: 1 (allow join to channel only if active in LFG)
-#                 0 (allow join to channel in any time)
-#
-#    Channel.SilentlyGMJoin
-#        Silently join GM characters (security level > 1) to channels
-#        Default: 0 (join announcement in normal way)
-#                 1 (GM join without announcement)
-#
-#    ChatLevelReq.Channel
-#        The required level of character to be able to write in chat channels
-#        Default: 1 (From level 1)
-#
-#    ChatLevelReq.Whisper
-#        The required level of character to be able to whisper
-#        Default: 1 (From level 1)
-#
-#    ChatLevelReq.Say
-#        The required level of character to be able to say/yell/emote
-#        Default: 1 (From level 1)
-#
-#    AllowPlayerCommands
-#        Allowed the players to use commands
-#        Default: 1 (allow)
-#
-###############################################################################
-
-ChatFakeMessagePreventing = 0
-ChatStrictLinkChecking.Severity = 0
-ChatStrictLinkChecking.Kick = 0
-ChatFlood.MessageCount = 10
-ChatFlood.MessageDelay = 1
-ChatFlood.MuteTime = 10
-Channel.RestrictedLfg = 1
-Channel.SilentlyGMJoin = 0
-ChatLevelReq.Channel = 1
-ChatLevelReq.Whisper = 1
-ChatLevelReq.Say = 1
-AllowPlayerCommands = 1
-
-###############################################################################
-# GAME MASTER SETTINGS
-#
-#    GM.LoginState
-#        GM mode at login
-#        Default: 2 (last save state)
-#                 0 (disable)
-#                 1 (enable)
-#
-#    GM.Visible
-#        GM visibility at login
-#        Default: 2 (last save state)
-#                 0 (invisible)
-#                 1 (visible)
-#
-#    GM.AcceptTickets
-#        Is GM accepting tickets from player by default or not.
-#        Default: 2 (last save state)
-#                 0 (disable)
-#                 1 (enable)
-#
-#    GM.Chat
-#        GM chat mode at login
-#        Default: 2 (last save state)
-#                 0 (disable)
-#                 1 (enable)
-#
-#    GM.WhisperingTo
-#        Is GM accepting whispers from player by default or not.
-#        Default: 2 (last save state)
-#                 0 (disable)
-#                 1 (enable)
-#
-#    GM.InGMList.Level
-#        Max GM level showed in GM list (if visible) in non-GM state (.gm off)
-#                 0 (only players)
-#                 1 (only moderators)
-#                 2 (only gamemasters)
-#        Default: 3 (anyone)
-#
-#    GM.InWhoList.Level
-#        Max GM level showed in who list (if visible).
-#                 0 (only players)
-#                 1 (only moderators)
-#                 2 (only gamemasters)
-#        Default: 3 (anyone)
-#
-#    GM.LogTrade
-#        Include GM trade and trade slot enchanting operations in GM log
-#        Default: 1 (include)
-#                 0 (not include)
-#
-#    GM.StartLevel
-#        GM starting level (1-100)
-#        Default: 1
-#
-#    GM.AllowInvite
-#        Is GM accepting invites from players by default or not
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    GM.AllowFriend
-#        Are players allowed to add GMs to their friend list
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    GM.LowerSecurity
-#        Disallow a lower security member to interact with
-#         a higher one using commands
-#        Default: 0 (disable)
-#                 1 (enable)
-#
-#    GM.AllowAchievementGain
-#        If enabled it allows gaining achievements for GM characters
-#        Default: 1 (enable)
-#                 0 (disable)
-#
-#    GM.TicketSystem.ChanceOfGMSurvey
-#        Chance of sending a GM survey with every ticket completion.
-#        Default: 50
-#                 0 (disables surveys)
-#
-###############################################################################
-
-GM.LoginState            = 2
-GM.Visible               = 2
-GM.AcceptTickets         = 2
-GM.Chat                  = 2
-GM.WhisperingTo          = 2
-GM.InGMList.Level        = 3
-GM.InWhoList.Level       = 3
-GM.LogTrade              = 1
-GM.StartLevel            = 80
-GM.AllowInvite           = 0
-GM.AllowFriend           = 0
-GM.LowerSecurity         = 0
-GM.AllowAchievementGain  = 1
-GM.TicketSystem.ChanceOfGMSurvey = 50
-
-###############################################################################
-# VISIBILITY AND RADIUSES
-#
-#    Visibility.GroupMode
-#        Group visibility modes
-#        Default: 1 (raid members 100% auto detect invisible player from
-#                    same raid)
-#                 0 (only members from same group can
-#                    100% auto detect invisible player)
-#                 2 (players from same team can 100% auto detect
-#                    invisible player)
-#
-#    Visibility.Distance.Continents
-#    Visibility.Distance.Instances
-#    Visibility.Distance.BGArenas
-#        Visibility distance for different ingame object in different maps.
-#        Visibility on continents on offy ~90 yards. In BG/Arenas ~180.
-#        For instances default ~120.
-#        Max limited by active player zone: ~ 333
-#        Min limit is max aggro radius (45) * Rate.Creature.Aggro
-#
-#    Visibility.Distance.Object
-#        Visible distance for gameobject, dynobject, bodies, corpses, bones
-#        Min limit is iteraction distance (5)
-#
-#    Visibility.Distance.InFlight
-#        Visible distance for player in flight
-#        Min limit is 0 (not show any objects)
-#
-#    Visibility.Distance.Grey.Unit
-#        Visibility grey distance for creatures/players (fast changing objects)
-#         addition to appropriate object type Visibility.Distance.* use in case
-#         visibility removing to object (except corpse around distances)
-#         If D is distance and G is grey distance then object
-#         make visible if distance to it <= D
-#         but make non visible if distance > D+G
-#        Default: 1 (yard)
-#
-#    Visibility.Distance.Grey.Object
-#        Visibility grey distance for dynobjects/gameobjects/corpses/creatures
-#        Default: 10 (yards)
-#
-###############################################################################
-
-Visibility.GroupMode = 1
-Visibility.Distance.Continents = 90
-Visibility.Distance.Instances = 120
-Visibility.Distance.BGArenas = 180
-Visibility.Distance.Object = 100
-Visibility.Distance.InFlight = 100
-Visibility.Distance.Grey.Unit   = 1
-Visibility.Distance.Grey.Object = 10
-
-Visibility.Notify.Period.OnContinents = 1000
-Visibility.Notify.Period.InInstances  = 1000
-Visibility.Notify.Period.InBGArenas   = 1000
-
-###############################################################################
-# SERVER RATES
-#
-#    Rate.Health
-#    Rate.Mana
-#    Rate.Rage.Income
-#    Rate.Rage.Loss
-#    Rate.RunicPower.Income
-#    Rate.RunicPower.Loss
-#    Rate.Focus
-#    Rate.Loyalty
-#        Health and power regeneration and rage income from damage.
-#        Default: 1
-#
-#    Rate.Skill.Discovery
-#        Skill Discovery Rates
-#        Default: 1
-#
-#    Rate.Drop.Item.Poor
-#    Rate.Drop.Item.Normal
-#    Rate.Drop.Item.Uncommon
-#    Rate.Drop.Item.Rare
-#    Rate.Drop.Item.Epic
-#    Rate.Drop.Item.Legendary
-#    Rate.Drop.Item.Artifact
-#    Rate.Drop.Item.Referenced
-#    Rate.Drop.Money
-#        Drop rates (items by quality and money)
-#        Default: 1
-#
-#    Rate.Drop.Item.ReferencedAmount
-#        Multiplier for referenced loot
-#        Default: 1
-#
-#    Rate.Drop.Money
-#        Drop rates
-#        Default: 1
-#
-#    Rate.XP.Kill
-#    Rate.XP.Quest
-#    Rate.XP.Explore
-#        XP rates
-#        Default: 1
-#
-#    Rate.RepairCost
-#        Repair cost rate
-#        Default: 1   - standard cost
-#                 2   - double cost
-#                 0.5 - half cost
-#
-#    Rate.Rest.InGame
-#    Rate.Rest.Offline.InTavernOrCity
-#    Rate.Rest.Offline.InWilderness
-#        Resting points grow rates
-#        Default: 1   - standard rate
-#                 2   - double rate
-#                 0.5 - half rate
-#
-#    Rate.Damage.Fall
-#        Damage after fall rate.
-#        Default: 1   - standard damage
-#                 2   - double damage
-#                 0.5 - half damage
-#
-#    Rate.Auction.Time
-#    Rate.Auction.Deposit
-#    Rate.Auction.Cut
-#        Auction rates
-#         (auction time, deposit get at auction start,
-#         auction cut from price at auction end)
-#
-#    Rate.Honor
-#        Honor gain rate
-#
-#    Rate.Mining.Amount
-#    Rate.Mining.Next
-#        Mining Rates
-#         Mining.Amount changes minimum/maximum use times of a deposit,
-#         Mining.Next changes chance to have next use of a deposit
-#
-#    Rate.Talent
-#        Talent Point rates
-#        Default: 1
-#
-#    Rate.Reputation.Gain
-#        Reputation Gain rate
-#        Default: 1
-#
-#    Rate.Reputation.LowLevel.Kill
-#        Reputation Gain from low level kill (grey creature)
-#        Default: 1
-#
-#    Rate.Reputation.LowLevel.Quest
-#        Reputation Gain rate
-#        Default: 1
-#
-#    Rate.XP.Kill.Premium
-#    Rate.XP.Quest.Premium
-#    Rate.XP.Explore.Premium
-#        XP rates Premium modifier
-#        Default: 1
-#
-#    Rate.Reputation.RecruitAFriendBonus
-#        Reputation bonus amount for recruit-a-friend. 0.1 = 10% bonus.
-#        Default: 0.1 (blizzlike)
-#
-#    Rate.MoveSpeed
-#        Multiply the default movement speed for players
-#         and whatever they're controlling.
-#        Default: 1   - no change
-#                 1.4 - 40% increase
-#
-#    Rate.InstanceResetTime
-#        Multiplier for the number of days in between
-#         global raid/heroic instance resets.
-#        Default: 1
-#
-#    SkillGain.Crafting
-#    SkillGain.Defense
-#    SkillGain.Gathering
-#    SkillGain.Weapon
-#        Crafting/defense/gathering/weapon skills gain at skill grow (1,2,...)
-#        Default: 1
-#
-#    SkillChance.Orange
-#    SkillChance.Yellow
-#    SkillChance.Green
-#    SkillChance.Grey
-#        Skill chance values (0..100)
-#        Default: 100-75-25-0
-#
-#    SkillChance.MiningSteps
-#    SkillChance.SkinningSteps
-#        For skinning and Mining chance decrease with skill level.
-#        Default: 0  - no decrease
-#                 75 - in 2 times each 75 skill points
-#
-#    DurabilityLoss.InPvP
-#        If true, players take durability loss on death in PvP.
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    DurabilityLoss.OnDeath
-#        Durability loss percentage on death
-#        Default: 10 - standard
-#                 20 - double
-#                 5  - half
-#
-#    DurabilityLossChance.Damage
-#        Chance lost one from equiped items durability
-#         point at damage apply or receive.
-#        Default: 0.5 (100/0.5 = 200)
-#         Each 200 damage apply one from 19 possible equipped items
-#
-#    DurabilityLossChance.Absorb
-#         Chance lost one from armor items durability point at damage absorb.
-#         Default: 0.5 (100/0.5 = 200)
-#          Each 200 absorbs apply one from 15 possible armor equipped items
-#
-#    DurabilityLossChance.Parry
-#         Chance lost weapon durability point at parry.
-#         Default: 0.05 (100/0.05 = 2000)
-#          Each 2000 parry attacks main weapon lost point
-#
-#    DurabilityLossChance.Block
-#         Chance lost sheild durability point at damage block.
-#         Default: 0.05 (100/0.05 = 2000)
-#          Each 2000 partly or full blocked attacks shield lost point
-#
-#    Death.SicknessLevel
-#         Starting Character start gain sickness at spirit resurrection (1 min)
-#         Default: 11
-#                  -10 - character will have full time
-#                    (10min) sickness at 1 level
-#                  maxplayerlevel+1
-#                   - character will not have sickess at any level
-#
-#    Death.CorpseReclaimDelay.PvP
-#    Death.CorpseReclaimDelay.PvE
-#         Enabled/disabled increase corpse reclaim delay at PvP/PvE deaths
-#         Default: 1 (enabled)
-#                  0 (disabled)
-#
-#    Death.Bones.World
-#    Death.Bones.BattlegroundOrArena
-#         Enable/disable creating bones instead corpse at resurrection
-#          (in normal zones/instances, or battleground/arenas)
-#         Default: 1 (enabled)
-#                  0 (disabled)
-#
-#    Die.Command.Mode
-#        Switch between two possible .die modes, where mode 1 kills
-#         and does not trigger anything such as loot, and mode 0 does
-#         damage and does trigger things such as loot
-#        Default: 1
-#                  0
-#
-###############################################################################
-
-Rate.Health = 1
-Rate.Mana = 1
-Rate.Rage.Income = 1
-Rate.Rage.Loss = 1
-Rate.RunicPower.Income = 1
-Rate.RunicPower.Loss = 1
-Rate.Focus = 1
-Rate.Loyalty = 1
-Rate.Skill.Discovery = 1
-Rate.Drop.Item.Poor = 1
-Rate.Drop.Item.Normal = 1
-Rate.Drop.Item.Uncommon = 1
-Rate.Drop.Item.Rare = 1
-Rate.Drop.Item.Epic = 1
-Rate.Drop.Item.Legendary = 1
-Rate.Drop.Item.Artifact = 1
-Rate.Drop.Item.Referenced = 1
-Rate.Drop.Item.ReferencedAmount = 1
-Rate.Drop.Money = 1
-Rate.XP.Kill    = 1
-Rate.XP.Quest   = 1
-Rate.XP.Explore = 1
-Rate.XP.Kill.Premium    = 1
-Rate.XP.Quest.Premium   = 1
-Rate.XP.Explore.Premium = 1
-Rate.RepairCost = 1
-Rate.Rest.InGame = 1
-Rate.Rest.Offline.InTavernOrCity = 1
-Rate.Rest.Offline.InWilderness = 1
-Rate.Damage.Fall = 1
-Rate.Auction.Time = 1
-Rate.Auction.Deposit = 1
-Rate.Auction.Cut = 1
-Rate.Honor = 1
-Rate.Mining.Amount = 1
-Rate.Mining.Next   = 1
-Rate.Talent = 1
-Rate.Reputation.Gain = 1
-Rate.Reputation.LowLevel.Kill    = 1
-Rate.Reputation.LowLevel.Quest   = 1
-Rate.Reputation.RecruitAFriendBonus = 0.1
-Rate.MoveSpeed = 1
-Rate.InstanceResetTime = 1
-SkillGain.Crafting = 1
-SkillGain.Defense = 1
-SkillGain.Gathering = 1
-SkillGain.Weapon = 1
-SkillChance.Orange = 100
-SkillChance.Yellow = 75
-SkillChance.Green  = 25
-SkillChance.Grey   = 0
-SkillChance.MiningSteps   = 0
-SkillChance.SkinningSteps = 0
-DurabilityLoss.InPvP = 0
-DurabilityLoss.OnDeath = 10
-DurabilityLossChance.Damage = 0.5
-DurabilityLossChance.Absorb = 0.5
-DurabilityLossChance.Parry  = 0.05
-DurabilityLossChance.Block  = 0.05
-Death.SicknessLevel = 11
-Death.CorpseReclaimDelay.PvP = 1
-Death.CorpseReclaimDelay.PvE = 0
-Death.Bones.World = 1
-Death.Bones.BattlegroundOrArena = 1
-Die.Command.Mode = 1
-
-###############################################################################
-# AUTO BROADCAST
-#
-#    AutoBroadcast.On
-#        Enable auto broadcast
-#        Default: 0 - off
-#                 1 - on
-#
-#    AutoBroadcast.Center
-#        Display method
-#        Default: 0 - announce
-#                 1 - notify
-#                 2 - both
-#
-#    AutoBroadcast.Timer
-#        Timer for auto broadcast (in milliseconds)
-#
-###############################################################################
-
-AutoBroadcast.On = 0
-AutoBroadcast.Center = 0
-AutoBroadcast.Timer = 60000
-
-###############################################################################
-# BATTLEGROUND CONFIG
-#
-#    Battleground.CastDeserter
-#        Cast Deserter spell at player who leave battleground in progress
-#        Default: 1 (enable)
-#                 0 (disable)
-#
-#    Battleground.QueueAnnouncer.Enable
-#        Enable queue announcer posting to chat
-#        Default: 0 (disable)
-#                 1 (enable)
-#
-#    Battleground.QueueAnnouncer.PlayerOnly
-#        Queue announcer type
-#        Default: 0 (system message - all players can see it)
-#                 1 (private - only the queued player can see it)
-#
-#    Battleground.InvitationType
-#        Set Battleground invitation type
-#        Default: 0 (normal - invite as much players to bg as possible,
-#                    don't bother with ballance)
-#                 1 (Experimental - don't allow to invite much more players
-#                    of one faction)
-#
-#    Battleground.PrematureFinishTimer
-#        The time to end the bg if there are less than MinPlayersPerTeam on
-#         one side (in milliseconds)
-#        Default: 300000 (5 minutes)
-#                 0 - disable (not recommended)
-#
-#    BattleGround.PremadeGroupWaitForMatch
-#        The time in which premade group of 1 faction waits in BG Queue
-#         for premade group of other faction
-#        Default: 1800000 (30 minutes)
-#                 0 - disable (not recommended)
-#
-#    Battleground.GiveXPForKills
-#        Give experience for honorable kills in battlegrounds
-#        Default: 0 (disable)
-#                 1 (enable)
-#
-#    Battleground.Random.ResetHour
-#        Reset random battlegrounds at specified hour of the day (0-23)
-#        Default: 6
-#
-###############################################################################
-
-Battleground.CastDeserter = 1
-Battleground.QueueAnnouncer.Enable = 0
-Battleground.QueueAnnouncer.PlayerOnly = 0
-Battleground.InvitationType = 0
-BattleGround.PrematureFinishTimer = 300000
-BattleGround.PremadeGroupWaitForMatch = 1800000
-Battleground.GiveXPForKills = 0
-Battleground.Random.ResetHour = 6
-
-###############################################################################
-# ARENA CONFIG
-#
-#    Arena.MaxRatingDifference
-#        The maximum rating difference between two groups in rated matches
-#        Default: 150 (enable, recommended)
-#                 0 (disable, rating difference is discarded)
-#
-#    Arena.RatingDiscardTimer
-#        After the specified milliseconds has passed,
-#         rating information will be discarded when selecting teams for
-#         matches also initiates an update by this timer
-#        Default: 600000 (10 minutes, recommended)
-#                 0 (disable)
-#
-#    Arena.AutoDistributePoints
-#        Set if arena points should be distributed automatically,
-#         or by GM command
-#        Default: 0 (disable) (recommended):
-#                    use gm command or sql query to distribute the points
-#                 1 (enable)  arena points are distributed automatically
-#
-#    Arena.AutoDistributeInterval
-#        How often should the distribution take place
-#        If automatic distribution is enabled in days
-#        Default: 7 (weekly)
-#
-#    Arena.QueueAnnouncer.Enable
-#        Enable bg queue announcer posting to chat
-#        Default: 0 (disable)
-#                 1 (enable)
-#
-#    Arena.ArenaSeason.ID
-#        Current area season id show in client
-#        Default: 1
-#
-#    Arena.ArenaSeason.InProgress
-#        Current area season state
-#        Default: 1 (active)
-#                 0 (finished)
-#
-#    Arena.ArenaStartRating
-#     Start arena team command rating
-#     Default: 0
-#
-#    Arena.ArenaStartPersonalRating
-#     Start personal rating on entry in team
-#     Default: 0
-#
-#    Arena.ArenaStartMatchmakerRating
-#     Start matchmaker rating for players
-#     Default: 1500
-#
-###############################################################################
-
-Arena.MaxRatingDifference = 150
-Arena.RatingDiscardTimer = 600000
-Arena.AutoDistributePoints = 0
-Arena.AutoDistributeInterval = 7
-Arena.QueueAnnouncer.Enable = 0
-Arena.QueueAnnouncer.PlayerOnly = 0
-Arena.ArenaSeason.ID = 1
-Arena.ArenaSeason.InProgress = 1
-Arena.ArenaStartRating = 0
-Arena.ArenaStartPersonalRating = 0
-Arena.ArenaStartMatchmakerRating = 1500
-
-###############################################################################
-# NETWORK CONFIG
-#
-#    Network.Threads
-#         Number of threads for network,
-#          recommend 1 thread per 1000 connections.
-#         Default: 1
-#
-#    Network.OutKBuff
-#         The size of the output kernel buffer used
-#          ( SO_SNDBUF socket option, tcp manual ).
-#         Default: -1 (Use system default setting)
-#
-#    Network.OutUBuff
-#         Userspace buffer for output.
-#          This is amount of memory reserved per each connection.
-#         Default: 65536
-#
-#    Network.TcpNoDelay:
-#         TCP Nagle algorithm setting
-#         Default: 0 (enable Nagle algorithm, less traffic, more latency)
-#                  1 (TCP_NO_DELAY, disable Nagle algorithm,
-#                     more traffic but less latency)
-#
-###############################################################################
-
-Network.Threads = 1
-Network.OutKBuff = -1
-Network.OutUBuff = 65536
-Network.TcpNodelay = 1
-
-###############################################################################
-# AUCTION HOUSE BOT SETTINGS
-#
-#    AuctionHouseBot.DEBUG
-#        Enable/Disable Debugging output
-#    Default 0 (disabled)
-#
-#    AuctionHouseBot.DEBUG_FILTERS
-#        Enable/Disable Debugging output from Filters
-#    Default 0 (disabled)
-#
-#    AuctionHouseBot.EnableSeller
-#        Enable/Disable the part of AHBot that puts items up for auction
-#    Default 0 (disabled)
-#
-#    AuctionHouseBot.EnableBuyer
-#        Enable/Disable the part of AHBot that buys items from players
-#    Default 0 (disabled)
-#
-#    AuctionHouseBot.UseBuyPriceForSeller
-#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
-#    Default 0 (use SellPrice)
-#
-#    AuctionHouseBot.UseBuyPriceForBuyer
-#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
-#    Default 0 (use SellPrice)
-#
-#    Auction House Bot character data
-#        AuctionHouseBot.Account is the account number
-#         (in realmd->account table) of the player you want to run
-#         as the auction bot.
-#        AuctionHouseBot.GUID is the GUID (in characters->characters table)
-#         of the player you want to run as the auction bot.
-#    Default: 0 (Auction House Bot disabled)
-#
-#    AuctionHouseBot.ItemsPerCycle
-#        Number of Items to Add/Remove from the AH during mass operations
-#    Default 200
-#
-###############################################################################
-
-AuctionHouseBot.DEBUG = 0
-AuctionHouseBot.DEBUG_FILTERS = 0
-AuctionHouseBot.EnableSeller = 0
-AuctionHouseBot.EnableBuyer = 0
-AuctionHouseBot.UseBuyPriceForSeller = 0
-AuctionHouseBot.UseBuyPriceForBuyer = 0
-AuctionHouseBot.Account = 0
-AuctionHouseBot.GUID = 0
-AuctionHouseBot.ItemsPerCycle = 200
-
-###############################################################################
-# AUCTION HOUSE BOT FILTERS PART 1
-#
-#    AuctionHouseBot.VendorItems
-#        Include items that can be bought from vendors.
-#    Default 0 (False)
-#
-#    AuctionHouseBot.VendorTradeGoods
-#        Include Trade Goods that can be bought from vendors.
-#    Default 0 (False)
-#
-#    AuctionHouseBot.LootItems
-#        Include items that can be looted or fished for.
-#    Default 1 (True)
-#
-#    AuctionHouseBot.LootTradeGoods
-#        Include Trade Goods that can be looted or fished for.
-#    Default 1 (True)
-#
-#    AuctionHouseBot.OtherItems
-#        Include misc. items.
-#    Default 0 (False)
-#
-#    AuctionHouseBot.OtherTradeGoods
-#        Include misc. Trade Goods.
-#    Default 0 (False)
-#
-#    AuctionHouseBot.Bonding_types
-#        Indicates which bonding types to allow seller to put up for auction
-#            No_Bind
-#             Default 1 (True)
-#            Bind_When_Picked_Up
-#             Default 0 (False)
-#            Bind_When_Equipped
-#             Default 1 (True)
-#            Bind_When_Use
-#             Default 1 (True)
-#            Bind_Quest_Item
-#             Default 0 (False)
-#
-#    AuctionHouseBot.DisableBeta_PTR_Unused
-#        Disable certain items that are usually unavailable to Players
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisablePermEnchant
-#        Disable Items with a Permanent Enchantment
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableConjured
-#        Disable Conjured Items
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableGems
-#        Disable Gems
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableMoney
-#        Disable Items that are used as money
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableMoneyLoot
-#        Disable Items that have Money as a loot
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableLootable
-#        Disable Items that have other items as loot
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableKeys
-#        Disable Items that are keys
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableDuration
-#        Disable Items with a duration
-#    Default 0 (False)
-#
-#    AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel
-#        Disable items that are BOP or Quest Item
-#        with a Required level that is less than the Item Level
-#        (This prevents a level 10 with a level 60 weapon or armor)
-#        (May need further refinement)
-#    Default 0 (False)
-#
-###############################################################################
-
-AuctionHouseBot.VendorItems = 0
-AuctionHouseBot.VendorTradeGoods = 0
-AuctionHouseBot.LootItems = 1
-AuctionHouseBot.LootTradeGoods = 1
-AuctionHouseBot.OtherItems = 0
-AuctionHouseBot.OtherTradeGoods = 0
-AuctionHouseBot.No_Bind = 1
-AuctionHouseBot.Bind_When_Picked_Up = 0
-AuctionHouseBot.Bind_When_Equipped = 1
-AuctionHouseBot.Bind_When_Use = 1
-AuctionHouseBot.Bind_Quest_Item = 0
-AuctionHouseBot.DisableBeta_PTR_Unused = 0
-AuctionHouseBot.DisablePermEnchant = 0
-AuctionHouseBot.DisableConjured = 0
-AuctionHouseBot.DisableGems = 0
-AuctionHouseBot.DisableMoney = 0
-AuctionHouseBot.DisableMoneyLoot = 0
-AuctionHouseBot.DisableLootable = 0
-AuctionHouseBot.DisableKeys = 0
-AuctionHouseBot.DisableDuration = 0
-AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
-
-###############################################################################
-# AUCTION HOUSE BOT FILTERS PART 2
-#
-#     These Filters are boolean (0 or 1) and will disable items that are
-#     specifically meant for the Class named.
-#     (UnusedClass is Class 10, which was skipped for some reason)
-#     Default 0 (allowed)
-#
-###############################################################################
-
-AuctionHouseBot.DisableWarriorItems = 0
-AuctionHouseBot.DisablePaladinItems = 0
-AuctionHouseBot.DisableHunterItems = 0
-AuctionHouseBot.DisableRogueItems = 0
-AuctionHouseBot.DisablePriestItems = 0
-AuctionHouseBot.DisableDKItems = 0
-AuctionHouseBot.DisableShamanItems = 0
-AuctionHouseBot.DisableMageItems = 0
-AuctionHouseBot.DisableWarlockItems = 0
-AuctionHouseBot.DisableUnusedClassItems = 0
-AuctionHouseBot.DisableDruidItems = 0
-
-###############################################################################
-# AUCTION HOUSE BOT FILTERS PART 3
-#
-#    AuctionHouseBot.DisableItemsBelowLevel
-#        Prevent Seller from listing Items below this Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableItemsAboveLevel
-#        Prevent Seller from listing Items above this Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsBelowLevel
-#        Prevent Seller from listing Trade Goods below this Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsAboveLevel
-#        Prevent Seller from listing Trade Goods above this Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableItemsBelowGUID
-#        Prevent Seller from listing Items below this GUID
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableItemsAboveGUID
-#        Prevent Seller from listing Items above this GUID
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsBelowGUID
-#        Prevent Seller from listing Trade Goods below this GUID
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsAboveGUID
-#        Prevent Seller from listing Trade Goods above this GUID
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableItemsBelowReqLevel
-#        Prevent Seller from listing Items below this Required Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableItemsAboveReqLevel
-#        Prevent Seller from listing Items above this Required Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsBelowReqLevel
-#        Prevent Seller from listing Trade Goods below this Required Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsAboveReqLevel
-#        Prevent Seller from listing Trade Goods above this Required Level
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableItemsBelowReqSkillRank
-#        Prevent Seller from listing Items below this Required Skill Rank
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableItemsAboveReqSkillRank
-#        Prevent Seller from listing Items above this Required Skill Rank
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsBelowReqSkillRank
-#        Prevent Seller from listing Trade Goods below this Required Skill Rank
-#    Default 0 (Off)
-#
-#    AuctionHouseBot.DisableTGsAboveReqSkillRank
-#        Prevent Seller from listing Trade Goods above this Required Skill Rank
-#    Default 0 (Off)
-#
-###############################################################################
-
-AuctionHouseBot.DisableItemsBelowLevel = 0
-AuctionHouseBot.DisableItemsAboveLevel = 0
-AuctionHouseBot.DisableTGsBelowLevel = 0
-AuctionHouseBot.DisableTGsAboveLevel = 0
-AuctionHouseBot.DisableItemsBelowGUID = 0
-AuctionHouseBot.DisableItemsAboveGUID = 0
-AuctionHouseBot.DisableTGsBelowGUID = 0
-AuctionHouseBot.DisableTGsAboveGUID = 0
-AuctionHouseBot.DisableItemsBelowReqLevel = 0
-AuctionHouseBot.DisableItemsAboveReqLevel = 0
-AuctionHouseBot.DisableTGsBelowReqLevel = 0
-AuctionHouseBot.DisableTGsAboveReqLevel = 0
-AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
-AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
-AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
-AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
-
-###############################################################################
-# CONSOLE AND REMOTE ACCESS
-#
-#    Console.Enable
-#        Enable console
-#        Default: 1 - on
-#                 0 - off
-#
-#    Ra.Enable
-#        Enable remote console
-#        Default: 0 - off
-#                 1 - on
-#
-#    Ra.IP
-#        Default remote console ip address, use 0.0.0.0 for every address
-#
-#    Ra.Port
-#        Default remote console port
-#
-#    Ra.MinLevel
-#        Minimum level that's required to login,3 by default
-#
-#    Ra.Secure
-#        Kick client on wrong pass
-#
-#    SOAP.Enable
-#        Enable soap service
-#        Default: 0 - off
-#                 1 - on
-#
-#    SOAP.IP
-#        Bound SOAP service ip address, use 0.0.0.0 to access from everywhere
-#        Default: 127.0.0.1
-#
-#    SOAP.Port
-#        SOAP port
-#        Default: 7878
-#
-###################################################################################################################
-
-Console.Enable = 1
-Ra.Enable = 0
-Ra.IP = 0.0.0.0
-Ra.Port = 3443
-Ra.MinLevel = 3
-Ra.Secure = 1
-SOAP.Enabled = 0
-SOAP.IP = 127.0.0.1
-SOAP.Port = 7878
-
-###################################################################################################################
-#    CharDelete.Method
-#        Character deletion behavior
-#        Default: 0  - Completely remove the character from the database
-#                 1  - Unlinking, the character gets unlinked from the account,
-#                      the name gets freed up and appears as deleted ingame
-#
-#    CharDelete.MinLevel
-#        Character gets deleted by CharDelete.Method=0 when the character
-#        hasn't the specified level yet.
-#        Default: 0  - For all characters the specified mode will be used
-#                 1+ - Only for players which have reached the specified level
-#                      will be deleted by the specified mode.
-#                      the rest will be deleted by CharDelete.Method=0
-#
-#    CharDelete.KeepDays
-#        Define the amount of days for which the characters are kept in the database before
-#        they will be removed
-#        Default: 30
-#                 0  - Don't delete any characters, they stay in the database forever.
-#
-###################################################################################################################
-
-CharDelete.Method = 0
-CharDelete.MinLevel = 0
-CharDelete.KeepDays = 30
-
-###############################################################################
-# MOVEMENT ANTICHEAT
-#
-#    Anticheat.Movement.Enable
-#        Enable Movement Anticheat
-#        Default: 0 - off
-#                 1 - on
-#
-#    Anticheat.Movement.AlarmCount
-#        Count alarms. After AlarmCount is exceeded, actions are taken against
-#        the player. (default 5)
-#
-#    Anticheat.Movement.AlarmTime
-#        Reset alarm-count after this milliseconds. (default 5000)
-#
-#    Anticheat.Movement.Kill
-#        Enable Kill cheater
-#        Default: 0 - off
-#                 1 - on
-#
-#    Anticheat.Movement.Kick
-#        Enable Kick cheater
-#        Default: 0 - off
-#                 1 - on
-#
-#    Anticheat.Movement.BanType
-#        Enable Ban cheater
-#        Default: 0 - off
-#                 1 - Ban Account
-#                 2 - Ban IP
-#                 3 - Ban Account + IP
-#
-#    Anticheat.Movement.BanTime
-#        How long the ban should last.
-#        Default: 1 Minute - 1m
-#
-#    Anticheat.Movement.MaxXYT
-#        Max units a player is allowed to travel per millisecond.
-#        Default: 0.04 (This is ~400% Speed, 0.007 is walk-speed,
-#                 310% is 0.0287)
-#
-#    Anticheat.Movement.IgnoreSecAfterTeleport
-#        After being teleported this number of seconds no cheat is reported.
-#        Default: 10 seconds - 10
-#
-#    Anticheat.Movement.GmLevel
-#        Only accounts that are below this gm-level or exact at the same,
-#        are reported for cheating.
-#        Default: Only normal Players - 0
-#
-###############################################################################
-
-Anticheat.Movement.Enable = 1
-Anticheat.Movement.AlarmCount = 4
-Anticheat.Movement.AlarmTime = 6000
-Anticheat.Movement.Kill = 0
-Anticheat.Movement.Kick = 0
-Anticheat.Movement.BanType = 0
-Anticheat.Movement.BanTime = "1m"
-Anticheat.Movement.MaxXYT = 0.0330
-Anticheat.Movement.IgnoreSecAfterTeleport = 10
-Anticheat.Movement.GmLevel = 1
-
-###############################################################################
-# CUSTOM SERVER OPTIONS
-#
-#    PlayerStart.AllReputation
-#        Players will start with most of the high level reputations that are
-#         needed for items, mounts etc.
-#
-#    PlayerStart.AllSpells
-#        If enabled, players will start with all their class spells
-#         (not talents). Useful for instant 80 servers.
-#        You must populate playercreateinfo_spell_custom table with the spells
-#         you want, or this WILL NOT WORK! The table has data for all
-#         classes / races up to TBC expansion.
-#         Do not enable if you do not know what you are doing!
-#        Default: 0 - off
-#                 1 - on
-#
-#    PlayerStart.MapsExplored
-#        Players will start with all maps explored if enabled
-#
-#    MusicInBattleground
-#        If enabled "L70ETC-Power of the horde" will be played when BG starts
-#
-#    HonorPointsAfterDuel
-#        The amount of honor points the duel winner will get after a duel.
-#        Default: 0 - disable
-#
-#    AlwaysMaxWeaponSkill
-#        Players will automatically gain max weapon/defense skill when
-#         logging in, leveling up etc.
-#
-#    PvPToken.Enable
-#        Enable/disable PvP Token System. Players will get a token
-#         after slaying another player that gives honor.
-#
-#    PvPToken.MapAllowType
-#        Where players can receive the pvp token
-#        4 - In all maps
-#        3 - In battlegrounds only
-#        2 - In FFA areas only (gurubashi arena etc)
-#        1 - In battlegrounds AND FFA areas only
-#
-#    PvPToken.ItemID
-#        The item players will get after killing someone
-#         if PvP Token system is enabled.
-#        Default: 29434 - Badge of justice
-#
-#    PvPToken.ItemCount
-#        Modify the item ID count - Default: 1
-#
-#    NoResetTalentsCost
-#        Enable or disable no cost when reseting talents
-#
-#   Guild.AllowMultipleGuildMaster
-#       Allow override of 1 Guild Master limit. Additional Guild Masters must
-#       be set using the ".guild rank" command, not through the UI
-#       Default: 0 = Only 1 Guild Master per guild
-#                1 = Allow more than one Guild Master
-#
-#   ShowKickInWorld
-#        Determines wether a message is broadcasted to the entire server
-#         when a player gets kicked
-#        Default: 0 = Disable
-#                 1 = Enable
-#
-#   RecordUpdateTimeDiffInterval
-#        Record update time diff to the log file
-#         update diff can be used as a criterion of performance
-#         diff < 300: good performance
-#         diff > 600: bad performance, may be caused by high cpu usage
-#        Default: 60000 (diff is written into log every 60000 ms or 1 minute.
-#                 >0 = Interval
-#                 0 = Disable
-#
-#   MinRecordUpdateTimeDiff
-#        Only record update time diff which is greater than this value
-#        Default: 10
-#
-#   PlayerStart.String
-#       If set to anything other than "", this string will be displayed
-#        to players when they login to a newly created character.
-#       Default: "" - send no text
-#
-#   LevelReq.Trade
-#        The required level of character to be able to trade
-#        Default: 1 (From level 1)
-#
-#   LevelReq.Ticket
-#        The required level of character to be able to write tickets
-#        Default: 1 (From level 1)
-#
-#   LevelReq.Auction
-#        The required level of character to be able to use auction
-#        Default: 1 (From level 1)
-#
-#   LevelReq.Mail
-#        The required level of character to be able to send and receive mail
-#        Default: 1 (From level 1)
-#
-#   DungeonFinder.Enable
-#        Enable Dungeon Finder system. Will enable dungeon finder and raid finder
-#        Default: 0 - off
-#                 1 - on
-#
-###############################################################################
-
-PlayerStart.AllReputation = 0
-PlayerStart.AllSpells = 0
-PlayerStart.MapsExplored = 0
-MusicInBattleground = 0
-HonorPointsAfterDuel = 0
-AlwaysMaxWeaponSkill = 0
-PvPToken.Enable = 0
-PvPToken.MapAllowType = 4
-PvPToken.ItemID = 29434
-PvPToken.ItemCount = 1
-Guild.AllowMultipleGuildMaster = 0
-NoResetTalentsCost = 0
-ShowKickInWorld = 0
-RecordUpdateTimeDiffInterval = 60000
-MinRecordUpdateTimeDiff = 100
-PlayerStart.String = ""
-LevelReq.Trade = 1
-LevelReq.Ticket = 1
-LevelReq.Auction = 1
-LevelReq.Mail = 1
-DungeonFinder.Enable = 0
-
-#######################################################################
-#   OutdoorPvP.Wintergrasp.Enabled
-#       Determines whether the Wintergrasp battle is enabled or not.
-#        Default: 0 = Disable
-#                 1 = Enable
-#
-#   OutdoorPvP.Wintergrasp.SaveState.Period
-#      Interval of Save Wintergrasp State Data  to restore it after crash/shutdown/restart
-#      Interval (in milliseconds)
-#      Default (10000 milliseconds)
-#      Warning:  Do not set it less 1 second!
-#
-#   OutdoorPvP.Wintergrasp.StartTime
-#       The start time of the first battle after server starts (in minutes)
-#       Default: 30
-#
-#   OutdoorPvP.Wintergrasp.BattleTime
-#       Time limit of a battle (in minutes)
-#       Default: 30
-#
-#   OutdoorPvP.Wintergrasp.Interval
-#       Interval between battles (in minutes)
-#       Default: 150
-#
-#   OutdoorPvP.Wintergrasp.CustomHonorRewards
-#       Defines whether custom honor rewards should be given to player
-#        for partaking in the Wintergrasp Battle.
-#        Default: 0 = Disable
-#                 1 = Enable
-#
-#   OutdoorPvP.Wintergrasp.CustomHonorBattleWin
-#       Defines the amount of honor points that should be given to the
-#        team winning the Wintergrasp Battle.
-#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
-#       Default: 3000
-#
-#   OutdoorPvP.Wintergrasp.CustomHonorBattleLose
-#       Defines the amount of honor points that should be given to the
-#        team losing the Wintergrasp Battle.
-#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
-#       Default: 1250
-#
-#   OutdoorPvP.Wintergrasp.CustomHonorDamageTower
-#       Defines the amount of honor points that should be given to the
-#        team for damaging a tower.
-#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
-#       Default: 750
-#
-#   OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower
-#       Defines the amount of honor points that should be given to the
-#        team for destroying a tower.
-#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
-#       Default: 750
-#
-#   OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding
-#       Defines the amount of honor points that should be given to the
-#        team for damaged buildings after the battle.
-#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
-#       Default: 750
-#
-#   OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding
-#      Defines the amount of honor points that should be given to the
-#        team for intact buildings after the battle.
-#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
-#       Default: 1500
-#
-#   OutdoorPvP.Wintergrasp.Antifarm.Enable
-#		Enable or Disable antifarm system
-#              (Default: 0)
-#
-#   OutdoorPvP.Wintergrasp.Antifarm.Atk
-#		Min count atack players for antifarm
-#              (Default: 5)
-#
-#   OutdoorPvP.Wintergrasp.Antifarm.Def
-#		Min count defense players for antifarm
-#              (Default: 5)
-#
-##########################################################
-
-OutdoorPvP.Wintergrasp.Enabled = 1
-OutdoorPvP.Wintergrasp.SaveState.Period = 10000
-OutdoorPvP.Wintergrasp.StartTime = 30
-OutdoorPvP.Wintergrasp.BattleTime = 30
-OutdoorPvP.Wintergrasp.Interval = 150
-OutdoorPvP.Wintergrasp.CustomHonorRewards = 0
-OutdoorPvP.Wintergrasp.CustomHonorBattleWin = 3000
-OutdoorPvP.Wintergrasp.CustomHonorBattleLose = 1250
-OutdoorPvP.Wintergrasp.CustomHonorDamageTower = 750
-OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower = 750
-OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding = 750
-OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding = 1500
\ No newline at end of file
+################################################
+# Trinity@Greedy-core World Server configuration file #
+################################################
+[worldserver]
+
+# Note to devs, line breaks should be at column 80
+###############################################################################
+# CONNECTIONS AND DIRECTORIES
+#
+#    RealmID
+#        RealmID must match the realmlist inside the realmd database
+#
+#    DataDir
+#        Data directory setting.
+#        Important: DataDir needs to be quoted, as it is a string which may
+#         contain space characters.
+#        Example: "@prefix@/share/trinitycore"
+#
+#    LogsDir
+#        Logs directory setting.
+#        Important: Logs dir must exists, or all logs need to be disabled
+#        Default: "" - no log directory prefix, if used log names isn't
+#         absolute path then logs will be stored in current directory.
+#
+#    LoginDatabaseInfo
+#    WorldDatabaseInfo
+#    CharacterDatabaseInfo
+#        Database connection settings for the world server.
+#        Default:
+#                    hostname;port;username;password;database
+#                    .;somenumber;username;password;database
+#                     - use named pipes in Windows
+#                    Named pipes: mySQL required adding
+#                        "enable-named-pipe" to [mysqld] section my.ini
+#                    .;/path/to/unix_socket;username;password;database
+#                     - use Unix sockets in Unix/Linux
+#
+#    LoginDatabase.WorkerThreads
+#    WorldDatabase.WorkerThreads
+#    CharacterDatabase.WorkerThreads
+#        The amount of worker threads spawned to handle
+#        asynchronous (delayed) MySQL statements.
+#        Each worker thread is mirrored with its own
+#        connection to the MySQL server and their own
+#        thread on the MySQL server.
+#        Default: 1
+#
+#    LoginDatabase.SynchThreads
+#    WorldDatabase.SynchThreads
+#    CharacterDatabase.SynchThreads
+#        The amount of MySQL connections spawned to handle
+#        synchronous (blocking) MySQL statements.
+#        Default: 1, 1, 2
+#
+#    MaxPingTime
+#        Settings for maximum database-ping interval (seconds between pings)
+#        Default: 1800 (30 minutes)
+#
+#    WorldServerPort
+#        Default WorldServerPort
+#
+#    BindIP
+#        Bind World Server to IP/hostname
+#
+###############################################################################
+
+RealmID = 1
+DataDir = "."
+LogsDir = ""
+LoginDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;auth"
+WorldDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;world"
+CharacterDatabaseInfo = "127.0.0.1;3306;trinity;trinity;characters"
+LoginDatabase.WorkerThreads = 1
+WorldDatabase.WorkerThreads = 1
+CharacterDatabase.WorkerThreads = 1
+LoginDatabase.SynchThreads = 1
+WorldDatabase.SynchThreads = 1
+CharacterDatabase.SynchThreads = 2
+MaxPingTime = 1800
+WorldServerPort = 8085
+BindIP = "0.0.0.0"
+
+###############################################################################
+# SCRIPTING SETTINGS
+#
+#    Locale
+#        Setting for current (DBC) locale to use
+#
+#    EventAI Error reporting
+#        Default: 0 - Only startup
+#                 1 - Startup errors and Runtime event errors
+#                 2 - Startup errors, Runtime event errors, and Creation errors
+#
+###############################################################################
+
+Locale = 0
+EAIErrorLevel = 2
+
+###############################################################################
+# PERFORMANCE SETINGS
+#
+#    UseProcessors
+#        Processors mask for multi-processor system (Used only in Windows)
+#        Default: 0 (selected by OS)
+#                 number (bitmask value of selected processors)
+#
+#    ProcessPriority
+#        Process priority setting (Used only at Windows)
+#        Default: 1 (HIGH)
+#                 0 (Normal)
+#
+#    Compression
+#        Compression level for update packages sent to client (1..9)
+#        Default: 1 (speed)
+#                 9 (best compression)
+#
+#    PlayerLimit
+#        Maximum number of players in the world. Excluding Mods, GMs and Admins
+#        Default: 100
+#                 0 (for infinite players)
+#                 If you want to block players and enable Mods, GMs or Admins use
+#                 DB field realmd.realmlist.allowedSecurityLevel
+#
+#    SaveRespawnTimeImmediately
+#        Save respawn time for creatures at death and gameobjects at use/open
+#        Default: 1 (save creature/gameobject respawn time immediately)
+#                 0 (save creature/gameobject respawn time at grid unload)
+#
+#    MaxOverspeedPings
+#        Maximum overspeed ping count before player kick
+#         (minimum is 2, 0 used for disable check)
+#        Default: 2
+#
+#    GridUnload
+#        Unload grids
+#         (if you have lot memory you can disable it to speed up
+#         player move to new grids second time)
+#        Default: 1 (unload grids)
+#                 0 (do not unload grids)
+#
+#    SocketSelectTime
+#        Socket select time (in milliseconds)
+#        Default: 10000 (10 secs)
+#
+#    SocketTimeOutTime
+#        Time in milliseconds afer which a connection sitting idle on the character
+#        selection screen is disconnected.
+#        Default: 900000 (15 minutes)
+#
+#    SessionAddDelay
+#        Time in microseconds that a network thread will sleep after authentication
+#        protocol and adding a connection to the world session map.
+#        Default: 10000 (10 milliseconds, 0,01 second)
+#
+#    GridCleanUpDelay
+#        Grid clean up delay (in milliseconds)
+#        Default: 300000 (5 min)
+#
+#    MapUpdateInterval
+#        Map update interval (in milliseconds)
+#        Default: 100
+#
+#    ChangeWeatherInterval
+#        Weather update interval (in milliseconds)
+#        Default: 600000 (10 min)
+#
+#    PlayerSaveInterval
+#        Player save interval (in milliseconds)
+#        Default: 900000 (15 min)
+#
+#    PlayerSave.Stats.MinLevel
+#        Minimum level for saving character stats for external usage in database    
+#        Default: 0  (do not save character stats)    
+#                 1+ (save stats for characters with level 1+)    
+#
+#    PlayerSave.Stats.SaveOnlyOnLogout    
+#        Enable/Disable saving of character stats only on logout
+#        Default: 1 (only save on logout)
+#                 0 (save on every player save)
+#
+#    vmap.enableLOS
+#    vmap.enableHeight
+#        Enable/Disable VMmap support for line of sight and height calculation
+#                 0 (disable)
+#        Default: 1 (enable)
+#
+#    vmap.ignoreMapIds
+#        Map id that will be ignored by VMaps
+#         List of ids with delimiter ','
+#         If more then one id is defined and spaces are included, the string
+#         has to be enclosed by "
+#        Example: "369,0,1,530"
+#
+#    vmap.ignoreSpellIds
+#        These spells are ignored for LoS calculation
+#         List of ids with delimiter ','
+#
+#    vmap.petLOS
+#        Check LOS for pets, to avoid them going through walls etc.
+#                 0 (disable, somewhat less CPU usage)
+#        Default: 1 (enable, each pet attack command will check for LOS)
+#
+#    vmap.enableIndoorCheck
+#        Enable/Disable VMap based indoor check to remove outdoor-only auras (mounts etc.)
+#                 0 (disabled, somewhat less CPU usage)
+#        Default: 1 (enabled)
+#
+#    DetectPosCollision
+#        Check final move position, summon position, etc for visible collision
+#         with other objects or wall (wall only if vmaps are enabled)
+#        Default: 1 (enable, required more CPU usage)
+#                 0 (disable, less position precision but will use less CPU)
+#
+#    TargetPosRecalculateRange
+#        Max distance from movement target point (+moving unit size) and
+#         targeted object (+size) after that new target movement point
+#         calculated. Max: melee attack range (5), min: contact range (0.5)
+#         More distance let have better performence, less distance let have
+#         more sensitive reaction at target move.
+#        Default: 1.5
+#
+#    UpdateUptimeInterval
+#        Update realm uptime period in minutes. Must be > 0
+#        Default: 10 (minutes)
+#
+#    LogDB.Opt.ClearInterval
+#        Time for the WUPDATE_CLEANDB timer that clears the `logs` table
+#         of old entries. Must be > 0.
+#        Default: 10 (minutes)
+#
+#    LogDB.Opt.ClearTime
+#        The maximum time in seconds of old `logs` table entries to keep.
+#        Default: 1209600 (14 days)
+#                 0 - don't clear
+#
+#    MaxCoreStuckTime
+#        Periodically check if the process is frozen, if this is the case
+#         force crash after the specified amount of seconds. Must be > 0.
+#         Recommended > 10 secs if you use this.
+#        Default: 0 (Disabled)
+#
+#    AddonChannel
+#        Permit/disable the use of the addon channel through the server
+#         (some client side addons will not work correctly with disabled
+#         addon channel)
+#        Default: 1 (permit addon channel)
+#                 0 (do not permit addon channel)
+#
+#    MapUpdate.Threads
+#    Number of threads to update maps.
+#    Default: 1
+#
+#    CleanCharacterDB
+#        Perform character db clean ups on start up
+#        Default: 0 (Disabled)
+#                 1 (Enable)
+#
+###############################################################################
+
+UseProcessors = 0
+ProcessPriority = 1
+Compression = 1
+PlayerLimit = 100
+SaveRespawnTimeImmediately = 1
+MaxOverspeedPings = 2
+GridUnload = 1
+SocketSelectTime = 10000
+SocketTimeOutTime = 900000
+SessionAddDelay = 10000
+GridCleanUpDelay = 300000
+MapUpdateInterval = 100
+ChangeWeatherInterval = 600000
+PlayerSaveInterval = 900000
+PlayerSave.Stats.MinLevel = 0
+PlayerSave.Stats.SaveOnlyOnLogout = 1
+vmap.enableLOS = 1
+vmap.enableHeight = 1
+vmap.ignoreMapIds = ""
+vmap.ignoreSpellIds = "7720"
+vmap.petLOS = 1
+vmap.enableIndoorCheck = 1
+DetectPosCollision = 1
+TargetPosRecalculateRange = 1.5
+UpdateUptimeInterval = 10
+LogDB.Opt.ClearInterval = 10
+LogDB.Opt.ClearTime = 1209600
+MaxCoreStuckTime = 0
+AddonChannel = 1
+MapUpdate.Threads = 1
+CleanCharacterDB = 0
+
+###############################################################################
+# SERVER LOGGING
+#
+#    LogSQL
+#        Enable logging of SQL commands from in game
+#         All commands are written to a file: YYYY-MM-DD_logSQL.sql
+#         If a new day starts (00:00:00) then a new file is created
+#         the old file will not be deleted.
+#        Default: 1 - Write SQL code to logfile
+#                 0 - Do not log
+#
+#    PidFile
+#        World daemon PID file
+#        Default: ""             - do not create PID file
+#                 "./worldd.pid" - create PID file (recommended name)
+#
+#    LogLevel
+#        Server console level of logging
+#                 0 = Minimum
+#        Default: 1 = Basic
+#                 2 = Detail
+#                 3 = Full/Debug
+#
+#    LogFile
+#        Logfile name
+#        Default: "Server.log"
+#                 "" - Empty name disable creating log file
+#
+#    ChatLogFile
+#        Log file for chat logs
+#        Default: "chat.log"
+#                 "" - Empty name for disable
+#
+#    LogTimestamp
+#        Logfile with timestamp of server start in name
+#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name
+#
+#    LogFileLevel
+#        Server file level of logging
+#        Default: 0 = Minimum
+#                 1 = Basic
+#                 2 = Detail
+#                 3 = Full/Debug
+#
+#    LogFilter_AchievementUpdates
+#    LogFilter_CreatureMoves
+#    LogFilter_TransportMoves
+#    LogFilter_VisibilityChanges
+#        Log filters
+#        Default: 1 - not include with any log level
+#                 0 - include in log if log level permit
+#
+#    WorldLogFile
+#        Packet logging file for the worldserver
+#        Default: "world.log"
+#
+#    DBErrorLogFile
+#        Log file of DB errors detected at server run
+#        Default: "DBErrors.log"
+#
+#    CharLogFile
+#        Character operations logfile name
+#        Default: "Char.log"
+#                 "" - Empty name disable creating log file
+#
+#    CharLogTimestamp
+#        Logfile with timestamp of server start in name
+#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name
+#
+#    CharLogDump
+#        Write character dump before deleting in Char.log
+#         For restoration, cut character data from log starting from
+#         line == START DUMP == to line == END DUMP == (exclusive) in file
+#         and load it using the loadpdump command
+#        Default: 0 - don't include dumping chars to log
+#                 1 - include dumping chars to log
+#
+#    CharLogDump.Separate
+#        Write character dump to separate file
+#        Default: 0 - don't write dump to separate file
+#                 1 - write each dump to separate file
+#
+#    CharLogDump.SeparateDir
+#        Subdirectory within logs dir for separate char dumps.
+#
+#    GmLogFile
+#        Log file of gm commands
+#        Default: "gm_commands.log"
+#                 "" - Empty name for disable
+#
+#    GmLogTimestamp
+#        GM Logfile with timestamp of server start in name
+#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name
+#
+#    GmLogPerAccount
+#        GM Logfiles with GM account id
+#         (Note: logs not created if GmLogFile not set)
+#        Default: 0 - add gm log data to single log file
+#                 1 - add gm log data to account specific log files with name
+#                     in form Logname_#ID_YYYY-MM-DD_HH-MM-SS.Ext
+#                     or form Logname_#ID.Ext
+#
+#    RaLogFile
+#        Log file of RA commands
+#        Default: "Ra.log"
+#                 "" - Empty name for disable
+#
+#    ArenaLogFile
+#        Log file of arena fights and arena team creations
+#        Default: "" - do not create arena log file
+#
+#    ArenaLog.ExtendedInfo
+#        Include extended info for each player after rated arena (guid, name, team, IP, healing/damage done, killing blows)
+#        Default: 0 - disabled
+#                 1 - enabled
+#
+#    SQLDriverLogFile
+#        Log file of SQL driver events.
+#        For effective query logging you need to build in debug configuration.
+#        Default: "" - Empty name for disable
+#
+#    LogColors
+#        Color for messages (format "normal basic detail debug")
+#        Default: "" - no colors
+#        Colors: 0  - BLACK
+#                1  - RED
+#                2  - GREEN
+#                3  - BROWN
+#                4  - BLUE
+#                5  - MAGENTA
+#                6  - CYAN
+#                7  - GREY
+#                8  - YELLOW
+#                9  - LRED
+#                10 - LGREEN
+#                11 - LBLUE
+#                12 - LMAGENTA
+#                13 - LCYAN
+#                14 - WHITE
+#        Example: "13 11 9 5"
+#
+#    EnableLogDB
+#        Enable/disable logging to database (LogDatabaseInfo).
+#        Default: 0 - disabled
+#                 1 - enabled
+#
+#    DBLogLevel
+#        Log level of DB logging.
+#                 0 = Minimum
+#                 1 = Basic
+#                 2 = Detail
+#        Default: 3 = Full/Debug
+#
+#    LogDB.Char
+#        Enable/disable logging character outputs to DB.
+#        Default: 0 - off
+#                 1 - on
+#
+#    LogDB.GM
+#        Enable/disable logging GM commands to DB.
+#        Default: 0 - off
+#                 1 - on
+#
+#    LogDB.RA
+#        Enable/disable logging remote access events to DB.
+#        Default: 0 - off
+#                 1 - on
+#
+#    LogDB.World
+#        Enable/disable logging world packets to DB.
+#        Default: 0 - off
+#                 1 - on (very heavy)
+#
+#    LogDB.Chat
+#        Enable/disable logging chat messages to the database.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.Channel
+#        Enable logging chatting in custom channels.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.Whisper
+#        Enable logging whispers between players.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.Party
+#        Enable logging party messages.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.Raid
+#        Enable logging raid messages.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.Guild
+#        Enable logging guild messages.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.Public
+#        Enable logging public chat events (say/yell/emote).
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.Addon
+#        Enable logging addon messages.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogs.BattleGround
+#        Enable logging battleground chats.
+#        Default: 0 - off
+#                 1 - on
+#
+#    ChatLogTimestamp
+#        Chat Logfile with timestamp of server start in name
+#         in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name
+#
+###############################################################################
+
+LogSQL = 1
+PidFile = ""
+LogLevel = 1
+LogFile = "Server.log"
+ChatLogFile = "chat.log"
+LogTimestamp = 0
+LogFileLevel = 0
+LogFilter_AchievementUpdates = 1
+LogFilter_CreatureMoves = 1
+LogFilter_TransportMoves = 1
+LogFilter_VisibilityChanges = 1
+WorldLogFile = ""
+DBErrorLogFile = "db_errors.log"
+CharLogFile = "characters.log"
+CharLogTimestamp = 0
+CharLogDump = 0
+CharLogDump.Separate = 0
+CharLogDump.SeparateDir = ""
+GmLogFile = "gm_commands.log"
+GmLogTimestamp = 0
+GmLogPerAccount = 0
+RaLogFile = "ra_commands.log"
+ArenaLogFile = ""
+ArenaLog.ExtendedInfo = 0
+SQLDriverLogFile = ""
+LogColors = ""
+EnableLogDB = 0
+DBLogLevel = 2
+LogDB.Char   = 0
+LogDB.GM     = 0
+LogDB.RA     = 0
+LogDB.World  = 0
+LogDB.Chat   = 0
+ChatLogs.Channel      = 0
+ChatLogs.SysChan      = 0
+ChatLogs.Whisper      = 0
+ChatLogs.Party        = 0
+ChatLogs.Raid         = 0
+ChatLogs.Guild        = 0
+ChatLogs.Public       = 0
+ChatLogs.Addon        = 0
+ChatLogs.BattleGround = 0
+ChatLogTimestamp = 0
+
+###############################################################################
+# CHAT LOGGING AND LEXICS CUTTER
+#
+#    ChatLog.Enable
+#        Enable system of chat logging.
+#        Default: 1 - on
+#                 0 - off
+#
+#    ChatLog.DateSplit
+#        Split log files by date (filename must include $d as date placeholder).
+#        Default: 1 - split
+#                 0 - do not split
+#
+#    ChatLog.UTFHeader
+#        Add UTF8 header at the beginning of new file.
+#        Default: 1 - add
+#                 0 - do not add
+#
+#    ChatLog.Ignore.Unprintable
+#        Ignore messages with unprintable characters.
+#        Default: 1 - ignore
+#                 0 - do not ignore
+#
+#    ChatLog.Lexics.Enable
+#        Enable lexics cutter in chats.
+#        Default: 1 - on
+#                 0 - off
+#
+#    ChatLog.Lexics.Cut.Enable
+#        Cut innormative lexics in chat.
+#        Default: 1 - cut
+#                 0 - do not cut
+#
+#    ChatLog.Lexics.Cut.Replacement
+#        Text shown instead of message with innormative lexics.
+#
+#    ChatLog.Lexics.WordsFile
+#        Path to the file with words considered as innormative.
+#
+#    ChatLog.Lexics.AnalogsFile
+#        Path to the file with letter analogs.
+#
+#    ChatLog.Lexics.Ignore.Spaces
+#        Ignore spaces in filtered words. Example: W O R D
+#        Default: 1 - ignore
+#                 0 - do not ignore
+#
+#    ChatLog.Lexics.Ignore.Repeats
+#        Ignore repeating symbols in filtered words. Example: WWWOOOORRRRRRDDD
+#        Default: 1 - ignore
+#                 0 - do not ignore
+#
+#    ChatLog.Lexics.Ignore.GM
+#        Ignore (do not filter) messages from GM.
+#        Default: 1 - ignore
+#                 0 - do not ignore
+#
+#    ChatLog.Lexics.Action
+#        Action taken when bad lexics is found.
+#        Default: 0 - log only
+#                 1 - polymorph
+#                 2 - stun
+#                 3 - instant kill
+#                 4 - leave 5 health
+#                 5 - mute
+#                 6 - stuck (works as stun + 50% health) [by KAPATEJIb]
+#                 7 - resurrection sickness [by Koshei]
+#                 8 - shear [by Koshei]
+#
+#    ChatLog.Lexics.Action.Duration
+#        Duration of action in milliseconds.
+#        Default: 0 - no duration
+#
+#    SETTINGS FOR DIFFERENT CHAT TYPES
+#    Available types:
+#        * Chat - common chat
+#        * Party - party chat
+#        * Guild - guild chat
+#        * Whisper - whispers
+#        * Channel - channels
+#        * Raid - raid chat
+#        * BattleGround - battleground chat
+#        * Lexics.Innormative - messages filtered by lexics cutter
+#
+#    ChatLog.*.File
+#        Log file name for given chat type.
+#
+#    ChatLog.*.Screen
+#        Output message in server console for given chat type.
+#        Default: 0 - do not show
+#                 1 - show
+#
+#    ChatLog.Lexics.*.Cut
+#        Cut lexics for given chat type (except Innormative).
+#        Default: 1 - cut
+#                 0 - do not cut
+#
+###############################################################################
+
+ChatLog.Enable = 1
+ChatLog.DateSplit = 1
+ChatLog.UTFHeader = 1
+ChatLog.Ignore.Unprintable = 1
+
+ChatLog.Lexics.Enable = 1
+ChatLog.Lexics.Cut.Enable = 1
+ChatLog.Lexics.Cut.Replacement = &!@^%!^&*!!!
+ChatLog.Lexics.AnalogsFile = letter_analogs.txt
+ChatLog.Lexics.WordsFile = innormative_words.txt
+ChatLog.Lexics.Ignore.Spaces = 1
+ChatLog.Lexics.Ignore.Repeats = 1
+ChatLog.Lexics.Ignore.GM = 1
+ChatLog.Lexics.Action = 0
+ChatLog.Lexics.Action.Duration = 0
+
+ChatLog.Chat.File = "main_chat-$d.log"
+ChatLog.Chat.Screen = 0
+ChatLog.Lexics.Chat.Cut = 1
+
+ChatLog.Party.File = "party_chat-$d.log"
+ChatLog.Party.Screen = 0
+ChatLog.Lexics.Party.Cut = 1
+
+ChatLog.Guild.File = "guild_chat-$d.log"
+ChatLog.Guild.Screen = 0
+ChatLog.Lexics.Guild.Cut = 1
+
+ChatLog.Whisper.File = "whisper_chat-$d.log"
+ChatLog.Whisper.Screen = 0
+ChatLog.Lexics.Whisper.Cut = 1
+
+ChatLog.Channel.File = "channel_chat-$d.log"
+ChatLog.Channel.Screen = 0
+ChatLog.Lexics.Channel.Cut = 1
+
+ChatLog.Raid.File = "raid_chat-$d.log"
+ChatLog.Raid.Screen = 0
+ChatLog.Lexics.Raid.Cut = 1
+
+ChatLog.BattleGround.File = "bg_chat-$d.log"
+ChatLog.BattleGround.Screen = 0
+ChatLog.Lexics.BattleGround.Cut = 1
+
+ChatLog.Lexics.Innormative.File = "innormative-$d.log"
+ChatLog.Lexics.Innormative.Screen = 0
+
+###############################################################################
+# SERVER SETTINGS
+#
+#    GameType
+#        Server realm style
+#        Default: 0 = NORMAL
+#                 1 = PVP
+#                 4 = NORMAL
+#                 6 = RP
+#                 8 = RPPVP
+#                 16 FFA_PVP (free for all pvp mode like arena PvP in all
+#                     zones except rest activated places and sanctuaries)
+#
+#    RealmZone
+#        Server realm zone (set allowed alphabet in character names/etc)
+#         See also Strict*Names options.
+#        Default: 1 Development    - any language
+#                 2 United States  - extended-Latin
+#                 3 Oceanic        - extended-Latin
+#                 4 Latin America  - extended-Latin
+#                 5 Tournament     - basic-Latin at create, any at login
+#                 6 Korea          - East-Asian
+#                 7 Tournament     - basic-Latin at create, any at login
+#                 8 English        - extended-Latin
+#                 9 German         - extended-Latin
+#                 10 French        - extended-Latin
+#                 11 Spanish       - extended-Latin
+#                 12 Russian       - Cyrillic
+#                 13 Tournament    - basic-Latin at create, any at login
+#                 14 Taiwan        - East-Asian
+#                 15 Tournament    - basic-Latin at create, any at login
+#                 16 China         - East-Asian
+#                 17 CN1           - basic-Latin at create, any at login
+#                 18 CN2           - basic-Latin at create, any at login
+#                 19 CN3           - basic-Latin at create, any at login
+#                 20 CN4           - basic-Latin at create, any at login
+#                 21 CN5           - basic-Latin at create, any at login
+#                 22 CN6           - basic-Latin at create, any at login
+#                 23 CN7           - basic-Latin at create, any at login
+#                 24 CN8           - basic-Latin at create, any at login
+#                 25 Tournament    - basic-Latin at create, any at login
+#                 26 Test Server   - any language
+#                 27 Tournament    - basic-Latin at create, any at login
+#                 28 QA Server     - any language
+#                 29 CN9           - basic-Latin at create, any at login
+#
+#    Expansion
+#        Allow server use content from expansion
+#        Default: 2 - check expansion 2 maps existence, and if client support
+#                      expansion 2 and account have expansion 2 setting then
+#                      allow visit expansion 2 maps, allow create new class
+#                      character)
+#                 1 - check expansion 1 maps existence, and if client support
+#                      expansion 1 and account have expansion 1 setting then
+#                      allow visit expansion 1 maps, allow create new races
+#                      character)
+#                 0 - don't check expansion maps existence, don't allow visit
+#                      maps, don't allow create new race or new class
+#                      characters, ignore account expansion setting)
+#
+#    DBC.Locale
+#        DBC Language Settings
+#        Default: 255 = Auto Detect
+#                 0   = English
+#                 1   = Korean
+#                 2   = French
+#                 3   = German
+#                 4   = Chinese
+#                 5   = Taiwanese
+#                 6   = Spanish
+#                 7   = Spanish Mexico
+#                 8   = Russian
+#
+#    DeclinedNames
+#        Allow russian clients to set and use declined names
+#        Default: 0 - do not use declined names, except when
+#                      the Russian RealmZone is set
+#                 1 - use declined names
+#
+#    StrictPlayerNames
+#        Limit player name to language specific symbol set, don't allow
+#         character creation, and set rename request and disconnect at not
+#         allowed symbols name
+#        Default: 0 disable (limited server timezone dependent client check)
+#                 1 basic latin characters  (strict)
+#                 2 realm zone specific (strict). See RealmZone setting.
+#                   Note: In any case if you want correctly see character
+#                   name at client this client must have appropriate fonts
+#                   (included in client by default, with active official
+#                   localization or custom localization fonts in
+#                   clientdir/Fonts).
+#                 3 basic latin characters + server timezone specific
+#
+#    StrictCharterNames
+#        Limit guild/arena team charter names to language specific symbol set,
+#          don't allow charter creation with unallowed symbols in name
+#        Default: 0 disable
+#                 1 basic latin characters  (strict)
+#                 2 realm zone specific (strict). See RealmZone setting.
+#                   Note: In any case if you want correctly see character
+#                   name at client this client must have appropriate fonts
+#                   (included in client by default, with active official
+#                   localization or custom localization fonts in
+#                   clientdir/Fonts).
+#                 3 basic latin characters + server timezone specific
+#
+#    StrictPetNames
+#        Limit pet names to language specific symbols set
+#        Default: 0 disable
+#                 1 basic latin characters  (strict)
+#                 2 realm zone specific (strict). See RealmZone setting.
+#                   Note: In any case if you want correctly see character
+#                   name at client this client must have appropriate fonts
+#                   (included in client by default, with active official
+#                   localization or custom localization fonts in
+#                   clientdir/Fonts).
+#                 3 basic latin characters + server timezone specific
+#
+#    MinPlayerName
+#        Minimal name length (1..12)
+#        Default: 2
+#
+#    MinCharterName
+#        Minimal name length (1..24)
+#        Default: 2
+#
+#    MinPetName
+#        Minimal name length (1..12)
+#        Default: 2
+#
+#    MaxWhoListReturns
+#        Set the max number of players returned in the /who list and interface.
+#        Default: 49 (stable)
+#
+#    CharacterCreating.Disabled
+#        Disable characters creating for specific team or any
+#         (non-player accounts not affected)
+#        Default: 0 - enabled
+#                 1 - disabled only for Alliance
+#                 2 - disabled only for Horde
+#                 3 - disabled for both teams
+#
+#    CharacterCreating.Disabled.RaceMask
+#        Mask of races which cannot be created (ignored for GM accounts).
+#        Default: 0 - all races are enabled
+#                 Check http://www.trinitycore.info/index.php/Characters_tc2#race 
+#                 for race mask values.
+#        Example: 1536 = 1024 + 512 - Blood Elf and Draenei races are disabled.
+#
+#    CharacterCreating.Disabled.ClassMask
+#        Mask of classes which cannot be created (ignored for GM accounts).
+#        Default: 0 - all classes are enabled
+#                 Check http://www.trinitycore.info/index.php/Characters_tc2#class 
+#                 for class mask values.
+#        Example: 288 = 32 + 256 - Death Knight and Warlock classes are disabled.
+#
+#    CharactersPerAccount
+#        Limit numbers of characters per account (at all realms).
+#         Note: this setting limit character creating at _current_ realm base
+#         at characters amount at all realms
+#        Default: 50
+#                The number must be >= CharactersPerRealm
+#
+#    CharactersPerRealm
+#        Limit numbers of characters for account at realm
+#        Default: 10 (client limitation)
+#                The number must be between 1 and 10
+#
+#    HeroicCharactersPerRealm
+#        Limit numbers of heroic class characters for account at realm
+#        Default: 1
+#                The number must be between 0 (not allowed) and 10
+#
+#    CharacterCreating.MinLevelForHeroicCharacter
+#        Limit creating heroic characters only for account with another
+#         character of specific level (ignored for GM accounts)
+#                 0  - not require any existed chaarcter
+#                 1  - require at least any character existed
+#        Default: 55 - default requirement
+#
+#    SkipCinematics
+#        Disable in-game script movie at first character's login
+#         (allows to prevent buggy intro in case of custom start
+#         location coordinates)
+#        Default: 0 - show intro for each new characrer
+#                 1 - show intro only for first character of selected race
+#                 2 - disable intro show in all cases
+#
+#    MaxPlayerLevel
+#        Max level that can be reached by player for experience
+#         (in range from 1 to 100). Going past 100 voids your warranty
+#         and you will not receive support for bugs you encounter.
+#        Change not recommended
+#        Default: 80
+#
+#    MinDualSpecLevel
+#        Min level at which players can use Dual Spec functionality
+#        Default: 40
+#
+#    StartPlayerLevel
+#        Staring level that have character upon creation
+#         (in range 1 to MaxPlayerLevel)
+#        Default: 1
+#
+#    StartHeroicPlayerLevel
+#        Staring level that have character of heroic class upon creation
+#         (in range 1 to MaxPlayerLevel)
+#        Default: 55
+#
+#    StartPlayerMoney
+#        Amount of money that new players will start with.
+#         If you want to start with silver, use for example 100
+#         (100 copper = 1 silver)
+#        Default: 0
+#
+#    MaxHonorPoints
+#        Max honor points that player can have.
+#        Default: 75000
+#
+#    StartHonorPoints
+#        Amount of honor that new players will start with
+#        Default: 0
+#
+#    MaxArenaPoints
+#        Max arena points that player can have.
+#        Default: 10000
+#
+#    StartArenaPoints
+#        Amount of arena points that new players will start with
+#        Default: 0
+#
+#    RecruitAFriend.MaxLevel
+#        Highest level at which a player can benefit from the Recruit-A-Friend
+#         XP multiplier
+#        Default: 60
+#
+#    RecruitAFriend.MaxDifference = 3
+#        Highest level difference between linked players for both players to 
+#         benefit from the Recruit-A-Friend XP multiplier
+#        Default: 3
+#
+#    InstantLogout
+#        Enable or disable instant logout for security level (0..4) or higher
+#        (NOT in combat/while dueling/while falling)
+#        Default: 1 (Mods/GMs/Admins)
+#
+#    DisableWaterBreath
+#        Disable/enable waterbreathing for security level (0..4) or higher
+#        Default: 4 (None)
+#
+#    AllFlightPaths
+#        Players will start with all flight paths
+#         (Note: ALL flight paths, not only player's team)
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    InstantFlightPaths
+#        Flight paths will take players to their destination instantly, instead
+#         of making them wait to fly there.
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    AlwaysMaxSkillForLevel
+#        Players will automatically gain max level dependent (weapon/defense)
+#         skill when logging in, leveling up etc.
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    ActivateWeather
+#        Activate weather system
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    CastUnstuck
+#        Allow cast or not Unstuck spell at .start or client Help option use
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    Instance.IgnoreLevel
+#        Ignore level requirement to enter instance
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    Instance.IgnoreRaid
+#        Ignore raid requirement to enter instance
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    Instance.ResetTimeHour
+#        The hour of the day (0-23) when the global instance resets occur.
+#        Default: 4
+#
+#    Instance.UnloadDelay
+#        Unload the instance map from memory after some time
+#         if no players are inside.
+#        Default: 1800000 (miliseconds 30 minutes)
+#                 0 (instance maps are kept in memory until they are reset)
+#
+#    Quests.LowLevelHideDiff
+#        Quest level difference to hide for player low level quests:
+#         if player_level > quest_level + LowLevelQuestsHideDiff then quest
+#         "!" mark not show for quest giver
+#        Default: 4
+#                -1 (show all available quests marks)
+#
+#    Quests.HighLevelHideDiff
+#        Quest level difference to hide for player high level quests:
+#         if player_level < quest_min_level - HighLevelQuestsHideDiff then
+#         quest "!" mark not show for quest giver
+#        Default: 7
+#                -1 (show all available quests marks)
+#
+#    Quests.IgnoreRaid
+#        Allow non-raid quests to be completed when in raid group
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    Guild.EventLogRecordsCount
+#        Count of guild event log records stored in guild_eventlog table
+#         Increase to store more guild events in table, minimum is 100
+#         You can set it to very high value to prevent oldest guild events to
+#         be rewritten by latest guild events; can slow down performance
+#        Default: 100
+#
+#    Guild.BankEventLogRecordsCount
+#        Count of guild_bank event log records stored in
+#         guild_bank_eventlog table
+#         Increase to store more guild_bank events in table - minimum is 25
+#         (GUILD_BANK_MAX_LOGS) for each guild_bank tab
+#         Useful when you don't want old log events to be overwritten by new,
+#         but increasing can slow down performance
+#        Default: 25
+#
+#    MaxPrimaryTradeSkill
+#        Max count that player can learn the primary trade skill.
+#        Default: 2
+#        Max : 10
+#
+#    MinPetitionSigns
+#        Min signatures count to creating guild (0..9).
+#        Default: 9
+#
+#    MaxGroupXPDistance
+#        Max distance to creature for group member to get XP at creature death.
+#        Default: 74
+#
+#    MaxRecruitAFriendBonusDistance
+#        Max distance to player for group member to get RaF bonus for XP.
+#        Default: 100
+#
+#    MailDeliveryDelay
+#        Mail delivery delay time for item sending
+#        Default: 3600 sec (1 hour)
+#
+#    SkillChance.Prospecting
+#        For prospecting skillup impossible by default,
+#         but can be allowed as custom setting
+#        Default: 0 - no skilups
+#                 1 - skilups possible
+#
+#    SkillChance.Milling
+#        For milling skillup impossible by default,
+#         but can be allowed as custom setting
+#        Default: 0 - no skilups
+#                 1 - skilups possible
+#
+#    OffhandCheckAtSpellUnlearn
+#        Unlearning certain spells can change offhand weapon restrictions
+#         for equip slots.
+#        Default: 1 - recheck offhand slot weapon at unlearning a spell
+#                 0 - recheck offhand slot weapon only at zone update
+#
+#    ClientCacheVersion
+#        Client cache version for client cache data reset. Use any different
+#         from DB value and not recently used for triggering reset.
+#        Default: 0 (use DB value from world DB db_version.cache_id field)
+#
+#    Event.Announce
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    BeepAtStart
+#        Beep at core start finished (mostly work only at Unix/Linux systems)
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    Motd
+#        Message of the Day. Displayed at worldlogin for every user
+#         Use '@' for a newline, and be sure to escape special characters.
+#        Example: "Welcome to John\'s Server@WinterGrasp is closed."
+#
+#    Server.LoginInfo
+#        Enable/disable sending server info (core version) on login.
+#        Default: 0 - disable
+#                 1 - enable
+#
+#    Command.LookupMaxResults
+#        The maximum number of results a .lookup command can return
+#        Default: 0 - unlimited
+#
+###############################################################################
+
+GameType = 0
+RealmZone = 1
+Expansion = 2
+DBC.Locale = 255
+DeclinedNames = 0
+StrictPlayerNames = 0
+StrictCharterNames = 0
+StrictPetNames = 0
+MaxWhoListReturns = 49
+MinPlayerName = 2
+MinCharterName = 2
+MinPetName = 2
+CharacterCreating.Disabled = 0
+CharacterCreating.Disabled.RaceMask = 0
+CharacterCreating.Disabled.ClassMask = 0
+CharactersPerAccount = 50
+CharactersPerRealm = 10
+HeroicCharactersPerRealm = 1
+CharacterCreating.MinLevelForHeroicCharacter = 55
+SkipCinematics = 0
+MaxPlayerLevel = 80
+MinDualSpecLevel = 40
+StartPlayerLevel = 1
+StartHeroicPlayerLevel = 55
+StartPlayerMoney = 0
+MaxHonorPoints = 75000
+StartHonorPoints = 0
+MaxArenaPoints = 10000
+StartArenaPoints = 0
+RecruitAFriend.MaxLevel = 60
+RecruitAFriend.MaxDifference = 3
+InstantLogout = 1
+DisableWaterBreath = 4
+AllFlightPaths = 0
+InstantFlightPaths = 0
+AlwaysMaxSkillForLevel = 0
+ActivateWeather = 1
+CastUnstuck = 1
+Instance.IgnoreLevel = 0
+Instance.IgnoreRaid = 0
+Instance.ResetTimeHour = 4
+Instance.UnloadDelay = 1800000
+Quests.LowLevelHideDiff = 4
+Quests.HighLevelHideDiff = 7
+Quests.IgnoreRaid = 0
+Guild.EventLogRecordsCount = 100
+Guild.BankEventLogRecordsCount = 25
+MaxPrimaryTradeSkill = 2
+MinPetitionSigns = 9
+MaxGroupXPDistance = 74
+MaxRecruitAFriendBonusDistance = 100
+MailDeliveryDelay = 3600
+SkillChance.Prospecting = 0
+SkillChance.Milling = 0
+OffhandCheckAtSpellUnlearn = 1
+ClientCacheVersion = 0
+Event.Announce = 0
+BeepAtStart = 1
+Motd = "Welcome to a Trinity Core server."
+Server.LoginInfo = 0
+Command.LookupMaxResults = 0
+
+###############################################################################
+# PLAYER INTERACTION
+#
+#    AllowTwoSide.Accounts
+#        Allow or not accounts to create characters in the 2 teams
+#         in any game type.
+#        Default: 1 (Allowed)
+#                 0 (Not allowed)
+#
+#    AllowTwoSide.Interaction.Chat
+#    AllowTwoSide.Interaction.Channel
+#    AllowTwoSide.Interaction.Group
+#    AllowTwoSide.Interaction.Guild
+#    AllowTwoSide.Interaction.Auction
+#    AllowTwoSide.Interaction.Mail
+#        Allow or not common :chat(say,yell)
+#                             channel(chat)
+#                             group(join)
+#                             guild(join)
+#                             merge all auction houses for players from
+#                             different teams
+#                             send mail to other team.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    AllowTwoSide.WhoList
+#        Allow or not show player from both team in who list.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    AllowTwoSide.AddFriend
+#        Allow or not adding friends from other team in friend list.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    AllowTwoSide.Trade
+#        Allow or not trading with other team in party.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    TalentsInspecting
+#        Allow other players see character talents in inspect dialog
+#         (Characters in Gamemaster mode can inspect talents always)
+#        Default: 1 (allow)
+#                 0 (not allow)
+#
+###############################################################################
+
+AllowTwoSide.Accounts = 1
+AllowTwoSide.Interaction.Chat = 0
+AllowTwoSide.Interaction.Channel = 0
+AllowTwoSide.Interaction.Group = 0
+AllowTwoSide.Interaction.Guild = 0
+AllowTwoSide.Interaction.Auction = 0
+AllowTwoSide.Interaction.Mail = 0
+AllowTwoSide.WhoList = 0
+AllowTwoSide.AddFriend = 0
+AllowTwoSide.Trade = 0
+TalentsInspecting = 1
+
+###############################################################################
+# CREATURE SETTINGS
+#
+#    ThreatRadius
+#        Radius for creature to evade after being
+#         pulled away from combat start point
+#         If ThreatRadius is less than creature aggro radius
+#         then aggro radius will be used
+#        Default: 60 yards
+#
+#    Rate.Creature.Aggro
+#        Aggro radius percent or off.
+#        Default: 1   - 100%
+#                 1.5 - 150%
+#                 0   - off (0%)
+#
+#    CreatureFamilyFleeAssistanceRadius
+#        Radius which creature will use to seek for a nearby creature
+#         for assistance. Creature will flee to this creature.
+#        Default: 30
+#                 0   - off
+#
+#    CreatureFamilyAssistanceRadius
+#        Radius which creature will use to call assistance without moving
+#        Default: 10
+#                 0   - off
+#
+#    CreatureFamilyAssistanceDelay
+#        Reaction time for creature assistance call
+#        Default: 1500 (1.5s)
+#
+#    CreatureFamilyFleeDelay
+#        Time during which creature can flee when no assistant found
+#        Default: 7000 (7s)
+#
+#    WorldBossLevelDiff
+#        Difference for boss dynamic level with target
+#        Default: 3
+#
+#    Corpse.Decay.NORMAL
+#    Corpse.Decay.RARE
+#    Corpse.Decay.ELITE
+#    Corpse.Decay.RAREELITE
+#    Corpse.Decay.WORLDBOSS
+#        Seconds until creature corpse will decay if not looted or skinned.
+#        Default: 60, 300, 300, 300, 3600
+#
+#    Rate.Corpse.Decay.Looted
+#         Controls how long the creature corpse stays after it had been looted,
+#          as a multiplier of its Corpse.Decay.* config.
+#         Default: 0.5
+#
+#    Rate.Creature.Normal.Damage
+#    Rate.Creature.Elite.Elite.Damage
+#    Rate.Creature.Elite.RAREELITE.Damage
+#    Rate.Creature.Elite.WORLDBOSS.Damage
+#    Rate.Creature.Elite.RARE.Damage
+#        Creature Damage Rates.
+#        Examples: 2 - creatures will damage 2x, 1.7 - 1.7x.
+#
+#    Rate.Creature.Normal.SpellDamage
+#    Rate.Creature.Elite.Elite.SpellDamage
+#    Rate.Creature.Elite.RAREELITE.SpellDamage
+#    Rate.Creature.Elite.WORLDBOSS.SpellDamag
+#    Rate.Creature.Elite.RARE.SpellDamage
+#        Creature Spell Damage Rates.
+#        Examples: 2 - creatures will damage with spells 2x, 1.7 - 1.7x.
+#
+#    Rate.Creature.Normal.HP
+#    Rate.Creature.Elite.Elite.HP
+#    Rate.Creature.Elite.RAREELITE.HP
+#    Rate.Creature.Elite.WORLDBOSS.HP
+#    Rate.Creature.Elite.RARE.HP
+#        Creature Health Ammount Modifier.
+#        Examples: 2 - creatures have 2x health, 1.7 - 1.7x.
+#
+#    ListenRange.Say
+#        Distance from player to listen text that creature
+#         (or other world object) says
+#        Default: 40
+#
+#    ListenRange.TextEmote
+#        Distance from player to listen textemote that creature
+#         (or other world object) says
+#        Default: 40
+#
+#    ListenRange.Yell
+#        Distance from player to listen text that creature
+#         (or other world object) yells
+#        Default: 300
+#
+###############################################################################
+
+ThreatRadius = 60
+Rate.Creature.Aggro = 1
+CreatureFamilyFleeAssistanceRadius = 30
+CreatureFamilyAssistanceRadius = 10
+CreatureFamilyAssistanceDelay = 1500
+CreatureFamilyFleeDelay = 7000
+WorldBossLevelDiff = 3
+Corpse.Decay.NORMAL = 60
+Corpse.Decay.RARE = 300
+Corpse.Decay.ELITE = 300
+Corpse.Decay.RAREELITE = 300
+Corpse.Decay.WORLDBOSS = 3600
+Rate.Corpse.Decay.Looted = 0.5
+Rate.Creature.Normal.Damage = 1
+Rate.Creature.Elite.Elite.Damage = 1
+Rate.Creature.Elite.RAREELITE.Damage = 1
+Rate.Creature.Elite.WORLDBOSS.Damage = 1
+Rate.Creature.Elite.RARE.Damage = 1
+Rate.Creature.Normal.SpellDamage = 1
+Rate.Creature.Elite.Elite.SpellDamage = 1
+Rate.Creature.Elite.RAREELITE.SpellDamage = 1
+Rate.Creature.Elite.WORLDBOSS.SpellDamage = 1
+Rate.Creature.Elite.RARE.SpellDamage = 1
+Rate.Creature.Normal.HP = 1
+Rate.Creature.Elite.Elite.HP = 1
+Rate.Creature.Elite.RAREELITE.HP = 1
+Rate.Creature.Elite.WORLDBOSS.HP = 1
+Rate.Creature.Elite.RARE.HP = 1
+ListenRange.Say = 40
+ListenRange.TextEmote = 40
+ListenRange.Yell = 300
+
+###############################################################################
+# CHAT SETTINGS
+#
+#    ChatFakeMessagePreventing
+#        Chat protection from creating fake messages using a lot spaces
+#         (other invisible symbols),
+#         not applied to addon language messages, but can cause old addons
+#         that use normal languages for sending data to another clients.
+#        Default: 0 (disible fake messages preventing)
+#                 1 (enabled fake messages preventing)
+#
+#    ChatStrictLinkChecking.Severity
+#        Check chat messages for ingame links to
+#         spells, items, quests, achievements etc.
+#        Default: 0 (disable link checking)
+#                 1 (check if only valid pipe commands are used.
+#                    This prevents posting pictures for example)
+#                 2 (verifiy that pipe commands are used in a correct order)
+#                 3 (check if color, entry and name don't contradict
+#                    each other. For correct work, please assure
+#                    that you have extracted locale DBCs of every language
+#                    specific client playing on this server.)
+#
+#    ChatStrictLinkChecking.Kick
+#        Defines what should be done if a message is considered to contain
+#         invalid pipe commands.
+#        Default: 0 (silently ignore message)
+#                 1 (kick players who sent invalid formed messages)
+#
+#    ChatFlood.MessageCount
+#        Chat anti-flood protection, haste message count to activate protection
+#        Default: 10
+#                 0 (disible anti-flood protection)
+#
+#    ChatFlood.MessageDelay
+#        Chat anti-flood protection, minimum message delay to count message
+#        Default: 1 (in secs)
+#
+#    ChatFlood.MuteTime
+#        Chat anti-flood protection, mute time at activation flood protection
+#        Default: 10 (in secs)
+#
+#    Channel.RestrictedLfg
+#        Restrict LookupForGroup channel to registered in LFG tool players
+#        Default: 1 (allow join to channel only if active in LFG)
+#                 0 (allow join to channel in any time)
+#
+#    Channel.SilentlyGMJoin
+#        Silently join GM characters (security level > 1) to channels
+#        Default: 0 (join announcement in normal way)
+#                 1 (GM join without announcement)
+#
+#    ChatLevelReq.Channel
+#        The required level of character to be able to write in chat channels
+#        Default: 1 (From level 1)
+#
+#    ChatLevelReq.Whisper
+#        The required level of character to be able to whisper
+#        Default: 1 (From level 1)
+#
+#    ChatLevelReq.Say
+#        The required level of character to be able to say/yell/emote
+#        Default: 1 (From level 1)
+#
+#    AllowPlayerCommands
+#        Allowed the players to use commands
+#        Default: 1 (allow)
+#
+###############################################################################
+
+ChatFakeMessagePreventing = 0
+ChatStrictLinkChecking.Severity = 0
+ChatStrictLinkChecking.Kick = 0
+ChatFlood.MessageCount = 10
+ChatFlood.MessageDelay = 1
+ChatFlood.MuteTime = 10
+Channel.RestrictedLfg = 1
+Channel.SilentlyGMJoin = 0
+ChatLevelReq.Channel = 1
+ChatLevelReq.Whisper = 1
+ChatLevelReq.Say = 1
+AllowPlayerCommands = 1
+
+###############################################################################
+# GAME MASTER SETTINGS
+#
+#    GM.LoginState
+#        GM mode at login
+#        Default: 2 (last save state)
+#                 0 (disable)
+#                 1 (enable)
+#
+#    GM.Visible
+#        GM visibility at login
+#        Default: 2 (last save state)
+#                 0 (invisible)
+#                 1 (visible)
+#
+#    GM.AcceptTickets
+#        Is GM accepting tickets from player by default or not.
+#        Default: 2 (last save state)
+#                 0 (disable)
+#                 1 (enable)
+#
+#    GM.Chat
+#        GM chat mode at login
+#        Default: 2 (last save state)
+#                 0 (disable)
+#                 1 (enable)
+#
+#    GM.WhisperingTo
+#        Is GM accepting whispers from player by default or not.
+#        Default: 2 (last save state)
+#                 0 (disable)
+#                 1 (enable)
+#
+#    GM.InGMList.Level
+#        Max GM level showed in GM list (if visible) in non-GM state (.gm off)
+#                 0 (only players)
+#                 1 (only moderators)
+#                 2 (only gamemasters)
+#        Default: 3 (anyone)
+#
+#    GM.InWhoList.Level
+#        Max GM level showed in who list (if visible).
+#                 0 (only players)
+#                 1 (only moderators)
+#                 2 (only gamemasters)
+#        Default: 3 (anyone)
+#
+#    GM.LogTrade
+#        Include GM trade and trade slot enchanting operations in GM log
+#        Default: 1 (include)
+#                 0 (not include)
+#
+#    GM.StartLevel
+#        GM starting level (1-100)
+#        Default: 1
+#
+#    GM.AllowInvite
+#        Is GM accepting invites from players by default or not
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    GM.AllowFriend
+#        Are players allowed to add GMs to their friend list
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    GM.LowerSecurity
+#        Disallow a lower security member to interact with
+#         a higher one using commands
+#        Default: 0 (disable)
+#                 1 (enable)
+#
+#    GM.AllowAchievementGain
+#        If enabled it allows gaining achievements for GM characters
+#        Default: 1 (enable)
+#                 0 (disable)
+#
+#    GM.TicketSystem.ChanceOfGMSurvey
+#        Chance of sending a GM survey with every ticket completion.
+#        Default: 50
+#                 0 (disables surveys)
+#
+###############################################################################
+
+GM.LoginState            = 2
+GM.Visible               = 2
+GM.AcceptTickets         = 2
+GM.Chat                  = 2
+GM.WhisperingTo          = 2
+GM.InGMList.Level        = 3
+GM.InWhoList.Level       = 3
+GM.LogTrade              = 1
+GM.StartLevel            = 80
+GM.AllowInvite           = 0
+GM.AllowFriend           = 0
+GM.LowerSecurity         = 0
+GM.AllowAchievementGain  = 1
+GM.TicketSystem.ChanceOfGMSurvey = 50
+
+###############################################################################
+# VISIBILITY AND RADIUSES
+#
+#    Visibility.GroupMode
+#        Group visibility modes
+#        Default: 1 (raid members 100% auto detect invisible player from
+#                    same raid)
+#                 0 (only members from same group can
+#                    100% auto detect invisible player)
+#                 2 (players from same team can 100% auto detect
+#                    invisible player)
+#
+#    Visibility.Distance.Continents
+#    Visibility.Distance.Instances
+#    Visibility.Distance.BGArenas
+#        Visibility distance for different ingame object in different maps.
+#        Visibility on continents on offy ~90 yards. In BG/Arenas ~180.
+#        For instances default ~120.
+#        Max limited by active player zone: ~ 333
+#        Min limit is max aggro radius (45) * Rate.Creature.Aggro
+#
+#    Visibility.Distance.Object
+#        Visible distance for gameobject, dynobject, bodies, corpses, bones
+#        Min limit is iteraction distance (5)
+#
+#    Visibility.Distance.InFlight
+#        Visible distance for player in flight
+#        Min limit is 0 (not show any objects)
+#
+#    Visibility.Distance.Grey.Unit
+#        Visibility grey distance for creatures/players (fast changing objects)
+#         addition to appropriate object type Visibility.Distance.* use in case
+#         visibility removing to object (except corpse around distances)
+#         If D is distance and G is grey distance then object
+#         make visible if distance to it <= D
+#         but make non visible if distance > D+G
+#        Default: 1 (yard)
+#
+#    Visibility.Distance.Grey.Object
+#        Visibility grey distance for dynobjects/gameobjects/corpses/creatures
+#        Default: 10 (yards)
+#
+###############################################################################
+
+Visibility.GroupMode = 1
+Visibility.Distance.Continents = 90
+Visibility.Distance.Instances = 120
+Visibility.Distance.BGArenas = 180
+Visibility.Distance.Object = 100
+Visibility.Distance.InFlight = 100
+Visibility.Distance.Grey.Unit   = 1
+Visibility.Distance.Grey.Object = 10
+
+Visibility.Notify.Period.OnContinents = 1000
+Visibility.Notify.Period.InInstances  = 1000
+Visibility.Notify.Period.InBGArenas   = 1000
+
+###############################################################################
+# SERVER RATES
+#
+#    Rate.Health
+#    Rate.Mana
+#    Rate.Rage.Income
+#    Rate.Rage.Loss
+#    Rate.RunicPower.Income
+#    Rate.RunicPower.Loss
+#    Rate.Focus
+#    Rate.Loyalty
+#        Health and power regeneration and rage income from damage.
+#        Default: 1
+#
+#    Rate.Skill.Discovery
+#        Skill Discovery Rates
+#        Default: 1
+#
+#    Rate.Drop.Item.Poor
+#    Rate.Drop.Item.Normal
+#    Rate.Drop.Item.Uncommon
+#    Rate.Drop.Item.Rare
+#    Rate.Drop.Item.Epic
+#    Rate.Drop.Item.Legendary
+#    Rate.Drop.Item.Artifact
+#    Rate.Drop.Item.Referenced
+#    Rate.Drop.Money
+#        Drop rates (items by quality and money)
+#        Default: 1
+#
+#    Rate.Drop.Item.ReferencedAmount
+#        Multiplier for referenced loot
+#        Default: 1
+#
+#    Rate.Drop.Money
+#        Drop rates
+#        Default: 1
+#
+#    Rate.XP.Kill
+#    Rate.XP.Quest
+#    Rate.XP.Explore
+#        XP rates
+#        Default: 1
+#
+#    Rate.RepairCost
+#        Repair cost rate
+#        Default: 1   - standard cost
+#                 2   - double cost
+#                 0.5 - half cost
+#
+#    Rate.Rest.InGame
+#    Rate.Rest.Offline.InTavernOrCity
+#    Rate.Rest.Offline.InWilderness
+#        Resting points grow rates
+#        Default: 1   - standard rate
+#                 2   - double rate
+#                 0.5 - half rate
+#
+#    Rate.Damage.Fall
+#        Damage after fall rate.
+#        Default: 1   - standard damage
+#                 2   - double damage
+#                 0.5 - half damage
+#
+#    Rate.Auction.Time
+#    Rate.Auction.Deposit
+#    Rate.Auction.Cut
+#        Auction rates
+#         (auction time, deposit get at auction start,
+#         auction cut from price at auction end)
+#
+#    Rate.Honor
+#        Honor gain rate
+#
+#    Rate.Mining.Amount
+#    Rate.Mining.Next
+#        Mining Rates
+#         Mining.Amount changes minimum/maximum use times of a deposit,
+#         Mining.Next changes chance to have next use of a deposit
+#
+#    Rate.Talent
+#        Talent Point rates
+#        Default: 1
+#
+#    Rate.Reputation.Gain
+#        Reputation Gain rate
+#        Default: 1
+#
+#    Rate.Reputation.LowLevel.Kill
+#        Reputation Gain from low level kill (grey creature)
+#        Default: 1
+#
+#    Rate.Reputation.LowLevel.Quest
+#        Reputation Gain rate
+#        Default: 1
+#
+#    Rate.XP.Kill.Premium
+#    Rate.XP.Quest.Premium
+#    Rate.XP.Explore.Premium
+#        XP rates Premium modifier
+#        Default: 1
+#
+#    Rate.Reputation.RecruitAFriendBonus
+#        Reputation bonus amount for recruit-a-friend. 0.1 = 10% bonus.
+#        Default: 0.1 (blizzlike)
+#
+#    Rate.MoveSpeed
+#        Multiply the default movement speed for players
+#         and whatever they're controlling.
+#        Default: 1   - no change
+#                 1.4 - 40% increase
+#
+#    Rate.InstanceResetTime
+#        Multiplier for the number of days in between
+#         global raid/heroic instance resets.
+#        Default: 1
+#
+#    SkillGain.Crafting
+#    SkillGain.Defense
+#    SkillGain.Gathering
+#    SkillGain.Weapon
+#        Crafting/defense/gathering/weapon skills gain at skill grow (1,2,...)
+#        Default: 1
+#
+#    SkillChance.Orange
+#    SkillChance.Yellow
+#    SkillChance.Green
+#    SkillChance.Grey
+#        Skill chance values (0..100)
+#        Default: 100-75-25-0
+#
+#    SkillChance.MiningSteps
+#    SkillChance.SkinningSteps
+#        For skinning and Mining chance decrease with skill level.
+#        Default: 0  - no decrease
+#                 75 - in 2 times each 75 skill points
+#
+#    DurabilityLoss.InPvP
+#        If true, players take durability loss on death in PvP.
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    DurabilityLoss.OnDeath
+#        Durability loss percentage on death
+#        Default: 10 - standard
+#                 20 - double
+#                 5  - half
+#
+#    DurabilityLossChance.Damage
+#        Chance lost one from equiped items durability
+#         point at damage apply or receive.
+#        Default: 0.5 (100/0.5 = 200)
+#         Each 200 damage apply one from 19 possible equipped items
+#
+#    DurabilityLossChance.Absorb
+#         Chance lost one from armor items durability point at damage absorb.
+#         Default: 0.5 (100/0.5 = 200)
+#          Each 200 absorbs apply one from 15 possible armor equipped items
+#
+#    DurabilityLossChance.Parry
+#         Chance lost weapon durability point at parry.
+#         Default: 0.05 (100/0.05 = 2000)
+#          Each 2000 parry attacks main weapon lost point
+#
+#    DurabilityLossChance.Block
+#         Chance lost sheild durability point at damage block.
+#         Default: 0.05 (100/0.05 = 2000)
+#          Each 2000 partly or full blocked attacks shield lost point
+#
+#    Death.SicknessLevel
+#         Starting Character start gain sickness at spirit resurrection (1 min)
+#         Default: 11
+#                  -10 - character will have full time
+#                    (10min) sickness at 1 level
+#                  maxplayerlevel+1
+#                   - character will not have sickess at any level
+#
+#    Death.CorpseReclaimDelay.PvP
+#    Death.CorpseReclaimDelay.PvE
+#         Enabled/disabled increase corpse reclaim delay at PvP/PvE deaths
+#         Default: 1 (enabled)
+#                  0 (disabled)
+#
+#    Death.Bones.World
+#    Death.Bones.BattlegroundOrArena
+#         Enable/disable creating bones instead corpse at resurrection
+#          (in normal zones/instances, or battleground/arenas)
+#         Default: 1 (enabled)
+#                  0 (disabled)
+#
+#    Die.Command.Mode
+#        Switch between two possible .die modes, where mode 1 kills
+#         and does not trigger anything such as loot, and mode 0 does
+#         damage and does trigger things such as loot
+#        Default: 1
+#                  0
+#
+###############################################################################
+
+Rate.Health = 1
+Rate.Mana = 1
+Rate.Rage.Income = 1
+Rate.Rage.Loss = 1
+Rate.RunicPower.Income = 1
+Rate.RunicPower.Loss = 1
+Rate.Focus = 1
+Rate.Loyalty = 1
+Rate.Skill.Discovery = 1
+Rate.Drop.Item.Poor = 1
+Rate.Drop.Item.Normal = 1
+Rate.Drop.Item.Uncommon = 1
+Rate.Drop.Item.Rare = 1
+Rate.Drop.Item.Epic = 1
+Rate.Drop.Item.Legendary = 1
+Rate.Drop.Item.Artifact = 1
+Rate.Drop.Item.Referenced = 1
+Rate.Drop.Item.ReferencedAmount = 1
+Rate.Drop.Money = 1
+Rate.XP.Kill    = 1
+Rate.XP.Quest   = 1
+Rate.XP.Explore = 1
+Rate.XP.Kill.Premium    = 1
+Rate.XP.Quest.Premium   = 1
+Rate.XP.Explore.Premium = 1
+Rate.RepairCost = 1
+Rate.Rest.InGame = 1
+Rate.Rest.Offline.InTavernOrCity = 1
+Rate.Rest.Offline.InWilderness = 1
+Rate.Damage.Fall = 1
+Rate.Auction.Time = 1
+Rate.Auction.Deposit = 1
+Rate.Auction.Cut = 1
+Rate.Honor = 1
+Rate.Mining.Amount = 1
+Rate.Mining.Next   = 1
+Rate.Talent = 1
+Rate.Reputation.Gain = 1
+Rate.Reputation.LowLevel.Kill    = 1
+Rate.Reputation.LowLevel.Quest   = 1
+Rate.Reputation.RecruitAFriendBonus = 0.1
+Rate.MoveSpeed = 1
+Rate.InstanceResetTime = 1
+SkillGain.Crafting = 1
+SkillGain.Defense = 1
+SkillGain.Gathering = 1
+SkillGain.Weapon = 1
+SkillChance.Orange = 100
+SkillChance.Yellow = 75
+SkillChance.Green  = 25
+SkillChance.Grey   = 0
+SkillChance.MiningSteps   = 0
+SkillChance.SkinningSteps = 0
+DurabilityLoss.InPvP = 0
+DurabilityLoss.OnDeath = 10
+DurabilityLossChance.Damage = 0.5
+DurabilityLossChance.Absorb = 0.5
+DurabilityLossChance.Parry  = 0.05
+DurabilityLossChance.Block  = 0.05
+Death.SicknessLevel = 11
+Death.CorpseReclaimDelay.PvP = 1
+Death.CorpseReclaimDelay.PvE = 0
+Death.Bones.World = 1
+Death.Bones.BattlegroundOrArena = 1
+Die.Command.Mode = 1
+
+###############################################################################
+# AUTO BROADCAST
+#
+#    AutoBroadcast.On
+#        Enable auto broadcast
+#        Default: 0 - off
+#                 1 - on
+#
+#    AutoBroadcast.Center
+#        Display method
+#        Default: 0 - announce
+#                 1 - notify
+#                 2 - both
+#
+#    AutoBroadcast.Timer
+#        Timer for auto broadcast (in milliseconds)
+#
+###############################################################################
+
+AutoBroadcast.On = 0
+AutoBroadcast.Center = 0
+AutoBroadcast.Timer = 60000
+
+###############################################################################
+# BATTLEGROUND CONFIG
+#
+#    Battleground.CastDeserter
+#        Cast Deserter spell at player who leave battleground in progress
+#        Default: 1 (enable)
+#                 0 (disable)
+#
+#    Battleground.QueueAnnouncer.Enable
+#        Enable queue announcer posting to chat
+#        Default: 0 (disable)
+#                 1 (enable)
+#
+#    Battleground.QueueAnnouncer.PlayerOnly
+#        Queue announcer type
+#        Default: 0 (system message - all players can see it)
+#                 1 (private - only the queued player can see it)
+#
+#    Battleground.InvitationType
+#        Set Battleground invitation type
+#        Default: 0 (normal - invite as much players to bg as possible,
+#                    don't bother with ballance)
+#                 1 (Experimental - don't allow to invite much more players
+#                    of one faction)
+#
+#    Battleground.PrematureFinishTimer
+#        The time to end the bg if there are less than MinPlayersPerTeam on
+#         one side (in milliseconds)
+#        Default: 300000 (5 minutes)
+#                 0 - disable (not recommended)
+#
+#    BattleGround.PremadeGroupWaitForMatch
+#        The time in which premade group of 1 faction waits in BG Queue
+#         for premade group of other faction
+#        Default: 1800000 (30 minutes)
+#                 0 - disable (not recommended)
+#
+#    Battleground.GiveXPForKills
+#        Give experience for honorable kills in battlegrounds
+#        Default: 0 (disable)
+#                 1 (enable)
+#
+#    Battleground.Random.ResetHour
+#        Reset random battlegrounds at specified hour of the day (0-23)
+#        Default: 6
+#
+###############################################################################
+
+Battleground.CastDeserter = 1
+Battleground.QueueAnnouncer.Enable = 0
+Battleground.QueueAnnouncer.PlayerOnly = 0
+Battleground.InvitationType = 0
+BattleGround.PrematureFinishTimer = 300000
+BattleGround.PremadeGroupWaitForMatch = 1800000
+Battleground.GiveXPForKills = 0
+Battleground.Random.ResetHour = 6
+
+###############################################################################
+# ARENA CONFIG
+#
+#    Arena.MaxRatingDifference
+#        The maximum rating difference between two groups in rated matches
+#        Default: 150 (enable, recommended)
+#                 0 (disable, rating difference is discarded)
+#
+#    Arena.RatingDiscardTimer
+#        After the specified milliseconds has passed,
+#         rating information will be discarded when selecting teams for
+#         matches also initiates an update by this timer
+#        Default: 600000 (10 minutes, recommended)
+#                 0 (disable)
+#
+#    Arena.AutoDistributePoints
+#        Set if arena points should be distributed automatically,
+#         or by GM command
+#        Default: 0 (disable) (recommended):
+#                    use gm command or sql query to distribute the points
+#                 1 (enable)  arena points are distributed automatically
+#
+#    Arena.AutoDistributeInterval
+#        How often should the distribution take place
+#        If automatic distribution is enabled in days
+#        Default: 7 (weekly)
+#
+#    Arena.QueueAnnouncer.Enable
+#        Enable bg queue announcer posting to chat
+#        Default: 0 (disable)
+#                 1 (enable)
+#
+#    Arena.ArenaSeason.ID
+#        Current area season id show in client
+#        Default: 1
+#
+#    Arena.ArenaSeason.InProgress
+#        Current area season state
+#        Default: 1 (active)
+#                 0 (finished)
+#
+#    Arena.ArenaStartRating
+#     Start arena team command rating
+#     Default: 0
+#
+#    Arena.ArenaStartPersonalRating
+#     Start personal rating on entry in team
+#     Default: 0
+#
+#    Arena.ArenaStartMatchmakerRating
+#     Start matchmaker rating for players
+#     Default: 1500
+#
+###############################################################################
+
+Arena.MaxRatingDifference = 150
+Arena.RatingDiscardTimer = 600000
+Arena.AutoDistributePoints = 0
+Arena.AutoDistributeInterval = 7
+Arena.QueueAnnouncer.Enable = 0
+Arena.QueueAnnouncer.PlayerOnly = 0
+Arena.ArenaSeason.ID = 1
+Arena.ArenaSeason.InProgress = 1
+Arena.ArenaStartRating = 0
+Arena.ArenaStartPersonalRating = 0
+Arena.ArenaStartMatchmakerRating = 1500
+
+###############################################################################
+# NETWORK CONFIG
+#
+#    Network.Threads
+#         Number of threads for network,
+#          recommend 1 thread per 1000 connections.
+#         Default: 1
+#
+#    Network.OutKBuff
+#         The size of the output kernel buffer used
+#          ( SO_SNDBUF socket option, tcp manual ).
+#         Default: -1 (Use system default setting)
+#
+#    Network.OutUBuff
+#         Userspace buffer for output.
+#          This is amount of memory reserved per each connection.
+#         Default: 65536
+#
+#    Network.TcpNoDelay:
+#         TCP Nagle algorithm setting
+#         Default: 0 (enable Nagle algorithm, less traffic, more latency)
+#                  1 (TCP_NO_DELAY, disable Nagle algorithm,
+#                     more traffic but less latency)
+#
+###############################################################################
+
+Network.Threads = 1
+Network.OutKBuff = -1
+Network.OutUBuff = 65536
+Network.TcpNodelay = 1
+
+###############################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+#    AuctionHouseBot.DEBUG
+#        Enable/Disable Debugging output
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.DEBUG_FILTERS
+#        Enable/Disable Debugging output from Filters
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableSeller
+#        Enable/Disable the part of AHBot that puts items up for auction
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableBuyer
+#        Enable/Disable the part of AHBot that buys items from players
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.UseBuyPriceForSeller
+#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    AuctionHouseBot.UseBuyPriceForBuyer
+#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number
+#         (in realmd->account table) of the player you want to run
+#         as the auction bot.
+#        AuctionHouseBot.GUID is the GUID (in characters->characters table)
+#         of the player you want to run as the auction bot.
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.ItemsPerCycle
+#        Number of Items to Add/Remove from the AH during mass operations
+#    Default 200
+#
+###############################################################################
+
+AuctionHouseBot.DEBUG = 0
+AuctionHouseBot.DEBUG_FILTERS = 0
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.ItemsPerCycle = 200
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 1
+#
+#    AuctionHouseBot.VendorItems
+#        Include items that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.VendorTradeGoods
+#        Include Trade Goods that can be bought from vendors.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.LootItems
+#        Include items that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.LootTradeGoods
+#        Include Trade Goods that can be looted or fished for.
+#    Default 1 (True)
+#
+#    AuctionHouseBot.OtherItems
+#        Include misc. items.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.OtherTradeGoods
+#        Include misc. Trade Goods.
+#    Default 0 (False)
+#
+#    AuctionHouseBot.Bonding_types
+#        Indicates which bonding types to allow seller to put up for auction
+#            No_Bind
+#             Default 1 (True)
+#            Bind_When_Picked_Up
+#             Default 0 (False)
+#            Bind_When_Equipped
+#             Default 1 (True)
+#            Bind_When_Use
+#             Default 1 (True)
+#            Bind_Quest_Item
+#             Default 0 (False)
+#
+#    AuctionHouseBot.DisableBeta_PTR_Unused
+#        Disable certain items that are usually unavailable to Players
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisablePermEnchant
+#        Disable Items with a Permanent Enchantment
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableConjured
+#        Disable Conjured Items
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableGems
+#        Disable Gems
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoney
+#        Disable Items that are used as money
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableMoneyLoot
+#        Disable Items that have Money as a loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableLootable
+#        Disable Items that have other items as loot
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableKeys
+#        Disable Items that are keys
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableDuration
+#        Disable Items with a duration
+#    Default 0 (False)
+#
+#    AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel
+#        Disable items that are BOP or Quest Item
+#        with a Required level that is less than the Item Level
+#        (This prevents a level 10 with a level 60 weapon or armor)
+#        (May need further refinement)
+#    Default 0 (False)
+#
+###############################################################################
+
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.VendorTradeGoods = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.LootTradeGoods = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.OtherTradeGoods = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.DisableBeta_PTR_Unused = 0
+AuctionHouseBot.DisablePermEnchant = 0
+AuctionHouseBot.DisableConjured = 0
+AuctionHouseBot.DisableGems = 0
+AuctionHouseBot.DisableMoney = 0
+AuctionHouseBot.DisableMoneyLoot = 0
+AuctionHouseBot.DisableLootable = 0
+AuctionHouseBot.DisableKeys = 0
+AuctionHouseBot.DisableDuration = 0
+AuctionHouseBot.DisableBOP_Or_Quest_NoReqLevel = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 2
+#
+#     These Filters are boolean (0 or 1) and will disable items that are
+#     specifically meant for the Class named.
+#     (UnusedClass is Class 10, which was skipped for some reason)
+#     Default 0 (allowed)
+#
+###############################################################################
+
+AuctionHouseBot.DisableWarriorItems = 0
+AuctionHouseBot.DisablePaladinItems = 0
+AuctionHouseBot.DisableHunterItems = 0
+AuctionHouseBot.DisableRogueItems = 0
+AuctionHouseBot.DisablePriestItems = 0
+AuctionHouseBot.DisableDKItems = 0
+AuctionHouseBot.DisableShamanItems = 0
+AuctionHouseBot.DisableMageItems = 0
+AuctionHouseBot.DisableWarlockItems = 0
+AuctionHouseBot.DisableUnusedClassItems = 0
+AuctionHouseBot.DisableDruidItems = 0
+
+###############################################################################
+# AUCTION HOUSE BOT FILTERS PART 3
+#
+#    AuctionHouseBot.DisableItemsBelowLevel
+#        Prevent Seller from listing Items below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveLevel
+#        Prevent Seller from listing Items above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowLevel
+#        Prevent Seller from listing Trade Goods below this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveLevel
+#        Prevent Seller from listing Trade Goods above this Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowGUID
+#        Prevent Seller from listing Items below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveGUID
+#        Prevent Seller from listing Items above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowGUID
+#        Prevent Seller from listing Trade Goods below this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveGUID
+#        Prevent Seller from listing Trade Goods above this GUID
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqLevel
+#        Prevent Seller from listing Items below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqLevel
+#        Prevent Seller from listing Items above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqLevel
+#        Prevent Seller from listing Trade Goods below this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqLevel
+#        Prevent Seller from listing Trade Goods above this Required Level
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsBelowReqSkillRank
+#        Prevent Seller from listing Items below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableItemsAboveReqSkillRank
+#        Prevent Seller from listing Items above this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsBelowReqSkillRank
+#        Prevent Seller from listing Trade Goods below this Required Skill Rank
+#    Default 0 (Off)
+#
+#    AuctionHouseBot.DisableTGsAboveReqSkillRank
+#        Prevent Seller from listing Trade Goods above this Required Skill Rank
+#    Default 0 (Off)
+#
+###############################################################################
+
+AuctionHouseBot.DisableItemsBelowLevel = 0
+AuctionHouseBot.DisableItemsAboveLevel = 0
+AuctionHouseBot.DisableTGsBelowLevel = 0
+AuctionHouseBot.DisableTGsAboveLevel = 0
+AuctionHouseBot.DisableItemsBelowGUID = 0
+AuctionHouseBot.DisableItemsAboveGUID = 0
+AuctionHouseBot.DisableTGsBelowGUID = 0
+AuctionHouseBot.DisableTGsAboveGUID = 0
+AuctionHouseBot.DisableItemsBelowReqLevel = 0
+AuctionHouseBot.DisableItemsAboveReqLevel = 0
+AuctionHouseBot.DisableTGsBelowReqLevel = 0
+AuctionHouseBot.DisableTGsAboveReqLevel = 0
+AuctionHouseBot.DisableItemsBelowReqSkillRank = 0
+AuctionHouseBot.DisableItemsAboveReqSkillRank = 0
+AuctionHouseBot.DisableTGsBelowReqSkillRank = 0
+AuctionHouseBot.DisableTGsAboveReqSkillRank = 0
+
+###############################################################################
+# CONSOLE AND REMOTE ACCESS
+#
+#    Console.Enable
+#        Enable console
+#        Default: 1 - on
+#                 0 - off
+#
+#    Ra.Enable
+#        Enable remote console
+#        Default: 0 - off
+#                 1 - on
+#
+#    Ra.IP
+#        Default remote console ip address, use 0.0.0.0 for every address
+#
+#    Ra.Port
+#        Default remote console port
+#
+#    Ra.MinLevel
+#        Minimum level that's required to login,3 by default
+#
+#    Ra.Secure
+#        Kick client on wrong pass
+#
+#    SOAP.Enable
+#        Enable soap service
+#        Default: 0 - off
+#                 1 - on
+#
+#    SOAP.IP
+#        Bound SOAP service ip address, use 0.0.0.0 to access from everywhere
+#        Default: 127.0.0.1
+#
+#    SOAP.Port
+#        SOAP port
+#        Default: 7878
+#
+###################################################################################################################
+
+Console.Enable = 1
+Ra.Enable = 0
+Ra.IP = 0.0.0.0
+Ra.Port = 3443
+Ra.MinLevel = 3
+Ra.Secure = 1
+SOAP.Enabled = 0
+SOAP.IP = 127.0.0.1
+SOAP.Port = 7878
+
+###################################################################################################################
+#    CharDelete.Method
+#        Character deletion behavior
+#        Default: 0  - Completely remove the character from the database
+#                 1  - Unlinking, the character gets unlinked from the account,
+#                      the name gets freed up and appears as deleted ingame
+#
+#    CharDelete.MinLevel
+#        Character gets deleted by CharDelete.Method=0 when the character
+#        hasn't the specified level yet.
+#        Default: 0  - For all characters the specified mode will be used
+#                 1+ - Only for players which have reached the specified level
+#                      will be deleted by the specified mode.
+#                      the rest will be deleted by CharDelete.Method=0
+#
+#    CharDelete.KeepDays
+#        Define the amount of days for which the characters are kept in the database before
+#        they will be removed
+#        Default: 30
+#                 0  - Don't delete any characters, they stay in the database forever.
+#
+###################################################################################################################
+
+CharDelete.Method = 0
+CharDelete.MinLevel = 0
+CharDelete.KeepDays = 30
+
+###############################################################################
+# MOVEMENT ANTICHEAT
+#
+#    Anticheat.Movement.Enable
+#        Enable Movement Anticheat
+#        Default: 0 - off
+#                 1 - on
+#
+#    Anticheat.Movement.AlarmCount
+#        Count alarms. After AlarmCount is exceeded, actions are taken against
+#        the player. (default 5)
+#
+#    Anticheat.Movement.AlarmTime
+#        Reset alarm-count after this milliseconds. (default 5000)
+#
+#    Anticheat.Movement.Kill
+#        Enable Kill cheater
+#        Default: 0 - off
+#                 1 - on
+#
+#    Anticheat.Movement.Kick
+#        Enable Kick cheater
+#        Default: 0 - off
+#                 1 - on
+#
+#    Anticheat.Movement.BanType
+#        Enable Ban cheater
+#        Default: 0 - off
+#                 1 - Ban Account
+#                 2 - Ban IP
+#                 3 - Ban Account + IP
+#
+#    Anticheat.Movement.BanTime
+#        How long the ban should last.
+#        Default: 1 Minute - 1m
+#
+#    Anticheat.Movement.MaxXYT
+#        Max units a player is allowed to travel per millisecond.
+#        Default: 0.04 (This is ~400% Speed, 0.007 is walk-speed,
+#                 310% is 0.0287)
+#
+#    Anticheat.Movement.IgnoreSecAfterTeleport
+#        After being teleported this number of seconds no cheat is reported.
+#        Default: 10 seconds - 10
+#
+#    Anticheat.Movement.GmLevel
+#        Only accounts that are below this gm-level or exact at the same,
+#        are reported for cheating.
+#        Default: Only normal Players - 0
+#
+###############################################################################
+
+Anticheat.Movement.Enable = 1
+Anticheat.Movement.AlarmCount = 4
+Anticheat.Movement.AlarmTime = 6000
+Anticheat.Movement.Kill = 0
+Anticheat.Movement.Kick = 0
+Anticheat.Movement.BanType = 0
+Anticheat.Movement.BanTime = "1m"
+Anticheat.Movement.MaxXYT = 0.0330
+Anticheat.Movement.IgnoreSecAfterTeleport = 10
+Anticheat.Movement.GmLevel = 1
+
+###############################################################################
+# CUSTOM SERVER OPTIONS
+#
+#    PlayerStart.AllReputation
+#        Players will start with most of the high level reputations that are
+#         needed for items, mounts etc.
+#
+#    PlayerStart.AllSpells
+#        If enabled, players will start with all their class spells
+#         (not talents). Useful for instant 80 servers.
+#        You must populate playercreateinfo_spell_custom table with the spells
+#         you want, or this WILL NOT WORK! The table has data for all
+#         classes / races up to TBC expansion.
+#         Do not enable if you do not know what you are doing!
+#        Default: 0 - off
+#                 1 - on
+#
+#    PlayerStart.MapsExplored
+#        Players will start with all maps explored if enabled
+#
+#    MusicInBattleground
+#        If enabled "L70ETC-Power of the horde" will be played when BG starts
+#
+#    HonorPointsAfterDuel
+#        The amount of honor points the duel winner will get after a duel.
+#        Default: 0 - disable
+#
+#    AlwaysMaxWeaponSkill
+#        Players will automatically gain max weapon/defense skill when
+#         logging in, leveling up etc.
+#
+#    PvPToken.Enable
+#        Enable/disable PvP Token System. Players will get a token
+#         after slaying another player that gives honor.
+#
+#    PvPToken.MapAllowType
+#        Where players can receive the pvp token
+#        4 - In all maps
+#        3 - In battlegrounds only
+#        2 - In FFA areas only (gurubashi arena etc)
+#        1 - In battlegrounds AND FFA areas only
+#
+#    PvPToken.ItemID
+#        The item players will get after killing someone
+#         if PvP Token system is enabled.
+#        Default: 29434 - Badge of justice
+#
+#    PvPToken.ItemCount
+#        Modify the item ID count - Default: 1
+#
+#    NoResetTalentsCost
+#        Enable or disable no cost when reseting talents
+#
+#   Guild.AllowMultipleGuildMaster
+#       Allow override of 1 Guild Master limit. Additional Guild Masters must
+#       be set using the ".guild rank" command, not through the UI
+#       Default: 0 = Only 1 Guild Master per guild
+#                1 = Allow more than one Guild Master
+#
+#   ShowKickInWorld
+#        Determines wether a message is broadcasted to the entire server
+#         when a player gets kicked
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   RecordUpdateTimeDiffInterval
+#        Record update time diff to the log file
+#         update diff can be used as a criterion of performance
+#         diff < 300: good performance
+#         diff > 600: bad performance, may be caused by high cpu usage
+#        Default: 60000 (diff is written into log every 60000 ms or 1 minute.
+#                 >0 = Interval
+#                 0 = Disable
+#
+#   MinRecordUpdateTimeDiff
+#        Only record update time diff which is greater than this value
+#        Default: 10
+#
+#   PlayerStart.String
+#       If set to anything other than "", this string will be displayed
+#        to players when they login to a newly created character.
+#       Default: "" - send no text
+#
+#   LevelReq.Trade
+#        The required level of character to be able to trade
+#        Default: 1 (From level 1)
+#
+#   LevelReq.Ticket
+#        The required level of character to be able to write tickets
+#        Default: 1 (From level 1)
+#
+#   LevelReq.Auction
+#        The required level of character to be able to use auction
+#        Default: 1 (From level 1)
+#
+#   LevelReq.Mail
+#        The required level of character to be able to send and receive mail
+#        Default: 1 (From level 1)
+#
+#   DungeonFinder.Enable
+#        Enable Dungeon Finder system. Will enable dungeon finder and raid finder
+#        Default: 0 - off
+#                 1 - on
+#
+###############################################################################
+
+PlayerStart.AllReputation = 0
+PlayerStart.AllSpells = 0
+PlayerStart.MapsExplored = 0
+MusicInBattleground = 0
+HonorPointsAfterDuel = 0
+AlwaysMaxWeaponSkill = 0
+PvPToken.Enable = 0
+PvPToken.MapAllowType = 4
+PvPToken.ItemID = 29434
+PvPToken.ItemCount = 1
+Guild.AllowMultipleGuildMaster = 0
+NoResetTalentsCost = 0
+ShowKickInWorld = 0
+RecordUpdateTimeDiffInterval = 60000
+MinRecordUpdateTimeDiff = 100
+PlayerStart.String = ""
+LevelReq.Trade = 1
+LevelReq.Ticket = 1
+LevelReq.Auction = 1
+LevelReq.Mail = 1
+DungeonFinder.Enable = 0
+
+#######################################################################
+#   OutdoorPvP.Wintergrasp.Enabled
+#       Determines whether the Wintergrasp battle is enabled or not.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.SaveState.Period
+#      Interval of Save Wintergrasp State Data  to restore it after crash/shutdown/restart
+#      Interval (in milliseconds)
+#      Default (10000 milliseconds)
+#      Warning:  Do not set it less 1 second!
+#
+#   OutdoorPvP.Wintergrasp.StartTime
+#       The start time of the first battle after server starts (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.BattleTime
+#       Time limit of a battle (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.Interval
+#       Interval between battles (in minutes)
+#       Default: 150
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorRewards
+#       Defines whether custom honor rewards should be given to player
+#        for partaking in the Wintergrasp Battle.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleWin
+#       Defines the amount of honor points that should be given to the
+#        team winning the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 3000
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleLose
+#       Defines the amount of honor points that should be given to the
+#        team losing the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1250
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamageTower
+#       Defines the amount of honor points that should be given to the
+#        team for damaging a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower
+#       Defines the amount of honor points that should be given to the
+#        team for destroying a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding
+#       Defines the amount of honor points that should be given to the
+#        team for damaged buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding
+#      Defines the amount of honor points that should be given to the
+#        team for intact buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1500
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Enable
+#		Enable or Disable antifarm system
+#              (Default: 0)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Atk
+#		Min count atack players for antifarm
+#              (Default: 5)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Def
+#		Min count defense players for antifarm
+#              (Default: 5)
+#
+##########################################################
+
+OutdoorPvP.Wintergrasp.Enabled = 1
+OutdoorPvP.Wintergrasp.SaveState.Period = 10000
+OutdoorPvP.Wintergrasp.StartTime = 30
+OutdoorPvP.Wintergrasp.BattleTime = 30
+OutdoorPvP.Wintergrasp.Interval = 150
+OutdoorPvP.Wintergrasp.CustomHonorRewards = 0
+OutdoorPvP.Wintergrasp.CustomHonorBattleWin = 3000
+OutdoorPvP.Wintergrasp.CustomHonorBattleLose = 1250
+OutdoorPvP.Wintergrasp.CustomHonorDamageTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding = 750
+OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding = 1500
+OutdoorPvP.Wintergrasp.Antifarm.Enable = 0
+OutdoorPvP.Wintergrasp.Antifarm.Atk = 5
+OutdoorPvP.Wintergrasp.Antifarm.Def = 5
\ No newline at end of file
