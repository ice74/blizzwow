# HG changeset patch
# User asniker
# Date 1287328014 -21600
# Node ID adcf78646c6ca163f4bf6eba93b8e4b14e927988
# Parent  5c38cc51c3ae750f97d19a50f722501f768599cc
fix sql + fix many warnings + fix vanish + fix many instance

diff --git a/sql/Greedy-core/world/DalaranSewers.sql b/sql/Greedy-core/world/DalaranSewers.sql
--- a/sql/Greedy-core/world/DalaranSewers.sql
+++ b/sql/Greedy-core/world/DalaranSewers.sql
@@ -1,4 +1,4 @@
-UPDATE `world`.`gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192642 LIMIT 1 ;
-UPDATE `world`.`gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192643 LIMIT 1 ;
-UPDATE `world`.`battleground_template` SET `MinPlayersPerTeam` = '0', `MaxPlayersPerTeam` = '2' WHERE `battleground_template`.`id` =10 LIMIT 1 ;
+UPDATE `gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192642 LIMIT 1 ;
+UPDATE `gameobject_template` SET `flags` = '36' WHERE `gameobject_template`.`entry` =192643 LIMIT 1 ;
+UPDATE `battleground_template` SET `MinPlayersPerTeam` = '0', `MaxPlayersPerTeam` = '2' WHERE `battleground_template`.`id` =10 LIMIT 1 ;
 DELETE FROM `disables` WHERE `entry` = 10 ;
diff --git a/sql/Greedy-core/world/IcecrownCitadel.sql b/sql/Greedy-core/world/IcecrownCitadel.sql
--- a/sql/Greedy-core/world/IcecrownCitadel.sql
+++ b/sql/Greedy-core/world/IcecrownCitadel.sql
@@ -1,15 +1,20 @@
-п»їUPDATE `creature_template` SET `ScriptName`='' WHERE `entry` IN (SELECT `id` FROM `creature` WHERE `map` = 631);
+-- Cleanup
+UPDATE `creature_template` SET `ScriptName`='' WHERE `entry` IN (SELECT `id` FROM `creature` WHERE `map` = 631);
 
-# GameObject
+-- GameObject
 UPDATE `gameobject_template` SET `ScriptName` = 'go_icecrown_teleporter' WHERE `entry` IN (202223,202235,202242,202243,202244,202245,202246);
-UPDATE `gameobject_template` SET `flags` = 32 WHERE `entry` IN (202235,202242,202243,202244,202245,202246,202223);
+UPDATE `gameobject_template` SET `flags` = 32 WHERE `entry` IN (202235,202242,202243,202244,202245,202246);
+UPDATE `gameobject_template` SET `flags` = 52 WHERE `entry` = 202223;
 UPDATE `gameobject_template` SET `ScriptName` = '', `data10` = 70308 WHERE `entry` = 201584;
 UPDATE `gameobject` SET `phaseMask` = '1' WHERE `id` IN (202242,202243,202244,202245,202235,202223,202246);
 UPDATE `gameobject` SET `state` = '1' WHERE `id` IN (201614,201613);
 UPDATE `gameobject` SET `state` = '0' WHERE `id` IN (201375);
 
-# Boss
-
+-- Boss
+UPDATE `creature_template` SET `ScriptName`='boss_lord_marrowgar' WHERE `entry` = 36612;
+UPDATE `creature_template` SET `ScriptName`='boss_lady_deathwhisper' WHERE `entry` = 36855;
+UPDATE `creature_template` SET `ScriptName`='boss_saurfang' WHERE `entry` = 37813;
+UPDATE `creature_template` SET `ScriptName`='boss_festergut' WHERE `entry` = 36626;
 UPDATE `creature_template` SET `ScriptName`='boss_rotface' WHERE `entry`= 36627;
 UPDATE `creature_template` SET `ScriptName`='boss_professor_putricide' WHERE `entry` = 36678;
 UPDATE `creature_template` SET `ScriptName`='boss_blood_elf_valanar_icc' WHERE `entry` = 37970;
@@ -20,7 +25,7 @@
 UPDATE `creature_template` SET `ScriptName`='boss_sindragosa' WHERE `entry` = 36853;
 UPDATE `creature_template` SET `ScriptName`='boss_the_lich_king' WHERE `entry` = 36597;
 
-# Mobs
+-- Mobs
 UPDATE `creature_template` SET `ScriptName`='npc_tirion_icc' WHERE `entry`= 38995;
 UPDATE `creature_template` SET `ScriptName`='npc_swarming_shadows' WHERE `entry` = 38163;
 UPDATE `creature_template` SET `ScriptName`='npc_bloodbeast' WHERE `entry` = 38508;
@@ -32,6 +37,7 @@
 UPDATE `creature_template` SET `ScriptName`='npc_ghoul_icc' WHERE `entry` = 37695;
 UPDATE `creature_template` SET `ScriptName`='npc_defile_icc' WHERE `entry` = 38757;
 UPDATE `creature_template` SET `ScriptName`='npc_raging_spirit_icc' WHERE `entry`= 36701;
+UPDATE `creature_template` SET `ScriptName`='npc_vile_spirit_icc' WHERE `entry`= 37799;
 UPDATE `creature_template` SET `ScriptName`='npc_shambling_horror_icc' WHERE `entry` = 37698;
 UPDATE `creature_template` SET `ScriptName`='npc_ooze_little' WHERE `entry`= 36897;
 UPDATE `creature_template` SET `ScriptName`='npc_ooze_big' WHERE `entry`= 36899;
@@ -51,64 +57,6 @@
 UPDATE `creature_template` SET `ScriptName`='npc_frost_bomb' WHERE `entry`= 37186;
 UPDATE `creature_template` SET `ScriptName`='npc_icc_puddle_stalker' WHERE `entry`= 37824;
 UPDATE `creature_template` SET `ScriptName`='npc_abomination' WHERE `entry` = 37672;
-
-UPDATE `creature_template` SET `ScriptName`='' WHERE `entry` IN (SELECT `id` FROM `creature` WHERE `map` = 631);
-
-# GameObject
-UPDATE `gameobject_template` SET `ScriptName` = 'go_icecrown_teleporter' WHERE `entry` IN (202223,202235,202242,202243,202244,202245,202246);
-UPDATE `gameobject_template` SET `flags` = 32 WHERE `entry` IN (202235,202242,202243,202244,202245,202246);
-UPDATE `gameobject_template` SET `flags` = 52 WHERE `entry` = 202223;
-UPDATE `gameobject_template` SET `ScriptName` = '', `data10` = 70308 WHERE `entry` = 201584;
-UPDATE `gameobject` SET `phaseMask` = '1' WHERE `id` IN (202242,202243,202244,202245,202235,202223,202246);
-UPDATE `gameobject` SET `state` = '1' WHERE `id` IN (201614,201613,201375);
-
-# Boss
-UPDATE `creature_template` SET `ScriptName`='boss_lord_marrowgar' WHERE `entry` = 36612;
-UPDATE `creature_template` SET `ScriptName`='boss_lady_deathwhisper' WHERE `entry` = 36855;
-UPDATE `creature_template` SET `ScriptName`='boss_saurfang' WHERE `entry` = 37813;
-UPDATE `creature_template` SET `ScriptName`='boss_festergut' WHERE `entry` = 36626;
-UPDATE `creature_template` SET `ScriptName`='boss_rotface' WHERE `entry`= 36627;
-UPDATE `creature_template` SET `ScriptName`='boss_professor_putricide' WHERE `entry` = 36678;
-UPDATE `creature_template` SET `ScriptName`='boss_blood_elf_valanar_icc' WHERE `entry` = 37970;
-UPDATE `creature_template` SET `ScriptName`='boss_blood_elf_keleset_icc' WHERE `entry` = 37972;
-UPDATE `creature_template` SET `ScriptName`='boss_blood_elf_taldaram_icc' WHERE `entry` = 37973;
-UPDATE `creature_template` SET `ScriptName`='boss_blood_queen_lanathel' WHERE `entry` = 37955;
-UPDATE `creature_template` SET `ScriptName`='boss_valithria' WHERE `entry` = 36789;
-UPDATE `creature_template` SET `ScriptName`='boss_sindragosa' WHERE `entry` = 36853;
-UPDATE `creature_template` SET `ScriptName`='boss_the_lich_king' WHERE `entry` = 36597;
-
-# Mobs
-UPDATE `creature_template` SET `ScriptName`='npc_tirion_icc' WHERE `entry`= 38995;
-UPDATE `creature_template` SET `ScriptName`='npc_swarming_shadows' WHERE `entry` = 38163;
-UPDATE `creature_template` SET `ScriptName`='npc_bloodbeast' WHERE `entry` = 38508;
-UPDATE `creature_template` SET `ScriptName`='npc_cold_flame' WHERE `entry` = 36672;
-UPDATE `creature_template` SET `ScriptName`='npc_bone_spike' WHERE `entry` = 38711;
-UPDATE `creature_template` SET `ScriptName`='npc_volatile_ooze' WHERE `entry` = 37697;
-UPDATE `creature_template` SET `ScriptName`='npc_ice_puls_icc' WHERE `entry` = 36633;
-UPDATE `creature_template` SET `ScriptName`='npc_valkyr_icc' WHERE `entry` = 36609;
-UPDATE `creature_template` SET `ScriptName`='npc_ghoul_icc' WHERE `entry` = 37695;
-UPDATE `creature_template` SET `ScriptName`='npc_defile_icc' WHERE `entry` = 38757;
-UPDATE `creature_template` SET `ScriptName`='npc_raging_spirit_icc' WHERE `entry`= 36701;
-UPDATE `creature_template` SET `ScriptName`='npc_vile_spirit_icc' WHERE `entry`= 37799;
-UPDATE `creature_template` SET `ScriptName`='npc_shambling_horror_icc' WHERE `entry` = 37698;
-UPDATE `creature_template` SET `ScriptName`='npc_ooze_little' WHERE `entry`= 36897;
-UPDATE `creature_template` SET `ScriptName`='npc_ooze_big' WHERE `entry`= 36899;
-UPDATE `creature_template` SET `ScriptName`='npc_shade' WHERE `entry` = 38222;
-UPDATE `creature_template` SET `ScriptName`='npc_skellmage_icc' WHERE `entry` = 37868;
-UPDATE `creature_template` SET `ScriptName`='npc_fireskell_icc' WHERE `entry` = 36791;
-UPDATE `creature_template` SET `ScriptName`='npc_suppressor_icc' WHERE `entry` = 37863;
-UPDATE `creature_template` SET `ScriptName`='npc_manavoid_icc' WHERE `entry` = 38068;
-UPDATE `creature_template` SET `ScriptName`='npc_glutabomination_icc' WHERE `entry` = 37886;
-UPDATE `creature_template` SET `ScriptName`='npc_blistzombie_icc' WHERE `entry` = 37934;
-UPDATE `creature_template` SET `ScriptName`='npc_dreamcloud_icc' WHERE `entry` = 37985;
-UPDATE `creature_template` SET `ScriptName`='npc_dreamportal_icc' WHERE `entry` = 37945;
-UPDATE `creature_template` SET `ScriptName`='npc_cult_fanatic_and_adherent' WHERE `entry` IN (37949,38010,38136,37890,38009,38135);
-UPDATE `creature_template` SET `ScriptName`='npc_rimefang' WHERE `entry`= 37533;
-UPDATE `creature_template` SET `ScriptName`='npc_spinestalker' WHERE `entry`= 37534;
-UPDATE `creature_template` SET `ScriptName`='npc_ice_tomb' WHERE `entry`= 36980;
-UPDATE `creature_template` SET `ScriptName`='npc_frost_bomb' WHERE `entry`= 37186;
-UPDATE `creature_template` SET `ScriptName`='npc_icc_puddle_stalker' WHERE `entry`= 37824;
-UPDATE `creature_template` SET `ScriptName`='npc_abomination' WHERE `entry` = 37672;
 UPDATE `creature_template` SET `ScriptName`='npc_sticky_ooze' WHERE `entry`= 37006;
 UPDATE `creature_template` SET `ScriptName`='npc_ooze_explode_stalker' WHERE `entry` = 38107;
 UPDATE `creature_template` SET `ScriptName`='npc_gas_cloud_icc' WHERE `entry` = 37562;
@@ -118,8 +66,7 @@
 UPDATE `creature_template` SET `ScriptName`='npc_icc_combat_stalker' WHERE `entry` = 38752;
 UPDATE `creature_template` SET `ScriptName`='npc_valithria_alternative' WHERE `entry` = 37950;
 
-
-# Other
+-- Other
 UPDATE `creature_template` SET `minlevel` = 82, `maxlevel` = 82, `faction_A` = 14, `faction_H` = 14, `unit_flags` = 33554434, `type_flags` = 1024 WHERE `entry` = 36672;
 UPDATE `creature_template` SET `minlevel` = 82, `maxlevel` = 82, `faction_A` = 35, `faction_H` = 35 WHERE `entry` = 37950;
 UPDATE `creature_template` SET `minlevel` = 80, `maxlevel` = 80, `faction_A` = 14, `faction_H` = 14, `unit_flags` = 0, type_flags = 0, `VehicleId` = 533 WHERE `entry` IN (36619,38233,38459,38460);
@@ -131,24 +78,24 @@
 UPDATE `creature_model_info` SET `bounding_radius` = 5,`combat_reach` = 5 WHERE `modelid` = 31119;
 UPDATE `creature_template` SET `mechanic_immune_mask` = 634339327 WHERE `entry` IN (36855,38106,38296,38297);
 UPDATE `creature_template` SET `flags_extra` = 2 WHERE `entry` IN (37007,38301);
-UPDATE `creature_template` SET `spell1` = 70360, `spell2` = 70539, `spell3` = 70542, `VehicleId` = 591 WHERE `entry` IN (37672,38605,38786,38787);
+UPDATE `creature_template` SET `faction_A` = 14, `faction_H` = 14, `spell1` = 70360, `spell2` = 70539, `spell3` = 70542, `VehicleId` = 591 WHERE `entry` IN (37672,38605,38786,38787);
 UPDATE `creature_template` SET `dynamicflags` = 8, `npcflag` = 0, `unit_flags` = 32832 WHERE `entry` = 38995;
 UPDATE `creature_template` SET `faction_A` = 14, `faction_H` = 14 WHERE `entry` IN (36899,38123);
 
-# Spell
+-- Spell
 
 DELETE FROM `spell_script_names` WHERE `spell_id` IN(69783,69057,69140,72705,69147,69075,70834,70835,70836,70903,71236);
 
-# Not attackable and disable move flag
+-- Not attackable and disable move flag
 UPDATE `creature_template` SET `unit_flags` = 33555204 WHERE `entry` IN (37986,37824,38234,38317,36659,38548,37186,37006,37918,37690);
 UPDATE `creature_template` SET `unit_flags` = 33587972 WHERE `entry` = 37013;
 UPDATE `creature_template` SET `flags_extra` = 0 WHERE `entry` IN (37986,38234,38317,36659,38548,37186,37013);
 UPDATE `creature_template` SET `flags_extra` = 128 WHERE `entry` = 38234;
 
-# Instance
+-- Instance
 UPDATE `instance_template` SET `script`='instance_icecrown_citadel' WHERE `map` = 631;
 
-# Creature addon template
+-- Creature addon template
 
 DELETE FROM `creature_addon` WHERE `guid` = 136107;
 DELETE FROM `creature_template_addon` WHERE `entry` IN (37690,37672,36659,38186,37945,38429,38430,37918);
@@ -165,10 +112,9 @@
 (38430, 0, 0, 0, 0, 0, '71994 0'),
 (37918, 0, 0, 0, 0, 0, '70715 0');
 
+-- Thanks YTDB
 
-#Thanks YTDB
-
-# Conditions
+-- Conditions
 
 DELETE FROM `conditions` WHERE `SourceEntry` IN (69508,70881,70360,36659,70781,70856,70857,70858,70859,70860,70861);
 DELETE FROM `conditions` WHERE `ConditionValue2` IN (SELECT `id` FROM `creature` WHERE `map` = 631);
@@ -180,7 +126,7 @@
 (13,0,69164,0,18,1,36659,0,0, '', 'Festergut - Gaseous Blight'),
 (13,0,69125,0,18,1,37013,0,0, '', '');
 
-#creature
+-- creature
 
 DELETE FROM `creature` WHERE `id` IN(37813, 37013, 36659);
 INSERT INTO `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `DeathState`, `MovementType`) VALUES
@@ -195,10 +141,10 @@
 (93955,36659,631,15,1,11686,0,4267.87,3137.33,360.469,0,300,0,0,25200,0,0,0),
 (136107,37813,631,15,1,30790,0,-493.905,2211.35,541.114,3.18037,300,0,0,12299490,0,0,0); -- saurfang
 
-#Linked spell
+-- Linked spell
 
 DELETE FROM `spell_linked_spell` WHERE `spell_trigger` = 72202;
-DELETE FROM `spell_linked_spell` WHERE `spell_effect` IN(72202,69166,70347,72380,69706,70311,69291);
+DELETE FROM `spell_linked_spell` WHERE `spell_effect` IN(72202,69166,70347,72380,69706,70702,70311, 69291);
 INSERT INTO `spell_linked_spell` (`spell_trigger`,`spell_effect`,`type`,`comment`) VALUES
 (70360,70347,0,'Eat Ooze'),
 (72379,72380,0,'Blood Nova'),
@@ -222,7 +168,7 @@
 (-70308,70311,0, 'Professor: Abomination call'),
 (-69290,69291,0, 'Festergut: Gaseous spore');
 
-#Linked Respawn
+-- Linked Respawn
 
 DELETE FROM `creature_linked_respawn` WHERE `guid` IN (136104,136105,136107,67608,67614,67901,77641,77642,77643,115558);
 INSERT INTO `creature_linked_respawn` (`guid`,`linkedGuid`) VALUES
@@ -237,30 +183,73 @@
 (77643,77643), -- Prince Valanar
 (115558,115558); -- Blood-Queen Lana'thel
 
-# Npc spell click spell
+-- Npc spell click spell
 
 DELETE FROM `npc_spellclick_spells` WHERE npc_entry IN (37945,38430);
 INSERT INTO `npc_spellclick_spells` (`npc_entry`, `spell_id`, `quest_start`, `quest_start_active`, `quest_end`, `cast_flags`, `aura_required`, `aura_forbidden`, `user_type`) VALUES
 (37945,70766,0,0,0,3,0,0,0),
 (38430,70766,0,0,0,3,0,0,0);
 
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (70107);
+INSERT INTO `spell_proc_event` VALUES (70107, 0x08, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000054, 0x00000000, 0, 20, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (69762);
+INSERT INTO `spell_proc_event` VALUES (69762, 0x00, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00014000, 0x00000000, 0, 101, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72178);
+INSERT INTO `spell_proc_event` VALUES (72178, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00055510, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72176);
+INSERT INTO `spell_proc_event` VALUES (72176, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00051154, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (70602);
+INSERT INTO `spell_proc_event` VALUES (70602, 0x20, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x000AAA20, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (71494);
+INSERT INTO `spell_proc_event` VALUES (71494, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 101, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72176);
+INSERT INTO `spell_proc_event` VALUES (72176, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00051154, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72178);
+INSERT INTO `spell_proc_event` VALUES (72178, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00055510, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (71604);
+INSERT INTO `spell_proc_event` VALUES (71604, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (70001);
+INSERT INTO `spell_proc_event` VALUES (70001, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (71971);
+INSERT INTO `spell_proc_event` VALUES (71971, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72256);
+INSERT INTO `spell_proc_event` VALUES (72256, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72408);
+INSERT INTO `spell_proc_event` VALUES (72408, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+
+DELETE FROM `spell_proc_event` WHERE `entry` IN (72455);
+INSERT INTO `spell_proc_event` VALUES (72455, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000008, 0x00000000, 0, 100, 0);
+
 DELETE FROM script_texts WHERE entry <= -1665902 AND entry >= -1666080;
 DELETE FROM script_texts WHERE entry <= -1810001 AND entry >= -1810031;
 
 # 1
 DELETE FROM script_texts WHERE `npc_entry` = 36612;
 INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
-(36612,-1631000,'This is the beginning AND the end, mortals. None may enter the master''s sanctum!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16950,1,0,0,'SAY_ENTER_ZONE'),
-(36612,-1631001,'The Scourge will wash over this world as a swarm of death and destruction!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16941,1,0,0,'SAY_AGGRO'),
-(36612,-1631002,'BONE STORM!',NULL,NULL, NULL,NULL,NULL,NULL,NULL,NULL,16946,1,0,0,'SAY_BONE_STORM'),
-(36612,-1631003,'Bound by bone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16947,1,0,0, 'SAY_BONESPIKE_1'),
-(36612,-1631004,'Stick Around!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16948,1,0,0,'SAY_BONESPIKE_2'),
-(36612,-1631005,'The only escape is death!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16949,1,0,0,'SAY_BONESPIKE_3'),
-(36612,-1631006,'More bones for the offering!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16942,1,0,0,'SAY_KILL_1'),
-(36612,-1631007,'Languish in damnation!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16943,1,0,0,'SAY_KILL_2'),
-(36612,-1631008,'I see... only darkness...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16944,1,0,0,'SAY_DEATH'),
-(36612,-1631009,'THE MASTER''S RAGE COURSES THROUGH ME!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16945,1,0,0,'SAY_BERSERK'),
-(36612,-1631010,'Lord Marrowgar creates a whirling storm of bone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'SAY_BONE_STORM_EMOTE');
+(36612,-1631000,'This is the beginning AND the end, mortals. None may enter the master''s sanctum!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Смертные, ваш путь закончится так и не начавшись! Никто не смеет входить  в Обитель Господина!',16950,1,0,0,'SAY_ENTER_ZONE'),
+(36612,-1631001,'The Scourge will wash over this world as a swarm of death and destruction!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Плеть накроет этот мир волной смерти и разрушения!',16941,1,0,0,'SAY_AGGRO'),
+(36612,-1631002,'BONE STORM!',NULL,NULL, NULL,NULL,NULL,NULL,NULL,'ВИХРЬ КОСТЕЙ!',16946,1,0,0,'SAY_BONE_STORM'),
+(36612,-1631003,'Bound by bone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Костяная хватка!',16947,1,0,0, 'SAY_BONESPIKE_1'),
+(36612,-1631004,'Stick Around!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Постой-ка тут!',16948,1,0,0,'SAY_BONESPIKE_2'),
+(36612,-1631005,'The only escape is death!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Единственный выход - это СМЕРТЬ!',16949,1,0,0,'SAY_BONESPIKE_3'),
+(36612,-1631006,'More bones for the offering!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Кости, для жертвоприношений!',16942,1,0,0,'SAY_KILL_1'),
+(36612,-1631007,'Languish in damnation!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Сгинь в вечных муках!',16943,1,0,0,'SAY_KILL_2'),
+(36612,-1631008,'I see... only darkness...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Я вижу... лишь тьму',16944,1,0,0,'SAY_DEATH'),
+(36612,-1631009,'THE MASTER''S RAGE COURSES THROUGH ME!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Во мне бушует ярость господина!',16945,1,0,0,'SAY_BERSERK'),
+(36612,-1631010,'Lord Marrowgar creates a whirling storm of bone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,'Лорд Ребрад распадается, и его кости начинают вращаться',0,3,0,0,'SAY_BONE_STORM_EMOTE');
 
 #2
 DELETE FROM `script_texts` WHERE `entry` BETWEEN -1631028 AND -1631011;
@@ -414,7 +403,7 @@
 (36627,-1631101,'I brokes-ded it...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16987,1,0,0,'SAY_KILL_2'),
 (36627,-1631102,'Sleepy Time!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16990,1,0,0,'SAY_BERSERK'),
 (36627,-1631103,'Bad news daddy...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,16989,1,0,0,'SAY_DEATH');
- 
+
 # 7
 INSERT INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
 (36678,-1666026,'Good news, everyone! I think I perfected a plague that will destroy all life on Azeroth!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,17144,1,0,0,''),
@@ -518,232 +507,210 @@
 (-1810030, 'Watch as the world around you collapses!',null,null,null,null,null,null,null,null,17370,1,0,0,''),
 (-1810031, 'You gnats actually hurt me! Perhaps I''ve toyed with you long enough, now taste the vengeance of the grave!',null,null,null,null,null,null,null,null,17359,1,0,0,'');
 
--- Spells
-DELETE FROM `spell_proc_event` WHERE `entry` IN (70107);
-INSERT INTO `spell_proc_event` VALUES (70107, 0x08, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000054, 0x00000000, 0, 20, 0);
+# Locale
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (69762);
-INSERT INTO `spell_proc_event` VALUES (69762, 0x00, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00014000, 0x00000000, 0, 101, 0);
+# Лорд Ребрад
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (72178);
-INSERT INTO `spell_proc_event` VALUES (72178, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00055510, 0x00000000, 0, 100, 0);
+UPDATE `script_texts` SET `content_loc8`='Смертные, ваш путь закончится так и не начавшись! Никто не смеет входить  в Обитель Господина!' WHERE `entry`=-1631000;
+UPDATE `script_texts` SET `content_loc8`='Плеть накроет этот мир волной смерти и разрушения!' WHERE `entry`=-1631001;
+UPDATE `script_texts` SET `content_loc8`='ВИХРЬ КОСТЕЙ!' WHERE `entry`=-1631002;
+UPDATE `script_texts` SET `content_loc8`='Костяная хватка!' WHERE `entry`=-1631003;
+UPDATE `script_texts` SET `content_loc8`='Постой-ка тут!' WHERE `entry`=-1631004;
+UPDATE `script_texts` SET `content_loc8`='Единственный выход - это СМЕРТЬ!' WHERE `entry`=-1631005;
+UPDATE `script_texts` SET `content_loc8`='Кости, для жертвоприношений!' WHERE `entry`=-1631006;
+UPDATE `script_texts` SET `content_loc8`='Сгинь в вечных муках!' WHERE `entry`=-1631007;
+UPDATE `script_texts` SET `content_loc8`='Я вижу... лишь тьму' WHERE `entry`=-1631008;
+UPDATE `script_texts` SET `content_loc8`='Во мне бушует ярость господина!' WHERE `entry`=-1631009;
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (72176);
-INSERT INTO `spell_proc_event` VALUES (72176, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00051154, 0x00000000, 0, 100, 0);
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (70602);
-INSERT INTO `spell_proc_event` VALUES (70602, 0x20, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x000AAA20, 0x00000000, 0, 100, 0);
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (71494);
-INSERT INTO `spell_proc_event` VALUES (71494, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 101, 0);
+# Леди
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (72176);
-INSERT INTO `spell_proc_event` VALUES (72176, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00051154, 0x00000000, 0, 100, 0);
+UPDATE `script_texts` SET `content_loc8`='Вы здесь потому, что наделены особым знанием: вы понимаете, что на мир пало проклятье слепоты!' WHERE `entry`=-1631011;
+UPDATE `script_texts` SET `content_loc8`='Вам удалось сквозь пелену лжи разглядеть источник истиной силы!' WHERE `entry`=-1631012;
+UPDATE `script_texts` SET `content_loc8`='Посмотрите на свои руки, задумайтесь над нелепостью их строения!' WHERE `entry`=-1631013;
+UPDATE `script_texts` SET `content_loc8`='Кожа, мускулы, кровь, что пульсирует в жилах, все это говорит о вашем не совершенстве, вашей слабостью. Создатели жестоко пошутили над вами!' WHERE `entry`=-1631014;
+UPDATE `script_texts` SET `content_loc8`='Чем раньше вы осознаете собственную ущербность, тем скорее выберете иной путь!' WHERE `entry`=-1631015;
+UPDATE `script_texts` SET `content_loc8`='Для нашего господина нет ничего невозможного, его сила не знает границ, ничто не может сломить его волю!' WHERE `entry`=-1631016;
+UPDATE `script_texts` SET `content_loc8`='Тот, кто откажется повиноваться будет уничтожен. Тот же, кто будет служить ему верой и правдой, достигнет таких высот, о которых вы не в силах даже помыслить!' WHERE `entry`=-1631017;
+UPDATE `script_texts` SET `content_loc8`='Как вы смеете ступать в эти священные покои, это место станет вашей могилой!' WHERE `entry`=-1631018;
+UPDATE `script_texts` SET `content_loc8`='Довольно! Пришла пора взять все в свои руки!' WHERE `entry`=-1631019;
+UPDATE `script_texts` SET `content_loc8`='Прими это благословение и покажи чужакам мощь нашего господина!' WHERE `entry`=-1631022;
+UPDATE `script_texts` SET `content_loc8`='Я освобождаю тебя от проклятья плоти, мой верный слуга!' WHERE `entry`=-1631023;
+UPDATE `script_texts` SET `content_loc8`='Восстань и обрети истинную форму!' WHERE `entry`=-1631024;
+UPDATE `script_texts` SET `content_loc8`='Ты не в силах противится моей воле!' WHERE `entry`=-1631021;
+UPDATE `script_texts` SET `content_loc8`='Мне надоел этот фарс!' WHERE `entry`=-1631027;
+UPDATE `script_texts` SET `content_loc8`='На все воля господина...Ваша смерть неизбежна...' WHERE `entry`=-1631028;
+UPDATE `script_texts` SET `content_loc8`='Вы осознали бессмысленность своих действий?' WHERE `entry`=-1631025;
+UPDATE `script_texts` SET `content_loc8`='Ступай во тьму... Вечную тьму!' WHERE `entry`=-1631026;
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (72178);
-INSERT INTO `spell_proc_event` VALUES (72178, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00055510, 0x00000000, 0, 100, 0);
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (71604);
-INSERT INTO `spell_proc_event` VALUES (71604, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+#Бой на кораблях
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (70001);
-INSERT INTO `spell_proc_event` VALUES (70001, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+UPDATE `script_texts` SET `content_loc8`='Благодарю духов, что они послали нам вас. "Усмиритель небес" уже улетел. Быстрее, на борт "Молота Оргрима". Ели вы поспешите, то ещё успеете его нагнать.' WHERE `entry`=-1665919;
+UPDATE `script_texts` SET `content_loc8`='Вот это поможет!' WHERE `entry`=-1665920;
+UPDATE `script_texts` SET `content_loc8`='Ака''Магош, храбрые войны. Солдат Альянса тут очень много.' WHERE `entry`=-1665921;
+UPDATE `script_texts` SET `content_loc8`='Капитан Саурфанг будет рад видеть вас на борту "Молота Оргрима". Мы будем сдерживать Альянс, пока вы не будете готовы к взлету.' WHERE `entry`=-1665922;
+UPDATE `script_texts` SET `content_loc8`='Воспряньте, сыны и дочери Орды! Сегодня мы будем биться со смертельным врагом! ЛОК''ТАР ОГАР!' WHERE `entry`=-1665925;
+UPDATE `script_texts` SET `content_loc8`='Вы видите? Что это там в далеке?' WHERE `entry`=-1665926;
+UPDATE `script_texts` SET `content_loc8`='БОЕВОЙ КОРАБЛЬ АЛЬЯНСА! ВСЕ НА ПАЛУБУ!' WHERE `entry`=-1665927;
+UPDATE `script_texts` SET `content_loc8`='Ружейники, ОГОНЬ!' WHERE `entry`=-1665932;
+UPDATE `script_texts` SET `content_loc8`='Мортирщики, заряжай!' WHERE `entry`=-1665933;
+UPDATE `script_texts` SET `content_loc8`='Пехота, сержанты, в бой!' WHERE `entry`=-16659309;
+UPDATE `script_texts` SET `content_loc8`='Как ты СМЕЕШЬ ступать на мой корабль? Сейчас ты умрешь.' WHERE `entry`=-1665931;
+UPDATE `script_texts` SET `content_loc8`='Двигай свою калошу, не то мы ее прямо в небе взорвем! Орде тут делать нечего!' WHERE `entry`=-1665928;
+UPDATE `script_texts` SET `content_loc8`='Корабль под обстрелом! Заклинателя сюда, пусть заткнет эти пушки!' WHERE `entry`=-1665934;
+UPDATE `script_texts` SET `content_loc8`='Альянс повержен! Вперед, к Королю-личу!' WHERE `entry`=-1665935;
+UPDATE `script_texts` SET `content_loc8`='Ты скоро поймешь, какие у нас тут дела! Кор''крон, уничтожить их!' WHERE `entry`=-1665929;
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (71971);
-INSERT INTO `spell_proc_event` VALUES (71971, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+# Саурфанг
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (72256);
-INSERT INTO `spell_proc_event` VALUES (72256, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
+UPDATE `script_texts` SET `content_loc8`='ВО ИМЯ КОРОЛЯ-ЛИЧА!' WHERE `entry`=-1631045;
+UPDATE `script_texts` SET `content_loc8`='Земля обагрится вашей кровью!' WHERE `entry`=-1631046;
+UPDATE `script_texts` SET `content_loc8`='Веселитесь, слуги мои!' WHERE `entry`=-1631047;
+UPDATE `script_texts` SET `content_loc8`='Ты ничтожество!' WHERE `entry`=-1631048;
+UPDATE `script_texts` SET `content_loc8`='Твоя душа не обретет покоя!' WHERE `entry`=-1631049;
+UPDATE `script_texts` SET `content_loc8`='Я... Cтал СМЕРТЬЮ!' WHERE `entry`=-1631051;
+UPDATE `script_texts` SET `content_loc8`='Я... Освободился.' WHERE `entry`=-1631052;
+UPDATE `script_texts` SET `content_loc8`='Все павшие войны Орды. Все дохлые псы Альянса. Все пополнят Армию Короля-лича. Даже сейчас Валь`киры воскрешают ваших покойников, чтобы те стали частью Плети!' WHERE `entry`=-1631030;
+UPDATE `script_texts` SET `content_loc8`='Сейчас всё будет ещё хуже. Идите сюда, я покажу вам какой силой меня наделил Король-лич!' WHERE `entry`=-1631031;
+UPDATE `script_texts` SET `content_loc8`='Ха-ха-ха! Дворфы...' WHERE `entry`=-1631034;
+UPDATE `script_texts` SET `content_loc8`='Присоеденись ко мне, отец. Перейди на мою сторону, и вместе мы разрушим этот мир во имя Плети и во славу Короля-лича!' WHERE `entry`=-1631037;
+UPDATE `script_texts` SET `content_loc8`='Старый упрямец. У тебя нет шансов! Я сильнее и могущественнее, чем ты можешь представить!' WHERE `entry`=-1631039;
+UPDATE `script_texts` SET `content_loc8`='Жалкий старик! Ну что ж, герои. Хотите узнать, сколь могущественна Плеть?' WHERE `entry`=-1631044;
+UPDATE `script_texts` SET `content_loc8`='Один орк против мощи Альянса?' WHERE `entry`=-1631032;
+UPDATE `script_texts` SET `content_loc8`='Кор''крон, выдвигайтесь! Герои, будьте начеку. Плеть только что...' WHERE `entry`=-1631036;
+UPDATE `script_texts` SET `content_loc8`='Мой мальчик погиб у Врат Гнева. Я здесь, чтобы забрать его тело.' WHERE `entry`=-1631038;
+UPDATE `script_texts` SET `content_loc8`='Мы назвали его Дранош - на орочьем это значит "Сердце Дренора". Я бы не позволил чернокнижникам збрать его. Он был бы в безопасности в Гарадаре под защитой старейшин.' WHERE `entry`=-1631040;
+UPDATE `script_texts` SET `content_loc8`='Я пообещал его матери, когда она умирала, что пройду через Темный Портал один. неважно, умер бы я или выжил - мой сын остался бы цел. И чист...' WHERE `entry`=-1631041;
+UPDATE `script_texts` SET `content_loc8`='Сегодня я исполню это обещание.' WHERE `entry`=-1631042;
+UPDATE `script_texts` SET `content_loc8`='Мы похороним тебя как подобает, в Награнде, рядом с матерью и предками...' WHERE `entry`=-1666002;
+UPDATE `script_texts` SET `content_loc8`='Помните о чести, герои... какой бы жестокой не была битва... никогда не трекайтесь от неё.' WHERE `entry`=-1666003;
+UPDATE `script_texts` SET `content_loc8`='Мурадин защищай палубу, и приготовь солдат к штурму верхних этажей Цитадели. Я вызову из Штормграда подкрепление.' WHERE `entry`=-1665998;
+UPDATE `script_texts` SET `content_loc8`='Отступи, Мурадин. Позволь пройти скорбящему отцу.' WHERE `entry`=-1631063;
+UPDATE `script_texts` SET `content_loc8`='Я... Я не был у Врат Гнева. Но многое узнал от выживших солдат. Твой сын сражался достойно. Он пал смертью героя. И заслуживает погребения с почестями.' WHERE `entry`=-1631068;
+UPDATE `script_texts` SET `content_loc8`='Джайна, почему ты плачешь?' WHERE `entry`=-1631070;
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (72408);
-INSERT INTO `spell_proc_event` VALUES (72408, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0, 100, 0);
 
-DELETE FROM `spell_proc_event` WHERE `entry` IN (72455);
-INSERT INTO `spell_proc_event` VALUES (72455, 0x01, 0x00, 0x00000000, 0x00000000, 0x00000000, 0x00000008, 0x00000000, 0, 100, 0);
+#Эвент Саурфанга(Мурадин, СС, Вариан)
 
--- Translation
+UPDATE `script_texts` SET `content_loc8`='Один орк против мощи Альянса?' WHERE `entry`=-1631032;
+UPDATE `script_texts` SET `content_loc8`='Кор''крон, выдвигайтесь! Герои, будьте начеку. Плеть только что...' WHERE `entry`=-1631036;
+UPDATE `script_texts` SET `content_loc8`='Мой мальчик погиб у Врат Гнева. Я здесь, чтобы забрать его тело.' WHERE `entry`=-1631038;
+UPDATE `script_texts` SET `content_loc8`='Мы назвали его Дранош - на орочьем это значит "Сердце Дренора". Я бы не позволил чернокнижникам збрать его. Он был бы в безопасности в Гарадаре под защитой старейшин.' WHERE `entry`=-1631040;
+UPDATE `script_texts` SET `content_loc8`='Я пообещал его матери, когда она умирала, что пройду через Темный Портал один. неважно, умер бы я или выжил - мой сын остался бы цел. И чист...' WHERE `entry`=-1631041;
+UPDATE `script_texts` SET `content_loc8`='Сегодня я исполню это обещание.' WHERE `entry`=-1631042;
+UPDATE `script_texts` SET `content_loc8`='Мы похороним тебя как подобает, в Награнде, рядом с матерью и предками...' WHERE `entry`=-1666002;
+UPDATE `script_texts` SET `content_loc8`='Помните о чести, герои... какой бы жестокой не была битва... никогда не трекайтесь от неё.' WHERE `entry`=-1666003;
+UPDATE `script_texts` SET `content_loc8`='Мурадин защищай палубу, и приготовь солдат к штурму верхних этажей Цитадели. Я вызову из Штормграда подкрепление.' WHERE `entry`=-1665998;
+UPDATE `script_texts` SET `content_loc8`='Отступи, Мурадин. Позволь пройти скорбящему отцу.' WHERE `entry`=-1631063;
+UPDATE `script_texts` SET `content_loc8`='Я... Я не был у Врат Гнева. Но многое узнал от выживших солдат. Твой сын сражался достойно. Он пал смертью героя. И заслуживает погребения с почестями.' WHERE `entry`=-1631068;
+UPDATE `script_texts` SET `content_loc8`='Джайна, почему ты плачешь?' WHERE `entry`=-1631070;
 
-/*Р›РѕСЂРґ Р РµР±СЂР°Рґ*/
+# Гниломорд
 
-UPDATE `script_texts` SET `content_loc8`='РЎРјРµСЂС‚РЅС‹Рµ, РІР°С€ РїСѓС‚СЊ Р·Р°РєРѕРЅС‡РёС‚СЃСЏ С‚Р°Рє Рё РЅРµ РЅР°С‡Р°РІС€РёСЃСЊ! РќРёРєС‚Рѕ РЅРµ СЃРјРµРµС‚ РІС…РѕРґРёС‚СЊ  РІ РћР±РёС‚РµР»СЊ Р“РѕСЃРїРѕРґРёРЅР°!' WHERE `entry`=-1631000;
-UPDATE `script_texts` SET `content_loc8`='РџР»РµС‚СЊ РЅР°РєСЂРѕРµС‚ СЌС‚РѕС‚ РјРёСЂ РІРѕР»РЅРѕР№ СЃРјРµСЂС‚Рё Рё СЂР°Р·СЂСѓС€РµРЅРёСЏ!' WHERE `entry`=-1631001;
-UPDATE `script_texts` SET `content_loc8`='Р’РРҐР Р¬ РљРћРЎРўР•Р™!' WHERE `entry`=-1631002;
-UPDATE `script_texts` SET `content_loc8`='РљРѕСЃС‚СЏРЅР°СЏ С…РІР°С‚РєР°!' WHERE `entry`=-1631003;
-UPDATE `script_texts` SET `content_loc8`='РџРѕСЃС‚РѕР№-РєР° С‚СѓС‚!' WHERE `entry`=-1631004;
-UPDATE `script_texts` SET `content_loc8`='Р•РґРёРЅСЃС‚РІРµРЅРЅС‹Р№ РІС‹С…РѕРґ - СЌС‚Рѕ РЎРњР•Р РўР¬!' WHERE `entry`=-1631005;
-UPDATE `script_texts` SET `content_loc8`='РљРѕСЃС‚Рё, РґР»СЏ Р¶РµСЂС‚РІРѕРїСЂРёРЅРѕС€РµРЅРёР№!' WHERE `entry`=-1631006;
-UPDATE `script_texts` SET `content_loc8`='РЎРіРёРЅСЊ РІ РІРµС‡РЅС‹С… РјСѓРєР°С…!' WHERE `entry`=-1631007;
-UPDATE `script_texts` SET `content_loc8`='РЇ РІРёР¶Сѓ... Р»РёС€СЊ С‚СЊРјСѓ' WHERE `entry`=-1631008;
-UPDATE `script_texts` SET `content_loc8`='Р’Рѕ РјРЅРµ Р±СѓС€СѓРµС‚ СЏСЂРѕСЃС‚СЊ РіРѕСЃРїРѕРґРёРЅР°!' WHERE `entry`=-1631009;
+UPDATE `script_texts` SET `content_loc8`='Что? Прелесть? Нееееееееееееет!!!' WHERE `entry`=-1631094;
+UPDATE `script_texts` SET `content_loc8`='УУИИИИИИ!' WHERE `entry`=-1631095;
+UPDATE `script_texts` SET `content_loc8`='Отличные новости, народ! Слизь снова потелка!' WHERE `entry`=-1631091;
+UPDATE `script_texts` SET `content_loc8`='Отличные новости, народ! Я починил трубы для подачи ядовитой слизи!' WHERE `entry`=-1631092;
+UPDATE `script_texts` SET `content_loc8`='Папочка сделает новые игрушки из вас!' WHERE `entry`=-1631100;
+UPDATE `script_texts` SET `content_loc8`='Я это заломал...' WHERE `entry`=-1631101;
+UPDATE `script_texts` SET `content_loc8`='Папочка, не огорчайся…' WHERE `entry`=-1631103;
+UPDATE `script_texts` SET `content_loc8`='Я сделал очень злую каку! Сейчас взорвется!' WHERE `entry`=-1631099;
 
+# Тухлопуз
 
-/*Р›РµРґРё РЎРјРµСЂС‚РЅС‹Р№ РЁРµРїРѕС‚*/
+UPDATE `script_texts` SET `content_loc8`='Тухлопуз, ты всегда был моим любимчиком, как и Гниломорд! Молодец, что оставил столько газа. Я его даже чувствую!' WHERE `entry`=-1631090;
+UPDATE `script_texts` SET `content_loc8`='Нет! Вы убили Вонючку! Сейчас получите!' WHERE `entry`=-1631078;
+UPDATE `script_texts` SET `content_loc8`='Повеселимся?' WHERE `entry`=-1631079;
+UPDATE `script_texts` SET `content_loc8`='Что-то мне нехорошо...' WHERE `entry`=-1631083;
+UPDATE `script_texts` SET `content_loc8`='Веселью конец!' WHERE `entry`=-1631088;
+UPDATE `script_texts` SET `content_loc8`='Па-па...' WHERE `entry`=-1631089;
+UPDATE `script_texts` SET `content_loc8`='Мер-твец, мер-твец, мер-твец!' WHERE `entry`=-1631087;
+UPDATE `script_texts` SET `content_loc8`='Папочка! У меня получилось!' WHERE `entry`=-1631086;
+UPDATE `script_texts` SET `content_loc8`='Это обычное облаго газа, только будьте осторожны, не такое уж оно и обычное!' WHERE `entry`=-1631080;
 
-UPDATE `script_texts` SET `content_loc8`='Р’С‹ Р·РґРµСЃСЊ РїРѕС‚РѕРјСѓ, С‡С‚Рѕ РЅР°РґРµР»РµРЅС‹ РѕСЃРѕР±С‹Рј Р·РЅР°РЅРёРµРј: РІС‹ РїРѕРЅРёРјР°РµС‚Рµ, С‡С‚Рѕ РЅР° РјРёСЂ РїР°Р»Рѕ РїСЂРѕРєР»СЏС‚СЊРµ СЃР»РµРїРѕС‚С‹!' WHERE `entry`=-1631011;
-UPDATE `script_texts` SET `content_loc8`='Р’Р°Рј СѓРґР°Р»РѕСЃСЊ СЃРєРІРѕР·СЊ РїРµР»РµРЅСѓ Р»Р¶Рё СЂР°Р·РіР»СЏРґРµС‚СЊ РёСЃС‚РѕС‡РЅРёРє РёСЃС‚РёРЅРѕР№ СЃРёР»С‹!' WHERE `entry`=-1631012;
-UPDATE `script_texts` SET `content_loc8`='РџРѕСЃРјРѕС‚СЂРёС‚Рµ РЅР° СЃРІРѕРё СЂСѓРєРё, Р·Р°РґСѓРјР°Р№С‚РµСЃСЊ РЅР°Рґ РЅРµР»РµРїРѕСЃС‚СЊСЋ РёС… СЃС‚СЂРѕРµРЅРёСЏ!' WHERE `entry`=-1631013;
-UPDATE `script_texts` SET `content_loc8`='РљРѕР¶Р°, РјСѓСЃРєСѓР»С‹, РєСЂРѕРІСЊ, С‡С‚Рѕ РїСѓР»СЊСЃРёСЂСѓРµС‚ РІ Р¶РёР»Р°С…, РІСЃРµ СЌС‚Рѕ РіРѕРІРѕСЂРёС‚ Рѕ РІР°С€РµРј РЅРµСЃРѕРІРµСЂС€РµРЅСЃС‚РІРµ, РІР°С€РµР№ СЃР»Р°Р±РѕСЃС‚Рё. РЎРѕР·РґР°С‚РµР»Рё Р¶РµСЃС‚РѕРєРѕ РїРѕС€СѓС‚РёР»Рё РЅР°Рґ РІР°РјРё!' WHERE `entry`=-1631014;
-UPDATE `script_texts` SET `content_loc8`='Р§РµРј СЂР°РЅСЊС€Рµ РІС‹ РѕСЃРѕР·РЅР°РµС‚Рµ СЃРѕР±СЃС‚РІРµРЅРЅСѓСЋ СѓС‰РµСЂР±РЅРѕСЃС‚СЊ, С‚РµРј СЃРєРѕСЂРµРµ РІС‹Р±РµСЂРµС‚Рµ РёРЅРѕР№ РїСѓС‚СЊ!' WHERE `entry`=-1631015;
-UPDATE `script_texts` SET `content_loc8`='Р”Р»СЏ РЅР°С€РµРіРѕ РіРѕСЃРїРѕРґРёРЅР° РЅРµС‚ РЅРёС‡РµРіРѕ РЅРµРІРѕР·РјРѕР¶РЅРѕРіРѕ, РµРіРѕ СЃРёР»Р° РЅРµ Р·РЅР°РµС‚ РіСЂР°РЅРёС†, РЅРёС‡С‚Рѕ РЅРµ РјРѕР¶РµС‚ СЃР»РѕРјРёС‚СЊ РµРіРѕ РІРѕР»СЋ!' WHERE `entry`=-1631016;
-UPDATE `script_texts` SET `content_loc8`='РўРѕС‚, РєС‚Рѕ РѕС‚РєР°Р¶РµС‚СЃСЏ РїРѕРІРёРЅРѕРІР°С‚СЊСЃСЏ Р±СѓРґРµС‚ СѓРЅРёС‡С‚РѕР¶РµРЅ. РўРѕС‚ Р¶Рµ, РєС‚Рѕ Р±СѓРґРµС‚ СЃР»СѓР¶РёС‚СЊ РµРјСѓ РІРµСЂРѕР№ Рё РїСЂР°РІРґРѕР№, РґРѕСЃС‚РёРіРЅРµС‚ С‚Р°РєРёС… РІС‹СЃРѕС‚, Рѕ РєРѕС‚РѕСЂС‹С… РІС‹ РЅРµ РІ СЃРёР»Р°С… РґР°Р¶Рµ РїРѕРјС‹СЃР»РёС‚СЊ!' WHERE `entry`=-1631017;
-UPDATE `script_texts` SET `content_loc8`='РљР°Рє РІС‹ СЃРјРµРµС‚Рµ СЃС‚СѓРїР°С‚СЊ РІ СЌС‚Рё СЃРІСЏС‰РµРЅРЅС‹Рµ РїРѕРєРѕРё, СЌС‚Рѕ РјРµСЃС‚Рѕ СЃС‚Р°РЅРµС‚ РІР°С€РµР№ РјРѕРіРёР»РѕР№!' WHERE `entry`=-1631018;
-UPDATE `script_texts` SET `content_loc8`='Р”РѕРІРѕР»СЊРЅРѕ! РџСЂРёС€Р»Р° РїРѕСЂР° РІР·СЏС‚СЊ РІСЃРµ РІ СЃРІРѕРё СЂСѓРєРё!' WHERE `entry`=-1631019;
-UPDATE `script_texts` SET `content_loc8`='РџСЂРёРјРё СЌС‚Рѕ Р±Р»Р°РіРѕСЃР»РѕРІРµРЅРёРµ Рё РїРѕРєР°Р¶Рё С‡СѓР¶Р°РєР°Рј РјРѕС‰СЊ РЅР°С€РµРіРѕ РіРѕСЃРїРѕРґРёРЅР°!' WHERE `entry`=-1631022;
-UPDATE `script_texts` SET `content_loc8`='РЇ РѕСЃРІРѕР±РѕР¶РґР°СЋ С‚РµР±СЏ РѕС‚ РїСЂРѕРєР»СЏС‚СЊСЏ РїР»РѕС‚Рё, РјРѕР№ РІРµСЂРЅС‹Р№ СЃР»СѓРіР°!' WHERE `entry`=-1631023;
-UPDATE `script_texts` SET `content_loc8`='Р’РѕСЃСЃС‚Р°РЅСЊ Рё РѕР±СЂРµС‚Рё РёСЃС‚РёРЅРЅСѓСЋ С„РѕСЂРјСѓ!' WHERE `entry`=-1631024;
-UPDATE `script_texts` SET `content_loc8`='РўС‹ РЅРµ РІ СЃРёР»Р°С… РїСЂРѕС‚РёРІРёС‚СЃСЏ РјРѕРµР№ РІРѕР»Рµ!' WHERE `entry`=-1631021;
-UPDATE `script_texts` SET `content_loc8`='РњРЅРµ РЅР°РґРѕРµР» СЌС‚РѕС‚ С„Р°СЂСЃ!' WHERE `entry`=-1631027;
-UPDATE `script_texts` SET `content_loc8`='РќР° РІСЃРµ РІРѕР»СЏ РіРѕСЃРїРѕРґРёРЅР°...Р’Р°С€Р° СЃРјРµСЂС‚СЊ РЅРµРёР·Р±РµР¶РЅР°...' WHERE `entry`=-1631028;
-UPDATE `script_texts` SET `content_loc8`='Р’С‹ РѕСЃРѕР·РЅР°Р»Рё Р±РµСЃСЃРјС‹СЃР»РµРЅРЅРѕСЃС‚СЊ СЃРІРѕРёС… РґРµР№СЃС‚РІРёР№?' WHERE `entry`=-1631025;
-UPDATE `script_texts` SET `content_loc8`='РЎС‚СѓРїР°Р№ РІРѕ С‚СЊРјСѓ... Р’РµС‡РЅСѓСЋ С‚СЊРјСѓ!' WHERE `entry`=-1631026;
+# Профессор Мерзоцоид
 
+UPDATE `script_texts` SET `content_loc8`='Отличные новости, народ! Я усовершенствовал штамм чумы, которая уничтожит весь Азерот!' WHERE `entry`=-1666026;
+UPDATE `script_texts` SET `content_loc8`='Хм, что-то я ничего не чувствую. Что?! Это еще откуда?' WHERE `entry`=-1666029;
+UPDATE `script_texts` SET `content_loc8`='На вкус, как вишенка! ОЙ! Извиниите!' WHERE `entry`=-1666030;
+UPDATE `script_texts` SET `content_loc8`='Плохие новости, народ… Похоже, у меня ничего не выйдет…' WHERE `entry`=-1666034;
+UPDATE `script_texts` SET `content_loc8`='Герои, вы должны мне помочь! Мои силы... на исходе. Залечите мои раны...' WHERE `entry`=-1666063;
+UPDATE `script_texts` SET `content_loc8`='Я открыла портал в Изумруднй Сон. Там вы найдете спасение, герои.' WHERE `entry`=-1666064;
+UPDATE `script_texts` SET `content_loc8`='Силы возвращаются ко мне. Герои, ещё немного!' WHERE `entry`=-1666065;
+UPDATE `script_texts` SET `content_loc8`='Я долго не продержусь!' WHERE `entry`=-1666066;
+UPDATE `script_texts` SET `content_loc8`='Прискорбная потеря...' WHERE `entry`=-1666068;
+UPDATE `script_texts` SET `content_loc8`='Простите меня! Я... не могу... оста... ВСЁ ВО ВЛАСТИ КОШМАРА!' WHERE `entry`=-1666067;
+UPDATE `script_texts` SET `content_loc8`='НЕУДАЧНИКИ!' WHERE `entry`=-16660690;
+UPDATE `script_texts` SET `content_loc8`='Я ИЗЛЕЧИЛАСЬ! Изера, даруй мне силу покончить с этими нечистивыми тварями.' WHERE `entry`=-1666070;
 
-/*Р‘РѕР№ РЅР° РєРѕСЂР°Р±Р»СЏС…*/
 
-UPDATE `script_texts` SET `content_loc8`='Р‘Р»Р°РіРѕРґР°СЂСЋ РґСѓС…РѕРІ, С‡С‚Рѕ РѕРЅРё РїРѕСЃР»Р°Р»Рё РЅР°Рј РІР°СЃ. "РЈСЃРјРёСЂРёС‚РµР»СЊ РЅРµР±РµСЃ" СѓР¶Рµ СѓР»РµС‚РµР». Р‘С‹СЃС‚СЂРµРµ, РЅР° Р±РѕСЂС‚ "РњРѕР»РѕС‚Р° РћСЂРіСЂРёРјР°". Р•Р»Рё РІС‹ РїРѕСЃРїРµС€РёС‚Рµ, С‚Рѕ РµС‰С‘ СѓСЃРїРµРµС‚Рµ РµРіРѕ РЅР°РіРЅР°С‚СЊ.' WHERE `entry`=-1665919;
-UPDATE `script_texts` SET `content_loc8`='Р’РѕС‚ СЌС‚Рѕ РїРѕРјРѕР¶РµС‚!' WHERE `entry`=-1665920;
-UPDATE `script_texts` SET `content_loc8`='РђРєР°''РњР°РіРѕС€, С…СЂР°Р±СЂС‹Рµ РІРѕР№РЅС‹. РЎРѕР»РґР°С‚ РђР»СЊСЏРЅСЃР° С‚СѓС‚ РѕС‡РµРЅСЊ РјРЅРѕРіРѕ.' WHERE `entry`=-1665921;
-UPDATE `script_texts` SET `content_loc8`='РљР°РїРёС‚Р°РЅ РЎР°СѓСЂС„Р°РЅРі Р±СѓРґРµС‚ СЂР°Рґ РІРёРґРµС‚СЊ РІР°СЃ РЅР° Р±РѕСЂС‚Сѓ "РњРѕР»РѕС‚Р° РћСЂРіСЂРёРјР°". РњС‹ Р±СѓРґРµРј СЃРґРµСЂР¶РёРІР°С‚СЊ РђР»СЊСЏРЅСЃ, РїРѕРєР° РІС‹ РЅРµ Р±СѓРґРµС‚Рµ РіРѕС‚РѕРІС‹ Рє РІР·Р»РµС‚Сѓ.' WHERE `entry`=-1665922;
-UPDATE `script_texts` SET `content_loc8`='Р’РѕСЃРїСЂСЏРЅСЊС‚Рµ, СЃС‹РЅС‹ Рё РґРѕС‡РµСЂРё РћСЂРґС‹! РЎРµРіРѕРґРЅСЏ РјС‹ Р±СѓРґРµРј Р±РёС‚СЊСЃСЏ СЃРѕ СЃРјРµСЂС‚РµР»СЊРЅС‹Рј РІСЂР°РіРѕРј! Р›РћРљ''РўРђР  РћР“РђР !' WHERE `entry`=-1665925;
-UPDATE `script_texts` SET `content_loc8`='Р’С‹ РІРёРґРёС‚Рµ? Р§С‚Рѕ СЌС‚Рѕ С‚Р°Рј РІ РґР°Р»РµРєРµ?' WHERE `entry`=-1665926;
-UPDATE `script_texts` SET `content_loc8`='Р‘РћР•Р’РћР™ РљРћР РђР‘Р›Р¬ РђР›Р¬РЇРќРЎРђ! Р’РЎР• РќРђ РџРђР›РЈР‘РЈ!' WHERE `entry`=-1665927;
-UPDATE `script_texts` SET `content_loc8`='Р СѓР¶РµР№РЅРёРєРё, РћР“РћРќР¬!' WHERE `entry`=-1665932;
-UPDATE `script_texts` SET `content_loc8`='РњРѕСЂС‚РёСЂС‰РёРєРё, Р·Р°СЂСЏР¶Р°Р№!' WHERE `entry`=-1665933;
-UPDATE `script_texts` SET `content_loc8`='РџРµС…РѕС‚Р°, СЃРµСЂР¶Р°РЅС‚С‹, РІ Р±РѕР№!' WHERE `entry`=-16659309;
-UPDATE `script_texts` SET `content_loc8`='РљР°Рє С‚С‹ РЎРњР•Р•РЁР¬ СЃС‚СѓРїР°С‚СЊ РЅР° РјРѕР№ РєРѕСЂР°Р±Р»СЊ? РЎРµР№С‡Р°СЃ С‚С‹ СѓРјСЂРµС€СЊ.' WHERE `entry`=-1665931;
-UPDATE `script_texts` SET `content_loc8`='Р”РІРёРіР°Р№ СЃРІРѕСЋ РєР°Р»РѕС€Сѓ, РЅРµ С‚Рѕ РјС‹ РµРµ РїСЂСЏРјРѕ РІ РЅРµР±Рµ РІР·РѕСЂРІРµРј! РћСЂРґРµ С‚СѓС‚ РґРµР»Р°С‚СЊ РЅРµС‡РµРіРѕ!' WHERE `entry`=-1665928;
-UPDATE `script_texts` SET `content_loc8`='РљРѕСЂР°Р±Р»СЊ РїРѕРґ РѕР±СЃС‚СЂРµР»РѕРј! Р—Р°РєР»РёРЅР°С‚РµР»СЏ СЃСЋРґР°, РїСѓСЃС‚СЊ Р·Р°С‚РєРЅРµС‚ СЌС‚Рё РїСѓС€РєРё!' WHERE `entry`=-1665934;
-UPDATE `script_texts` SET `content_loc8`='РђР»СЊСЏРЅСЃ РїРѕРІРµСЂР¶РµРЅ! Р’РїРµСЂРµРґ, Рє РљРѕСЂРѕР»СЋ-Р»РёС‡Сѓ!' WHERE `entry`=-1665935;
-UPDATE `script_texts` SET `content_loc8`='РўС‹ СЃРєРѕСЂРѕ РїРѕР№РјРµС€СЊ, РєР°РєРёРµ Сѓ РЅР°СЃ С‚СѓС‚ РґРµР»Р°! РљРѕСЂ''РєСЂРѕРЅ, СѓРЅРёС‡С‚РѕР¶РёС‚СЊ РёС…!' WHERE `entry`=-1665929;
+#Кровавый Совет
 
-/*РЎР°СѓСЂС„Р°РЅРі РЎРјРµСЂС‚РѕРЅРѕСЃРЅС‹Р№*/
+UPDATE `script_texts` SET `content_loc8`='Глупые смертные. Думали, что одолели нас? Сан''лейн - непобедимые воины Короля-лича. Теперь наши силы едины!' WHERE `entry`=-1666035;
+UPDATE `script_texts` SET `content_loc8`='Восстаньте, братья, и уничтожьте наших врагов!' WHERE `entry`=-1666036;
+UPDATE `script_texts` SET `content_loc8`='Наксанар был досадным недоразумением! Сила Сферы позволит Валанару свершить отмщение!' WHERE `entry`=-1666049;
+UPDATE `script_texts` SET `content_loc8`='И прольется кровь!' WHERE `entry`=-1666038;
+UPDATE `script_texts` SET `content_loc8`='Пища для червей.' WHERE `entry`=-1666045;
 
-UPDATE `script_texts` SET `content_loc8`='Р’Рћ РРњРЇ РљРћР РћР›РЇ-Р›РР§Рђ!' WHERE `entry`=-1631045;
-UPDATE `script_texts` SET `content_loc8`='Р—РµРјР»СЏ РѕР±Р°РіСЂРёС‚СЃСЏ РІР°С€РµР№ РєСЂРѕРІСЊСЋ!' WHERE `entry`=-1631046;
-UPDATE `script_texts` SET `content_loc8`='Р’РµСЃРµР»РёС‚РµСЃСЊ, СЃР»СѓРіРё РјРѕРё!' WHERE `entry`=-1631047;
-UPDATE `script_texts` SET `content_loc8`='РўС‹ РЅРёС‡С‚РѕР¶РµСЃС‚РІРѕ!' WHERE `entry`=-1631048;
-UPDATE `script_texts` SET `content_loc8`='РўРІРѕСЏ РґСѓС€Р° РЅРµ РѕР±СЂРµС‚РµС‚ РїРѕРєРѕСЏ!' WHERE `entry`=-1631049;
-UPDATE `script_texts` SET `content_loc8`='РЇ... CС‚Р°Р» РЎРњР•Р РўР¬Р®!' WHERE `entry`=-1631051;
-UPDATE `script_texts` SET `content_loc8`='РЇ... РћСЃРІРѕР±РѕРґРёР»СЃСЏ.' WHERE `entry`=-1631052;
-UPDATE `script_texts` SET `content_loc8`='Р’СЃРµ РїР°РІС€РёРµ РІРѕР№РЅС‹ РћСЂРґС‹. Р’СЃРµ РґРѕС…Р»С‹Рµ РїСЃС‹ РђР»СЊСЏРЅСЃР°. Р’СЃРµ РїРѕРїРѕР»РЅСЏС‚ РђСЂРјРёСЋ РљРѕСЂРѕР»СЏ-Р»РёС‡Р°. Р”Р°Р¶Рµ СЃРµР№С‡Р°СЃ Р’Р°Р»СЊ`РєРёСЂС‹ РІРѕСЃРєСЂРµС€Р°СЋС‚ РІР°С€РёС… РїРѕРєРѕР№РЅРёРєРѕРІ, С‡С‚РѕР±С‹ С‚Рµ СЃС‚Р°Р»Рё С‡Р°СЃС‚СЊСЋ РџР»РµС‚Рё!' WHERE `entry`=-1631030;
-UPDATE `script_texts` SET `content_loc8`='РЎРµР№С‡Р°СЃ РІСЃС‘ Р±СѓРґРµС‚ РµС‰С‘ С…СѓР¶Рµ. РРґРёС‚Рµ СЃСЋРґР°, СЏ РїРѕРєР°Р¶Сѓ РІР°Рј РєР°РєРѕР№ СЃРёР»РѕР№ РјРµРЅСЏ РЅР°РґРµР»РёР» РљРѕСЂРѕР»СЊ-Р»РёС‡!' WHERE `entry`=-1631031;
-UPDATE `script_texts` SET `content_loc8`='РҐР°-С…Р°-С…Р°! Р”РІРѕСЂС„С‹...' WHERE `entry`=-1631034;
-UPDATE `script_texts` SET `content_loc8`='РџСЂРёСЃРѕРµРґРёРЅРёСЃСЊ РєРѕ РјРЅРµ, РѕС‚РµС†. РџРµСЂРµР№РґРё РЅР° РјРѕСЋ СЃС‚РѕСЂРѕРЅСѓ, Рё РІРјРµСЃС‚Рµ РјС‹ СЂР°Р·СЂСѓС€РёРј СЌС‚РѕС‚ РјРёСЂ РІРѕ РёРјСЏ РџР»РµС‚Рё Рё РІРѕ СЃР»Р°РІСѓ РљРѕСЂРѕР»СЏ-Р»РёС‡Р°!' WHERE `entry`=-1631037;
-UPDATE `script_texts` SET `content_loc8`='РЎС‚Р°СЂС‹Р№ СѓРїСЂСЏРјРµС†. РЈ С‚РµР±СЏ РЅРµС‚ С€Р°РЅСЃРѕРІ! РЇ СЃРёР»СЊРЅРµРµ Рё РјРѕРіСѓС‰РµСЃС‚РІРµРЅРЅРµРµ, С‡РµРј С‚С‹ РјРѕР¶РµС€СЊ РїСЂРµРґСЃС‚Р°РІРёС‚СЊ!' WHERE `entry`=-1631039;
-UPDATE `script_texts` SET `content_loc8`='Р–Р°Р»РєРёР№ СЃС‚Р°СЂРёРє! РќСѓ С‡С‚Рѕ Р¶, РіРµСЂРѕРё. РҐРѕС‚РёС‚Рµ СѓР·РЅР°С‚СЊ, СЃРєРѕР»СЊ РјРѕРіСѓС‰РµСЃС‚РІРµРЅРЅР° РџР»РµС‚СЊ?' WHERE `entry`=-1631044;
 
-/*Р­РІРµРЅС‚ РЎР°СѓСЂС„Р°РЅРіР°(РњСѓСЂР°РґРёРЅ, РЎРЎ, Р’Р°СЂРёР°РЅ)*/
+#Валитрия
 
-UPDATE `script_texts` SET `content_loc8`='РћРґРёРЅ РѕСЂРє РїСЂРѕС‚РёРІ РјРѕС‰Рё РђР»СЊСЏРЅСЃР°?' WHERE `entry`=-1631032;
-UPDATE `script_texts` SET `content_loc8`='РљРѕСЂ''РєСЂРѕРЅ, РІС‹РґРІРёРіР°Р№С‚РµСЃСЊ! Р“РµСЂРѕРё, Р±СѓРґСЊС‚Рµ РЅР°С‡РµРєСѓ. РџР»РµС‚СЊ С‚РѕР»СЊРєРѕ С‡С‚Рѕ...' WHERE `entry`=-1631036;
-UPDATE `script_texts` SET `content_loc8`='РњРѕР№ РјР°Р»СЊС‡РёРє РїРѕРіРёР± Сѓ Р’СЂР°С‚ Р“РЅРµРІР°. РЇ Р·РґРµСЃСЊ, С‡С‚РѕР±С‹ Р·Р°Р±СЂР°С‚СЊ РµРіРѕ С‚РµР»Рѕ.' WHERE `entry`=-1631038;
-UPDATE `script_texts` SET `content_loc8`='РњС‹ РЅР°Р·РІР°Р»Рё РµРіРѕ Р”СЂР°РЅРѕС€ - РЅР° РѕСЂРѕС‡СЊРµРј СЌС‚Рѕ Р·РЅР°С‡РёС‚ "РЎРµСЂРґС†Рµ Р”СЂРµРЅРѕСЂР°". РЇ Р±С‹ РЅРµ РїРѕР·РІРѕР»РёР» С‡РµСЂРЅРѕРєРЅРёР¶РЅРёРєР°Рј Р·Р±СЂР°С‚СЊ РµРіРѕ. РћРЅ Р±С‹Р» Р±С‹ РІ Р±РµР·РѕРїР°СЃРЅРѕСЃС‚Рё РІ Р“Р°СЂР°РґР°СЂРµ РїРѕРґ Р·Р°С‰РёС‚РѕР№ СЃС‚Р°СЂРµР№С€РёРЅ.' WHERE `entry`=-1631040;
-UPDATE `script_texts` SET `content_loc8`='РЇ РїРѕРѕР±РµС‰Р°Р» РµРіРѕ РјР°С‚РµСЂРё, РєРѕРіРґР° РѕРЅР° СѓРјРёСЂР°Р»Р°, С‡С‚Рѕ РїСЂРѕР№РґСѓ С‡РµСЂРµР· РўРµРјРЅС‹Р№ РџРѕСЂС‚Р°Р» РѕРґРёРЅ. РЅРµРІР°Р¶РЅРѕ, СѓРјРµСЂ Р±С‹ СЏ РёР»Рё РІС‹Р¶РёР» - РјРѕР№ СЃС‹РЅ РѕСЃС‚Р°Р»СЃСЏ Р±С‹ С†РµР». Р С‡РёСЃС‚...' WHERE `entry`=-1631041;
-UPDATE `script_texts` SET `content_loc8`='РЎРµРіРѕРґРЅСЏ СЏ РёСЃРїРѕР»РЅСЋ СЌС‚Рѕ РѕР±РµС‰Р°РЅРёРµ.' WHERE `entry`=-1631042;
-UPDATE `script_texts` SET `content_loc8`='РњС‹ РїРѕС…РѕСЂРѕРЅРёРј С‚РµР±СЏ РєР°Рє РїРѕРґРѕР±Р°РµС‚, РІ РќР°РіСЂР°РЅРґРµ, СЂСЏРґРѕРј СЃ РјР°С‚РµСЂСЊСЋ Рё РїСЂРµРґРєР°РјРё...' WHERE `entry`=-1666002;
-UPDATE `script_texts` SET `content_loc8`='РџРѕРјРЅРёС‚Рµ Рѕ С‡РµСЃС‚Рё, РіРµСЂРѕРё... РєР°РєРѕР№ Р±С‹ Р¶РµСЃС‚РѕРєРѕР№ РЅРµ Р±С‹Р»Р° Р±РёС‚РІР°... РЅРёРєРѕРіРґР° РЅРµ С‚СЂРµРєР°Р№С‚РµСЃСЊ РѕС‚ РЅРµС‘.' WHERE `entry`=-1666003;
-UPDATE `script_texts` SET `content_loc8`='РњСѓСЂР°РґРёРЅ Р·Р°С‰РёС‰Р°Р№ РїР°Р»СѓР±Сѓ, Рё РїСЂРёРіРѕС‚РѕРІСЊ СЃРѕР»РґР°С‚ Рє С€С‚СѓСЂРјСѓ РІРµСЂС…РЅРёС… СЌС‚Р°Р¶РµР№ Р¦РёС‚Р°РґРµР»Рё. РЇ РІС‹Р·РѕРІСѓ РёР· РЁС‚РѕСЂРјРіСЂР°РґР° РїРѕРґРєСЂРµРїР»РµРЅРёРµ.' WHERE `entry`=-1665998;
-UPDATE `script_texts` SET `content_loc8`='РћС‚СЃС‚СѓРїРё, РњСѓСЂР°РґРёРЅ. РџРѕР·РІРѕР»СЊ РїСЂРѕР№С‚Рё СЃРєРѕСЂР±СЏС‰РµРјСѓ РѕС‚С†Сѓ.' WHERE `entry`=-1631063;
-UPDATE `script_texts` SET `content_loc8`='РЇ... РЇ РЅРµ Р±С‹Р» Сѓ Р’СЂР°С‚ Р“РЅРµРІР°. РќРѕ РјРЅРѕРіРѕРµ СѓР·РЅР°Р» РѕС‚ РІС‹Р¶РёРІС€РёС… СЃРѕР»РґР°С‚. РўРІРѕР№ СЃС‹РЅ СЃСЂР°Р¶Р°Р»СЃСЏ РґРѕСЃС‚РѕР№РЅРѕ. РћРЅ РїР°Р» СЃРјРµСЂС‚СЊСЋ РіРµСЂРѕСЏ. Р Р·Р°СЃР»СѓР¶РёРІР°РµС‚ РїРѕРіСЂРµР±РµРЅРёСЏ СЃ РїРѕС‡РµСЃС‚СЏРјРё.' WHERE `entry`=-1631068;
-UPDATE `script_texts` SET `content_loc8`='Р”Р¶Р°Р№РЅР°, РїРѕС‡РµРјСѓ С‚С‹ РїР»Р°С‡РµС€СЊ?' WHERE `entry`=-1631070;
+UPDATE `script_texts` SET `content_loc8`='Герои, вы должны мне помочь! Мои силы... на исходе. Залечите мои раны...' WHERE `entry`=-1666063;
+UPDATE `script_texts` SET `content_loc8`='Я открыла портал в Изумрудный Сон. Там вы найдете спасение, герои.' WHERE `entry`=-1666064;
+UPDATE `script_texts` SET `content_loc8`='Силы возвращаются ко мне. Герои, ещё немного!' WHERE `entry`=-1666065;
+UPDATE `script_texts` SET `content_loc8`='Я долго не продержусь!' WHERE `entry`=-1666066;
+UPDATE `script_texts` SET `content_loc8`='Прискорбная потеря...' WHERE `entry`=-1666068;
+UPDATE `script_texts` SET `content_loc8`='Простите меня! Я... не могу... оста... ВСЁ ВО ВЛАСТИ КОШМАРА!' WHERE `entry`=-1666067;
+UPDATE `script_texts` SET `content_loc8`='НЕУДАЧНИКИ!' WHERE `entry`=-16660690;
+UPDATE `script_texts` SET `content_loc8`='Я ИЗЛЕЧИЛАСЬ! Изера, даруй мне силу покончить с этими нечистивыми тварями.' WHERE `entry`=-1666070;
 
 
-/*Р“РЅРёР»РѕРјРѕСЂРґ*/
 
-UPDATE `script_texts` SET `content_loc8`='Р§С‚Рѕ? РџСЂРµР»РµСЃС‚СЊ? РќРµРµРµРµРµРµРµРµРµРµРµРµРµС‚!!!' WHERE `entry`=-1631094;
-UPDATE `script_texts` SET `content_loc8`='РЈРЈРРРРРР!' WHERE `entry`=-1631095;
-UPDATE `script_texts` SET `content_loc8`='РћС‚Р»РёС‡РЅС‹Рµ РЅРѕРІРѕСЃС‚Рё, РЅР°СЂРѕРґ! РЎР»РёР·СЊ СЃРЅРѕРІР° РїРѕС‚РµРєР»Р°!' WHERE `entry`=-1631091;
-UPDATE `script_texts` SET `content_loc8`='РћС‚Р»РёС‡РЅС‹Рµ РЅРѕРІРѕСЃС‚Рё, РЅР°СЂРѕРґ! РЇ РїРѕС‡РёРЅРёР» С‚СЂСѓР±С‹ РґР»СЏ РїРѕРґР°С‡Рё СЏРґРѕРІРёС‚РѕР№ СЃР»РёР·Рё!' WHERE `entry`=-1631092;
-UPDATE `script_texts` SET `content_loc8`='РџР°РїРѕС‡РєР° СЃРґРµР»Р°РµС‚ РЅРѕРІС‹Рµ РёРіСЂСѓС€РєРё РёР· РІР°СЃ!' WHERE `entry`=-1631100;
-UPDATE `script_texts` SET `content_loc8`='РЇ СЌС‚Рѕ Р·Р°Р»РѕРјР°Р»...' WHERE `entry`=-1631101;
-UPDATE `script_texts` SET `content_loc8`='РџР°РїРѕС‡РєР°, РЅРµ РѕРіРѕСЂС‡Р°Р№СЃСЏвЂ¦' WHERE `entry`=-1631103;
-UPDATE `script_texts` SET `content_loc8`='РЇ СЃРґРµР»Р°Р» РѕС‡РµРЅСЊ Р·Р»СѓСЋ РєР°РєСѓ! РЎРµР№С‡Р°СЃ РІР·РѕСЂРІРµС‚СЃСЏ!' WHERE `entry`=-1631099;
+# Синдрагоса
 
-/*РўСѓС…Р»РѕРїСѓР·*/
+UPDATE `script_texts` SET `content_loc8`='Глупцы, зачем вы сюда явились! Ледяные ветра Нордскола унесут ваши души!' WHERE `entry`=-1666071;
+UPDATE `script_texts` SET `content_loc8`='Трепещите, смертные, ибо ваша жалкая магия теперь бессильна!' WHERE `entry`=-1666072;
+UPDATE `script_texts` SET `content_loc8`='Вы чувствуете?' WHERE `entry`=-1666073;
+UPDATE `script_texts` SET `content_loc8`='Ааах! Жжется! Что это за магия?!' WHERE `entry`=-1666074;
+UPDATE `script_texts` SET `content_loc8`='Сейчас вы почуствуете всю мощь нашего господина!' WHERE `entry`=-1666076;
+UPDATE `script_texts` SET `content_loc8`='Погибни!' WHERE `entry`=-1666077;
+UPDATE `script_texts` SET `content_loc8`='Удел смертных...' WHERE `entry`=-1666078;
+UPDATE `script_texts` SET `content_loc8`='Довольно! Я устала от этих игр!' WHERE `entry`=-1666079;
+UPDATE `script_texts` SET `content_loc8`='Наконец-то...свободна...' WHERE `entry`=-1666080;
 
-UPDATE `script_texts` SET `content_loc8`='РўСѓС…Р»РѕРїСѓР·, С‚С‹ РІСЃРµРіРґР° Р±С‹Р» РјРѕРёРј Р»СЋР±РёРјС‡РёРєРѕРј, РєР°Рє Рё Р“РЅРёР»РѕРјРѕСЂРґ! РњРѕР»РѕРґРµС†, С‡С‚Рѕ РѕСЃС‚Р°РІРёР» СЃС‚РѕР»СЊРєРѕ РіР°Р·Р°. РЇ РµРіРѕ РґР°Р¶Рµ С‡СѓРІСЃС‚РІСѓСЋ!' WHERE `entry`=-1631090;
-UPDATE `script_texts` SET `content_loc8`='РќРµС‚! Р’С‹ СѓР±РёР»Рё Р’РѕРЅСЋС‡РєСѓ! РЎРµР№С‡Р°СЃ РїРѕР»СѓС‡РёС‚Рµ!' WHERE `entry`=-1631078;
-UPDATE `script_texts` SET `content_loc8`='РџРѕРІРµСЃРµР»РёРјСЃСЏ?' WHERE `entry`=-1631079;
-UPDATE `script_texts` SET `content_loc8`='Р§С‚Рѕ-С‚Рѕ РјРЅРµ РЅРµС…РѕСЂРѕС€Рѕ...' WHERE `entry`=-1631083;
-UPDATE `script_texts` SET `content_loc8`='Р’РµСЃРµР»СЊСЋ РєРѕРЅРµС†!' WHERE `entry`=-1631088;
-UPDATE `script_texts` SET `content_loc8`='РџР°-РїР°...' WHERE `entry`=-1631089;
-UPDATE `script_texts` SET `content_loc8`='РњРµСЂ-С‚РІРµС†, РјРµСЂ-С‚РІРµС†, РјРµСЂ-С‚РІРµС†!' WHERE `entry`=-1631087;
-UPDATE `script_texts` SET `content_loc8`='РџР°РїРѕС‡РєР°! РЈ РјРµРЅСЏ РїРѕР»СѓС‡РёР»РѕСЃСЊ!' WHERE `entry`=-1631086;
-UPDATE `script_texts` SET `content_loc8`='Р­С‚Рѕ РѕР±С‹С‡РЅРѕРµ РѕР±Р»Р°РіРѕ РіР°Р·Р°, С‚РѕР»СЊРєРѕ Р±СѓРґСЊС‚Рµ РѕСЃС‚РѕСЂРѕР¶РЅС‹, РЅРµ С‚Р°РєРѕРµ СѓР¶ РѕРЅРѕ Рё РѕР±С‹С‡РЅРѕРµ!' WHERE `entry`=-1631080;
+# КОРОЛЬ-ЛИЧ
 
-
-/*РџСЂРѕС„РµСЃСЃРѕСЂ РњРµСЂР·РѕС†РѕРёРґ*/
-
-UPDATE `script_texts` SET `content_loc8`='РћС‚Р»РёС‡РЅС‹Рµ РЅРѕРІРѕСЃС‚Рё, РЅР°СЂРѕРґ! РЇ СѓСЃРѕРІРµСЂС€РµРЅСЃС‚РІРѕРІР°Р» С€С‚Р°РјРј С‡СѓРјС‹, РєРѕС‚РѕСЂР°СЏ СѓРЅРёС‡С‚РѕР¶РёС‚ РІРµСЃСЊ РђР·РµСЂРѕС‚!' WHERE `entry`=-1666026;
-UPDATE `script_texts` SET `content_loc8`='РҐРј, С‡С‚Рѕ-С‚Рѕ СЏ РЅРёС‡РµРіРѕ РЅРµ С‡СѓРІСЃС‚РІСѓСЋ. Р§С‚Рѕ?! Р­С‚Рѕ РµС‰Рµ РѕС‚РєСѓРґР°?' WHERE `entry`=-1666029;
-UPDATE `script_texts` SET `content_loc8`='РќР° РІРєСѓСЃ, РєР°Рє РІРёС€РµРЅРєР°! РћР™! РР·РІРёРЅРёРёС‚Рµ!' WHERE `entry`=-1666030;
-UPDATE `script_texts` SET `content_loc8`='РџР»РѕС…РёРµ РЅРѕРІРѕСЃС‚Рё, РЅР°СЂРѕРґвЂ¦ РџРѕС…РѕР¶Рµ, Сѓ РјРµРЅСЏ РЅРёС‡РµРіРѕ РЅРµ РІС‹Р№РґРµС‚вЂ¦' WHERE `entry`=-1666034;
-
-
-/*РљСЂРѕРІР°РІС‹Р№ РЎРѕРІРµС‚*/
-
-UPDATE `script_texts` SET `content_loc8`='Р“Р»СѓРїС‹Рµ СЃРјРµСЂС‚РЅС‹Рµ. Р”СѓРјР°Р»Рё, С‡С‚Рѕ РѕРґРѕР»РµР»Рё РЅР°СЃ? РЎР°РЅ''Р»РµР№РЅ - РЅРµРїРѕР±РµРґРёРјС‹Рµ РІРѕРёРЅС‹ РљРѕСЂРѕР»СЏ-Р»РёС‡Р°. РўРµРїРµСЂСЊ РЅР°С€Рё СЃРёР»С‹ РµРґРёРЅС‹!' WHERE `entry`=-1666035;
-UPDATE `script_texts` SET `content_loc8`='Р’РѕСЃСЃС‚Р°РЅСЊС‚Рµ, Р±СЂР°С‚СЊСЏ, Рё СѓРЅРёС‡С‚РѕР¶СЊС‚Рµ РЅР°С€РёС… РІСЂР°РіРѕРІ!' WHERE `entry`=-1666036;
-UPDATE `script_texts` SET `content_loc8`='РќР°РєСЃР°РЅР°СЂ Р±С‹Р» РґРѕСЃР°РґРЅС‹Рј РЅРµРґРѕСЂР°Р·СѓРјРµРЅРёРµРј! РЎРёР»Р° РЎС„РµСЂС‹ РїРѕР·РІРѕР»РёС‚ Р’Р°Р»Р°РЅР°СЂСѓ СЃРІРµСЂС€РёС‚СЊ РѕС‚РјС‰РµРЅРёРµ!' WHERE `entry`=-1666049;
-UPDATE `script_texts` SET `content_loc8`='Р РїСЂРѕР»СЊРµС‚СЃСЏ РєСЂРѕРІСЊ!' WHERE `entry`=-1666038;
-UPDATE `script_texts` SET `content_loc8`='РџРёС‰Р° РґР»СЏ С‡РµСЂРІРµР№.' WHERE `entry`=-1666045;
-
-
-/*Р’Р°Р»РёС‚СЂРёСЏ*/
-
-UPDATE `script_texts` SET `content_loc8`='Р“РµСЂРѕРё, РІС‹ РґРѕР»Р¶РЅС‹ РјРЅРµ РїРѕРјРѕС‡СЊ! РњРѕРё СЃРёР»С‹... РЅР° РёСЃС…РѕРґРµ. Р—Р°Р»РµС‡РёС‚Рµ РјРѕРё СЂР°РЅС‹...' WHERE `entry`=-1666063;
-UPDATE `script_texts` SET `content_loc8`='РЇ РѕС‚РєСЂС‹Р»Р° РїРѕСЂС‚Р°Р» РІ РР·СѓРјСЂСѓРґРЅС‹Р№ РЎРѕРЅ. РўР°Рј РІС‹ РЅР°Р№РґРµС‚Рµ СЃРїР°СЃРµРЅРёРµ, РіРµСЂРѕРё.' WHERE `entry`=-1666064;
-UPDATE `script_texts` SET `content_loc8`='РЎРёР»С‹ РІРѕР·РІСЂР°С‰Р°СЋС‚СЃСЏ РєРѕ РјРЅРµ. Р“РµСЂРѕРё, РµС‰С‘ РЅРµРјРЅРѕРіРѕ!' WHERE `entry`=-1666065;
-UPDATE `script_texts` SET `content_loc8`='РЇ РґРѕР»РіРѕ РЅРµ РїСЂРѕРґРµСЂР¶СѓСЃСЊ!' WHERE `entry`=-1666066;
-UPDATE `script_texts` SET `content_loc8`='РџСЂРёСЃРєРѕСЂР±РЅР°СЏ РїРѕС‚РµСЂСЏ...' WHERE `entry`=-1666068;
-UPDATE `script_texts` SET `content_loc8`='РџСЂРѕСЃС‚РёС‚Рµ РјРµРЅСЏ! РЇ... РЅРµ РјРѕРіСѓ... РѕСЃС‚Р°... Р’РЎРЃ Р’Рћ Р’Р›РђРЎРўР РљРћРЁРњРђР Рђ!' WHERE `entry`=-1666067;
-UPDATE `script_texts` SET `content_loc8`='РќР•РЈР”РђР§РќРРљР!' WHERE `entry`=-16660690;
-UPDATE `script_texts` SET `content_loc8`='РЇ РР—Р›Р•Р§РР›РђРЎР¬! РР·РµСЂР°, РґР°СЂСѓР№ РјРЅРµ СЃРёР»Сѓ РїРѕРєРѕРЅС‡РёС‚СЊ СЃ СЌС‚РёРјРё РЅРµС‡РёСЃС‚РёРІС‹РјРё С‚РІР°СЂСЏРјРё.' WHERE `entry`=-1666070;
-
-
-/*РЎРёРЅРґСЂР°РіРѕСЃР°*/
-
-UPDATE `script_texts` SET `content_loc8`='Р“Р»СѓРїС†С‹, Р·Р°С‡РµРј РІС‹ СЃСЋРґР° СЏРІРёР»РёСЃСЊ! Р›РµРґСЏРЅС‹Рµ РІРµС‚СЂР° РќРѕСЂРґСЃРєРѕР»Р° СѓРЅРµСЃСѓС‚ РІР°С€Рё РґСѓС€Рё!' WHERE `entry`=-1666071;
-UPDATE `script_texts` SET `content_loc8`='РўСЂРµРїРµС‰РёС‚Рµ, СЃРјРµСЂС‚РЅС‹Рµ, РёР±Рѕ РІР°С€Р° Р¶Р°Р»РєР°СЏ РјР°РіРёСЏ С‚РµРїРµСЂСЊ Р±РµСЃСЃРёР»СЊРЅР°!' WHERE `entry`=-1666072;
-UPDATE `script_texts` SET `content_loc8`='Р’С‹ С‡СѓРІСЃС‚РІСѓРµС‚Рµ?' WHERE `entry`=-1666073;
-UPDATE `script_texts` SET `content_loc8`='РђР°Р°С…! Р–Р¶РµС‚СЃСЏ! Р§С‚Рѕ СЌС‚Рѕ Р·Р° РјР°РіРёСЏ?!' WHERE `entry`=-1666074;
-UPDATE `script_texts` SET `content_loc8`='РЎРµР№С‡Р°СЃ РІС‹ РїРѕС‡СѓСЃС‚РІСѓРµС‚Рµ РІСЃСЋ РјРѕС‰СЊ РЅР°С€РµРіРѕ РіРѕСЃРїРѕРґРёРЅР°!' WHERE `entry`=-1666076;
-UPDATE `script_texts` SET `content_loc8`='РџРѕРіРёР±РЅРё!' WHERE `entry`=-1666077;
-UPDATE `script_texts` SET `content_loc8`='РЈРґРµР» СЃРјРµСЂС‚РЅС‹С…...' WHERE `entry`=-1666078;
-UPDATE `script_texts` SET `content_loc8`='Р”РѕРІРѕР»СЊРЅРѕ! РЇ СѓСЃС‚Р°Р»Р° РѕС‚ СЌС‚РёС… РёРіСЂ!' WHERE `entry`=-1666079;
-UPDATE `script_texts` SET `content_loc8`='РќР°РєРѕРЅРµС†-С‚Рѕ...СЃРІРѕР±РѕРґРЅР°...' WHERE `entry`=-1666080;
-
-
-/*РљРћР РћР›Р¬-Р›РР§*/
-UPDATE `script_texts` SET `content_loc8`='РќРµСѓР¶РµР»Рё РїСЂРёР±С‹Р»Рё РЅР°РєРѕРЅРµС† С…РІР°Р»РµРЅС‹Рµ СЃРёР»С‹ РЎРІРµС‚Р°? РњРЅРµ Р±СЂРѕСЃРёС‚СЊ Р›РµРґСЏРЅСѓСЋ РЎРєРѕСЂР±СЊ Рё СЃРґР°С‚СЊСЃСЏ РЅР° С‚РІРѕСЋ РјРёР»РѕСЃСЊ, Р¤РѕСЂРґСЂРёРЅРі?' WHERE `entry`=-1810001;
-UPDATE `script_texts` SET `content_loc8`='РњС‹ РґР°СЂСѓРµРј С‚РµР±Рµ Р±С‹СЃС‚СЂСѓСЋ СЃРјРµСЂС‚СЊ, РђСЂС‚Р°СЃ. Р‘РѕР»РµРµ Р±С‹СЃС‚СЂСѓСЋ, С‡РµРј С‚С‹ Р·Р°СЃР»СѓР¶РёРІР°РµС€СЊ Р·Р° С‚Рѕ, С‡С‚Рѕ Р·Р°РјСѓС‡Р°Р» Рё РїРѕРіСѓР±РёР» РґРµСЃСЏС‚РєРё С‚С‹СЃСЏС‡ РґСѓС€' WHERE `entry`=-1810002;
-UPDATE `script_texts` SET `content_loc8`='РўС‹ РїСЂРѕР№РґРµС€СЊ С‡РµСЂРµР· СЌС‚Рё РјСѓС‡РµРЅРёСЏ СЃР°Рј. Р Р±СѓРґРµС€СЊ РњРћР›РРўР¬ Рѕ РїРѕС‰Р°РґРµ, РЅРѕ СЏ РЅРµ Р±СѓРґСѓ СЃР»СѓС€Р°С‚СЊ. РўРІРѕРё РѕС‚С‡Р°СЏРЅРЅС‹Рµ РєСЂРёРєРё РїРѕСЃР»СѓР¶Р°С‚ РґРѕРєР°Р·Р°С‚РµР»СЊСЃС‚РІРѕРј РјРѕРµР№ Р±РµР·РіСЂР°РЅРёС‡РЅРѕР№ РјРѕС‰Рё.' WHERE `entry`=-1810003;
-UPDATE `script_texts` SET `content_loc8`='Р”Р° Р±СѓРґРµС‚ С‚Р°Рє. Р§РµРјРїРёРѕРЅС‹, РІ Р°С‚Р°РєСѓ!' WHERE `entry`=-1810004;
-UPDATE `script_texts` SET `content_loc8`='РЇ РѕСЃС‚Р°РІР»СЋ С‚РµР±СЏ РІ Р¶РёРІС‹С…, С‡С‚РѕР±С‹ С‚С‹ СѓРІРёРґРµР» С„РёРЅР°Р». РќРµ РјРѕРіСѓ РґРѕРїСѓСЃС‚РёС‚СЊ, С‡С‚РѕР±С‹ РІРµР»РёС‡Р°Р№С€РёР№ СЃР»СѓР¶РёС‚РµР»СЊ РЎРІРµС‚Р° РїСЂРѕРїСѓСЃС‚РёР» СЂРѕР¶РґРµРЅРёРµ РњРћР•Р“Рћ РњРР Рђ.' WHERE `entry`=-1810005;
-UPDATE `script_texts` SET `content_loc8`='РЇ РїСЂРѕРјРѕСЂРѕР¶Сѓ РІР°СЃ РЅР°СЃРєРІРѕР·СЊ - Рё РІС‹ СЂР°Р·Р»РµС‚РёС‚РµСЃСЊ РЅР° Р»РµРґСЏРЅС‹Рµ РѕСЃРєРѕР»РєРё.' WHERE `entry`=-1810007;
-UPDATE `script_texts` SET `content_loc8`='РљРћРќР•Р¦ РЎР’Р•РўРђ!' WHERE `entry`=-1810008;
-UPDATE `script_texts` SET `content_loc8`='РЎРєР»РѕРЅРёСЃСЊ РїРµСЂРµРґ СЃРІРѕРёРј РіРѕСЃРїРѕРґРёРЅРѕРј Рё РїРѕРІРµР»РёС‚РµР»РµРј!.' WHERE `entry`=-1810009;
-UPDATE `script_texts` SET `content_loc8`='РќР°РґРµР¶РґР° С‚Р°РµС‚!' WHERE `entry`=-1810010;
-UPDATE `script_texts` SET `content_loc8`='РџСЂРёС€РµР» РљРћРќР•Р¦!' WHERE `entry`=-1810011;
-UPDATE `script_texts` SET `content_loc8`='Р’СЃС‚СЂРµС‡Р°Р№С‚Рµ С‚СЂР°РіРёС‡РµСЃРєРёР№ С„РёРЅР°Р»!' WHERE `entry`=-1810012;
-UPDATE `script_texts` SET `content_loc8`='РЎРѕРјРЅРµРЅРёР№ РЅРµС‚, РІС‹ РІРµР»РёС‡Р°Р№С€РёРµ РіРµСЂРѕРё РђР·РµСЂРѕС‚Р°! Р’С‹ РїСЂРµРѕРґРѕР»РµР»Рё РІСЃРµ РїСЂРµРїСЏС‚СЃС‚РІРёСЏ, РєРѕС‚РѕСЂС‹Рµ СЏ РІРѕР·РґРІРёРі РїРµСЂРµРґ РІР°РјРё. РЎРёР»СЊРЅРµР№С€РёРµ РёР· РјРѕРёС… СЃР»СѓРі РїР°Р»Рё РїРѕРґ РІР°С€РёРј РЅР°С‚РёСЃРєРѕРј, СЃРіРѕСЂРµР»Рё РІ РїР»Р°РјРµРЅРё РІР°С€РµР№ СЏСЂРѕСЃС‚Рё!' WHERE `entry`=-1810013;
-UPDATE `script_texts` SET `content_loc8`='РўС‹ РѕС‚Р»РёС‡РЅРѕ РёС… РѕР±СѓС‡РёР», Р¤РѕСЂРґСЂРёРЅРі! ' WHERE `entry`=-1810014;
-UPDATE `script_texts` SET `content_loc8`='РЎРјРѕС‚СЂРё, РєР°Рє СЏ Р±СѓРґСѓ РІСЃРѕРєСЂРµС€Р°С‚СЊ РёС…, Рё РїСЂРµРІСЂР°С‰Р°С‚СЊ РІ РІРѕРёРЅРѕРІ РџР»РµС‚Рё! РћРЅРё РїРѕРІРµСЂРіРЅСѓС‚ СЌС‚РѕС‚ РјРёСЂ РІ РїСѓС‡РёРЅСѓ С…Р°РѕСЃР°. РђР·РµСЂРѕС‚ РїР°РґРµС‚ РѕС‚ РёС… СЂСѓРє! Рё С‚С‹ СЃС‚Р°РЅРµС€СЊ РїРµСЂРІРѕР№ Р¶РµСЂС‚РІРѕР№.' WHERE `entry`=-1810015;
-UPDATE `script_texts` SET `content_loc8`='РњРЅРµ РїРѕ РґСѓС€Рµ СЌС‚Р° РёСЂРѕРЅРёСЏ.' WHERE `entry`=-1810016;
-UPDATE `script_texts` SET `content_loc8`='РЎР’Р•Рў, Р”РђР РЈР™ РњРќР• РџРћРЎР›Р•Р”РќР•Р• Р‘Р›РђР“РћРЎР›РћР’Р›Р•РќРР•... Р”РђР™ РњРќР• РЎРР›Р« Р РђР—Р‘РРўР¬ Р­РўР РћРљРћР’Р«!' WHERE `entry`=-1810017;
-UPDATE `script_texts` SET `content_loc8`='РќРµРІРѕР·РјРѕР¶РЅРѕ...' WHERE `entry`=-1810018;
-UPDATE `script_texts` SET `content_loc8`='РђР°С…! Р’С‹ РјРµРЅСЏ Рё РїСЂР°РІРґР° СЂР°РЅРёР»Рё. РЇ СЃР»РёС€РєРѕРј РґРѕР»РіРѕ СЃ РІР°РјРё РёРіСЂР°Р»! РСЃРїС‹С‚Р°Р№С‚Рµ РЅР° СЃРµР±Рµ Р’РѕР·РјРµР·РґРёРµ РЎРњР•Р РўР!' WHERE `entry`=-1666080;
-UPDATE `script_texts` SET `content_loc8`='Р РІРѕС‚ СЏ СЃС‚РѕСЋ РєР°Рє Р»РµРІ РїСЂРµРґ Р°РіРЅС†Р°РјРё... Р РЅРµ РґСЂРѕР¶Р°С‚ РѕРЅРё.' WHERE `entry`=-1810024;
-UPDATE `script_texts` SET `content_loc8`='РРј РЅРµРІРµРґРѕРј СЃС‚СЂР°С….' WHERE `entry`=-1810025;
-UPDATE `script_texts` SET `content_loc8`='РќСѓ Р¶Рµ РіРµСЂРѕРё, РІ РІР°С€РµР№ СЏСЂРѕСЃС‚Рё РјРѕСЏ СЃРёР»Р°!' WHERE `entry`=-1810006;
-UPDATE `script_texts` SET `content_loc8`='Р›РµРґСЏРЅР°СЏ РЎРєРѕСЂР±СЊ Р¶Р°Р¶РґРµС‚ РєСЂРѕРІРё!' WHERE `entry`=-1810027;
-UPDATE `script_texts` SET `content_loc8`='Р›РµРґСЏРЅР°СЏ РЎРєРѕСЂР±СЊ РїРѕРіР»РѕС‚РёС‚ РґСѓС€Сѓ РІР°С€РµРіРѕ С‚РѕРІР°СЂРёС‰Р°.' WHERE `entry`=-1810028;
-UPDATE `script_texts` SET `content_loc8`='РЎРјРѕС‚СЂРёС‚Рµ РєР°Рє РјРёСЂ СЂСѓС€РёС‚СЃСЏ РІРѕРєСЂСѓРі РІР°СЃ!' WHERE `entry`=-1810030;
-UPDATE `script_texts` SET `content_loc8`='Р’Р°Р»СЊ''РєРёСЂР°, С‚РІРѕР№ РіРѕСЃРїРѕРґРёРЅ Р·РѕРІРµС‚!' WHERE `entry`=-1810029;
-UPDATE `script_texts` SET `content_loc8`='РҐРІР°С‚РёС‚, РђСЂС‚Р°СЃ! РўРІРѕСЏ РЅРµРЅР°РІРёСЃС‚СЊ РЅРµ Р·Р°Р±РµСЂРµС‚ Р±РѕР»СЊС€Рµ РЅРё РѕРґРЅРѕР№ Р¶РёР·РЅРё!' WHERE `entry`=-1810020;
-UPDATE `script_texts` SET `content_loc8`='Р’С‹ РїСЂРёС€Р»Рё, С‡С‚РѕР±С‹ РІРµСЂС€РёС‚СЊ СЃСѓРґ РЅР°Рґ РђСЂС‚Р°СЃРѕРј? Р§С‚РѕР±С‹ СѓРЅРёС‡С‚РѕР¶РёС‚СЊ РљРѕСЂРѕР»СЏ-Р»РёС‡Р°?' WHERE `entry`=-1666080;
-UPDATE `script_texts` SET `content_loc8`='Р’С‹ РЅРµ РґРѕР»Р¶РЅС‹ РѕРєР°Р·Р°С‚СЊСЃСЏ РІРѕ РІР»Р°СЃС‚Рё Р›РµРґСЏРЅРѕР№ РЎРєРѕСЂР±Рё. РРЅР°С‡Рµ, РєР°Рє Рё СЏ, Р±СѓРґРµС‚Рµ РЅР°РІРµРє РїРѕСЂР°Р±РѕС‰РµРЅС‹ СЌС‚РёРј РїСЂРѕРєР»СЏС‚С‹Рј РєР»РёРЅРєРѕРј!' WHERE `entry`=-1666080;
-UPDATE `script_texts` SET `content_loc8`='РџРѕРјРѕРіРёС‚Рµ РјРЅРµ СѓРЅРёС‡С‚РѕР¶РёС‚СЊ СЌС‚Рё РёСЃС‚РµСЂР·Р°РЅРЅС‹Рµ РґСѓС€Рё! Р’РјРµСЃС‚Рµ РјС‹ РІС‹С‚СЏРЅРµРј СЃРёР»Сѓ РёР· Р›РµРґСЏРЅРѕР№ РЎРєРѕСЂР±Рё Рё РѕСЃР»Р°Р±РёРј РљРѕСЂРѕР»СЏ-Р»РёС‡Р°!' WHERE `entry`=-1666080; */
-UPDATE `script_texts` SET `content_loc8`='РќР°РєРѕРЅРµС† СЏ СЃРІРѕР±РѕРґРµРЅ! Р’СЃС‘ РєРѕРЅС‡РµРЅРѕ, СЃС‹РЅ РјРѕР№... РќР°СЃС‚Р°Р» С‡Р°СЃ СЂР°СЃРїР»Р°С‚С‹!' WHERE `entry`=-1810021;
-UPDATE `script_texts` SET `content_loc8`='РџРѕРґРЅРёРјРёС‚РµСЃСЊ, Р’РѕРёРЅС‹ РЎРІРµС‚Р°!' WHERE `entry`=-1810023;
-UPDATE `script_texts` SET `content_loc8`='РљРѕСЂРѕР»СЊ-Р»РёС‡ РїР°РґРµС‚!' WHERE `entry`=-1810022;
\ No newline at end of file
+UPDATE `script_texts` SET `content_loc8`='Неужели прибыли наконец хваленые силы Света? Мне бросить Ледяную Скорбь и сдаться на твою милось, Фордринг?' WHERE `entry`=-1810001;
+UPDATE `script_texts` SET `content_loc8`='Мы даруем тебе быструю смерть, Артас. Более быструю, чем ты заслуживаешь за то, что замучал и погубил десятки тысяч душ' WHERE `entry`=-1810002;
+UPDATE `script_texts` SET `content_loc8`='Ты пройдешь через эти мучения сам. И будешь МОЛИТЬ о пощаде, но я не буду слушать. Твои отчаянные крики послужат доказательством моей безграничной мощи.' WHERE `entry`=-1810003;
+UPDATE `script_texts` SET `content_loc8`='Да будет так. Чемпионы, в атаку!' WHERE `entry`=-1810004;
+UPDATE `script_texts` SET `content_loc8`='Я оставлю тебя в живых, чтобы ты увидел финал. Не могу допустить, чтобы величайший служитель Света пропустил рождение МОЕГО МИРА.' WHERE `entry`=-1810005;
+UPDATE `script_texts` SET `content_loc8`='Я проморожу вас насквозь - и вы разлетитесь на ледяные осколки.' WHERE `entry`=-1810007;
+UPDATE `script_texts` SET `content_loc8`='КОНЕЦ СВЕТА!' WHERE `entry`=-1810008;
+UPDATE `script_texts` SET `content_loc8`='Склонись перед своим господином и повелителем!.' WHERE `entry`=-1810009;
+UPDATE `script_texts` SET `content_loc8`='Надежда тает!' WHERE `entry`=-1810010;
+UPDATE `script_texts` SET `content_loc8`='Пришел КОНЕЦ!' WHERE `entry`=-1810011;
+UPDATE `script_texts` SET `content_loc8`='Встречайте трагический финал!' WHERE `entry`=-1810012;
+UPDATE `script_texts` SET `content_loc8`='Сомнений нет, вы величайшие герои Азерота! Вы преодолели все препятствия, которые я воздвиг перед вами. Сильнейшие из моих слуг пали под вашим натиском, сгорели в пламени вашей ярости!' WHERE `entry`=-1810013;
+UPDATE `script_texts` SET `content_loc8`='Ты отлично их обучил, Фордринг! ' WHERE `entry`=-1810014;
+UPDATE `script_texts` SET `content_loc8`='Смотри, как я буду всокрешать их, и превращать в воинов Плети! Они повергнут этот мир в пучину хаоса. Азерот падет от их рук! и ты станешь первой жертвой.' WHERE `entry`=-1810015;
+UPDATE `script_texts` SET `content_loc8`='Мне по душе эта ирония.' WHERE `entry`=-1810016;
+UPDATE `script_texts` SET `content_loc8`='СВЕТ, ДАРУЙ МНЕ ПОСЛЕДНЕЕ БЛАГОСЛОВЛЕНИЕ... ДАЙ МНЕ СИЛЫ РАЗБИТЬ ЭТИ ОКОВЫ!' WHERE `entry`=-1810017;
+UPDATE `script_texts` SET `content_loc8`='Невозможно...' WHERE `entry`=-1810018;
+UPDATE `script_texts` SET `content_loc8`='Аах! Вы меня и правда ранили. Я слишком долго с вами играл! Испытайте на себе Возмездие СМЕРТИ!' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='И вот я стою как лев пред агнцами... И не дрожат они.' WHERE `entry`=-1810024;
+UPDATE `script_texts` SET `content_loc8`='Им неведом страх.' WHERE `entry`=-1810025;
+UPDATE `script_texts` SET `content_loc8`='Ну же герои, в вашей ярости моя сила!' WHERE `entry`=-1810006;
+UPDATE `script_texts` SET `content_loc8`='Ледяная Скорбь жаждет крови!' WHERE `entry`=-1810027;
+UPDATE `script_texts` SET `content_loc8`='Ледяная Скорбь поглотит душу вашего товарища.' WHERE `entry`=-1810028;
+UPDATE `script_texts` SET `content_loc8`='Смотрите как мир рушится вокруг вас!' WHERE `entry`=-1810030;
+UPDATE `script_texts` SET `content_loc8`='Валь''кира, твой гсоподин зовет!' WHERE `entry`=-1810029;
+UPDATE `script_texts` SET `content_loc8`='Хватит, Артас! Твоя ненависть не заберет больше ни одной жизни!' WHERE `entry`=-1810020;
+UPDATE `script_texts` SET `content_loc8`='Вы пришли, что бы вершить суд над Артасом? Что бы уничтожить Короля-лича?' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='Вы не должны оказаться во власти Ледяной Скорби. Иначе, как и я, будете навек порабощены этим проклятым клинком!' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='Помогите мне уничтожить эти истерзанные души! Вместе мы вытянем силу из Ледяной Скорби и ослабим Короля-лича!' WHERE `entry`=-1666080;
+UPDATE `script_texts` SET `content_loc8`='Наконец я свободен! Всё кончено, сын мой... Настал час расплаты!' WHERE `entry`=-1810021;
+UPDATE `script_texts` SET `content_loc8`='Поднимитесь, Воины Света!' WHERE `entry`=-1810023;
+UPDATE `script_texts` SET `content_loc8`='Король-лич падет!' WHERE `entry`=-1810022;
\ No newline at end of file
diff --git a/sql/Greedy-core/world/IoC.sql b/sql/Greedy-core/world/IoC.sql
--- a/sql/Greedy-core/world/IoC.sql
+++ b/sql/Greedy-core/world/IoC.sql
@@ -62,7 +62,7 @@
 -- Overlord Agmar &   script
 UPDATE creature_template SET `ScriptName`='boss_isle_of_conquest' WHERE `entry` IN (34924,34922);
 	
-INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
+INSERT IGNORE  `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
 (12039, 'le donjon de l''alliance', NULL, 'le donjon de l''alliance', NULL, NULL, NULL, NULL, NULL, NULL),
 (12038, 'le donjon de la Horde', NULL, 'le donjon de la Horde', NULL, NULL, NULL, NULL, NULL, NULL),
 (12037, 'L''Alliance a pris le donjon de la Horde !', NULL, 'L''Alliance a pris le donjon de la Horde !', NULL, NULL, NULL, NULL, NULL, NULL),
@@ -93,7 +93,7 @@
 (12012, 'The battle will begin in one minute!', NULL, 'La bataille commencera dans 1 minute.', NULL, NULL, NULL, NULL, NULL, NULL),
 (12011, 'The battle will begin in two minutes!', NULL, 'La bataille commencera dans 2 minutes.', NULL, NULL, NULL, NULL, NULL, NULL);
 
-INSERT INTO `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES
+INSERT IGNORE `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES
 (66548, 66550, 0, 'Isle of Conquest (OUT>IN)'),
 (66549, 66550, 0, 'Isle of Conquest (IN>OUT)'),
 (66550, -66549, 2, 'Isle of Conquest Teleport (OUT>IN) Debuff limit'),
diff --git a/sql/Greedy-core/world/Naxxramas.sql b/sql/Greedy-core/world/Naxxramas.sql
--- a/sql/Greedy-core/world/Naxxramas.sql
+++ b/sql/Greedy-core/world/Naxxramas.sql
@@ -62,8 +62,6 @@
 ('333007','181125','533','1','2617.74','-3336.81','267.684','0','0','0','0','1','25','0','1'),
 -- 181170 Vaccuum - Combat Gate
 ('333008','181170','533','1','2692.04','-3361.4','267.684','0','0','0','0','1','6','0','1'),
--- 181119 Deathknight Door
-('333009','181119','533','1','2587.76','-3017.16','240.5','3.14159','0','0','1','3.13916e-007','6','0','1'),
 -- 181200 Noth - Entry Door
 ('333010','181200','533','1','2737.83','-3489.78','262.107','0','0','0','0','1','25','0','0'),
 -- 181201 Noth - Exit Door
@@ -88,4 +86,24 @@
 ('333019','181228','533','1','3635.34','-5090.31','143.206','1.37','0','0','0.632673','0.774419','6','0','1');
 
 UPDATE gameobject_template SET size = 1.2 WHERE entry = 181201;
-UPDATE gameobject_template SET faction = 14 WHERE entry IN (181126,181195,181167,181235,181197,181209,181123,181120,181121,181124,181125,181170,181119,181200,181201,181202,181203,181241,181225,181228,181496,181366);
\ No newline at end of file
+UPDATE gameobject_template SET faction = 14 WHERE entry IN (181126,181195,181167,181235,181197,181209,181123,181120,181121,181124,181125,181170,181119,181200,181201,181202,181203,181241,181225,181228,181496,181366);
+
+UPDATE creature_template SET health_mod = '3346800' WHERE entry = '16061';
+UPDATE creature_template SET health_mod = '2231200' WHERE entry = '15956';
+UPDATE creature_template SET health_mod = '780920' WHERE entry = '30549';
+UPDATE creature_template SET health_mod = '2231200' WHERE entry = '15953';
+UPDATE creature_template SET health_mod = '2789000' WHERE entry = '15932';
+UPDATE creature_template SET health_mod = '836700' WHERE entry = '16060';
+UPDATE creature_template SET health_mod = '2928450' WHERE entry = '15931';
+UPDATE creature_template SET health_mod = '2500000' WHERE entry = '15990';
+UPDATE creature_template SET health_mod = '780920' WHERE entry = '16065';
+UPDATE creature_template SET health_mod = '4322950' WHERE entry = '16028';
+UPDATE creature_template SET health_mod = '6693600' WHERE entry = '16011';
+UPDATE creature_template SET health_mod = '2510100' WHERE entry = '15952';
+UPDATE creature_template SET health_mod = '2789000' WHERE entry = '15954';
+UPDATE creature_template SET health_mod = '4183500' WHERE entry = '15989';
+UPDATE creature_template SET health_mod = '780920' WHERE entry = '16063';
+UPDATE creature_template SET health_mod = '3834875' WHERE entry = '15928';
+UPDATE creature_template SET health_mod = '780920' WHERE entry = '16064';
+UPDATE creature_template SET health_mod = '3067900' WHERE entry = '15936';
+
diff --git a/sql/Greedy-core/world/TrialChampion.sql b/sql/Greedy-core/world/TrialChampion.sql
--- a/sql/Greedy-core/world/TrialChampion.sql
+++ b/sql/Greedy-core/world/TrialChampion.sql
@@ -63,7 +63,7 @@
 (0,-1999926, 'Coming out of the gate Grand Champions other faction.  ' ,0,0,0,1, 'SAY_START' ),
 (0,-1999927, 'Good work! You can get your award from Crusader\'s Coliseum chest!.  ' ,0,1,0,1, 'Win' ),
 (0,-1999928, 'You spoiled my grand entrance. Rat.' ,16256,1,0,5, 'SAY_AGGRO' ),
-(0,-1999929, 'Did you honestly think an agent if the Kich King would be bested on the field of your pathetic little tournament?' ,16257,1,0,5, 'SAY_AGGRO_1' ),
+(0,-1999929, 'Did you honestly think an agent if the Lich King would be bested on the field of your pathetic little tournament?' ,16257,1,0,5, 'SAY_AGGRO_1' ),
 (0,-1999930, 'I have come to finish my task ' ,16258,1,0,5, 'SAY_AGGRO_2' ),
 (0,-1999931, 'This farce ends here!' ,16259,1,0,5, 'SAY_AGGRO_3' ),
 (0,-1999932, '[Zombie]Brains.... .... ....' ,0,1,0,5, 'SAY_SLAY' ),
diff --git a/sql/Greedy-core/world/TrialofCrusader.sql b/sql/Greedy-core/world/TrialofCrusader.sql
--- a/sql/Greedy-core/world/TrialofCrusader.sql
+++ b/sql/Greedy-core/world/TrialofCrusader.sql
@@ -145,7 +145,7 @@
 UPDATE creature_template SET ScriptName="mob_frost_sphere" WHERE entry = 34606;
 UPDATE creature_template SET ScriptName="toc_tirion_fordring" WHERE entry=34996; 
 UPDATE creature_template SET ScriptName="toc_barrett_ramsey" WHERE entry=34816; 
-UPDATE instance_template SET script="instance_trial_of_the_crusader" WHERE map=649; 
+UPDATE instance_template SET script="instance_trial_of_the_crusader" WHERE map=649; 	
 
 
 UPDATE creature_template SET npcflag=1 WHERE entry IN(34816, 3481601, 3481602, 3481603, 34568, 3456801, 3456802, 3456803, 34567, 3456701, 3456702, 3456703); 
@@ -541,270 +541,3 @@
 UPDATE `creature_template` SET `scriptname`='mob_toc_pet_warlock', `AIName` ='' WHERE `entry` IN (35465);
 UPDATE `creature_template` SET `scriptname`='mob_toc_pet_hunter', `AIName` ='' WHERE `entry` IN (35610);
 
--- -------------------------------------------------------------------------
--- ------------------------ Trial Of the Champion --------------------------
--- -------------------------------------------------------------------------
--- Gate
-DELETE FROM `gameobject` WHERE `guid` in (150077,150080);
-REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `ScriptName`) VALUES 
-(195649, 0, 411, 'South Portcullis', '', '', '', 0, 37, 3.26663, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
-(195648, 0, 411, 'East Portcullis', '', '', '', 0, 37, 3.26663, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ''),
-(195650, 0, 411, 'North Portcullis', '', '', '', 0, 37, 3.26663, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '');
-REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES 
-(150076, 195650, 650, 3, 65535, 807.66, 618.091, 412.394, 3.12015, 0, 0, 0.999943, 0.0107224, 25, 0, 0),
-(150073, 195648, 650, 3, 65535, 746.561, 557.002, 412.393, 1.57292, 0, 0, 0.707856, 0.706357, 25, 0, 1),
-(150074, 195649, 650, 3, 65535, 685.625, 617.977, 412.285, 6.28137, 0, 0, 0.000909718, -1, 25, 0, 1),
-(150081, 195647, 650, 3, 1, 746.698, 677.469, 412.339, 1.5708, 0, 0, 1, 0, 0, 0, 1);
--- Mounts
-DELETE FROM `vehicle_accessory` WHERE `entry` in (35491,33299,33418,33409,33300,33408,33301,33414,33297,33416,33298);
-INSERT INTO `vehicle_accessory` (`entry`,`accessory_entry`,`seat_id`,`minion`,`description`) VALUES
-(35491,35451,0,0, 'Black Knight'),
-(33299,35323,0,1, 'Darkspear Raptor'),
-(33418,35326,0,1, 'Silvermoon Hawkstrider'),
-(33409,35314,0,1, 'Orgrimmar Wolf'),
-(33300,35325,0,1, 'Thunder Bluff Kodo'),
-(33408,35329,0,1, 'Ironforge Ram'),
-(33301,35331,0,1, 'Gnomeregan Mechanostrider'),
-(33414,35327,0,1, 'Forsaken Warhorse'),
-(33297,35328,0,1, 'Stormwind Steed'),
-(33416,35330,0,1, 'Exodar Elekk'),
-(33298,35332,0,1, 'Darnassian Nightsaber');
-UPDATE `creature_template` SET `minlevel` = 80,`maxlevel` = 80 WHERE `entry` in (33298,33416,33297,33301,33408,35640,33299,33300,35634,33418,35638,33409,33414,33299,35635,35641);
-UPDATE `creature_template` SET `faction_A` = 14,`faction_H` = 14 WHERE `entry` in (33298,33416,33297,33301,33408,35545,33299,35564,35590,35119,34928,35309,35305,33414,35307,35325,33300,35327,35326,33418,35638,35314,33409,33299,35635,35640,35641,35634,35633,35636,35768,35637,34658);
-UPDATE `creature_template` SET `Health_mod` = 10,`mindmg` = 20000,`maxdmg` = 30000 WHERE `entry` in (33298,33416,33297,33301,33408,33409,33418,33300,33414,33299,33298,33416,33297,33301,33408,35640,35638,35634,35635,35641,35633,35636,35768,35637,34658);
-UPDATE `creature_template` SET `speed_run` = 2,`Health_mod` = 40,`mindmg` = 10000,`maxdmg` = 20000,`spell1` =62544,`spell2` =63010,`spell3` =0,`spell4` =0 WHERE `entry` in (35644,36558);
-UPDATE `creature` SET `spawntimesecs` = 86400 WHERE `id` in (35644,36558);
--- ScriptName
-UPDATE `creature_template` SET `ScriptName`='generic_vehicleAI_toc5' WHERE `entry`=33299;
--- VehicleId
-UPDATE `creature_template` SET `VehicleId`=486 WHERE `entry` in (33299,35491);
--- faction for Vehicle
-UPDATE `creature_template` SET `faction_A`=35,`faction_H`=35,`unit_flags`=33554432  WHERE `entry` in (35314,35326,35327,35325,35323,35331,35330,35329,35328,35332,35491);
--- Texts 
-DELETE FROM `script_texts` WHERE `entry` <= -1999926 and `entry` >= -1999956;
-INSERT INTO `script_texts` (`npc_entry`,`entry`,`content_default`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
-(0,-1999926, 'Coming out of the gate Grand Champions other faction.  ' ,0,0,0,1, '' ),
-(0,-1999927, 'Good work! You can get your award from Crusader\'s Coliseum chest!.  ' ,0,1,0,1, '' ),
-(0,-1999928, 'You spoiled my grand entrance. Rat.' ,16256,1,0,5, '' ),
-(0,-1999929, 'Did you honestly think an agent if the Lich King would be bested on the field of your pathetic little tournament?' ,16257,1,0,5, '' ),
-(0,-1999930, 'I have come to finish my task ' ,16258,1,0,5, '' ),
-(0,-1999931, 'This farce ends here!' ,16259,1,0,5, '' ),
-(0,-1999932, '[Zombie]Brains.... .... ....' ,0,1,0,5, '' ),
-(0,-1999933, 'My roting flash was just getting in the way!' ,16262,1,0,5, '' ),
-(0,-1999934, 'I have no need for bones to best you!' ,16263,1,0,5, '' ),
-(0,-1999935, 'No! I must not fail...again...' ,16264,1,0,5, '' ),
-(0,-1999936, 'What\'s that. up near the rafters ?' ,0,1,0,5, '' ),
-(0,-1999937, 'Please change your weapon! Next battle will be start now!' ,0,3,0,5, '' ),
-(0,-1999939, 'Excellent work!' ,0,1,0,1, '' ),
-(0,-1999940, 'Coming out of the gate Crusader\'s Coliseum Champion.' ,0,0,0,1, '' ),
-(0,-1999941, 'Excellent work! You are win Argent champion!' ,0,3,0,0, '' ),
-(0,-1999942, 'The Sunreavers are proud to present their representatives in this trial by combat.' ,0,0,0,1, '' ),
-(0,-1999943, 'Welcome, champions. Today, before the eyes of your leeders and peers, you will prove youselves worthy combatants.' ,0,0,0,1, '' ),
-(0,-1999944, 'Fight well, Horde! Lok\'tar Ogar!' ,0,1,0,5, '' ),
-(0,-1999945, 'Finally, a fight worth watching.' ,0,1,0,5, '' ),
-(0,-1999946, 'I did not come here to watch animals tear at each other senselessly, Tirion' ,0,1,0,5, '' ),
-(0,-1999947, 'You will first be facing three of the Grand Champions of the Tournament! These fierce contenders have beaten out all others to reach the pinnacle of skill in the joust.' ,0,1,0,5, '' ),
-(0,-1999948, 'Will tought! You next challenge comes from the Crusade\'s own ranks. You will be tested against their consederable prowess.' ,0,1,0,5, '' ),
-(0,-1999949, 'You may begin!' ,0,0,0,5, '' ),
-(0,-1999950, 'Well, then. Let us begin.' ,0,1,0,5, '' ),
-(0,-1999951, 'Take this time to consider your past deeds.' ,16248,1,0,5, '' ),
-(0,-1999952, 'What is the meaning of this?' ,0,1,0,5, '' ),
-(0,-1999953, 'No...I\'m still too young' ,0,1,0,5, '' ),
-(0,-1999954, 'Excellent work! You are win Argent champion!' ,0,3,0,0, '' );
--- Update mob's stats
-REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
-(35571, 12006, 0, 0, 0, 0, 28597, 0, 28597, 0, 'Runok Wildmane', 'Grand Champion of the Thunder Bluff', '', 0, 80, 80, 2, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67529, 67530, 67528, 67534, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_shaman_toc5'),
-(12006, 0, 0, 0, 0, 0, 28597, 0, 28597, 0, 'Runok Wildmane', 'Grand Champion of the Thunder Bluff', '', 0, 80, 80, 2, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68319, 67530, 67528, 67534, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(35569, 12005, 0, 0, 0, 0, 28637, 0, 28637, 0, 'Eressea Dawnsinger', 'Grand Champion of Silvermoon', '', 0, 80, 80, 2, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66044, 66042, 66045, 66043, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_mage_toc5'),
-(12005, 0, 0, 0, 0, 0, 28637, 0, 28637, 0, 'Eressea Dawnsinger', 'Grand Champion of Silvermoon', '', 0, 80, 80, 2, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68312, 68310, 66045, 68311, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(35572, 12009, 0, 0, 0, 0, 28587, 0, 28587, 0, 'Mokra the Skullcrusher', 'Grand Champion of Orgrimmar', '', 0, 80, 80, 2, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 441, 1, 0, 617297499, 0, 'boss_warrior_toc5'),
-(12009, 0, 0, 0, 0, 0, 28587, 0, 28587, 0, 'Mokra the Skullcrusher', 'Grand Champion of Orgrimmar', '', 0, 80, 80, 0, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 35.38, 20, 0, 0, 0, 0, 0, 0, 0, 441, 1, 0, 617297499, 1, ''),
-(35617, 12008, 0, 0, 0, 0, 28589, 0, 28589, 0, 'Deathstalker Visceri', 'Grand Champion of Undercity', '', 0, 80, 80, 2, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67709, 67706, 67701, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_rouge_toc5'),
-(12008, 0, 0, 0, 0, 0, 28589, 0, 28589, 0, 'Deathstalker Visceri', 'Grand Champion of Undercity', '', 0, 80, 80, 0, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67709, 67706, 67701, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 35.38, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(35570, 12007, 0, 0, 0, 0, 28588, 0, 28588, 0, 'Zul\'tore', 'Grand Champion of Sen\'jin', '', 0, 80, 80, 2, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68340, 66083, 66081, 66079, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_hunter_toc5'),
-(12007, 0, 0, 0, 0, 0, 28588, 0, 28588, 0, 'Zul\'tore', 'Grand Champion of Sen\'jin', '', 0, 80, 80, 0, 1801, 1801, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68340, 66083, 66081, 66079, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 35.38, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(34701, 12001, 0, 0, 0, 0, 28736, 0, 28736, 0, 'Colosos', 'Grand Champion of the Exodar', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67529, 67530, 67528, 67534, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_shaman_toc5'),
-(12001, 0, 0, 0, 0, 0, 28736, 0, 28736, 0, 'Colosos', 'Grand Champion of the Exodar', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 17, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68319, 67530, 68318, 67534, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(34703, 12003, 0, 0, 0, 0, 28564, 0, 28564, 0, 'Lana Stouthammer', 'Grand Champion of Ironforge', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67709, 67706, 67701, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 441, 1, 0, 617297499, 0, 'boss_rouge_toc5'),
-(12003, 0, 0, 0, 0, 0, 28564, 0, 28564, 0, 'Lana Stouthammer', 'Grand Champion of Ironforge', '', 0, 80, 80, 0, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 35.38, 20, 0, 0, 0, 0, 0, 0, 0, 441, 1, 0, 617297499, 1, ''),
-(34702, 12000, 0, 0, 0, 0, 28586, 0, 28586, 0, 'Ambrose Boltspark', 'Grand Champion of Gnomeregan', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66044, 66042, 66045, 66043, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_mage_toc5'),
-(12000, 0, 0, 0, 0, 0, 28586, 0, 28586, 0, 'Ambrose Boltspark', 'Grand Champion of Gnomeregan', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68312, 68310, 66045, 68311, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(34657, 12002, 0, 0, 0, 0, 28735, 0, 28735, 0, 'Jaelyne Evensong', 'Grand Champion of Darnassus', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68340, 66083, 66081, 66079, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_hunter_toc5'),
-(12002, 0, 0, 0, 0, 0, 28735, 0, 28735, 0, 'Jaelyne Evensong', 'Grand Champion of Darnassus', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68340, 66083, 66081, 66079, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(34705, 12004, 0, 0, 0, 0, 28560, 0, 28560, 0, 'Marshal Jacob Alerius', 'Grand Champion of Stormwind', '', 0, 80, 80, 2, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 10.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 0, 'boss_warrior_toc5'),
-(12004, 0, 0, 0, 0, 0, 28560, 0, 28560, 0, 'Marshal Jacob Alerius', 'Grand Champion of Stormwind', '', 0, 80, 80, 0, 1802, 1802, 0, 1, 1, 1, 420, 630, 0, 158, 15.2, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 35.38, 20, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 617297499, 1, ''),
-(35590, 12444, 0, 0, 0, 0, 24996, 24999, 24997, 0, 'Risen Champion', 'Black Knight\'s Minion', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 0, 420, 630, 0, 158, 1, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67774, 67879, 67729, 67886, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1.5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(12444, 0, 0, 0, 0, 0, 24996, 24999, 24997, 0, 'Risen Champion', 'Black Knight\'s Minion', '', 0, 80, 80, 0, 14, 14, 0, 1, 1, 0, 420, 630, 0, 158, 1.4, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67774, 67879, 67729, 67886, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 7.076, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(35564, 12436, 0, 0, 0, 0, 25528, 0, 25528, 0, 'Risen Arelas Brightstar', 'Black Knight\'s Minion', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 0, 420, 630, 0, 158, 1.4, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67774, 67879, 67729, 67886, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 2.5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_risen_ghoul'),
-(12436, 0, 0, 0, 0, 0, 25528, 0, 25528, 0, 'Risen Arelas Brightstar', 'Black Knight\'s Minion', '', 0, 80, 80, 0, 14, 14, 0, 1, 1, 0, 420, 630, 0, 158, 1.4, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67879, 67886, 67880, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 9.43467, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(35545, 0, 0, 0, 0, 0, 25528, 0, 25528, 0, 'Risen Jaeren Sunsworn', 'Black Knight\'s Minion', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 0, 420, 630, 0, 158, 1.4, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67774, 67879, 67729, 67886, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 2.5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_risen_ghoul'),
-(35451, 35490, 0, 0, 0, 0, 29837, 0, 29837, 0, 'The Black Knight', '', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 11.8, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 6, 72, 35451, 0, 0, 0, 0, 0, 0, 0, 0, 67724, 67745, 67718, 67725, 0, 0, 0, 0, 0, 0, 9530, 9530, '', 0, 3, 5.95238, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 805257215, 0, 'boss_black_knight'),
-(35490, 0, 0, 0, 0, 0, 29837, 0, 29837, 0, 'The Black Knight', '', '', 0, 80, 80, 0, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 17.6, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 6, 72, 35490, 0, 0, 0, 0, 0, 0, 0, 0, 67884, 68306, 67881, 67883, 0, 0, 0, 0, 0, 0, 10700, 10700, '', 0, 3, 37.7387, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 805257215, 1, ''),
-(35119, 12011, 0, 0, 0, 0, 29616, 0, 29616, 0, 'Eadric the Pure', 'Grand Champion of the Argent Crusade', '', 0, 82, 82, 2, 14, 14, 0, 1, 1, 1, 452, 678, 0, 170, 14.5, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66865, 66863, 66867, 66935, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 42.5, 20, 0, 0, 0, 0, 0, 0, 0, 151, 1, 0, 805257215, 0, 'boss_eadric'),
-(12011, 0, 0, 0, 0, 0, 29616, 0, 29616, 0, 'Eadric the Pure', 'Grand Champion of the Argent Crusade', '', 0, 82, 82, 2, 14, 14, 0, 1, 1, 1, 452, 678, 0, 170, 22.4, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66865, 66863, 66867, 66935, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 42.5, 20, 0, 0, 0, 0, 0, 0, 0, 151, 1, 0, 805257215, 1, ''),
-(34928, 12010, 0, 0, 0, 0, 29490, 0, 29490, 0, 'Argent Confessor Paletress', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 1, 1, 452, 678, 0, 170, 14.5, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66546, 66536, 66515, 66537, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 8, 20, 0, 0, 0, 0, 0, 0, 0, 151, 1, 0, 805257215, 0, 'boss_paletress'),
-(12010, 0, 0, 0, 0, 0, 29490, 0, 29490, 0, 'Argent Confessor Paletress', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 1, 1, 452, 678, 0, 170, 22.4, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66546, 67674, 66515, 67675, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 8, 20, 0, 0, 0, 0, 0, 0, 0, 151, 1, 0, 805257215, 1, ''),
-(35309, 12439, 0, 0, 0, 0, 29762, 29763, 29762, 0, 'Argent Lightwielder', '', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 8.4, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67247, 67290, 15284, 67237, 0, 0, 0, 0, 0, 0, 7651, 7651, '', 0, 3, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_argent_soldier'),
-(12439, 0, 0, 0, 0, 0, 29762, 29763, 29762, 0, 'Argent Lightwielder', '', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 12.6, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67247, 67290, 15284, 67237, 0, 0, 0, 0, 0, 0, 7651, 7651, '', 0, 3, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(35305, 12488, 0, 0, 0, 0, 29758, 29759, 29758, 0, 'Argent Monk', '', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 8, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67251, 67255, 67233, 67235, 0, 0, 0, 0, 0, 0, 7661, 7661, '', 0, 3, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_argent_soldier'),
-(12488, 0, 0, 0, 0, 0, 29758, 29759, 29758, 0, 'Argent Monk', '', '', 0, 80, 80, 0, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 12, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67251, 67255, 67233, 67235, 0, 0, 0, 0, 0, 0, 7661, 7661, '', 0, 3, 23.5867, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(35307, 12448, 0, 0, 0, 0, 29760, 29761, 29760, 0, 'Argent Priestess', '', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 5.5, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67194, 36176, 67289, 67229, 0, 0, 0, 0, 0, 0, 7653, 7653, '', 0, 3, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_argent_soldier'),
-(12448, 0, 0, 0, 0, 0, 29760, 29761, 29760, 0, 'Argent Priestess', '', '', 0, 80, 80, 2, 14, 14, 0, 1, 1, 1, 420, 630, 0, 158, 8.5, 2000, 2000, 2, 0, 0, 0, 0, 0, 0, 0, 336, 504, 126, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67194, 36176, 67289, 67229, 0, 0, 0, 0, 0, 0, 7653, 7653, '', 0, 3, 10, 8, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, '');
--- Memory's Stats
-REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
-(35052, 12446, 0, 0, 0, 0, 29553, 0, 29553, 0, 'Memory of Algalon', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 4, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67679, 67678, 67677, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12446, 0, 0, 0, 0, 0, 29553, 0, 29553, 0, 'Memory of Algalon', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 4, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67679, 67678, 67677, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35041, 12486, 0, 0, 0, 0, 29546, 0, 29546, 0, 'Memory of Archimonde', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 3, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12486, 0, 0, 0, 0, 0, 29546, 0, 29546, 0, 'Memory of Archimonde', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 3, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35033, 12438, 0, 0, 0, 0, 14367, 0, 14367, 0, 'Memory of Chromaggus', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 2, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12438, 0, 0, 0, 0, 0, 14367, 0, 14367, 0, 'Memory of Chromaggus', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 2, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35046, 12451, 0, 0, 0, 0, 29549, 0, 29549, 0, 'Memory of Cyanigosa', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 2, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12451, 0, 0, 0, 0, 0, 29549, 0, 29549, 0, 'Memory of Cyanigosa', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 2, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35043, 12482, 0, 0, 0, 0, 18699, 0, 18699, 0, 'Memory of Delrissa', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12482, 0, 0, 0, 0, 0, 18699, 0, 18699, 0, 'Memory of Delrissa', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35047, 12456, 0, 0, 0, 0, 26644, 0, 26644, 0, 'Memory of Eck', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12456, 0, 0, 0, 0, 0, 26644, 0, 26644, 0, 'Memory of Eck', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35044, 12440, 0, 0, 0, 0, 23428, 0, 23428, 0, 'Memory of Entropius', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12440, 0, 0, 0, 0, 0, 23428, 0, 23428, 0, 'Memory of Entropius', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35039, 12725, 0, 0, 0, 0, 18698, 0, 18698, 0, 'Memory of Gruul', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12725, 0, 0, 0, 0, 0, 18698, 0, 18698, 0, 'Memory of Gruul', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35034, 12453, 0, 0, 0, 0, 29540, 0, 29540, 0, 'Memory of Hakkar', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12453, 0, 0, 0, 0, 0, 29540, 0, 29540, 0, 'Memory of Hakkar', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35049, 12455, 0, 0, 0, 0, 29557, 0, 29557, 0, 'Memory of Heigan', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12455, 0, 0, 0, 0, 0, 29557, 0, 29557, 0, 'Memory of Heigan', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35030, 12454, 0, 0, 0, 0, 29537, 0, 29537, 0, 'Memory of Herod', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12454, 0, 0, 0, 0, 0, 29537, 0, 29537, 0, 'Memory of Herod', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(34942, 12484, 0, 0, 0, 0, 29525, 0, 29525, 0, 'Memory of Hogger', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12484, 0, 0, 0, 0, 0, 29525, 0, 29525, 0, 'Memory of Hogger', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35050, 12450, 0, 0, 0, 0, 29185, 0, 29185, 0, 'Memory of Ignis', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 5, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12450, 0, 0, 0, 0, 0, 29185, 0, 29185, 0, 'Memory of Ignis', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 5, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35042, 12442, 0, 0, 0, 0, 29547, 0, 29547, 0, 'Memory of Illidan', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 3, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12442, 0, 0, 0, 0, 0, 29547, 0, 29547, 0, 'Memory of Illidan', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 3, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35045, 12483, 0, 0, 0, 0, 29558, 0, 29558, 0, 'Memory of Ingvar', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12483, 0, 0, 0, 0, 0, 29558, 0, 29558, 0, 'Memory of Ingvar', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 6, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35037, 12437, 0, 0, 0, 0, 29542, 0, 29542, 0, 'Memory of Kalithresh', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66552, 66620, 66619, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29.2313, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12437, 0, 0, 0, 0, 0, 29542, 0, 29542, 0, 'Memory of Kalithresh', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66552, 66620, 66619, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35031, 12441, 0, 0, 0, 0, 29562, 0, 29562, 0, 'Memory of Lucifron', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 66619, 66552, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12441, 0, 0, 0, 0, 0, 29562, 0, 29562, 0, 'Memory of Lucifron', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 66619, 66552, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35038, 12445, 0, 0, 0, 0, 29543, 0, 29543, 0, 'Memory of Malchezaar', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 3, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12445, 0, 0, 0, 0, 0, 29543, 0, 29543, 0, 'Memory of Malchezaar', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 3, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35029, 12447, 0, 0, 0, 0, 29556, 0, 29556, 0, 'Memory of Mutanus', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12447, 0, 0, 0, 0, 0, 29556, 0, 29556, 0, 'Memory of Mutanus', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35048, 12449, 0, 0, 0, 0, 21401, 0, 21401, 0, 'Memory of Onyxia', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 2, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12449, 0, 0, 0, 0, 0, 21401, 0, 21401, 0, 'Memory of Onyxia', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 2, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35028, 12485, 0, 0, 0, 0, 29536, 0, 29536, 0, 'Memory of VanCleef', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12485, 0, 0, 0, 0, 0, 29536, 0, 29536, 0, 'Memory of VanCleef', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35040, 12452, 0, 0, 0, 0, 29545, 0, 0, 0, 'Memory of Vashj', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12452, 0, 0, 0, 0, 0, 29545, 0, 29545, 0, 'Memory of Vashj', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 452, 678, 0, 170, 15, 2000, 2000, 1, 0, 0, 0, 0, 0, 0, 0, 362, 542, 136, 7, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35036, 12443, 0, 0, 0, 0, 29541, 0, 29541, 0, 'Memory of Vek\'nilash', '', '', 0, 82, 82, 2, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12443, 0, 0, 0, 0, 0, 29541, 0, 29541, 0, 'Memory of Vek\'nilash', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35051, 12487, 0, 0, 0, 0, 28548, 0, 28548, 0, 'Memory of Vezax', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory'),
-(12487, 0, 0, 0, 0, 0, 28548, 0, 28548, 0, 'Memory of Vezax', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 122.031, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, ''),
-(35032, 0, 0, 0, 0, 0, 14992, 0, 14992, 0, 'Memory of Thunderaan', '', '', 0, 82, 82, 0, 14, 14, 0, 1, 0.5, 1, 330, 495, 0, 124, 20.5, 2000, 2000, 8, 0, 0, 0, 0, 0, 0, 0, 264, 396, 99, 10, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66620, 67679, 66619, 67678, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 29, 25, 0, 0, 0, 0, 0, 0, 0, 150, 1, 0, 617297499, 0, 'npc_memory');
--- Equipment
-UPDATE `creature_template` SET `equipment_id`=2049 WHERE `entry` in (35314,35326,35327,35325,35323,35331,35330,35329,35328,35332);
-UPDATE `creature_template` SET `equipment_id`=2025 WHERE `entry` in (35571,12006);
-UPDATE `creature_template` SET `equipment_id`=2021 WHERE `entry` in (35569,12005);
-UPDATE `creature_template` SET `equipment_id`=2018 WHERE `entry` in (35572,12009);
-UPDATE `creature_template` SET `equipment_id`=2020 WHERE `entry` in (35617,12008);
-UPDATE `creature_template` SET `equipment_id`=2019 WHERE `entry` in (35570,12007);
-UPDATE `creature_template` SET `equipment_id`=2096 WHERE `entry` in (34701,12001);
-UPDATE `creature_template` SET `equipment_id`=2093 WHERE `entry` in (34703,12003);
-UPDATE `creature_template` SET `equipment_id`=2095 WHERE `entry` in (34657,12002);
-UPDATE `creature_template` SET `equipment_id`=2092 WHERE `entry` in (34705,12004);
-UPDATE `creature_template` SET `equipment_id`=834 WHERE `entry` in (35119,12011);
-UPDATE `creature_template` SET `equipment_id`=235 WHERE `entry` in (34928,12010);
-UPDATE `creature_template` SET `equipment_id`=0 WHERE `entry` in (35451,12012);
--- Griphon of black Knight
-REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES 
-(35491, 0, 0, 0, 0, 0, 29842, 0, 0, 0, 'Black Knight\'s Skeletal Gryphon', '', '', 0, 80, 80, 2, 35, 35, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 33554432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1048576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 486, 0, 0, '', 0, 4, 15, 1, 0, 0, 0, 0, 0, 0, 0, 164, 1, 0, 0, 0, 'npc_black_knight_skeletal_gryphon');
-DELETE FROM `script_waypoint` WHERE `entry`=35491;
-INSERT INTO `script_waypoint` VALUES
-(35491,1,781.513062, 657.989624, 466.821472,0,''),
-(35491,2,759.004639, 665.142029, 462.540771,0,''),
-(35491,3,732.936646, 657.163879, 452.678284,0,''),
-(35491,4,717.490967, 646.008545, 440.136902,0,''),
-(35491,5,707.570129, 628.978455, 431.128632,0,''),
-(35491,6,705.164063, 603.628418, 422.956635,0,''),
-(35491,7,716.350891, 588.489746, 420.801666,0,''),
-(35491,8,741.702881, 580.167725, 420.523010,0,''),
-(35491,9,761.634033, 586.382690, 422.206207,0,''),
-(35491,10,775.982666, 601.991943, 423.606079,0,''),
-(35491,11,769.051025, 624.686157, 420.035126,0,''),
-(35491,12,756.582214, 631.692322, 412.529785,0,''),
-(35491,13,744.841,634.505,411.575,0,'');
--- Griphon of black Knight before battle start
-REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES 
-(35492, 0, 0, 0, 0, 0, 29842, 0, 0, 0, 'Black Knight\'s Skeletal Gryphon', '', '', 0, 80, 80, 2, 35, 35, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 33554432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1048576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 486, 0, 0, '', 0, 3, 15, 1, 0, 0, 0, 0, 0, 0, 0, 164, 1, 0, 0, 0, 'npc_gr');
-DELETE FROM `script_waypoint` WHERE `entry`=35492;
-INSERT INTO `script_waypoint` VALUES
-(35492,1,741.067078, 634.471558, 411.569366,0,''),
-(35492,2,735.726196, 639.247498, 414.725555,0,''),
-(35492,3,730.187256, 653.250977, 418.913269,0,''),
-(35492,4,734.517700, 666.071350, 426.259247,0,''),
-(35492,5,739.638489, 675.339417, 438.226776,0,''),
-(35492,6,741.833740, 698.797302, 456.986328,0,''),
-(35492,7,734.647339, 711.084778, 467.165314,0,''),
-(35492,8,715.388489, 723.820862, 470.333588,0,''),
-(35492,9,687.178711, 730.140503, 470.569336,0,'');
--- Announcer for start event
-DELETE FROM `creature_template` WHERE `entry` in (35591,35592);
-INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES 
-(35591, 0, 0, 0, 0, 0, 29894, 0, 0, 0, 'Jaeren Sunsworn', '', '', 0, 75, 75, 2, 14, 14, 0, 1, 1, 0, 0, 0, 0, 0, 1, 2000, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_anstart'),
-(35592, 0, 0, 0, 0, 0, 29893, 0, 0, 0, 'Arelas Brightstar', '', '', 0, 75, 75, 2, 14, 14, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 512, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 'npc_anstart');
--- Spawn Announcer in normal/heroic mode
-DELETE FROM `creature` WHERE `id`=35004;
-DELETE FROM `creature` WHERE `guid` in (180100);
-INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`DeathState`,`MovementType`) VALUES
-(180100, 35591, 650, 3, 1, 0, 0, 746.626, 618.54, 411.09, 4.63158, 86400, 0, 0, 10635, 0, 0, 0);
--- Addons
-REPLACE INTO `creature_template_addon` VALUES
--- Argent
-(35309, 0, 0, 0, 1, 0, '63501 0'),
-(12439, 0, 0, 0, 1, 0, '63501 0'),
-(35305, 0, 0, 0, 1, 0, '63501 0'),
-(12488, 0, 0, 0, 1, 0, '63501 0'),
-(35307, 0, 0, 0, 1, 0, '63501 0'),
-(12448, 0, 0, 0, 1, 0, '63501 0'),
-(35119, 0, 0, 0, 1, 0, '63501 0'),
-(12011, 0, 0, 0, 1, 0, '63501 0'),
-(34928, 0, 0, 0, 1, 0, '63501 0'),
-(12010, 0, 0, 0, 1, 0, '63501 0'),
--- Faction_champ
-(35323, 0, 0, 0, 1, 0, '63399 0 62852 0 64723 0'),
-(35570, 0, 0, 0, 1, 0, '63399 0 62852 0 64723 0'),
-(12007, 0, 0, 0, 1, 0, '63399 0 62852 0 64723 0'),
-(35326, 0, 0, 0, 1, 0, '63403 0 62852 0 64723 0'),
-(35569, 0, 0, 0, 1, 0, '63403 0 62852 0 64723 0'),
-(12005, 0, 0, 0, 1, 0, '63403 0 62852 0 64723 0'),
-(35314, 0, 0, 0, 1, 0, '63433 0 62852 0 64723 0'),
-(35572, 0, 0, 0, 1, 0, '63433 0 62852 0 64723 0'),
-(12009, 0, 0, 0, 1, 0, '63433 0 62852 0 64723 0'),
-(35325, 0, 0, 0, 1, 0, '63436 0 62852 0 64723 0'),
-(35571, 0, 0, 0, 1, 0, '63436 0 62852 0 64723 0'),
-(12006, 0, 0, 0, 1, 0, '63436 0 62852 0 64723 0'),
-(35329, 0, 0, 0, 1, 0, '63427 0 62852 0 64723 0'),
-(34703, 0, 0, 0, 1, 0, '63427 0 62852 0 64723 0'),
-(12003, 0, 0, 0, 1, 0, '63427 0 62852 0 64723 0'),
-(35331, 0, 0, 0, 1, 0, '63396 0 62852 0 64723 0'),
-(34702, 0, 0, 0, 1, 0, '63396 0 62852 0 64723 0'),
-(12000, 0, 0, 0, 1, 0, '63396 0 62852 0 64723 0'),
-(35327, 0, 0, 0, 1, 0, '63430 0 62852 0 64723 0'),
-(35617, 0, 0, 0, 1, 0, '63430 0 62852 0 64723 0'),
-(12008, 0, 0, 0, 1, 0, '63430 0 62852 0 64723 0'),
-(35328, 0, 0, 0, 1, 0, '62594 0 62852 0 64723 0'),
-(34705, 0, 0, 0, 1, 0, '62594 0 62852 0 64723 0'),
-(12004, 0, 0, 0, 1, 0, '62594 0 62852 0 64723 0'),
-(35330, 0, 0, 0, 1, 0, '63423 0 62852 0 64723 0'),
-(34701, 0, 0, 0, 1, 0, '63423 0 62852 0 64723 0'),
-(12001, 0, 0, 0, 1, 0, '63423 0 62852 0 64723 0'),
-(35332, 0, 0, 0, 1, 0, '63406 0 62852 0 64723 0'),
-(12002, 0, 0, 0, 1, 0, '63406 0 62852 0 64723 0'),
-(34657, 0, 0, 0, 1, 0, '63406 0 62852 0 64723 0');
--- Argent Warhorse
-UPDATE `creature_template` SET `VehicleId` =486 WHERE `entry` =35644;
--- Immunes (crash fix xD )
-UPDATE `creature_template` SET `mechanic_immune_mask`=`mechanic_immune_mask`|1073741823 WHERE `entry` IN
-(35309,12439, -- Argent Lightwielder
-35305,12488, -- Argent Monk
-35307,12448); -- Argent Priestess
\ No newline at end of file
diff --git a/sql/Greedy-core/world/error-fix.sql b/sql/Greedy-core/world/error-fix.sql
--- a/sql/Greedy-core/world/error-fix.sql
+++ b/sql/Greedy-core/world/error-fix.sql
@@ -1,5 +1,5 @@
 delete from `conditions` where `sourceEntry`='64468 ';
-DELETE FROM `creature_template` WHERE `entry` between "200000" AND "300004";
+DELETE FROM `creature_template` WHERE `entry` between "200000" AND "200016";
 INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `Health_mod`, `Mana_mod`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `equipment_id`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
 
 (200000, 0, 0, 0, 0, 0, '6097', 0, 0, 0, 'Axe 1h/Axe 2h', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
@@ -21,22 +21,8 @@
 (200013, 0, 0, 0, 0, 0, '6699', 0, 0, 0, 'Necklace', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
 (200014, 0, 0, 0, 0, 0, '6699', 0, 0, 0, 'Ring', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
 (200015, 0, 0, 0, 0, 0, '6699', 0, 0, 0, 'Trinket', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200016, 0, 0, 0, 0, 0, '6699', 0, 0, 0, 'Cloak', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200017, 0, 0, 0, 0, 0, '6699', 0, 0, 0, 'Shirt/Tabard', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
+(200016, 0, 0, 0, 0, 0, '6699', 0, 0, 0, 'Cloak', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, '');
 
-(200018, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Consumable', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200019, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Food', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200020, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Potions', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200021, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Elixir', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200022, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Flask', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200023, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Scroll', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200025, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Enchancement',  'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200026, 0, 0, 0, 0, 0, '17067', 0, 0, 0, 'Bandage',  'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-
-(200027, 0, 0, 0, 0, 0, '10433', 0, 0, 0, 'Red gem', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200028, 0, 0, 0, 0, 0, '10433', 0, 0, 0, 'Blue gem', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200029, 0, 0, 0, 0, 0, '10433', 0, 0, 0, 'Yellow gem', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, ''),
-(200030, 0, 0, 0, 0, 0, '10433', 0, 0, 0, 'Purple gem', 'Sacred-wow', '', 0, 90, 90, 0, 35, 35, 4224, 1, 1, 20000, 20000, 0, 20000, 1, 0, 200, 0, 0, 0, 0, 0, 0, 0, 0, 20000, 20000, 2000, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, '');
 UPDATE `creature_template` SET `ScriptName` = 'npc_image_of_medivh' WHERE `entry` = 200000;
 UPDATE `creature_template` SET `ScriptName` = 'mob_high_inquisitor_valroth' WHERE `entry` = 200001;
 UPDATE `creature_template` SET `ScriptName` = 'npc_geezle' WHERE `entry` = 200002;
@@ -44,63 +30,22 @@
 UPDATE `creature_template` SET `ScriptName` = 'npc_bloodmaul_brutebane' WHERE `entry` = 200004;
 UPDATE `creature_template` SET `ScriptName` = 'npc_colossus' WHERE `entry` = 200005;
 UPDATE `creature_template` SET `ScriptName` = 'npc_lorekeeper' WHERE `entry` = 200006;
-UPDATE `creature_template` SET `ScriptName` = 'mob_right_arm' WHERE `entry` = 200007;
-UPDATE `creature_template` SET `ScriptName` = 'npc_raging_gnoul' WHERE `entry` = 200008;
-UPDATE `creature_template` SET `ScriptName` = 'npc_risen_witch_doctor' WHERE `entry` = 200009;
-UPDATE `creature_template` SET `ScriptName` = 'npc_abon' WHERE `entry` = 200010;
-UPDATE `creature_template` SET `ScriptName` = 'npc_coldflame' WHERE `entry` = 200011;
-UPDATE `creature_template` SET `ScriptName` = 'npc_cult_fanatic' WHERE `entry` = 200012;
-UPDATE `creature_template` SET `ScriptName` = 'npc_cult_adherent' WHERE `entry` = 200013;
-UPDATE `creature_template` SET `ScriptName` = 'npc_vengeful_shade' WHERE `entry` = 200014;
-UPDATE `creature_template` SET `ScriptName` = 'boss_deathbringer_saurfang' WHERE `entry` = 200015;
-UPDATE `creature_template` SET `ScriptName` = 'npc_high_overlord_saurfang_icc' WHERE `entry` = 200016;
-UPDATE `creature_template` SET `ScriptName` = 'npc_muradin_bronzebeard_icc' WHERE `entry` = 200017;
-UPDATE `creature_template` SET `ScriptName` = 'npc_mageguard_dalaran' WHERE `entry` = 200018;
-UPDATE `creature_template` SET `ScriptName` = 'npc_sinkhole_kill_credit' WHERE `entry` = 200019;
-UPDATE `creature_template` SET `ScriptName` = 'mob_nerubar_victim' WHERE `entry` = 200020;
-UPDATE `creature_template` SET `ScriptName` = 'npc_beryl_sorcerer' WHERE `entry` = 200021;
-UPDATE `creature_template` SET `ScriptName` = 'npc_magmoth_crusher' WHERE `entry` = 200022;
-UPDATE `creature_template` SET `ScriptName` = 'npc_gymer' WHERE `entry` = 200023;
-UPDATE `creature_template` SET `ScriptName` = 'spell_marrowgar_bone_spike_graveyard' WHERE `entry` = 200025;
-UPDATE `creature_template` SET `ScriptName` = 'spell_marrowgar_bone_storm' WHERE `entry` = 200026;
-UPDATE `creature_template` SET `ScriptName` = 'spell_cultist_dark_martyrdom' WHERE `entry` = 200027;
-UPDATE `creature_template` SET `ScriptName` = 'spell_marrowgar_coldflame' WHERE `entry` = 200028;
-UPDATE `creature_template` SET `ScriptName` = 'npc_myradin_icc' WHERE `entry` = 200029;
+UPDATE `creature_template` SET `ScriptName` = 'npc_raging_gnoul' WHERE `entry` = 200007;
+UPDATE `creature_template` SET `ScriptName` = 'npc_risen_witch_doctor' WHERE `entry` = 200008;
+UPDATE `creature_template` SET `ScriptName` = 'npc_abon' WHERE `entry` = 200009;
+UPDATE `creature_template` SET `ScriptName` = 'npc_myradin_icc' WHERE `entry` = 200010;
+UPDATE `creature_template` SET `ScriptName` = 'npc_mageguard_dalaran' WHERE `entry` = 200011;
+UPDATE `creature_template` SET `ScriptName` = 'mob_nerubar_victim' WHERE `entry` = 200012;
+UPDATE `creature_template` SET `ScriptName` = 'npc_sinkhole_kill_credit' WHERE `entry` = 200013;
+UPDATE `creature_template` SET `ScriptName` = 'npc_beryl_sorcerer' WHERE `entry` = 200014;
+UPDATE `creature_template` SET `ScriptName` = 'npc_magmoth_crusher' WHERE `entry` = 200015;
+UPDATE `creature_template` SET `ScriptName` = 'npc_gymer' WHERE `entry` = 200016;
 
-DELETE FROM `creature` where `guid` ='86025';
-DELETE FROM `creature` where `guid` ='124255';
-DELETE FROM `creature` where `guid` ='124254';
-DELETE FROM `creature` where `guid` ='124253';
-DELETE FROM `creature` where `guid` ='124252';
-DELETE FROM `creature` where `guid` ='124251';
-DELETE FROM `creature` where `guid` ='124256';
-DELETE FROM `creature` where `guid` ='124257';
-DELETE FROM `creature` where `guid` ='124258';
-DELETE FROM `creature` where `guid` ='124259';
-DELETE FROM `creature` where `guid` ='124260';
-DELETE FROM `creature` where `guid` ='124261';
-DELETE FROM `creature` where `guid` ='124262';
-DELETE FROM `creature` where `guid` ='124263';
-DELETE FROM `creature` where `guid` ='123498';
-DELETE FROM `creature` where `guid` ='123499';
-DELETE FROM `creature` where `guid` ='123500';
-DELETE FROM `creature` where `guid` ='86025';
 
-DELETE FROM `creature_addon` where `guid` ='124255';
-DELETE FROM `creature_addon` where `guid` ='124254';
-DELETE FROM `creature_addon` where `guid` ='124253';
-DELETE FROM `creature_addon` where `guid` ='124252';
-DELETE FROM `creature_addon` where `guid` ='124251';
-DELETE FROM `creature_addon` where `guid` ='124256';
-DELETE FROM `creature_addon` where `guid` ='124257';
-DELETE FROM `creature_addon` where `guid` ='124258';
-DELETE FROM `creature_addon` where `guid` ='124259';
-DELETE FROM `creature_addon` where `guid` ='124260';
-DELETE FROM `creature_addon` where `guid` ='124261';
-DELETE FROM `creature_addon` where `guid` ='124262';
-DELETE FROM `creature_addon` where `guid` ='124263';
-DELETE FROM `creature_addon` where `guid` ='123498';
-DELETE FROM `creature_addon` where `guid` ='123499';
-DELETE FROM `creature_addon` where `guid` ='123500';
 
-UPDATE `creature_template` SET `minlevel`=80,`maxlevel`=80,`unit_class`=1,`exp`=2 WHERE entry>199999 and entry<200031;
\ No newline at end of file
+
+
+UPDATE `creature_template` SET `minlevel`=80,`maxlevel`=80,`unit_class`=1,`exp`=2 WHERE entry>199999 and entry<200017;
+
+DELETE FROM `gameobject_loot_template` WHERE entry IN (26094,26097);
+DELETE FROM `reference_loot_template` WHERE entry IN (50008,50009);
\ No newline at end of file
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -1,16995 +1,17011 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Common.h"
-#include "CreatureAIImpl.h"
-#include "Log.h"
-#include "Opcodes.h"
-#include "WorldPacket.h"
-#include "WorldSession.h"
-#include "World.h"
-#include "ObjectMgr.h"
-#include "SpellMgr.h"
-#include "Unit.h"
-#include "QuestDef.h"
-#include "Player.h"
-#include "Creature.h"
-#include "Spell.h"
-#include "Group.h"
-#include "SpellAuras.h"
-#include "SpellAuraEffects.h"
-#include "MapManager.h"
-#include "ObjectAccessor.h"
-#include "CreatureAI.h"
-#include "Formulas.h"
-#include "Pet.h"
-#include "Util.h"
-#include "Totem.h"
-#include "Battleground.h"
-#include "OutdoorPvP.h"
-#include "InstanceSaveMgr.h"
-#include "GridNotifiersImpl.h"
-#include "CellImpl.h"
-#include "Path.h"
-#include "CreatureGroups.h"
-#include "PetAI.h"
-#include "PassiveAI.h"
-#include "Traveller.h"
-#include "TemporarySummon.h"
-#include "Vehicle.h"
-#include "Transport.h"
-
-#include <math.h>
-
-float baseMoveSpeed[MAX_MOVE_TYPE] =
-{
-    2.5f,                  // MOVE_WALK
-    7.0f,                  // MOVE_RUN
-    2.5f,                  // MOVE_RUN_BACK
-    4.722222f,             // MOVE_SWIM
-    4.5f,                  // MOVE_SWIM_BACK
-    3.141594f,             // MOVE_TURN_RATE
-    7.0f,                  // MOVE_FLIGHT
-    4.5f,                  // MOVE_FLIGHT_BACK
-    3.14f                  // MOVE_PITCH_RATE
-};
-float playerBaseMoveSpeed[MAX_MOVE_TYPE] = {
-    2.5f,                  // MOVE_WALK
-    7.0f,                  // MOVE_RUN
-    2.5f,                  // MOVE_RUN_BACK
-    4.722222f,             // MOVE_SWIM
-    4.5f,                  // MOVE_SWIM_BACK
-    3.141594f,             // MOVE_TURN_RATE
-    7.0f,                  // MOVE_FLIGHT
-    4.5f,                  // MOVE_FLIGHT_BACK
-    3.14f                  // MOVE_PITCH_RATE
-};
-
-// Used for prepare can/can`t triggr aura
-static bool InitTriggerAuraData();
-// Define can trigger auras
-static bool isTriggerAura[TOTAL_AURAS];
-// Define can`t trigger auras (need for disable second trigger)
-static bool isNonTriggerAura[TOTAL_AURAS];
-// Triggered always, even from triggered spells
-static bool isAlwaysTriggeredAura[TOTAL_AURAS];
-// Prepare lists
-static bool procPrepared = InitTriggerAuraData();
-
-// we can disable this warning for this since it only
-// causes undefined behavior when passed to the base class constructor
-#ifdef _MSC_VER
-#pragma warning(disable:4355)
-#endif
-Unit::Unit(): WorldObject(),
-m_movedPlayer(NULL), IsAIEnabled(false), NeedChangeAI(false),
-m_ControlledByPlayer(false), i_AI(NULL), i_disabledAI(NULL), m_procDeep(0),
-m_removedAurasCount(0), i_motionMaster(this), m_ThreatManager(this), m_vehicle(NULL),
-m_vehicleKit(NULL), m_unitTypeMask(UNIT_MASK_NONE), m_HostileRefManager(this)
-{
-#ifdef _MSC_VER
-#pragma warning(default:4355)
-#endif
-    m_objectType |= TYPEMASK_UNIT;
-    m_objectTypeId = TYPEID_UNIT;
-
-    m_updateFlag = (UPDATEFLAG_HIGHGUID | UPDATEFLAG_LIVING | UPDATEFLAG_HAS_POSITION);
-
-    m_attackTimer[BASE_ATTACK] = 0;
-    m_attackTimer[OFF_ATTACK] = 0;
-    m_attackTimer[RANGED_ATTACK] = 0;
-    m_modAttackSpeedPct[BASE_ATTACK] = 1.0f;
-    m_modAttackSpeedPct[OFF_ATTACK] = 1.0f;
-    m_modAttackSpeedPct[RANGED_ATTACK] = 1.0f;
-
-    m_extraAttacks = 0;
-    m_canDualWield = false;
-
-    m_rootTimes = 0;
-
-    m_state = 0;
-    m_form = FORM_NONE;
-    m_deathState = ALIVE;
-
-    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
-        m_currentSpells[i] = NULL;
-
-    m_addDmgOnce = 0;
-
-    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
-        m_SummonSlot[i] = 0;
-
-    m_ObjectSlot[0] = m_ObjectSlot[1] = m_ObjectSlot[2] = m_ObjectSlot[3] = 0;
-
-    m_auraUpdateIterator = m_ownedAuras.end();
-    m_Visibility = VISIBILITY_ON;
-
-    m_interruptMask = 0;
-    m_detectInvisibilityMask = 0;
-    m_invisibilityMask = 0;
-    m_transform = 0;
-    m_ShapeShiftFormSpellId = 0;
-    m_canModifyStats = false;
-
-    for (uint8 i = 0; i < MAX_SPELL_IMMUNITY; ++i)
-        m_spellImmune[i].clear();
-    for (uint8 i = 0; i < UNIT_MOD_END; ++i)
-    {
-        m_auraModifiersGroup[i][BASE_VALUE] = 0.0f;
-        m_auraModifiersGroup[i][BASE_PCT] = 1.0f;
-        m_auraModifiersGroup[i][TOTAL_VALUE] = 0.0f;
-        m_auraModifiersGroup[i][TOTAL_PCT] = 1.0f;
-    }
-                                                            // implement 50% base damage from offhand
-    m_auraModifiersGroup[UNIT_MOD_DAMAGE_OFFHAND][TOTAL_PCT] = 0.5f;
-
-    for (uint8 i = 0; i < MAX_ATTACK; ++i)
-    {
-        m_weaponDamage[i][MINDAMAGE] = BASE_MINDAMAGE;
-        m_weaponDamage[i][MAXDAMAGE] = BASE_MAXDAMAGE;
-    }
-    for (uint8 i = 0; i < MAX_STATS; ++i)
-        m_createStats[i] = 0.0f;
-
-    m_attacking = NULL;
-    m_modMeleeHitChance = 0.0f;
-    m_modRangedHitChance = 0.0f;
-    m_modSpellHitChance = 0.0f;
-    m_baseSpellCritChance = 5;
-
-    m_CombatTimer = 0;
-    m_lastManaUse = 0;
-
-    //m_victimThreat = 0.0f;
-    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
-        m_threatModifier[i] = 1.0f;
-    m_isSorted = true;
-    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
-        m_speed_rate[i] = 1.0f;
-
-    m_charmInfo = NULL;
-    //m_unit_movement_flags = 0;
-    m_reducedThreatPercent = 0;
-    m_misdirectionTargetGUID = 0;
-
-    // remove aurastates allowing special moves
-    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
-        m_reactiveTimer[i] = 0;
-
-    m_cleanupDone = false;
-    m_duringRemoveFromWorld = false;
-}
-
-Unit::~Unit()
-{
-    // set current spells as deletable
-    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
-    {
-        if (m_currentSpells[i])
-        {
-            m_currentSpells[i]->SetReferencedFromCurrent(false);
-            m_currentSpells[i] = NULL;
-        }
-    }
-
-    RemoveAllGameObjects();
-    RemoveAllDynObjects();
-    _DeleteRemovedAuras();
-
-    delete m_charmInfo;
-    delete m_vehicleKit;
-
-    ASSERT(!m_duringRemoveFromWorld);
-    ASSERT(!m_attacking);
-    ASSERT(m_attackers.empty());
-    ASSERT(m_sharedVision.empty());
-    ASSERT(m_Controlled.empty());
-    ASSERT(m_appliedAuras.empty());
-    ASSERT(m_ownedAuras.empty());
-    ASSERT(m_removedAuras.empty());
-}
-
-void Unit::Update(uint32 p_time)
-{
-    // WARNING! Order of execution here is important, do not change.
-    // Spells must be processed with event system BEFORE they go to _UpdateSpells.
-    // Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.
-    m_Events.Update(p_time);
-
-    if (!IsInWorld())
-        return;
-
-    _UpdateSpells(p_time);
-
-    // If this is set during update SetCantProc(false) call is missing somewhere in the code
-    // Having this would prevent spells from being proced, so let's crash
-    ASSERT(!m_procDeep);
-
-    if (CanHaveThreatList() && getThreatManager().isNeedUpdateToClient(p_time))
-        SendThreatListUpdate();
-
-    // update combat timer only for players and pets (only pets with PetAI)
-    if (isInCombat() && (GetTypeId() == TYPEID_PLAYER || (ToCreature()->isPet() && IsControlledByPlayer())))
-    {
-        // Check UNIT_STAT_MELEE_ATTACKING or UNIT_STAT_CHASE (without UNIT_STAT_FOLLOW in this case) so pets can reach far away
-        // targets without stopping half way there and running off.
-        // These flags are reset after target dies or another command is given.
-        if (m_HostileRefManager.isEmpty())
-        {
-            // m_CombatTimer set at aura start and it will be freeze until aura removing
-            if (m_CombatTimer <= p_time)
-                ClearInCombat();
-            else
-                m_CombatTimer -= p_time;
-        }
-    }
-
-    //not implemented before 3.0.2
-    //if (!hasUnitState(UNIT_STAT_CASTING))
-    {
-        if (uint32 base_att = getAttackTimer(BASE_ATTACK))
-            setAttackTimer(BASE_ATTACK, (p_time >= base_att ? 0 : base_att - p_time));
-        if (uint32 ranged_att = getAttackTimer(RANGED_ATTACK))
-            setAttackTimer(RANGED_ATTACK, (p_time >= ranged_att ? 0 : ranged_att - p_time));
-        if (uint32 off_att = getAttackTimer(OFF_ATTACK))
-            setAttackTimer(OFF_ATTACK, (p_time >= off_att ? 0 : off_att - p_time));
-    }
-
-    // update abilities available only for fraction of time
-    UpdateReactives(p_time);
-
-    ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, HealthBelowPct(20));
-    ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, HealthBelowPct(35));
-    ModifyAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT, HealthAbovePct(75));
-
-    i_motionMaster.UpdateMotion(p_time);
-}
-
-bool Unit::haveOffhandWeapon() const
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-        return this->ToPlayer()->GetWeaponForAttack(OFF_ATTACK,true);
-    else
-        return m_canDualWield;
-}
-
-void Unit::SendMonsterMoveWithSpeedToCurrentDestination(Player* player)
-{
-    float x, y, z;
-    if (GetMotionMaster()->GetDestination(x, y, z))
-        SendMonsterMoveWithSpeed(x, y, z, 0, player);
-}
-
-
-void Unit::SendMonsterMoveWithSpeed(float x, float y, float z, uint32 transitTime, Player* player)
-{
-    if (!transitTime)
-    {
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            Traveller<Player> traveller(*(Player*)this);
-            transitTime = traveller.GetTotalTrevelTimeTo(x,y,z);
-        }
-        else
-        {
-            Traveller<Creature> traveller(*this->ToCreature());
-            transitTime = traveller.GetTotalTrevelTimeTo(x,y,z);
-        }
-    }
-    //float orientation = (float)atan2((double)dy, (double)dx);
-    SendMonsterMove(x, y, z, transitTime, player);
-}
-
-void Unit::SendMonsterStop(bool on_death)
-{
-    WorldPacket data(SMSG_MONSTER_MOVE, (17 + GetPackGUID().size()));
-    data.append(GetPackGUID());
-    data << uint8(0);                                       // new in 3.1
-    data << GetPositionX() << GetPositionY() << GetPositionZ();
-    data << getMSTime();
-
-    if (on_death == true)
-    {
-        data << uint8(0);
-        data << uint32((GetUnitMovementFlags() & MOVEMENTFLAG_LEVITATING) ? SPLINEFLAG_FLYING : SPLINEFLAG_WALKING);
-        data << uint32(0);                                      // Time in between points
-        data << uint32(1);                                      // 1 single waypoint
-        data << GetPositionX() << GetPositionY() << GetPositionZ();
-    }
-    else
-        data << uint8(1);
-
-    SendMessageToSet(&data, true);
-
-    clearUnitState(UNIT_STAT_MOVE);
-}
-
-void Unit::SendMonsterMove(float NewPosX, float NewPosY, float NewPosZ, uint32 Time, Player* player)
-{
-    WorldPacket data(SMSG_MONSTER_MOVE, 1+12+4+1+4+4+4+12+GetPackGUID().size());
-    data.append(GetPackGUID());
-
-    data << uint8(0);                                       // new in 3.1
-    data << GetPositionX() << GetPositionY() << GetPositionZ();
-    data << getMSTime();
-
-    data << uint8(0);
-    data << uint32((GetUnitMovementFlags() & MOVEMENTFLAG_LEVITATING) ? SPLINEFLAG_FLYING : SPLINEFLAG_WALKING);
-    data << Time;                                           // Time in between points
-    data << uint32(1);                                      // 1 single waypoint
-    data << NewPosX << NewPosY << NewPosZ;                  // the single waypoint Point B
-
-    if (player)
-        player->GetSession()->SendPacket(&data);
-    else
-        SendMessageToSet(&data, true);
-
-    addUnitState(UNIT_STAT_MOVE);
-}
-
-void Unit::SendMonsterMove(float NewPosX, float NewPosY, float NewPosZ, uint32 MoveFlags, uint32 time, float speedZ, Player *player)
-{
-    WorldPacket data(SMSG_MONSTER_MOVE, 12+4+1+4+4+4+12+GetPackGUID().size());
-    data.append(GetPackGUID());
-
-    data << uint8(0);                                       // new in 3.1
-    data << GetPositionX() << GetPositionY() << GetPositionZ();
-    data << getMSTime();
-
-    data << uint8(0);
-    data << MoveFlags;
-
-    if (MoveFlags & SPLINEFLAG_TRAJECTORY)
-    {
-        data << time;
-        data << speedZ;
-        data << (uint32)0; // walk time after jump
-    }
-    else
-        data << time;
-
-    data << uint32(1);                                      // 1 single waypoint
-    data << NewPosX << NewPosY << NewPosZ;                  // the single waypoint Point B
-
-    if (player)
-        player->GetSession()->SendPacket(&data);
-    else
-        SendMessageToSet(&data, true);
-}
-
-void Unit::SendMonsterMoveTransport(Unit *vehicleOwner)
-{
-    WorldPacket data(SMSG_MONSTER_MOVE_TRANSPORT, GetPackGUID().size()+vehicleOwner->GetPackGUID().size());
-    data.append(GetPackGUID());
-    data.append(vehicleOwner->GetPackGUID());
-    data << int8(GetTransSeat());
-    data << uint8(0);
-    data << GetPositionX() - vehicleOwner->GetPositionX();
-    data << GetPositionY() - vehicleOwner->GetPositionY();
-    data << GetPositionZ() - vehicleOwner->GetPositionZ();
-    data << uint32(getMSTime());
-    data << uint8(4);
-    data << GetTransOffsetO();
-    data << uint32(SPLINEFLAG_TRANSPORT);
-    data << uint32(0);// move time
-    data << uint32(0);//GetTransOffsetX();
-    data << uint32(0);//GetTransOffsetY();
-    data << uint32(0);//GetTransOffsetZ();
-    SendMessageToSet(&data, true);
-}
-
-void Unit::resetAttackTimer(WeaponAttackType type)
-{
-    m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type]);
-}
-
-bool Unit::IsWithinCombatRange(const Unit *obj, float dist2compare) const
-{
-    if (!obj || !IsInMap(obj)) return false;
-
-    float dx = GetPositionX() - obj->GetPositionX();
-    float dy = GetPositionY() - obj->GetPositionY();
-    float dz = GetPositionZ() - obj->GetPositionZ();
-    float distsq = dx*dx + dy*dy + dz*dz;
-
-    float sizefactor = GetCombatReach() + obj->GetCombatReach();
-    float maxdist = dist2compare + sizefactor;
-
-    return distsq < maxdist * maxdist;
-}
-
-bool Unit::IsWithinMeleeRange(const Unit *obj, float dist) const
-{
-    if (!obj || !IsInMap(obj)) return false;
-
-    float dx = GetPositionX() - obj->GetPositionX();
-    float dy = GetPositionY() - obj->GetPositionY();
-    float dz = GetPositionZ() - obj->GetPositionZ();
-    float distsq = dx*dx + dy*dy + dz*dz;
-
-    float sizefactor = GetMeleeReach() + obj->GetMeleeReach();
-    float maxdist = dist + sizefactor;
-
-    return distsq < maxdist * maxdist;
-}
-
-void Unit::GetRandomContactPoint(const Unit* obj, float &x, float &y, float &z, float distance2dMin, float distance2dMax) const
-{
-    float combat_reach = GetCombatReach();
-    if (combat_reach < 0.1) // sometimes bugged for players
-    {
-        //sLog.outError("Unit %u (Type: %u) has invalid combat_reach %f",GetGUIDLow(),GetTypeId(),combat_reach);
-        //if (GetTypeId() == TYPEID_UNIT)
-        //    sLog.outError("Creature entry %u has invalid combat_reach", this->ToCreature()->GetEntry());
-        combat_reach = DEFAULT_COMBAT_REACH;
-    }
-    uint32 attacker_number = getAttackers().size();
-    if (attacker_number > 0)
-        --attacker_number;
-    GetNearPoint(obj,x,y,z,obj->GetCombatReach(), distance2dMin+(distance2dMax-distance2dMin)*(float)rand_norm()
-        , GetAngle(obj) + (attacker_number ? (static_cast<float>(M_PI/2) - static_cast<float>(M_PI) * (float)rand_norm()) * float(attacker_number) / combat_reach * 0.3f : 0));
-}
-
-void Unit::UpdateInterruptMask()
-{
-    m_interruptMask = 0;
-    for (AuraApplicationList::const_iterator i = m_interruptableAuras.begin(); i != m_interruptableAuras.end(); ++i)
-        m_interruptMask |= (*i)->GetBase()->GetSpellProto()->AuraInterruptFlags;
-
-    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
-        if (spell->getState() == SPELL_STATE_CASTING)
-            m_interruptMask |= spell->m_spellInfo->ChannelInterruptFlags;
-}
-
-bool Unit::HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const
-{
-    if (!HasAuraType(auraType))
-        return false;
-    AuraEffectList const &auras = GetAuraEffectsByType(auraType);
-    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-        if (SpellEntry const *iterSpellProto = (*itr)->GetSpellProto())
-            if (iterSpellProto->SpellFamilyName == familyName && iterSpellProto->SpellFamilyFlags[0] & familyFlags)
-                return true;
-    return false;
-}
-
-void Unit::DealDamageMods(Unit *pVictim, uint32 &damage, uint32* absorb)
-{
-    if (!pVictim->isAlive() || pVictim->hasUnitState(UNIT_STAT_UNATTACKABLE) || (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode()))
-    {
-        if (absorb)
-            *absorb += damage;
-        damage = 0;
-        return;
-    }
-
-    //You don't lose health from damage taken from another player while in a sanctuary
-    //You still see it in the combat log though
-    if (pVictim != this && IsControlledByPlayer() && pVictim->IsControlledByPlayer())
-    {
-        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
-        if (area && area->IsSanctuary())      //sanctuary
-        {
-            if (absorb)
-                *absorb += damage;
-            damage = 0;
-        }
-    }
-
-    uint32 originalDamage = damage;
-
-    if (absorb && originalDamage > damage)
-        *absorb += (originalDamage - damage);
-}
-
-uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellEntry const *spellProto, bool durabilityLoss)
-{
-    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsAIEnabled)
-        pVictim->ToCreature()->AI()->DamageTaken(this, damage);
-
-    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->IsAIEnabled)
-        this->ToCreature()->AI()->DamageDealt(pVictim, damage);
-
-    if (damagetype != NODAMAGE)
-    {
-        // interrupting auras with AURA_INTERRUPT_FLAG_DAMAGE before checking !damage (absorbed damage breaks that type of auras)
-        pVictim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TAKE_DAMAGE, spellProto ? spellProto->Id : 0);
-
-        // copy damage to casters of this aura
-        AuraEffectList const& vCopyDamage = pVictim->GetAuraEffectsByType(SPELL_AURA_SHARE_DAMAGE_PCT);
-        for (AuraEffectList::const_iterator i = vCopyDamage.begin(); i != vCopyDamage.end(); ++i)
-        {
-            // check damage school mask
-            if (((*i)->GetMiscValue() & damageSchoolMask) == 0)
-                continue;
-
-            Unit * shareDamageTarget = (*i)->GetCaster();
-            if (!shareDamageTarget)
-                continue;
-            SpellEntry const * spell = (*i)->GetSpellProto();
-
-            uint32 share = uint32(damage * (float((*i)->GetAmount()) / 100.0f));
-
-            // TODO: check packets if damage is done by pVictim, or by attacker of pVictim
-            DealDamageMods(shareDamageTarget, share, NULL);
-            DealDamage(shareDamageTarget, share, NULL, NODAMAGE, GetSpellSchoolMask(spell), spell, false);
-        }
-    }
-
-    // Rage from Damage made (only from direct weapon damage)
-    if (cleanDamage && damagetype == DIRECT_DAMAGE && this != pVictim && getPowerType() == POWER_RAGE)
-    {
-        uint32 weaponSpeedHitFactor;
-        uint32 rage_damage = damage + cleanDamage->absorbed_damage;
-
-        switch(cleanDamage->attackType)
-        {
-            case BASE_ATTACK:
-            {
-                weaponSpeedHitFactor = uint32(GetAttackTime(cleanDamage->attackType) / 1000.0f * 3.5f);
-                if (cleanDamage->hitOutCome == MELEE_HIT_CRIT)
-                    weaponSpeedHitFactor *= 2;
-
-                RewardRage(rage_damage, weaponSpeedHitFactor, true);
-
-                break;
-            }
-            case OFF_ATTACK:
-            {
-                weaponSpeedHitFactor = uint32(GetAttackTime(cleanDamage->attackType) / 1000.0f * 1.75f);
-                if (cleanDamage->hitOutCome == MELEE_HIT_CRIT)
-                    weaponSpeedHitFactor *= 2;
-
-                RewardRage(rage_damage, weaponSpeedHitFactor, true);
-
-                break;
-            }
-            case RANGED_ATTACK:
-                break;
-            default:
-                break;
-        }
-    }
-
-    if (!damage)
-    {
-        // Rage from absorbed damage
-        if (cleanDamage && cleanDamage->absorbed_damage && pVictim->getPowerType() == POWER_RAGE)
-            pVictim->RewardRage(cleanDamage->absorbed_damage, 0, false);
-
-        return 0;
-    }
-
-    sLog.outStaticDebug("DealDamageStart");
-
-    uint32 health = pVictim->GetHealth();
-    sLog.outDetail("deal dmg:%d to health:%d ",damage,health);
-
-    // duel ends when player has 1 or less hp
-    bool duel_hasEnded = false;
-    if (pVictim->GetTypeId() == TYPEID_PLAYER && pVictim->ToPlayer()->duel && damage >= (health-1))
-    {
-        // prevent kill only if killed in duel and killed by opponent or opponent controlled creature
-        if (pVictim->ToPlayer()->duel->opponent == this || pVictim->ToPlayer()->duel->opponent->GetGUID() == GetOwnerGUID())
-            damage = health - 1;
-
-        duel_hasEnded = true;
-    }
-
-    if (GetTypeId() == TYPEID_PLAYER && this != pVictim)
-    {
-        Player *killer = this->ToPlayer();
-
-        // in bg, count dmg if victim is also a player
-        if (pVictim->GetTypeId() == TYPEID_PLAYER)
-            if (Battleground *bg = killer->GetBattleground())
-                bg->UpdatePlayerScore(killer, SCORE_DAMAGE_DONE, damage);
-
-        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, damage, 0, pVictim);
-        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_DEALT, damage);
-    }
-
-    if (pVictim->GetTypeId() == TYPEID_PLAYER)
-        pVictim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_RECEIVED, damage);
-    else if (!pVictim->IsControlledByPlayer())
-    {
-        if (!pVictim->ToCreature()->hasLootRecipient())
-            pVictim->ToCreature()->SetLootRecipient(this);
-
-        if (IsControlledByPlayer())
-            pVictim->ToCreature()->LowerPlayerDamageReq(health < damage ?  health : damage);
-    }
-
-    if (health <= damage)
-    {
-        sLog.outStaticDebug("DealDamage: victim just died");
-
-        if (pVictim->GetTypeId() == TYPEID_PLAYER)
-        {
-            pVictim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, health);
-
-            // call before auras are removed
-            if (Player* killer = this->ToPlayer()) // keep the this-> for clarity
-                killer->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 0, 0, pVictim);
-        }
-
-        Kill(pVictim, durabilityLoss);
-    }
-    else
-    {
-        sLog.outStaticDebug("DealDamageAlive");
-
-        if (pVictim->GetTypeId() == TYPEID_PLAYER)
-            pVictim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, damage);
-
-        pVictim->ModifyHealth(- (int32)damage);
-
-        if (damagetype == DIRECT_DAMAGE || damagetype == SPELL_DIRECT_DAMAGE)
-            pVictim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_DIRECT_DAMAGE, spellProto ? spellProto->Id : 0);
-
-        if (pVictim->GetTypeId() != TYPEID_PLAYER)
-        {
-            if (spellProto && IsDamageToThreatSpell(spellProto))
-                pVictim->AddThreat(this, damage * 2.0f, damageSchoolMask, spellProto);
-            else
-                pVictim->AddThreat(this, (float)damage, damageSchoolMask, spellProto);
-        }
-        else                                                // victim is a player
-        {
-            // random durability for items (HIT TAKEN)
-            if (roll_chance_f(sWorld.getRate(RATE_DURABILITY_LOSS_DAMAGE)))
-            {
-                EquipmentSlots slot = EquipmentSlots(urand(0,EQUIPMENT_SLOT_END-1));
-                pVictim->ToPlayer()->DurabilityPointLossForEquipSlot(slot);
-            }
-        }
-
-        // Rage from damage received
-        if (this != pVictim && pVictim->getPowerType() == POWER_RAGE)
-        {
-            uint32 rage_damage = damage + (cleanDamage ? cleanDamage->absorbed_damage : 0);
-            pVictim->RewardRage(rage_damage, 0, false);
-        }
-
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            // random durability for items (HIT DONE)
-            if (roll_chance_f(sWorld.getRate(RATE_DURABILITY_LOSS_DAMAGE)))
-            {
-                EquipmentSlots slot = EquipmentSlots(urand(0,EQUIPMENT_SLOT_END-1));
-                this->ToPlayer()->DurabilityPointLossForEquipSlot(slot);
-            }
-        }
-
-        if (damagetype != NODAMAGE && damage)
-        {
-            if (pVictim != this && pVictim->GetTypeId() == TYPEID_PLAYER) // does not support creature push_back
-            {
-                if (damagetype != DOT)
-                {
-                    if (Spell* spell = pVictim->m_currentSpells[CURRENT_GENERIC_SPELL])
-                    {
-                        if (spell->getState() == SPELL_STATE_PREPARING)
-                        {
-                            uint32 interruptFlags = spell->m_spellInfo->InterruptFlags;
-                            if (interruptFlags & SPELL_INTERRUPT_FLAG_ABORT_ON_DMG)
-                                pVictim->InterruptNonMeleeSpells(false);
-                            else if (interruptFlags & SPELL_INTERRUPT_FLAG_PUSH_BACK)
-                                spell->Delayed();
-                        }
-                    }
-                }
-
-                if (Spell* spell = pVictim->m_currentSpells[CURRENT_CHANNELED_SPELL])
-                {
-                    if (spell->getState() == SPELL_STATE_CASTING)
-                    {
-                        uint32 channelInterruptFlags = spell->m_spellInfo->ChannelInterruptFlags;
-                        if (((channelInterruptFlags & CHANNEL_FLAG_DELAY) != 0) && (damagetype != DOT))
-                            spell->DelayedChannel();
-                    }
-                }
-            }
-        }
-
-        // last damage from duel opponent
-        if (duel_hasEnded)
-        {
-            ASSERT(pVictim->GetTypeId() == TYPEID_PLAYER);
-            Player *he = pVictim->ToPlayer();
-
-            ASSERT(he->duel);
-
-            he->SetHealth(1);
-
-            he->duel->opponent->CombatStopWithPets(true);
-            he->CombatStopWithPets(true);
-
-            he->CastSpell(he, 7267, true);                  // beg
-            he->DuelComplete(DUEL_WON);
-        }
-    }
-
-    sLog.outStaticDebug("DealDamageEnd returned %d damage", damage);
-
-    return damage;
-}
-
-void Unit::CastStop(uint32 except_spellid)
-{
-    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
-        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id != except_spellid)
-            InterruptSpell(CurrentSpellTypes(i),false);
-}
-
-void Unit::CastSpell(Unit* Victim, uint32 spellId, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-
-    if (!spellInfo)
-    {
-        sLog.outError("CastSpell: unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
-        return;
-    }
-
-    CastSpell(Victim,spellInfo,triggered,castItem,triggeredByAura, originalCaster);
-}
-
-void Unit::CastSpell(Unit* Victim,SpellEntry const *spellInfo, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
-{
-    if (!spellInfo)
-    {
-        sLog.outError("CastSpell: unknown spell by caster: %s %u)", (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
-        return;
-    }
-
-    if (!originalCaster && GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem() && IsControlledByPlayer())
-        if (Unit * owner = GetOwner())
-            originalCaster=owner->GetGUID();
-
-    SpellCastTargets targets;
-    targets.setUnitTarget(Victim);
-
-    if (castItem)
-        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
-
-    if (!originalCaster && triggeredByAura)
-        originalCaster = triggeredByAura->GetCasterGUID();
-
-    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
-
-    spell->m_CastItem = castItem;
-    spell->prepare(&targets, triggeredByAura);
-}
-
-void Unit::CastCustomSpell(Unit* target, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
-{
-    CustomSpellValues values;
-    if (bp0)
-        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);
-    if (bp1)
-        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);
-    if (bp2)
-        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);
-    CastCustomSpell(spellId, values, target, triggered, castItem, triggeredByAura, originalCaster);
-}
-
-void Unit::CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* target, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
-{
-    CustomSpellValues values;
-    values.AddSpellMod(mod, value);
-    CastCustomSpell(spellId, values, target, triggered, castItem, triggeredByAura, originalCaster);
-}
-
-void Unit::CastCustomSpell(uint32 spellId, CustomSpellValues const &value, Unit* Victim, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-    {
-        sLog.outError("CastSpell: unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
-        return;
-    }
-
-    SpellCastTargets targets;
-    targets.setUnitTarget(Victim);
-
-    if (!originalCaster && triggeredByAura)
-        originalCaster = triggeredByAura->GetCasterGUID();
-
-    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
-
-    if (castItem)
-    {
-        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
-        spell->m_CastItem = castItem;
-    }
-
-    for (CustomSpellValues::const_iterator itr = value.begin(); itr != value.end(); ++itr)
-        spell->SetSpellValue(itr->first, itr->second);
-
-    spell->prepare(&targets, triggeredByAura);
-}
-
-// used for scripting
-void Unit::CastSpell(float x, float y, float z, uint32 spellId, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster, Unit* OriginalVictim)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-
-    if (!spellInfo)
-    {
-        sLog.outError("CastSpell(x,y,z): unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
-        return;
-    }
-
-    if (castItem)
-        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
-
-    if (!originalCaster && triggeredByAura)
-        originalCaster = triggeredByAura->GetCasterGUID();
-
-    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
-
-    SpellCastTargets targets;
-    targets.setDst(x, y, z, GetOrientation());
-    if (OriginalVictim)
-        targets.setUnitTarget(OriginalVictim);
-    spell->m_CastItem = castItem;
-    spell->prepare(&targets, triggeredByAura);
-}
-
-// used for scripting
-void Unit::CastSpell(GameObject *go, uint32 spellId, bool triggered, Item *castItem, AuraEffect* triggeredByAura, uint64 originalCaster)
-{
-    if (!go)
-        return;
-
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-
-    if (!spellInfo)
-    {
-        sLog.outError("CastSpell(x,y,z): unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
-        return;
-    }
-
-    if (!(spellInfo->Targets & (TARGET_FLAG_OBJECT | TARGET_FLAG_OBJECT_CASTER)))
-    {
-        sLog.outError("CastSpell: spell id %i by caster: %s %u) is not gameobject spell", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
-        return;
-    }
-
-    if (castItem)
-        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
-
-    if (!originalCaster && triggeredByAura)
-        originalCaster = triggeredByAura->GetCasterGUID();
-
-    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
-
-    SpellCastTargets targets;
-    targets.setGOTarget(go);
-    spell->m_CastItem = castItem;
-    spell->prepare(&targets, triggeredByAura);
-}
-
-// Obsolete func need remove, here only for comotability vs another patches
-uint32 Unit::SpellNonMeleeDamageLog(Unit *pVictim, uint32 spellID, uint32 damage)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellID);
-    SpellNonMeleeDamage damageInfo(this, pVictim, spellInfo->Id, spellInfo->SchoolMask);
-    damage = SpellDamageBonus(pVictim, spellInfo, damage, SPELL_DIRECT_DAMAGE);
-    CalculateSpellDamageTaken(&damageInfo, damage, spellInfo);
-    DealDamageMods(damageInfo.target,damageInfo.damage,&damageInfo.absorb);
-    SendSpellNonMeleeDamageLog(&damageInfo);
-    DealSpellDamage(&damageInfo, true);
-    return damageInfo.damage;
-}
-
-void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage *damageInfo, int32 damage, SpellEntry const *spellInfo, WeaponAttackType attackType, bool crit)
-{
-    if (damage < 0)
-        return;
-
-    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_FIXED_DAMAGE)
-    {
-        damageInfo->damage = damage;
-        return;
-    }
-
-    Unit *pVictim = damageInfo->target;
-    if (!pVictim || !pVictim->isAlive())
-        return;
-
-    SpellSchoolMask damageSchoolMask = SpellSchoolMask(damageInfo->schoolMask);
-    uint32 crTypeMask = pVictim->GetCreatureTypeMask();
-
-    if (IsDamageReducedByArmor(damageSchoolMask, spellInfo))
-        damage = CalcArmorReducedDamage(pVictim, damage, spellInfo, attackType);
-
-    bool blocked = false;
-    // Per-school calc
-    switch (spellInfo->DmgClass)
-    {
-        // Melee and Ranged Spells
-        case SPELL_DAMAGE_CLASS_RANGED:
-        case SPELL_DAMAGE_CLASS_MELEE:
-            {
-                // Physical Damage
-                if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
-                {
-                    // Get blocked status
-                    blocked = isSpellBlocked(pVictim, spellInfo, attackType);
-                }
-
-                if (crit)
-                {
-                    damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;
-
-                    // Calculate crit bonus
-                    uint32 crit_bonus = damage;
-                    // Apply crit_damage bonus for melee spells
-                    if (Player* modOwner = GetSpellModOwner())
-                        modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);
-                    damage += crit_bonus;
-
-                    // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
-                    int32 critPctDamageMod = 0;
-                    if (attackType == RANGED_ATTACK)
-                        critPctDamageMod += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
-                    else
-                    {
-                        critPctDamageMod += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
-                        critPctDamageMod += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS_MELEE);
-                    }
-                    // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS
-                    critPctDamageMod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);
-
-                    if (critPctDamageMod != 0)
-                        damage = int32(damage * float((100.0f + critPctDamageMod)/100.0f));
-                }
-
-                // Spell weapon based damage CAN BE crit & blocked at same time
-                if (blocked)
-                {
-                    damageInfo->blocked = pVictim->GetShieldBlockValue();
-                    //double blocked amount if block is critical
-                    if (pVictim->isBlockCritical())
-                        damageInfo->blocked += damageInfo->blocked;
-                    if (damage < int32(damageInfo->blocked))
-                        damageInfo->blocked = uint32(damage);
-                    damage -= damageInfo->blocked;
-                }
-
-                if (attackType != RANGED_ATTACK)
-                    ApplyResilience(pVictim, NULL, &damage, crit, CR_CRIT_TAKEN_MELEE);
-                else
-                    ApplyResilience(pVictim, NULL, &damage, crit, CR_CRIT_TAKEN_RANGED);
-            }
-            break;
-        // Magical Attacks
-        case SPELL_DAMAGE_CLASS_NONE:
-        case SPELL_DAMAGE_CLASS_MAGIC:
-            {
-                // If crit add critical bonus
-                if (crit)
-                {
-                    damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;
-                    damage = SpellCriticalDamageBonus(spellInfo, damage, pVictim);
-                }
-
-                ApplyResilience(pVictim, NULL, &damage, crit, CR_CRIT_TAKEN_SPELL);
-            }
-            break;
-    }
-
-    // Calculate absorb resist
-    if (damage > 0)
-    {
-        // Chaos Bolt - "Chaos Bolt cannot be resisted, and pierces through all absorption effects."
-        if (spellInfo->SpellIconID != 3178)
-        {
-            CalcAbsorbResist(pVictim, damageSchoolMask, SPELL_DIRECT_DAMAGE, damage, &damageInfo->absorb, &damageInfo->resist, spellInfo);
-            damage -= damageInfo->absorb + damageInfo->resist;
-        }
-    }
-    else
-        damage = 0;
-
-    damageInfo->damage = damage;
-}
-
-void Unit::DealSpellDamage(SpellNonMeleeDamage *damageInfo, bool durabilityLoss)
-{
-    if (damageInfo == 0)
-        return;
-
-    Unit *pVictim = damageInfo->target;
-
-    if (!pVictim)
-        return;
-
-    if (!pVictim->isAlive() || pVictim->hasUnitState(UNIT_STAT_UNATTACKABLE) || (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode()))
-        return;
-
-    SpellEntry const *spellProto = sSpellStore.LookupEntry(damageInfo->SpellID);
-    if (spellProto == NULL)
-    {
-        sLog.outDebug("Unit::DealSpellDamage have wrong damageInfo->SpellID: %u", damageInfo->SpellID);
-        return;
-    }
-
-    //You don't lose health from damage taken from another player while in a sanctuary
-    //You still see it in the combat log though
-    if (pVictim != this && IsControlledByPlayer() && pVictim->IsControlledByPlayer())
-    {
-        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
-
-        if (area && area->IsSanctuary())       // sanctuary
-            return;
-    }
-
-    // Call default DealDamage
-    CleanDamage cleanDamage(damageInfo->cleanDamage, damageInfo->absorb, BASE_ATTACK, MELEE_HIT_NORMAL);
-    DealDamage(pVictim, damageInfo->damage, &cleanDamage, SPELL_DIRECT_DAMAGE, SpellSchoolMask(damageInfo->schoolMask), spellProto, durabilityLoss);
-}
-
-//TODO for melee need create structure as in
-void Unit::CalculateMeleeDamage(Unit *pVictim, uint32 damage, CalcDamageInfo *damageInfo, WeaponAttackType attackType)
-{
-    damageInfo->attacker         = this;
-    damageInfo->target           = pVictim;
-    damageInfo->damageSchoolMask = GetMeleeDamageSchoolMask();
-    damageInfo->attackType       = attackType;
-    damageInfo->damage           = 0;
-    damageInfo->cleanDamage      = 0;
-    damageInfo->absorb           = 0;
-    damageInfo->resist           = 0;
-    damageInfo->blocked_amount   = 0;
-
-    damageInfo->TargetState      = 0;
-    damageInfo->HitInfo          = 0;
-    damageInfo->procAttacker     = PROC_FLAG_NONE;
-    damageInfo->procVictim       = PROC_FLAG_NONE;
-    damageInfo->procEx           = PROC_EX_NONE;
-    damageInfo->hitOutCome       = MELEE_HIT_EVADE;
-
-    if (!pVictim)
-        return;
-    if (!isAlive() || !pVictim->isAlive())
-        return;
-
-    // Select HitInfo/procAttacker/procVictim flag based on attack type
-    switch (attackType)
-    {
-        case BASE_ATTACK:
-            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_MAINHAND_ATTACK;
-            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
-            damageInfo->HitInfo      = HITINFO_NORMALSWING2;
-            break;
-        case OFF_ATTACK:
-            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_OFFHAND_ATTACK;
-            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
-            damageInfo->HitInfo = HITINFO_LEFTSWING;
-            break;
-        default:
-            return;
-    }
-
-    // Physical Immune check
-    if (damageInfo->target->IsImmunedToDamage(SpellSchoolMask(damageInfo->damageSchoolMask)))
-    {
-       damageInfo->HitInfo       |= HITINFO_NORMALSWING;
-       damageInfo->TargetState    = VICTIMSTATE_IS_IMMUNE;
-
-       damageInfo->procEx        |= PROC_EX_IMMUNE;
-       damageInfo->damage         = 0;
-       damageInfo->cleanDamage    = 0;
-       return;
-    }
-
-    damage += CalculateDamage(damageInfo->attackType, false, true);
-    // Add melee damage bonus
-    MeleeDamageBonus(damageInfo->target, &damage, damageInfo->attackType);
-
-    // Calculate armor reduction
-    if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
-    {
-        damageInfo->damage = CalcArmorReducedDamage(damageInfo->target, damage, NULL , damageInfo->attackType);
-        damageInfo->cleanDamage += damage - damageInfo->damage;
-    }
-    else
-        damageInfo->damage = damage;
-
-    damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
-
-    switch (damageInfo->hitOutCome)
-    {
-        case MELEE_HIT_EVADE:
-            {
-                damageInfo->HitInfo    |= HITINFO_MISS|HITINFO_SWINGNOHITSOUND;
-                damageInfo->TargetState = VICTIMSTATE_EVADES;
-
-                damageInfo->procEx|=PROC_EX_EVADE;
-                damageInfo->damage = 0;
-                damageInfo->cleanDamage = 0;
-            }
-            return;
-        case MELEE_HIT_MISS:
-            {
-                damageInfo->HitInfo    |= HITINFO_MISS;
-                damageInfo->TargetState = VICTIMSTATE_INTACT;
-
-                damageInfo->procEx |= PROC_EX_MISS;
-                damageInfo->damage  = 0;
-                damageInfo->cleanDamage = 0;
-            }
-            break;
-        case MELEE_HIT_NORMAL:
-            damageInfo->TargetState = VICTIMSTATE_HIT;
-            damageInfo->procEx|=PROC_EX_NORMAL_HIT;
-            break;
-        case MELEE_HIT_CRIT:
-            {
-                damageInfo->HitInfo     |= HITINFO_CRITICALHIT;
-                damageInfo->TargetState  = VICTIMSTATE_HIT;
-
-                damageInfo->procEx      |= PROC_EX_CRITICAL_HIT;
-                // Crit bonus calc
-                damageInfo->damage += damageInfo->damage;
-                int32 mod = 0;
-                // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
-                if (damageInfo->attackType == RANGED_ATTACK)
-                    mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
-                else
-                {
-                    mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
-                    mod += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS_MELEE);
-                }
-
-                uint32 crTypeMask = damageInfo->target->GetCreatureTypeMask();
-
-                // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS
-                mod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);
-                if (mod != 0)
-                    damageInfo->damage = int32((damageInfo->damage) * float((100.0f + mod)/100.0f));
-            }
-            break;
-        case MELEE_HIT_PARRY:
-            damageInfo->TargetState  = VICTIMSTATE_PARRY;
-            damageInfo->procEx      |= PROC_EX_PARRY;
-            damageInfo->cleanDamage += damageInfo->damage;
-            damageInfo->damage = 0;
-            break;
-        case MELEE_HIT_DODGE:
-            damageInfo->TargetState  = VICTIMSTATE_DODGE;
-            damageInfo->procEx      |= PROC_EX_DODGE;
-            damageInfo->cleanDamage += damageInfo->damage;
-            damageInfo->damage = 0;
-            break;
-        case MELEE_HIT_BLOCK:
-            {
-                damageInfo->TargetState = VICTIMSTATE_HIT;
-                damageInfo->HitInfo    |= HITINFO_BLOCK;
-                damageInfo->procEx     |= PROC_EX_BLOCK;
-                damageInfo->blocked_amount = damageInfo->target->GetShieldBlockValue();
-                //double blocked amount if block is critical
-                if (damageInfo->target->isBlockCritical())
-                    damageInfo->blocked_amount+=damageInfo->blocked_amount;
-                if (damageInfo->blocked_amount >= damageInfo->damage)
-                {
-                    damageInfo->TargetState = VICTIMSTATE_BLOCKS;
-                    damageInfo->blocked_amount = damageInfo->damage;
-                    damageInfo->procEx |= PROC_EX_FULL_BLOCK;
-                }
-                else
-                    damageInfo->procEx  |= PROC_EX_NORMAL_HIT;
-                damageInfo->damage      -= damageInfo->blocked_amount;
-                damageInfo->cleanDamage += damageInfo->blocked_amount;
-            }
-            break;
-        case MELEE_HIT_GLANCING:
-            {
-                damageInfo->HitInfo     |= HITINFO_GLANCING;
-                damageInfo->TargetState  = VICTIMSTATE_HIT;
-                damageInfo->procEx      |= PROC_EX_NORMAL_HIT;
-                int32 leveldif = int32(pVictim->getLevel()) - int32(getLevel());
-                if (leveldif > 3)
-                    leveldif = 3;
-                float reducePercent = 1 - leveldif * 0.1f;
-                damageInfo->cleanDamage += damageInfo->damage-uint32(reducePercent * damageInfo->damage);
-                damageInfo->damage   = uint32(reducePercent * damageInfo->damage);
-            }
-            break;
-        case MELEE_HIT_CRUSHING:
-            {
-                damageInfo->HitInfo     |= HITINFO_CRUSHING;
-                damageInfo->TargetState  = VICTIMSTATE_HIT;
-                damageInfo->procEx      |= PROC_EX_NORMAL_HIT;
-                // 150% normal damage
-                damageInfo->damage += (damageInfo->damage / 2);
-            }
-        break;
-        default:
-            break;
-    }
-
-    int32 resilienceReduction = damageInfo->damage;
-    if (attackType != RANGED_ATTACK)
-        ApplyResilience(pVictim, NULL, &resilienceReduction, (damageInfo->hitOutCome == MELEE_HIT_CRIT), CR_CRIT_TAKEN_MELEE);
-    else
-        ApplyResilience(pVictim, NULL, &resilienceReduction, (damageInfo->hitOutCome == MELEE_HIT_CRIT), CR_CRIT_TAKEN_RANGED);
-    resilienceReduction = damageInfo->damage - resilienceReduction;
-    damageInfo->damage      -= resilienceReduction;
-    damageInfo->cleanDamage += resilienceReduction;
-
-    // Calculate absorb resist
-    if (int32(damageInfo->damage) > 0)
-    {
-        damageInfo->procVictim |= PROC_FLAG_TAKEN_DAMAGE;
-        // Calculate absorb & resists
-        CalcAbsorbResist(damageInfo->target, SpellSchoolMask(damageInfo->damageSchoolMask), DIRECT_DAMAGE, damageInfo->damage, &damageInfo->absorb, &damageInfo->resist);
-        damageInfo->damage -= damageInfo->absorb + damageInfo->resist;
-        if (damageInfo->absorb)
-        {
-            damageInfo->HitInfo |= HITINFO_ABSORB;
-            damageInfo->procEx  |= PROC_EX_ABSORB;
-        }
-        if (damageInfo->resist)
-            damageInfo->HitInfo |= HITINFO_RESIST;
-    }
-    else // Impossible get negative result but....
-        damageInfo->damage = 0;
-}
-
-void Unit::DealMeleeDamage(CalcDamageInfo *damageInfo, bool durabilityLoss)
-{
-    Unit *pVictim = damageInfo->target;
-
-    if (!pVictim->isAlive() || pVictim->hasUnitState(UNIT_STAT_UNATTACKABLE) || (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode()))
-        return;
-
-    //You don't lose health from damage taken from another player while in a sanctuary
-    //You still see it in the combat log though
-    if (pVictim != this && IsControlledByPlayer() && pVictim->IsControlledByPlayer())
-    {
-        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
-        if (area && area->IsSanctuary())      // sanctuary
-            return;
-    }
-
-    // Hmmmm dont like this emotes client must by self do all animations
-    if (damageInfo->HitInfo&HITINFO_CRITICALHIT)
-        pVictim->HandleEmoteCommand(EMOTE_ONESHOT_WOUNDCRITICAL);
-    if (damageInfo->blocked_amount && damageInfo->TargetState != VICTIMSTATE_BLOCKS)
-        pVictim->HandleEmoteCommand(EMOTE_ONESHOT_PARRYSHIELD);
-
-    if (damageInfo->TargetState == VICTIMSTATE_PARRY)
-    {
-        // Get attack timers
-        float offtime  = float(pVictim->getAttackTimer(OFF_ATTACK));
-        float basetime = float(pVictim->getAttackTimer(BASE_ATTACK));
-        // Reduce attack time
-        if (pVictim->haveOffhandWeapon() && offtime < basetime)
-        {
-            float percent20 = pVictim->GetAttackTime(OFF_ATTACK) * 0.20f;
-            float percent60 = 3.0f * percent20;
-            if (offtime > percent20 && offtime <= percent60)
-                pVictim->setAttackTimer(OFF_ATTACK, uint32(percent20));
-            else if (offtime > percent60)
-            {
-                offtime -= 2.0f * percent20;
-                pVictim->setAttackTimer(OFF_ATTACK, uint32(offtime));
-            }
-        }
-        else
-        {
-            float percent20 = pVictim->GetAttackTime(BASE_ATTACK) * 0.20f;
-            float percent60 = 3.0f * percent20;
-            if (basetime > percent20 && basetime <= percent60)
-                pVictim->setAttackTimer(BASE_ATTACK, uint32(percent20));
-            else if (basetime > percent60)
-            {
-                basetime -= 2.0f * percent20;
-                pVictim->setAttackTimer(BASE_ATTACK, uint32(basetime));
-            }
-        }
-    }
-
-    // Call default DealDamage
-    CleanDamage cleanDamage(damageInfo->cleanDamage,damageInfo->absorb,damageInfo->attackType,damageInfo->hitOutCome);
-    DealDamage(pVictim, damageInfo->damage, &cleanDamage, DIRECT_DAMAGE, SpellSchoolMask(damageInfo->damageSchoolMask), NULL, durabilityLoss);
-
-    // If this is a creature and it attacks from behind it has a probability to daze it's victim
-    if ((damageInfo->hitOutCome == MELEE_HIT_CRIT || damageInfo->hitOutCome == MELEE_HIT_CRUSHING || damageInfo->hitOutCome == MELEE_HIT_NORMAL || damageInfo->hitOutCome == MELEE_HIT_GLANCING) &&
-        GetTypeId() != TYPEID_PLAYER && !this->ToCreature()->IsControlledByPlayer() && !pVictim->HasInArc(M_PI, this)
-        && (pVictim->GetTypeId() == TYPEID_PLAYER || !pVictim->ToCreature()->isWorldBoss()))
-    {
-        // -probability is between 0% and 40%
-        // 20% base chance
-        float Probability = 20.0f;
-
-        //there is a newbie protection, at level 10 just 7% base chance; assuming linear function
-        if (pVictim->getLevel() < 30)
-            Probability = 0.65f * pVictim->getLevel() + 0.5f;
-
-        uint32 VictimDefense=pVictim->GetDefenseSkillValue();
-        uint32 AttackerMeleeSkill=GetUnitMeleeSkill();
-
-        Probability *= AttackerMeleeSkill/(float)VictimDefense;
-
-        if (Probability > 40.0f)
-            Probability = 40.0f;
-
-        if (roll_chance_f(Probability))
-            CastSpell(pVictim, 1604, true);
-    }
-
-    if (GetTypeId() == TYPEID_PLAYER)
-        ToPlayer()->CastItemCombatSpell(pVictim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
-
-    // Do effect if any damage done to target
-    if (damageInfo->damage)
-    {
-        AuraEffectList const& vDamageShields = pVictim->GetAuraEffectsByType(SPELL_AURA_DAMAGE_SHIELD);
-        for (AuraEffectList::const_iterator dmgShieldItr = vDamageShields.begin(); dmgShieldItr != vDamageShields.end(); ++dmgShieldItr)
-        {
-            SpellEntry const *i_spellProto = (*dmgShieldItr)->GetSpellProto();
-            // Damage shield can be resisted...
-            if (SpellMissInfo missInfo = pVictim->SpellHitResult(this, i_spellProto ,false))
-            {
-                pVictim->SendSpellMiss(this, i_spellProto->Id, missInfo);
-                continue;
-            }
-
-            // ...or immuned
-            if (IsImmunedToDamage(i_spellProto))
-            {
-                pVictim->SendSpellDamageImmune(this, i_spellProto->Id);
-                continue;
-            }
-
-            uint32 damage = (*dmgShieldItr)->GetAmount();
-
-            // No Unit::CalcAbsorbResist here - opcode doesn't send that data - this damage is probably not affected by that
-            pVictim->DealDamageMods(this,damage,NULL);
-
-            // TODO: Move this to a packet handler
-            WorldPacket data(SMSG_SPELLDAMAGESHIELD,(8+8+4+4+4+4));
-            data << uint64(pVictim->GetGUID());
-            data << uint64(GetGUID());
-            data << uint32(i_spellProto->Id);
-            data << uint32(damage);                  // Damage
-            int32 overkill = int32(damage) - int32(GetHealth());
-            data << uint32(overkill > 0 ? overkill : 0); // Overkill
-            data << uint32(i_spellProto->SchoolMask);
-            pVictim->SendMessageToSet(&data, true);
-
-            pVictim->DealDamage(this, damage, 0, SPELL_DIRECT_DAMAGE, GetSpellSchoolMask(i_spellProto), i_spellProto, true);
-        }
-    }
-}
-
-void Unit::HandleEmoteCommand(uint32 anim_id)
-{
-    WorldPacket data(SMSG_EMOTE, 4 + 8);
-    data << uint32(anim_id);
-    data << uint64(GetGUID());
-    SendMessageToSet(&data, true);
-}
-
-bool Unit::IsDamageReducedByArmor(SpellSchoolMask schoolMask, SpellEntry const *spellInfo, uint8 effIndex)
-{
-    // only physical spells damage gets reduced by armor
-    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
-        return false;
-    if (spellInfo)
-    {
-        // there are spells with no specific attribute but they have "ignores armor" in tooltip
-        if (sSpellMgr.GetSpellCustomAttr(spellInfo->Id) & SPELL_ATTR_CU_IGNORE_ARMOR)
-            return false;
-
-        // bleeding effects are not reduced by armor
-        if (effIndex != MAX_SPELL_EFFECTS && spellInfo->EffectApplyAuraName[effIndex] == SPELL_AURA_PERIODIC_DAMAGE)
-            if (GetSpellMechanicMask(spellInfo, effIndex) & (1<<MECHANIC_BLEED))
-                return false;
-    }
-    return true;
-}
-
-uint32 Unit::CalcArmorReducedDamage(Unit* pVictim, const uint32 damage, SpellEntry const *spellInfo, WeaponAttackType /*attackType*/)
-{
-    uint32 newdamage = 0;
-    float armor = float(pVictim->GetArmor());
-
-    // Ignore enemy armor by SPELL_AURA_MOD_TARGET_RESISTANCE aura
-    armor += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_NORMAL);
-
-    if (spellInfo)
-        if (Player *modOwner = GetSpellModOwner())
-            modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_IGNORE_ARMOR, armor);
-
-    AuraEffectList const& ResIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);
-    for (AuraEffectList::const_iterator j = ResIgnoreAurasAb.begin(); j != ResIgnoreAurasAb.end(); ++j)
-    {
-        if ((*j)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL
-            && (*j)->IsAffectedOnSpell(spellInfo))
-            armor = floor(float(armor) * (float(100 - (*j)->GetAmount()) / 100.0f));
-    }
-
-    AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
-    for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)
-    {
-        if ((*j)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
-            armor = floor(float(armor) * (float(100 - (*j)->GetAmount()) / 100.0f));
-    }
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_ARMOR_PENETRATION_PCT);
-        for (AuraEffectList::const_iterator itr = ResIgnoreAuras.begin(); itr != ResIgnoreAuras.end(); ++itr)
-        {
-            // item neutral spell
-            if ((*itr)->GetSpellProto()->EquippedItemClass == -1)
-            {
-                armor = floor(float(armor) * (float(100 - (*itr)->GetAmount()) / 100.0f));
-                continue;
-            }
-
-            // item dependent spell - check curent weapons
-            for (int i = 0; i < MAX_ATTACK; ++i)
-            {
-                Item *weapon = ToPlayer()->GetWeaponForAttack(WeaponAttackType(i), true);
-
-                if (weapon && weapon->IsFitToSpellRequirements((*itr)->GetSpellProto()))
-                {
-                    armor = floor(float(armor) * (float(100 - (*itr)->GetAmount()) / 100.0f));
-                    break;
-                }
-            }
-        }
-    }
-
-    // Apply Player CR_ARMOR_PENETRATION rating
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        float maxArmorPen=0;
-        if (getLevel() < 60)
-            maxArmorPen = float(400 + 85 * pVictim->getLevel());
-        else
-            maxArmorPen = 400 + 85 * pVictim->getLevel() + 4.5f * 85 * (pVictim->getLevel() - 59);
-        // Cap armor penetration to this number
-        maxArmorPen = std::min(((armor+maxArmorPen) / 3),armor);
-        // Figure out how much armor do we ignore
-        float armorPen = maxArmorPen * this->ToPlayer()->GetRatingBonusValue(CR_ARMOR_PENETRATION) / 100.0f;
-        // Got the value, apply it
-        armor -= armorPen;
-    }
-
-    if (armor < 0.0f)
-        armor = 0.0f;
-
-    float levelModifier = getLevel();
-    if (levelModifier > 59)
-        levelModifier = levelModifier + (4.5f * (levelModifier-59));
-
-    float tmpvalue = 0.1f * armor / (8.5f * levelModifier + 40);
-    tmpvalue = tmpvalue/(1.0f + tmpvalue);
-
-    if (tmpvalue < 0.0f)
-        tmpvalue = 0.0f;
-    if (tmpvalue > 0.75f)
-        tmpvalue = 0.75f;
-
-    newdamage = uint32(damage - (damage * tmpvalue));
-
-    return (newdamage > 1) ? newdamage : 1;
-}
-
-void Unit::CalcAbsorbResist(Unit *pVictim, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32 *absorb, uint32 *resist, SpellEntry const *spellInfo)
-{
-    if (!pVictim || !pVictim->isAlive() || !damage)
-        return;
-
-    // Magic damage, check for resists
-    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
-    {
-        float baseVictimResistance = (float) pVictim->GetResistance(GetFirstSchoolInMask(schoolMask));
-        float ignoredResistance = (float) GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask);
-        float victimResistance = baseVictimResistance + ignoredResistance;
-
-        uint32 BOSS_LEVEL = 83;
-        float BOSS_RESISTANCE_CONSTANT = 510.0;
-        uint32 level = getLevel();
-        float resistanceConstant = 0.0f;
-
-        if (level == BOSS_LEVEL)
-            resistanceConstant = BOSS_RESISTANCE_CONSTANT;
-        else
-            resistanceConstant = level * 5.0f;
-
-        float averageResist = victimResistance / (victimResistance + resistanceConstant);
-        float discreteResistProbability[11];
-        for (int i = 0; i < 11; i++)
-        {
-            discreteResistProbability[i] = 0.5f - 2.5f * fabs(0.1f * i - averageResist);
-            if (discreteResistProbability[i] < 0.0f)
-                discreteResistProbability[i] = 0.0f;
-        }
-
-        if (averageResist <= 0.1f)
-        {
-            discreteResistProbability[0] = 1.0f - 7.5f * averageResist;
-            discreteResistProbability[1] = 5.0f * averageResist;
-            discreteResistProbability[2] = 2.5f * averageResist;
-        }
-
-        float r = (float)rand_norm();
-        int i = 0;
-        float probabilitySum = discreteResistProbability[0];
-
-        while (r >= probabilitySum && i < 10)
-        {
-            i++;
-            probabilitySum += discreteResistProbability[i];
-        }
-
-        uint32 damageResisted = damage * i / 10;
-
-        *resist += damageResisted;
-
-        AuraEffectList const &ResIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);
-        for (AuraEffectList::const_iterator j = ResIgnoreAurasAb.begin(); j != ResIgnoreAurasAb.end(); ++j)
-        {
-            if ((*j)->GetMiscValue() & schoolMask
-                && (*j)->IsAffectedOnSpell(spellInfo))
-                *resist= int32(float(*resist) * (float(100-(*j)->GetAmount())/100.0f));
-        }
-
-        AuraEffectList const &ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
-        for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)
-        {
-            if ((*j)->GetMiscValue() & schoolMask)
-                *resist= int32(float(*resist) * (float(100-(*j)->GetAmount())/100.0f));
-        }
-    }
-    else
-        *resist = 0;
-
-    int32 RemainingDamage = damage - *resist;
-    int32 TotalAbsorb = RemainingDamage;
-    // Get unit state (need for some absorb check)
-    uint32 unitflag = pVictim->GetUInt32Value(UNIT_FIELD_FLAGS);
-    // Death Prevention Aura
-    SpellEntry const* preventDeathSpell = NULL;
-    int32 preventDeathAmount = 0;
-    // Need remove expired auras after
-    bool existExpired = false;
-    TriggeredSpellInfoVct triggeredSpells;
-
-    // Incanter's Absorption, for converting to spell power
-    int32 incanterAbsorption = 0;
-
-    // absorb without mana cost
-    AuraEffectList const& vSchoolAbsorb = pVictim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_ABSORB);
-    for (AuraEffectList::const_iterator i = vSchoolAbsorb.begin(); i != vSchoolAbsorb.end() && RemainingDamage > 0; ++i)
-    {
-        if (!((*i)->GetMiscValue() & schoolMask))
-            continue;
-
-        SpellEntry const* spellProto = (*i)->GetSpellProto();
-
-        // Max Amount can be absorbed by this aura
-        int32  currentAbsorb = (*i)->GetAmount();
-
-        // Found empty aura (impossible but..)
-        if (currentAbsorb <= 0)
-        {
-            existExpired = true;
-            continue;
-        }
-        // Handle custom absorb auras
-        // TODO: try find better way
-        switch (spellProto->SpellFamilyName)
-        {
-            case SPELLFAMILY_GENERIC:
-            {
-                // Astral Shift
-                if (spellProto->SpellIconID == 3066)
-                {
-                    //reduces all damage taken while stun, fear or silence
-                    if (unitflag & (UNIT_FLAG_STUNNED|UNIT_FLAG_FLEEING|UNIT_FLAG_SILENCED))
-                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
-                    continue;
-                }
-                // Nerves of Steel
-                if (spellProto->SpellIconID == 2115)
-                {
-                    // while affected by Stun and Fear
-                    if (unitflag&(UNIT_FLAG_STUNNED|UNIT_FLAG_FLEEING))
-                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
-                    continue;
-                }
-                // Spell Deflection
-                if (spellProto->SpellIconID == 3006)
-                {
-                    // You have a chance equal to your Parry chance
-                    if (damagetype == DIRECT_DAMAGE &&                   // Only for direct damage
-                        roll_chance_f(pVictim->GetUnitParryChance()))    // Roll chance
-                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
-                    continue;
-                }
-                // Reflective Shield (Lady Malande boss)
-                if (spellProto->Id == 41475)
-                {
-                    triggeredSpells.push_back(TriggeredSpellInfo(33619, pVictim, this,
-                        std::min(RemainingDamage, currentAbsorb) / 2, *i));
-                    break;
-                }
-                if (spellProto->Id == 39228 || // Argussian Compass
-                    spellProto->Id == 60218)   // Essence of Gossamer
-                {
-                    // Max absorb stored in 1 dummy effect
-                    int32 maxAbsorb = SpellMgr::CalculateSpellEffectAmount(spellProto, 1);
-                    if (maxAbsorb < currentAbsorb)
-                        currentAbsorb = maxAbsorb;
-                    break;
-                }
-                break;
-            }
-            case SPELLFAMILY_DRUID:
-            {
-                // Primal Tenacity
-                if (spellProto->SpellIconID == 2253)
-                {
-                    //reduces all damage taken while Stunned
-                    if (pVictim->m_form == FORM_CAT && (unitflag & UNIT_FLAG_STUNNED))
-                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
-                    continue;
-                }
-                // Savage Defense
-                if (spellProto->SpellIconID == 146)
-                {
-                    if (RemainingDamage < currentAbsorb)
-                        currentAbsorb = RemainingDamage;
-
-                    (*i)->SetAmount(0);     // guarantee removal
-                    existExpired = true;    // maybe hacky but not crashy
-
-                    RemainingDamage -= currentAbsorb;
-                    continue;
-                }
-                // Moonkin Form passive
-                if (spellProto->Id == 69366)
-                {
-                    //reduces all damage taken while Stunned
-                    if (unitflag & UNIT_FLAG_STUNNED)
-                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
-                    continue;
-                }
-                break;
-            }
-            case SPELLFAMILY_ROGUE:
-            {
-                // Cheat Death (make less prio with Guardian Spirit case)
-                if (spellProto->SpellIconID == 2109)
-                {
-                    if (!preventDeathSpell &&
-                        pVictim->GetTypeId() == TYPEID_PLAYER &&        // Only players
-                        !pVictim->ToPlayer()->HasSpellCooldown(31231) && // Only if no cooldown
-                        roll_chance_i((*i)->GetAmount()))               // Only if roll
-                    {
-                        preventDeathSpell = (*i)->GetSpellProto();
-                    }
-                    continue;
-                }
-                break;
-            }
-            case SPELLFAMILY_PRIEST:
-            {
-                // Guardian Spirit
-                if (spellProto->SpellIconID == 2873)
-                {
-                    preventDeathSpell = (*i)->GetSpellProto();
-                    preventDeathAmount = (*i)->GetAmount();
-                    continue;
-                }
-
-                // Power Word: Shield
-                if (spellProto->SpellFamilyFlags.IsEqual(0x1, 0, 0x400))
-                {
-                    if (pVictim == this)
-                        break;
-                    Unit* caster = (*i)->GetCaster();
-                    if (!caster)
-                        break;
-                    // Reflective Shield
-                    if (AuraEffect const * aurEff = caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST, 566, 0))
-                    {
-                        switch(aurEff->GetMiscValue())
-                        {
-                            case 5065:                          // Rank 1
-                            case 5064:                          // Rank 2
-                                triggeredSpells.push_back(TriggeredSpellInfo(33619, pVictim, this,
-                                    std::min(RemainingDamage, currentAbsorb) * aurEff->GetAmount() / 100, *i));
-                                break;
-                            default:
-                                sLog.outError("Unit::CalcAbsorbResist: unknown Reflective Shield spell %d", aurEff->GetId());
-                                break;
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_PALADIN:
-            {
-                // Ardent Defender
-                if (spellProto->SpellIconID == 2135 && pVictim->GetTypeId() == TYPEID_PLAYER)
-                {
-                    int32 remainingHealth = pVictim->GetHealth() - RemainingDamage;
-                    uint32 allowedHealth = pVictim->CountPctFromMaxHealth(35);
-                    // If damage kills us
-                    if (remainingHealth <= 0 && !pVictim->ToPlayer()->HasSpellCooldown(66235))
-                    {
-                        // Cast healing spell, completely avoid damage
-                        RemainingDamage = 0;
-
-                        uint32 defenseSkillValue = pVictim->GetDefenseSkillValue();
-                        // Max heal when defense skill denies critical hits from raid bosses
-                        // Formula: max defense at level + 140 (raiting from gear)
-                        uint32 reqDefForMaxHeal  = pVictim->getLevel() * 5 + 140;
-                        float pctFromDefense = (defenseSkillValue >= reqDefForMaxHeal)
-                            ? 1.0f
-                            : float(defenseSkillValue) / float(reqDefForMaxHeal);
-
-                        int32 healAmount = int32(pVictim->CountPctFromMaxHealth(uint32((*i)->GetAmount() * pctFromDefense)));
-                        pVictim->CastCustomSpell(pVictim, 66235, &healAmount, NULL, NULL, true);
-                        pVictim->ToPlayer()->AddSpellCooldown(66235,0,time(NULL) + 120);
-                    }
-                    else if (remainingHealth < int32(allowedHealth))
-                    {
-                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
-                        uint32 damageToReduce = (pVictim->GetHealth() < allowedHealth)
-                            ? RemainingDamage
-                            : allowedHealth - remainingHealth;
-                        RemainingDamage -= damageToReduce * currentAbsorb / 100;
-                    }
-                    continue;
-
-                }
-                break;
-            }
-            case SPELLFAMILY_SHAMAN:
-            {
-                // Astral Shift
-                if (spellProto->SpellIconID == 3066)
-                {
-                    //reduces all damage taken while stun, fear or silence
-                    if (unitflag & (UNIT_FLAG_STUNNED|UNIT_FLAG_FLEEING|UNIT_FLAG_SILENCED))
-                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
-                    continue;
-                }
-                break;
-            }
-            case SPELLFAMILY_DEATHKNIGHT:
-            {
-                switch (spellProto->Id)
-                {
-                    case 51271: // Unbreakable Armor
-                        if (Unit *caster = (*i)->GetCaster())
-                        {
-                            uint32 absorbed = uint32(currentAbsorb * caster->GetArmor() * 0.01f);
-
-                            // Glyph of Unbreakable Armor
-                            if (AuraEffect *aurEff = caster->GetAuraEffect(58635, 0))
-                                absorbed += uint32(absorbed * aurEff->GetAmount() / 100);
-
-                            RemainingDamage -= absorbed;
-                        }
-                        continue;
-                    case 52284: // Will of the Necropolis
-                    case 52285:
-                    case 52286:
-                    {
-                        int32 remainingHp = (int32)pVictim->GetHealth() - RemainingDamage;
-
-                        // min pct of hp is stored in effect 0 of talent spell
-                        uint32 rank = sSpellMgr.GetSpellRank(spellProto->Id);
-                        SpellEntry const * talentProto = sSpellStore.LookupEntry(sSpellMgr.GetSpellWithRank(49189, rank));
-
-                        int32 minHp = int32(pVictim->CountPctFromMaxHealth(SpellMgr::CalculateSpellEffectAmount(talentProto, 0, (*i)->GetCaster())));
-                        // Damage that would take you below [effect0] health or taken while you are at [effect0]
-                        if (remainingHp < minHp)
-                        {
-                            uint32 absorbed = uint32(currentAbsorb * RemainingDamage * 0.01f);
-                            RemainingDamage -= absorbed;
-                        }
-                        continue;
-                    }
-                    case 48707: // Anti-Magic Shell (on self)
-                    {
-                        // damage absorbed by Anti-Magic Shell energizes the DK with additional runic power.
-                        // This, if I'm not mistaken, shows that we get back ~2% of the absorbed damage as runic power.
-                        int32 absorbed = RemainingDamage * currentAbsorb / 100;
-                        RemainingDamage -= absorbed;
-                        triggeredSpells.push_back(TriggeredSpellInfo(49088, pVictim, pVictim, absorbed * 2 / 10, *i));
-                        continue;
-                    }
-                    case 50462: // Anti-Magic Shell (on single party/raid member)
-                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
-                        continue;
-                    case 50461: // Anti-Magic Zone
-                        if (Unit *caster = (*i)->GetCaster())
-                        {
-                            int32 absorbed = RemainingDamage * currentAbsorb / 100;
-                            int32 canabsorb = caster->GetHealth();
-                            if (canabsorb < absorbed)
-                                absorbed = canabsorb;
-
-                            RemainingDamage -= absorbed;
-                        }
-                        continue;
-                    default:
-                        break;
-                }
-                break;
-            }
-            default:
-                break;
-        }
-
-        // currentAbsorb - damage can be absorbed by shield
-        // If need absorb less damage
-        if (RemainingDamage < currentAbsorb)
-            currentAbsorb = RemainingDamage;
-
-        RemainingDamage -= currentAbsorb;
-
-        // Fire Ward or Frost Ward or Ice Barrier (or Mana Shield)
-        // for Incanter's Absorption converting to spell power
-        if (spellProto->SpellFamilyName == SPELLFAMILY_MAGE && spellProto->SpellFamilyFlags[2] & 0x000008)
-            incanterAbsorption += currentAbsorb;
-
-        // Reduce shield amount
-        (*i)->SetAmount((*i)->GetAmount() -currentAbsorb);
-        // Need remove it later
-        if ((*i)->GetAmount() <= 0)
-            existExpired = true;
-    }
-
-    for (TriggeredSpellInfoVct::const_iterator itr = triggeredSpells.begin(); itr != triggeredSpells.end(); ++itr)
-    {
-        if (itr->spell)
-            itr->source->CastCustomSpell(itr->spell, SPELLVALUE_BASE_POINT0, itr->amount, itr->target, true, NULL, itr->auraEff);
-        else if (itr->amount > 0)
-        {
-            uint32 damage = uint32(itr->amount);
-            itr->source->DealDamageMods(itr->target, damage, NULL);
-            itr->source->DealDamage(itr->target, damage, NULL, damagetype, schoolMask, 0, false);
-        }
-    }
-
-    // Remove all expired absorb auras
-    if (existExpired)
-    {
-        for (AuraEffectList::const_iterator i = vSchoolAbsorb.begin(); i != vSchoolAbsorb.end();)
-        {
-            AuraEffect * auraEff =(*i);
-            ++i;
-            if (auraEff->GetAmount() <= 0)
-            {
-                uint32 removedAuras = pVictim->m_removedAurasCount;
-                auraEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
-                if (removedAuras+1<pVictim->m_removedAurasCount)
-                    i=vSchoolAbsorb.begin();
-            }
-        }
-    }
-
-    // absorb by mana cost
-    AuraEffectList const& vManaShield = pVictim->GetAuraEffectsByType(SPELL_AURA_MANA_SHIELD);
-    for (AuraEffectList::const_iterator i = vManaShield.begin(), next; i != vManaShield.end() && RemainingDamage > 0; i = next)
-    {
-        next = i; ++next;
-
-        // check damage school mask
-        if (((*i)->GetMiscValue() & schoolMask) == 0)
-            continue;
-
-        int32 currentAbsorb;
-        if (RemainingDamage >= (*i)->GetAmount())
-            currentAbsorb = (*i)->GetAmount();
-        else
-            currentAbsorb = RemainingDamage;
-
-        if (float manaMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier((*i)->GetSpellProto(), (*i)->GetEffIndex(), (*i)->GetCaster()))
-        {
-            int32 maxAbsorb = int32(pVictim->GetPower(POWER_MANA) / manaMultiplier);
-            if (currentAbsorb > maxAbsorb)
-                currentAbsorb = maxAbsorb;
-
-            int32 manaReduction = int32(currentAbsorb * manaMultiplier);
-            pVictim->ApplyPowerMod(POWER_MANA, manaReduction, false);
-        }
-
-        // Mana Shield (or Fire Ward or Frost Ward or Ice Barrier)
-        // for Incanter's Absorption converting to spell power
-        if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_MAGE && (*i)->GetSpellProto()->SpellFamilyFlags[2] & 0x000008)
-            incanterAbsorption += currentAbsorb;
-
-        (*i)->SetAmount((*i)->GetAmount()-currentAbsorb);
-        if ((*i)->GetAmount() <= 0)
-        {
-            (*i)->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
-            next = vManaShield.begin();
-        }
-
-        RemainingDamage -= currentAbsorb;
-    }
-
-    // only split damage if not damaging yourself
-    if (pVictim != this)
-    {
-        AuraEffectList const& vSplitDamageFlat = pVictim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_FLAT);
-        for (AuraEffectList::const_iterator i = vSplitDamageFlat.begin(), next; i != vSplitDamageFlat.end() && RemainingDamage >= 0; i = next)
-        {
-            next = i; ++next;
-
-            // check damage school mask
-            if (((*i)->GetMiscValue() & schoolMask) == 0)
-                continue;
-
-            // Damage can be splitted only if aura has an alive caster
-            Unit *caster = (*i)->GetCaster();
-            if (!caster || caster == pVictim || !caster->IsInWorld() || !caster->isAlive())
-                continue;
-
-            int32 currentAbsorb;
-            if (RemainingDamage >= (*i)->GetAmount())
-                currentAbsorb = (*i)->GetAmount();
-            else
-                currentAbsorb = RemainingDamage;
-
-            RemainingDamage -= currentAbsorb;
-
-            uint32 splitted = currentAbsorb;
-            uint32 splitted_absorb = 0;
-            DealDamageMods(caster,splitted,&splitted_absorb);
-
-            SendSpellNonMeleeDamageLog(caster, (*i)->GetSpellProto()->Id, splitted, schoolMask, splitted_absorb, 0, false, 0, false);
-
-            CleanDamage cleanDamage = CleanDamage(splitted, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
-            DealDamage(caster, splitted, &cleanDamage, DIRECT_DAMAGE, schoolMask, (*i)->GetSpellProto(), false);
-        }
-
-        AuraEffectList const& vSplitDamagePct = pVictim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_PCT);
-        for (AuraEffectList::const_iterator i = vSplitDamagePct.begin(), next; i != vSplitDamagePct.end() && RemainingDamage >= 0; i = next)
-        {
-            next = i;
-            ++next;
-
-            // check damage school mask
-            if (((*i)->GetMiscValue() & schoolMask) == 0)
-                continue;
-
-            // Damage can be splitted only if aura has an alive caster
-            Unit *caster = (*i)->GetCaster();
-            if (!caster || caster == pVictim || !caster->IsInWorld() || !caster->isAlive())
-                continue;
-
-            uint32 splitted = uint32(RemainingDamage * (*i)->GetAmount() / 100.0f);
-
-            RemainingDamage -=  int32(splitted);
-
-            uint32 split_absorb = 0;
-            DealDamageMods(caster,splitted,&split_absorb);
-
-            SendSpellNonMeleeDamageLog(caster, (*i)->GetSpellProto()->Id, splitted, schoolMask, split_absorb, 0, false, 0, false);
-
-            CleanDamage cleanDamage = CleanDamage(splitted, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
-            DealDamage(caster, splitted, &cleanDamage, DIRECT_DAMAGE, schoolMask, (*i)->GetSpellProto(), false);
-        }
-    }
-
-    TotalAbsorb = (TotalAbsorb - RemainingDamage > 0) ? TotalAbsorb - RemainingDamage : 0;
-    // TODO: School should be checked for absorbing auras or for attacks?
-    int32 auraAbsorbMod = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_TARGET_ABSORB_SCHOOL);
-    AuraEffectList const& AbsIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABILITY_ABSORB_SCHOOL);
-    for (AuraEffectList::const_iterator i = AbsIgnoreAurasAb.begin(); i != AbsIgnoreAurasAb.end(); ++i)
-    {
-        if ((*i)->GetAmount() > auraAbsorbMod
-            && (*i)->IsAffectedOnSpell(spellInfo))
-            auraAbsorbMod = (*i)->GetAmount();
-    }
-
-    // Ignore absorb - add reduced amount again to damage
-    RemainingDamage += auraAbsorbMod * TotalAbsorb / 100;
-
-    // Apply death prevention spells effects
-    if (preventDeathSpell && RemainingDamage >= int32(pVictim->GetHealth()))
-    {
-        switch(preventDeathSpell->SpellFamilyName)
-        {
-            case SPELLFAMILY_ROGUE:
-            {
-                // Cheat Death
-                if (preventDeathSpell->SpellIconID == 2109)
-                {
-                    pVictim->CastSpell(pVictim, 31231, true);
-                    pVictim->ToPlayer()->AddSpellCooldown(31231, 0, time(NULL) + 60);
-
-                    // with health > 10% lost health until health == 10%, in other case no losses
-                    uint32 health10 = pVictim->CountPctFromMaxHealth(10);
-                    RemainingDamage = pVictim->GetHealth() > health10 ? pVictim->GetHealth() - health10 : 0;
-                }
-                break;
-            }
-            case SPELLFAMILY_PRIEST:
-            {
-                // Guardian Spirit
-                if (preventDeathSpell->SpellIconID == 2873)
-                {
-                    int32 healAmount = int32(pVictim->CountPctFromMaxHealth(preventDeathAmount));
-                    pVictim->RemoveAurasDueToSpell(preventDeathSpell->Id);
-                    pVictim->CastCustomSpell(pVictim, 48153, &healAmount, NULL, NULL, true);
-                    RemainingDamage = 0;
-                }
-                break;
-            }
-        }
-    }
-
-    *absorb = RemainingDamage > 0 ? (damage - RemainingDamage - *resist) : (damage - *resist);
-
-    // Incanter's Absorption, if have affective absorbing
-    if (incanterAbsorption)
-    {
-        // Incanter's Absorption
-        // TODO: move this code to procflag
-        if (AuraEffect const * aurEff = pVictim->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 2941, 0))
-        {
-            // Get total damage bonus from auras
-            int32 current_dmg = 0;
-            std::pair<AuraApplicationMap::const_iterator, AuraApplicationMap::const_iterator> range = pVictim->GetAppliedAuras().equal_range(44413);
-            for (AuraApplicationMap::const_iterator iter = range.first; iter != range.second; ++iter)
-                if (AuraEffect const * bonusEff = iter->second->GetBase()->GetEffect(0))
-                    current_dmg += bonusEff->GetAmount();
-
-            int32 new_dmg = (int32)*absorb * aurEff->GetAmount() / 100;
-            if (new_dmg > 0)
-                pVictim->CastCustomSpell(pVictim, 44413, &new_dmg, NULL, NULL, true);
-        }
-    }
-}
-
-void Unit::CalcHealAbsorb(Unit *pVictim, const SpellEntry *healSpell, uint32 &healAmount, uint32 &absorb)
-{
-    if (!healAmount)
-        return;
-
-    int32 RemainingHeal = healAmount;
-
-    // Need remove expired auras after
-    bool existExpired = false;
-
-    // absorb without mana cost
-    AuraEffectList const& vHealAbsorb = pVictim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_HEAL_ABSORB);
-    for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end() && RemainingHeal > 0; ++i)
-    {
-        if (!((*i)->GetMiscValue() & healSpell->SchoolMask))
-            continue;
-
-        // Max Amount can be absorbed by this aura
-        int32 currentAbsorb = (*i)->GetAmount();
-
-        // Found empty aura (impossible but..)
-        if (currentAbsorb <= 0)
-        {
-            existExpired = true;
-            continue;
-        }
-
-        // currentAbsorb - damage can be absorbed by shield
-        // If need absorb less damage
-        if (RemainingHeal < currentAbsorb)
-            currentAbsorb = RemainingHeal;
-
-        RemainingHeal -= currentAbsorb;
-
-        // Reduce shield amount
-        (*i)->SetAmount((*i)->GetAmount() - currentAbsorb);
-        // Need remove it later
-        if ((*i)->GetAmount() <= 0)
-            existExpired = true;
-    }
-
-    // Remove all expired absorb auras
-    if (existExpired)
-    {
-        for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end();)
-        {
-            AuraEffect *auraEff = *i;
-            ++i;
-            if (auraEff->GetAmount() <= 0)
-            {
-                uint32 removedAuras = pVictim->m_removedAurasCount;
-                auraEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
-                if (removedAuras+1 < pVictim->m_removedAurasCount)
-                    i = vHealAbsorb.begin();
-            }
-        }
-    }
-
-    absorb = RemainingHeal > 0 ? (healAmount - RemainingHeal) : healAmount;
-    healAmount = RemainingHeal;
-}
-
-void Unit::AttackerStateUpdate (Unit *pVictim, WeaponAttackType attType, bool extra)
-{
-    if (hasUnitState(UNIT_STAT_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
-        return;
-
-    if (!pVictim->isAlive())
-        return;
-
-    if ((attType == BASE_ATTACK || attType == OFF_ATTACK) && !this->IsWithinLOSInMap(pVictim))
-        return;
-
-    CombatStart(pVictim);
-    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
-
-    uint32 hitInfo;
-    if (attType == BASE_ATTACK)
-        hitInfo = HITINFO_NORMALSWING2;
-    else if (attType == OFF_ATTACK)
-        hitInfo = HITINFO_LEFTSWING;
-    else
-        return;                                             // ignore ranged case
-
-    // melee attack spell casted at main hand attack only - no normal melee dmg dealt
-    if (attType == BASE_ATTACK && m_currentSpells[CURRENT_MELEE_SPELL])
-        m_currentSpells[CURRENT_MELEE_SPELL]->cast();
-    else
-    {
-        // attack can be redirected to another target
-        pVictim = SelectMagnetTarget(pVictim);
-
-        CalcDamageInfo damageInfo;
-        CalculateMeleeDamage(pVictim, 0, &damageInfo, attType);
-        // Send log damage message to client
-        DealDamageMods(pVictim, damageInfo.damage, &damageInfo.absorb);
-        SendAttackStateUpdate(&damageInfo);
-
-        ProcDamageAndSpell(damageInfo.target, damageInfo.procAttacker, damageInfo.procVictim, damageInfo.procEx, damageInfo.damage, damageInfo.attackType);
-        DealMeleeDamage(&damageInfo,true);
-
-        if (GetTypeId() == TYPEID_PLAYER)
-            sLog.outStaticDebug("AttackerStateUpdate: (Player) %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
-                GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
-        else
-            sLog.outStaticDebug("AttackerStateUpdate: (NPC)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
-                GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
-    }
-
-    if(!extra && m_extraAttacks)
-    {
-        while(m_extraAttacks)
-        {
-            AttackerStateUpdate(pVictim, BASE_ATTACK, true);
-            if(m_extraAttacks > 0)
-                --m_extraAttacks;
-        }
-    }
-}
-
-MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(const Unit *pVictim, WeaponAttackType attType) const
-{
-    // This is only wrapper
-
-    // Miss chance based on melee
-    //float miss_chance = MeleeMissChanceCalc(pVictim, attType);
-    float miss_chance = MeleeSpellMissChance(pVictim, attType, int32(GetWeaponSkillValue(attType,pVictim)) - int32(pVictim->GetDefenseSkillValue(this)), 0);
-
-    // Critical hit chance
-    float crit_chance = GetUnitCriticalChance(attType, pVictim);
-
-    // stunned target cannot dodge and this is check in GetUnitDodgeChance() (returned 0 in this case)
-    float dodge_chance = pVictim->GetUnitDodgeChance();
-    float block_chance = pVictim->GetUnitBlockChance();
-    float parry_chance = pVictim->GetUnitParryChance();
-
-    // Useful if want to specify crit & miss chances for melee, else it could be removed
-    sLog.outStaticDebug("MELEE OUTCOME: miss %f crit %f dodge %f parry %f block %f", miss_chance,crit_chance,dodge_chance,parry_chance,block_chance);
-
-    return RollMeleeOutcomeAgainst(pVictim, attType, int32(crit_chance*100), int32(miss_chance*100), int32(dodge_chance*100),int32(parry_chance*100),int32(block_chance*100));
-}
-
-MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit *pVictim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance) const
-{
-    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode())
-        return MELEE_HIT_EVADE;
-
-    int32 attackerMaxSkillValueForLevel = GetMaxSkillValueForLevel(pVictim);
-    int32 victimMaxSkillValueForLevel = pVictim->GetMaxSkillValueForLevel(this);
-
-    int32 attackerWeaponSkill = GetWeaponSkillValue(attType,pVictim);
-    int32 victimDefenseSkill = pVictim->GetDefenseSkillValue(this);
-
-    // bonus from skills is 0.04%
-    int32    skillBonus  = 4 * (attackerWeaponSkill - victimMaxSkillValueForLevel);
-    int32    sum = 0, tmp = 0;
-    int32    roll = urand (0, 10000);
-
-    sLog.outStaticDebug ("RollMeleeOutcomeAgainst: skill bonus of %d for attacker", skillBonus);
-    sLog.outStaticDebug ("RollMeleeOutcomeAgainst: rolled %d, miss %d, dodge %d, parry %d, block %d, crit %d",
-        roll, miss_chance, dodge_chance, parry_chance, block_chance, crit_chance);
-
-    tmp = miss_chance;
-
-    if (tmp > 0 && roll < (sum += tmp))
-    {
-        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: MISS");
-        return MELEE_HIT_MISS;
-    }
-
-    // always crit against a sitting target (except 0 crit chance)
-    if (pVictim->GetTypeId() == TYPEID_PLAYER && crit_chance > 0 && !pVictim->IsStandState())
-    {
-        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRIT (sitting victim)");
-        return MELEE_HIT_CRIT;
-    }
-
-    // Dodge chance
-
-    // only players can't dodge if attacker is behind
-    if (pVictim->GetTypeId() == TYPEID_PLAYER && !pVictim->HasInArc(M_PI,this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
-    {
-        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
-    }
-    else
-    {
-        // Reduce dodge chance by attacker expertise rating
-        if (GetTypeId() == TYPEID_PLAYER)
-            dodge_chance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType)*100);
-        else
-            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
-
-        // Modify dodge chance by attacker SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
-        dodge_chance+= GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE)*100;
-        dodge_chance = int32 (float (dodge_chance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));
-
-        tmp = dodge_chance;
-        if ((tmp > 0)                                        // check if unit _can_ dodge
-            && ((tmp -= skillBonus) > 0)
-            && roll < (sum += tmp))
-        {
-            sLog.outStaticDebug ("RollMeleeOutcomeAgainst: DODGE <%d, %d)", sum-tmp, sum);
-            return MELEE_HIT_DODGE;
-        }
-    }
-
-    // parry & block chances
-
-    // check if attack comes from behind, nobody can parry or block if attacker is behind
-    if (!pVictim->HasInArc(M_PI, this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
-        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: attack came from behind.");
-    else
-    {
-        // Reduce parry chance by attacker expertise rating
-        if (GetTypeId() == TYPEID_PLAYER)
-            parry_chance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType)*100);
-        else
-            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
-
-        if (pVictim->GetTypeId() == TYPEID_PLAYER || !(pVictim->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY))
-        {
-            int32 tmp2 = int32(parry_chance);
-            if (tmp2 > 0                                         // check if unit _can_ parry
-                && (tmp2 -= skillBonus) > 0
-                && roll < (sum += tmp2))
-            {
-                sLog.outStaticDebug ("RollMeleeOutcomeAgainst: PARRY <%d, %d)", sum-tmp2, sum);
-                return MELEE_HIT_PARRY;
-            }
-        }
-
-        if (pVictim->GetTypeId() == TYPEID_PLAYER || !(pVictim->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
-        {
-            tmp = block_chance;
-            if (tmp > 0                                          // check if unit _can_ block
-                && (tmp -= skillBonus) > 0
-                && roll < (sum += tmp))
-            {
-                sLog.outStaticDebug ("RollMeleeOutcomeAgainst: BLOCK <%d, %d)", sum-tmp, sum);
-                return MELEE_HIT_BLOCK;
-            }
-        }
-    }
-
-    // Critical chance
-    tmp = crit_chance;
-
-    if (tmp > 0 && roll < (sum += tmp))
-    {
-        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRIT <%d, %d)", sum-tmp, sum);
-        if (GetTypeId() == TYPEID_UNIT && (this->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRIT))
-            sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRIT DISABLED)");
-        else
-            return MELEE_HIT_CRIT;
-    }
-
-    // Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)
-    if (attType != RANGED_ATTACK &&
-        (GetTypeId() == TYPEID_PLAYER || this->ToCreature()->isPet()) &&
-        pVictim->GetTypeId() != TYPEID_PLAYER && !pVictim->ToCreature()->isPet() &&
-        getLevel() < pVictim->getLevelForTarget(this))
-    {
-        // cap possible value (with bonuses > max skill)
-        int32 skill = attackerWeaponSkill;
-        int32 maxskill = attackerMaxSkillValueForLevel;
-        skill = (skill > maxskill) ? maxskill : skill;
-
-        tmp = (10 + (victimDefenseSkill - skill)) * 100;
-        tmp = tmp > 4000 ? 4000 : tmp;
-        if (roll < (sum += tmp))
-        {
-            sLog.outStaticDebug ("RollMeleeOutcomeAgainst: GLANCING <%d, %d)", sum-4000, sum);
-            return MELEE_HIT_GLANCING;
-        }
-    }
-
-    // mobs can score crushing blows if they're 4 or more levels above victim
-    if (getLevelForTarget(pVictim) >= pVictim->getLevelForTarget(this) + 4 &&
-        // can be from by creature (if can) or from controlled player that considered as creature
-        !IsControlledByPlayer() &&
-        !(GetTypeId() == TYPEID_UNIT && this->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRUSH))
-    {
-        // when their weapon skill is 15 or more above victim's defense skill
-        tmp = victimDefenseSkill;
-        int32 tmpmax = victimMaxSkillValueForLevel;
-        // having defense above your maximum (from items, talents etc.) has no effect
-        tmp = tmp > tmpmax ? tmpmax : tmp;
-        // tmp = mob's level * 5 - player's current defense skill
-        tmp = attackerMaxSkillValueForLevel - tmp;
-        if (tmp >= 15)
-        {
-            // add 2% chance per lacking skill point, min. is 15%
-            tmp = tmp * 200 - 1500;
-            if (roll < (sum += tmp))
-            {
-                sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRUSHING <%d, %d)", sum-tmp, sum);
-                return MELEE_HIT_CRUSHING;
-            }
-        }
-    }
-
-    sLog.outStaticDebug ("RollMeleeOutcomeAgainst: NORMAL");
-    return MELEE_HIT_NORMAL;
-}
-
-uint32 Unit::CalculateDamage(WeaponAttackType attType, bool normalized, bool addTotalPct)
-{
-    float min_damage, max_damage;
-
-    if (GetTypeId() == TYPEID_PLAYER && (normalized || !addTotalPct))
-        this->ToPlayer()->CalculateMinMaxDamage(attType,normalized,addTotalPct,min_damage, max_damage);
-    else
-    {
-        switch (attType)
-        {
-            case RANGED_ATTACK:
-                min_damage = GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE);
-                max_damage = GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE);
-                break;
-            case BASE_ATTACK:
-                min_damage = GetFloatValue(UNIT_FIELD_MINDAMAGE);
-                max_damage = GetFloatValue(UNIT_FIELD_MAXDAMAGE);
-                break;
-            case OFF_ATTACK:
-                min_damage = GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE);
-                max_damage = GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE);
-                break;
-                // Just for good manner
-            default:
-                min_damage = 0.0f;
-                max_damage = 0.0f;
-                break;
-        }
-    }
-
-    if (min_damage > max_damage)
-        std::swap(min_damage,max_damage);
-
-    if (max_damage == 0.0f)
-        max_damage = 5.0f;
-
-    return urand((uint32)min_damage, (uint32)max_damage);
-}
-
-float Unit::CalculateLevelPenalty(SpellEntry const* spellProto) const
-{
-    if (spellProto->spellLevel <= 0 || spellProto->spellLevel >= spellProto->maxLevel)
-        return 1.0f;
-
-    float LvlPenalty = 0.0f;
-
-    if (spellProto->spellLevel < 20)
-        LvlPenalty = 20.0f - spellProto->spellLevel * 3.75f;
-    float LvlFactor = (float(spellProto->spellLevel) + 6.0f) / float(getLevel());
-    if (LvlFactor > 1.0f)
-        LvlFactor = 1.0f;
-
-    return (100.0f - LvlPenalty) * LvlFactor / 100.0f;
-}
-
-void Unit::SendMeleeAttackStart(Unit* pVictim)
-{
-    WorldPacket data(SMSG_ATTACKSTART, 8 + 8);
-    data << uint64(GetGUID());
-    data << uint64(pVictim->GetGUID());
-
-    SendMessageToSet(&data, true);
-    sLog.outStaticDebug("WORLD: Sent SMSG_ATTACKSTART");
-}
-
-void Unit::SendMeleeAttackStop(Unit* victim)
-{
-    if (!victim)
-        return;
-
-    WorldPacket data(SMSG_ATTACKSTOP, (8+8+4));            // we guess size
-    data.append(GetPackGUID());
-    data.append(victim->GetPackGUID());                     // can be 0x00...
-    data << uint32(0);                                      // can be 0x1
-    SendMessageToSet(&data, true);
-    sLog.outDetail("%s %u stopped attacking %s %u", (GetTypeId() == TYPEID_PLAYER ? "player" : "creature"), GetGUIDLow(), (victim->GetTypeId() == TYPEID_PLAYER ? "player" : "creature"),victim->GetGUIDLow());
-}
-
-bool Unit::isSpellBlocked(Unit *pVictim, SpellEntry const * /*spellProto*/, WeaponAttackType attackType)
-{
-    if (pVictim->HasInArc(M_PI,this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
-    {
-        // Check creatures flags_extra for disable block
-        if (pVictim->GetTypeId() == TYPEID_UNIT &&
-           pVictim->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
-                return false;
-
-        float blockChance = pVictim->GetUnitBlockChance();
-        blockChance += (int32(GetWeaponSkillValue(attackType)) - int32(pVictim->GetMaxSkillValueForLevel()))*0.04f;
-        if (roll_chance_f(blockChance))
-            return true;
-    }
-    return false;
-}
-
-bool Unit::isBlockCritical()
-{
-    if (roll_chance_i(GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_CRIT_CHANCE)))
-        return true;
-    return false;
-}
-
-int32 Unit::GetMechanicResistChance(const SpellEntry *spell)
-{
-    if (!spell)
-        return 0;
-    int32 resist_mech = 0;
-    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
-    {
-        if (spell->Effect[eff] == 0)
-           break;
-        int32 effect_mech = GetEffectMechanic(spell, eff);
-        if (effect_mech)
-        {
-            int32 temp = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);
-            if (resist_mech < temp)
-                resist_mech = temp;
-        }
-    }
-    return resist_mech;
-}
-
-// Melee based spells hit result calculations
-SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell)
-{
-    WeaponAttackType attType = BASE_ATTACK;
-
-    // Check damage class instead of attack type to correctly handle judgements
-    // - they are meele, but can't be dodged/parried/deflected because of ranged dmg class
-    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
-        attType = RANGED_ATTACK;
-
-    int32 attackerWeaponSkill;
-    // skill value for these spells (for example judgements) is 5* level
-    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED && !IsRangedWeaponSpell(spell))
-        attackerWeaponSkill = getLevel() * 5;
-    // bonus from skills is 0.04% per skill Diff
-    else
-        attackerWeaponSkill = int32(GetWeaponSkillValue(attType,pVictim));
-
-    int32 skillDiff = attackerWeaponSkill - int32(pVictim->GetMaxSkillValueForLevel(this));
-    int32 fullSkillDiff = attackerWeaponSkill - int32(pVictim->GetDefenseSkillValue(this));
-
-    uint32 roll = urand (0, 10000);
-
-    uint32 missChance = uint32(MeleeSpellMissChance(pVictim, attType, fullSkillDiff, spell->Id)*100.0f);
-    // Roll miss
-    uint32 tmp = missChance;
-    if (roll < tmp)
-        return SPELL_MISS_MISS;
-
-    // Chance resist mechanic (select max value from every mechanic spell effect)
-    int32 resist_mech = 0;
-    // Get effects mechanic and chance
-    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
-    {
-        int32 effect_mech = GetEffectMechanic(spell, eff);
-        if (effect_mech)
-        {
-            int32 temp = pVictim->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);
-            if (resist_mech < temp*100)
-                resist_mech = temp*100;
-        }
-    }
-    // Roll chance
-    tmp += resist_mech;
-    if (roll < tmp)
-        return SPELL_MISS_RESIST;
-
-    bool canDodge = true;
-    bool canParry = true;
-    bool canBlock = spell->AttributesEx3 & SPELL_ATTR_EX3_BLOCKABLE_SPELL;
-
-    // Same spells cannot be parry/dodge
-    if (spell->Attributes & SPELL_ATTR_IMPOSSIBLE_DODGE_PARRY_BLOCK)
-        return SPELL_MISS_NONE;
-
-    // Chance resist mechanic
-    int32 resist_chance = pVictim->GetMechanicResistChance(spell)*100;
-    tmp += resist_chance;
-    if (roll < tmp)
-        return SPELL_MISS_RESIST;
-
-    // Ranged attacks can only miss, resist and deflect
-    if (attType == RANGED_ATTACK)
-    {
-        // only if in front
-        if (pVictim->HasInArc(M_PI,this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
-        {
-            int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS)*100;
-            tmp+=deflect_chance;
-            if (roll < tmp)
-                return SPELL_MISS_DEFLECT;
-        }
-        return SPELL_MISS_NONE;
-    }
-
-    // Check for attack from behind
-    if (!pVictim->HasInArc(M_PI,this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
-    {
-        // Can`t dodge from behind in PvP (but its possible in PvE)
-        if (pVictim->GetTypeId() == TYPEID_PLAYER)
-            canDodge = false;
-        // Can`t parry or block
-        canParry = false;
-        canBlock = false;
-    }
-    // Check creatures flags_extra for disable parry
-    if (pVictim->GetTypeId() == TYPEID_UNIT)
-    {
-        uint32 flagEx = pVictim->ToCreature()->GetCreatureInfo()->flags_extra;
-        if (flagEx & CREATURE_FLAG_EXTRA_NO_PARRY)
-            canParry = false;
-        // Check creatures flags_extra for disable block
-        if (flagEx & CREATURE_FLAG_EXTRA_NO_BLOCK)
-            canBlock = false;
-    }
-    // Ignore combat result aura
-    AuraEffectList const &ignore = GetAuraEffectsByType(SPELL_AURA_IGNORE_COMBAT_RESULT);
-    for (AuraEffectList::const_iterator i = ignore.begin(); i != ignore.end(); ++i)
-    {
-        if (!(*i)->IsAffectedOnSpell(spell))
-            continue;
-        switch ((*i)->GetMiscValue())
-        {
-            case MELEE_HIT_DODGE: canDodge = false; break;
-            case MELEE_HIT_BLOCK: canBlock = false; break;
-            case MELEE_HIT_PARRY: canParry = false; break;
-            default:
-                sLog.outStaticDebug("Spell %u SPELL_AURA_IGNORE_COMBAT_RESULT have unhandled state %d", (*i)->GetId(), (*i)->GetMiscValue());
-                break;
-        }
-    }
-
-    if (canDodge)
-    {
-        // Roll dodge
-        int32 dodgeChance = int32(pVictim->GetUnitDodgeChance()*100.0f) - skillDiff * 4;
-        // Reduce enemy dodge chance by SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
-        dodgeChance += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE)*100;
-        dodgeChance = int32(float(dodgeChance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));
-        // Reduce dodge chance by attacker expertise rating
-        if (GetTypeId() == TYPEID_PLAYER)
-            dodgeChance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);
-        else
-            dodgeChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
-        if (dodgeChance < 0)
-            dodgeChance = 0;
-
-        if (roll < (tmp += dodgeChance))
-            return SPELL_MISS_DODGE;
-    }
-
-    if (canParry)
-    {
-        // Roll parry
-        int32 parryChance = int32(pVictim->GetUnitParryChance()*100.0f)  - skillDiff * 4;
-        // Reduce parry chance by attacker expertise rating
-        if (GetTypeId() == TYPEID_PLAYER)
-            parryChance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);
-        else
-            parryChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
-        if (parryChance < 0)
-            parryChance = 0;
-
-        tmp += parryChance;
-        if (roll < tmp)
-            return SPELL_MISS_PARRY;
-    }
-
-    if (canBlock)
-    {
-        int32 blockChance = int32(pVictim->GetUnitBlockChance()*100.0f)  - skillDiff * 4;
-        if (blockChance < 0)
-            blockChance = 0;
-        tmp += blockChance;
-
-        if (roll < tmp)
-            return SPELL_MISS_BLOCK;
-    }
-
-    return SPELL_MISS_NONE;
-}
-
-// TODO need use unit spell resistances in calculations
-SpellMissInfo Unit::MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell)
-{
-    // Can`t miss on dead target (on skinning for example)
-    if (!pVictim->isAlive() && pVictim->GetTypeId() != TYPEID_PLAYER)
-        return SPELL_MISS_NONE;
-
-    SpellSchoolMask schoolMask = GetSpellSchoolMask(spell);
-    // PvP - PvE spell misschances per leveldif > 2
-    int32 lchance = pVictim->GetTypeId() == TYPEID_PLAYER ? 7 : 11;
-    int32 leveldif = int32(pVictim->getLevelForTarget(this)) - int32(getLevelForTarget(pVictim));
-
-    // Base hit chance from attacker and victim levels
-    int32 modHitChance;
-    if (leveldif < 3)
-        modHitChance = 96 - leveldif;
-    else
-        modHitChance = 94 - (leveldif - 2) * lchance;
-
-    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
-    if (Player *modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spell->Id, SPELLMOD_RESIST_MISS_CHANCE, modHitChance);
-    // Increase from attacker SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT auras
-    modHitChance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, schoolMask);
-    // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
-    modHitChance += pVictim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, schoolMask);
-    // Reduce spell hit chance for Area of effect spells from victim SPELL_AURA_MOD_AOE_AVOIDANCE aura
-    if (IsAreaOfEffectSpell(spell))
-        modHitChance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_AOE_AVOIDANCE);
-
-    int32 HitChance = modHitChance * 100;
-    // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
-    HitChance += int32(m_modSpellHitChance * 100.0f);
-
-    // Decrease hit chance from victim rating bonus
-    if (pVictim->GetTypeId() == TYPEID_PLAYER)
-        HitChance -= int32(pVictim->ToPlayer()->GetRatingBonusValue(CR_HIT_TAKEN_SPELL) * 100.0f);
-
-    if (HitChance < 100)
-        HitChance = 100;
-    else if (HitChance > 10000)
-        HitChance = 10000;
-
-    int32 tmp = 10000 - HitChance;
-
-    int32 rand = irand(0, 10000);
-
-    if (rand < tmp)
-        return SPELL_MISS_MISS;
-
-    // Chance resist mechanic (select max value from every mechanic spell effect)
-    int32 resist_chance = pVictim->GetMechanicResistChance(spell) * 100;
-    tmp += resist_chance;
-
-    // Chance resist debuff
-    if (!IsPositiveSpell(spell->Id))
-    {
-        bool bNegativeAura = false;
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (spell->EffectApplyAuraName[i] != 0)
-            {
-                bNegativeAura = true;
-                break;
-            }
-        }
-
-        if (bNegativeAura)
-        {
-            tmp += pVictim->GetMaxPositiveAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spell->Dispel)) * 100;
-            tmp += pVictim->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spell->Dispel)) * 100;
-        }
-    }
-
-   // Roll chance
-    if (rand < tmp)
-        return SPELL_MISS_RESIST;
-
-    // cast by caster in front of victim
-    if (pVictim->HasInArc(M_PI, this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
-    {
-        int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;
-        tmp += deflect_chance;
-        if (rand < tmp)
-            return SPELL_MISS_DEFLECT;
-    }
-
-    return SPELL_MISS_NONE;
-}
-
-// Calculate spell hit result can be:
-// Every spell can: Evade/Immune/Reflect/Sucesful hit
-// For melee based spells:
-//   Miss
-//   Dodge
-//   Parry
-// For spells
-//   Resist
-SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool CanReflect)
-{
-    // Return evade for units in evade mode
-    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode() && this != pVictim)
-        return SPELL_MISS_EVADE;
-
-    // Check for immune
-    if (pVictim->IsImmunedToSpell(spell))
-        return SPELL_MISS_IMMUNE;
-
-    // All positive spells can`t miss
-    // TODO: client not show miss log for this spells - so need find info for this in dbc and use it!
-    if (IsPositiveSpell(spell->Id)
-        &&(!IsHostileTo(pVictim)))  //prevent from affecting enemy by "positive" spell
-        return SPELL_MISS_NONE;
-    // Check for immune
-    if (pVictim->IsImmunedToDamage(spell))
-        return SPELL_MISS_IMMUNE;
-
-    if (this == pVictim)
-        return SPELL_MISS_NONE;
-
-    // Try victim reflect spell
-    if (CanReflect)
-    {
-        int32 reflectchance = pVictim->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS);
-        Unit::AuraEffectList const& mReflectSpellsSchool = pVictim->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
-        for (Unit::AuraEffectList::const_iterator i = mReflectSpellsSchool.begin(); i != mReflectSpellsSchool.end(); ++i)
-            if ((*i)->GetMiscValue() & GetSpellSchoolMask(spell))
-                reflectchance += (*i)->GetAmount();
-        if (reflectchance > 0 && roll_chance_i(reflectchance))
-        {
-            // Start triggers for remove charges if need (trigger only for victim, and mark as active spell)
-            ProcDamageAndSpell(pVictim, PROC_FLAG_NONE, PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG, PROC_EX_REFLECT, 1, BASE_ATTACK, spell);
-            return SPELL_MISS_REFLECT;
-        }
-    }
-
-    switch (spell->DmgClass)
-    {
-        case SPELL_DAMAGE_CLASS_RANGED:
-        case SPELL_DAMAGE_CLASS_MELEE:
-            return MeleeSpellHitResult(pVictim, spell);
-        case SPELL_DAMAGE_CLASS_NONE:
-            return SPELL_MISS_NONE;
-        case SPELL_DAMAGE_CLASS_MAGIC:
-            return MagicSpellHitResult(pVictim, spell);
-    }
-    return SPELL_MISS_NONE;
-}
-
-uint32 Unit::GetDefenseSkillValue(Unit const* target) const
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        // in PvP use full skill instead current skill value
-        uint32 value = (target && target->GetTypeId() == TYPEID_PLAYER)
-            ? this->ToPlayer()->GetMaxSkillValue(SKILL_DEFENSE)
-            : this->ToPlayer()->GetSkillValue(SKILL_DEFENSE);
-        value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_DEFENSE_SKILL));
-        return value;
-    }
-    else
-        return GetUnitMeleeSkill(target);
-}
-
-float Unit::GetUnitDodgeChance() const
-{
-    if (hasUnitState(UNIT_STAT_STUNNED))
-        return 0.0f;
-    if (GetTypeId() == TYPEID_PLAYER)
-        return GetFloatValue(PLAYER_DODGE_PERCENTAGE);
-    else
-    {
-        if (((Creature const*)this)->isTotem())
-            return 0.0f;
-        else
-        {
-            float dodge = 5.0f;
-            dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
-            return dodge > 0.0f ? dodge : 0.0f;
-        }
-    }
-}
-
-float Unit::GetUnitParryChance() const
-{
-    if (IsNonMeleeSpellCasted(false) || hasUnitState(UNIT_STAT_STUNNED))
-        return 0.0f;
-
-    float chance = 0.0f;
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        Player const* player = (Player const*)this;
-        if (player->CanParry())
-        {
-            Item *tmpitem = player->GetWeaponForAttack(BASE_ATTACK,true);
-            if (!tmpitem)
-                tmpitem = player->GetWeaponForAttack(OFF_ATTACK,true);
-
-            if (tmpitem)
-                chance = GetFloatValue(PLAYER_PARRY_PERCENTAGE);
-        }
-    }
-    else if (GetTypeId() == TYPEID_UNIT)
-    {
-        if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
-        {
-            chance = 5.0f;
-            chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
-        }
-    }
-
-    return chance > 0.0f ? chance : 0.0f;
-}
-
-float Unit::GetUnitBlockChance() const
-{
-    if (IsNonMeleeSpellCasted(false) || hasUnitState(UNIT_STAT_STUNNED))
-        return 0.0f;
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        Player const* player = (Player const*)this;
-        if (player->CanBlock())
-        {
-            Item *tmpitem = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
-            if (tmpitem && !tmpitem->IsBroken() && tmpitem->GetProto()->Block)
-                return GetFloatValue(PLAYER_BLOCK_PERCENTAGE);
-        }
-        // is player but has no block ability or no not broken shield equipped
-        return 0.0f;
-    }
-    else
-    {
-        if (((Creature const*)this)->isTotem())
-            return 0.0f;
-        else
-        {
-            float block = 5.0f;
-            block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
-            return block > 0.0f ? block : 0.0f;
-        }
-    }
-}
-
-float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit *pVictim) const
-{
-    float crit;
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        switch(attackType)
-        {
-            case BASE_ATTACK:
-                crit = GetFloatValue(PLAYER_CRIT_PERCENTAGE);
-                break;
-            case OFF_ATTACK:
-                crit = GetFloatValue(PLAYER_OFFHAND_CRIT_PERCENTAGE);
-                break;
-            case RANGED_ATTACK:
-                crit = GetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE);
-                break;
-                // Just for good manner
-            default:
-                crit = 0.0f;
-                break;
-        }
-    }
-    else
-    {
-        crit = 5.0f;
-        crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
-        crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
-    }
-
-    // flat aura mods
-    if (attackType == RANGED_ATTACK)
-        crit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_CHANCE);
-    else
-        crit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_CHANCE);
-
-    crit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
-
-    // reduce crit chance from Rating for players
-    if (attackType != RANGED_ATTACK)
-    {
-        ApplyResilience(pVictim, &crit, NULL, false, CR_CRIT_TAKEN_MELEE);
-        // Glyph of barkskin
-        if (pVictim->HasAura(63057) && pVictim->HasAura(22812))
-            crit -= 25.0f;
-    }
-    else
-        ApplyResilience(pVictim, &crit, NULL, false, CR_CRIT_TAKEN_RANGED);
-
-    // Apply crit chance from defence skill
-    crit += (int32(GetMaxSkillValueForLevel(pVictim)) - int32(pVictim->GetDefenseSkillValue(this))) * 0.04f;
-
-    if (crit < 0.0f)
-        crit = 0.0f;
-    return crit;
-}
-
-uint32 Unit::GetWeaponSkillValue (WeaponAttackType attType, Unit const* target) const
-{
-    uint32 value = 0;
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        Item* item = this->ToPlayer()->GetWeaponForAttack(attType,true);
-
-        // feral or unarmed skill only for base attack
-        if (attType != BASE_ATTACK && !item)
-            return 0;
-
-        if (IsInFeralForm())
-            return GetMaxSkillValueForLevel();              // always maximized SKILL_FERAL_COMBAT in fact
-
-        // weapon skill or (unarmed for base attack and fist weapons)
-        uint32 skill;
-        if (item && item->GetSkill() != SKILL_FIST_WEAPONS)
-            skill = item->GetSkill();
-        else
-            skill = SKILL_UNARMED;
-
-        // in PvP use full skill instead current skill value
-        value = (target && target->IsControlledByPlayer())
-            ? this->ToPlayer()->GetMaxSkillValue(skill)
-            : this->ToPlayer()->GetSkillValue(skill);
-        // Modify value from ratings
-        value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL));
-        switch (attType)
-        {
-            case BASE_ATTACK:   value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL_MAINHAND)); break;
-            case OFF_ATTACK:    value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL_OFFHAND));  break;
-            case RANGED_ATTACK: value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL_RANGED));   break;
-            default: break;
-        }
-    }
-    else
-        value = GetUnitMeleeSkill(target);
-   return value;
-}
-
-void Unit::_DeleteRemovedAuras()
-{
-    while (!m_removedAuras.empty())
-    {
-        delete m_removedAuras.front();
-        m_removedAuras.pop_front();
-    }
-}
-
-void Unit::_UpdateSpells(uint32 time)
-{
-    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
-        _UpdateAutoRepeatSpell();
-
-    // remove finished spells from current pointers
-    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
-    {
-        if (m_currentSpells[i] && m_currentSpells[i]->getState() == SPELL_STATE_FINISHED)
-        {
-            m_currentSpells[i]->SetReferencedFromCurrent(false);
-            m_currentSpells[i] = NULL;                      // remove pointer
-        }
-    }
-
-    // m_auraUpdateIterator can be updated in indirect called code at aura remove to skip next planned to update but removed auras
-    for (m_auraUpdateIterator = m_ownedAuras.begin(); m_auraUpdateIterator != m_ownedAuras.end();)
-    {
-        Aura * i_aura = m_auraUpdateIterator->second;
-        ++m_auraUpdateIterator;                            // need shift to next for allow update if need into aura update
-        i_aura->UpdateOwner(time, this);
-    }
-
-    // remove expired auras - do that after updates(used in scripts?)
-    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end();)
-    {
-        if (i->second->IsExpired())
-            RemoveOwnedAura(i, AURA_REMOVE_BY_EXPIRE);
-        else
-            ++i;
-    }
-
-    for (VisibleAuraMap::iterator itr = m_visibleAuras.begin(); itr != m_visibleAuras.end(); ++itr)
-        if (itr->second->IsNeedClientUpdate())
-            itr->second->ClientUpdate();
-
-    _DeleteRemovedAuras();
-
-    if (!m_gameObj.empty())
-    {
-        GameObjectList::iterator itr;
-        for (itr = m_gameObj.begin(); itr != m_gameObj.end();)
-        {
-            if (!(*itr)->isSpawned())
-            {
-                (*itr)->SetOwnerGUID(0);
-                (*itr)->SetRespawnTime(0);
-                (*itr)->Delete();
-                m_gameObj.erase(itr++);
-            }
-            else
-                ++itr;
-        }
-    }
-}
-
-void Unit::_UpdateAutoRepeatSpell()
-{
-    //check "realtime" interrupts
-    if ((GetTypeId() == TYPEID_PLAYER && ((Player*)this)->isMoving()) || IsNonMeleeSpellCasted(false,false,true,m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == 75))
-    {
-        // cancel wand shoot
-        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
-            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-        m_AutoRepeatFirstCast = true;
-        return;
-    }
-
-    //apply delay (Auto Shot (spellID 75) not affected)
-    if (m_AutoRepeatFirstCast && getAttackTimer(RANGED_ATTACK) < 500 && m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
-        setAttackTimer(RANGED_ATTACK,500);
-    m_AutoRepeatFirstCast = false;
-
-    //castroutine
-    if (isAttackReady(RANGED_ATTACK))
-    {
-        // Check if able to cast
-        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->CheckCast(true) != SPELL_CAST_OK)
-        {
-            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-            return;
-        }
-
-        // we want to shoot
-        Spell* spell = new Spell(this, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo, true);
-        spell->prepare(&(m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_targets));
-
-        // all went good, reset attack
-        resetAttackTimer(RANGED_ATTACK);
-    }
-}
-
-void Unit::SetCurrentCastedSpell(Spell * pSpell)
-{
-    ASSERT(pSpell);                                         // NULL may be never passed here, use InterruptSpell or InterruptNonMeleeSpells
-
-    CurrentSpellTypes CSpellType = pSpell->GetCurrentContainer();
-
-    if (pSpell == m_currentSpells[CSpellType]) return;      // avoid breaking self
-
-    // break same type spell if it is not delayed
-    InterruptSpell(CSpellType,false);
-
-    // special breakage effects:
-    switch (CSpellType)
-    {
-        case CURRENT_GENERIC_SPELL:
-        {
-            // generic spells always break channeled not delayed spells
-            InterruptSpell(CURRENT_CHANNELED_SPELL,false);
-
-            // autorepeat breaking
-            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
-            {
-                // break autorepeat if not Auto Shot
-                if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
-                    InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-                m_AutoRepeatFirstCast = true;
-            }
-            addUnitState(UNIT_STAT_CASTING);
-        } break;
-
-        case CURRENT_CHANNELED_SPELL:
-        {
-            // channel spells always break generic non-delayed and any channeled spells
-            InterruptSpell(CURRENT_GENERIC_SPELL,false);
-            InterruptSpell(CURRENT_CHANNELED_SPELL);
-
-            // it also does break autorepeat if not Auto Shot
-            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] &&
-                m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
-                InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
-            addUnitState(UNIT_STAT_CASTING);
-        } break;
-
-        case CURRENT_AUTOREPEAT_SPELL:
-        {
-            // only Auto Shoot does not break anything
-            if (pSpell->m_spellInfo->Id != 75)
-            {
-                // generic autorepeats break generic non-delayed and channeled non-delayed spells
-                InterruptSpell(CURRENT_GENERIC_SPELL,false);
-                InterruptSpell(CURRENT_CHANNELED_SPELL,false);
-            }
-            // special action: set first cast flag
-            m_AutoRepeatFirstCast = true;
-        } break;
-
-        default:
-        {
-            // other spell types don't break anything now
-        } break;
-    }
-
-    // current spell (if it is still here) may be safely deleted now
-    if (m_currentSpells[CSpellType])
-        m_currentSpells[CSpellType]->SetReferencedFromCurrent(false);
-
-    // set new current spell
-    m_currentSpells[CSpellType] = pSpell;
-    pSpell->SetReferencedFromCurrent(true);
-
-    pSpell->m_selfContainer = &(m_currentSpells[pSpell->GetCurrentContainer()]);
-}
-
-void Unit::InterruptSpell(CurrentSpellTypes spellType, bool withDelayed, bool withInstant)
-{
-    ASSERT(spellType < CURRENT_MAX_SPELL);
-
-    //sLog.outDebug("Interrupt spell for unit %u.", GetEntry());
-    Spell *spell = m_currentSpells[spellType];
-    if (spell
-        && (withDelayed || spell->getState() != SPELL_STATE_DELAYED)
-        && (withInstant || spell->GetCastTime() > 0))
-    {
-        // for example, do not let self-stun aura interrupt itself
-        if (!spell->IsInterruptable())
-            return;
-
-        m_currentSpells[spellType] = NULL;
-
-        // send autorepeat cancel message for autorepeat spells
-        if (spellType == CURRENT_AUTOREPEAT_SPELL)
-        {
-            if (GetTypeId() == TYPEID_PLAYER)
-                this->ToPlayer()->SendAutoRepeatCancel(this);
-        }
-
-        if (spell->getState() != SPELL_STATE_FINISHED)
-            spell->cancel();
-        spell->SetReferencedFromCurrent(false);
-    }
-}
-
-void Unit::FinishSpell(CurrentSpellTypes spellType, bool ok /*= true*/)
-{
-    Spell* spell = m_currentSpells[spellType];
-    if (!spell)
-        return;
-
-    if (spellType == CURRENT_CHANNELED_SPELL)
-        spell->SendChannelUpdate(0);
-
-    spell->finish(ok);
-}
-
-bool Unit::IsNonMeleeSpellCasted(bool withDelayed, bool skipChanneled, bool skipAutorepeat, bool isAutoshoot, bool skipInstant) const
-{
-    // We don't do loop here to explicitly show that melee spell is excluded.
-    // Maybe later some special spells will be excluded too.
-
-    // if checkInstant then instant spells shouldn't count as being casted
-    if (!skipInstant && m_currentSpells[CURRENT_GENERIC_SPELL] && !m_currentSpells[CURRENT_GENERIC_SPELL]->GetCastTime())
-        return false;
-
-    // generic spells are casted when they are not finished and not delayed
-    if (m_currentSpells[CURRENT_GENERIC_SPELL] &&
-        (m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_FINISHED) &&
-        (withDelayed || m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_DELAYED))
-    {
-        if (!isAutoshoot || !(m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_RESET_AUTO_ACTIONS))
-            return(true);
-    }
-    // channeled spells may be delayed, but they are still considered casted
-    else if (!skipChanneled && m_currentSpells[CURRENT_CHANNELED_SPELL] &&
-        (m_currentSpells[CURRENT_CHANNELED_SPELL]->getState() != SPELL_STATE_FINISHED))
-    {
-        if (!isAutoshoot || !(m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_RESET_AUTO_ACTIONS))
-            return(true);
-    }
-    // autorepeat spells may be finished or delayed, but they are still considered casted
-    else if (!skipAutorepeat && m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
-        return(true);
-
-    return(false);
-}
-
-void Unit::InterruptNonMeleeSpells(bool withDelayed, uint32 spell_id, bool withInstant)
-{
-    // generic spells are interrupted if they are not finished or delayed
-    if (m_currentSpells[CURRENT_GENERIC_SPELL] && (!spell_id || m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->Id == spell_id))
-        InterruptSpell(CURRENT_GENERIC_SPELL,withDelayed,withInstant);
-
-    // autorepeat spells are interrupted if they are not finished or delayed
-    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] && (!spell_id || m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == spell_id))
-        InterruptSpell(CURRENT_AUTOREPEAT_SPELL,withDelayed,withInstant);
-
-    // channeled spells are interrupted if they are not finished, even if they are delayed
-    if (m_currentSpells[CURRENT_CHANNELED_SPELL] && (!spell_id || m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->Id == spell_id))
-        InterruptSpell(CURRENT_CHANNELED_SPELL,true,true);
-}
-
-Spell* Unit::FindCurrentSpellBySpellId(uint32 spell_id) const
-{
-    for (uint32 i = 0; i < CURRENT_MAX_SPELL; i++)
-        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id == spell_id)
-            return m_currentSpells[i];
-    return NULL;
-}
-
-int32 Unit::GetCurrentSpellCastTime(uint32 spell_id) const
-{
-    if (Spell const * spell = FindCurrentSpellBySpellId(spell_id))
-        return spell->GetCastTime();
-    return 0;
-}
-
-bool Unit::isInFrontInMap(Unit const* target, float distance,  float arc) const
-{
-    return IsWithinDistInMap(target, distance) && HasInArc(arc, target);
-}
-
-bool Unit::isInBackInMap(Unit const* target, float distance, float arc) const
-{
-    return IsWithinDistInMap(target, distance) && !HasInArc(2 * M_PI - arc, target);
-}
-
-void Unit::SetFacingToObject(WorldObject* pObject)
-{
-    // update orientation at server
-    SetOrientation(GetAngle(pObject));
-
-    // and client
-    WorldPacket data;
-    BuildHeartBeatMsg(&data);
-    SendMessageToSet(&data, false);
-}
-
-bool Unit::isInAccessiblePlaceFor(Creature const* c) const
-{
-    if (IsInWater())
-        return c->canSwim();
-    else
-        return c->canWalk() || c->canFly();
-}
-
-bool Unit::IsInWater() const
-{
-    return GetBaseMap()->IsInWater(GetPositionX(),GetPositionY(), GetPositionZ());
-}
-
-bool Unit::IsUnderWater() const
-{
-    return GetBaseMap()->IsUnderWater(GetPositionX(),GetPositionY(),GetPositionZ());
-}
-
-void Unit::DeMorph()
-{
-    SetDisplayId(GetNativeDisplayId());
-}
-
-void Unit::_AddAura(UnitAura * aura, Unit * caster)
-{
-    ASSERT(!m_cleanupDone);
-    m_ownedAuras.insert(AuraMap::value_type(aura->GetId(), aura));
-
-    // passive and Incanter's Absorption and auras with different type can stack with themselves any number of times
-    if (!aura->IsPassive() && aura->GetId() != 44413)
-    {
-        // find current aura from spell and change it's stackamount
-        if (Aura * foundAura = GetOwnedAura(aura->GetId(), aura->GetCasterGUID(), 0, aura))
-        {
-            if (aura->GetSpellProto()->StackAmount)
-            {
-                aura->ModStackAmount(foundAura->GetStackAmount());
-            }
-            // Update periodic timers from the previous aura
-            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-            {
-                AuraEffect *existingEff = foundAura->GetEffect(i);
-                AuraEffect *newEff = aura->GetEffect(i);
-                if (!existingEff || !newEff)
-                    continue;
-                newEff->SetPeriodicTimer(existingEff->GetPeriodicTimer());
-            }
-
-            // Use the new one to replace the old one
-            // This is the only place where AURA_REMOVE_BY_STACK should be used
-            RemoveOwnedAura(foundAura, AURA_REMOVE_BY_STACK);
-        }
-    }
-    _RemoveNoStackAurasDueToAura(aura);
-
-    if (aura->IsRemoved())
-        return;
-
-    aura->SetIsSingleTarget(caster && IsSingleTargetSpell(aura->GetSpellProto()));
-    if (aura->IsSingleTarget())
-    {
-        ASSERT((IsInWorld() && !IsDuringRemoveFromWorld()) || (aura->GetCasterGUID() == GetGUID()));
-        // register single target aura
-        caster->GetSingleCastAuras().push_back(aura);
-        // remove other single target auras
-        Unit::AuraList& scAuras = caster->GetSingleCastAuras();
-        for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end();)
-        {
-            if ((*itr) != aura &&
-                IsSingleTargetSpells((*itr)->GetSpellProto(), aura->GetSpellProto()))
-            {
-                (*itr)->Remove();
-                itr = scAuras.begin();
-            }
-            else
-                ++itr;
-        }
-    }
-}
-
-// creates aura application instance and registers it in lists
-// aura application effects are handled separately to prevent aura list corruption
-AuraApplication * Unit::_CreateAuraApplication(Aura * aura, uint8 effMask)
-{
-    // can't apply aura on unit which is going to be deleted - to not create a memory leak
-    ASSERT(!m_cleanupDone);
-    // aura musn't be removed
-    ASSERT(!aura->IsRemoved());
-
-    SpellEntry const* aurSpellInfo = aura->GetSpellProto();
-    uint32 aurId = aurSpellInfo->Id;
-
-    // ghost spell check, allow apply any auras at player loading in ghost mode (will be cleanup after load)
-    if (!isAlive() && !IsDeathPersistentSpell(aurSpellInfo) &&
-        (GetTypeId() != TYPEID_PLAYER || !this->ToPlayer()->GetSession()->PlayerLoading()))
-        return NULL;
-
-    Unit * caster = aura->GetCaster();
-
-    AuraApplication * aurApp = new AuraApplication(this, caster, aura, effMask);
-    m_appliedAuras.insert(AuraApplicationMap::value_type(aurId, aurApp));
-
-    if (aurSpellInfo->AuraInterruptFlags)
-    {
-        m_interruptableAuras.push_back(aurApp);
-        AddInterruptMask(aurSpellInfo->AuraInterruptFlags);
-    }
-
-    if (AuraState aState = GetSpellAuraState(aura->GetSpellProto()))
-        m_auraStateAuras.insert(AuraStateAurasMap::value_type(aState, aurApp));
-
-    aura->_ApplyForTarget(this, caster, aurApp);
-    return aurApp;
-}
-
-void Unit::_ApplyAuraEffect(Aura * aura, uint8 effIndex)
-{
-    ASSERT(aura);
-    ASSERT(aura->HasEffect(effIndex));
-    AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());
-    ASSERT(aurApp);
-    if (!aurApp->GetEffectMask())
-        _ApplyAura(aurApp, 1<<effIndex);
-    else
-        aurApp->_HandleEffect(effIndex, true);
-}
-
-// handles effects of aura application
-// should be done after registering aura in lists
-void Unit::_ApplyAura(AuraApplication * aurApp, uint8 effMask)
-{
-    Aura * aura = aurApp->GetBase();
-
-    _RemoveNoStackAurasDueToAura(aura);
-
-    if (aurApp->GetRemoveMode())
-        return;
-
-    // Update target aura state flag
-    if (AuraState aState = GetSpellAuraState(aura->GetSpellProto()))
-        ModifyAuraState(aState, true);
-
-    if (aurApp->GetRemoveMode())
-        return;
-
-    // Sitdown on apply aura req seated
-    if (aura->GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED && !IsSitState())
-        SetStandState(UNIT_STAND_STATE_SIT);
-
-    Unit * caster = aura->GetCaster();
-
-    if (aurApp->GetRemoveMode())
-        return;
-
-    aura->HandleAuraSpecificMods(aurApp, caster, true);
-
-    // apply effects of the aura
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (effMask & 1<<i && (!aurApp->GetRemoveMode()))
-            aurApp->_HandleEffect(i, true);
-    }
-}
-
-// removes aura application from lists and unapplies effects
-void Unit::_UnapplyAura(AuraApplicationMap::iterator &i, AuraRemoveMode removeMode)
-{
-    AuraApplication * aurApp = i->second;
-    ASSERT(aurApp);
-    ASSERT(!aurApp->GetRemoveMode());
-    ASSERT(aurApp->GetTarget() == this);
-    aurApp->SetRemoveMode(removeMode);
-    Aura * aura = aurApp->GetBase();
-    sLog.outDebug("Aura %u now is remove mode %d", aura->GetId(), removeMode);
-
-    // dead loop is killing the server probably
-    ASSERT(m_removedAurasCount < 0xFFFFFFFF);
-
-    ++m_removedAurasCount;
-
-    Unit * caster = aura->GetCaster();
-
-    // Remove all pointers from lists here to prevent possible pointer invalidation on spellcast/auraapply/auraremove
-    m_appliedAuras.erase(i);
-
-    if (aura->GetSpellProto()->AuraInterruptFlags)
-    {
-        m_interruptableAuras.remove(aurApp);
-        UpdateInterruptMask();
-    }
-
-    bool auraStateFound = false;
-    AuraState auraState = GetSpellAuraState(aura->GetSpellProto());
-    if (auraState)
-    {
-        bool canBreak = false;
-        // Get mask of all aurastates from remaining auras
-        for (AuraStateAurasMap::iterator itr = m_auraStateAuras.lower_bound(auraState); itr != m_auraStateAuras.upper_bound(auraState) && !(auraStateFound && canBreak);)
-        {
-            if (itr->second == aurApp)
-            {
-                m_auraStateAuras.erase(itr);
-                itr = m_auraStateAuras.lower_bound(auraState);
-                canBreak = true;
-                continue;
-            }
-            auraStateFound = true;
-            ++itr;
-        }
-    }
-
-    aurApp->_Remove();
-    aura->_UnapplyForTarget(this, caster, aurApp);
-
-    // remove effects of the spell - needs to be done after removing aura from lists
-    for (uint8 itr = 0 ; itr < MAX_SPELL_EFFECTS; ++itr)
-    {
-        if (aurApp->HasEffect(itr))
-            aurApp->_HandleEffect(itr, false);
-    }
-
-    // all effect mustn't be applied
-    ASSERT(!aurApp->GetEffectMask());
-
-    // Remove totem at next update if totem looses its aura
-    if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE && GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem()&& this->ToTotem()->GetSummonerGUID() == aura->GetCasterGUID())
-    {
-        if (this->ToTotem()->GetSpell() == aura->GetId() && this->ToTotem()->GetTotemType() == TOTEM_PASSIVE)
-            this->ToTotem()->setDeathState(JUST_DIED);
-    }
-
-    // Remove aurastates only if were not found
-    if (!auraStateFound)
-        ModifyAuraState(auraState, false);
-
-    aura->HandleAuraSpecificMods(aurApp, caster, false);
-
-    // only way correctly remove all auras from list
-    //if (removedAuras != m_removedAurasCount) new aura may be added
-        i = m_appliedAuras.begin();
-}
-
-void Unit::_UnapplyAura(AuraApplication * aurApp, AuraRemoveMode removeMode)
-{
-    // aura can be removed from unit only if it's applied on it, shouldn't happen
-    ASSERT(aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) == aurApp);
-    uint32 spellId = aurApp->GetBase()->GetId();
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
-    {
-        if (iter->second == aurApp)
-        {
-            _UnapplyAura(iter, removeMode);
-            return;
-        }
-        else
-            ++iter;
-    }
-    ASSERT(false);
-}
-
-void Unit::_RemoveNoStackAuraApplicationsDueToAura(Aura * aura)
-{
-    // dynobj auras can stack infinite number of times
-    if (aura->GetType() == DYNOBJ_AURA_TYPE)
-        return;
-
-    SpellEntry const* spellProto = aura->GetSpellProto();
-
-    uint32 spellId = spellProto->Id;
-
-    // passive spell special case (only non stackable with ranks)
-    if (IsPassiveSpell(spellId) && IsPassiveSpellStackableWithRanks(spellProto))
-        return;
-
-    bool remove = false;
-    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
-    {
-        if (remove)
-        {
-            remove = false;
-            i = m_appliedAuras.begin();
-        }
-
-        if (!_IsNoStackAuraDueToAura(aura, i->second->GetBase()))
-            continue;
-
-        RemoveAura(i, AURA_REMOVE_BY_DEFAULT);
-        if (i == m_appliedAuras.end())
-            break;
-        remove = true;
-    }
-}
-
-void Unit::_RemoveNoStackAurasDueToAura(Aura * aura)
-{
-    SpellEntry const* spellProto = aura->GetSpellProto();
-
-    uint32 spellId = spellProto->Id;
-
-    // passive spell special case (only non stackable with ranks)
-    if (IsPassiveSpell(spellId) && IsPassiveSpellStackableWithRanks(spellProto))
-        return;
-
-    bool remove = false;
-    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end(); ++i)
-    {
-        if (remove)
-        {
-            remove = false;
-            i = m_ownedAuras.begin();
-        }
-
-        if (!_IsNoStackAuraDueToAura(aura, i->second))
-            continue;
-
-        RemoveOwnedAura(i, AURA_REMOVE_BY_DEFAULT);
-        if (i == m_ownedAuras.end())
-            break;
-        remove = true;
-    }
-}
-
-bool Unit::_IsNoStackAuraDueToAura(Aura * appliedAura, Aura * existingAura) const
-{
-    SpellEntry const* spellProto = appliedAura->GetSpellProto();
-    // Do not check already applied aura
-    if (existingAura == appliedAura)
-        return false;
-
-    // Do not check dynobj auras for stacking
-    if (existingAura->GetType() != UNIT_AURA_TYPE)
-        return false;
-
-    SpellEntry const* i_spellProto = existingAura->GetSpellProto();
-    uint32 i_spellId = i_spellProto->Id;
-    bool sameCaster = appliedAura->GetCasterGUID() == existingAura->GetCasterGUID();
-
-    if (IsPassiveSpell(i_spellId))
-    {
-        // passive non-stackable spells not stackable only for same caster
-        if (!sameCaster)
-            return false;
-
-        // passive non-stackable spells not stackable only with another rank of same spell
-        if (!sSpellMgr.IsRankSpellDueToSpell(spellProto, i_spellId))
-            return false;
-    }
-
-    bool is_triggered_by_spell = false;
-    // prevent triggering aura of removing aura that triggered it
-    // prevent triggered aura of removing aura that triggering it (triggered effect early some aura of parent spell
-    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        if (i_spellProto->EffectTriggerSpell[j] == spellProto->Id
-            || spellProto->EffectTriggerSpell[j] == i_spellProto->Id) // I do not know what is this for
-        {
-            is_triggered_by_spell = true;
-            break;
-        }
-    }
-
-    if (is_triggered_by_spell)
-        return false;
-
-    if (sSpellMgr.CanAurasStack(spellProto, i_spellProto, sameCaster))
-        return false;
-    return true;
-}
-
-void Unit::_HandleAuraEffect(AuraEffect * aurEff, bool apply)
-{
-    if (apply)
-        m_modAuras[aurEff->GetAuraType()].push_back(aurEff);
-    else
-        m_modAuras[aurEff->GetAuraType()].remove(aurEff);
-}
-
-// All aura base removes should go threw this function!
-void Unit::RemoveOwnedAura(AuraMap::iterator &i, AuraRemoveMode removeMode)
-{
-    Aura * aura = i->second;
-    ASSERT(!aura->IsRemoved());
-
-    // if unit currently update aura list then make safe update iterator shift to next
-    if (m_auraUpdateIterator == i)
-        ++m_auraUpdateIterator;
-
-    m_ownedAuras.erase(i);
-    m_removedAuras.push_back(aura);
-
-    // Unregister single target aura
-    if (aura->IsSingleTarget())
-        aura->UnregisterSingleTarget();
-
-    aura->_Remove(removeMode);
-
-    i = m_ownedAuras.begin();
-}
-
-void Unit::RemoveOwnedAura(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)
-{
-    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId);)
-        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!caster || itr->second->GetCasterGUID() == caster))
-        {
-            RemoveOwnedAura(itr, removeMode);
-            itr = m_ownedAuras.lower_bound(spellId);
-        }
-        else
-            ++itr;
-}
-
-void Unit::RemoveOwnedAura(Aura * aura, AuraRemoveMode removeMode)
-{
-    if (aura->IsRemoved())
-        return;
-
-    ASSERT(aura->GetOwner() == this);
-
-    uint32 spellId = aura->GetId();
-    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)
-        if (itr->second == aura)
-        {
-            RemoveOwnedAura(itr, removeMode);
-            return;
-        }
-    ASSERT(false);
-}
-
-Aura * Unit::GetOwnedAura(uint32 spellId, uint64 caster, uint8 reqEffMask, Aura * except) const
-{
-    for (AuraMap::const_iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)
-        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!caster || itr->second->GetCasterGUID() == caster) && (!except || except != itr->second))
-            return itr->second;
-    return NULL;
-}
-
-void Unit::RemoveAura(AuraApplicationMap::iterator &i, AuraRemoveMode mode)
-{
-    AuraApplication * aurApp = i->second;
-    // Do not remove aura which is already being removed
-    if (aurApp->GetRemoveMode())
-        return;
-    Aura * aura = aurApp->GetBase();
-    _UnapplyAura(i, mode);
-    // Remove aura - for Area and Target auras
-    if (aura->GetOwner() == this)
-        aura->Remove(mode);
-}
-
-void Unit::RemoveAura(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
-    {
-        Aura const * aura = iter->second->GetBase();
-        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
-            && (!caster || aura->GetCasterGUID() == caster))
-        {
-            RemoveAura(iter, removeMode);
-            return;
-        }
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAura(AuraApplication * aurApp, AuraRemoveMode mode)
-{
-    ASSERT(aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) == aurApp);
-    // no need to remove
-    if (aurApp->GetRemoveMode() || aurApp->GetBase()->IsRemoved())
-        return;
-    uint32 spellId = aurApp->GetBase()->GetId();
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
-    {
-        if (aurApp == iter->second)
-        {
-            RemoveAura(iter, mode);
-            return;
-        }
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAura(Aura * aura, AuraRemoveMode mode)
-{
-    if (aura->IsRemoved())
-        return;
-    if (AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID()))
-        RemoveAura(aurApp, mode);
-    else
-        ASSERT(false);
-}
-
-void Unit::RemoveAurasDueToSpell(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
-    {
-        Aura const * aura = iter->second->GetBase();
-        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
-            && (!caster || aura->GetCasterGUID() == caster))
-        {
-            RemoveAura(iter, removeMode);
-            iter = m_appliedAuras.lower_bound(spellId);
-        }
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAuraFromStack(uint32 spellId, uint64 caster, AuraRemoveMode removeMode)
-{
-    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
-    {
-        Aura const * aura = iter->second;
-        if ((aura->GetType() == UNIT_AURA_TYPE)
-            && (!caster || aura->GetCasterGUID() == caster))
-        {
-            RemoveAuraFromStack(iter, removeMode);
-            return;
-        }
-        else
-            ++iter;
-    }
-}
-
-inline void Unit::RemoveAuraFromStack(AuraMap::iterator &iter, AuraRemoveMode removeMode)
-{
-    if (iter->second->ModStackAmount(-1))
-        RemoveOwnedAura(iter, removeMode);
-}
-
-void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint64 casterGUID, Unit *dispeller)
-{
-    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
-    {
-        Aura * aura = iter->second;
-        if (aura->GetCasterGUID() == casterGUID)
-        {
-            if (aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES)
-                aura->DropCharge();
-            else
-                RemoveAuraFromStack(iter, AURA_REMOVE_BY_ENEMY_SPELL);
-
-            // Unstable Affliction (crash if before removeaura?)
-            if (aura->GetSpellProto()->SpellFamilyName == SPELLFAMILY_WARLOCK && (aura->GetSpellProto()->SpellFamilyFlags[1] & 0x0100))
-            {
-                if (AuraEffect const * aurEff = aura->GetEffect(0))
-                {
-                    int32 damage = aurEff->GetAmount()*9;
-                    // backfire damage and silence
-                    dispeller->CastCustomSpell(dispeller, 31117, &damage, NULL, NULL, true, NULL, NULL, aura->GetCasterGUID());
-                }
-            }
-            // Flame Shock
-            if (aura->GetSpellProto()->SpellFamilyName == SPELLFAMILY_SHAMAN && (aura->GetSpellProto()->SpellFamilyFlags[0] & 0x10000000))
-            {
-                Unit * caster = aura->GetCaster();
-                if (caster)
-                {
-                    uint32 triggeredSpellId = 0;
-                    // Lava Flows
-                    if (AuraEffect const * aurEff = caster->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 3087, 0))
-                    {
-                        switch(aurEff->GetId())
-                        {
-                            case 51482: // Rank 3
-                                triggeredSpellId = 65264;
-                                break;
-                            case 51481: // Rank 2
-                                triggeredSpellId = 65263;
-                                break;
-                            case 51480: // Rank 1
-                                triggeredSpellId = 64694;
-                                break;
-                            default:
-                                sLog.outError("Aura::HandleAuraSpecificMods: Unknown rank of Lava Flows (%d) found", aurEff->GetId());
-                        }
-                    }
-                    if (triggeredSpellId)
-                        caster->CastSpell(caster, triggeredSpellId, true);
-                }
-            }
-            return;
-        }
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit *stealer)
-{
-    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
-    {
-        Aura * aura = iter->second;
-        if (aura->GetCasterGUID() == casterGUID)
-        {
-            int32 damage[MAX_SPELL_EFFECTS];
-            int32 baseDamage[MAX_SPELL_EFFECTS];
-            uint8 effMask = 0;
-            uint8 recalculateMask = 0;
-            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-            {
-                if (aura->GetEffect(i))
-                {
-                    baseDamage[i] = aura->GetEffect(i)->GetBaseAmount();
-                    damage[i] = aura->GetEffect(i)->GetAmount();
-                    effMask |= (1<<i);
-                    if (aura->GetEffect(i)->CanBeRecalculated())
-                        recalculateMask |= (1<<i);
-                }
-                else
-                {
-                    baseDamage[i] = NULL;
-                    damage[i] = NULL;
-                }
-            }
-
-            bool stealCharge = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
-
-            if (stealCharge)
-                aura->DropCharge();
-            else
-                RemoveAuraFromStack(iter, AURA_REMOVE_BY_ENEMY_SPELL);
-
-
-            if (Aura * newAura = stealCharge ? stealer->GetAura(aura->GetId(), aura->GetCasterGUID()) : NULL)
-            {
-                uint8 newCharges = newAura->GetCharges() + 1;
-                uint8 maxCharges = newAura->GetSpellProto()->procCharges;
-                // We must be able to steal as much charges as original caster can have
-                if (Unit * caster = newAura->GetCaster())
-                    if (Player* modOwner = caster->GetSpellModOwner())
-                        modOwner->ApplySpellMod(aura->GetId(), SPELLMOD_CHARGES, maxCharges);
-                newAura->SetCharges(maxCharges < newCharges ? maxCharges : newCharges);
-            }
-            else
-            {
-                int32 dur = (2*MINUTE*IN_MILLISECONDS < aura->GetDuration() || aura->GetDuration() < 0) ? 2*MINUTE*IN_MILLISECONDS : aura->GetDuration();
-
-                newAura = Aura::TryCreate(aura->GetSpellProto(), effMask, stealer, NULL, &baseDamage[0], NULL, aura->GetCasterGUID());
-                if (!newAura)
-                    return;
-                // strange but intended behaviour: Stolen single target auras won't be treated as single targeted
-                if (newAura->IsSingleTarget())
-                    newAura->UnregisterSingleTarget();
-                newAura->SetLoadedState(dur, dur, stealCharge ? 1 : aura->GetCharges(), aura->GetStackAmount(), recalculateMask, &damage[0]);
-                newAura->ApplyForTargets();
-            }
-            return;
-        }
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAurasDueToItemSpell(Item* castItem,uint32 spellId)
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
-    {
-        if (!castItem || iter->second->GetBase()->GetCastItemGUID() == castItem->GetGUID())
-        {
-            RemoveAura(iter);
-            iter = m_appliedAuras.upper_bound(spellId);          // overwrite by more appropriate
-        }
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAurasByType(AuraType auraType, uint64 casterGUID, Aura * except, bool negative, bool positive)
-{
-    for (AuraEffectList::iterator iter = m_modAuras[auraType].begin(); iter != m_modAuras[auraType].end();)
-    {
-        Aura * aura = (*iter)->GetBase();
-        AuraApplication * aurApp = aura ->GetApplicationOfTarget(GetGUID());
-
-        ++iter;
-        if (aura != except && (!casterGUID || aura->GetCasterGUID() == casterGUID)
-            && ((negative && !aurApp->IsPositive()) || (positive && aurApp->IsPositive())))
-        {
-            uint32 removedAuras = m_removedAurasCount;
-            RemoveAura(aurApp);
-            if (m_removedAurasCount > removedAuras + 1)
-                iter = m_modAuras[auraType].begin();
-        }
-    }
-}
-
-void Unit::RemoveAurasWithAttribute(uint32 flags)
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        SpellEntry const *spell = iter->second->GetBase()->GetSpellProto();
-        if (spell->Attributes & flags)
-            RemoveAura(iter);
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveNotOwnSingleTargetAuras(uint32 newPhase)
-{
-    // single target auras from other casters
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        AuraApplication const * aurApp = iter->second;
-        Aura const * aura = aurApp->GetBase();
-
-        if (aura->GetCasterGUID() != GetGUID() && IsSingleTargetSpell(aura->GetSpellProto()))
-        {
-            if (!newPhase)
-                RemoveAura(iter);
-            else
-            {
-                Unit* caster = aura->GetCaster();
-                if (!caster || !caster->InSamePhase(newPhase))
-                    RemoveAura(iter);
-                else
-                    ++iter;
-            }
-        }
-        else
-            ++iter;
-    }
-
-    // single target auras at other targets
-    AuraList& scAuras = GetSingleCastAuras();
-    for (AuraList::iterator iter = scAuras.begin(); iter != scAuras.end();)
-    {
-        Aura * aura = *iter;
-        if (aura->GetUnitOwner() != this && !aura->GetUnitOwner()->InSamePhase(newPhase))
-        {
-            aura->Remove();
-            iter = scAuras.begin();
-        }
-        else
-            ++iter;
-    }
-}
-
-
-void Unit::RemoveAurasWithInterruptFlags(uint32 flag, uint32 except)
-{
-    if (!(m_interruptMask & flag))
-        return;
-
-    // interrupt auras
-    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end();)
-    {
-        Aura * aura = (*iter)->GetBase();
-        ++iter;
-        if ((aura->GetSpellProto()->AuraInterruptFlags & flag) && (!except || aura->GetId() != except))
-        {
-            uint32 removedAuras = m_removedAurasCount;
-            RemoveAura(aura);
-            if (m_removedAurasCount > removedAuras + 1)
-                iter = m_interruptableAuras.begin();
-        }
-    }
-
-    // interrupt channeled spell
-    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
-        if (spell->getState() == SPELL_STATE_CASTING
-            && (spell->m_spellInfo->ChannelInterruptFlags & flag)
-            && spell->m_spellInfo->Id != except)
-            InterruptNonMeleeSpells(false);
-
-    UpdateInterruptMask();
-}
-
-void Unit::RemoveAurasWithFamily(SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        Aura const * aura = iter->second->GetBase();
-        if (!casterGUID || aura->GetCasterGUID() == casterGUID)
-        {
-            SpellEntry const *spell = aura->GetSpellProto();
-            if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
-            {
-                RemoveAura(iter);
-                continue;
-            }
-        }
-        ++iter;
-    }
-}
-
-void Unit::RemoveMovementImpairingAuras()
-{
-    RemoveAurasWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT));
-}
-
-void Unit::RemoveAurasWithMechanic(uint32 mechanic_mask, AuraRemoveMode removemode, uint32 except)
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        Aura const * aura = iter->second->GetBase();
-        if (!except || aura->GetId() != except)
-        {
-            if (GetAllSpellMechanicMask(aura->GetSpellProto()) & mechanic_mask)
-            {
-                RemoveAura(iter, removemode);
-                continue;
-            }
-        }
-        ++iter;
-    }
-}
-
-void Unit::RemoveAreaAurasDueToLeaveWorld()
-{
-    // make sure that all area auras not applied on self are removed - prevent access to deleted pointer later
-    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
-    {
-        Aura * aura = iter->second;
-        ++iter;
-        Aura::ApplicationMap const & appMap = aura->GetApplicationMap();
-        for (Aura::ApplicationMap::const_iterator itr = appMap.begin(); itr!= appMap.end();)
-        {
-            AuraApplication * aurApp = itr->second;
-            ++itr;
-            Unit * target = aurApp->GetTarget();
-            if (target == this)
-                continue;
-            target->RemoveAura(aurApp);
-            // things linked on aura remove may apply new area aura - so start from the beginning
-            iter = m_ownedAuras.begin();
-        }
-    }
-
-    // remove area auras owned by others
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        if (iter->second->GetBase()->GetOwner() != this)
-        {
-            RemoveAura(iter);
-        }
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAllAuras()
-{
-    // this may be a dead loop if some events on aura remove will continiously apply aura on remove
-    // we want to have all auras removed, so use your brain when linking events
-    while (!m_appliedAuras.empty() || !m_ownedAuras.empty())
-    {
-        AuraApplicationMap::iterator aurAppIter;
-        for (aurAppIter = m_appliedAuras.begin(); aurAppIter != m_appliedAuras.end();)
-            _UnapplyAura(aurAppIter, AURA_REMOVE_BY_DEFAULT);
-
-        AuraMap::iterator aurIter;
-        for (aurIter = m_ownedAuras.begin(); aurIter != m_ownedAuras.end();)
-            RemoveOwnedAura(aurIter);
-    }
-}
-
-void Unit::RemoveArenaAuras(bool onleave)
-{
-    // in join, remove positive buffs, on end, remove negative
-    // used to remove positive visible auras in arenas
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        AuraApplication const * aurApp = iter->second;
-        Aura const * aura = aurApp->GetBase();
-        if (!(aura->GetSpellProto()->AttributesEx4 & SPELL_ATTR_EX4_UNK21) // don't remove stances, shadowform, pally/hunter auras
-            && !aura->IsPassive()                               // don't remove passive auras
-            && (!(aura->GetSpellProto()->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY) || !(aura->GetSpellProto()->Attributes & SPELL_ATTR_UNK8))   // not unaffected by invulnerability auras or not having that unknown flag (that seemed the most probable)
-            && (aurApp->IsPositive() ^ onleave))                   // remove positive buffs on enter, negative buffs on leave
-            RemoveAura(iter);
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAllAurasOnDeath()
-{
-    // used just after dieing to remove all visible auras
-    // and disable the mods for the passive ones
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        Aura const * aura = iter->second->GetBase();
-        if (!aura->IsPassive() && !aura->IsDeathPersistent())
-            _UnapplyAura(iter, AURA_REMOVE_BY_DEATH);
-        else
-            ++iter;
-    }
-
-    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
-    {
-        Aura * aura = iter->second;
-        if (!aura->IsPassive() && !aura->IsDeathPersistent())
-            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEATH);
-        else
-            ++iter;
-    }
-}
-
-void Unit::RemoveAllAurasRequiringDeadTarget()
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
-    {
-        Aura const * aura = iter->second->GetBase();
-        if (!aura->IsPassive() && IsRequiringDeadTargetSpell(aura->GetSpellProto()))
-            _UnapplyAura(iter, AURA_REMOVE_BY_DEFAULT);
-        else
-            ++iter;
-    }
-
-    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
-    {
-        Aura * aura = iter->second;
-        if (!aura->IsPassive() && IsRequiringDeadTargetSpell(aura->GetSpellProto()))
-            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEFAULT);
-        else
-            ++iter;
-    }
-}
-
-void Unit::DelayOwnedAuras(uint32 spellId, uint64 caster, int32 delaytime)
-{
-    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);++iter)
-    {
-        Aura * aura = iter->second;
-        if (!caster || aura->GetCasterGUID() == caster)
-        {
-            if (aura->GetDuration() < delaytime)
-                aura->SetDuration(0);
-            else
-                aura->SetDuration(aura->GetDuration() - delaytime);
-
-            // update for out of range group members (on 1 slot use)
-            aura->SetNeedClientUpdateForTargets();
-            sLog.outDebug("Aura %u partially interrupted on unit %u, new duration: %u ms",aura->GetId() , GetGUIDLow(), aura->GetDuration());
-        }
-    }
-}
-
-void Unit::_RemoveAllAuraStatMods()
-{
-    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
-        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, false);
-}
-
-void Unit::_ApplyAllAuraStatMods()
-{
-    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
-        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, true);
-}
-
-AuraEffect * Unit::GetAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
-{
-    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
-        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
-            return itr->second->GetBase()->GetEffect(effIndex);
-    return NULL;
-}
-
-AuraEffect * Unit::GetAuraEffectOfRankedSpell(uint32 spellId, uint8 effIndex, uint64 caster) const
-{
-    uint32 rankSpell = sSpellMgr.GetFirstSpellInChain(spellId);
-    while (true)
-    {
-        if (AuraEffect * aurEff = GetAuraEffect(rankSpell, effIndex, caster))
-            return aurEff;
-        SpellChainNode const * chainNode = sSpellMgr.GetSpellChainNode(rankSpell);
-        if (!chainNode)
-            break;
-        else
-            rankSpell = chainNode->next;
-    }
-    return NULL;
-}
-
-AuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames name, uint32 iconId, uint8 effIndex) const
-{
-    AuraEffectList const& auras = GetAuraEffectsByType(type);
-    for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        if (effIndex != (*itr)->GetEffIndex())
-            continue;
-        SpellEntry const * spell = (*itr)->GetSpellProto();
-        if (spell->SpellIconID == iconId && spell->SpellFamilyName == uint32(name) && !spell->SpellFamilyFlags)
-            return *itr;
-    }
-    return NULL;
-}
-
-AuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
-{
-    AuraEffectList const& auras = GetAuraEffectsByType(type);
-    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
-    {
-        SpellEntry const *spell = (*i)->GetSpellProto();
-        if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
-        {
-            if (casterGUID && (*i)->GetCasterGUID() != casterGUID)
-                continue;
-            return (*i);
-        }
-    }
-    return NULL;
-}
-
-AuraApplication * Unit::GetAuraApplication(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraApplication * except) const
-{
-    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
-    {
-        Aura const * aura = itr->second->GetBase();
-        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || aura->GetCasterGUID() == casterGUID) && (!except || except != itr->second))
-            return itr->second;
-    }
-    return NULL;
-}
-
-Aura * Unit::GetAura(uint32 spellId, uint64 casterGUID, uint8 reqEffMask) const
-{
-    AuraApplication * aurApp = GetAuraApplication(spellId, casterGUID, reqEffMask);
-    return aurApp ? aurApp->GetBase():NULL;
-}
-
-AuraApplication * Unit::GetAuraApplicationOfRankedSpel(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraApplication * except) const
-{
-    uint32 rankSpell = sSpellMgr.GetFirstSpellInChain(spellId);
-    while (true)
-    {
-        if (AuraApplication * aurApp = GetAuraApplication(rankSpell, casterGUID, reqEffMask, except))
-            return aurApp;
-        SpellChainNode const * chainNode = sSpellMgr.GetSpellChainNode(rankSpell);
-        if (!chainNode)
-            break;
-        else
-            rankSpell = chainNode->next;
-    }
-    return NULL;
-}
-
-Aura * Unit::GetAuraOfRankedSpell(uint32 spellId, uint64 casterGUID, uint8 reqEffMask) const
-{
-    AuraApplication * aurApp = GetAuraApplicationOfRankedSpel(spellId, casterGUID, reqEffMask);
-    return aurApp ? aurApp->GetBase() : NULL;
-}
-
-bool Unit::HasAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
-{
-    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
-        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
-            return true;
-    return false;
-}
-
-bool Unit::HasAura(uint32 spellId, uint64 caster, uint8 reqEffMask) const
-{
-    if (GetAuraApplication(spellId, caster, reqEffMask))
-        return true;
-    return false;
-}
-
-bool Unit::HasAuraType(AuraType auraType) const
-{
-    return (!m_modAuras[auraType].empty());
-}
-
-bool Unit::HasAuraTypeWithMiscvalue(AuraType auratype, int32 miscvalue) const
-{
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-        if (miscvalue == (*i)->GetMiscValue())
-            return true;
-    return false;
-}
-
-bool Unit::HasAuraTypeWithAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
-{
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-        if ((*i)->IsAffectedOnSpell(affectedSpell))
-            return true;
-    return false;
-}
-
-bool Unit::HasAuraTypeWithValue(AuraType auratype, int32 value) const
-{
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-        if (value == (*i)->GetAmount())
-            return true;
-    return false;
-}
-
-bool Unit::HasNegativeAuraWithInterruptFlag(uint32 flag, uint64 guid)
-{
-    if (!(m_interruptMask & flag))
-        return false;
-    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end(); ++iter)
-    {
-        if (!(*iter)->IsPositive() && (*iter)->GetBase()->GetSpellProto()->AuraInterruptFlags & flag && (!guid || (*iter)->GetBase()->GetCasterGUID() == guid))
-            return true;
-    }
-    return false;
-}
-
-bool Unit::HasNegativeAuraWithAttribute(uint32 flag, uint64 guid)
-{
-    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
-    {
-        Aura const *aura = iter->second->GetBase();
-        if (!iter->second->IsPositive() && aura->GetSpellProto()->Attributes & flag && (!guid || aura->GetCasterGUID() == guid))
-            return true;
-    }
-    return false;
-}
-
-AuraEffect * Unit::IsScriptOverriden(SpellEntry const * spell, int32 script) const
-{
-    AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
-    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
-    {
-        if ((*i)->GetMiscValue() == script)
-            if ((*i)->IsAffectedOnSpell(spell))
-                return (*i);
-    }
-    return NULL;
-}
-
-uint32 Unit::GetDiseasesByCaster(uint64 casterGUID, bool remove)
-{
-    static const AuraType diseaseAuraTypes[] =
-    {
-        SPELL_AURA_PERIODIC_DAMAGE, // Frost Fever and Blood Plague
-        SPELL_AURA_LINKED,          // Crypt Fever and Ebon Plague
-        SPELL_AURA_NONE
-    };
-
-    uint32 diseases=0;
-    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
-    {
-        for (AuraEffectList::iterator i = m_modAuras[*itr].begin(); i != m_modAuras[*itr].end();)
-        {
-            // Get auras with disease dispel type by caster
-            if ((*i)->GetSpellProto()->Dispel == DISPEL_DISEASE
-                && (*i)->GetCasterGUID() == casterGUID)
-            {
-                ++diseases;
-
-                if (remove)
-                {
-                    RemoveAura((*i)->GetId(), (*i)->GetCasterGUID());
-                    i = m_modAuras[*itr].begin();
-                    continue;
-                }
-            }
-            ++i;
-        }
-    }
-    return diseases;
-}
-
-uint32 Unit::GetDoTsByCaster(uint64 casterGUID) const
-{
-    static const AuraType diseaseAuraTypes[] =
-    {
-        SPELL_AURA_PERIODIC_DAMAGE,
-        SPELL_AURA_PERIODIC_DAMAGE_PERCENT,
-        SPELL_AURA_NONE
-    };
-
-    uint32 dots=0;
-    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
-    {
-        Unit::AuraEffectList const& auras = GetAuraEffectsByType(*itr);
-        for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
-        {
-            // Get auras by caster
-            if ((*i)->GetCasterGUID() == casterGUID)
-                ++dots;
-        }
-    }
-    return dots;
-}
-
-int32 Unit::GetTotalAuraModifier(AuraType auratype) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-        modifier += (*i)->GetAmount();
-
-    return modifier;
-}
-
-float Unit::GetTotalAuraMultiplier(AuraType auratype) const
-{
-    float multiplier = 1.0f;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-        multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
-
-    return multiplier;
-}
-
-int32 Unit::GetMaxPositiveAuraModifier(AuraType auratype)
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetAmount() > modifier)
-            modifier = (*i)->GetAmount();
-    }
-
-    return modifier;
-}
-
-int32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-        if ((*i)->GetAmount() < modifier)
-            modifier = (*i)->GetAmount();
-
-    return modifier;
-}
-
-int32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue()& misc_mask)
-            modifier += (*i)->GetAmount();
-    }
-    return modifier;
-}
-
-float Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask) const
-{
-    float multiplier = 1.0f;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue()& misc_mask)
-            multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
-    }
-    return multiplier;
-}
-
-int32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() > modifier)
-            modifier = (*i)->GetAmount();
-    }
-
-    return modifier;
-}
-
-int32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() < modifier)
-            modifier = (*i)->GetAmount();
-    }
-
-    return modifier;
-}
-
-int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue() == misc_value)
-            modifier += (*i)->GetAmount();
-    }
-    return modifier;
-}
-
-float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const
-{
-    float multiplier = 1.0f;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue() == misc_value)
-            multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
-    }
-    return multiplier;
-}
-
-int32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() > modifier)
-            modifier = (*i)->GetAmount();
-    }
-
-    return modifier;
-}
-
-int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() < modifier)
-            modifier = (*i)->GetAmount();
-    }
-
-    return modifier;
-}
-
-int32 Unit::GetTotalAuraModifierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->IsAffectedOnSpell(affectedSpell))
-            modifier += (*i)->GetAmount();
-    }
-    return modifier;
-}
-
-float Unit::GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
-{
-    float multiplier = 1.0f;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->IsAffectedOnSpell(affectedSpell))
-            multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
-    }
-    return multiplier;
-}
-
-int32 Unit::GetMaxPositiveAuraModifierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->IsAffectedOnSpell(affectedSpell) && (*i)->GetAmount() > modifier)
-            modifier = (*i)->GetAmount();
-    }
-
-    return modifier;
-}
-
-int32 Unit::GetMaxNegativeAuraModifierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
-{
-    int32 modifier = 0;
-
-    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
-    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
-    {
-        if ((*i)->IsAffectedOnSpell(affectedSpell) && (*i)->GetAmount() < modifier)
-            modifier = (*i)->GetAmount();
-    }
-
-    return modifier;
-}
-
-void Unit::AddDynObject(DynamicObject* dynObj)
-{
-    m_dynObjGUIDs.push_back(dynObj->GetGUID());
-}
-
-void Unit::RemoveDynObject(uint32 spellid)
-{
-    if (m_dynObjGUIDs.empty())
-        return;
-    for (DynObjectGUIDs::iterator i = m_dynObjGUIDs.begin(); i != m_dynObjGUIDs.end();)
-    {
-        DynamicObject* dynObj = GetMap()->GetDynamicObject(*i);
-        if (!dynObj) // may happen if a dynobj is removed when grid unload
-            i = m_dynObjGUIDs.erase(i);
-        else if (spellid == 0 || dynObj->GetSpellId() == spellid)
-        {
-            dynObj->Delete();
-            i = m_dynObjGUIDs.erase(i);
-        }
-        else
-            ++i;
-    }
-}
-
-void Unit::RemoveAllDynObjects()
-{
-    while (!m_dynObjGUIDs.empty())
-    {
-        DynamicObject* dynObj = GetMap()->GetDynamicObject(*m_dynObjGUIDs.begin());
-        if (dynObj)
-            dynObj->Delete();
-        m_dynObjGUIDs.erase(m_dynObjGUIDs.begin());
-    }
-}
-
-DynamicObject * Unit::GetDynObject(uint32 spellId)
-{
-    for (DynObjectGUIDs::iterator i = m_dynObjGUIDs.begin(); i != m_dynObjGUIDs.end();)
-    {
-        DynamicObject* dynObj = GetMap()->GetDynamicObject(*i);
-        if (!dynObj)
-        {
-            i = m_dynObjGUIDs.erase(i);
-            continue;
-        }
-
-        if (dynObj->GetSpellId() == spellId)
-            return dynObj;
-        ++i;
-    }
-    return NULL;
-}
-
-GameObject* Unit::GetGameObject(uint32 spellId) const
-{
-    for (GameObjectList::const_iterator i = m_gameObj.begin(); i != m_gameObj.end(); ++i)
-        if ((*i)->GetSpellId() == spellId)
-            return *i;
-
-    return NULL;
-}
-
-void Unit::AddGameObject(GameObject* gameObj)
-{
-    if (!gameObj || !gameObj->GetOwnerGUID() == 0) return;
-    m_gameObj.push_back(gameObj);
-    gameObj->SetOwnerGUID(GetGUID());
-
-    if (GetTypeId() == TYPEID_PLAYER && gameObj->GetSpellId())
-    {
-        SpellEntry const* createBySpell = sSpellStore.LookupEntry(gameObj->GetSpellId());
-        // Need disable spell use for owner
-        if (createBySpell && createBySpell->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
-            // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
-            this->ToPlayer()->AddSpellAndCategoryCooldowns(createBySpell,0,NULL,true);
-    }
-}
-
-void Unit::RemoveGameObject(GameObject* gameObj, bool del)
-{
-    if (!gameObj || !gameObj->GetOwnerGUID() == GetGUID()) return;
-
-    gameObj->SetOwnerGUID(0);
-
-    for (uint32 i = 0; i < 4; ++i)
-    {
-        if (m_ObjectSlot[i] == gameObj->GetGUID())
-        {
-            m_ObjectSlot[i] = 0;
-            break;
-        }
-    }
-
-    // GO created by some spell
-    if (uint32 spellid = gameObj->GetSpellId())
-    {
-        RemoveAurasDueToSpell(spellid);
-
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            SpellEntry const* createBySpell = sSpellStore.LookupEntry(spellid);
-            // Need activate spell use for owner
-            if (createBySpell && createBySpell->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
-                // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
-                this->ToPlayer()->SendCooldownEvent(createBySpell);
-        }
-    }
-
-    m_gameObj.remove(gameObj);
-
-    if (del)
-    {
-        gameObj->SetRespawnTime(0);
-        gameObj->Delete();
-    }
-}
-
-void Unit::RemoveGameObject(uint32 spellid, bool del)
-{
-    if (m_gameObj.empty())
-        return;
-    GameObjectList::iterator i, next;
-    for (i = m_gameObj.begin(); i != m_gameObj.end(); i = next)
-    {
-        next = i;
-        if (spellid == 0 || (*i)->GetSpellId() == spellid)
-        {
-            (*i)->SetOwnerGUID(0);
-            if (del)
-            {
-                (*i)->SetRespawnTime(0);
-                (*i)->Delete();
-            }
-
-            next = m_gameObj.erase(i);
-        }
-        else
-            ++next;
-    }
-}
-
-void Unit::RemoveAllGameObjects()
-{
-    // remove references to unit
-    for (GameObjectList::iterator i = m_gameObj.begin(); i != m_gameObj.end();)
-    {
-        (*i)->SetOwnerGUID(0);
-        (*i)->SetRespawnTime(0);
-        (*i)->Delete();
-        i = m_gameObj.erase(i);
-    }
-}
-
-void Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage *log)
-{
-    WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG, (16+4+4+4+1+4+4+1+1+4+4+1)); // we guess size
-    data.append(log->target->GetPackGUID());
-    data.append(log->attacker->GetPackGUID());
-    data << uint32(log->SpellID);
-    data << uint32(log->damage);                            // damage amount
-    int32 overkill = log->damage - log->target->GetHealth();
-    data << uint32(overkill > 0 ? overkill : 0);            // overkill
-    data << uint8 (log->schoolMask);                        // damage school
-    data << uint32(log->absorb);                            // AbsorbedDamage
-    data << uint32(log->resist);                            // resist
-    data << uint8 (log->physicalLog);                       // if 1, then client show spell name (example: %s's ranged shot hit %s for %u school or %s suffers %u school damage from %s's spell_name
-    data << uint8 (log->unused);                            // unused
-    data << uint32(log->blocked);                           // blocked
-    data << uint32(log->HitInfo);
-    data << uint8 (0);                                      // flag to use extend data
-    SendMessageToSet(&data, true);
-}
-
-void Unit::SendSpellNonMeleeDamageLog(Unit *target, uint32 SpellID, uint32 Damage, SpellSchoolMask damageSchoolMask, uint32 AbsorbedDamage, uint32 Resist, bool PhysicalDamage, uint32 Blocked, bool CriticalHit)
-{
-    SpellNonMeleeDamage log(this, target, SpellID, damageSchoolMask);
-    log.damage = Damage - AbsorbedDamage - Resist - Blocked;
-    log.absorb = AbsorbedDamage;
-    log.resist = Resist;
-    log.physicalLog = PhysicalDamage;
-    log.blocked = Blocked;
-    log.HitInfo = SPELL_HIT_TYPE_UNK1 | SPELL_HIT_TYPE_UNK3 | SPELL_HIT_TYPE_UNK6;
-    if (CriticalHit)
-        log.HitInfo |= SPELL_HIT_TYPE_CRIT;
-    SendSpellNonMeleeDamageLog(&log);
-}
-
-void Unit::ProcDamageAndSpell(Unit *pVictim, uint32 procAttacker, uint32 procVictim, uint32 procExtra, uint32 amount, WeaponAttackType attType, SpellEntry const *procSpell, SpellEntry const * procAura)
-{
-     // Not much to do if no flags are set.
-    if (procAttacker)
-        ProcDamageAndSpellFor(false, pVictim,procAttacker, procExtra,attType, procSpell, amount, procAura);
-    // Now go on with a victim's events'n'auras
-    // Not much to do if no flags are set or there is no victim
-    if (pVictim && pVictim->isAlive() && procVictim)
-        pVictim->ProcDamageAndSpellFor(true, this, procVictim, procExtra, attType, procSpell, amount, procAura);
-}
-
-void Unit::SendPeriodicAuraLog(SpellPeriodicAuraLogInfo *pInfo)
-{
-    AuraEffect const * aura = pInfo->auraEff;
-
-    WorldPacket data(SMSG_PERIODICAURALOG, 30);
-    data.append(GetPackGUID());
-    data.appendPackGUID(aura->GetCasterGUID());
-    data << uint32(aura->GetId());                          // spellId
-    data << uint32(1);                                      // count
-    data << uint32(aura->GetAuraType());                    // auraId
-    switch(aura->GetAuraType())
-    {
-        case SPELL_AURA_PERIODIC_DAMAGE:
-        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
-            data << uint32(pInfo->damage);                  // damage
-            data << uint32(pInfo->overDamage);              // overkill?
-            data << uint32(GetSpellSchoolMask(aura->GetSpellProto()));
-            data << uint32(pInfo->absorb);                  // absorb
-            data << uint32(pInfo->resist);                  // resist
-            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick
-            break;
-        case SPELL_AURA_PERIODIC_HEAL:
-        case SPELL_AURA_OBS_MOD_HEALTH:
-            data << uint32(pInfo->damage);                  // damage
-            data << uint32(pInfo->overDamage);              // overheal
-            data << uint32(pInfo->absorb);                  // absorb
-            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick
-            break;
-        case SPELL_AURA_OBS_MOD_POWER:
-        case SPELL_AURA_PERIODIC_ENERGIZE:
-            data << uint32(aura->GetMiscValue());           // power type
-            data << uint32(pInfo->damage);                  // damage
-            break;
-        case SPELL_AURA_PERIODIC_MANA_LEECH:
-            data << uint32(aura->GetMiscValue());           // power type
-            data << uint32(pInfo->damage);                  // amount
-            data << float(pInfo->multiplier);               // gain multiplier
-            break;
-        default:
-            sLog.outError("Unit::SendPeriodicAuraLog: unknown aura %u", uint32(aura->GetAuraType()));
-            return;
-    }
-
-    SendMessageToSet(&data, true);
-}
-
-void Unit::SendSpellMiss(Unit *target, uint32 spellID, SpellMissInfo missInfo)
-{
-    WorldPacket data(SMSG_SPELLLOGMISS, (4+8+1+4+8+1));
-    data << uint32(spellID);
-    data << uint64(GetGUID());
-    data << uint8(0);                                       // can be 0 or 1
-    data << uint32(1);                                      // target count
-    // for (i = 0; i < target count; ++i)
-    data << uint64(target->GetGUID());                      // target GUID
-    data << uint8(missInfo);
-    // end loop
-    SendMessageToSet(&data, true);
-}
-
-void Unit::SendSpellDamageImmune(Unit * target, uint32 spellId)
-{
-    WorldPacket data(SMSG_SPELLORDAMAGE_IMMUNE, 8+8+4+1);
-    data << uint64(GetGUID());
-    data << uint64(target->GetGUID());
-    data << uint32(spellId);
-    data << uint8(0); // bool - log format: 0-default, 1-debug
-    SendMessageToSet(&data,true);
-}
-
-void Unit::SendAttackStateUpdate(CalcDamageInfo *damageInfo)
-{
-    sLog.outDebug("WORLD: Sending SMSG_ATTACKERSTATEUPDATE");
-
-    uint32 count = 1;
-    size_t maxsize = 4+5+5+4+4+1+4+4+4+4+4+1+4+4+4+4+4*12;
-    WorldPacket data(SMSG_ATTACKERSTATEUPDATE, maxsize);    // we guess size
-    data << uint32(damageInfo->HitInfo);
-    data.append(damageInfo->attacker->GetPackGUID());
-    data.append(damageInfo->target->GetPackGUID());
-    data << uint32(damageInfo->damage);                     // Full damage
-    int32 overkill = damageInfo->damage - damageInfo->target->GetHealth();
-    data << uint32(overkill < 0 ? 0 : overkill);            // Overkill
-    data << uint8(count);                                   // Sub damage count
-
-    for (uint32 i = 0; i < count; ++i)
-    {
-        data << uint32(damageInfo->damageSchoolMask);       // School of sub damage
-        data << float(damageInfo->damage);                  // sub damage
-        data << uint32(damageInfo->damage);                 // Sub Damage
-    }
-
-    if (damageInfo->HitInfo & (HITINFO_ABSORB | HITINFO_ABSORB2))
-    {
-        for (uint32 i = 0; i < count; ++i)
-            data << uint32(damageInfo->absorb);             // Absorb
-    }
-
-    if (damageInfo->HitInfo & (HITINFO_RESIST | HITINFO_RESIST2))
-    {
-        for (uint32 i = 0; i < count; ++i)
-            data << uint32(damageInfo->resist);             // Resist
-    }
-
-    data << uint8(damageInfo->TargetState);
-    data << uint32(0);
-    data << uint32(0);
-
-    if (damageInfo->HitInfo & HITINFO_BLOCK)
-        data << uint32(damageInfo->blocked_amount);
-
-    if (damageInfo->HitInfo & HITINFO_UNK3)
-        data << uint32(0);
-
-    if (damageInfo->HitInfo & HITINFO_UNK1)
-    {
-        data << uint32(0);
-        data << float(0);
-        data << float(0);
-        data << float(0);
-        data << float(0);
-        data << float(0);
-        data << float(0);
-        data << float(0);
-        data << float(0);
-        data << float(0);       // Found in a loop with 1 iteration
-        data << float(0);       // ditto ^
-        data << uint32(0);
-    }
-
-    SendMessageToSet(&data, true);
-}
-
-void Unit::SendAttackStateUpdate(uint32 HitInfo, Unit *target, uint8 /*SwingType*/, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount)
-{
-    CalcDamageInfo dmgInfo;
-    dmgInfo.HitInfo = HitInfo;
-    dmgInfo.attacker = this;
-    dmgInfo.target = target;
-    dmgInfo.damage = Damage - AbsorbDamage - Resist - BlockedAmount;
-    dmgInfo.damageSchoolMask = damageSchoolMask;
-    dmgInfo.absorb = AbsorbDamage;
-    dmgInfo.resist = Resist;
-    dmgInfo.TargetState = TargetState;
-    dmgInfo.blocked_amount = BlockedAmount;
-    SendAttackStateUpdate(&dmgInfo);
-}
-
-bool Unit::HandleHasteAuraProc(Unit *pVictim, uint32 damage, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
-{
-    SpellEntry const *hasteSpell = triggeredByAura->GetSpellProto();
-
-    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
-        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
-
-    uint32 triggered_spell_id = 0;
-    Unit* target = pVictim;
-    int32 basepoints0 = 0;
-
-    switch(hasteSpell->SpellFamilyName)
-    {
-        case SPELLFAMILY_ROGUE:
-        {
-            switch(hasteSpell->Id)
-            {
-                // Blade Flurry
-                case 13877:
-                case 33735:
-                {
-                    target = SelectNearbyTarget();
-                    if (!target || target == pVictim)
-                        return false;
-                    basepoints0 = damage;
-                    triggered_spell_id = 22482;
-                    break;
-                }
-            }
-            break;
-        }
-    }
-
-    // processed charge only counting case
-    if (!triggered_spell_id)
-        return true;
-
-    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!triggerEntry)
-    {
-        sLog.outError("Unit::HandleHasteAuraProc: Spell %u have not existed triggered spell %u",hasteSpell->Id,triggered_spell_id);
-        return false;
-    }
-
-    // default case
-    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
-        return false;
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
-        return false;
-
-    if (basepoints0)
-        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-    else
-        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
-
-    return true;
-}
-
-bool Unit::HandleSpellCritChanceAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
-{
-    SpellEntry const *triggeredByAuraSpell = triggeredByAura->GetSpellProto();
-
-    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
-        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
-
-    uint32 triggered_spell_id = 0;
-    Unit* target = pVictim;
-    int32 basepoints0 = 0;
-
-    switch(triggeredByAuraSpell->SpellFamilyName)
-    {
-        case SPELLFAMILY_MAGE:
-        {
-            switch(triggeredByAuraSpell->Id)
-            {
-                // Focus Magic
-                case 54646:
-                {
-                    Unit* caster = triggeredByAura->GetCaster();
-                    if (!caster)
-                        return false;
-
-                    triggered_spell_id = 54648;
-                    target = caster;
-                    break;
-                }
-            }
-        }
-    }
-
-    // processed charge only counting case
-    if (!triggered_spell_id)
-        return true;
-
-    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!triggerEntry)
-    {
-        sLog.outError("Unit::HandleHasteAuraProc: Spell %u have not existed triggered spell %u",triggeredByAuraSpell->Id,triggered_spell_id);
-        return false;
-    }
-
-    // default case
-    if (!target || (target != this && !target->isAlive()))
-        return false;
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
-        return false;
-
-    if (basepoints0)
-        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-    else
-        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
-
-    return true;
-}
-
-bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, AuraEffect* triggeredByAura, SpellEntry const * procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown)
-{
-    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto();
-    uint32 effIndex = triggeredByAura->GetEffIndex();
-    int32  triggerAmount = triggeredByAura->GetAmount();
-
-    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
-        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
-
-    uint32 triggered_spell_id = 0;
-    uint32 cooldown_spell_id = 0; // for random trigger, will be one of the triggered spell to avoid repeatable triggers
-                                  // otherwise, it's the triggered_spell_id by default
-    Unit* target = pVictim;
-    int32 basepoints0 = 0;
-    uint64 originalCaster = 0;
-
-    switch(dummySpell->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            switch (dummySpell->Id)
-            {
-                // Bloodworms Health Leech
-                case 50453:
-                {
-                    if (Unit *owner = this->GetOwner())
-                    {
-                        basepoints0 = int32(damage*1.50);
-                        target = owner;
-                        triggered_spell_id = 50454;
-                        break;
-                    }
-                    return false;
-                }
-                // Eye for an Eye
-                case 9799:
-                case 25988:
-                {
-                    // return damage % to attacker but < 50% own total health
-                    basepoints0 = int32((triggerAmount * damage) /100);
-
-                    int32 halfMaxHealth = int32(CountPctFromMaxHealth(50));
-                    if (basepoints0 > halfMaxHealth)
-                        basepoints0 = halfMaxHealth;
-
-                    sLog.outDebug("DEBUG LINE: Data about Eye for an Eye ID %u, damage taken %u, unit max health %u, damage done %u", dummySpell->Id, damage, GetMaxHealth(), basepoints0);
-
-                    triggered_spell_id = 25997;
-
-                    break;
-                }
-                // Sweeping Strikes
-                case 18765:
-                case 35429:
-                {
-                    target = SelectNearbyTarget();
-                    if (!target)
-                        return false;
-
-                    triggered_spell_id = 26654;
-                    break;
-                }
-                // Unstable Power
-                case 24658:
-                {
-                    if (!procSpell || procSpell->Id == 24659)
-                        return false;
-                    // Need remove one 24659 aura
-                    RemoveAuraFromStack(24659);
-                    return true;
-                }
-                // Restless Strength
-                case 24661:
-                {
-                    // Need remove one 24662 aura
-                    RemoveAuraFromStack(24662);
-                    return true;
-                }
-                // Adaptive Warding (Frostfire Regalia set)
-                case 28764:
-                {
-                    if (!procSpell)
-                        return false;
-
-                    // find Mage Armor
-                    if (!GetAuraEffect(SPELL_AURA_MOD_MANA_REGEN_INTERRUPT, SPELLFAMILY_MAGE, 0x10000000, 0, 0))
-                        return false;
-
-                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
-                    {
-                        case SPELL_SCHOOL_NORMAL:
-                        case SPELL_SCHOOL_HOLY:
-                            return false;                   // ignored
-                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 28765; break;
-                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 28768; break;
-                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 28766; break;
-                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 28769; break;
-                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 28770; break;
-                        default:
-                            return false;
-                    }
-
-                    target = this;
-                    break;
-                }
-                // Obsidian Armor (Justice Bearer`s Pauldrons shoulder)
-                case 27539:
-                {
-                    if (!procSpell)
-                        return false;
-
-                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
-                    {
-                        case SPELL_SCHOOL_NORMAL:
-                            return false;                   // ignore
-                        case SPELL_SCHOOL_HOLY:   triggered_spell_id = 27536; break;
-                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 27533; break;
-                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 27538; break;
-                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 27534; break;
-                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 27535; break;
-                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 27540; break;
-                        default:
-                            return false;
-                    }
-
-                    target = this;
-                    break;
-                }
-                // Mana Leech (Passive) (Priest Pet Aura)
-                case 28305:
-                {
-                    // Cast on owner
-                    target = GetOwner();
-                    if (!target)
-                        return false;
-
-                    triggered_spell_id = 34650;
-                    break;
-                }
-                // Spirit Walk
-                case 58875:
-                {
-                    // Cast on owner
-                    target = GetOwner();
-                    if (!target)
-                        return false;
-
-                    triggered_spell_id = 58876;
-                    break;
-                }
-                // Mark of Malice
-                case 33493:
-                {
-                    // Cast finish spell at last charge
-                    if (triggeredByAura->GetBase()->GetCharges() > 1)
-                        return false;
-
-                    target = this;
-                    triggered_spell_id = 33494;
-                    break;
-                }
-                // Twisted Reflection (boss spell)
-                case 21063:
-                    triggered_spell_id = 21064;
-                    break;
-                // Vampiric Aura (boss spell)
-                case 38196:
-                {
-                    basepoints0 = 3 * damage;               // 300%
-                    if (basepoints0 < 0)
-                        return false;
-
-                    triggered_spell_id = 31285;
-                    target = this;
-                    break;
-                }
-                // Aura of Madness (Darkmoon Card: Madness trinket)
-                //=====================================================
-                // 39511 Sociopath: +35 strength (Paladin, Rogue, Druid, Warrior)
-                // 40997 Delusional: +70 attack power (Rogue, Hunter, Paladin, Warrior, Druid)
-                // 40998 Kleptomania: +35 agility (Warrior, Rogue, Paladin, Hunter, Druid)
-                // 40999 Megalomania: +41 damage/healing (Druid, Shaman, Priest, Warlock, Mage, Paladin)
-                // 41002 Paranoia: +35 spell/melee/ranged crit strike rating (All classes)
-                // 41005 Manic: +35 haste (spell, melee and ranged) (All classes)
-                // 41009 Narcissism: +35 intellect (Druid, Shaman, Priest, Warlock, Mage, Paladin, Hunter)
-                // 41011 Martyr Complex: +35 stamina (All classes)
-                // 41406 Dementia: Every 5 seconds either gives you +5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
-                // 41409 Dementia: Every 5 seconds either gives you -5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
-                case 39446:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER || !this->isAlive())
-                        return false;
-
-                    // Select class defined buff
-                    switch (getClass())
-                    {
-                        case CLASS_PALADIN:                 // 39511,40997,40998,40999,41002,41005,41009,41011,41409
-                        case CLASS_DRUID:                   // 39511,40997,40998,40999,41002,41005,41009,41011,41409
-                            triggered_spell_id = RAND(39511,40997,40998,40999,41002,41005,41009,41011,41409);
-                            cooldown_spell_id = 39511;
-                            break;
-                        case CLASS_ROGUE:                   // 39511,40997,40998,41002,41005,41011
-                        case CLASS_WARRIOR:                 // 39511,40997,40998,41002,41005,41011
-                            triggered_spell_id = RAND(39511,40997,40998,41002,41005,41011);
-                            cooldown_spell_id = 39511;
-                            break;
-                        case CLASS_PRIEST:                  // 40999,41002,41005,41009,41011,41406,41409
-                        case CLASS_SHAMAN:                  // 40999,41002,41005,41009,41011,41406,41409
-                        case CLASS_MAGE:                    // 40999,41002,41005,41009,41011,41406,41409
-                        case CLASS_WARLOCK:                 // 40999,41002,41005,41009,41011,41406,41409
-                            triggered_spell_id = RAND(40999,41002,41005,41009,41011,41406,41409);
-                            cooldown_spell_id = 40999;
-                            break;
-                        case CLASS_HUNTER:                  // 40997,40999,41002,41005,41009,41011,41406,41409
-                            triggered_spell_id = RAND(40997,40999,41002,41005,41009,41011,41406,41409);
-                            cooldown_spell_id = 40997;
-                            break;
-                        default:
-                            return false;
-                    }
-
-                    target = this;
-                    if (roll_chance_i(10))
-                        this->ToPlayer()->Say("This is Madness!", LANG_UNIVERSAL);
-                    break;
-                }
-                // Sunwell Exalted Caster Neck (??? neck)
-                // cast ??? Light's Wrath if Exalted by Aldor
-                // cast ??? Arcane Bolt if Exalted by Scryers
-                case 46569:
-                    return false;                           // old unused version
-                // Sunwell Exalted Caster Neck (Shattered Sun Pendant of Acumen neck)
-                // cast 45479 Light's Wrath if Exalted by Aldor
-                // cast 45429 Arcane Bolt if Exalted by Scryers
-                case 45481:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    // Get Aldor reputation rank
-                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
-                    {
-                        target = this;
-                        triggered_spell_id = 45479;
-                        break;
-                    }
-                    // Get Scryers reputation rank
-                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
-                    {
-                        // triggered at positive/self casts also, current attack target used then
-                        if (IsFriendlyTo(target))
-                        {
-                            target = getVictim();
-                            if (!target)
-                            {
-                                uint64 selected_guid = ToPlayer()->GetSelection();
-                                target = ObjectAccessor::GetUnit(*this,selected_guid);
-                                if (!target)
-                                    return false;
-                            }
-                            if (IsFriendlyTo(target))
-                                return false;
-                        }
-
-                        triggered_spell_id = 45429;
-                        break;
-                    }
-                    return false;
-                }
-                // Sunwell Exalted Melee Neck (Shattered Sun Pendant of Might neck)
-                // cast 45480 Light's Strength if Exalted by Aldor
-                // cast 45428 Arcane Strike if Exalted by Scryers
-                case 45482:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    // Get Aldor reputation rank
-                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
-                    {
-                        target = this;
-                        triggered_spell_id = 45480;
-                        break;
-                    }
-                    // Get Scryers reputation rank
-                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
-                    {
-                        triggered_spell_id = 45428;
-                        break;
-                    }
-                    return false;
-                }
-                // Sunwell Exalted Tank Neck (Shattered Sun Pendant of Resolve neck)
-                // cast 45431 Arcane Insight if Exalted by Aldor
-                // cast 45432 Light's Ward if Exalted by Scryers
-                case 45483:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    // Get Aldor reputation rank
-                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
-                    {
-                        target = this;
-                        triggered_spell_id = 45432;
-                        break;
-                    }
-                    // Get Scryers reputation rank
-                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
-                    {
-                        target = this;
-                        triggered_spell_id = 45431;
-                        break;
-                    }
-                    return false;
-                }
-                // Sunwell Exalted Healer Neck (Shattered Sun Pendant of Restoration neck)
-                // cast 45478 Light's Salvation if Exalted by Aldor
-                // cast 45430 Arcane Surge if Exalted by Scryers
-                case 45484:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    // Get Aldor reputation rank
-                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
-                    {
-                        target = this;
-                        triggered_spell_id = 45478;
-                        break;
-                    }
-                    // Get Scryers reputation rank
-                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
-                    {
-                        triggered_spell_id = 45430;
-                        break;
-                    }
-                    return false;
-                }
-                // Living Seed
-                case 48504:
-                {
-                    triggered_spell_id = 48503;
-                    basepoints0 = triggerAmount;
-                    target = this;
-                    break;
-                }
-                // Kill command
-                case 58914:
-                {
-                    // Remove aura stack from pet
-                    RemoveAuraFromStack(58914);
-                    Unit* owner = GetOwner();
-                    if (!owner)
-                        return true;
-                    // reduce the owner's aura stack
-                    owner->RemoveAuraFromStack(34027);
-                    return true;
-                }
-                // Vampiric Touch (generic, used by some boss)
-                case 52723:
-                case 60501:
-                {
-                    triggered_spell_id = 52724;
-                    basepoints0 = damage / 2;
-                    target = this;
-                    break;
-                }
-                // Shadowfiend Death (Gain mana if pet dies with Glyph of Shadowfiend)
-                case 57989:
-                {
-                    Unit *owner = GetOwner();
-                    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
-                        return false;
-                    // Glyph of Shadowfiend (need cast as self cast for owner, no hidden cooldown)
-                    owner->CastSpell(owner,58227,true,castItem,triggeredByAura);
-                    return true;
-                }
-                // Divine purpose
-                case 31871:
-                case 31872:
-                {
-                    // Roll chane
-                    if (!pVictim || !pVictim->isAlive() || !roll_chance_i(triggerAmount))
-                        return false;
-
-                    // Remove any stun effect on target
-                    pVictim->RemoveAurasWithMechanic(1<<MECHANIC_STUN, AURA_REMOVE_BY_ENEMY_SPELL);
-                    return true;
-                }
-                // Glyph of Life Tap
-                case 63320:
-                {
-                    triggered_spell_id = 63321; // Life Tap
-                    break;
-                }
-                case 71519: // Deathbringer's Will Normal
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    std::vector<uint32> RandomSpells;
-                    switch (getClass())
-                    {
-                        case CLASS_WARRIOR:
-                        case CLASS_PALADIN:
-                        case CLASS_DEATH_KNIGHT:
-                            RandomSpells.push_back(71484);
-                            RandomSpells.push_back(71491);
-                            RandomSpells.push_back(71492);
-                            break;
-                        case CLASS_SHAMAN:
-                        case CLASS_ROGUE:
-                            RandomSpells.push_back(71486);
-                            RandomSpells.push_back(71485);
-                            RandomSpells.push_back(71492);
-                            break;
-                        case CLASS_DRUID:
-                            RandomSpells.push_back(71484);
-                            RandomSpells.push_back(71485);
-                            RandomSpells.push_back(71486);
-                            break;
-                        case CLASS_HUNTER:
-                            RandomSpells.push_back(71486);
-                            RandomSpells.push_back(71491);
-                            RandomSpells.push_back(71485);
-                            break;
-                        default:
-                            return false;
-                    }
-                    if (RandomSpells.empty()) //shouldn't happen
-                        return false;
-
-                    uint8 rand_spell = irand(0,(RandomSpells.size() - 1));
-                    CastSpell(target,RandomSpells[rand_spell],true,castItem,triggeredByAura, originalCaster);
-                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)
-                    {
-                        if (!ToPlayer()->HasSpellCooldown(*itr))
-                            ToPlayer()->AddSpellCooldown(*itr,0,time(NULL) + cooldown);
-                    }
-                    break;
-                }
-                case 71562: // Deathbringer's Will Heroic
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    std::vector<uint32> RandomSpells;
-                    switch (getClass())
-                    {
-                        case CLASS_WARRIOR:
-                        case CLASS_PALADIN:
-                        case CLASS_DEATH_KNIGHT:
-                            RandomSpells.push_back(71561);
-                            RandomSpells.push_back(71559);
-                            RandomSpells.push_back(71560);
-                            break;
-                        case CLASS_SHAMAN:
-                        case CLASS_ROGUE:
-                            RandomSpells.push_back(71558);
-                            RandomSpells.push_back(71556);
-                            RandomSpells.push_back(71560);
-                            break;
-                        case CLASS_DRUID:
-                            RandomSpells.push_back(71561);
-                            RandomSpells.push_back(71556);
-                            RandomSpells.push_back(71558);
-                            break;
-                        case CLASS_HUNTER:
-                            RandomSpells.push_back(71558);
-                            RandomSpells.push_back(71559);
-                            RandomSpells.push_back(71556);
-                            break;
-                        default:
-                            return false;
-                    }
-                    if (RandomSpells.empty()) //shouldn't happen
-                        return false;
-
-                    uint8 rand_spell = irand(0,(RandomSpells.size() - 1));
-                    CastSpell(target,RandomSpells[rand_spell],true,castItem,triggeredByAura, originalCaster);
-                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)
-                    {
-                        if (!ToPlayer()->HasSpellCooldown(*itr))
-                            ToPlayer()->AddSpellCooldown(*itr,0,time(NULL) + cooldown);
-                    }
-                    break;
-                }
-                // Item - Shadowmourne Legendary
-                case 71903:
-                {
-                    if (!pVictim || !pVictim->isAlive() || HasAura(73422))  // cant collect shards while under effect of Chaos Bane buff
-                        return false;
-
-                    CastSpell(this, 71905, true, NULL, triggeredByAura);
-
-                    // this can't be handled in AuraScript because we need to know pVictim
-                    Aura const* dummy = GetAura(71905);
-                    if (!dummy || dummy->GetStackAmount() < 10)
-                        return false;
-
-                    RemoveAurasDueToSpell(71905);
-                    triggered_spell_id = 71904;
-                    target = pVictim;
-                    break;
-                }
-                // Shadow's Fate (Shadowmourne questline)
-                case 71169:
-                {
-                    triggered_spell_id = 71203;
-                    target = triggeredByAura->GetCaster();
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_MAGE:
-        {
-            // Magic Absorption
-            if (dummySpell->SpellIconID == 459)             // only this spell have SpellIconID == 459 and dummy aura
-            {
-                if (getPowerType() != POWER_MANA)
-                    return false;
-
-                // mana reward
-                basepoints0 = (triggerAmount * GetMaxPower(POWER_MANA) / 100);
-                target = this;
-                triggered_spell_id = 29442;
-                break;
-            }
-            // Master of Elements
-            if (dummySpell->SpellIconID == 1920)
-            {
-                if (!procSpell)
-                    return false;
-
-                // mana cost save
-                int32 cost = procSpell->manaCost + procSpell->ManaCostPercentage * GetCreateMana() / 100;
-                basepoints0 = cost * triggerAmount/100;
-                if (basepoints0 <= 0)
-                    return false;
-
-                target = this;
-                triggered_spell_id = 29077;
-                break;
-            }
-            // Arcane Potency
-            if (dummySpell->SpellIconID == 2120)
-            {
-                if (!procSpell)
-                    return false;
-
-                target = this;
-                switch (dummySpell->Id)
-                {
-                    case 31571: triggered_spell_id = 57529; break;
-                    case 31572: triggered_spell_id = 57531; break;
-                    default:
-                        sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u",dummySpell->Id);
-                        return false;
-                }
-                break;
-            }
-
-            // Hot Streak
-            if (dummySpell->SpellIconID == 2999)
-            {
-                if (effIndex != 0)
-                    return false;
-                AuraEffect *counter = triggeredByAura->GetBase()->GetEffect(1);
-                if (!counter)
-                    return true;
-
-                // Count spell criticals in a row in second aura
-                if (procEx & PROC_EX_CRITICAL_HIT)
-                {
-                    counter->SetAmount(counter->GetAmount()*2);
-                    if (counter->GetAmount() < 100) // not enough
-                        return true;
-                    // Crititcal counted -> roll chance
-                    if (roll_chance_i(triggerAmount))
-                       CastSpell(this, 48108, true, castItem, triggeredByAura);
-                }
-                counter->SetAmount(25);
-                return true;
-            }
-            // Burnout
-            if (dummySpell->SpellIconID == 2998)
-            {
-                if (!procSpell)
-                    return false;
-
-                int32 cost = procSpell->manaCost + procSpell->ManaCostPercentage * GetCreateMana() / 100;
-                basepoints0 = cost * triggerAmount/100;
-                if (basepoints0 <= 0)
-                    return false;
-                triggered_spell_id = 44450;
-                target = this;
-                break;
-            }
-            // Incanter's Regalia set (add trigger chance to Mana Shield)
-            if (dummySpell->SpellFamilyFlags[0] & 0x8000)
-            {
-                if (GetTypeId() != TYPEID_PLAYER)
-                    return false;
-
-                target = this;
-                triggered_spell_id = 37436;
-                break;
-            }
-            switch(dummySpell->Id)
-            {
-                // Glyph of Polymorph
-                case 56375:
-                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE, 0, target->GetAura(32409)); // SW:D shall not be removed.
-                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE_PERCENT);
-                    return true;
-                // Glyph of Icy Veins
-                case 56374:
-                {
-                    RemoveAurasByType(SPELL_AURA_MOD_HASTE, 0, 0, true, false);
-                    RemoveAurasByType(SPELL_AURA_MOD_DECREASE_SPEED);
-                    return true;
-                }
-                // Ignite
-                case 11119:
-                case 11120:
-                case 12846:
-                case 12847:
-                case 12848:
-                {
-                    switch (dummySpell->Id)
-                    {
-                        case 11119: basepoints0 = int32(0.04f*damage); break;
-                        case 11120: basepoints0 = int32(0.08f*damage); break;
-                        case 12846: basepoints0 = int32(0.12f*damage); break;
-                        case 12847: basepoints0 = int32(0.16f*damage); break;
-                        case 12848: basepoints0 = int32(0.20f*damage); break;
-                        default:
-                            sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u (IG)",dummySpell->Id);
-                            return false;
-                    }
-
-                    triggered_spell_id = 12654;
-                    basepoints0 += pVictim->GetRemainingDotDamage(GetGUID(), triggered_spell_id);
-                    break;
-                }
-                // Glyph of Ice Block
-                case 56372:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    SpellCooldowns const SpellCDs = this->ToPlayer()->GetSpellCooldowns();
-                    // remove cooldowns on all ranks of Frost Nova
-                    for (SpellCooldowns::const_iterator itr = SpellCDs.begin(); itr != SpellCDs.end(); itr++)
-                    {
-                        SpellEntry const* SpellCDs_entry = sSpellStore.LookupEntry(itr->first);
-                        // Frost Nova
-                        if (SpellCDs_entry && SpellCDs_entry->SpellFamilyName == SPELLFAMILY_MAGE
-                           && SpellCDs_entry->SpellFamilyFlags[0] & 0x00000040)
-                            this->ToPlayer()->RemoveSpellCooldown(SpellCDs_entry->Id, true);
-                    }
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            switch(dummySpell->Id)
-            {
-                // Sweeping Strikes
-                case 12328:
-                {
-                    target = SelectNearbyTarget();
-                    if (!target)
-                        return false;
-
-                    triggered_spell_id = 26654;
-                    break;
-                }
-                // Improved Spell Reflection
-                case 59088:
-                case 59089:
-                {
-                    triggered_spell_id = 59725;
-                    target = this;
-                    break;
-                }
-            }
-
-            // Retaliation
-            if (dummySpell->SpellFamilyFlags[1] & 0x8)
-            {
-                // check attack comes not from behind
-                if (!HasInArc(M_PI, pVictim))
-                    return false;
-
-                triggered_spell_id = 22858;
-                break;
-            }
-            // Second Wind
-            if (dummySpell->SpellIconID == 1697)
-            {
-                // only for spells and hit/crit (trigger start always) and not start from self casted spells (5530 Mace Stun Effect for example)
-                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == pVictim)
-                    return false;
-                // Need stun or root mechanic
-                if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_STUN))))
-                    return false;
-
-                switch (dummySpell->Id)
-                {
-                    case 29838: triggered_spell_id=29842; break;
-                    case 29834: triggered_spell_id=29841; break;
-                    case 42770: triggered_spell_id=42771; break;
-                    default:
-                        sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u (SW)",dummySpell->Id);
-                    return false;
-                }
-
-                target = this;
-                break;
-            }
-            // Damage Shield
-            if (dummySpell->SpellIconID == 3214)
-            {
-                triggered_spell_id = 59653;
-                // % of amount blocked
-                basepoints0 = GetShieldBlockValue() * triggerAmount / 100;
-                break;
-            }
-            // Glyph of Blocking
-            if (dummySpell->Id == 58375)
-            {
-                triggered_spell_id = 58374;
-                break;
-            }
-            // Glyph of Sunder Armor
-            if (dummySpell->Id == 58387)
-            {
-                if (!pVictim || !pVictim->isAlive() || !procSpell)
-                    return false;
-
-                target = SelectNearbyTarget();
-                if (!target || target == pVictim)
-                    return false;
-
-                CastSpell(target, 58567, true);
-                return true;
-            }
-            break;
-        }
-        case SPELLFAMILY_WARLOCK:
-        {
-            // Seed of Corruption
-            if (dummySpell->SpellFamilyFlags[1] & 0x00000010)
-            {
-                if (procSpell && procSpell->Id == 27285)
-                    return false;
-                // if damage is more than need or target die from damage deal finish spell
-                if (triggeredByAura->GetAmount() <= int32(damage) || GetHealth() <= damage)
-                {
-                    // remember guid before aura delete
-                    uint64 casterGuid = triggeredByAura->GetCasterGUID();
-
-                    // Remove aura (before cast for prevent infinite loop handlers)
-                    RemoveAurasDueToSpell(triggeredByAura->GetId());
-
-                    // Cast finish spell (triggeredByAura already not exist!)
-                    if (Unit* caster = GetUnit(*this, casterGuid))
-                        caster->CastSpell(this, 27285, true, castItem);
-                    return true;                            // no hidden cooldown
-                }
-
-                // Damage counting
-                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);
-                return true;
-            }
-            // Seed of Corruption (Mobs cast) - no die req
-            if (dummySpell->SpellFamilyFlags.IsEqual(0, 0, 0) && dummySpell->SpellIconID == 1932)
-            {
-                // if damage is more than need deal finish spell
-                if (triggeredByAura->GetAmount() <= int32(damage))
-                {
-                    // remember guid before aura delete
-                    uint64 casterGuid = triggeredByAura->GetCasterGUID();
-
-                    // Remove aura (before cast for prevent infinite loop handlers)
-                    RemoveAurasDueToSpell(triggeredByAura->GetId());
-
-                    // Cast finish spell (triggeredByAura already not exist!)
-                    if (Unit* caster = GetUnit(*this, casterGuid))
-                        caster->CastSpell(this, 32865, true, castItem);
-                    return true;                            // no hidden cooldown
-                }
-                // Damage counting
-                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);
-                return true;
-            }
-            // Fel Synergy
-            if (dummySpell->SpellIconID == 3222)
-            {
-                target = GetGuardianPet();
-                if (!target)
-                    return false;
-                basepoints0 = damage * triggerAmount / 100;
-                triggered_spell_id = 54181;
-                break;
-            }
-            switch (dummySpell->Id)
-            {
-                // Siphon Life
-                case 63108:
-                {
-                    // Glyph of Siphon Life
-                    if (HasAura(56216))
-                        triggerAmount += triggerAmount / 4;
-                    triggered_spell_id = 63106;
-                    target = this;
-                    basepoints0 = int32(damage*triggerAmount/100);
-                    break;
-                }
-                // Glyph of Shadowflame
-                case 63310:
-                {
-                    triggered_spell_id = 63311;
-                    break;
-                }
-                // Nightfall
-                case 18094:
-                case 18095:
-                // Glyph of corruption
-                case 56218:
-                {
-                    target = this;
-                    triggered_spell_id = 17941;
-                    break;
-                }
-                //Soul Leech
-                case 30293:
-                case 30295:
-                case 30296:
-                {
-                    // Improved Soul Leech
-                    AuraEffectList const& SoulLeechAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
-                    for (Unit::AuraEffectList::const_iterator i = SoulLeechAuras.begin(); i != SoulLeechAuras.end(); ++i)
-                    {
-                        if ((*i)->GetId() == 54117 || (*i)->GetId() == 54118)
-                        {
-                            if ((*i)->GetEffIndex() != 0)
-                                continue;
-                            basepoints0 = int32((*i)->GetAmount());
-                            target = GetGuardianPet();
-                            if (target)
-                            {
-                                // regen mana for pet
-                                CastCustomSpell(target,54607,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-                            }
-                            // regen mana for caster
-                            CastCustomSpell(this,59117,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-                            // Get second aura of spell for replenishment effect on party
-                            if (AuraEffect const * aurEff = (*i)->GetBase()->GetEffect(1))
-                            {
-                                // Replenishment - roll chance
-                                if (roll_chance_i(aurEff->GetAmount()))
-                                {
-                                    CastSpell(this,57669,true, castItem, triggeredByAura);
-                                }
-                            }
-                            break;
-                        }
-                    }
-                    // health
-                    basepoints0 = int32(damage*triggerAmount/100);
-                    target = this;
-                    triggered_spell_id = 30294;
-                    break;
-                }
-                // Shadowflame (Voidheart Raiment set bonus)
-                case 37377:
-                {
-                    triggered_spell_id = 37379;
-                    break;
-                }
-                // Pet Healing (Corruptor Raiment or Rift Stalker Armor)
-                case 37381:
-                {
-                    target = GetGuardianPet();
-                    if (!target)
-                        return false;
-
-                    // heal amount
-                    basepoints0 = damage * triggerAmount/100;
-                    triggered_spell_id = 37382;
-                    break;
-                }
-                // Shadowflame Hellfire (Voidheart Raiment set bonus)
-                case 39437:
-                {
-                    triggered_spell_id = 37378;
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_PRIEST:
-        {
-            // Vampiric Touch
-            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)
-            {
-                if (!pVictim || !pVictim->isAlive())
-                    return false;
-
-                if (effIndex != 0)
-                    return false;
-
-                // pVictim is caster of aura
-                if (triggeredByAura->GetCasterGUID() != pVictim->GetGUID())
-                    return false;
-
-                // Energize 0.25% of max. mana
-                pVictim->CastSpell(pVictim,57669,true,castItem,triggeredByAura);
-                return true;                                // no hidden cooldown
-            }
-            // Divine Aegis
-            if (dummySpell->SpellIconID == 2820)
-            {
-                // Multiple effects stack, so let's try to find this aura.
-                int32 bonus = 0;
-                if (AuraEffect *aurEff = target->GetAuraEffect(47753, 0))
-                    bonus = aurEff->GetAmount();
-
-                basepoints0 = damage * triggerAmount/100 + bonus;
-                if (basepoints0 > target->getLevel() * 125)
-                    basepoints0 = target->getLevel() * 125;
-
-                triggered_spell_id = 47753;
-                break;
-            }
-            // Body and Soul
-            if (dummySpell->SpellIconID == 2218)
-            {
-                // Proc only from Abolish desease on self cast
-                if (procSpell->Id != 552 || pVictim != this || !roll_chance_i(triggerAmount))
-                    return false;
-                triggered_spell_id = 64136;
-                target = this;
-                break;
-            }
-            switch(dummySpell->Id)
-            {
-                // Vampiric Embrace
-                case 15286:
-                {
-                    if (!pVictim || !pVictim->isAlive())
-                        return false;
-
-                    // heal amount
-                    int32 team = triggerAmount*damage/500;
-                    int32 self = triggerAmount*damage/100 - team;
-                    CastCustomSpell(this,15290,&team,&self,NULL,true,castItem,triggeredByAura);
-                    return true;                                // no hidden cooldown
-                }
-                // Priest Tier 6 Trinket (Ashtongue Talisman of Acumen)
-                case 40438:
-                {
-                    // Shadow Word: Pain
-                    if (procSpell->SpellFamilyFlags[0] & 0x8000)
-                        triggered_spell_id = 40441;
-                    // Renew
-                    else if (procSpell->SpellFamilyFlags[0] & 0x40)
-                        triggered_spell_id = 40440;
-                    else
-                        return false;
-
-                    target = this;
-                    break;
-                }
-                // Glyph of Prayer of Healing
-                case 55680:
-                {
-                    triggered_spell_id = 56161;
-
-                    SpellEntry const* GoPoH = sSpellStore.LookupEntry(triggered_spell_id);
-                    if (!GoPoH)
-                        return false;
-
-                    int EffIndex = 0;
-                    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)
-                    {
-                        if (GoPoH->Effect[i] == SPELL_EFFECT_APPLY_AURA)
-                        {
-                            EffIndex = i;
-                            break;
-                        }
-                    }
-                    int32 tickcount = GetSpellMaxDuration(GoPoH) / GoPoH->EffectAmplitude[EffIndex];
-                    if (!tickcount)
-                        return false;
-
-                    basepoints0 = damage * triggerAmount / tickcount / 100;
-                    break;
-                }
-                // Improved Shadowform
-                case 47570:
-                case 47569:
-                {
-                    if (!roll_chance_i(triggerAmount))
-                        return false;
-
-                    RemoveMovementImpairingAuras();
-                    break;
-                }
-                // Glyph of Dispel Magic
-                case 55677:
-                {
-                    // Dispel Magic shares spellfamilyflag with abolish disease
-                    if (procSpell->SpellIconID != 74)
-                        return false;
-                    if (!target || !target->IsFriendlyTo(this))
-                        return false;
-
-                    basepoints0 = int32(target->CountPctFromMaxHealth(triggerAmount));
-                    triggered_spell_id = 56131;
-                    break;
-                }
-                // Oracle Healing Bonus ("Garments of the Oracle" set)
-                case 26169:
-                {
-                    // heal amount
-                    basepoints0 = int32(damage * 10/100);
-                    target = this;
-                    triggered_spell_id = 26170;
-                    break;
-                }
-                // Frozen Shadoweave (Shadow's Embrace set) warning! its not only priest set
-                case 39372:
-                {
-                    if (!procSpell || (GetSpellSchoolMask(procSpell) & (SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_SHADOW)) == 0)
-                        return false;
-
-                    // heal amount
-                    basepoints0 = damage * triggerAmount/100;
-                    target = this;
-                    triggered_spell_id = 39373;
-                    break;
-                }
-                // Greater Heal (Vestments of Faith (Priest Tier 3) - 4 pieces bonus)
-                case 28809:
-                {
-                    triggered_spell_id = 28810;
-                    break;
-                }
-                // Priest T10 Healer 2P Bonus
-                case 70770:
-                    // Flash Heal
-                    if (procSpell->SpellFamilyFlags[0] & 0x800)
-                    {
-                        triggered_spell_id = 70772;
-                        SpellEntry const* blessHealing = sSpellStore.LookupEntry(triggered_spell_id);
-                        if (!blessHealing)
-                            return false;
-                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(blessHealing) / blessHealing->EffectAmplitude[0]));
-                    }
-                    break;
-            }
-            break;
-        }
-        case SPELLFAMILY_DRUID:
-        {
-            switch(dummySpell->Id)
-            {
-                // Glyph of Innervate
-                case 54832:
-                {
-                    if (procSpell->SpellIconID != 62)
-                        return false;
-
-                    int32 mana_perc = SpellMgr::CalculateSpellEffectAmount(triggeredByAura->GetSpellProto(), triggeredByAura->GetEffIndex());
-                    basepoints0 = uint32((GetCreatePowers(POWER_MANA) * mana_perc / 100) / 10);
-                    triggered_spell_id = 54833;
-                    target = this;
-                    break;
-                }
-                // Glyph of Starfire
-                case 54845:
-                {
-                    triggered_spell_id = 54846;
-                    break;
-                }
-                // Glyph of Shred
-                case 54815:
-                {
-                    // try to find spell Rip on the target
-                    if (AuraEffect const *AurEff = target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00800000, 0x0, 0x0, GetGUID()))
-                    {
-                        // Rip's max duration, note: spells which modifies Rip's duration also counted like Glyph of Rip
-                        uint32 CountMin = AurEff->GetBase()->GetMaxDuration();
-
-                        // just Rip's max duration without other spells
-                        uint32 CountMax = GetSpellMaxDuration(AurEff->GetSpellProto());
-
-                        // add possible auras' and Glyph of Shred's max duration
-                        CountMax += 3 * triggerAmount * 1000;       // Glyph of Shred               -> +6 seconds
-                        CountMax += HasAura(54818) ? 4 * 1000 : 0;  // Glyph of Rip                 -> +4 seconds
-                        CountMax += HasAura(60141) ? 4 * 1000 : 0;  // Rip Duration/Lacerate Damage -> +4 seconds
-
-                        // if min < max -> that means caster didn't cast 3 shred yet
-                        // so set Rip's duration and max duration
-                        if (CountMin < CountMax)
-                        {
-                            AurEff->GetBase()->SetDuration(AurEff->GetBase()->GetDuration() + triggerAmount * 1000);
-                            AurEff->GetBase()->SetMaxDuration(CountMin + triggerAmount * 1000);
-                            return true;
-                        }
-                    }
-                    // if not found Rip
-                    return false;
-                }
-                // Glyph of Rake
-                case 54821:
-                {
-                    if (procSpell->SpellVisual[0] == 750 && procSpell->EffectApplyAuraName[1] == 3)
-                    {
-                        if (target->GetTypeId() == TYPEID_UNIT)
-                        {
-                            triggered_spell_id = 54820;
-                            break;
-                        }
-                    }
-                    return false;
-                }
-                // Leader of the Pack
-                case 24932:
-                {
-                   if (triggerAmount <= 0)
-                        return false;
-                    basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
-                    target = this;
-                    triggered_spell_id = 34299;
-                    if (triggeredByAura->GetCasterGUID() != GetGUID())
-                        break;
-                    int32 basepoints1 = triggerAmount * 2;
-                    // Improved Leader of the Pack
-                    // Check cooldown of heal spell cooldown
-                    if (GetTypeId() == TYPEID_PLAYER && !ToPlayer()->HasSpellCooldown(34299))
-                        CastCustomSpell(this,60889,&basepoints1,0,0,true,0,triggeredByAura);
-                    break;
-                }
-                // Healing Touch (Dreamwalker Raiment set)
-                case 28719:
-                {
-                    // mana back
-                    basepoints0 = int32(procSpell->manaCost * 30 / 100);
-                    target = this;
-                    triggered_spell_id = 28742;
-                    break;
-                }
-                // Glyph of Rejuvenation
-                case 54754:
-                {
-                    if (!pVictim || !pVictim->HealthBelowPct(uint32(triggerAmount)))
-                        return false;
-                    basepoints0 = int32(triggerAmount * damage / 100);
-                    triggered_spell_id = 54755;
-                    break;
-                }
-                // Healing Touch Refund (Idol of Longevity trinket)
-                case 28847:
-                {
-                    target = this;
-                    triggered_spell_id = 28848;
-                    break;
-                }
-                // Mana Restore (Malorne Raiment set / Malorne Regalia set)
-                case 37288:
-                case 37295:
-                {
-                    target = this;
-                    triggered_spell_id = 37238;
-                    break;
-                }
-                // Druid Tier 6 Trinket
-                case 40442:
-                {
-                    float  chance;
-
-                    // Starfire
-                    if (procSpell->SpellFamilyFlags[0] & 0x4)
-                    {
-                        triggered_spell_id = 40445;
-                        chance = 25.0f;
-                    }
-                    // Rejuvenation
-                    else if (procSpell->SpellFamilyFlags[0] & 0x10)
-                    {
-                        triggered_spell_id = 40446;
-                        chance = 25.0f;
-                    }
-                    // Mangle (Bear) and Mangle (Cat)
-                    else if (procSpell->SpellFamilyFlags[1] & 0x00000440)
-                    {
-                        triggered_spell_id = 40452;
-                        chance = 40.0f;
-                    }
-                    else
-                        return false;
-
-                    if (!roll_chance_f(chance))
-                        return false;
-
-                    target = this;
-                    break;
-                }
-                // Maim Interrupt
-                case 44835:
-                {
-                    // Deadly Interrupt Effect
-                    triggered_spell_id = 32747;
-                    break;
-                }
-                // Item - Druid T10 Balance 4P Bonus
-                case 70723:
-                {
-                    // Wrath & Starfire
-                    if ((procSpell->SpellFamilyFlags[0] & 0x5) && (procEx & PROC_EX_CRITICAL_HIT))
-                    {
-                        triggered_spell_id = 71023;
-                        SpellEntry const* triggeredSpell = sSpellStore.LookupEntry(triggered_spell_id);
-                        if (!triggeredSpell)
-                            return false;
-                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(triggeredSpell) / triggeredSpell->EffectAmplitude[0]));
-                    }
-                    break;
-                }
-            }
-            // Eclipse
-            if (dummySpell->SpellIconID == 2856 && GetTypeId() == TYPEID_PLAYER)
-            {
-                if (!procSpell || effIndex != 0)
-                    return false;
-
-                bool isWrathSpell = (procSpell->SpellFamilyFlags[0] & 1);
-
-                if (!roll_chance_f(dummySpell->procChance * (isWrathSpell ? 0.6f : 1.0f)))
-                    return false;
-
-                target = this;
-                if (target->HasAura(isWrathSpell ? 48517 : 48518))
-                    return false;
-
-                triggered_spell_id = isWrathSpell ? 48518 : 48517;
-                break;
-            }
-            // Living Seed
-            else if (dummySpell->SpellIconID == 2860)
-            {
-                triggered_spell_id = 48504;
-                basepoints0 = triggerAmount * damage / 100;
-                break;
-            }
-            // King of the Jungle
-            else if (dummySpell->SpellIconID == 2850)
-            {
-                // Effect 0 - mod damage while having Enrage
-                if (effIndex == 0)
-                {
-                    if (!(procSpell->SpellFamilyFlags[0] & 0x00080000))
-                        return false;
-                    triggered_spell_id = 51185;
-                    basepoints0 = triggerAmount;
-                    target = this;
-                    break;
-                }
-                // Effect 1 - Tiger's Fury restore energy
-                else if (effIndex == 1)
-                {
-                    if (!(procSpell->SpellFamilyFlags[2] & 0x00000800))
-                        return false;
-                    triggered_spell_id = 51178;
-                    basepoints0 = triggerAmount;
-                    target = this;
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_ROGUE:
-        {
-            switch(dummySpell->Id)
-            {
-                // Glyph of Backstab
-                case 56800:
-                {
-                    triggered_spell_id = 63975;
-                    break;
-                }
-                // Deadly Throw Interrupt
-                case 32748:
-                {
-                    // Prevent cast Deadly Throw Interrupt on self from last effect (apply dummy) of Deadly Throw
-                    if (this == pVictim)
-                        return false;
-
-                    triggered_spell_id = 32747;
-                    break;
-                }
-            }
-            // Cut to the Chase
-            if (dummySpell->SpellIconID == 2909)
-            {
-                // "refresh your Slice and Dice duration to its 5 combo point maximum"
-                // lookup Slice and Dice
-                if (AuraEffect const* aur = GetAuraEffect(SPELL_AURA_MOD_HASTE, SPELLFAMILY_ROGUE,0x40000, 0, 0))
-                {
-                    aur->GetBase()->SetDuration(GetSpellMaxDuration(aur->GetSpellProto()), true);
-                    return true;
-                }
-                return false;
-            }
-            // Deadly Brew
-            else if (dummySpell->SpellIconID == 2963)
-            {
-                triggered_spell_id = 3409;
-                break;
-            }
-            // Quick Recovery
-            else if (dummySpell->SpellIconID == 2116)
-            {
-                if (!procSpell)
-                    return false;
-
-                // energy cost save
-                basepoints0 = procSpell->manaCost * triggerAmount/100;
-                if (basepoints0 <= 0)
-                    return false;
-
-                target = this;
-                triggered_spell_id = 31663;
-                break;
-            }
-            break;
-        }
-        case SPELLFAMILY_HUNTER:
-        {
-            // Thrill of the Hunt
-            if (dummySpell->SpellIconID == 2236)
-            {
-                if (!procSpell)
-                    return false;
-
-                // Explosive Shot
-                if (procSpell->SpellFamilyFlags[2] & 0x200)
-                {
-                    if (AuraEffect const* pEff = pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_HUNTER, 0x0, 0x80000000, 0x0, GetGUID()))
-                        basepoints0 = CalculatePowerCost(pEff->GetSpellProto(), this, SpellSchoolMask(pEff->GetSpellProto()->SchoolMask)) * 4/10/3;
-                }
-                else
-                    basepoints0 = CalculatePowerCost(procSpell, this, SpellSchoolMask(procSpell->SchoolMask)) * 4/10;
-                if (basepoints0 <= 0)
-                    return false;
-
-                basepoints0 += 1;   // standard basepoint increase for CastCustomSpell
-                target = this;
-                triggered_spell_id = 34720;
-                break;
-            }
-            // Hunting Party
-            if (dummySpell->SpellIconID == 3406)
-            {
-                triggered_spell_id = 57669;
-                target = this;
-                break;
-            }
-            // Improved Mend Pet
-            if (dummySpell->SpellIconID == 267)
-            {
-                int32 chance = SpellMgr::CalculateSpellEffectAmount(triggeredByAura->GetSpellProto(), triggeredByAura->GetEffIndex());
-                if (!roll_chance_i(chance))
-                    return false;
-
-                triggered_spell_id = 24406;
-                break;
-            }
-            // Lock and Load
-            if (dummySpell->SpellIconID == 3579)
-            {
-                // Proc only from periodic (from trap activation proc another aura of this spell)
-                if (!(procFlag & PROC_FLAG_DONE_PERIODIC) || !roll_chance_i(triggerAmount))
-                    return false;
-                triggered_spell_id = 56453;
-                target = this;
-                break;
-            }
-            // Rapid Recuperation
-            if (dummySpell->SpellIconID == 3560)
-            {
-                // This effect only from Rapid Killing (mana regen)
-                if (!(procSpell->SpellFamilyFlags[1] & 0x01000000))
-                    return false;
-                triggered_spell_id = 56654;
-
-                target = this;
-
-                switch(dummySpell->Id)
-                {
-                    case 53228:                             // Rank 1
-                        triggered_spell_id = 56654;
-                        break;
-                    case 53232:                             // Rank 2
-                        triggered_spell_id = 58882;
-                        break;
-                }
-                break;
-            }
-            // Glyph of Mend Pet
-            if(dummySpell->Id == 57870)
-            {
-                pVictim->CastSpell(pVictim, 57894, true, NULL, NULL, GetGUID());
-                return true;
-            }
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Seal of Righteousness - melee proc dummy (addition ${$MWS*(0.022*$AP+0.044*$SPH)} damage)
-            if (dummySpell->SpellFamilyFlags[0]&0x8000000)
-            {
-                if (effIndex != 0)
-                    return false;
-                triggered_spell_id = 25742;
-                float ap = GetTotalAttackPowerValue(BASE_ATTACK);
-                int32 holy = SpellBaseDamageBonus(SPELL_SCHOOL_MASK_HOLY) +
-                             SpellBaseDamageBonusForVictim(SPELL_SCHOOL_MASK_HOLY, pVictim);
-                basepoints0 = (int32)GetAttackTime(BASE_ATTACK) * int32(ap*0.022f + 0.044f * holy) / 1000;
-                break;
-            }
-            // Light's Beacon - Beacon of Light
-            if (dummySpell->Id == 53651)
-            {
-                // Get target of beacon of light
-                if (Unit * beaconTarget = triggeredByAura->GetBase()->GetCaster())
-                {
-                    // do not proc when target of beacon of light is healed
-                    if (beaconTarget == this)
-                        return false;
-                    // check if it was heal by paladin which casted this beacon of light
-                    if (beaconTarget->GetAura(53563, pVictim->GetGUID()))
-                    {
-                        if (beaconTarget->IsWithinLOSInMap(pVictim))
-                        {
-                            basepoints0 = damage;
-                            triggered_spell_id = 53654;
-                            target = beaconTarget;
-                            break;
-                        }
-                    }
-                }
-                return false;
-            }
-            // Judgements of the Wise
-            if (dummySpell->SpellIconID == 3017)
-            {
-                target = this;
-                triggered_spell_id = 31930;
-                // replenishment
-                CastSpell(this,57669,true, castItem, triggeredByAura);
-                break;
-            }
-            // Sanctified Wrath
-            if (dummySpell->SpellIconID == 3029)
-            {
-                triggered_spell_id = 57318;
-                target = this;
-                basepoints0 = triggerAmount;
-                CastCustomSpell(target,triggered_spell_id,&basepoints0,&basepoints0,NULL,true,castItem,triggeredByAura);
-                return true;
-            }
-            // Sacred Shield
-            if (dummySpell->SpellFamilyFlags[1]&0x00080000)
-            {
-                if (procFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)
-                {
-                    if (procSpell->SpellFamilyName == SPELLFAMILY_PALADIN
-                        && (procSpell->SpellFamilyFlags[0] & 0x40000000))
-                    {
-                        basepoints0 = int32(float(damage)/12.0f);
-                        CastCustomSpell(this,66922,&basepoints0,NULL,NULL,true,0,triggeredByAura, pVictim->GetGUID());
-                        return true;
-                    }
-                    else
-                        return false;
-                }
-                else
-                    triggered_spell_id = 58597;
-                target = this;
-                break;
-            }
-            // Righteous Vengeance
-            if (dummySpell->SpellIconID == 3025)
-            {
-                // 4 damage tick
-                basepoints0 = triggerAmount*damage/400;
-                triggered_spell_id = 61840;
-                // Add remaining ticks to damage done
-                basepoints0 += pVictim->GetRemainingDotDamage(GetGUID(), triggered_spell_id);
-                break;
-            }
-            // Sheath of Light
-            if (dummySpell->SpellIconID == 3030)
-            {
-                // 4 healing tick
-                basepoints0 = triggerAmount*damage/400;
-                triggered_spell_id = 54203;
-                break;
-            }
-            switch (dummySpell->Id)
-            {
-                // Heart of the Crusader
-                case 20335: // rank 1
-                    triggered_spell_id = 21183;
-                    break;
-                case 20336: // rank 2
-                    triggered_spell_id = 54498;
-                    break;
-                case 20337: // rank 3
-                    triggered_spell_id = 54499;
-                    break;
-                // Judgement of Light
-                case 20185:
-                {
-                    if (pVictim->getPowerType() == POWER_MANA)
-                    {
-                        // 2% of base mana
-                        basepoints0 = int32(pVictim->CountPctFromMaxHealth(2));
-                        pVictim->CastCustomSpell(pVictim, 20267, &basepoints0, 0, 0, true, 0, triggeredByAura);
-                    }
-                        return true;
-                }
-                // Judgement of Wisdom
-                case 20186:
-                {
-                    if (pVictim && pVictim->isAlive() && pVictim->getPowerType() == POWER_MANA)
-                    {
-                        // 2% of base mana
-                        basepoints0 = int32(pVictim->GetCreateMana() * 2 / 100);
-                        pVictim->CastCustomSpell(pVictim, 20268, &basepoints0, NULL, NULL, true, 0, triggeredByAura);
-                    }
-                    return true;
-                }
-                // Holy Power (Redemption Armor set)
-                case 28789:
-                {
-                    if (!pVictim)
-                        return false;
-
-                    // Set class defined buff
-                    switch (pVictim->getClass())
-                    {
-                        case CLASS_PALADIN:
-                        case CLASS_PRIEST:
-                        case CLASS_SHAMAN:
-                        case CLASS_DRUID:
-                            triggered_spell_id = 28795;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
-                            break;
-                        case CLASS_MAGE:
-                        case CLASS_WARLOCK:
-                            triggered_spell_id = 28793;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
-                            break;
-                        case CLASS_HUNTER:
-                        case CLASS_ROGUE:
-                            triggered_spell_id = 28791;     // Increases the friendly target's attack power by $s1 for $d.
-                            break;
-                        case CLASS_WARRIOR:
-                            triggered_spell_id = 28790;     // Increases the friendly target's armor
-                            break;
-                        default:
-                            return false;
-                    }
-                    break;
-                }
-                case 25899:                                 // Greater Blessing of Sanctuary
-                case 20911:                                 // Blessing of Sanctuary
-                {
-                    target = this;
-                    switch (target->getPowerType())
-                    {
-                        case POWER_MANA:
-                            triggered_spell_id = 57319;
-                            break;
-                        default:
-                            return false;
-                    }
-                    break;
-                }
-                // Seal of Vengeance (damage calc on apply aura)
-                case 31801:
-                {
-                    if (effIndex != 0)                       // effect 1,2 used by seal unleashing code
-                        return false;
-
-                    // At melee attack or Hammer of the Righteous spell damage considered as melee attack
-                    if ((procFlag & PROC_FLAG_DONE_MELEE_AUTO_ATTACK) || (procSpell && procSpell->Id == 53595))
-                        triggered_spell_id = 31803;
-                    // On target with 5 stacks of Holy Vengeance direct damage is done
-                    if (Aura * aur = pVictim->GetAura(triggered_spell_id, GetGUID()))
-                    {
-                        if (aur->GetStackAmount() == 5)
-                        {
-                            aur->RefreshDuration();
-                            CastSpell(pVictim, 42463, true);
-                            return true;
-                        }
-                    }
-
-                    // Only Autoattack can stack debuff
-                    if (procFlag & PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS)
-                        return false;
-                    break;
-                }
-                // Seal of Corruption
-                case 53736:
-                {
-                    if (effIndex != 0)                       // effect 1,2 used by seal unleashing code
-                        return false;
-
-                    // At melee attack or Hammer of the Righteous spell damage considered as melee attack
-                    if ((procFlag & PROC_FLAG_DONE_MELEE_AUTO_ATTACK) || (procSpell && procSpell->Id == 53595))
-                        triggered_spell_id = 53742;
-                    // On target with 5 stacks of Blood Corruption direct damage is done
-                    if (Aura * aur = pVictim->GetAura(triggered_spell_id, GetGUID()))
-                    {
-                        if (aur->GetStackAmount() == 5)
-                        {
-                            aur->RefreshDuration();
-                            CastSpell(pVictim, 53739, true);
-                            return true;
-                        }
-                    }
-
-                    // Only Autoattack can stack debuff
-                    if (procFlag & PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS)
-                        return false;
-                    break;
-                }
-                // Spiritual Attunement
-                case 31785:
-                case 33776:
-                {
-                    // if healed by another unit (pVictim)
-                    if (this == pVictim)
-                        return false;
-
-                    // heal amount
-                    basepoints0 = triggerAmount*(std::min(damage,GetMaxHealth() - GetHealth()))/100;
-                    target = this;
-
-                    if (basepoints0)
-                        triggered_spell_id = 31786;
-                    break;
-                }
-                // Paladin Tier 6 Trinket (Ashtongue Talisman of Zeal)
-                case 40470:
-                {
-                    if (!procSpell)
-                        return false;
-
-                    float  chance;
-
-                    // Flash of light/Holy light
-                    if (procSpell->SpellFamilyFlags[0] & 0xC0000000)
-                    {
-                        triggered_spell_id = 40471;
-                        chance = 15.0f;
-                    }
-                    // Judgement (any)
-                    else if (GetSpellSpecific(procSpell) == SPELL_SPECIFIC_JUDGEMENT)
-                    {
-                        triggered_spell_id = 40472;
-                        chance = 50.0f;
-                    }
-                    else
-                        return false;
-
-                    if (!roll_chance_f(chance))
-                        return false;
-
-                    break;
-                }
-                // Glyph of Divinity
-                case 54939:
-                {
-                    // Lookup base amount mana restore
-                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; i++)
-                        if (procSpell->Effect[i] == SPELL_EFFECT_ENERGIZE)
-                        {
-                            int32 mana = SpellMgr::CalculateSpellEffectAmount(procSpell, i);
-                            CastCustomSpell(this, 54986, 0, &mana, 0, true, castItem, triggeredByAura);
-                            break;
-                        }
-                    return true;
-                }
-                // Glyph of Flash of Light
-                case 54936:
-                {
-                    triggered_spell_id = 54957;
-                    basepoints0 = triggerAmount*damage/100;
-                    break;
-                }
-                // Glyph of Holy Light
-                case 54937:
-                {
-                    triggered_spell_id = 54968;
-                    basepoints0 = triggerAmount*damage/100;
-                    break;
-                }
-                case 71406: // Tiny Abomination in a Jar
-                {
-                    if (!pVictim || !pVictim->isAlive())
-                        return false;
-
-                    CastSpell(this, 71432, true, NULL, triggeredByAura);
-
-                    Aura const* dummy = GetAura(71432);
-                    if (!dummy || dummy->GetStackAmount() < 8)
-                        return false;
-
-                    RemoveAurasDueToSpell(71432);
-                    triggered_spell_id = 71433;  // default main hand attack
-                    // roll if offhand
-                    if (Player const* player = ToPlayer())
-                        if (player->GetWeaponForAttack(OFF_ATTACK, true) && urand(0, 1))
-                            triggered_spell_id = 71434;
-                    target = pVictim;
-                    break;
-                }
-                case 71545: // Tiny Abomination in a Jar (Heroic)
-                {
-                    if (!pVictim || !pVictim->isAlive())
-                        return false;
-
-                    CastSpell(this, 71432, true, NULL, triggeredByAura);
-
-                    Aura const* dummy = GetAura(71432);
-                    if (!dummy || dummy->GetStackAmount() < 7)
-                        return false;
-
-                    RemoveAurasDueToSpell(71432);
-                    triggered_spell_id = 71433;  // default main hand attack
-                    // roll if offhand
-                    if (Player const* player = ToPlayer())
-                        if (player->GetWeaponForAttack(OFF_ATTACK, true) && urand(0, 1))
-                            triggered_spell_id = 71434;
-                    target = pVictim;
-                    break;
-                }
-                // Item - Paladin T10 Retribution 2P Bonus
-                case 70765:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    this->ToPlayer()->RemoveSpellCooldown(53385, true);
-                    return true;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_SHAMAN:
-        {
-            switch(dummySpell->Id)
-            {
-                // Earthen Power (Rank 1, 2)
-                case 51523:
-                case 51524:
-                {
-                    // Totem itself must be a caster of this spell
-                    Unit* caster = NULL;
-                    for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr) {
-                        if ((*itr)->GetEntry() != 2630)
-                            continue;
-
-                        caster = (*itr);
-                        break;
-                    }
-
-                    if (!caster)
-                        return false;
-
-                    caster->CastSpell(caster, 59566, true, castItem, triggeredByAura, originalCaster);
-                    return true;
-                }
-                // Tidal Force
-                case 55198:
-                {
-                    // Remove aura stack from  caster
-                    RemoveAuraFromStack(55166);
-                    // drop charges
-                    return false;
-                }
-                // Totemic Power (The Earthshatterer set)
-                case 28823:
-                {
-                    if (!pVictim)
-                        return false;
-
-                    // Set class defined buff
-                    switch (pVictim->getClass())
-                    {
-                        case CLASS_PALADIN:
-                        case CLASS_PRIEST:
-                        case CLASS_SHAMAN:
-                        case CLASS_DRUID:
-                            triggered_spell_id = 28824;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
-                            break;
-                        case CLASS_MAGE:
-                        case CLASS_WARLOCK:
-                            triggered_spell_id = 28825;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
-                            break;
-                        case CLASS_HUNTER:
-                        case CLASS_ROGUE:
-                            triggered_spell_id = 28826;     // Increases the friendly target's attack power by $s1 for $d.
-                            break;
-                        case CLASS_WARRIOR:
-                            triggered_spell_id = 28827;     // Increases the friendly target's armor
-                            break;
-                        default:
-                            return false;
-                    }
-                    break;
-                }
-                // Lesser Healing Wave (Totem of Flowing Water Relic)
-                case 28849:
-                {
-                    target = this;
-                    triggered_spell_id = 28850;
-                    break;
-                }
-                // Windfury Weapon (Passive) 1-5 Ranks
-                case 33757:
-                {
-                    if (GetTypeId() != TYPEID_PLAYER || !castItem || !castItem->IsEquipped()  || !pVictim || !pVictim->isAlive())
-                        return false;
-
-                    // custom cooldown processing case
-                    if (cooldown && ToPlayer()->HasSpellCooldown(dummySpell->Id))
-                        return false;
-
-                    if (triggeredByAura->GetBase() && castItem->GetGUID() != triggeredByAura->GetBase()->GetCastItemGUID())
-                        return false;
-
-                    WeaponAttackType attType = WeaponAttackType(this->ToPlayer()->GetAttackBySlot(castItem->GetSlot()));
-                    if ((attType != BASE_ATTACK && attType != OFF_ATTACK) || !isAttackReady(attType))
-                        return false;
-
-                    // Now compute real proc chance...
-                    uint32 chance = 20;
-                    this->ToPlayer()->ApplySpellMod(dummySpell->Id,SPELLMOD_CHANCE_OF_SUCCESS,chance);
-
-                    Item* addWeapon = this->ToPlayer()->GetWeaponForAttack(attType == BASE_ATTACK ? OFF_ATTACK : BASE_ATTACK, true);
-                    uint32 enchant_id_add = addWeapon ? addWeapon->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)) : 0;
-                    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id_add);
-                    if (pEnchant && pEnchant->spellid[0] == dummySpell->Id)
-                        chance += 14;
-
-                    if (!roll_chance_i(chance))
-                        return false;
-
-                    // Now amount of extra power stored in 1 effect of Enchant spell
-                    // Get it by item enchant id
-                    uint32 spellId;
-                    switch (castItem->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)))
-                    {
-                        case 283: spellId =  8232; break;   // 1 Rank
-                        case 284: spellId =  8235; break;   // 2 Rank
-                        case 525: spellId = 10486; break;   // 3 Rank
-                        case 1669:spellId = 16362; break;   // 4 Rank
-                        case 2636:spellId = 25505; break;   // 5 Rank
-                        case 3785:spellId = 58801; break;   // 6 Rank
-                        case 3786:spellId = 58803; break;   // 7 Rank
-                        case 3787:spellId = 58804; break;   // 8 Rank
-                        default:
-                        {
-                            sLog.outError("Unit::HandleDummyAuraProc: non handled item enchantment (rank?) %u for spell id: %u (Windfury)",
-                                castItem->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)),dummySpell->Id);
-                            return false;
-                        }
-                    }
-
-                    SpellEntry const* windfurySpellEntry = sSpellStore.LookupEntry(spellId);
-                    if (!windfurySpellEntry)
-                    {
-                        sLog.outError("Unit::HandleDummyAuraProc: non existed spell id: %u (Windfury)",spellId);
-                        return false;
-                    }
-
-                    int32 extra_attack_power = CalculateSpellDamage(pVictim, windfurySpellEntry, 1);
-
-                    // Value gained from additional AP
-                    basepoints0 = int32(extra_attack_power/14.0f * GetAttackTime(BASE_ATTACK)/1000);
-                    triggered_spell_id = 25504;
-
-                    // apply cooldown before cast to prevent processing itself
-                    if (cooldown)
-                        ToPlayer()->AddSpellCooldown(dummySpell->Id,0,time(NULL) + cooldown);
-
-                    // Attack Twice
-                    for (uint32 i = 0; i<2; ++i)
-                        CastCustomSpell(pVictim,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-
-                    return true;
-                }
-                // Shaman Tier 6 Trinket
-                case 40463:
-                {
-                    if (!procSpell)
-                        return false;
-
-                    float chance;
-                    if (procSpell->SpellFamilyFlags[0] & 0x1)
-                    {
-                        triggered_spell_id = 40465;         // Lightning Bolt
-                        chance = 15.0f;
-                    }
-                    else if (procSpell->SpellFamilyFlags[0] & 0x80)
-                    {
-                        triggered_spell_id = 40465;         // Lesser Healing Wave
-                        chance = 10.0f;
-                    }
-                    else if (procSpell->SpellFamilyFlags[1] & 0x00000010)
-                    {
-                        triggered_spell_id = 40466;         // Stormstrike
-                        chance = 50.0f;
-                    }
-                    else
-                        return false;
-
-                    if (!roll_chance_f(chance))
-                        return false;
-
-                    target = this;
-                    break;
-                }
-                // Glyph of Healing Wave
-                case 55440:
-                {
-                    // Not proc from self heals
-                    if (this == pVictim)
-                        return false;
-                    basepoints0 = triggerAmount * damage / 100;
-                    target = this;
-                    triggered_spell_id = 55533;
-                    break;
-                }
-                // Spirit Hunt
-                case 58877:
-                {
-                    // Cast on owner
-                    target = GetOwner();
-                    if (!target)
-                        return false;
-                    basepoints0 = triggerAmount * damage / 100;
-                    triggered_spell_id = 58879;
-                    break;
-                }
-                // Shaman T8 Elemental 4P Bonus
-                case 64928:
-                {
-                    basepoints0 = int32(triggerAmount * damage / 100);
-                    triggered_spell_id = 64930;            // Electrified
-                    break;
-                }
-                // Shaman T9 Elemental 4P Bonus
-                case 67228:
-                {
-                    // Lava Burst
-                    if (procSpell->SpellFamilyFlags[1] & 0x1000)
-                    {
-                        triggered_spell_id = 71824;
-                        SpellEntry const* triggeredSpell = sSpellStore.LookupEntry(triggered_spell_id);
-                        if (!triggeredSpell)
-                            return false;
-                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(triggeredSpell) / triggeredSpell->EffectAmplitude[0]));
-                    }
-                    break;
-                }
-                // Item - Shaman T10 Restoration 4P Bonus
-                case 70808:
-                {
-                    // Chain Heal
-                    if((procSpell->SpellFamilyFlags[0] & 0x100) && (procEx & PROC_EX_CRITICAL_HIT))
-                    {
-                        triggered_spell_id = 70809;
-                        SpellEntry const* triggeredSpell = sSpellStore.LookupEntry(triggered_spell_id);
-                        if (!triggeredSpell)
-                            return false;
-                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(triggeredSpell) / triggeredSpell->EffectAmplitude[0]));
-                    }
-                    break;
-                }
-                // Item - Shaman T10 Elemental 2P Bonus
-                case 70811:
-                {
-                    // Lightning Bolt & Chain Lightning
-                    if(procSpell->SpellFamilyFlags[0] & 0x3)
-                    {
-                        if (ToPlayer()->HasSpellCooldown(16166))
-                        {
-                            uint32 newCooldownDelay = ToPlayer()->GetSpellCooldownDelay(16166);
-                            if (newCooldownDelay < 3)
-                                newCooldownDelay = 0;
-                            else
-                                newCooldownDelay -= 2;
-                            ToPlayer()->AddSpellCooldown(16166,0, uint32(time(NULL) + newCooldownDelay));
-
-                            WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
-                            data << uint32(16166);                  // Spell ID
-                            data << uint64(GetGUID());              // Player GUID
-                            data << int32(-2000);                   // Cooldown mod in milliseconds
-                            ToPlayer()->GetSession()->SendPacket(&data);
-                            return true;
-                        }
-                    }
-                    return false;
-                }
-                case 63280: // Glyph of Totem of Wrath
-                {
-                    if (procSpell->SpellIconID != 2019)
-                        return false;
-
-                    AuraEffect * aurEffA = NULL;
-                    AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
-                    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
-                    {
-                        SpellEntry const *spell = (*i)->GetSpellProto();
-                        if (spell->SpellFamilyName == uint32(SPELLFAMILY_SHAMAN) && spell->SpellFamilyFlags.HasFlag(0, 0x02000000, 0))
-                        {
-                            if ((*i)->GetCasterGUID() != GetGUID())
-                                continue;
-                            if (spell->Id == 63283)
-                                continue;
-                            aurEffA = (*i);
-                            break;
-                        }
-                    }
-                    if (aurEffA)
-                    {
-                        int32 bp0 = 0, bp1 = 0;
-                        bp0 = aurEffA->GetAmount() * triggerAmount / 100;
-                        if (AuraEffect * aurEffB = aurEffA->GetBase()->GetEffect(EFFECT_1))
-                            bp1 = aurEffB->GetAmount() * triggerAmount / 100;
-                        CastCustomSpell(this, 63283, &bp0, &bp1, NULL, true, NULL, triggeredByAura);
-                        return true;
-                    }
-                    return false;
-                }
-                break;
-            }
-            // Frozen Power
-            if (dummySpell->SpellIconID == 3780)
-            {
-                if (this->GetDistance(target) < 15.0f)
-                    return false;
-                float chance = (float)triggerAmount;
-                if (!roll_chance_f(chance))
-                    return false;
-
-                triggered_spell_id = 63685;
-                break;
-            }
-            // Storm, Earth and Fire
-            if (dummySpell->SpellIconID == 3063)
-            {
-                // Earthbind Totem summon only
-                if (procSpell->Id != 2484)
-                    return false;
-
-                float chance = (float)triggerAmount;
-                if (!roll_chance_f(chance))
-                    return false;
-
-                triggered_spell_id = 64695;
-                break;
-            }
-            // Ancestral Awakening
-            if (dummySpell->SpellIconID == 3065)
-            {
-                triggered_spell_id = 52759;
-                basepoints0 = triggerAmount * damage / 100;
-                target = this;
-                break;
-            }
-            // Earth Shield
-            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)
-            {
-                // 3.0.8: Now correctly uses the Shaman's own spell critical strike chance to determine the chance of a critical heal.
-                originalCaster = triggeredByAura->GetCasterGUID();
-                target = this;
-                basepoints0 = triggerAmount;
-
-                // Glyph of Earth Shield
-                if (AuraEffect* aur = GetAuraEffect(63279,0))
-                {
-                    int32 aur_mod = aur->GetAmount();
-                    basepoints0 = int32(basepoints0 * (aur_mod + 100.0f) / 100.0f);
-                }
-                triggered_spell_id = 379;
-                break;
-            }
-            // Flametongue Weapon (Passive)
-            if (dummySpell->SpellFamilyFlags[0] & 0x200000)
-            {
-                if (GetTypeId() != TYPEID_PLAYER  || !pVictim || !pVictim->isAlive() || !castItem || !castItem->IsEquipped())
-                    return false;
-
-                float fire_onhit = (float)(SpellMgr::CalculateSpellEffectAmount(dummySpell, 0) / 100.0);
-
-                float add_spellpower = (float)(SpellBaseDamageBonus(SPELL_SCHOOL_MASK_FIRE)
-                                     + SpellBaseDamageBonusForVictim(SPELL_SCHOOL_MASK_FIRE, pVictim));
-
-                // 1.3speed = 5%, 2.6speed = 10%, 4.0 speed = 15%, so, 1.0speed = 3.84%
-                add_spellpower= add_spellpower / 100.0f * 3.84f;
-
-                // Enchant on Off-Hand and ready?
-                if (castItem->GetSlot() == EQUIPMENT_SLOT_OFFHAND && isAttackReady(OFF_ATTACK))
-                {
-                    float BaseWeaponSpeed = GetAttackTime(OFF_ATTACK)/1000.0f;
-
-                    // Value1: add the tooltip damage by swingspeed + Value2: add spelldmg by swingspeed
-                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));
-                    triggered_spell_id = 10444;
-                }
-
-                // Enchant on Main-Hand and ready?
-                else if (castItem->GetSlot() == EQUIPMENT_SLOT_MAINHAND && isAttackReady(BASE_ATTACK))
-                {
-                    float BaseWeaponSpeed = GetAttackTime(BASE_ATTACK)/1000.0f;
-
-                    // Value1: add the tooltip damage by swingspeed +  Value2: add spelldmg by swingspeed
-                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));
-                    triggered_spell_id = 10444;
-                }
-
-                // If not ready, we should  return, shouldn't we?!
-                else
-                    return false;
-
-                CastCustomSpell(pVictim,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-                return true;
-            }
-            // Improved Water Shield
-            if (dummySpell->SpellIconID == 2287)
-            {
-                // Default chance for Healing Wave and Riptide
-                float chance = (float)triggeredByAura->GetAmount();
-
-                if (procSpell->SpellFamilyFlags[0] & 0x80)
-                    // Lesser Healing Wave - 0.6 of default
-                    chance *= 0.6f;
-                else if (procSpell->SpellFamilyFlags[0] & 0x100)
-                    // Chain heal - 0.3 of default
-                    chance *= 0.3f;
-
-                if (!roll_chance_f(chance))
-                    return false;
-
-                // Water Shield
-                if (AuraEffect const * aurEff = GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 0, 0x00000020, 0))
-                {
-                    uint32 spell = aurEff->GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
-                    CastSpell(this, spell, true, castItem, triggeredByAura);
-                    return true;
-                }
-                return false;
-            }
-            // Lightning Overload
-            if (dummySpell->SpellIconID == 2018)            // only this spell have SpellFamily Shaman SpellIconID == 2018 and dummy aura
-            {
-                if (!procSpell || GetTypeId() != TYPEID_PLAYER || !pVictim)
-                    return false;
-
-                // custom cooldown processing case
-                if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(dummySpell->Id))
-                    return false;
-
-                uint32 spellId = 0;
-                // Every Lightning Bolt and Chain Lightning spell have duplicate vs half damage and zero cost
-                switch (procSpell->Id)
-                {
-                    // Lightning Bolt
-                    case   403: spellId = 45284; break;     // Rank  1
-                    case   529: spellId = 45286; break;     // Rank  2
-                    case   548: spellId = 45287; break;     // Rank  3
-                    case   915: spellId = 45288; break;     // Rank  4
-                    case   943: spellId = 45289; break;     // Rank  5
-                    case  6041: spellId = 45290; break;     // Rank  6
-                    case 10391: spellId = 45291; break;     // Rank  7
-                    case 10392: spellId = 45292; break;     // Rank  8
-                    case 15207: spellId = 45293; break;     // Rank  9
-                    case 15208: spellId = 45294; break;     // Rank 10
-                    case 25448: spellId = 45295; break;     // Rank 11
-                    case 25449: spellId = 45296; break;     // Rank 12
-                    case 49237: spellId = 49239; break;     // Rank 13
-                    case 49238: spellId = 49240; break;     // Rank 14
-                    // Chain Lightning
-                    case   421: spellId = 45297; break;     // Rank  1
-                    case   930: spellId = 45298; break;     // Rank  2
-                    case  2860: spellId = 45299; break;     // Rank  3
-                    case 10605: spellId = 45300; break;     // Rank  4
-                    case 25439: spellId = 45301; break;     // Rank  5
-                    case 25442: spellId = 45302; break;     // Rank  6
-                    case 49270: spellId = 49268; break;     // Rank  7
-                    case 49271: spellId = 49269; break;     // Rank  8
-                    default:
-                        sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u (LO)", procSpell->Id);
-                        return false;
-                }
-
-                // Chain Lightning
-                if (procSpell->SpellFamilyFlags[0] & 0x2)
-                {
-                    // Chain lightning has [LightOverload_Proc_Chance] / [Max_Number_of_Targets] chance to proc of each individual target hit.
-                    // A maxed LO would have a 33% / 3 = 11% chance to proc of each target.
-                    // LO chance was already "accounted" at the proc chance roll, now need to divide the chance by [Max_Number_of_Targets]
-                    float chance = 100.0f / procSpell->EffectChainTarget[effIndex];
-                    if (!roll_chance_f(chance))
-                        return false;
-
-                    // Remove cooldown (Chain Lightning - have Category Recovery time)
-                    ToPlayer()->RemoveSpellCooldown(spellId);
-                }
-
-                CastSpell(pVictim, spellId, true, castItem, triggeredByAura);
-
-                if (cooldown && GetTypeId() == TYPEID_PLAYER)
-                    ToPlayer()->AddSpellCooldown(dummySpell->Id, 0, time(NULL) + cooldown);
-
-                return true;
-            }
-            // Static Shock
-            if (dummySpell->SpellIconID == 3059)
-            {
-                // Lightning Shield
-                if (AuraEffect const * aurEff = GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 0x400, 0, 0))
-                {
-                    uint32 spell = sSpellMgr.GetSpellWithRank(26364, sSpellMgr.GetSpellRank(aurEff->GetId()));
-
-                    // custom cooldown processing case
-                    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(spell))
-                        ToPlayer()->RemoveSpellCooldown(spell);
-
-                    CastSpell(target, spell, true, castItem, triggeredByAura);
-                    aurEff->GetBase()->DropCharge();
-                    return true;
-                }
-                return false;
-            }
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Blood-Caked Strike - Blood-Caked Blade
-            if (dummySpell->SpellIconID == 138)
-            {
-                if (!target || !target->isAlive())
-                    return false;
-
-                triggered_spell_id = dummySpell->EffectTriggerSpell[effIndex];
-                break;
-            }
-            // Improved Blood Presence
-            if (dummySpell->SpellIconID == 2636)
-            {
-                if (GetTypeId() != TYPEID_PLAYER)
-                    return false;
-                basepoints0 = triggerAmount * damage / 100;
-                break;
-            }
-            // Butchery
-            if (dummySpell->SpellIconID == 2664)
-            {
-                basepoints0 = triggerAmount;
-                triggered_spell_id = 50163;
-                target = this;
-                break;
-            }
-            // Dancing Rune Weapon
-            if (dummySpell->Id == 49028)
-            {
-                // 1 dummy aura for dismiss rune blade
-                if (effIndex != 1)
-                    return false;
-
-                Unit* pPet = NULL;
-                for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr) //Find Rune Weapon
-                    if ((*itr)->GetEntry() == 27893)
-                    {
-                        pPet = (*itr);
-                        break;
-                    }
-
-                if (pPet && pPet->getVictim() && damage && procSpell)
-                {
-                    uint32 procDmg = damage / 2;
-                    pPet->SendSpellNonMeleeDamageLog(pPet->getVictim(),procSpell->Id,procDmg,GetSpellSchoolMask(procSpell),0,0,false,0,false);
-                    pPet->DealDamage(pPet->getVictim(),procDmg,NULL,SPELL_DIRECT_DAMAGE,GetSpellSchoolMask(procSpell),procSpell,true);
-                    break;
-                }
-                else
-                    return false;
-            }
-            // Mark of Blood
-            if (dummySpell->Id == 49005)
-            {
-                // TODO: need more info (cooldowns/PPM)
-                triggered_spell_id = 61607;
-                break;
-            }
-            // Unholy Blight
-            if (dummySpell->Id == 49194)
-            {
-                basepoints0 = triggerAmount * damage / 100;
-                // Glyph of Unholy Blight
-                if (AuraEffect *glyph=GetAuraEffect(63332,0))
-                    basepoints0 += basepoints0 * glyph->GetAmount() / 100;
-                // Find replaced aura to use it's remaining amount
-                AuraEffectList const& DoTAuras = target->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
-                for (Unit::AuraEffectList::const_iterator i = DoTAuras.begin(); i != DoTAuras.end(); ++i)
-                {
-                     if ((*i)->GetCasterGUID() != GetGUID() || (*i)->GetId() != 50536)
-                         continue;
-                     basepoints0 += ((*i)->GetAmount() * ((*i)->GetTotalTicks() - ((*i)->GetTickNumber()))) / (*i)->GetTotalTicks();
-                     break;
-                }
-
-                triggered_spell_id = 50536;
-                break;
-            }
-            // Vendetta
-            if (dummySpell->SpellFamilyFlags[0] & 0x10000)
-            {
-                basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
-                triggered_spell_id = 50181;
-                target = this;
-                break;
-            }
-            // Necrosis
-            if (dummySpell->SpellIconID == 2709)
-            {
-                basepoints0 = triggerAmount * damage / 100;
-                triggered_spell_id = 51460;
-                break;
-            }
-            // Threat of Thassarian
-            if (dummySpell->SpellIconID == 2023)
-            {
-                // Must Dual Wield
-                if (!procSpell || !haveOffhandWeapon())
-                    return false;
-                // Chance as basepoints for dummy aura
-                if (!roll_chance_i(triggerAmount))
-                    return false;
-
-                switch (procSpell->Id)
-                {
-                    // Obliterate
-                    case 49020: triggered_spell_id = 66198; break;                            // Rank 1
-                    case 51423: triggered_spell_id = 66972; break;                            // Rank 2
-                    case 51424: triggered_spell_id = 66973; break;                            // Rank 3
-                    case 51425: triggered_spell_id = 66974; break;                            // Rank 4
-
-                    // Frost Strike
-                    case 49143: triggered_spell_id = 66196; break;                            // Rank 1
-                    case 51416: triggered_spell_id = 66958; break;                            // Rank 2
-                    case 51417: triggered_spell_id = 66959; break;                            // Rank 3
-                    case 51418: triggered_spell_id = 66960; break;                            // Rank 4
-                    case 51419: triggered_spell_id = 66961; break;                            // Rank 5
-                    case 55268: triggered_spell_id = 66962; break;                            // Rank 6
-
-                    // Plague Strike
-                    case 45462: triggered_spell_id = 66216; break;                            // Rank 1
-                    case 49917: triggered_spell_id = 66988; break;                            // Rank 2
-                    case 49918: triggered_spell_id = 66989; break;                            // Rank 3
-                    case 49919: triggered_spell_id = 66990; break;                            // Rank 4
-                    case 49920: triggered_spell_id = 66991; break;                            // Rank 5
-                    case 49921: triggered_spell_id = 66992; break;                            // Rank 6
-
-                    // Death Strike
-                    case 49998: triggered_spell_id = 66188; break;                            // Rank 1
-                    case 49999: triggered_spell_id = 66950; break;                            // Rank 2
-                    case 45463: triggered_spell_id = 66951; break;                            // Rank 3
-                    case 49923: triggered_spell_id = 66952; break;                            // Rank 4
-                    case 49924: triggered_spell_id = 66953; break;                            // Rank 5
-
-                    // Rune Strike
-                    case 56815: triggered_spell_id = 66217; break;                            // Rank 1
-
-                    // Blood Strike
-                    case 45902: triggered_spell_id = 66215; break;                            // Rank 1
-                    case 49926: triggered_spell_id = 66975; break;                            // Rank 2
-                    case 49927: triggered_spell_id = 66976; break;                            // Rank 3
-                    case 49928: triggered_spell_id = 66977; break;                            // Rank 4
-                    case 49929: triggered_spell_id = 66978; break;                            // Rank 5
-                    case 49930: triggered_spell_id = 66979; break;                            // Rank 6
-                    default:
-                        return false;
-                }
-                break;
-            }
-            // Runic Power Back on Snare/Root
-            if (dummySpell->Id == 61257)
-            {
-                // only for spells and hit/crit (trigger start always) and not start from self casted spells
-                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == pVictim)
-                    return false;
-                // Need snare or root mechanic
-                if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_SNARE))))
-                    return false;
-                triggered_spell_id = 61258;
-                target = this;
-                break;
-            }
-            // Wandering Plague
-            if (dummySpell->SpellIconID == 1614)
-            {
-                if (!roll_chance_f(GetUnitCriticalChance(BASE_ATTACK, pVictim)))
-                    return false;
-                basepoints0 = triggerAmount * damage / 100;
-                triggered_spell_id = 50526;
-                break;
-            }
-            // Sudden Doom
-            if (dummySpell->SpellIconID == 1939 && GetTypeId() == TYPEID_PLAYER)
-            {
-                SpellChainNode const* chain = NULL;
-                // get highest rank of the Death Coil spell
-                const PlayerSpellMap& sp_list = this->ToPlayer()->GetSpellMap();
-                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
-                {
-                    // check if shown in spell book
-                    if (!itr->second->active || itr->second->disabled || itr->second->state == PLAYERSPELL_REMOVED)
-                        continue;
-
-                    SpellEntry const *spellProto = sSpellStore.LookupEntry(itr->first);
-                    if (!spellProto)
-                        continue;
-
-                    if (spellProto->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT
-                        && spellProto->SpellFamilyFlags[0] & 0x2000)
-                    {
-                        SpellChainNode const* newChain = sSpellMgr.GetSpellChainNode(itr->first);
-
-                        // No chain entry or entry lower than found entry
-                        if (!chain || !newChain || (chain->rank < newChain->rank))
-                        {
-                            triggered_spell_id = itr->first;
-                            chain = newChain;
-                        }
-                        else
-                            continue;
-                        // Found spell is last in chain - do not need to look more
-                        // Optimisation for most common case
-                        if (chain && chain->last == itr->first)
-                            break;
-                    }
-                }
-            }
-            // Item - Death Knight T10 Melee 4P Bonus
-            if (dummySpell->Id == 70656)
-            {
-                if (!this->ToPlayer())
-                    return false;
-
-                for (uint32 i = 0; i < MAX_RUNES; ++i)
-                    if (this->ToPlayer()->GetRuneCooldown(i) == 0)
-                        return false;
-            }
-            break;
-        }
-        case SPELLFAMILY_POTION:
-        {
-            // alchemist's stone
-            if (dummySpell->Id == 17619)
-            {
-                if (procSpell->SpellFamilyName == SPELLFAMILY_POTION)
-                {
-                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; i++)
-                    {
-                        if (procSpell->Effect[i] == SPELL_EFFECT_HEAL)
-                        {
-                            triggered_spell_id = 21399;
-                        }
-                        else if (procSpell->Effect[i] == SPELL_EFFECT_ENERGIZE)
-                        {
-                            triggered_spell_id = 21400;
-                        }
-                        else
-                            continue;
-
-                        basepoints0 = int32(CalculateSpellDamage(this, procSpell,i) * 0.4f);
-                        CastCustomSpell(this,triggered_spell_id,&basepoints0,NULL,NULL,true,NULL,triggeredByAura);
-                    }
-                    return true;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_PET:
-        {
-            switch (dummySpell->SpellIconID)
-            {
-                // Guard Dog
-                case 201:
-                {
-                    triggered_spell_id = 54445;
-                    target = this;
-                    float addThreat = SpellMgr::CalculateSpellEffectAmount(procSpell, 0, this) * triggerAmount / 100.0f;
-                    pVictim->AddThreat(this, addThreat);
-                    break;
-                }
-                // Silverback
-                case 1582:
-                    triggered_spell_id = dummySpell->Id == 62765 ? 62801 : 62800;
-                    target = this;
-                    break;
-            }
-            break;
-        }
-        default:
-            break;
-    }
-
-    // if not handled by custom case, get triggered spell from dummySpell proto
-    if (!triggered_spell_id)
-        triggered_spell_id = dummySpell->EffectTriggerSpell[triggeredByAura->GetEffIndex()];
-
-    // processed charge only counting case
-    if (!triggered_spell_id)
-        return true;
-
-    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
-    if (!triggerEntry)
-    {
-        sLog.outError("Unit::HandleDummyAuraProc: Spell %u have not existed triggered spell %u",dummySpell->Id,triggered_spell_id);
-        return false;
-    }
-
-    // default case
-    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
-        return false;
-
-    if (cooldown_spell_id == 0)
-        cooldown_spell_id = triggered_spell_id;
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(cooldown_spell_id))
-        return false;
-
-    if (basepoints0)
-        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura, originalCaster);
-    else
-        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura, originalCaster);
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER)
-        ToPlayer()->AddSpellCooldown(cooldown_spell_id,0,time(NULL) + cooldown);
-
-    return true;
-}
-bool Unit::HandleObsModEnergyAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
-{
-    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto ();
-    //uint32 effIndex = triggeredByAura->GetEffIndex();
-    //int32  triggerAmount = triggeredByAura->GetAmount();
-
-    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
-        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
-
-    uint32 triggered_spell_id = 0;
-    Unit* target = pVictim;
-    int32 basepoints0 = 0;
-
-    switch(dummySpell->SpellFamilyName)
-    {
-        case SPELLFAMILY_HUNTER:
-        {
-            // Aspect of the Viper
-            if (dummySpell->SpellFamilyFlags[1] & 0x40000)
-            {
-                uint32 maxmana = GetMaxPower(POWER_MANA);
-                basepoints0 = uint32(maxmana* GetAttackTime(RANGED_ATTACK)/1000.0f/100.0f);
-                target = this;
-                triggered_spell_id = 34075;
-                break;
-            }
-            break;
-        }
-    }
-    // processed charge only counting case
-    if (!triggered_spell_id)
-        return true;
-
-    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
-
-    // Try handle unknown trigger spells
-    if (!triggerEntry)
-    {
-        sLog.outError("Unit::HandleObsModEnergyAuraProc: Spell %u have not existed triggered spell %u",dummySpell->Id,triggered_spell_id);
-        return false;
-    }
-
-    // default case
-    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
-        return false;
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
-        return false;
-    if (basepoints0)
-        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-    else
-        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
-    return true;
-}
-bool Unit::HandleModDamagePctTakenAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
-{
-    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto ();
-    //uint32 effIndex = triggeredByAura->GetEffIndex();
-    //int32  triggerAmount = triggeredByAura->GetAmount();
-
-    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
-        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
-
-    uint32 triggered_spell_id = 0;
-    Unit* target = pVictim;
-    int32 basepoints0 = 0;
-
-    switch(dummySpell->SpellFamilyName)
-    {
-        case SPELLFAMILY_PALADIN:
-        {
-            // Blessing of Sanctuary
-            if (dummySpell->SpellFamilyFlags[0] & 0x10000000)
-            {
-                switch (getPowerType())
-                {
-                    case POWER_MANA:   triggered_spell_id = 57319; break;
-                    default:
-                        return false;
-                }
-            }
-            break;
-        }
-    }
-    // processed charge only counting case
-    if (!triggered_spell_id)
-        return true;
-
-    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!triggerEntry)
-    {
-        sLog.outError("Unit::HandleModDamagePctTakenAuraProc: Spell %u have not existed triggered spell %u",dummySpell->Id,triggered_spell_id);
-        return false;
-    }
-
-    // default case
-    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
-        return false;
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
-        return false;
-
-    if (basepoints0)
-        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-    else
-        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
-
-    return true;
-}
-
-// Used in case when access to whole aura is needed
-// All procs should be handled like this...
-bool Unit::HandleAuraProc(Unit * pVictim, uint32 damage, Aura * triggeredByAura, SpellEntry const * procSpell, uint32 /*procFlag*/, uint32 procEx, uint32 /*cooldown*/, bool * handled)
-{
-    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto();
-
-    switch(dummySpell->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-            switch (dummySpell->Id)
-            {
-                // Nevermelting Ice Crystal
-                case 71564:
-                    RemoveAuraFromStack(71564);
-                    *handled = true;
-                    break;
-            }
-            break;
-        case SPELLFAMILY_PALADIN:
-        {
-            // Infusion of Light
-            if (dummySpell->SpellIconID == 3021)
-            {
-                // Flash of Light HoT on Flash of Light when Sacred Shield active
-                if (procSpell->SpellFamilyFlags[0] & 0x40000000 && procSpell->SpellIconID == 242)
-                {
-                    *handled = true;
-                    if (pVictim->HasAura(53601))
-                    {
-                        int32 bp0 = (damage/12) * SpellMgr::CalculateSpellEffectAmount(dummySpell, 2)/100;
-                        CastCustomSpell(pVictim, 66922, &bp0, NULL, NULL, true);
-                        return true;
-                    }
-                }
-                // but should not proc on non-critical Holy Shocks
-                else if ((procSpell->SpellFamilyFlags[0] & 0x200000 || procSpell->SpellFamilyFlags[1] & 0x10000) && !(procEx & PROC_EX_CRITICAL_HIT))
-                    *handled = true;
-                break;
-            }
-            break;
-        }
-        case SPELLFAMILY_MAGE:
-        {
-            // Combustion
-            switch (dummySpell->Id)
-            {
-                case 11129:
-                {
-                    *handled = true;
-                    Unit *caster = triggeredByAura->GetCaster();
-                    if (!caster || !damage)
-                        return false;
-
-                    //last charge and crit
-                    if (triggeredByAura->GetCharges() <= 1 && (procEx & PROC_EX_CRITICAL_HIT))
-                    {
-                        RemoveAurasDueToSpell(28682);       //-> remove Combustion auras
-                        return true;                        // charge counting (will removed)
-                    }
-
-                    // This function can be called twice during one spell hit (Area of Effect spells)
-                    // Make sure 28682 wasn't already removed by previous call
-                    if (HasAura(28682))
-                        this->CastSpell(this, 28682, true);
-
-                    return false; // ordinary chrages will be removed during crit chance computations.
-                }
-                // Empowered Fire
-                case 31656:
-                case 31657:
-                case 31658:
-                {
-                    *handled = true;
-
-                    SpellEntry const *spInfo = sSpellStore.LookupEntry(67545);
-                    if (!spInfo)
-                        return false;
-
-                    int32 bp0 = this->GetCreateMana() * SpellMgr::CalculateSpellEffectAmount(spInfo, 0) / 100;
-                    this->CastCustomSpell(this, 67545, &bp0, NULL, NULL, true, NULL, triggeredByAura->GetEffect(0), this->GetGUID());
-                    return true;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Blood of the North
-            // Reaping
-            // Death Rune Mastery
-            if (dummySpell->SpellIconID == 3041 || dummySpell->SpellIconID == 22 || dummySpell->SpellIconID == 2622)
-            {
-                *handled = true;
-                // Convert recently used Blood Rune to Death Rune
-                if (GetTypeId() == TYPEID_PLAYER)
-                {
-                    if (this->ToPlayer()->getClass() != CLASS_DEATH_KNIGHT)
-                        return false;
-                    RuneType rune = this->ToPlayer()->GetLastUsedRune();
-                    // can't proc from death rune use
-                    if (rune == RUNE_DEATH)
-                        return false;
-                    AuraEffect * aurEff = triggeredByAura->GetEffect(0);
-                    if (!aurEff)
-                        return false;
-                    // Reset amplitude - set death rune remove timer to 30s
-                    aurEff->ResetPeriodic(true);
-                    uint32 runesLeft;
-
-                    if (dummySpell->SpellIconID == 2622)
-                        runesLeft = 2;
-                    else
-                        runesLeft = 1;
-
-                    for (uint8 i=0; i < MAX_RUNES && runesLeft; ++i)
-                    {
-                        if (dummySpell->SpellIconID == 2622)
-                        {
-                            if (((Player*)this)->GetCurrentRune(i) == RUNE_DEATH ||
-                                ((Player*)this)->GetBaseRune(i) == RUNE_BLOOD)
-                                continue;
-                        }
-                        else
-                        {
-                            if (((Player*)this)->GetCurrentRune(i) == RUNE_DEATH ||
-                                ((Player*)this)->GetBaseRune(i) != RUNE_BLOOD)
-                                continue;
-                        }
-                        if (((Player*)this)->GetRuneCooldown(i) != ((Player*)this)->GetRuneBaseCooldown(i))
-                            continue;
-
-                        --runesLeft;
-                        // Mark aura as used
-                        ((Player*)this)->AddRuneByAuraEffect(i, RUNE_DEATH, aurEff);
-                    }
-                    return true;
-                }
-                return false;
-            }
-
-            switch(dummySpell->Id)
-            {
-                // Hungering Cold aura drop
-                case 51209:
-                    *handled = true;
-                    // Drop only in not disease case
-                    if (procSpell && procSpell->Dispel == DISPEL_DISEASE)
-                        return false;
-                    return true;
-            }
-            break;
-        }
-    }
-    return false;
-}
-
-bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, AuraEffect* triggeredByAura, SpellEntry const *procSpell, uint32 procFlags, uint32 procEx, uint32 cooldown)
-{
-    // Get triggered aura spell info
-    SpellEntry const* auraSpellInfo = triggeredByAura->GetSpellProto();
-
-    // Basepoints of trigger aura
-    int32 triggerAmount = triggeredByAura->GetAmount();
-
-    // Set trigger spell id, target, custom basepoints
-    uint32 trigger_spell_id = auraSpellInfo->EffectTriggerSpell[triggeredByAura->GetEffIndex()];
-
-    Unit*  target = NULL;
-    int32  basepoints0 = 0;
-
-    if (triggeredByAura->GetAuraType() == SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE)
-        basepoints0 = triggerAmount;
-
-    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
-        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
-
-    // Try handle unknown trigger spells
-    if (sSpellStore.LookupEntry(trigger_spell_id) == NULL)
-    {
-        switch (auraSpellInfo->SpellFamilyName)
-        {
-            case SPELLFAMILY_GENERIC:
-                switch (auraSpellInfo->Id)
-                {
-                    case 23780:             // Aegis of Preservation (Aegis of Preservation trinket)
-                        trigger_spell_id = 23781;
-                        break;
-                    case 33896:             // Desperate Defense (Stonescythe Whelp, Stonescythe Alpha, Stonescythe Ambusher)
-                        trigger_spell_id = 33898;
-                        break;
-                    case 43820:             // Charm of the Witch Doctor (Amani Charm of the Witch Doctor trinket)
-                        // Pct value stored in dummy
-                        basepoints0 = pVictim->GetCreateHealth() * SpellMgr::CalculateSpellEffectAmount(auraSpellInfo, 1) / 100;
-                        target = pVictim;
-                        break;
-                    case 57345:             // Darkmoon Card: Greatness
-                    {
-                        float stat = 0.0f;
-                        // strength
-                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 60229;stat = GetStat(STAT_STRENGTH); }
-                        // agility
-                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 60233;stat = GetStat(STAT_AGILITY);  }
-                        // intellect
-                        if (GetStat(STAT_INTELLECT)> stat) { trigger_spell_id = 60234;stat = GetStat(STAT_INTELLECT);}
-                        // spirit
-                        if (GetStat(STAT_SPIRIT)   > stat) { trigger_spell_id = 60235;                               }
-                        break;
-                    }
-                    case 67702:             // Death's Choice, Item - Coliseum 25 Normal Melee Trinket
-                    {
-                        float stat = 0.0f;
-                        // strength
-                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67708;stat = GetStat(STAT_STRENGTH); }
-                        // agility
-                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67703;                               }
-                        break;
-                    }
-                    case 67771:             // Death's Choice (heroic), Item - Coliseum 25 Heroic Melee Trinket
-                    {
-                        float stat = 0.0f;
-                        // strength
-                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67773;stat = GetStat(STAT_STRENGTH); }
-                        // agility
-                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67772;                               }
-                        break;
-                    }
-                    // Mana Drain Trigger
-                    case 27522:
-                    case 40336:
-                    {
-                        // On successful melee or ranged attack gain $29471s1 mana and if possible drain $27526s1 mana from the target.
-                        if (this && this->isAlive())
-                            CastSpell(this, 29471, true, castItem, triggeredByAura);
-                        if (pVictim && pVictim->isAlive())
-                            CastSpell(pVictim, 27526, true, castItem, triggeredByAura);
-                        return true;
-                    }
-                }
-                break;
-            case SPELLFAMILY_MAGE:
-                if (auraSpellInfo->SpellIconID == 2127)     // Blazing Speed
-                {
-                    switch (auraSpellInfo->Id)
-                    {
-                        case 31641:  // Rank 1
-                        case 31642:  // Rank 2
-                            trigger_spell_id = 31643;
-                            break;
-                        default:
-                            sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Blazing Speed",auraSpellInfo->Id);
-                            return false;
-                    }
-                }
-                break;
-            case SPELLFAMILY_WARRIOR:
-                if (auraSpellInfo->Id == 50421)             // Scent of Blood
-                    trigger_spell_id = 50422;
-                break;
-            case SPELLFAMILY_WARLOCK:
-            {
-                // Drain Soul
-                if (auraSpellInfo->SpellFamilyFlags[0] & 0x4000)
-                {
-                    // Improved Drain Soul
-                    Unit::AuraEffectList const& mAddFlatModifier = GetAuraEffectsByType(SPELL_AURA_DUMMY);
-                    for (Unit::AuraEffectList::const_iterator i = mAddFlatModifier.begin(); i != mAddFlatModifier.end(); ++i)
-                    {
-                        if ((*i)->GetMiscValue() == SPELLMOD_CHANCE_OF_SUCCESS && (*i)->GetSpellProto()->SpellIconID == 113)
-                        {
-                            int32 value2 = CalculateSpellDamage(this, (*i)->GetSpellProto(),2);
-                            basepoints0 = value2 * GetMaxPower(POWER_MANA) / 100;
-                            // Drain Soul
-                            CastCustomSpell(this, 18371, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
-                            break;
-                        }
-                    }
-                    // Not remove charge (aura removed on death in any cases)
-                    // Need for correct work Drain Soul SPELL_AURA_CHANNEL_DEATH_ITEM aura
-                    return false;
-                }
-                // Nether Protection
-                else if (auraSpellInfo->SpellIconID == 1985)
-                {
-                    if (!procSpell)
-                        return false;
-                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
-                    {
-                        case SPELL_SCHOOL_NORMAL:
-                            return false;                   // ignore
-                        case SPELL_SCHOOL_HOLY:   trigger_spell_id = 54370; break;
-                        case SPELL_SCHOOL_FIRE:   trigger_spell_id = 54371; break;
-                        case SPELL_SCHOOL_NATURE: trigger_spell_id = 54375; break;
-                        case SPELL_SCHOOL_FROST:  trigger_spell_id = 54372; break;
-                        case SPELL_SCHOOL_SHADOW: trigger_spell_id = 54374; break;
-                        case SPELL_SCHOOL_ARCANE: trigger_spell_id = 54373; break;
-                        default:
-                            return false;
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_PRIEST:
-            {
-                // Greater Heal Refund
-                if (auraSpellInfo->Id == 37594)
-                    trigger_spell_id = 37595;
-                // Blessed Recovery
-                else if (auraSpellInfo->SpellIconID == 1875)
-                {
-                    switch (auraSpellInfo->Id)
-                    {
-                        case 27811: trigger_spell_id = 27813; break;
-                        case 27815: trigger_spell_id = 27817; break;
-                        case 27816: trigger_spell_id = 27818; break;
-                        default:
-                            sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in BR", auraSpellInfo->Id);
-                        return false;
-                    }
-                    basepoints0 = damage * triggerAmount / 100 / 3;
-                    target = this;
-                }
-                break;
-            }
-            case SPELLFAMILY_DRUID:
-            {
-                // Druid Forms Trinket
-                if (auraSpellInfo->Id == 37336)
-                {
-                    switch(m_form)
-                    {
-                        case FORM_NONE:     trigger_spell_id = 37344;break;
-                        case FORM_CAT:      trigger_spell_id = 37341;break;
-                        case FORM_BEAR:
-                        case FORM_DIREBEAR: trigger_spell_id = 37340;break;
-                        case FORM_TREE:     trigger_spell_id = 37342;break;
-                        case FORM_MOONKIN:  trigger_spell_id = 37343;break;
-                        default:
-                            return false;
-                    }
-                }
-                // Druid T9 Feral Relic (Lacerate, Swipe, Mangle, and Shred)
-                else if (auraSpellInfo->Id == 67353)
-                {
-                    switch(m_form)
-                    {
-                        case FORM_CAT:      trigger_spell_id = 67355; break;
-                        case FORM_BEAR:
-                        case FORM_DIREBEAR: trigger_spell_id = 67354; break;
-                        default:
-                            return false;
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_HUNTER:
-            {
-                if (auraSpellInfo->SpellIconID == 3247)     // Piercing Shots
-                {
-                    switch (auraSpellInfo->Id)
-                    {
-                        case 53234:  // Rank 1
-                        case 53237:  // Rank 2
-                        case 53238:  // Rank 3
-                            trigger_spell_id = 63468;
-                            break;
-                        default:
-                            sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Piercing Shots",auraSpellInfo->Id);
-                            return false;
-                    }
-                    SpellEntry const *TriggerPS = sSpellStore.LookupEntry(trigger_spell_id);
-                    if (!TriggerPS)
-                        return false;
-
-                    basepoints0 = int32(damage * triggerAmount / 100 / (GetSpellMaxDuration(TriggerPS) / TriggerPS->EffectAmplitude[0]));
-                    basepoints0 += pVictim->GetRemainingDotDamage(GetGUID(), trigger_spell_id);
-                    break;
-                }
-                break;
-            }
-            case SPELLFAMILY_PALADIN:
-            {
-                switch (auraSpellInfo->Id)
-                {
-                    // Healing Discount
-                    case 37705:
-                    {
-                        trigger_spell_id = 37706;
-                        target = this;
-                        break;
-                    }
-                    // Soul Preserver
-                    case 60510:
-                    {
-                        trigger_spell_id = 60515;
-                        target = this;
-                        break;
-                    }
-                    // Lightning Capacitor
-                    case 37657:
-                    {
-                        if (!pVictim || !pVictim->isAlive())
-                            return false;
-                        // stacking
-                        CastSpell(this, 37658, true, NULL, triggeredByAura);
-
-                        Aura * dummy = GetAura(37658);
-                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
-                        if (!dummy || dummy->GetStackAmount() < triggerAmount)
-                            return false;
-
-                        RemoveAurasDueToSpell(37658);
-                        trigger_spell_id = 37661;
-                        target = pVictim;
-                        break;
-                    }
-                    // Thunder Capacitor
-                    case 54841:
-                    {
-                        if (!pVictim || !pVictim->isAlive())
-                            return false;
-                        // stacking
-                        CastSpell(this, 54842, true, NULL, triggeredByAura);
-
-                        // counting
-                        Aura * dummy = GetAura(54842);
-                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
-                        if (!dummy || dummy->GetStackAmount() < triggerAmount)
-                            return false;
-
-                        RemoveAurasDueToSpell(54842);
-                        trigger_spell_id = 54843;
-                        target = pVictim;
-                        break;
-                    }
-                    //Item - Coliseum 25 Normal Caster Trinket
-                    case 67712:
-                    {
-                        if(!pVictim || !pVictim->isAlive())
-                            return false;
-                        // stacking
-                        CastSpell(this, 67713, true, NULL, triggeredByAura);
-
-                        Aura * dummy = GetAura(67713);
-                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
-                        if(!dummy || dummy->GetStackAmount() < triggerAmount)
-                            return false;
-
-                        RemoveAurasDueToSpell(67713);
-                        trigger_spell_id = 67714;
-                        target = pVictim;
-                        break;
-                    }
-                    //Item - Coliseum 25 Heroic Caster Trinket
-                    case 67758:
-                    {
-                        if(!pVictim || !pVictim->isAlive())
-                            return false;
-                        // stacking
-                        CastSpell(this, 67759, true, NULL, triggeredByAura);
-
-                        Aura * dummy = GetAura(67759);
-                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
-                        if(!dummy || dummy->GetStackAmount() < triggerAmount)
-                            return false;
-
-                        RemoveAurasDueToSpell(67759);
-                        trigger_spell_id = 67760;
-                        target = pVictim;
-                        break;
-                    }
-                    default:
-                        // Illumination
-                        if (auraSpellInfo->SpellIconID == 241)
-                        {
-                            if (!procSpell)
-                                return false;
-                            // procspell is triggered spell but we need mana cost of original casted spell
-                            uint32 originalSpellId = procSpell->Id;
-                            // Holy Shock heal
-                            if (procSpell->SpellFamilyFlags[1] & 0x00010000)
-                            {
-                                switch(procSpell->Id)
-                                {
-                                    case 25914: originalSpellId = 20473; break;
-                                    case 25913: originalSpellId = 20929; break;
-                                    case 25903: originalSpellId = 20930; break;
-                                    case 27175: originalSpellId = 27174; break;
-                                    case 33074: originalSpellId = 33072; break;
-                                    case 48820: originalSpellId = 48824; break;
-                                    case 48821: originalSpellId = 48825; break;
-                                    default:
-                                        sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in HShock",procSpell->Id);
-                                       return false;
-                                }
-                            }
-                            SpellEntry const *originalSpell = sSpellStore.LookupEntry(originalSpellId);
-                            if (!originalSpell)
-                            {
-                                sLog.outError("Unit::HandleProcTriggerSpell: Spell %u unknown but selected as original in Illu",originalSpellId);
-                                return false;
-                            }
-                            // percent stored in effect 1 (class scripts) base points
-                            int32 cost = originalSpell->manaCost + originalSpell->ManaCostPercentage * GetCreateMana() / 100;
-                            basepoints0 = cost*SpellMgr::CalculateSpellEffectAmount(auraSpellInfo, 1)/100;
-                            trigger_spell_id = 20272;
-                            target = this;
-                        }
-                        break;
-                }
-                break;
-            }
-            case SPELLFAMILY_SHAMAN:
-            {
-                switch (auraSpellInfo->Id)
-                {
-                    // Lightning Shield (The Ten Storms set)
-                    case 23551:
-                    {
-                        trigger_spell_id = 23552;
-                        target = pVictim;
-                        break;
-                    }
-                    // Damage from Lightning Shield (The Ten Storms set)
-                    case 23552:
-                    {
-                        trigger_spell_id = 27635;
-                        break;
-                    }
-                    // Mana Surge (The Earthfury set)
-                    case 23572:
-                    {
-                        if (!procSpell)
-                            return false;
-                        basepoints0 = procSpell->manaCost * 35 / 100;
-                        trigger_spell_id = 23571;
-                        target = this;
-                        break;
-                    }
-                    default:
-                    {
-                        // Lightning Shield (overwrite non existing triggered spell call in spell.dbc
-                        if (auraSpellInfo->SpellFamilyFlags[0] & 0x400)
-                        {
-                            trigger_spell_id = sSpellMgr.GetSpellWithRank(26364, sSpellMgr.GetSpellRank(auraSpellInfo->Id));
-                        }
-                        // Nature's Guardian
-                        else if (auraSpellInfo->SpellIconID == 2013)
-                        {
-                            // Check health condition - should drop to less 30% (damage deal after this!)
-                            if (!HealthBelowPctDamaged(30, damage))
-                                return false;
-
-                             if (pVictim && pVictim->isAlive())
-                                 pVictim->getThreatManager().modifyThreatPercent(this,-10);
-
-                            basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
-                            trigger_spell_id = 31616;
-                            target = this;
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_DEATHKNIGHT:
-            {
-                // Acclimation
-                if (auraSpellInfo->SpellIconID == 1930)
-                {
-                    if (!procSpell)
-                        return false;
-                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
-                    {
-                        case SPELL_SCHOOL_NORMAL:
-                            return false;                   // ignore
-                        case SPELL_SCHOOL_HOLY:   trigger_spell_id = 50490; break;
-                        case SPELL_SCHOOL_FIRE:   trigger_spell_id = 50362; break;
-                        case SPELL_SCHOOL_NATURE: trigger_spell_id = 50488; break;
-                        case SPELL_SCHOOL_FROST:  trigger_spell_id = 50485; break;
-                        case SPELL_SCHOOL_SHADOW: trigger_spell_id = 50489; break;
-                        case SPELL_SCHOOL_ARCANE: trigger_spell_id = 50486; break;
-                        default:
-                            return false;
-                    }
-                }
-                // Blood Presence (Improved)
-                else if (auraSpellInfo->Id == 63611)
-                {
-                    if (GetTypeId() != TYPEID_PLAYER)
-                        return false;
-
-                    trigger_spell_id = 50475;
-                    basepoints0 = damage * triggerAmount / 100;
-                }
-                break;
-            }
-            default:
-                 break;
-        }
-    }
-
-    // All ok. Check current trigger spell
-    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(trigger_spell_id);
-    if (triggerEntry == NULL)
-    {
-        // Not cast unknown spell
-        // sLog.outError("Unit::HandleProcTriggerSpell: Spell %u have 0 in EffectTriggered[%d], not handled custom case?",auraSpellInfo->Id,triggeredByAura->GetEffIndex());
-        return false;
-    }
-
-    // not allow proc extra attack spell at extra attack
-    if (m_extraAttacks && IsSpellHaveEffect(triggerEntry, SPELL_EFFECT_ADD_EXTRA_ATTACKS))
-        return false;
-
-    // Custom requirements (not listed in procEx) Warning! damage dealing after this
-    // Custom triggered spells
-    switch (auraSpellInfo->Id)
-    {
-        // Persistent Shield (Scarab Brooch trinket)
-        // This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)
-        case 26467:
-        {
-            basepoints0 = damage * 15 / 100;
-            target = pVictim;
-            trigger_spell_id = 26470;
-            break;
-        }
-        // Unyielding Knights (item exploit 29108\29109)
-        case 38164:
-        {
-            if (!pVictim || pVictim->GetEntry() != 19457)  // Proc only if your target is Grillok
-                return false;
-            break;
-        }
-        // Deflection
-        case 52420:
-        {
-            if (!HealthBelowPct(35))
-                return false;
-            break;
-        }
-
-        // Cheat Death
-        case 28845:
-        {
-            // When your health drops below 20%
-            if (HealthBelowPctDamaged(20, damage) || HealthBelowPct(20))
-                return false;
-            break;
-        }
-        // Deadly Swiftness (Rank 1)
-        case 31255:
-        {
-            // whenever you deal damage to a target who is below 20% health.
-            if (!pVictim || !pVictim->isAlive() || pVictim->HealthAbovePct(20))
-                return false;
-
-            target = this;
-            trigger_spell_id = 22588;
-        }
-        // Greater Heal Refund (Avatar Raiment set)
-        case 37594:
-        {
-            if (!pVictim || !pVictim->isAlive())
-                return false;
-
-            // Not give if target already have full health
-            if (pVictim->IsFullHealth())
-                return false;
-            // If your Greater Heal brings the target to full health, you gain $37595s1 mana.
-            if (pVictim->GetHealth() + damage < pVictim->GetMaxHealth())
-                return false;
-            break;
-        }
-        // Bonus Healing (Crystal Spire of Karabor mace)
-        case 40971:
-        {
-            // If your target is below $s1% health
-            if (!pVictim || !pVictim->isAlive() || pVictim->HealthAbovePct(triggerAmount))
-                return false;
-            break;
-        }
-        // Evasive Maneuvers (Commendation of Kael`thas trinket)
-        case 45057:
-        {
-            // reduce you below $s1% health
-            if (GetHealth() - damage > GetMaxHealth() * triggerAmount / 100)
-                return false;
-            break;
-        }
-        // Rapid Recuperation
-        case 53228:
-        case 53232:
-        {
-            // This effect only from Rapid Fire (ability cast)
-            if (!(procSpell->SpellFamilyFlags[0] & 0x20))
-                return false;
-            break;
-        }
-        // Blessing of Ancient Kings (Val'anyr, Hammer of Ancient Kings)
-        case 64411:
-        {
-            basepoints0 = damage * 15 / 100;
-            target = pVictim;
-            trigger_spell_id = 64413;
-            break;
-        }
-        // Decimation
-        case 63156:
-        case 63158:
-            // Can proc only if target has hp below 35%
-            if (!pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, procSpell, this))
-                return false;
-            break;
-        // Deathbringer Saurfang - Rune of Blood
-        case 72408:
-            // can proc only if target is marked with rune
-            if (!pVictim->HasAura(72410))
-                return false;
-            break;
-        // Deathbringer Saurfang - Blood Beast's Blood Link
-        case 72176:
-            basepoints0 = 3;
-            break;
-    }
-
-    // Blade Barrier
-    if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 85)
-    {
-        Player * plr = this->ToPlayer();
-        if (this->GetTypeId() != TYPEID_PLAYER || !plr || plr->getClass() != CLASS_DEATH_KNIGHT)
-            return false;
-
-        if (!plr->IsBaseRuneSlotsOnCooldown(RUNE_BLOOD))
-            return false;
-    }
-
-    // Rime
-    else if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 56)
-    {
-        if (GetTypeId() != TYPEID_PLAYER)
-            return false;
-
-        // Howling Blast
-        this->ToPlayer()->RemoveSpellCategoryCooldown(1248, true);
-    }
-
-    // Custom basepoints/target for exist spell
-    // dummy basepoints or other customs
-    switch(trigger_spell_id)
-    {
-        // Auras which should proc on area aura source (caster in this case):
-        // Turn the Tables
-        case 52914:
-        case 52915:
-        case 52910:
-        // Honor Among Thieves
-        case 52916:
-        {
-            target = triggeredByAura->GetBase()->GetCaster();
-            if (!target)
-                return false;
-
-            if (cooldown && target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->HasSpellCooldown(trigger_spell_id))
-                return false;
-
-            target->CastSpell(target,trigger_spell_id,true,castItem,triggeredByAura);
-
-            if (cooldown && GetTypeId() == TYPEID_PLAYER)
-                this->ToPlayer()->AddSpellCooldown(trigger_spell_id,0,time(NULL) + cooldown);
-            return true;
-        }
-        // Cast positive spell on enemy target
-        case 7099:  // Curse of Mending
-        case 39647: // Curse of Mending
-        case 29494: // Temptation
-        case 20233: // Improved Lay on Hands (cast on target)
-        {
-            target = pVictim;
-            break;
-        }
-        // Combo points add triggers (need add combopoint only for main target, and after possible combopoints reset)
-        case 15250: // Rogue Setup
-        {
-            if (!pVictim || pVictim != getVictim())   // applied only for main target
-                return false;
-            break;                                   // continue normal case
-        }
-        // Finish movies that add combo
-        case 14189: // Seal Fate (Netherblade set)
-        case 14157: // Ruthlessness
-        {
-            if (!pVictim || pVictim == this)
-                return false;
-            // Need add combopoint AFTER finish movie (or they dropped in finish phase)
-            break;
-        }
-        // Bloodthirst (($m/100)% of max health)
-        case 23880:
-        {
-            basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
-            break;
-        }
-        // Shamanistic Rage triggered spell
-        case 30824:
-        {
-            basepoints0 = int32(GetTotalAttackPowerValue(BASE_ATTACK) * triggerAmount / 100);
-            break;
-        }
-        // Enlightenment (trigger only from mana cost spells)
-        case 35095:
-        {
-            if (!procSpell || procSpell->powerType != POWER_MANA || (procSpell->manaCost == 0 && procSpell->ManaCostPercentage == 0 && procSpell->manaCostPerlevel == 0))
-                return false;
-            break;
-        }
-        // Demonic Pact
-        case 48090:
-        {
-            // Get talent aura from owner
-            if (isPet())
-                if (Unit * owner = GetOwner())
-                {
-                    if (AuraEffect * aurEff = owner->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 3220, 0))
-                    {
-                        basepoints0 = int32((aurEff->GetAmount() * owner->SpellBaseDamageBonus(SpellSchoolMask(SPELL_SCHOOL_MASK_MAGIC)) + 100.0f) / 100.0f);
-                        CastCustomSpell(this,trigger_spell_id,&basepoints0,&basepoints0,NULL,true,castItem,triggeredByAura);
-                        return true;
-                    }
-                }
-            break;
-        }
-        // Sword and Board
-        case 50227:
-        {
-            // Remove cooldown on Shield Slam
-            if (GetTypeId() == TYPEID_PLAYER)
-                this->ToPlayer()->RemoveSpellCategoryCooldown(1209, true);
-            break;
-        }
-        // Maelstrom Weapon
-        case 53817:
-        {
-            // have rank dependent proc chance, ignore too often cases
-            // PPM = 2.5 * (rank of talent),
-            uint32 rank = sSpellMgr.GetSpellRank(auraSpellInfo->Id);
-            // 5 rank -> 100% 4 rank -> 80% and etc from full rate
-            if (!roll_chance_i(20*rank))
-                return false;
-            break;
-        }
-        // Astral Shift
-        case 52179:
-        {
-            if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == pVictim)
-                return false;
-
-            // Need stun, fear or silence mechanic
-            if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_SILENCE)|(1<<MECHANIC_STUN)|(1<<MECHANIC_FEAR))))
-                return false;
-            break;
-        }
-        // Burning Determination
-        case 54748:
-        {
-            if (!procSpell)
-                return false;
-            // Need Interrupt or Silenced mechanic
-            if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_INTERRUPT)|(1<<MECHANIC_SILENCE))))
-                return false;
-            break;
-        }
-        // Lock and Load
-        case 56453:
-        {
-            // Proc only from Frost/Freezing trap activation or from Freezing Arrow (the periodic dmg proc handled elsewhere)
-            if (!(procFlags & PROC_FLAG_DONE_TRAP_ACTIVATION) || !procSpell || !(procSpell->SchoolMask & SPELL_SCHOOL_MASK_FROST) || !roll_chance_i(triggerAmount))
-                return false;
-            break;
-        }
-        // Glyph of Death's Embrace
-        case 58679:
-        {
-            // Proc only from healing part of Death Coil. Check is essential as all Death Coil spells have 0x2000 mask in SpellFamilyFlags
-            if (!procSpell || !(procSpell->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && procSpell->SpellFamilyFlags[0] == 0x80002000))
-                return false;
-            break;
-        }
-        // Glyph of Death Grip
-        case 58628:
-        {
-            // remove cooldown of Death Grip
-            if (GetTypeId() == TYPEID_PLAYER)
-                this->ToPlayer()->RemoveCategoryCooldown(82);
-            return true;
-        }
-        // Savage Defense
-        case 62606:
-        {
-            basepoints0 = int32(GetTotalAttackPowerValue(BASE_ATTACK) * triggerAmount / 100.0f);
-            break;
-        }
-        // Body and Soul
-        case 64128:
-        case 65081:
-        {
-            // Proc only from PW:S cast
-            if (!(procSpell->SpellFamilyFlags[0] & 0x00000001))
-                return false;
-            break;
-        }
-        // Deathbringer Saurfang - Blood Link
-        case 72202:
-            target = FindNearestCreature(37813, 75.0f); // NPC_DEATHBRINGER_SAURFANG = 37813
-            break;
-        // Shadow's Fate (Shadowmourne questline)
-        case 71169:
-            if (GetTypeId() != TYPEID_PLAYER)
-                return false;
-            if (ToPlayer()->GetQuestStatus(24547) != QUEST_STATUS_INCOMPLETE)   // A Feast of Souls
-                return false;
-            if (pVictim->GetTypeId() != TYPEID_UNIT)
-                return false;
-            // critters are not allowed
-            if (pVictim->GetCreatureType() == CREATURE_TYPE_CRITTER)
-                return false;
-            break;
-    }
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(trigger_spell_id))
-        return false;
-
-    // try detect target manually if not set
-    if (target == NULL)
-       target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && IsPositiveSpell(trigger_spell_id) ? this : pVictim;
-
-    // default case
-    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
-        return false;
-
-    if (basepoints0)
-        CastCustomSpell(target,trigger_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
-    else
-        CastSpell(target,trigger_spell_id,true,castItem,triggeredByAura);
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER)
-        ToPlayer()->AddSpellCooldown(trigger_spell_id,0,time(NULL) + cooldown);
-
-    return true;
-}
-
-bool Unit::HandleOverrideClassScriptAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect *triggeredByAura, SpellEntry const *procSpell, uint32 cooldown)
-{
-    int32 scriptId = triggeredByAura->GetMiscValue();
-
-    if (!pVictim || !pVictim->isAlive())
-        return false;
-
-    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
-        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
-
-    uint32 triggered_spell_id = 0;
-
-    switch(scriptId)
-    {
-        case 836:                                           // Improved Blizzard (Rank 1)
-        {
-            if (!procSpell || procSpell->SpellVisual[0] != 9487)
-                return false;
-            triggered_spell_id = 12484;
-            break;
-        }
-        case 988:                                           // Improved Blizzard (Rank 2)
-        {
-            if (!procSpell || procSpell->SpellVisual[0] != 9487)
-                return false;
-            triggered_spell_id = 12485;
-            break;
-        }
-        case 989:                                           // Improved Blizzard (Rank 3)
-        {
-            if (!procSpell || procSpell->SpellVisual[0] != 9487)
-                return false;
-            triggered_spell_id = 12486;
-            break;
-        }
-        case 4533:                                          // Dreamwalker Raiment 2 pieces bonus
-        {
-            // Chance 50%
-            if (!roll_chance_i(50))
-                return false;
-
-            switch (pVictim->getPowerType())
-            {
-                case POWER_MANA:   triggered_spell_id = 28722; break;
-                case POWER_RAGE:   triggered_spell_id = 28723; break;
-                case POWER_ENERGY: triggered_spell_id = 28724; break;
-                default:
-                    return false;
-            }
-            break;
-        }
-        case 4537:                                          // Dreamwalker Raiment 6 pieces bonus
-            triggered_spell_id = 28750;                     // Blessing of the Claw
-            break;
-        case 5497:                                          // Improved Mana Gems
-            triggered_spell_id = 37445;                     // Mana Surge
-            break;
-        case 7010:  // Revitalize - can proc on full hp target
-        case 7011:
-        case 7012:
-        {
-            if (!roll_chance_i(triggeredByAura->GetAmount()))
-                return false;
-            switch(pVictim->getPowerType())
-            {
-                case POWER_MANA:   triggered_spell_id = 48542; break;
-                case POWER_RAGE:   triggered_spell_id = 48541; break;
-                case POWER_ENERGY: triggered_spell_id = 48540; break;
-                case POWER_RUNIC_POWER: triggered_spell_id = 48543; break;
-                default:
-                    break;
-            }
-            break;
-        }
-        default:
-            break;
-    }
-
-    // not processed
-    if (!triggered_spell_id)
-        return false;
-
-    // standard non-dummy case
-    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!triggerEntry)
-    {
-        sLog.outError("Unit::HandleOverrideClassScriptAuraProc: Spell %u triggering for class script id %u",triggered_spell_id,scriptId);
-        return false;
-    }
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
-        return false;
-
-    CastSpell(pVictim, triggered_spell_id, true, castItem, triggeredByAura);
-
-    if (cooldown && GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
-
-    return true;
-}
-
-void Unit::setPowerType(Powers new_powertype)
-{
-    SetByteValue(UNIT_FIELD_BYTES_0, 3, new_powertype);
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (this->ToPlayer()->GetGroup())
-            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POWER_TYPE);
-    }
-    else if (this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_POWER_TYPE);
-        }
-    }
-
-    switch(new_powertype)
-    {
-        default:
-        case POWER_MANA:
-            break;
-        case POWER_RAGE:
-            SetMaxPower(POWER_RAGE, GetCreatePowers(POWER_RAGE));
-            SetPower(POWER_RAGE, 0);
-            break;
-        case POWER_FOCUS:
-            SetMaxPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
-            SetPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
-            break;
-        case POWER_ENERGY:
-            SetMaxPower(POWER_ENERGY, GetCreatePowers(POWER_ENERGY));
-            break;
-        case POWER_HAPPINESS:
-            SetMaxPower(POWER_HAPPINESS, GetCreatePowers(POWER_HAPPINESS));
-            SetPower(POWER_HAPPINESS, GetCreatePowers(POWER_HAPPINESS));
-            break;
-    }
-}
-
-FactionTemplateEntry const* Unit::getFactionTemplateEntry() const
-{
-    FactionTemplateEntry const* entry = sFactionTemplateStore.LookupEntry(getFaction());
-    if (!entry)
-    {
-        static uint64 guid = 0;                             // prevent repeating spam same faction problem
-
-        if (GetGUID() != guid)
-        {
-            if (const Player *player = ToPlayer())
-                sLog.outError("Player %s has invalid faction (faction template id) #%u", player->GetName(), getFaction());
-            else if (const Creature *creature = ToCreature())
-                sLog.outError("Creature (template id: %u) has invalid faction (faction template id) #%u", creature->GetCreatureInfo()->Entry, getFaction());
-            else
-                sLog.outError("Unit (name=%s, type=%u) has invalid faction (faction template id) #%u", GetName(), uint32(GetTypeId()), getFaction());
-
-            guid = GetGUID();
-        }
-    }
-    return entry;
-}
-
-bool Unit::IsHostileTo(Unit const* unit) const
-{
-    if (!unit)
-        return false;
-    // always non-hostile to self
-    if (unit == this)
-        return false;
-
-    // always non-hostile to GM in GM mode
-    if (unit->GetTypeId() == TYPEID_PLAYER && ((Player const*)unit)->isGameMaster())
-        return false;
-
-    // always hostile to enemy
-    if (getVictim() == unit || unit->getVictim() == this)
-        return true;
-
-    // test pet/charm masters instead pers/charmeds
-    Unit const* testerOwner = GetCharmerOrOwner();
-    Unit const* targetOwner = unit->GetCharmerOrOwner();
-
-    // always hostile to owner's enemy
-    if (testerOwner && (testerOwner->getVictim() == unit || unit->getVictim() == testerOwner))
-        return true;
-
-    // always hostile to enemy owner
-    if (targetOwner && (getVictim() == targetOwner || targetOwner->getVictim() == this))
-        return true;
-
-    // always hostile to owner of owner's enemy
-    if (testerOwner && targetOwner && (testerOwner->getVictim() == targetOwner || targetOwner->getVictim() == testerOwner))
-        return true;
-
-    Unit const* tester = testerOwner ? testerOwner : this;
-    Unit const* target = targetOwner ? targetOwner : unit;
-
-    // always non-hostile to target with common owner, or to owner/pet
-    if (tester == target)
-        return false;
-
-    // special cases (Duel, etc)
-    if (tester->GetTypeId() == TYPEID_PLAYER && target->GetTypeId() == TYPEID_PLAYER)
-    {
-        Player const* pTester = (Player const*)tester;
-        Player const* pTarget = (Player const*)target;
-
-        // Duel
-        if (pTester->duel && pTester->duel->opponent == pTarget && pTester->duel->startTime != 0)
-            return true;
-
-        // Group
-        if (pTester->GetGroup() && pTester->GetGroup() == pTarget->GetGroup())
-            return false;
-
-        // Sanctuary
-        if (pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY) && pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY))
-            return false;
-
-        // PvP FFA state
-        if (pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) && pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
-            return true;
-
-        //= PvP states
-        // Green/Blue (can't attack)
-        if (!pTester->HasAuraType(SPELL_AURA_MOD_FACTION) && !pTarget->HasAuraType(SPELL_AURA_MOD_FACTION))
-        {
-            if (pTester->GetTeam() == pTarget->GetTeam())
-                return false;
-
-            // Red (can attack) if true, Blue/Yellow (can't attack) in another case
-            return pTester->IsPvP() && pTarget->IsPvP();
-        }
-    }
-
-    // faction base cases
-    FactionTemplateEntry const*tester_faction = tester->getFactionTemplateEntry();
-    FactionTemplateEntry const*target_faction = target->getFactionTemplateEntry();
-    if (!tester_faction || !target_faction)
-        return false;
-
-    if (target->isAttackingPlayer() && tester->IsContestedGuard())
-        return true;
-
-    // PvC forced reaction and reputation case
-    if (tester->GetTypeId() == TYPEID_PLAYER && !tester->HasAuraType(SPELL_AURA_MOD_FACTION))
-    {
-        // forced reaction
-        if (target_faction->faction)
-        {
-            if (ReputationRank const* force =tester->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(target_faction))
-                return *force <= REP_HOSTILE;
-
-            // if faction have reputation then hostile state for tester at 100% dependent from at_war state
-            if (FactionEntry const* raw_target_faction = sFactionStore.LookupEntry(target_faction->faction))
-                if (FactionState const* factionState = tester->ToPlayer()->GetReputationMgr().GetState(raw_target_faction))
-                    return (factionState->Flags & FACTION_FLAG_AT_WAR);
-        }
-    }
-    // CvP forced reaction and reputation case
-    else if (target->GetTypeId() == TYPEID_PLAYER && !target->HasAuraType(SPELL_AURA_MOD_FACTION))
-    {
-        // forced reaction
-        if (tester_faction->faction)
-        {
-            if (ReputationRank const* force = target->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(tester_faction))
-                return *force <= REP_HOSTILE;
-
-            // apply reputation state
-            FactionEntry const* raw_tester_faction = sFactionStore.LookupEntry(tester_faction->faction);
-            if (raw_tester_faction && raw_tester_faction->reputationListID >=0)
-                return ((Player const*)target)->GetReputationMgr().GetRank(raw_tester_faction) <= REP_HOSTILE;
-        }
-    }
-
-    // common faction based case (CvC,PvC,CvP)
-    return tester_faction->IsHostileTo(*target_faction);
-}
-
-bool Unit::IsFriendlyTo(Unit const* unit) const
-{
-    // always friendly to self
-    if (unit == this)
-        return true;
-
-    // always friendly to GM in GM mode
-    if (unit->GetTypeId() == TYPEID_PLAYER && ((Player const*)unit)->isGameMaster())
-        return true;
-
-    // always non-friendly to enemy
-    if (getVictim() == unit || unit->getVictim() == this)
-        return false;
-
-    // test pet/charm masters instead pers/charmeds
-    Unit const* testerOwner = GetCharmerOrOwner();
-    Unit const* targetOwner = unit->GetCharmerOrOwner();
-
-    // always non-friendly to owner's enemy
-    if (testerOwner && (testerOwner->getVictim() == unit || unit->getVictim() == testerOwner))
-        return false;
-
-    // always non-friendly to enemy owner
-    if (targetOwner && (getVictim() == targetOwner || targetOwner->getVictim() == this))
-        return false;
-
-    // always non-friendly to owner of owner's enemy
-    if (testerOwner && targetOwner && (testerOwner->getVictim() == targetOwner || targetOwner->getVictim() == testerOwner))
-        return false;
-
-    Unit const* tester = testerOwner ? testerOwner : this;
-    Unit const* target = targetOwner ? targetOwner : unit;
-
-    // always friendly to target with common owner, or to owner/pet
-    if (tester == target)
-        return true;
-
-    // special cases (Duel)
-    if (tester->GetTypeId() == TYPEID_PLAYER && target->GetTypeId() == TYPEID_PLAYER)
-    {
-        Player const* pTester = (Player const*)tester;
-        Player const* pTarget = (Player const*)target;
-
-        // Duel
-        if (pTester->duel && pTester->duel->opponent == target && pTester->duel->startTime != 0)
-            return false;
-
-        // Group
-        if (pTester->GetGroup() && pTester->GetGroup() == pTarget->GetGroup())
-            return true;
-
-        // Sanctuary
-        if (pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY) && pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY))
-            return true;
-
-        // PvP FFA state
-        if (pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) && pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
-            return false;
-
-        //= PvP states
-        // Green/Blue (non-attackable)
-        if (!pTester->HasAuraType(SPELL_AURA_MOD_FACTION) && !pTarget->HasAuraType(SPELL_AURA_MOD_FACTION))
-        {
-            if (pTester->GetTeam() == pTarget->GetTeam())
-                return true;
-
-            // Blue (friendly/non-attackable) if not PVP, or Yellow/Red in another case (attackable)
-            return !pTarget->IsPvP();
-        }
-    }
-
-    // faction base cases
-    FactionTemplateEntry const *tester_faction = tester->getFactionTemplateEntry();
-    FactionTemplateEntry const *target_faction = target->getFactionTemplateEntry();
-    if (!tester_faction || !target_faction)
-        return false;
-
-    if (target->isAttackingPlayer() && tester->IsContestedGuard())
-        return false;
-
-    // PvC forced reaction and reputation case
-    if (tester->GetTypeId() == TYPEID_PLAYER && !tester->HasAuraType(SPELL_AURA_MOD_FACTION))
-    {
-        // forced reaction
-        if (target_faction->faction)
-        {
-            if (ReputationRank const *force =tester->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(target_faction))
-                return *force >= REP_FRIENDLY;
-
-            // if faction have reputation then friendly state for tester at 100% dependent from at_war state
-            if (FactionEntry const *raw_target_faction = sFactionStore.LookupEntry(target_faction->faction))
-                if (FactionState const *factionState = tester->ToPlayer()->GetReputationMgr().GetState(raw_target_faction))
-                    return !(factionState->Flags & FACTION_FLAG_AT_WAR);
-        }
-    }
-    // CvP forced reaction and reputation case
-    else if (target->GetTypeId() == TYPEID_PLAYER && !target->HasAuraType(SPELL_AURA_MOD_FACTION))
-    {
-        // forced reaction
-        if (tester_faction->faction)
-        {
-            if (ReputationRank const *force =target->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(tester_faction))
-                return *force >= REP_FRIENDLY;
-
-            // apply reputation state
-            if (FactionEntry const *raw_tester_faction = sFactionStore.LookupEntry(tester_faction->faction))
-                if (raw_tester_faction->reputationListID >= 0)
-                    return ((Player const*)target)->GetReputationMgr().GetRank(raw_tester_faction) >= REP_FRIENDLY;
-        }
-    }
-
-    // common faction based case (CvC,PvC,CvP)
-    return tester_faction->IsFriendlyTo(*target_faction);
-}
-
-bool Unit::IsHostileToPlayers() const
-{
-    FactionTemplateEntry const *my_faction = getFactionTemplateEntry();
-    if (!my_faction || !my_faction->faction)
-        return false;
-
-    FactionEntry const *raw_faction = sFactionStore.LookupEntry(my_faction->faction);
-    if (raw_faction && raw_faction->reputationListID >= 0)
-        return false;
-
-    return my_faction->IsHostileToPlayers();
-}
-
-bool Unit::IsNeutralToAll() const
-{
-    FactionTemplateEntry const *my_faction = getFactionTemplateEntry();
-    if (!my_faction || !my_faction->faction)
-        return true;
-
-    FactionEntry const *raw_faction = sFactionStore.LookupEntry(my_faction->faction);
-    if (raw_faction && raw_faction->reputationListID >= 0)
-        return false;
-
-    return my_faction->IsNeutralToAll();
-}
-
-bool Unit::Attack(Unit *victim, bool meleeAttack)
-{
-    if (!victim || victim == this)
-        return false;
-
-    // dead units can neither attack nor be attacked
-    if (!isAlive() || !victim->IsInWorld() || !victim->isAlive())
-        return false;
-
-    // player cannot attack in mount state
-    if (GetTypeId() == TYPEID_PLAYER && IsMounted())
-        return false;
-
-    // nobody can attack GM in GM-mode
-    if (victim->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (victim->ToPlayer()->isGameMaster())
-            return false;
-    }
-    else
-    {
-        if (victim->ToCreature()->IsInEvadeMode())
-            return false;
-    }
-
-    // remove SPELL_AURA_MOD_UNATTACKABLE at attack (in case non-interruptible spells stun aura applied also that not let attack)
-    if (HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
-        RemoveAurasByType(SPELL_AURA_MOD_UNATTACKABLE);
-
-    if (m_attacking)
-    {
-        if (m_attacking == victim)
-        {
-            // switch to melee attack from ranged/magic
-            if (meleeAttack)
-            {
-                if (!hasUnitState(UNIT_STAT_MELEE_ATTACKING))
-                {
-                    addUnitState(UNIT_STAT_MELEE_ATTACKING);
-                    SendMeleeAttackStart(victim);
-                    return true;
-                }
-            }
-            else if (hasUnitState(UNIT_STAT_MELEE_ATTACKING))
-            {
-                clearUnitState(UNIT_STAT_MELEE_ATTACKING);
-                SendMeleeAttackStop(victim);
-                return true;
-            }
-            return false;
-        }
-
-        //switch target
-        InterruptSpell(CURRENT_MELEE_SPELL);
-        if (!meleeAttack)
-            clearUnitState(UNIT_STAT_MELEE_ATTACKING);
-    }
-
-    if (m_attacking)
-        m_attacking->_removeAttacker(this);
-
-    m_attacking = victim;
-    m_attacking->_addAttacker(this);
-
-    // Set our target
-    SetUInt64Value(UNIT_FIELD_TARGET, victim->GetGUID());
-
-    if (meleeAttack)
-        addUnitState(UNIT_STAT_MELEE_ATTACKING);
-
-    // set position before any AI calls/assistance
-    //if (GetTypeId() == TYPEID_UNIT)
-    //    this->ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
-
-    if (GetTypeId() == TYPEID_UNIT)
-    {
-        // should not let player enter combat by right clicking target
-        SetInCombatWith(victim);
-        if (victim->GetTypeId() == TYPEID_PLAYER)
-            victim->SetInCombatWith(this);
-        AddThreat(victim, 0.0f);
-
-        this->ToCreature()->SendAIReaction(AI_REACTION_HOSTILE);
-        this->ToCreature()->CallAssistance();
-    }
-
-    // delay offhand weapon attack to next attack time
-    if (haveOffhandWeapon())
-        resetAttackTimer(OFF_ATTACK);
-
-    if (meleeAttack)
-        SendMeleeAttackStart(victim);
-
-    return true;
-}
-
-bool Unit::AttackStop()
-{
-    if (!m_attacking)
-        return false;
-
-    Unit* victim = m_attacking;
-
-    m_attacking->_removeAttacker(this);
-    m_attacking = NULL;
-
-    // Clear our target
-    SetUInt64Value(UNIT_FIELD_TARGET, 0);
-
-    clearUnitState(UNIT_STAT_MELEE_ATTACKING);
-
-    InterruptSpell(CURRENT_MELEE_SPELL);
-
-    // reset only at real combat stop
-    if (GetTypeId() == TYPEID_UNIT)
-    {
-        this->ToCreature()->SetNoCallAssistance(false);
-
-        if (this->ToCreature()->HasSearchedAssistance())
-        {
-            this->ToCreature()->SetNoSearchAssistance(false);
-            UpdateSpeed(MOVE_RUN, false);
-        }
-    }
-
-    SendMeleeAttackStop(victim);
-
-    return true;
-}
-
-void Unit::CombatStop(bool includingCast)
-{
-    if (includingCast && IsNonMeleeSpellCasted(false))
-        InterruptNonMeleeSpells(false);
-
-    AttackStop();
-    RemoveAllAttackers();
-    if (GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel
-    ClearInCombat();
-}
-
-void Unit::CombatStopWithPets(bool includingCast)
-{
-    CombatStop(includingCast);
-
-    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
-        (*itr)->CombatStop(includingCast);
-}
-
-bool Unit::isAttackingPlayer() const
-{
-    if (hasUnitState(UNIT_STAT_ATTACK_PLAYER))
-        return true;
-
-    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
-        if ((*itr)->isAttackingPlayer())
-            return true;
-
-    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
-        if (m_SummonSlot[i])
-            if (Creature *summon = GetMap()->GetCreature(m_SummonSlot[i]))
-                if (summon->isAttackingPlayer())
-                    return true;
-
-    return false;
-}
-
-void Unit::RemoveAllAttackers()
-{
-    while (!m_attackers.empty())
-    {
-        AttackerSet::iterator iter = m_attackers.begin();
-        if (!(*iter)->AttackStop())
-        {
-            sLog.outError("WORLD: Unit has an attacker that isn't attacking it!");
-            m_attackers.erase(iter);
-        }
-    }
-}
-
-void Unit::ModifyAuraState(AuraState flag, bool apply)
-{
-    if (apply)
-    {
-        if (!HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1)))
-        {
-            SetFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
-            if (GetTypeId() == TYPEID_PLAYER)
-            {
-                PlayerSpellMap const& sp_list = this->ToPlayer()->GetSpellMap();
-                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
-                {
-                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled) continue;
-                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(itr->first);
-                    if (!spellInfo || !IsPassiveSpell(itr->first)) continue;
-                    if (spellInfo->CasterAuraState == uint32(flag))
-                        CastSpell(this, itr->first, true, NULL);
-                }
-            }
-            else if (this->ToCreature()->isPet())
-            {
-                Pet *pet = ((Pet*)this);
-                for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
-                {
-                    if (itr->second.state == PETSPELL_REMOVED) continue;
-                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(itr->first);
-                    if (!spellInfo || !IsPassiveSpell(itr->first)) continue;
-                    if (spellInfo->CasterAuraState == uint32(flag))
-                        CastSpell(this, itr->first, true, NULL);
-                }
-            }
-        }
-    }
-    else
-    {
-        if (HasFlag(UNIT_FIELD_AURASTATE,1<<(flag-1)))
-        {
-            RemoveFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
-
-            if (flag != AURA_STATE_ENRAGE)                  // enrage aura state triggering continues auras
-            {
-                Unit::AuraApplicationMap& tAuras = GetAppliedAuras();
-                for (Unit::AuraApplicationMap::iterator itr = tAuras.begin(); itr != tAuras.end();)
-                {
-                    SpellEntry const* spellProto = (*itr).second->GetBase()->GetSpellProto();
-                    if (spellProto->CasterAuraState == uint32(flag))
-                        RemoveAura(itr);
-                    else
-                        ++itr;
-                }
-            }
-        }
-    }
-}
-
-uint32 Unit::BuildAuraStateUpdateForTarget(Unit * target) const
-{
-    uint32 auraStates = GetUInt32Value(UNIT_FIELD_AURASTATE) &~(PER_CASTER_AURA_STATE_MASK);
-    for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.begin(); itr != m_auraStateAuras.end(); ++itr)
-        if ((1<<(itr->first-1)) & PER_CASTER_AURA_STATE_MASK)
-            if (itr->second->GetBase()->GetCasterGUID() == target->GetGUID())
-                auraStates |= (1<<(itr->first-1));
-
-    return auraStates;
-}
-
-bool Unit::HasAuraState(AuraState flag, SpellEntry const *spellProto, Unit const * Caster) const
-{
-    if (Caster)
-    {
-        if (spellProto)
-        {
-            AuraEffectList const& stateAuras = Caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_IGNORE_AURASTATE);
-            for (AuraEffectList::const_iterator j = stateAuras.begin(); j != stateAuras.end(); ++j)
-                if ((*j)->IsAffectedOnSpell(spellProto))
-                    return true;
-        }
-        // Check per caster aura state
-        // If aura with aurastate by caster not found return false
-        if ((1<<(flag-1)) & PER_CASTER_AURA_STATE_MASK)
-        {
-            for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.lower_bound(flag); itr != m_auraStateAuras.upper_bound(flag); ++itr)
-                if (itr->second->GetBase()->GetCasterGUID() == Caster->GetGUID())
-                    return true;
-            return false;
-        }
-    }
-
-    return HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
-}
-
-Unit *Unit::GetOwner() const
-{
-    if (uint64 ownerid = GetOwnerGUID())
-    {
-        return ObjectAccessor::GetUnit(*this, ownerid);
-    }
-    return NULL;
-}
-
-Unit *Unit::GetCharmer() const
-{
-    if (uint64 charmerid = GetCharmerGUID())
-        return ObjectAccessor::GetUnit(*this, charmerid);
-    return NULL;
-}
-
-Player* Unit::GetCharmerOrOwnerPlayerOrPlayerItself() const
-{
-    uint64 guid = GetCharmerOrOwnerGUID();
-    if (IS_PLAYER_GUID(guid))
-        return ObjectAccessor::GetPlayer(*this, guid);
-
-    return GetTypeId() == TYPEID_PLAYER ? (Player*)this : NULL;
-}
-
-Minion *Unit::GetFirstMinion() const
-{
-    if (uint64 pet_guid = GetMinionGUID())
-    {
-        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
-            if (pet->HasUnitTypeMask(UNIT_MASK_MINION))
-                return (Minion*)pet;
-
-        sLog.outError("Unit::GetFirstMinion: Minion %u not exist.",GUID_LOPART(pet_guid));
-        const_cast<Unit*>(this)->SetMinionGUID(0);
-    }
-
-    return NULL;
-}
-
-Guardian* Unit::GetGuardianPet() const
-{
-    if (uint64 pet_guid = GetPetGUID())
-    {
-        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
-            if (pet->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
-                return (Guardian*)pet;
-
-        sLog.outCrash("Unit::GetGuardianPet: Guardian " UI64FMTD " not exist.", pet_guid);
-        const_cast<Unit*>(this)->SetPetGUID(0);
-    }
-
-    return NULL;
-}
-
-Unit* Unit::GetCharm() const
-{
-    if (uint64 charm_guid = GetCharmGUID())
-    {
-        if (Unit* pet = ObjectAccessor::GetUnit(*this, charm_guid))
-            return pet;
-
-        sLog.outError("Unit::GetCharm: Charmed creature %u not exist.",GUID_LOPART(charm_guid));
-        const_cast<Unit*>(this)->SetUInt64Value(UNIT_FIELD_CHARM, 0);
-    }
-
-    return NULL;
-}
-
-void Unit::SetMinion(Minion *minion, bool apply)
-{
-    sLog.outDebug("SetMinion %u for %u, apply %u", minion->GetEntry(), GetEntry(), apply);
-
-    if (apply)
-    {
-        if (!minion->AddUInt64Value(UNIT_FIELD_SUMMONEDBY, GetGUID()))
-        {
-            sLog.outCrash("SetMinion: Minion %u is not the minion of owner %u", minion->GetEntry(), GetEntry());
-            return;
-        }
-
-        m_Controlled.insert(minion);
-
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            minion->m_ControlledByPlayer = true;
-            minion->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
-        }
-
-        // Can only have one pet. If a new one is summoned, dismiss the old one.
-        if (minion->IsGuardianPet())
-        {
-            if (Guardian* oldPet = GetGuardianPet())
-            {
-                if (oldPet != minion && (oldPet->isPet() || minion->isPet() || oldPet->GetEntry() != minion->GetEntry()))
-                {
-                    // remove existing minion pet
-                    if (oldPet->isPet())
-                        ((Pet*)oldPet)->Remove(PET_SAVE_AS_CURRENT);
-                    else
-                        oldPet->UnSummon();
-                    SetPetGUID(minion->GetGUID());
-                    SetMinionGUID(0);
-                }
-            }
-            else
-            {
-                SetPetGUID(minion->GetGUID());
-                SetMinionGUID(0);
-            }
-        }
-
-        if (minion->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
-        {
-            if (AddUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))
-            {
-            }
-        }
-
-        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
-        {
-            SetCritterGUID(minion->GetGUID());
-        }
-
-        // PvP, FFAPvP
-        minion->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));
-
-        // FIXME: hack, speed must be set only at follow
-        if (GetTypeId() == TYPEID_PLAYER && minion->isPet())
-            for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
-                minion->SetSpeed(UnitMoveType(i), m_speed_rate[i], true);
-
-        // Ghoul pets have energy instead of mana (is anywhere better place for this code?)
-        if (minion->IsPetGhoul())
-            minion->setPowerType(POWER_ENERGY);
-
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            // Send infinity cooldown - client does that automatically but after relog cooldown needs to be set again
-            SpellEntry const *spellInfo = sSpellStore.LookupEntry(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));
-            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE))
-                this->ToPlayer()->AddSpellAndCategoryCooldowns(spellInfo, 0, NULL ,true);
-        }
-    }
-    else
-    {
-        if (minion->GetOwnerGUID() != GetGUID())
-        {
-            sLog.outCrash("SetMinion: Minion %u is not the minion of owner %u", minion->GetEntry(), GetEntry());
-            return;
-        }
-
-        m_Controlled.erase(minion);
-
-        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
-        {
-            if (GetCritterGUID() == minion->GetGUID())
-                SetCritterGUID(0);
-        }
-
-        if (minion->IsGuardianPet())
-        {
-            if (GetPetGUID() == minion->GetGUID())
-                SetPetGUID(0);
-        }
-        else if (minion->isTotem())
-        {
-            // All summoned by totem minions must disappear when it is removed.
-        if (const SpellEntry* spInfo = sSpellStore.LookupEntry(minion->ToTotem()->GetSpell()))
-            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-            {
-                if (spInfo->Effect[i] != SPELL_EFFECT_SUMMON)
-                    continue;
-
-                this->RemoveAllMinionsByEntry(spInfo->EffectMiscValue[i]);
-            }
-        }
-
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            SpellEntry const *spellInfo = sSpellStore.LookupEntry(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));
-            // Remove infinity cooldown
-            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE))
-                this->ToPlayer()->SendCooldownEvent(spellInfo);
-        }
-
-        //if (minion->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
-        {
-            if (RemoveUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))
-            {
-                //Check if there is another minion
-                for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
-                {
-                    // do not use this check, creature do not have charm guid
-                    //if (GetCharmGUID() == (*itr)->GetGUID())
-                    if (GetGUID() == (*itr)->GetCharmerGUID())
-                        continue;
-
-                    //ASSERT((*itr)->GetOwnerGUID() == GetGUID());
-                    if ((*itr)->GetOwnerGUID() != GetGUID())
-                    {
-                        OutDebugInfo();
-                        (*itr)->OutDebugInfo();
-                        ASSERT(false);
-                    }
-                    ASSERT((*itr)->GetTypeId() == TYPEID_UNIT);
-
-                    if (!(*itr)->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
-                        continue;
-
-                    if (AddUInt64Value(UNIT_FIELD_SUMMON, (*itr)->GetGUID()))
-                    {
-                        //show another pet bar if there is no charm bar
-                        if (GetTypeId() == TYPEID_PLAYER && !GetCharmGUID())
-                        {
-                            if ((*itr)->isPet())
-                                this->ToPlayer()->PetSpellInitialize();
-                            else
-                                this->ToPlayer()->CharmSpellInitialize();
-                        }
-                    }
-                    break;
-                }
-            }
-        }
-    }
-}
-
-void Unit::GetAllMinionsByEntry(std::list<Creature*>& Minions, uint32 entry)
-{
-    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)
-    {
-        Unit *unit = *itr;
-        ++itr;
-        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT
-            && unit->ToCreature()->isSummon()) // minion, actually
-            Minions.push_back(unit->ToCreature());
-    }
-}
-
-void Unit::RemoveAllMinionsByEntry(uint32 entry)
-{
-    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)
-    {
-        Unit *unit = *itr;
-        ++itr;
-        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT
-            && unit->ToCreature()->isSummon()) // minion, actually
-            unit->ToTempSummon()->UnSummon();
-        // i think this is safe because i have never heard that a despawned minion will trigger a same minion
-    }
-}
-
-void Unit::SetCharm(Unit* charm, bool apply)
-{
-    if (apply)
-    {
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            if (!AddUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))
-                sLog.outCrash("Player %s is trying to charm unit %u, but it already has a charmed unit " UI64FMTD "", GetName(), charm->GetEntry(), GetCharmGUID());
-
-            charm->m_ControlledByPlayer = true;
-            // TODO: maybe we can use this flag to check if controlled by player
-            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
-        }
-        else
-            charm->m_ControlledByPlayer = false;
-
-        // PvP, FFAPvP
-        charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));
-
-        if (!charm->AddUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))
-            sLog.outCrash("Unit %u is being charmed, but it already has a charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());
-
-        if (charm->HasUnitMovementFlag(MOVEMENTFLAG_WALKING))
-        {
-            charm->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-            charm->SendMovementFlagUpdate();
-        }
-
-        m_Controlled.insert(charm);
-    }
-    else
-    {
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            if (!RemoveUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))
-                sLog.outCrash("Player %s is trying to uncharm unit %u, but it has another charmed unit " UI64FMTD "", GetName(), charm->GetEntry(), GetCharmGUID());
-        }
-
-        if (!charm->RemoveUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))
-            sLog.outCrash("Unit %u is being uncharmed, but it has another charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());
-
-        if (charm->GetTypeId() == TYPEID_PLAYER)
-        {
-            charm->m_ControlledByPlayer = true;
-            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
-            charm->ToPlayer()->UpdatePvPState();
-        }
-        else if (Player *player = charm->GetCharmerOrOwnerPlayerOrPlayerItself())
-        {
-            charm->m_ControlledByPlayer = true;
-            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
-            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, player->GetByteValue(UNIT_FIELD_BYTES_2, 1));
-        }
-        else
-        {
-            charm->m_ControlledByPlayer = false;
-            charm->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
-            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
-        }
-
-        if (charm->GetTypeId() == TYPEID_PLAYER
-            || !charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_MINION)
-            || charm->GetOwnerGUID() != GetGUID())
-            m_Controlled.erase(charm);
-    }
-}
-
-int32 Unit::DealHeal(Unit *pVictim, uint32 addhealth)
-{
-    int32 gain = 0;
-
-    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsAIEnabled)
-        pVictim->ToCreature()->AI()->HealReceived(this, addhealth);
-
-    if (addhealth)
-        gain = pVictim->ModifyHealth(int32(addhealth));
-
-    Unit* unit = this;
-
-    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem())
-        unit = GetOwner();
-
-    if (unit->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (Battleground *bg = unit->ToPlayer()->GetBattleground())
-            bg->UpdatePlayerScore((Player*)unit, SCORE_HEALING_DONE, gain);
-
-        // use the actual gain, as the overheal shall not be counted, skip gain 0 (it ignored anyway in to criteria)
-        if (gain)
-            unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE, gain, 0, pVictim);
-
-        unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEAL_CASTED, addhealth);
-    }
-
-    if (pVictim->GetTypeId() == TYPEID_PLAYER)
-    {
-        pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_HEALING_RECEIVED, gain);
-        pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEALING_RECEIVED, addhealth);
-    }
-
-    return gain;
-}
-
-Unit* Unit::SelectMagnetTarget(Unit *victim, SpellEntry const *spellInfo)
-{
-    if (!victim)
-        return NULL;
-
-    // Magic case
-    if (spellInfo && (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC))
-    {
-        //I am not sure if this should be redirected.
-        if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE)
-            return victim;
-
-        Unit::AuraEffectList const& magnetAuras = victim->GetAuraEffectsByType(SPELL_AURA_SPELL_MAGNET);
-        for (Unit::AuraEffectList::const_iterator itr = magnetAuras.begin(); itr != magnetAuras.end(); ++itr)
-            if (Unit* magnet = (*itr)->GetBase()->GetUnitOwner())
-                if (magnet->isAlive())
-                {
-                    (*itr)->GetBase()->DropCharge();
-                    return magnet;
-                }
-    }
-    // Melee && ranged case
-    else
-    {
-        AuraEffectList const& hitTriggerAuras = victim->GetAuraEffectsByType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER);
-        for (AuraEffectList::const_iterator i = hitTriggerAuras.begin(); i != hitTriggerAuras.end(); ++i)
-            if (Unit* magnet = (*i)->GetBase()->GetCaster())
-                if (magnet->isAlive() && magnet->IsWithinLOSInMap(this))
-                    if (roll_chance_i((*i)->GetAmount()))
-                    {
-                        (*i)->GetBase()->DropCharge();
-                        return magnet;
-                    }
-    }
-
-    return victim;
-}
-
-Unit* Unit::GetFirstControlled() const
-{
-    //Sequence: charmed, pet, other guardians
-    Unit *unit = GetCharm();
-    if (!unit)
-        if (uint64 guid = GetUInt64Value(UNIT_FIELD_SUMMON))
-            unit = ObjectAccessor::GetUnit(*this, guid);
-
-    return unit;
-}
-
-void Unit::RemoveAllControlled()
-{
-    //possessed pet and vehicle
-    if (GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->StopCastingCharm();
-
-    while (!m_Controlled.empty())
-    {
-        Unit *target = *m_Controlled.begin();
-        m_Controlled.erase(m_Controlled.begin());
-        if (target->GetCharmerGUID() == GetGUID())
-            target->RemoveCharmAuras();
-        else if (target->GetOwnerGUID() == GetGUID() && target->isSummon())
-            target->ToTempSummon()->UnSummon();
-        else
-            sLog.outError("Unit %u is trying to release unit %u which is neither charmed nor owned by it", GetEntry(), target->GetEntry());
-    }
-    if (GetPetGUID())
-        sLog.outCrash("Unit %u is not able to release its pet " UI64FMTD, GetEntry(), GetPetGUID());
-    if (GetMinionGUID())
-        sLog.outCrash("Unit %u is not able to release its minion " UI64FMTD, GetEntry(), GetMinionGUID());
-    if (GetCharmGUID())
-        sLog.outCrash("Unit %u is not able to release its charm " UI64FMTD, GetEntry(), GetCharmGUID());
-}
-
-Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
-{
-    Player* player = NULL;
-    if (GetTypeId() == TYPEID_PLAYER)
-        player = (Player*)this;
-    // Should we enable this also for charmed units?
-    else if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isPet())
-        player = (Player*)GetOwner();
-
-    if (!player)
-        return NULL;
-    Group *pGroup = player->GetGroup();
-    //When there is no group check pet presence
-    if (!pGroup)
-    {
-        // We are pet now, return owner
-        if (player != this)
-            return IsWithinDistInMap(player, radius) ? player : NULL;
-        Unit * pet = GetGuardianPet();
-        //No pet, no group, nothing to return
-        if (!pet)
-            return NULL;
-        // We are owner now, return pet
-        return IsWithinDistInMap(pet, radius) ? pet : NULL;
-    }
-
-    std::vector<Unit*> nearMembers;
-    //reserve place for players and pets because resizing vector every unit push is unefficient (vector is reallocated then)
-    nearMembers.reserve(pGroup->GetMembersCount()*2);
-
-    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-        if (Player *Target = itr->getSource())
-        {
-            // IsHostileTo check duel and controlled by enemy
-            if (Target !=this && Target->isAlive() && IsWithinDistInMap(Target, radius) && !IsHostileTo(Target))
-                nearMembers.push_back(Target);
-
-        // Push player's pet to vector
-        if (Unit *pet = Target->GetGuardianPet())
-            if (pet != this && pet->isAlive() && IsWithinDistInMap(pet, radius) && !IsHostileTo(pet))
-                nearMembers.push_back(pet);
-        }
-
-    if (nearMembers.empty())
-        return NULL;
-
-    uint32 randTarget = urand(0,nearMembers.size()-1);
-    return nearMembers[randTarget];
-}
-
-//only called in Player::SetSeer
-// so move it to Player?
-void Unit::AddPlayerToVision(Player* plr)
-{
-    if (m_sharedVision.empty())
-    {
-        setActive(true);
-        SetWorldObject(true);
-    }
-    m_sharedVision.push_back(plr);
-}
-
-//only called in Player::SetSeer
-void Unit::RemovePlayerFromVision(Player* plr)
-{
-    m_sharedVision.remove(plr);
-    if (m_sharedVision.empty())
-    {
-        setActive(false);
-        SetWorldObject(false);
-    }
-}
-
-void Unit::RemoveBindSightAuras()
-{
-    RemoveAurasByType(SPELL_AURA_BIND_SIGHT);
-}
-
-void Unit::RemoveCharmAuras()
-{
-    RemoveAurasByType(SPELL_AURA_MOD_CHARM);
-    RemoveAurasByType(SPELL_AURA_MOD_POSSESS_PET);
-    RemoveAurasByType(SPELL_AURA_MOD_POSSESS);
-    RemoveAurasByType(SPELL_AURA_AOE_CHARM);
-}
-
-void Unit::UnsummonAllTotems()
-{
-    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
-    {
-        if (!m_SummonSlot[i])
-            continue;
-
-        if (Creature *OldTotem = GetMap()->GetCreature(m_SummonSlot[i]))
-            if (OldTotem->isSummon())
-                OldTotem->ToTempSummon()->UnSummon();
-    }
-}
-
-void Unit::SendHealSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorb, bool critical)
-{
-    // we guess size
-    WorldPacket data(SMSG_SPELLHEALLOG, (8+8+4+4+4+4+1+1));
-    data.append(pVictim->GetPackGUID());
-    data.append(GetPackGUID());
-    data << uint32(SpellID);
-    data << uint32(Damage);
-    data << uint32(OverHeal);
-    data << uint32(Absorb); // Absorb amount
-    data << uint8(critical ? 1 : 0);
-    data << uint8(0); // unused
-    SendMessageToSet(&data, true);
-}
-
-int32 Unit::HealBySpell(Unit * pVictim, SpellEntry const * spellInfo, uint32 addHealth, bool critical)
-{
-    uint32 absorb = 0;
-    // calculate heal absorb and reduce healing
-    CalcHealAbsorb(pVictim, spellInfo, addHealth, absorb);
-
-    int32 gain = DealHeal(pVictim, addHealth);
-    SendHealSpellLog(pVictim, spellInfo->Id, addHealth, uint32(addHealth - gain), absorb, critical);
-    return gain;
-}
-
-void Unit::SendEnergizeSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, Powers powertype)
-{
-    WorldPacket data(SMSG_SPELLENERGIZELOG, (8+8+4+4+4+1));
-    data.append(pVictim->GetPackGUID());
-    data.append(GetPackGUID());
-    data << uint32(SpellID);
-    data << uint32(powertype);
-    data << uint32(Damage);
-    SendMessageToSet(&data, true);
-}
-
-void Unit::EnergizeBySpell(Unit *pVictim, uint32 SpellID, uint32 Damage, Powers powertype)
-{
-    SendEnergizeSpellLog(pVictim, SpellID, Damage, powertype);
-    // needs to be called after sending spell log
-    pVictim->ModifyPower(powertype, Damage);
-}
-
-uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)
-{
-    if (!spellProto || !pVictim || damagetype == DIRECT_DAMAGE)
-        return pdamage;
-
-    // For totems get damage bonus from owner
-    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem())
-        if (Unit *owner = GetOwner())
-            return owner->SpellDamageBonus(pVictim, spellProto, pdamage, damagetype);
-
-    // Taken/Done total percent damage auras
-    float DoneTotalMod = 1.0f;
-    float ApCoeffMod = 1.0f;
-    int32 DoneTotal = 0;
-    int32 TakenTotal = 0;
-
-    // ..done
-    // Pet damage
-    if (GetTypeId() == TYPEID_UNIT && !this->ToCreature()->isPet())
-        DoneTotalMod *= this->ToCreature()->GetSpellDamageMod(this->ToCreature()->GetCreatureInfo()->rank);
-
-    AuraEffectList const &mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
-    for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
-        if (((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto)) &&
-            (*i)->GetSpellProto()->EquippedItemClass == -1 &&          // -1 == any item class (not wand)
-            (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0) // 0 == any inventory type (not wand)
-            DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-
-    uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
-    // Add flat bonus from spell damage versus
-    DoneTotal += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_FLAT_SPELL_DAMAGE_VERSUS, creatureTypeMask);
-    AuraEffectList const &mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
-    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
-        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
-            DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-
-    // bonus against aurastate
-    AuraEffectList const &mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
-    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
-        if (pVictim->HasAuraState(AuraState((*i)->GetMiscValue())))
-            DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
-
-    // done scripted mod (take it from owner)
-    Unit * owner = GetOwner() ? GetOwner() : this;
-    AuraEffectList const &mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
-    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
-    {
-        if (!(*i)->IsAffectedOnSpell(spellProto))
-            continue;
-
-        switch ((*i)->GetMiscValue())
-        {
-            case 4920: // Molten Fury
-            case 4919:
-            case 6917: // Death's Embrace
-            case 6926:
-            case 6928:
-            {
-                if (pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))
-                    DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
-                break;
-            }
-            // Soul Siphon
-            case 4992:
-            case 4993:
-            {
-                // effect 1 m_amount
-                int32 maxPercent = (*i)->GetAmount();
-                // effect 0 m_amount
-                int32 stepPercent = CalculateSpellDamage(this, (*i)->GetSpellProto(), 0);
-                // count affliction effects and calc additional damage in percentage
-                int32 modPercent = 0;
-                AuraApplicationMap const &victimAuras = pVictim->GetAppliedAuras();
-                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)
-                {
-                    Aura const * aura = itr->second->GetBase();
-                    SpellEntry const *m_spell = aura->GetSpellProto();
-                    if (m_spell->SpellFamilyName != SPELLFAMILY_WARLOCK || !(m_spell->SpellFamilyFlags[1] & 0x0004071B || m_spell->SpellFamilyFlags[0] & 0x8044C402))
-                        continue;
-                    modPercent += stepPercent * aura->GetStackAmount();
-                    if (modPercent >= maxPercent)
-                    {
-                        modPercent = maxPercent;
-                        break;
-                    }
-                }
-                DoneTotalMod *= (modPercent+100.0f)/100.0f;
-                break;
-            }
-            case 6916: // Death's Embrace
-            case 6925:
-            case 6927:
-                if (HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, spellProto, this))
-                    DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
-                break;
-            case 5481: // Starfire Bonus
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x200002, 0, 0))
-                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-                break;
-            }
-            case 4418: // Increased Shock Damage
-            case 4554: // Increased Lightning Damage
-            case 4555: // Improved Moonfire
-            case 5142: // Increased Lightning Damage
-            case 5147: // Improved Consecration / Libram of Resurgence
-            case 5148: // Idol of the Shooting Star
-            case 6008: // Increased Lightning Damage
-            case 8627: // Totem of Hex
-            {
-                DoneTotal += (*i)->GetAmount();
-                break;
-            }
-            // Tundra Stalker
-            // Merciless Combat
-            case 7277:
-            {
-                // Merciless Combat
-                if ((*i)->GetSpellProto()->SpellIconID == 2656)
-                {
-                    if (!pVictim->HealthAbovePct(35))
-                        DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
-                }
-                // Tundra Stalker
-                else
-                {
-                    // Frost Fever (target debuff)
-                    if (pVictim->HasAura(55095))
-                        DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-                    break;
-                }
-                break;
-            }
-            // Rage of Rivendare
-            case 7293:
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0,0x02000000,0))
-                {
-                    if (SpellChainNode const *chain = sSpellMgr.GetSpellChainNode((*i)->GetId()))
-                        DoneTotalMod *= (chain->rank * 2.0f + 100.0f)/100.0f;
-                }
-                break;
-            }
-            // Twisted Faith
-            case 7377:
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0,0, GetGUID()))
-                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-                break;
-            }
-            // Marked for Death
-            case 7598:
-            case 7599:
-            case 7600:
-            case 7601:
-            case 7602:
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400, 0, 0))
-                    DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
-                break;
-            }
-        }
-    }
-
-    // Custom scripted damage
-    switch(spellProto->SpellFamilyName)
-    {
-        case SPELLFAMILY_MAGE:
-            // Ice Lance
-            if (spellProto->SpellIconID == 186)
-            {
-                if (pVictim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
-                {
-                    // Glyph of Ice Lance
-                    if (owner->HasAura(56377) && pVictim->getLevel() > owner->getLevel())
-                        DoneTotalMod *= 4.0f;
-                    else
-                        DoneTotalMod *= 3.0f;
-                }
-            }
-
-            // Torment the weak
-            if (spellProto->SpellFamilyFlags[0]&0x20200021 || spellProto->SpellFamilyFlags[1]& 0x9000)
-                if (pVictim->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED))
-                {
-                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
-                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)
-                        if ((*i)->GetSpellProto()->SpellIconID == 3263)
-                        {
-                            DoneTotalMod *= float((*i)->GetAmount() + 100.f) / 100.f;
-                            break;
-                        }
-                }
-        break;
-        case SPELLFAMILY_PRIEST:
-            if (spellProto->SpellFamilyFlags[0] & 0x800000)
-            {
-                // Glyph of Shadow Word: Pain
-                if (AuraEffect * aurEff = GetAuraEffect(55687, 0))
-                    // Increase Mind Flay damage if Shadow Word: Pain present on target
-                    if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0,0, GetGUID()))
-                        DoneTotalMod *= (aurEff->GetAmount() + 100.0f) / 100.f;
-
-                // Twisted Faith - Mind Flay part
-                if (AuraEffect * aurEff = GetAuraEffect(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS, SPELLFAMILY_PRIEST, 2848, 1))
-                    // Increase Mind Flay damage if Shadow Word: Pain present on target
-                    if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0,0, GetGUID()))
-                        DoneTotalMod *= (aurEff->GetAmount() + 100.0f) / 100.f;
-            }
-        break;
-        case SPELLFAMILY_PALADIN:
-            // Judgement of Vengeance/Judgement of Corruption
-            if ((spellProto->SpellFamilyFlags[1] & 0x400000) && spellProto->SpellIconID == 2292)
-            {
-                // Get stack of Holy Vengeance/Blood Corruption on the target added by caster
-                uint32 stacks = 0;
-                Unit::AuraEffectList const& auras = pVictim->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
-                for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-                    if (((*itr)->GetId() == 31803 || (*itr)->GetId() == 53742) && (*itr)->GetCasterGUID() == GetGUID())
-                    {
-                        stacks = (*itr)->GetBase()->GetStackAmount();
-                        break;
-                    }
-                // + 10% for each application of Holy Vengeance/Blood Corruption on the target
-                if (stacks)
-                    DoneTotalMod *= (10.0f + float(stacks)) / 10.0f;
-            }
-        break;
-        case SPELLFAMILY_WARLOCK:
-            //Fire and Brimstone
-            if (spellProto->SpellFamilyFlags[1] & 0x00020040)
-                if (pVictim->HasAuraState(AURA_STATE_CONFLAGRATE))
-                {
-                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
-                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)
-                        if ((*i)->GetSpellProto()->SpellIconID == 3173)
-                        {
-                            DoneTotalMod *= float((*i)->GetAmount() + 100.f) / 100.f;
-                            break;
-                        }
-                }
-            // Drain Soul - increased damage for targets under 25 % HP
-            if (spellProto->SpellFamilyFlags[0] & 0x00004000)
-                if (HasAura(200000))
-                    DoneTotalMod *= 4;
-        break;
-        case SPELLFAMILY_DEATHKNIGHT:
-            // Improved Icy Touch
-            if (spellProto->SpellFamilyFlags[0] & 0x2)
-                if (AuraEffect * aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2721, 0))
-                    DoneTotalMod *= (100.0f + aurEff->GetAmount()) / 100.0f;
-            // Glacier Rot
-            if (spellProto->SpellFamilyFlags[0] & 0x2 || spellProto->SpellFamilyFlags[1] & 0x6)
-                if (AuraEffect * aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 196, 0))
-                    if (pVictim->GetDiseasesByCaster(owner->GetGUID()) > 0)
-                        DoneTotalMod *= (100.0f + aurEff->GetAmount()) / 100.0f;
-             // Sigil of the Vengeful Heart (Death Coil part)
-                 if (spellProto->SpellFamilyFlags[0] & 0x2000)
-                     if (AuraEffect * aurEff = GetAuraEffect(64962, 1))
-                         DoneTotal += aurEff->GetAmount();
-            // Impurity (dummy effect)
-            if (GetTypeId() == TYPEID_PLAYER)
-            {
-                PlayerSpellMap playerSpells = this->ToPlayer()->GetSpellMap();
-                for (PlayerSpellMap::const_iterator itr = playerSpells.begin(); itr != playerSpells.end(); ++itr)
-                {
-                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
-                        continue;
-                    switch (itr->first)
-                    {
-                        case 49220:
-                        case 49633:
-                        case 49635:
-                        case 49636:
-                        case 49638:
-                        {
-                            if (const SpellEntry *proto=sSpellStore.LookupEntry(itr->first))
-                                ApCoeffMod *= (100.0f + SpellMgr::CalculateSpellEffectAmount(proto, 0)) / 100.0f;
-                        }
-                        break;
-                    }
-                }
-            }
-        break;
-    }
-
-    // ..taken
-    int32 maxPositiveMod = 0; // max of the positive amount aura (that increase the damage taken)
-    int32 sumNegativeMod = 0; // sum the negative amount aura (that reduce the damage taken)
-    AuraEffectList const& mModDamagePercentTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
-    for (AuraEffectList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
-        if ((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto))
-        {
-            if ((*i)->GetAmount() > 0)
-            {
-                if ((*i)->GetAmount() > maxPositiveMod)
-                    maxPositiveMod = (*i)->GetAmount();
-            }
-            else
-                sumNegativeMod += (*i)->GetAmount();
-        }
-
-    // .. taken pct: dummy auras
-    AuraEffectList const& mDummyAuras = pVictim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
-    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
-    {
-        switch((*i)->GetSpellProto()->SpellIconID)
-        {
-            // Cheat Death
-            case 2109:
-                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
-                {
-                    if (pVictim->GetTypeId() != TYPEID_PLAYER)
-                        continue;
-                    float mod = pVictim->ToPlayer()->GetRatingBonusValue(CR_CRIT_TAKEN_MELEE)*(-8.0f);
-                    if (mod < (*i)->GetAmount())
-                        mod = (float)(*i)->GetAmount();
-                    sumNegativeMod += int32(mod);
-                }
-                break;
-            // Ebon Plague
-            case 1933:
-                if ((*i)->GetMiscValue() & (spellProto ? GetSpellSchoolMask(spellProto) : 0))
-                {
-                    if ((*i)->GetAmount() > maxPositiveMod)
-                        maxPositiveMod = (*i)->GetAmount();
-                }
-                break;
-        }
-    }
-
-    // From caster spells
-    AuraEffectList const& mOwnerTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
-    for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
-        if ((*i)->GetCasterGUID() == GetGUID() && (*i)->IsAffectedOnSpell(spellProto))
-            sumNegativeMod += (*i)->GetAmount();
-
-    // Mod damage from spell mechanic
-    if (uint32 mechanicMask = GetAllSpellMechanicMask(spellProto))
-    {
-        AuraEffectList const& mDamageDoneMechanic = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
-        for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
-            if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))
-                sumNegativeMod += (*i)->GetAmount();
-    }
-
-    float TakenTotalMod = (sumNegativeMod+maxPositiveMod+100.0f)/100.0f;
-
-    // Taken/Done fixed damage bonus auras
-    int32 DoneAdvertisedBenefit  = SpellBaseDamageBonus(GetSpellSchoolMask(spellProto));
-    int32 TakenAdvertisedBenefit = SpellBaseDamageBonusForVictim(GetSpellSchoolMask(spellProto), pVictim);
-    // Pets just add their bonus damage to their spell damage
-    // note that their spell damage is just gain of their own auras
-    if (HasUnitTypeMask(UNIT_MASK_GUARDIAN))
-        DoneAdvertisedBenefit += ((Guardian*)this)->GetBonusDamage();
-
-    // Check for table values
-    float coeff = 0;
-    SpellBonusEntry const *bonus = sSpellMgr.GetSpellBonusData(spellProto->Id);
-    if (bonus)
-    {
-        if (damagetype == DOT)
-        {
-            coeff = bonus->dot_damage;
-            if (bonus->ap_dot_bonus > 0)
-            {
-                WeaponAttackType attType = (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK;
-                float APbonus = attType == BASE_ATTACK ? pVictim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS) : pVictim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
-                APbonus += GetTotalAttackPowerValue(attType);
-                DoneTotal += int32(bonus->ap_dot_bonus * stack * ApCoeffMod * APbonus);
-            }
-        }
-        else
-        {
-            coeff = bonus->direct_damage;
-            if (bonus->ap_bonus > 0)
-            {
-                WeaponAttackType attType = (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK;
-                float APbonus = attType == BASE_ATTACK ? pVictim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS) : pVictim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
-                APbonus += GetTotalAttackPowerValue(attType);
-                DoneTotal += int32(bonus->ap_bonus * stack * ApCoeffMod * APbonus);
-            }
-        }
-    }
-    // Default calculation
-    if (DoneAdvertisedBenefit || TakenAdvertisedBenefit)
-    {
-        if (!bonus || coeff < 0)
-        {
-            // Damage Done from spell damage bonus
-            int32 CastingTime = IsChanneledSpell(spellProto) ? GetSpellDuration(spellProto) : GetSpellCastTime(spellProto);
-            // Damage over Time spells bonus calculation
-            float DotFactor = 1.0f;
-            if (damagetype == DOT)
-            {
-                int32 DotDuration = GetSpellDuration(spellProto);
-                // 200% limit
-                if (DotDuration > 0)
-                {
-                    if (DotDuration > 30000)
-                        DotDuration = 30000;
-                    if (!IsChanneledSpell(spellProto))
-                        DotFactor = DotDuration / 15000.0f;
-                    uint8 x = 0;
-                    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-                    {
-                        if (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && (
-                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_DAMAGE ||
-                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
-                        {
-                            x = j;
-                            break;
-                        }
-                    }
-                    int32 DotTicks = 6;
-                    if (spellProto->EffectAmplitude[x] != 0)
-                        DotTicks = DotDuration / spellProto->EffectAmplitude[x];
-                    if (DotTicks)
-                    {
-                        DoneAdvertisedBenefit /= DotTicks;
-                        TakenAdvertisedBenefit /= DotTicks;
-                    }
-                }
-            }
-            // Distribute Damage over multiple effects, reduce by AoE
-            CastingTime = GetCastingTimeForBonus(spellProto, damagetype, CastingTime);
-
-            // 50% for damage and healing spells for leech spells from damage bonus and 0% from healing
-            for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-            {
-                if (spellProto->Effect[j] == SPELL_EFFECT_HEALTH_LEECH ||
-                    (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
-                {
-                    CastingTime /= 2;
-                    break;
-                }
-            }
-            if (spellProto->SchoolMask != SPELL_SCHOOL_MASK_NORMAL)
-                coeff = (CastingTime / 3500.0f) * DotFactor;
-            else
-                coeff = DotFactor;
-        }
-
-        float coeff2 = CalculateLevelPenalty(spellProto) * stack;
-        if (spellProto->SpellFamilyName) //TODO: fix this
-            TakenTotal+= int32(TakenAdvertisedBenefit * coeff * coeff2);
-        if (Player* modOwner = GetSpellModOwner())
-        {
-            coeff *= 100.0f;
-            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
-            coeff /= 100.0f;
-        }
-        DoneTotal += int32(DoneAdvertisedBenefit * coeff * coeff2);
-    }
-
-    // Some spells don't benefit from done mods
-    if (spellProto->AttributesEx3 & SPELL_ATTR_EX3_NO_DONE_BONUS)
-    {
-        DoneTotal = 0;
-        DoneTotalMod = 1.0f;
-    }
-
-    float tmpDamage = (int32(pdamage) + DoneTotal) * DoneTotalMod;
-    // apply spellmod to Done damage (flat and pct)
-    if (Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, tmpDamage);
-
-    tmpDamage = (tmpDamage + TakenTotal) * TakenTotalMod;
-
-    return uint32(std::max(tmpDamage, 0.0f));
-}
-
-int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
-{
-    int32 DoneAdvertisedBenefit = 0;
-
-    // ..done
-    AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
-    for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)
-        if (((*i)->GetMiscValue() & schoolMask) != 0 &&
-        (*i)->GetSpellProto()->EquippedItemClass == -1 &&
-                                                            // -1 == any item class (not wand then)
-        (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0)
-                                                            // 0 == any inventory type (not wand then)
-            DoneAdvertisedBenefit += (*i)->GetAmount();
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        // Base value
-        DoneAdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
-
-        // Damage bonus from stats
-        AuraEffectList const& mDamageDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT);
-        for (AuraEffectList::const_iterator i = mDamageDoneOfStatPercent.begin(); i != mDamageDoneOfStatPercent.end(); ++i)
-        {
-            if ((*i)->GetMiscValue() & schoolMask)
-            {
-                // stat used stored in miscValueB for this aura
-                Stats usedStat = Stats((*i)->GetMiscValueB());
-                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetAmount() / 100.0f);
-            }
-        }
-        // ... and attack power
-        AuraEffectList const& mDamageDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);
-        for (AuraEffectList::const_iterator i =mDamageDonebyAP.begin(); i != mDamageDonebyAP.end(); ++i)
-            if ((*i)->GetMiscValue() & schoolMask)
-                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetAmount() / 100.0f);
-
-    }
-    return DoneAdvertisedBenefit > 0 ? DoneAdvertisedBenefit : 0;
-}
-
-int32 Unit::SpellBaseDamageBonusForVictim(SpellSchoolMask schoolMask, Unit *pVictim)
-{
-    uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
-
-    int32 TakenAdvertisedBenefit = 0;
-    // ..done (for creature type by mask) in taken
-    AuraEffectList const& mDamageDoneCreature = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
-    for (AuraEffectList::const_iterator i = mDamageDoneCreature.begin(); i != mDamageDoneCreature.end(); ++i)
-        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
-            TakenAdvertisedBenefit += (*i)->GetAmount();
-
-    // ..taken
-    AuraEffectList const& mDamageTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
-    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
-        if (((*i)->GetMiscValue() & schoolMask) != 0)
-            TakenAdvertisedBenefit += (*i)->GetAmount();
-
-    return TakenAdvertisedBenefit > 0 ? TakenAdvertisedBenefit : 0;
-}
-
-bool Unit::isSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
-{
-    // Mobs can't crit with spells.
-    if (IS_CREATURE_GUID(GetGUID()))
-        return false;
-
-    // not critting spell
-    if ((spellProto->AttributesEx2 & SPELL_ATTR_EX2_CANT_CRIT))
-        return false;
-
-    float crit_chance = 0.0f;
-    switch(spellProto->DmgClass)
-    {
-        case SPELL_DAMAGE_CLASS_NONE:  // Exception for Earth Shield and Lifebloom Final Bloom
-            if (spellProto->Id != 379 && spellProto->Id != 33778) // We need more spells to find a general way (if there is any)
-                return false;
-        case SPELL_DAMAGE_CLASS_MAGIC:
-        {
-            if (schoolMask & SPELL_SCHOOL_MASK_NORMAL)
-                crit_chance = 0.0f;
-            // For other schools
-            else if (GetTypeId() == TYPEID_PLAYER)
-                crit_chance = GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1 + GetFirstSchoolInMask(schoolMask));
-            else
-            {
-                crit_chance = (float)m_baseSpellCritChance;
-                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
-            }
-            // taken
-            if (pVictim)
-            {
-                if (!IsPositiveSpell(spellProto->Id))
-                {
-                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE
-                    crit_chance += pVictim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, schoolMask);
-                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE
-                    crit_chance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
-                    ApplyResilience(pVictim, &crit_chance, NULL, false, CR_CRIT_TAKEN_SPELL);
-                }
-                // scripted (increase crit chance ... against ... target by x%
-                AuraEffectList const& mOverrideClassScript = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
-                for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
-                {
-                    if (!((*i)->IsAffectedOnSpell(spellProto)))
-                        continue;
-                    int32 modChance=0;
-                    switch((*i)->GetMiscValue())
-                    {
-                        // Shatter
-                        case  911: modChance+= 16;
-                        case  910: modChance+= 17;
-                        case  849: modChance+= 17;
-                            if (!pVictim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
-                                break;
-                            crit_chance+=modChance;
-                            break;
-                        case 7917: // Glyph of Shadowburn
-                            if (pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))
-                                crit_chance+=(*i)->GetAmount();
-                            break;
-                        case 7997: // Renewed Hope
-                        case 7998:
-                            if (pVictim->HasAura(6788))
-                                crit_chance+=(*i)->GetAmount();
-                            break;
-                        case   21: // Test of Faith
-                        case 6935:
-                        case 6918:
-                            if (pVictim->HealthBelowPct(50))
-                                crit_chance+=(*i)->GetAmount();
-                            break;
-                        default:
-                            break;
-                    }
-                }
-                // Custom crit by class
-                switch (spellProto->SpellFamilyName)
-                {
-                    case SPELLFAMILY_DRUID:
-                        // Starfire
-                        if (spellProto->SpellFamilyFlags[0] & 0x4 && spellProto->SpellIconID == 1485)
-                        {
-                            // Improved Insect Swarm
-                            if (AuraEffect const * aurEff = GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))
-                                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00000002, 0, 0))
-                                    crit_chance+=aurEff->GetAmount();
-                           break;
-                        }
-                    break;
-                    case SPELLFAMILY_ROGUE:
-                        // Shiv-applied poisons can't crit
-                        if (FindCurrentSpellBySpellId(5938))
-                            crit_chance = 0.0f;
-                        break;
-                    case SPELLFAMILY_PALADIN:
-                        // Flash of light
-                        if (spellProto->SpellFamilyFlags[0] & 0x40000000)
-                        {
-                            // Sacred Shield
-                            AuraEffect const* aura = pVictim->GetAuraEffect(58597,1);
-                            if (aura && aura->GetCasterGUID() == GetGUID())
-                                crit_chance+=aura->GetAmount();
-                            break;
-                        }
-                        // Exorcism
-                        else if (spellProto->Category == 19)
-                        {
-                            if (pVictim->GetCreatureTypeMask() & CREATURE_TYPEMASK_DEMON_OR_UNDEAD)
-                                return true;
-                            break;
-                        }
-                    break;
-                    case SPELLFAMILY_SHAMAN:
-                        // Lava Burst
-                        if (spellProto->SpellFamilyFlags[1] & 0x00001000)
-                        {
-                            if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0,0, GetGUID()))
-                                return true;
-                            break;
-                        }
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELL_DAMAGE_CLASS_MELEE:
-            if (pVictim)
-            {
-                // Custom crit by class
-                switch(spellProto->SpellFamilyName)
-                {
-                    case SPELLFAMILY_DRUID:
-                        // Rend and Tear - bonus crit chance for Ferocious Bite on bleeding targets
-                        if (spellProto->SpellFamilyFlags[0] & 0x00800000
-                            && spellProto->SpellIconID == 1680
-                            && pVictim->HasAuraState(AURA_STATE_BLEEDING))
-                        {
-                            if (AuraEffect const *rendAndTear = GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 1))
-                                crit_chance += rendAndTear->GetAmount();
-                            break;
-                        }
-                    break;
-                    case SPELLFAMILY_PALADIN:
-                        // Judgement of Command proc always crits on stunned target
-                        if (spellProto->SpellFamilyName == SPELLFAMILY_PALADIN)
-                            if (spellProto->SpellFamilyFlags[0] & 0x0000000000800000LL && spellProto->SpellIconID == 561)
-                                if (pVictim->hasUnitState(UNIT_STAT_STUNNED))
-                                    return true;
-                }
-            }
-        case SPELL_DAMAGE_CLASS_RANGED:
-        {
-            if (pVictim)
-            {
-                crit_chance += GetUnitCriticalChance(attackType, pVictim);
-                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
-            }
-            break;
-        }
-        default:
-            return false;
-    }
-    // percent done
-    // only players use intelligence for critical chance computations
-    if (Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance);
-
-    crit_chance = crit_chance > 0.0f ? crit_chance : 0.0f;
-    if (roll_chance_f(crit_chance))
-        return true;
-    return false;
-}
-
-uint32 Unit::SpellCriticalDamageBonus(SpellEntry const *spellProto, uint32 damage, Unit *pVictim)
-{
-    // Calculate critical bonus
-    int32 crit_bonus;
-    switch(spellProto->DmgClass)
-    {
-        case SPELL_DAMAGE_CLASS_MELEE:                      // for melee based spells is 100%
-        case SPELL_DAMAGE_CLASS_RANGED:
-            // TODO: write here full calculation for melee/ranged spells
-            crit_bonus = damage;
-            break;
-        default:
-            crit_bonus = damage / 2;                        // for spells is 50%
-            break;
-    }
-
-    // adds additional damage to crit_bonus (from talents)
-    if (Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);
-
-    if (pVictim)
-    {
-        uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
-        crit_bonus = int32(crit_bonus * GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, creatureTypeMask));
-    }
-
-    if (crit_bonus > 0)
-        damage += crit_bonus;
-
-    return damage;
-}
-
-uint32 Unit::SpellCriticalHealingBonus(SpellEntry const *spellProto, uint32 damage, Unit *pVictim)
-{
-    // Calculate critical bonus
-    int32 crit_bonus;
-    switch(spellProto->DmgClass)
-    {
-        case SPELL_DAMAGE_CLASS_MELEE:                      // for melee based spells is 100%
-        case SPELL_DAMAGE_CLASS_RANGED:
-            // TODO: write here full calculation for melee/ranged spells
-            crit_bonus = damage;
-            break;
-        default:
-            crit_bonus = damage / 2;                        // for spells is 50%
-            break;
-    }
-
-    if (pVictim)
-    {
-        uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
-        crit_bonus = int32(crit_bonus * GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, creatureTypeMask));
-    }
-
-    if (crit_bonus > 0)
-        damage += crit_bonus;
-
-    damage = int32(float(damage) * GetTotalAuraMultiplier(SPELL_AURA_MOD_CRITICAL_HEALING_AMOUNT));
-
-    return damage;
-}
-
-uint32 Unit::SpellHealingBonus(Unit *pVictim, SpellEntry const *spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack)
-{
-    // For totems get healing bonus from owner (statue isn't totem in fact)
-    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem())
-        if (Unit* owner = GetOwner())
-            return owner->SpellHealingBonus(pVictim, spellProto, healamount, damagetype, stack);
-
-    // no bonus for heal potions/bandages
-    if (spellProto->SpellFamilyName == SPELLFAMILY_POTION)
-        return healamount;
-
-    // Healing Done
-    // Taken/Done total percent damage auras
-    float  DoneTotalMod = 1.0f;
-    float  TakenTotalMod = 1.0f;
-    int32  DoneTotal = 0;
-    int32  TakenTotal = 0;
-
-    // Healing done percent
-    AuraEffectList const& mHealingDonePct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
-    for (AuraEffectList::const_iterator i = mHealingDonePct.begin(); i != mHealingDonePct.end(); ++i)
-        DoneTotalMod *= (100.0f + (*i)->GetAmount()) / 100.0f;
-
-    // done scripted mod (take it from owner)
-    Unit *owner = GetOwner() ? GetOwner() : this;
-    AuraEffectList const &mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
-    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
-    {
-        if (!(*i)->IsAffectedOnSpell(spellProto))
-            continue;
-        switch((*i)->GetMiscValue())
-        {
-            case 4415: // Increased Rejuvenation Healing
-            case 4953:
-            case 3736: // Hateful Totem of the Third Wind / Increased Lesser Healing Wave / LK Arena (4/5/6) Totem of the Third Wind / Savage Totem of the Third Wind
-                DoneTotal+=(*i)->GetAmount();
-                break;
-            case 7997: // Renewed Hope
-            case 7998:
-                if (pVictim->HasAura(6788))
-                    DoneTotalMod *=((*i)->GetAmount() + 100.0f)/100.0f;
-                break;
-            case   21: // Test of Faith
-            case 6935:
-            case 6918:
-                if (pVictim->HealthBelowPct(50))
-                    DoneTotalMod *=((*i)->GetAmount() + 100.0f)/100.0f;
-                break;
-            case 7798: // Glyph of Regrowth
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0, 0))
-                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-                break;
-            }
-            case 8477: // Nourish Heal Boost
-            {
-                int32 stepPercent = (*i)->GetAmount();
-                int32 modPercent = 0;
-                AuraApplicationMap const& victimAuras = pVictim->GetAppliedAuras();
-                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)
-                {
-                    Aura const * aura = itr->second->GetBase();
-                    if (aura->GetCasterGUID() != GetGUID())
-                        continue;
-                    SpellEntry const* m_spell = aura->GetSpellProto();
-                    if (m_spell->SpellFamilyName != SPELLFAMILY_DRUID ||
-                        !(m_spell->SpellFamilyFlags[1] & 0x00000010 || m_spell->SpellFamilyFlags[0] & 0x50))
-                        continue;
-                    modPercent += stepPercent * aura->GetStackAmount();
-                }
-                DoneTotalMod *= (modPercent+100.0f)/100.0f;
-                break;
-            }
-            case 7871: // Glyph of Lesser Healing Wave
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 0 , 0x00000400, 0, GetGUID()))
-                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-                break;
-            }
-            default:
-                break;
-        }
-    }
-
-    // Taken/Done fixed damage bonus auras
-    int32 DoneAdvertisedBenefit  = SpellBaseHealingBonus(GetSpellSchoolMask(spellProto));
-    int32 TakenAdvertisedBenefit = SpellBaseHealingBonusForVictim(GetSpellSchoolMask(spellProto), pVictim);
-
-    bool scripted = false;
-
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch (spellProto->EffectApplyAuraName[i])
-        {
-            // These auras do not use healing coeff
-            case SPELL_AURA_PERIODIC_LEECH:
-            case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
-                scripted = true;
-                break;
-        }
-    }
-
-    // Check for table values
-    SpellBonusEntry const* bonus = !scripted ? sSpellMgr.GetSpellBonusData(spellProto->Id) : NULL;
-    float coeff = 0;
-    float factorMod = 1.0f;
-    if (bonus)
-    {
-        if (damagetype == DOT)
-        {
-            coeff = bonus->dot_damage;
-            if (bonus->ap_dot_bonus > 0)
-                DoneTotal += int32(bonus->ap_dot_bonus * stack * GetTotalAttackPowerValue(
-                    (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE)? RANGED_ATTACK : BASE_ATTACK));
-        }
-        else
-        {
-            coeff = bonus->direct_damage;
-            if (bonus->ap_bonus > 0)
-                DoneTotal += int32(bonus->ap_bonus * stack * GetTotalAttackPowerValue(
-                    (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE)? RANGED_ATTACK : BASE_ATTACK));
-        }
-    }
-    else // scripted bonus
-    {
-        // Gift of the Naaru
-        if (spellProto->SpellFamilyFlags[2] & 0x80000000 && spellProto->SpellIconID == 329)
-        {
-            scripted = true;
-            int32 apBonus = int32(std::max(GetTotalAttackPowerValue(BASE_ATTACK), GetTotalAttackPowerValue(RANGED_ATTACK)));
-            if (apBonus > DoneAdvertisedBenefit)
-                DoneTotal += int32(apBonus * 0.22f); // 22% of AP per tick
-            else
-                DoneTotal += int32(DoneAdvertisedBenefit * 0.377f); //37.7% of BH per tick
-        }
-        // Earthliving - 0.45% of normal hot coeff
-        else if (spellProto->SpellFamilyName == SPELLFAMILY_SHAMAN && spellProto->SpellFamilyFlags[1] & 0x80000)
-            factorMod *= 0.45f;
-        // Already set to scripted? so not uses healing bonus coefficient
-        // No heal coeff for SPELL_DAMAGE_CLASS_NONE class spells by default
-        else if (scripted || spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE)
-        {
-            scripted = true;
-            coeff = 0.0f;
-        }
-    }
-
-    // Default calculation
-    if (DoneAdvertisedBenefit || TakenAdvertisedBenefit)
-    {
-        if ((!bonus && !scripted) || coeff < 0)
-        {
-            // Damage Done from spell damage bonus
-            int32 CastingTime = !IsChanneledSpell(spellProto) ? GetSpellCastTime(spellProto) : GetSpellDuration(spellProto);
-            // Damage over Time spells bonus calculation
-            float DotFactor = 1.0f;
-            if (damagetype == DOT)
-            {
-                int32 DotDuration = GetSpellDuration(spellProto);
-                // 200% limit
-                if (DotDuration > 0)
-                {
-                    if (DotDuration > 30000) DotDuration = 30000;
-                    if (!IsChanneledSpell(spellProto)) DotFactor = DotDuration / 15000.0f;
-                    uint32 x = 0;
-                    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; j++)
-                    {
-                        if (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && (
-                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_DAMAGE ||
-                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
-                        {
-                            x = j;
-                            break;
-                        }
-                    }
-                    int32 DotTicks = 6;
-                    if (spellProto->EffectAmplitude[x] != 0)
-                        DotTicks = DotDuration / spellProto->EffectAmplitude[x];
-                    if (DotTicks)
-                    {
-                        DoneAdvertisedBenefit = DoneAdvertisedBenefit * int32(stack) / DotTicks;
-                        TakenAdvertisedBenefit = TakenAdvertisedBenefit * int32(stack) / DotTicks;
-                    }
-                }
-            }
-            // Distribute Damage over multiple effects, reduce by AoE
-            CastingTime = GetCastingTimeForBonus(spellProto, damagetype, CastingTime);
-            // 50% for damage and healing spells for leech spells from damage bonus and 0% from healing
-            for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-            {
-                if (spellProto->Effect[j] == SPELL_EFFECT_HEALTH_LEECH ||
-                    (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
-                {
-                    CastingTime /= 2;
-                    break;
-                }
-            }
-            // As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)
-            coeff = (CastingTime / 3500.0f) * DotFactor * 1.88f;
-        }
-
-        factorMod *= CalculateLevelPenalty(spellProto)* stack;
-        TakenTotal += int32(TakenAdvertisedBenefit * coeff * factorMod);
-        if (Player* modOwner = GetSpellModOwner())
-        {
-            coeff *= 100.0f;
-            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
-            coeff /= 100.0f;
-        }
-        DoneTotal += int32(DoneAdvertisedBenefit * coeff * factorMod);
-    }
-
-    // use float as more appropriate for negative values and percent applying
-    float heal = (int32(healamount) + DoneTotal) * DoneTotalMod;
-    // apply spellmod to Done amount
-    if (Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
-
-    // Nourish cast
-    if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[1] & 0x2000000)
-    {
-        // Rejuvenation, Regrowth, Lifebloom, or Wild Growth
-        if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x50, 0x4000010, 0))
-            //increase healing by 20%
-            TakenTotalMod *= 1.2f;
-    }
-
-    // Taken mods
-
-    // Healing Wave
-    if (spellProto->SpellFamilyName == SPELLFAMILY_SHAMAN && spellProto->SpellFamilyFlags[0] & 0x40)
-    {
-        // Search for Healing Way on Victim
-        if (AuraEffect const* HealingWay = pVictim->GetAuraEffect(29203, 0))
-            TakenTotalMod *= (HealingWay->GetAmount() + 100.0f) / 100.0f;
-    }
-
-    // Tenacity increase healing % taken
-    if (AuraEffect const* Tenacity = pVictim->GetAuraEffect(58549, 0))
-        TakenTotalMod *= (Tenacity->GetAmount() + 100.0f) / 100.0f;
-
-
-    // Healing taken percent
-    float minval = (float)pVictim->GetMaxNegativeAuraModifier(SPELL_AURA_MOD_HEALING_PCT);
-    if (minval)
-        TakenTotalMod *= (100.0f + minval) / 100.0f;
-
-    float maxval = (float)pVictim->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HEALING_PCT);
-    if (maxval)
-        TakenTotalMod *= (100.0f + maxval) / 100.0f;
-
-    if (damagetype == DOT)
-    {
-        // Healing over time taken percent
-        float minval_hot = (float)pVictim->GetMaxNegativeAuraModifier(SPELL_AURA_MOD_HOT_PCT);
-        if (minval_hot)
-            TakenTotalMod *= (100.0f + minval_hot) / 100.0f;
-
-        float maxval_hot = (float)pVictim->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HOT_PCT);
-        if (maxval_hot)
-            TakenTotalMod *= (100.0f + maxval_hot) / 100.0f;
-    }
-
-    AuraEffectList const& mHealingGet= pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_RECEIVED);
-    for (AuraEffectList::const_iterator i = mHealingGet.begin(); i != mHealingGet.end(); ++i)
-        if (GetGUID() == (*i)->GetCasterGUID() && (*i)->IsAffectedOnSpell(spellProto))
-            TakenTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
-
-    heal = (int32(heal) + TakenTotal) * TakenTotalMod;
-
-    return uint32(std::max(heal, 0.0f));
-}
-
-int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
-{
-    int32 AdvertisedBenefit = 0;
-
-    AuraEffectList const& mHealingDone = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE);
-    for (AuraEffectList::const_iterator i = mHealingDone.begin(); i != mHealingDone.end(); ++i)
-        if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetAmount();
-
-    // Healing bonus of spirit, intellect and strength
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        // Base value
-        AdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
-
-        // Healing bonus from stats
-        AuraEffectList const& mHealingDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT);
-        for (AuraEffectList::const_iterator i = mHealingDoneOfStatPercent.begin(); i != mHealingDoneOfStatPercent.end(); ++i)
-        {
-            // stat used dependent from misc value (stat index)
-            Stats usedStat = Stats((*i)->GetSpellProto()->EffectMiscValue[(*i)->GetEffIndex()]);
-            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetAmount() / 100.0f);
-        }
-
-        // ... and attack power
-        AuraEffectList const& mHealingDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);
-        for (AuraEffectList::const_iterator i = mHealingDonebyAP.begin(); i != mHealingDonebyAP.end(); ++i)
-            if ((*i)->GetMiscValue() & schoolMask)
-                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetAmount() / 100.0f);
-    }
-    return AdvertisedBenefit;
-}
-
-int32 Unit::SpellBaseHealingBonusForVictim(SpellSchoolMask schoolMask, Unit *pVictim)
-{
-    int32 AdvertisedBenefit = 0;
-    AuraEffectList const& mDamageTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_HEALING);
-    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
-        if (((*i)->GetMiscValue() & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetAmount();
-    return AdvertisedBenefit;
-}
-
-bool Unit::IsImmunedToDamage(SpellSchoolMask shoolMask)
-{
-    //If m_immuneToSchool type contain this school type, IMMUNE damage.
-    SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
-    for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
-        if (itr->type & shoolMask)
-            return true;
-
-    //If m_immuneToDamage type contain magic, IMMUNE damage.
-    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];
-    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)
-        if (itr->type & shoolMask)
-            return true;
-
-    return false;
-}
-
-bool Unit::IsImmunedToDamage(SpellEntry const* spellInfo)
-{
-    if (spellInfo->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return false;
-
-    uint32 shoolMask = GetSpellSchoolMask(spellInfo);
-    if (spellInfo->Id != 42292 && spellInfo->Id !=59752)
-    {
-        //If m_immuneToSchool type contain this school type, IMMUNE damage.
-        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
-        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
-            if (itr->type & shoolMask && !CanSpellPierceImmuneAura(spellInfo, sSpellStore.LookupEntry(itr->spellId)))
-                return true;
-    }
-
-    //If m_immuneToDamage type contain magic, IMMUNE damage.
-    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];
-    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)
-        if (itr->type & shoolMask)
-            return true;
-
-    return false;
-}
-
-bool Unit::IsImmunedToSpell(SpellEntry const* spellInfo)
-{
-    if (!spellInfo)
-        return false;
-
-    // Single spell immunity.
-    SpellImmuneList const& idList = m_spellImmune[IMMUNITY_ID];
-    for (SpellImmuneList::const_iterator itr = idList.begin(); itr != idList.end(); ++itr)
-        if (itr->type == spellInfo->Id)
-            return true;
-
-    if (spellInfo->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return false;
-
-    if (spellInfo->Dispel)
-    {
-        SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
-        for (SpellImmuneList::const_iterator itr = dispelList.begin(); itr != dispelList.end(); ++itr)
-            if (itr->type == spellInfo->Dispel)
-                return true;
-    }
-
-    if (spellInfo->Mechanic)
-    {
-        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];
-        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)
-            if (itr->type == spellInfo->Mechanic)
-                return true;
-    }
-
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        // State/effect immunities applied by aura expect full spell immunity
-        // Ignore effects with mechanic, they are supposed to be checked separately
-        if (!spellInfo->EffectMechanic[i])
-            if (IsImmunedToSpellEffect(spellInfo, i))
-                return true;
-    }
-
-    if (spellInfo->Id != 42292 && spellInfo->Id !=59752)
-    {
-        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
-        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
-            if ((itr->type & GetSpellSchoolMask(spellInfo))
-                && !(IsPositiveSpell(itr->spellId) && IsPositiveSpell(spellInfo->Id))
-                && !CanSpellPierceImmuneAura(spellInfo, sSpellStore.LookupEntry(itr->spellId)))
-                return true;
-    }
-
-    return false;
-}
-
-bool Unit::IsImmunedToSpellEffect(SpellEntry const* spellInfo, uint32 index) const
-{
-    if (!spellInfo)
-        return false;
-    //If m_immuneToEffect type contain this effect type, IMMUNE effect.
-    uint32 effect = spellInfo->Effect[index];
-    SpellImmuneList const& effectList = m_spellImmune[IMMUNITY_EFFECT];
-    for (SpellImmuneList::const_iterator itr = effectList.begin(); itr != effectList.end(); ++itr)
-        if (itr->type == effect)
-            return true;
-
-    if (uint32 mechanic = spellInfo->EffectMechanic[index])
-    {
-        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];
-        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)
-            if (itr->type == mechanic)
-                return true;
-    }
-
-    if (uint32 aura = spellInfo->EffectApplyAuraName[index])
-    {
-        SpellImmuneList const& list = m_spellImmune[IMMUNITY_STATE];
-        for (SpellImmuneList::const_iterator itr = list.begin(); itr != list.end(); ++itr)
-            if (itr->type == aura)
-                return true;
-        // Check for immune to application of harmful magical effects
-        AuraEffectList const& immuneAuraApply = GetAuraEffectsByType(SPELL_AURA_MOD_IMMUNE_AURA_APPLY_SCHOOL);
-        for (AuraEffectList::const_iterator iter = immuneAuraApply.begin(); iter != immuneAuraApply.end(); ++iter)
-            if (spellInfo->Dispel == DISPEL_MAGIC &&                                      // Magic debuff
-                ((*iter)->GetMiscValue() & GetSpellSchoolMask(spellInfo)) &&  // Check school
-                !IsPositiveEffect(spellInfo->Id, index))                                  // Harmful
-                return true;
-    }
-
-    return false;
-}
-
-bool Unit::IsDamageToThreatSpell(SpellEntry const * spellInfo) const
-{
-    if (!spellInfo)
-        return false;
-
-    switch(spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_WARLOCK:
-            if (spellInfo->SpellFamilyFlags[0] == 0x100) // Searing Pain
-                return true;
-            break;
-        case SPELLFAMILY_SHAMAN:
-            if (spellInfo->SpellFamilyFlags[0] == SPELLFAMILYFLAG_SHAMAN_FROST_SHOCK)
-                return true;
-            break;
-        case SPELLFAMILY_DEATHKNIGHT:
-            if (spellInfo->SpellFamilyFlags[1] == 0x20000000) // Rune Strike
-                return true;
-            break;
-    }
-
-    return false;
-}
-
-void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage, WeaponAttackType attType, SpellEntry const *spellProto)
-{
-    if (!pVictim)
-        return;
-
-    if (*pdamage == 0)
-        return;
-
-    uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
-
-    // Taken/Done fixed damage bonus auras
-    int32 DoneFlatBenefit = 0;
-    int32 TakenFlatBenefit = 0;
-
-    // ..done (for creature type by mask) in taken
-    AuraEffectList const& mDamageDoneCreature = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
-    for (AuraEffectList::const_iterator i = mDamageDoneCreature.begin(); i != mDamageDoneCreature.end(); ++i)
-        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
-            DoneFlatBenefit += (*i)->GetAmount();
-
-    // ..done
-    // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage
-
-    // ..done (base at attack power for marked target and base at attack power for creature type)
-    int32 APbonus = 0;
-
-    if (attType == RANGED_ATTACK)
-    {
-        APbonus += pVictim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
-
-        // ..done (base at attack power and creature type)
-        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);
-        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
-            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
-                APbonus += (*i)->GetAmount();
-    }
-    else
-    {
-        APbonus += pVictim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS);
-
-        // ..done (base at attack power and creature type)
-        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);
-        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
-            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
-                APbonus += (*i)->GetAmount();
-    }
-
-    if (APbonus != 0)                                       // Can be negative
-    {
-        bool normalized = false;
-        if (spellProto)
-            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-                if (spellProto->Effect[i] == SPELL_EFFECT_NORMALIZED_WEAPON_DMG)
-                {
-                    normalized = true;
-                    break;
-                }
-        DoneFlatBenefit += int32(APbonus/14.0f * GetAPMultiplier(attType,normalized));
-    }
-
-    // ..taken
-    AuraEffectList const& mDamageTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
-    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
-        if ((*i)->GetMiscValue() & GetMeleeDamageSchoolMask())
-            TakenFlatBenefit += (*i)->GetAmount();
-
-    if (attType != RANGED_ATTACK)
-        TakenFlatBenefit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
-    else
-        TakenFlatBenefit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN);
-
-    // Done/Taken total percent damage auras
-    float DoneTotalMod = 1.0f;
-    float TakenTotalMod = 1.0f;
-
-    // ..done
-    // SPELL_AURA_MOD_DAMAGE_PERCENT_DONE included in weapon damage
-    // SPELL_AURA_MOD_OFFHAND_DAMAGE_PCT  included in weapon damage
-
-    // SPELL_AURA_MOD_DAMAGE_PERCENT_DONE for non-physical spells like Scourge Strike, Frost Strike, this is NOT included in weapon damage
-    if (spellProto)
-        if (GetSpellSchoolMask(spellProto) != SPELL_SCHOOL_MASK_NORMAL)
-        {
-            AuraEffectList const &mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
-            for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
-                if (((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto)) && !((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL))
-                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-        }
-
-    AuraEffectList const &mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
-    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
-        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
-            DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-
-    // bonus against aurastate
-    AuraEffectList const &mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
-    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
-        if (pVictim->HasAuraState(AuraState((*i)->GetMiscValue())))
-            DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
-
-    // done scripted mod (take it from owner)
-    Unit * owner = GetOwner() ? GetOwner() : this;
-    AuraEffectList const &mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
-    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
-    {
-        if (!(*i)->IsAffectedOnSpell(spellProto))
-            continue;
-
-        switch ((*i)->GetMiscValue())
-        {
-            // Tundra Stalker
-            // Merciless Combat
-            case 7277:
-            {
-                // Merciless Combat
-                if ((*i)->GetSpellProto()->SpellIconID == 2656)
-                {
-                    if (!pVictim->HealthAbovePct(35))
-                        DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
-                }
-                // Tundra Stalker
-                else
-                {
-                    // Frost Fever (target debuff)
-                    if (pVictim->HasAura(55095))
-                        DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-                }
-                break;
-            }
-            // Rage of Rivendare
-            case 7293:
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0,0x02000000,0))
-                    if (SpellChainNode const *chain = sSpellMgr.GetSpellChainNode((*i)->GetId()))
-                        DoneTotalMod *= (chain->rank * 2.0f + 100.0f)/100.0f;
-                break;
-            }
-            // Marked for Death
-            case 7598:
-            case 7599:
-            case 7600:
-            case 7601:
-            case 7602:
-            {
-                if (pVictim->GetAuraEffect(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400, 0, 0))
-                    DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
-                break;
-            }
-        }
-    }
-
-    // Custom scripted damage
-    if (spellProto)
-        switch(spellProto->SpellFamilyName)
-        {
-            case SPELLFAMILY_DEATHKNIGHT:
-                // Glacier Rot
-                if (spellProto->SpellFamilyFlags[0] & 0x2 || spellProto->SpellFamilyFlags[1] & 0x6)
-                    if (AuraEffect * aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 196, 0))
-                        if (pVictim->GetDiseasesByCaster(owner->GetGUID()) > 0)
-                            DoneTotalMod *= (100.0f + aurEff->GetAmount()) / 100.0f;
-            break;
-        }
-
-    // ..taken
-    AuraEffectList const& mModDamagePercentTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
-    for (AuraEffectList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
-        if ((*i)->GetMiscValue() & GetMeleeDamageSchoolMask())
-            TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-
-    // From caster spells
-    AuraEffectList const& mOwnerTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
-    for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
-        if ((*i)->GetCasterGUID() == GetGUID() && (*i)->IsAffectedOnSpell(spellProto))
-            TakenTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
-
-    // .. taken pct (special attacks)
-    if (spellProto)
-    {
-        // Mod damage from spell mechanic
-        uint32 mechanicMask = GetAllSpellMechanicMask(spellProto);
-
-        // Shred, Maul - "Effects which increase Bleed damage also increase Shred damage"
-        if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[0] & 0x00008800)
-            mechanicMask |= (1<<MECHANIC_BLEED);
-
-        if (mechanicMask)
-        {
-            AuraEffectList const& mDamageDoneMechanic = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
-            for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
-                if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))
-                    TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-        }
-    }
-
-    // .. taken pct: dummy auras
-    AuraEffectList const& mDummyAuras = pVictim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
-    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
-    {
-        switch((*i)->GetSpellProto()->SpellIconID)
-        {
-            //Cheat Death
-            case 2109:
-                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
-                {
-                    if (pVictim->GetTypeId() != TYPEID_PLAYER)
-                        continue;
-                    float mod = pVictim->ToPlayer()->GetRatingBonusValue(CR_CRIT_TAKEN_MELEE)*(-8.0f);
-                    if (mod < (*i)->GetAmount())
-                        mod = (float)(*i)->GetAmount();
-                    TakenTotalMod *= (mod+100.0f)/100.0f;
-                }
-                break;
-            // Blessing of Sanctuary
-            // Greater Blessing of Sanctuary
-            case 19:
-            case 1804:
-            {
-                if ((*i)->GetSpellProto()->SpellFamilyName != SPELLFAMILY_PALADIN)
-                    continue;
-
-                if ((*i)->GetMiscValue() & (spellProto ? GetSpellSchoolMask(spellProto) : 0))
-                    TakenTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
-                break;
-            }
-            // Ebon Plague
-            case 1933:
-                if ((*i)->GetMiscValue() & (spellProto ? GetSpellSchoolMask(spellProto) : 0))
-                    TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-                break;
-        }
-    }
-
-    // .. taken pct: class scripts
-    AuraEffectList const& mclassScritAuras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
-    for (AuraEffectList::const_iterator i = mclassScritAuras.begin(); i != mclassScritAuras.end(); ++i)
-    {
-        switch((*i)->GetMiscValue())
-        {
-            case 6427: case 6428:                           // Dirty Deeds
-                if (pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))
-                {
-                    AuraEffect* eff0 = (*i)->GetBase()->GetEffect(0);
-                    if (!eff0 || (*i)->GetEffIndex() != 1)
-                    {
-                        sLog.outError("Spell structure of DD (%u) changed.",(*i)->GetId());
-                        continue;
-                    }
-
-                    // effect 0 have expected value but in negative state
-                    TakenTotalMod *= (-eff0->GetAmount()+100.0f)/100.0f;
-                }
-                break;
-        }
-    }
-
-    if (attType != RANGED_ATTACK)
-    {
-        AuraEffectList const& mModMeleeDamageTakenPercent = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
-        for (AuraEffectList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-    }
-    else
-    {
-        AuraEffectList const& mModRangedDamageTakenPercent = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
-        for (AuraEffectList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)
-            TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
-    }
-
-    float tmpDamage = float(int32(*pdamage) + DoneFlatBenefit) * DoneTotalMod;
-
-    // apply spellmod to Done damage
-    if (spellProto)
-        if (Player* modOwner = GetSpellModOwner())
-            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_DAMAGE, tmpDamage);
-
-    tmpDamage = (tmpDamage + TakenFlatBenefit)*TakenTotalMod;
-
-    // bonus result can be negative
-    *pdamage = uint32(std::max(tmpDamage, 0.0f));
-}
-
-void Unit::ApplySpellImmune(uint32 spellId, uint32 op, uint32 type, bool apply)
-{
-    if (apply)
-    {
-        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(), next; itr != m_spellImmune[op].end(); itr = next)
-        {
-            next = itr; ++next;
-            if (itr->type == type)
-            {
-                m_spellImmune[op].erase(itr);
-                next = m_spellImmune[op].begin();
-            }
-        }
-        SpellImmune Immune;
-        Immune.spellId = spellId;
-        Immune.type = type;
-        m_spellImmune[op].push_back(Immune);
-    }
-    else
-    {
-        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(); itr != m_spellImmune[op].end(); ++itr)
-        {
-            if (itr->spellId == spellId)
-            {
-                m_spellImmune[op].erase(itr);
-                break;
-            }
-        }
-    }
-
-}
-
-void Unit::ApplySpellDispelImmunity(const SpellEntry * spellProto, DispelType type, bool apply)
-{
-    ApplySpellImmune(spellProto->Id,IMMUNITY_DISPEL, type, apply);
-
-    if (apply && spellProto->AttributesEx & SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY)
-    {
-        // Create dispel mask by dispel type
-        uint32 dispelMask = GetDispellMask(type);
-        // Dispel all existing auras vs current dispel type
-        AuraApplicationMap& auras = GetAppliedAuras();
-        for (AuraApplicationMap::iterator itr = auras.begin(); itr != auras.end();)
-        {
-            SpellEntry const* spell = itr->second->GetBase()->GetSpellProto();
-            if ((1<<spell->Dispel) & dispelMask)
-            {
-                // Dispel aura
-                RemoveAura(itr);
-            }
-            else
-                ++itr;
-        }
-    }
-}
-
-float Unit::GetWeaponProcChance() const
-{
-    // normalized proc chance for weapon attack speed
-    // (odd formula...)
-    if (isAttackReady(BASE_ATTACK))
-        return (GetAttackTime(BASE_ATTACK) * 1.8f / 1000.0f);
-    else if (haveOffhandWeapon() && isAttackReady(OFF_ATTACK))
-        return (GetAttackTime(OFF_ATTACK) * 1.6f / 1000.0f);
-    return 0;
-}
-
-float Unit::GetPPMProcChance(uint32 WeaponSpeed, float PPM, const SpellEntry * spellProto) const
-{
-    // proc per minute chance calculation
-    if (PPM <= 0) return 0.0f;
-    // Apply chance modifer aura
-    if (spellProto)
-        if (Player* modOwner = GetSpellModOwner())
-            modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_PROC_PER_MINUTE,PPM);
-
-    return floor((WeaponSpeed * PPM) / 600.0f);   // result is chance in percents (probability = Speed_in_sec * (PPM / 60))
-}
-
-void Unit::Mount(uint32 mount, uint32 VehicleId, uint32 creatureEntry)
-{
-    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOUNT);
-
-    if (mount)
-        SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, mount);
-
-    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);
-
-    // unsummon pet
-    if (Player* plr = ToPlayer())
-    {
-        Pet* pet = plr->GetPet();
-        if (pet)
-        {
-            Battleground *bg = ToPlayer()->GetBattleground();
-            // don't unsummon pet in arena but SetFlag UNIT_FLAG_STUNNED to disable pet's interface
-            if (bg && bg->isArena())
-                pet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
-            else
-                plr->UnsummonPetTemporaryIfAny();
-        }
-
-        if (VehicleId)
-        {
-            if (CreateVehicleKit(VehicleId))
-            {
-                GetVehicleKit()->Reset();
-
-                // mounts can also have accessories
-                GetVehicleKit()->InstallAllAccessories(creatureEntry);
-
-                // Send others that we now have a vehicle
-                WorldPacket data(SMSG_PLAYER_VEHICLE_DATA, GetPackGUID().size()+4);
-                data.appendPackGUID(GetGUID());
-                data << uint32(VehicleId);
-                SendMessageToSet(&data,true);
-
-                data.Initialize(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
-                plr->GetSession()->SendPacket(&data);
-            }
-        }
-    }
-
-}
-
-void Unit::Unmount()
-{
-    if (!IsMounted())
-        return;
-
-    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);
-
-    SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, 0);
-    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);
-
-    // only resummon old pet if the player is already added to a map
-    // this prevents adding a pet to a not created map which would otherwise cause a crash
-    // (it could probably happen when logging in after a previous crash)
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (Pet *pPet = this->ToPlayer()->GetPet())
-        {
-            if (pPet && pPet->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) && !pPet->hasUnitState(UNIT_STAT_STUNNED))
-                pPet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
-        }
-        else
-            this->ToPlayer()->ResummonPetTemporaryUnSummonedIfAny();
-    }
-    if (GetTypeId() == TYPEID_PLAYER && GetVehicleKit())
-    {
-        // Send other players that we are no longer a vehicle
-        WorldPacket data(SMSG_PLAYER_VEHICLE_DATA, 8+4);
-        data.appendPackGUID(GetGUID());
-        data << uint32(0);
-        this->ToPlayer()->SendMessageToSet(&data, true);
-        // Remove vehicle class from player
-        RemoveVehicleKit();
-    }
-}
-
-void Unit::SetInCombatWith(Unit* enemy)
-{
-    Unit* eOwner = enemy->GetCharmerOrOwnerOrSelf();
-    if (eOwner->IsPvP())
-    {
-        SetInCombatState(true,enemy);
-        return;
-    }
-
-    //check for duel
-    if (eOwner->GetTypeId() == TYPEID_PLAYER && eOwner->ToPlayer()->duel)
-    {
-        Unit const* myOwner = GetCharmerOrOwnerOrSelf();
-        if (((Player const*)eOwner)->duel->opponent == myOwner)
-        {
-            SetInCombatState(true,enemy);
-            return;
-        }
-    }
-    SetInCombatState(false,enemy);
-}
-
-void Unit::CombatStart(Unit* target, bool initialAggro)
-{
-    if (initialAggro)
-    {
-        if (!target->IsStandState())
-            target->SetStandState(UNIT_STAND_STATE_STAND);
-
-        if (!target->isInCombat() && target->GetTypeId() != TYPEID_PLAYER
-            && !target->ToCreature()->HasReactState(REACT_PASSIVE) && target->ToCreature()->IsAIEnabled)
-        {
-            target->ToCreature()->AI()->AttackStart(this);
-        }
-
-        SetInCombatWith(target);
-        target->SetInCombatWith(this);
-    }
-    Unit *who = target->GetCharmerOrOwnerOrSelf();
-    if (who->GetTypeId() == TYPEID_PLAYER)
-      SetContestedPvP(who->ToPlayer());
-
-    Player *me = GetCharmerOrOwnerPlayerOrPlayerItself();
-    if (me && who->IsPvP()
-        && (who->GetTypeId() != TYPEID_PLAYER
-        || !me->duel || me->duel->opponent != who))
-    {
-        me->UpdatePvP(true);
-        me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT);
-    }
-}
-
-void Unit::SetInCombatState(bool PvP, Unit* enemy)
-{
-    // only alive units can be in combat
-    if (!isAlive())
-        return;
-
-    if (PvP)
-        m_CombatTimer = 5000;
-
-    if (isInCombat() || hasUnitState(UNIT_STAT_EVADE))
-        return;
-
-    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
-
-    if (GetTypeId() != TYPEID_PLAYER)
-    {
-        // Set home position at place of engaging combat for escorted creatures
-        if ((IsAIEnabled && this->ToCreature()->AI()->IsEscorted()) ||
-            GetMotionMaster()->GetCurrentMovementGeneratorType() == WAYPOINT_MOTION_TYPE ||
-            GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
-            this->ToCreature()->SetHomePosition(GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
-
-        if (enemy)
-        {
-            if (IsAIEnabled)
-            {
-                this->ToCreature()->AI()->EnterCombat(enemy);
-                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);//always remove Out of Combat Non Attackable flag if we enter combat and AI is enabled
-            }
-            if (this->ToCreature()->GetFormation())
-                this->ToCreature()->GetFormation()->MemberAttackStart(this->ToCreature(), enemy);
-        }
-
-        if (isPet())
-        {
-            UpdateSpeed(MOVE_RUN, true);
-            UpdateSpeed(MOVE_SWIM, true);
-            UpdateSpeed(MOVE_FLIGHT, true);
-        }
-    }
-
-    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
-    {
-        (*itr)->SetInCombatState(PvP, enemy);
-        (*itr)->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
-    }
-}
-
-void Unit::ClearInCombat()
-{
-    m_CombatTimer = 0;
-    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
-
-    // Player's state will be cleared in Player::UpdateContestedPvP
-    if (GetTypeId() != TYPEID_PLAYER)
-    {
-        Creature* creature = this->ToCreature();
-        if (creature->GetCreatureInfo() && creature->GetCreatureInfo()->unit_flags & UNIT_FLAG_OOC_NOT_ATTACKABLE)
-            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);//re-apply Out of Combat Non Attackable flag if we leave combat, can be overriden in scripts in EnterEvadeMode()
-
-        clearUnitState(UNIT_STAT_ATTACK_PLAYER);
-        if (HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_TAPPED))
-            SetUInt32Value(UNIT_DYNAMIC_FLAGS, ((Creature*)this)->GetCreatureInfo()->dynamicflags);
-    }
-    else
-        this->ToPlayer()->UpdatePotionCooldown();
-
-    if (GetTypeId() != TYPEID_PLAYER && ((Creature*)this)->isPet())
-    {
-        if (Unit *owner = GetOwner())
-            for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
-                if (owner->GetSpeedRate(UnitMoveType(i)) > GetSpeedRate(UnitMoveType(i)))
-                    SetSpeed(UnitMoveType(i), owner->GetSpeedRate(UnitMoveType(i)), true);
-    }
-    else if (!isCharmed())
-        return;
-
-    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
-}
-
-//TODO: remove this function
-bool Unit::isTargetableForAttack() const
-{
-    return isAttackableByAOE() && !hasUnitState(UNIT_STAT_DIED);
-}
-
-bool Unit::canAttack(Unit const* target, bool force) const
-{
-    ASSERT(target);
-
-    if (force)
-    {
-        if (IsFriendlyTo(target))
-            return false;
-
-        if (GetTypeId()!=TYPEID_PLAYER)
-        {
-            if (isPet())
-            {
-                if (Unit *owner = GetOwner())
-                    if (!(owner->canAttack(target)))
-                        return false;
-            }
-            else if (!IsHostileTo(target))
-                return false;
-        }
-    }
-    else if (!IsHostileTo(target))
-        return false;
-
-    if (!target->isAttackableByAOE() || target->hasUnitState(UNIT_STAT_DIED))
-        return false;
-
-    // shaman totem quests: spell 8898, shaman can detect elementals but elementals cannot see shaman
-    if (m_invisibilityMask || target->m_invisibilityMask)
-        if (!canDetectInvisibilityOf(target) && !target->canDetectInvisibilityOf(this))
-            return false;
-
-    if (target->GetVisibility() == VISIBILITY_GROUP_STEALTH && !canDetectStealthOf(target, GetDistance(target)))
-        return false;
-
-    if (m_vehicle)
-        if (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))
-            return false;
-
-    return true;
-}
-
-bool Unit::isAttackableByAOE(bool requireDeadTarget) const
-{
-    if (isAlive() == requireDeadTarget)
-        return false;
-
-    if (HasFlag(UNIT_FIELD_FLAGS,
-        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE))
-        return false;
-
-    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->isGameMaster())
-        return false;
-
-    return !hasUnitState(UNIT_STAT_UNATTACKABLE);
-}
-
-int32 Unit::ModifyHealth(int32 dVal)
-{
-    int32 gain = 0;
-
-    if (dVal == 0)
-        return 0;
-
-    int32 curHealth = (int32)GetHealth();
-
-    int32 val = dVal + curHealth;
-    if (val <= 0)
-    {
-        SetHealth(0);
-        return -curHealth;
-    }
-
-    int32 maxHealth = (int32)GetMaxHealth();
-
-    if (val < maxHealth)
-    {
-        SetHealth(val);
-        gain = val - curHealth;
-    }
-    else if (curHealth != maxHealth)
-    {
-        SetHealth(maxHealth);
-        gain = maxHealth - curHealth;
-    }
-
-    return gain;
-}
-
-int32 Unit::GetHealthGain(int32 dVal)
-{
-    int32 gain = 0;
-
-    if (dVal == 0)
-        return 0;
-
-    int32 curHealth = (int32)GetHealth();
-
-    int32 val = dVal + curHealth;
-    if (val <= 0)
-    {
-        return -curHealth;
-    }
-
-    int32 maxHealth = (int32)GetMaxHealth();
-
-    if (val < maxHealth)
-        gain = dVal;
-    else if (curHealth != maxHealth)
-        gain = maxHealth - curHealth;
-
-    return gain;
-}
-
-int32 Unit::ModifyPower(Powers power, int32 dVal)
-{
-    int32 gain = 0;
-
-    if (dVal == 0)
-        return 0;
-
-    int32 curPower = (int32)GetPower(power);
-
-    int32 val = dVal + curPower;
-    if (val <= 0)
-    {
-        SetPower(power,0);
-        return -curPower;
-    }
-
-    int32 maxPower = (int32)GetMaxPower(power);
-
-    if (val < maxPower)
-    {
-        SetPower(power,val);
-        gain = val - curPower;
-    }
-    else if (curPower != maxPower)
-    {
-        SetPower(power,maxPower);
-        gain = maxPower - curPower;
-    }
-
-    return gain;
-}
-
-bool Unit::isVisibleForOrDetect(Unit const* u, bool detect, bool inVisibleList, bool is3dDistance) const
-{
-    if (!u || !IsInMap(u))
-        return false;
-
-    return u->canSeeOrDetect(this, detect, inVisibleList, is3dDistance);
-}
-
-bool Unit::canSeeOrDetect(Unit const* /*u*/, bool /*detect*/, bool /*inVisibleList*/, bool /*is3dDistance*/) const
-{
-    return true;
-}
-
-bool Unit::canDetectInvisibilityOf(Unit const* u) const
-{
-    if (m_invisibilityMask & u->m_invisibilityMask) // same group
-        return true;
-    AuraEffectList const& auras = u->GetAuraEffectsByType(SPELL_AURA_MOD_STALKED); // Hunter mark
-    for (AuraEffectList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
-        if ((*iter)->GetCasterGUID() == GetGUID())
-            return true;
-
-    if (uint32 mask = (m_detectInvisibilityMask & u->m_invisibilityMask))
-    {
-        for (uint8 i = 0; i < 10; ++i)
-        {
-            if (((1 << i) & mask) == 0)
-                continue;
-
-            // find invisibility level
-            uint32 invLevel = 0;
-            Unit::AuraEffectList const& iAuras = u->GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY);
-            for (Unit::AuraEffectList::const_iterator itr = iAuras.begin(); itr != iAuras.end(); ++itr)
-                if (uint8((*itr)->GetMiscValue()) == i && int32(invLevel) < (*itr)->GetAmount())
-                    invLevel = (*itr)->GetAmount();
-
-            // find invisibility detect level
-            uint32 detectLevel = 0;
-            if (i == 6 && GetTypeId() == TYPEID_PLAYER)          // special drunk detection case
-            {
-                detectLevel = this->ToPlayer()->GetDrunkValue();
-            }
-            else
-            {
-                Unit::AuraEffectList const& dAuras = GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY_DETECTION);
-                for (Unit::AuraEffectList::const_iterator itr = dAuras.begin(); itr != dAuras.end(); ++itr)
-                    if (uint8((*itr)->GetMiscValue()) == i && int32(detectLevel) < (*itr)->GetAmount())
-                        detectLevel = (*itr)->GetAmount();
-            }
-
-            if (invLevel <= detectLevel)
-                return true;
-        }
-    }
-
-    return false;
-}
-
-bool Unit::canDetectStealthOf(Unit const* target, float distance) const
-{
-    if (hasUnitState(UNIT_STAT_STUNNED))
-        return false;
-    if (distance < 0.24f) //collision
-        return true;
-    if (!HasInArc(M_PI, target)) //behind
-        return false;
-    if (HasAuraType(SPELL_AURA_DETECT_STEALTH))
-        return true;
-
-    AuraEffectList const &auras = target->GetAuraEffectsByType(SPELL_AURA_MOD_STALKED); // Hunter mark
-    for (AuraEffectList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
-        if ((*iter)->GetCasterGUID() == GetGUID())
-            return true;
-
-    //Visible distance based on stealth value (stealth rank 4 300MOD, 10.5 - 3 = 7.5)
-    float visibleDistance = 7.5f;
-    //Visible distance is modified by -Level Diff (every level diff = 1.0f in visible distance)
-    visibleDistance += float(getLevelForTarget(target)) - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH)/5.0f;
-    //-Stealth Mod(positive like Master of Deception) and Stealth Detection(negative like paranoia)
-    //based on wowwiki every 5 mod we have 1 more level diff in calculation
-    visibleDistance += (float)(GetTotalAuraModifier(SPELL_AURA_MOD_DETECT) - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH_LEVEL)) / 5.0f;
-    visibleDistance = visibleDistance > MAX_PLAYER_STEALTH_DETECT_RANGE ? MAX_PLAYER_STEALTH_DETECT_RANGE : visibleDistance;
-
-    return distance < visibleDistance;
-}
-
-void Unit::SetVisibility(UnitVisibility x)
-{
-    m_Visibility = x;
-
-    if (m_Visibility == VISIBILITY_GROUP_STEALTH)
-        DestroyForNearbyPlayers();
-
-    UpdateObjectVisibility();
-}
-
-void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
-{
-    int32 main_speed_mod  = 0;
-    float stack_bonus     = 1.0f;
-    float non_stack_bonus = 1.0f;
-
-    switch(mtype)
-    {
-        // Only apply debuffs
-        case MOVE_FLIGHT_BACK:
-        case MOVE_RUN_BACK:
-        case MOVE_SWIM_BACK:
-            break;
-        case MOVE_WALK:
-            return;
-        case MOVE_RUN:
-        {
-            if (IsMounted()) // Use on mount auras
-            {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
-                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS);
-                non_stack_bonus = (100.0f + GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK))/100.0f;
-            }
-            else
-            {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SPEED);
-                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_SPEED_ALWAYS);
-                non_stack_bonus = (100.0f + GetMaxPositiveAuraModifier(SPELL_AURA_MOD_SPEED_NOT_STACK))/100.0f;
-            }
-            break;
-        }
-        case MOVE_SWIM:
-        {
-            main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SWIM_SPEED);
-            break;
-        }
-        case MOVE_FLIGHT:
-        {
-            if (GetTypeId() == TYPEID_UNIT && IsControlledByPlayer()) // not sure if good for pet
-            {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
-                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS);
-
-                // for some spells this mod is applied on vehicle owner
-                int32 owner_speed_mod = 0;
-
-                if (Unit * owner = GetCharmer())
-                    owner_speed_mod = owner->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
-
-                main_speed_mod = std::max(main_speed_mod, owner_speed_mod);
-            }
-            else if (IsMounted())
-            {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
-                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS);
-            }
-            else             // Use not mount (shapeshift for example) auras (should stack)
-                main_speed_mod  = GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED) + GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
-
-            non_stack_bonus = (100.0f + GetMaxPositiveAuraModifier(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK))/100.0f;
-
-            // Update speed for vehicle if available
-            if (GetTypeId() == TYPEID_PLAYER && GetVehicle())
-                GetVehicleBase()->UpdateSpeed(MOVE_FLIGHT, true);
-            break;
-        }
-        default:
-            sLog.outError("Unit::UpdateSpeed: Unsupported move type (%d)", mtype);
-            return;
-    }
-
-    float bonus = non_stack_bonus > stack_bonus ? non_stack_bonus : stack_bonus;
-
-    // now we ready for speed calculation
-    float speed  = main_speed_mod ? bonus*(100.0f + main_speed_mod)/100.0f : bonus;
-
-    switch(mtype)
-    {
-        case MOVE_RUN:
-        case MOVE_SWIM:
-        case MOVE_FLIGHT:
-        {
-            // Set creature speed rate from CreatureInfo
-            if (GetTypeId() == TYPEID_UNIT)
-                speed *= this->ToCreature()->GetCreatureInfo()->speed_walk;
-
-            // Normalize speed by 191 aura SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED if need
-            // TODO: possible affect only on MOVE_RUN
-            if (int32 normalization = GetMaxPositiveAuraModifier(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED))
-            {
-                // Use speed from aura
-                float max_speed = normalization / (IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
-                if (speed > max_speed)
-                    speed = max_speed;
-            }
-            break;
-        }
-        default:
-            break;
-    }
-
-    // for creature case, we check explicit if mob searched for assistance
-    if (GetTypeId() == TYPEID_UNIT)
-    {
-        if (this->ToCreature()->HasSearchedAssistance())
-            speed *= 0.66f;                                 // best guessed value, so this will be 33% reduction. Based off initial speed, mob can then "run", "walk fast" or "walk".
-    }
-
-    // Apply strongest slow aura mod to speed
-    int32 slow = GetMaxNegativeAuraModifier(SPELL_AURA_MOD_DECREASE_SPEED);
-    if (slow)
-    {
-        speed *=(100.0f + slow)/100.0f;
-        if (float minSpeedMod = (float)GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MINIMUM_SPEED))
-        {
-            float min_speed = minSpeedMod / 100.0f;
-            if (speed < min_speed)
-                speed = min_speed;
-        }
-    }
-    SetSpeed(mtype, speed, forced);
-}
-
-float Unit::GetSpeed(UnitMoveType mtype) const
-{
-    return m_speed_rate[mtype]*(IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
-}
-
-void Unit::SetSpeed(UnitMoveType mtype, float rate, bool forced)
-{
-    if (rate < 0)
-        rate = 0.0f;
-
-    // Update speed only on change
-    if (m_speed_rate[mtype] == rate)
-        return;
-
-    m_speed_rate[mtype] = rate;
-
-    propagateSpeedChange();
-
-    WorldPacket data;
-    if (!forced)
-    {
-        switch(mtype)
-        {
-            case MOVE_WALK:
-                data.Initialize(MSG_MOVE_SET_WALK_SPEED, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_RUN:
-                data.Initialize(MSG_MOVE_SET_RUN_SPEED, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_RUN_BACK:
-                data.Initialize(MSG_MOVE_SET_RUN_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_SWIM:
-                data.Initialize(MSG_MOVE_SET_SWIM_SPEED, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_SWIM_BACK:
-                data.Initialize(MSG_MOVE_SET_SWIM_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_TURN_RATE:
-                data.Initialize(MSG_MOVE_SET_TURN_RATE, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_FLIGHT:
-                data.Initialize(MSG_MOVE_SET_FLIGHT_SPEED, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_FLIGHT_BACK:
-                data.Initialize(MSG_MOVE_SET_FLIGHT_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            case MOVE_PITCH_RATE:
-                data.Initialize(MSG_MOVE_SET_PITCH_RATE, 8+4+2+4+4+4+4+4+4+4);
-                break;
-            default:
-                sLog.outError("Unit::SetSpeed: Unsupported move type (%d), data not sent to client.",mtype);
-                return;
-        }
-
-        data.append(GetPackGUID());
-        data << uint32(0);                                  // movement flags
-        data << uint16(0);                                  // unk flags
-        data << uint32(getMSTime());
-        data << float(GetPositionX());
-        data << float(GetPositionY());
-        data << float(GetPositionZ());
-        data << float(GetOrientation());
-        data << uint32(0);                                  // fall time
-        data << float(GetSpeed(mtype));
-        SendMessageToSet(&data, true);
-    }
-    else
-    {
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            // register forced speed changes for WorldSession::HandleForceSpeedChangeAck
-            // and do it only for real sent packets and use run for run/mounted as client expected
-            ++this->ToPlayer()->m_forced_speed_changes[mtype];
-
-            if (!isInCombat())
-                if (Pet* pet = this->ToPlayer()->GetPet())
-                    pet->SetSpeed(mtype, m_speed_rate[mtype], forced);
-        }
-
-        switch(mtype)
-        {
-            case MOVE_WALK:
-                data.Initialize(SMSG_FORCE_WALK_SPEED_CHANGE, 16);
-                break;
-            case MOVE_RUN:
-                data.Initialize(SMSG_FORCE_RUN_SPEED_CHANGE, 17);
-                break;
-            case MOVE_RUN_BACK:
-                data.Initialize(SMSG_FORCE_RUN_BACK_SPEED_CHANGE, 16);
-                break;
-            case MOVE_SWIM:
-                data.Initialize(SMSG_FORCE_SWIM_SPEED_CHANGE, 16);
-                break;
-            case MOVE_SWIM_BACK:
-                data.Initialize(SMSG_FORCE_SWIM_BACK_SPEED_CHANGE, 16);
-                break;
-            case MOVE_TURN_RATE:
-                data.Initialize(SMSG_FORCE_TURN_RATE_CHANGE, 16);
-                break;
-            case MOVE_FLIGHT:
-                data.Initialize(SMSG_FORCE_FLIGHT_SPEED_CHANGE, 16);
-                break;
-            case MOVE_FLIGHT_BACK:
-                data.Initialize(SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE, 16);
-                break;
-            case MOVE_PITCH_RATE:
-                data.Initialize(SMSG_FORCE_PITCH_RATE_CHANGE, 16);
-                break;
-            default:
-                sLog.outError("Unit::SetSpeed: Unsupported move type (%d), data not sent to client.",mtype);
-                return;
-        }
-        data.append(GetPackGUID());
-        data << (uint32)0;                                  // moveEvent, NUM_PMOVE_EVTS = 0x39
-        if (mtype == MOVE_RUN)
-            data << uint8(0);                               // new 2.1.0
-        data << float(GetSpeed(mtype));
-        SendMessageToSet(&data, true);
-    }
-}
-
-void Unit::SetHover(bool on)
-{
-    if (on)
-        CastSpell(this, 11010, true);
-    else
-        RemoveAurasDueToSpell(11010);
-}
-
-void Unit::setDeathState(DeathState s)
-{
-    // death state needs to be updated before RemoveAllAurasOnDeath() calls HandleChannelDeathItem(..) so that
-    // it can be used to check creation of death items (such as soul shards).
-    DeathState oldDeathState = m_deathState;
-    m_deathState = s;
-
-    if (s != ALIVE && s != JUST_ALIVED)
-    {
-        CombatStop();
-        DeleteThreatList();
-        getHostileRefManager().deleteReferences();
-        ClearComboPointHolders();                           // any combo points pointed to unit lost at it death
-
-        if (IsNonMeleeSpellCasted(false))
-            InterruptNonMeleeSpells(false);
-
-        UnsummonAllTotems();
-        RemoveAllControlled();
-        RemoveAllAurasOnDeath();
-        ExitVehicle();
-    }
-
-    if (s == JUST_DIED)
-    {
-        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, false);
-        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, false);
-        // remove aurastates allowing special moves
-        ClearAllReactives();
-        ClearDiminishings();
-        GetMotionMaster()->Clear(false);
-        GetMotionMaster()->MoveIdle();
-        if (m_vehicleKit)
-            m_vehicleKit->Die();
-        SendMonsterStop(true);
-        //without this when removing IncreaseMaxHealth aura player may stuck with 1 hp
-        //do not why since in IncreaseMaxHealth currenthealth is checked
-        SetHealth(0);
-        SetPower(getPowerType(),0);
-    }
-    else if (s == JUST_ALIVED)
-        RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE); // clear skinnable for creature and player (at battleground)
-
-    if (oldDeathState != ALIVE && s == ALIVE)
-    {
-        // Reset display id on resurection - needed by corpse explosion to cleanup after display change
-        // TODO: fix this
-        if (!HasAuraType(SPELL_AURA_TRANSFORM))
-            SetDisplayId(GetNativeDisplayId());
-    }
-}
-
-/*########################################
-########                          ########
-########       AGGRO SYSTEM       ########
-########                          ########
-########################################*/
-bool Unit::CanHaveThreatList() const
-{
-    // only creatures can have threat list
-    if (GetTypeId() != TYPEID_UNIT)
-        return false;
-
-    // only alive units can have threat list
-    if (!isAlive())
-        return false;
-
-    // totems can not have threat list
-    if (this->ToCreature()->isTotem())
-        return false;
-
-    // vehicles can not have threat list
-    //if (this->ToCreature()->IsVehicle())
-    //    return false;
-
-    // summons can not have a threat list, unless they are controlled by a creature
-    if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && IS_PLAYER_GUID(((Pet*)this)->GetOwnerGUID()))
-        return false;
-
-    return true;
-}
-
-//======================================================================
-
-float Unit::ApplyTotalThreatModifier(float fThreat, SpellSchoolMask schoolMask)
-{
-    if (!HasAuraType(SPELL_AURA_MOD_THREAT) || fThreat < 0)
-        return fThreat;
-
-    SpellSchools school = GetFirstSchoolInMask(schoolMask);
-
-    return fThreat * m_threatModifier[school];
-}
-
-//======================================================================
-
-void Unit::AddThreat(Unit* pVictim, float fThreat, SpellSchoolMask schoolMask, SpellEntry const *threatSpell)
-{
-    // Only mobs can manage threat lists
-    if (CanHaveThreatList())
-        m_ThreatManager.addThreat(pVictim, fThreat, schoolMask, threatSpell);
-}
-
-//======================================================================
-
-void Unit::DeleteThreatList()
-{
-    if (CanHaveThreatList() && !m_ThreatManager.isThreatListEmpty())
-        SendClearThreatListOpcode();
-    m_ThreatManager.clearReferences();
-}
-
-//======================================================================
-
-void Unit::TauntApply(Unit* taunter)
-{
-    ASSERT(GetTypeId() == TYPEID_UNIT);
-
-    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))
-        return;
-
-    if (!CanHaveThreatList())
-        return;
-
-    if (this->ToCreature()->HasReactState(REACT_PASSIVE))
-        return;
-
-    Unit *target = getVictim();
-    if (target && target == taunter)
-        return;
-
-    SetInFront(taunter);
-    if (this->ToCreature()->IsAIEnabled)
-        this->ToCreature()->AI()->AttackStart(taunter);
-
-    //m_ThreatManager.tauntApply(taunter);
-}
-
-//======================================================================
-
-void Unit::TauntFadeOut(Unit *taunter)
-{
-    ASSERT(GetTypeId() == TYPEID_UNIT);
-
-    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))
-        return;
-
-    if (!CanHaveThreatList())
-        return;
-
-    if (this->ToCreature()->HasReactState(REACT_PASSIVE))
-        return;
-
-    Unit *target = getVictim();
-    if (!target || target != taunter)
-        return;
-
-    if (m_ThreatManager.isThreatListEmpty())
-    {
-        if (this->ToCreature()->IsAIEnabled)
-            this->ToCreature()->AI()->EnterEvadeMode();
-        return;
-    }
-
-    //m_ThreatManager.tauntFadeOut(taunter);
-    target = m_ThreatManager.getHostilTarget();
-
-    if (target && target != taunter)
-    {
-        SetInFront(target);
-        if (this->ToCreature()->IsAIEnabled)
-            this->ToCreature()->AI()->AttackStart(target);
-    }
-}
-
-//======================================================================
-
-Unit* Creature::SelectVictim()
-{
-    //function provides main threat functionality
-    //next-victim-selection algorithm and evade mode are called
-    //threat list sorting etc.
-
-    Unit* target = NULL;
-    // First checking if we have some taunt on us
-    const AuraEffectList& tauntAuras = GetAuraEffectsByType(SPELL_AURA_MOD_TAUNT);
-    if (!tauntAuras.empty())
-    {
-        Unit* caster = tauntAuras.back()->GetCaster();
-
-        // The last taunt aura caster is alive an we are happy to attack him
-        if (caster && caster->isAlive())
-            return getVictim();
-        else if (tauntAuras.size() > 1)
-        {
-            // We do not have last taunt aura caster but we have more taunt auras,
-            // so find first available target
-
-            // Auras are pushed_back, last caster will be on the end
-            AuraEffectList::const_iterator aura = --tauntAuras.end();
-            do
-            {
-                --aura;
-                caster = (*aura)->GetCaster();
-                if (caster && caster->IsInMap(this) && canAttack(caster) && caster->isInAccessiblePlaceFor(this->ToCreature()))
-                {
-                    target = caster;
-                    break;
-                }
-            } while (aura != tauntAuras.begin());
-        }
-        else
-            target = getVictim();
-    }
-
-    if (CanHaveThreatList())
-    {
-        if (!target && !m_ThreatManager.isThreatListEmpty())
-            // No taunt aura or taunt aura caster is dead standard target selection
-            target = m_ThreatManager.getHostilTarget();
-    }
-    else if (!HasReactState(REACT_PASSIVE))
-    {
-        // We have player pet probably
-        target = getAttackerForHelper();
-        if (!target && isSummon())
-        {
-            if (Unit * owner = this->ToTempSummon()->GetOwner())
-            {
-                if (owner->isInCombat())
-                    target = owner->getAttackerForHelper();
-                if (!target)
-                {
-                    for (ControlList::const_iterator itr = owner->m_Controlled.begin(); itr != owner->m_Controlled.end(); ++itr)
-                    {
-                        if ((*itr)->isInCombat())
-                        {
-                            target = (*itr)->getAttackerForHelper();
-                            if (target) break;
-                        }
-                    }
-                }
-            }
-        }
-    }
-    else
-        return NULL;
-
-    if (target && _IsTargetAcceptable(target))
-    {
-        SetInFront(target);
-        return target;
-    }
-
-    // last case when creature don't must go to evade mode:
-    // it in combat but attacker not make any damage and not enter to aggro radius to have record in threat list
-    // for example at owner command to pet attack some far away creature
-    // Note: creature not have targeted movement generator but have attacker in this case
-    for (AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
-    {
-        if ((*itr) && !canCreatureAttack(*itr) && (*itr)->GetTypeId() != TYPEID_PLAYER
-        && !(*itr)->ToCreature()->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
-            return NULL;
-    }
-
-    // TODO: a vehicle may eat some mob, so mob should not evade
-    if (GetVehicle())
-        return NULL;
-
-    // search nearby enemy before enter evade mode
-    if (HasReactState(REACT_AGGRESSIVE))
-    {
-        target = SelectNearestTargetInAttackDistance();
-        if (target && _IsTargetAcceptable(target))
-                return target;
-    }
-
-    if (m_invisibilityMask)
-    {
-        Unit::AuraEffectList const& iAuras = GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY);
-        for (Unit::AuraEffectList::const_iterator itr = iAuras.begin(); itr != iAuras.end(); ++itr)
-            if ((*itr)->GetBase()->IsPermanent())
-            {
-                AI()->EnterEvadeMode();
-                break;
-            }
-        return NULL;
-    }
-
-    // enter in evade mode in other case
-    AI()->EnterEvadeMode();
-
-    return NULL;
-}
-
-//======================================================================
-//======================================================================
-//======================================================================
-
-int32 Unit::ApplyEffectModifiers(SpellEntry const* spellProto, uint8 effect_index, int32 value) const
-{
-    if (Player* modOwner = GetSpellModOwner())
-    {
-        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_ALL_EFFECTS, value);
-        switch (effect_index)
-        {
-            case 0:
-                modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_EFFECT1, value);
-                break;
-            case 1:
-                modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_EFFECT2, value);
-                break;
-            case 2:
-                modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_EFFECT3, value);
-                break;
-        }
-    }
-    return value;
-}
-
-// function uses real base points (typically value - 1)
-int32 Unit::CalculateSpellDamage(Unit const* target, SpellEntry const* spellProto, uint8 effect_index, int32 const* basePoints) const
-{
-    return SpellMgr::CalculateSpellEffectAmount(spellProto, effect_index, this, basePoints, target);
-}
-
-int32 Unit::CalcSpellDuration(SpellEntry const* spellProto)
-{
-    uint8 comboPoints = m_movedPlayer ? m_movedPlayer->GetComboPoints() : 0;
-
-    int32 minduration = GetSpellDuration(spellProto);
-    int32 maxduration = GetSpellMaxDuration(spellProto);
-
-    int32 duration;
-
-    if (comboPoints && minduration != -1 && minduration != maxduration)
-        duration = minduration + int32((maxduration - minduration) * comboPoints / 5);
-    else
-        duration = minduration;
-
-    return duration;
-}
-
-int32 Unit::ModSpellDuration(SpellEntry const* spellProto, Unit const* target, int32 duration, bool positive)
-{
-    //don't mod permament auras duration
-    if (duration < 0)
-        return duration;
-
-    //cut duration only of negative effects
-    if (!positive)
-    {
-        int32 mechanic = GetAllSpellMechanicMask(spellProto);
-
-        int32 durationMod;
-        int32 durationMod_always = 0;
-        int32 durationMod_not_stack = 0;
-
-        for (uint8 i = 1; i <= MECHANIC_ENRAGED; ++i)
-        {
-            if (!(mechanic & 1<<i))
-                continue;
-            // Find total mod value (negative bonus)
-            int32 new_durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD, i);
-            // Find max mod (negative bonus)
-            int32 new_durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD_NOT_STACK, i);
-            // Check if mods applied before were weaker
-            if (new_durationMod_always < durationMod_always)
-                durationMod_always = new_durationMod_always;
-            if (new_durationMod_not_stack < durationMod_not_stack)
-                durationMod_not_stack = new_durationMod_not_stack;
-        }
-
-        // Select strongest negative mod
-        if (durationMod_always > durationMod_not_stack)
-            durationMod = durationMod_not_stack;
-        else
-            durationMod = durationMod_always;
-
-        if (durationMod != 0)
-            duration = int32(float(duration) * float(100.0f+durationMod) / 100.0f);
-
-        // there are only negative mods currently
-        durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL, spellProto->Dispel);
-        durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK, spellProto->Dispel);
-
-        durationMod = 0;
-        if (durationMod_always > durationMod_not_stack)
-            durationMod += durationMod_not_stack;
-        else
-            durationMod += durationMod_always;
-
-        if (durationMod != 0)
-            duration = int32(float(duration) * float(100.0f+durationMod) / 100.0f);
-    }
-    else
-    {
-        //else positive mods here, there are no currently
-        //when there will be, change GetTotalAuraModifierByMiscValue to GetTotalPositiveAuraModifierByMiscValue
-
-        // Mixology - duration boost
-        if (target->GetTypeId() == TYPEID_PLAYER)
-        {
-            if (spellProto->SpellFamilyName == SPELLFAMILY_POTION && (
-                sSpellMgr.IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_BATTLE) ||
-                sSpellMgr.IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_GUARDIAN)))
-            {
-                if (target->HasAura(53042) && target->HasSpell(spellProto->EffectTriggerSpell[0]))
-                    duration *= 2;
-            }
-        }
-    }
-
-    // Glyphs which increase duration of selfcasted buffs
-    if (target == this)
-    {
-        switch (spellProto->SpellFamilyName)
-        {
-            case SPELLFAMILY_DRUID:
-                if (spellProto->SpellFamilyFlags[0] & 0x100)
-                {
-                    // Glyph of Thorns
-                    if (AuraEffect * aurEff = GetAuraEffect(57862, 0))
-                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
-                }
-                break;
-            case SPELLFAMILY_PALADIN:
-                if (spellProto->SpellFamilyFlags[0] & 0x00000002)
-                {
-                    // Glyph of Blessing of Might
-                    if (AuraEffect * aurEff = GetAuraEffect(57958, 0))
-                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
-                }
-                else if (spellProto->SpellFamilyFlags[0] & 0x00010000)
-                {
-                    // Glyph of Blessing of Wisdom
-                    if (AuraEffect * aurEff = GetAuraEffect(57979, 0))
-                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
-                }
-                break;
-        }
-    }
-    return duration > 0 ? duration : 0;
-}
-
-void Unit::ModSpellCastTime(SpellEntry const* spellProto, int32 & castTime, Spell * spell)
-{
-    if (!spellProto || castTime < 0)
-        return;
-    //called from caster
-    if (Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CASTING_TIME, castTime, spell);
-
-    if (!(spellProto->Attributes & (SPELL_ATTR_UNK4|SPELL_ATTR_TRADESPELL)) && spellProto->SpellFamilyName)
-        castTime = int32(float(castTime) * GetFloatValue(UNIT_MOD_CAST_SPEED));
-    else if (spellProto->Attributes & SPELL_ATTR_REQ_AMMO && !(spellProto->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG))
-        castTime = int32(float(castTime) * m_modAttackSpeedPct[RANGED_ATTACK]);
-    else if (spellProto->SpellVisual[0] == 3881 && HasAura(67556)) // cooking with Chef Hat.
-        castTime = 500;
-}
-
-DiminishingLevels Unit::GetDiminishing(DiminishingGroup group)
-{
-    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
-    {
-        if (i->DRGroup != group)
-            continue;
-
-        if (!i->hitCount)
-            return DIMINISHING_LEVEL_1;
-
-        if (!i->hitTime)
-            return DIMINISHING_LEVEL_1;
-
-        // If last spell was casted more than 15 seconds ago - reset the count.
-        if (i->stack == 0 && getMSTimeDiff(i->hitTime,getMSTime()) > 15000)
-        {
-            i->hitCount = DIMINISHING_LEVEL_1;
-            return DIMINISHING_LEVEL_1;
-        }
-        // or else increase the count.
-        else
-            return DiminishingLevels(i->hitCount);
-    }
-    return DIMINISHING_LEVEL_1;
-}
-
-void Unit::IncrDiminishing(DiminishingGroup group)
-{
-    // Checking for existing in the table
-    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
-    {
-        if (i->DRGroup != group)
-            continue;
-        if (int32(i->hitCount) < GetDiminishingReturnsMaxLevel(group))
-            i->hitCount += 1;
-        return;
-    }
-    m_Diminishing.push_back(DiminishingReturn(group,getMSTime(),DIMINISHING_LEVEL_2));
-}
-
-float Unit::ApplyDiminishingToDuration(DiminishingGroup group, int32 &duration,Unit* caster,DiminishingLevels Level, int32 limitduration)
-{
-    if (duration == -1 || group == DIMINISHING_NONE || caster->IsFriendlyTo(this))
-        return 1.0f;
-
-    // test pet/charm masters instead pets/charmeds
-    Unit const* targetOwner = GetCharmerOrOwner();
-    Unit const* casterOwner = caster->GetCharmerOrOwner();
-
-    // Duration of crowd control abilities on pvp target is limited by 10 sec. (2.2.0)
-    if (limitduration > 0 && duration > limitduration)
-    {
-        Unit const* target = targetOwner ? targetOwner : this;
-        Unit const* source = casterOwner ? casterOwner : caster;
-
-        if ((target->GetTypeId() == TYPEID_PLAYER
-            || ((Creature*)target)->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)
-            && source->GetTypeId() == TYPEID_PLAYER)
-            duration = limitduration;
-    }
-
-    float mod = 1.0f;
-
-    if (group == DIMINISHING_TAUNT)
-    {
-        if (GetTypeId() == TYPEID_UNIT && (((Creature*)this)->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_TAUNT_DIMINISH))
-        {
-            DiminishingLevels diminish = Level;
-            switch(diminish)
-            {
-                case DIMINISHING_LEVEL_1: break;
-                case DIMINISHING_LEVEL_2: mod = 0.65f; break;
-                case DIMINISHING_LEVEL_3: mod = 0.4225f; break;
-                case DIMINISHING_LEVEL_4: mod = 0.274625f; break;
-                case DIMINISHING_LEVEL_TAUNT_IMMUNE: mod = 0.0f; break;
-                default: break;
-            }
-        }
-    }
-    // Some diminishings applies to mobs too (for example, Stun)
-    else if ((GetDiminishingReturnsGroupType(group) == DRTYPE_PLAYER
-        && ((targetOwner ? (targetOwner->GetTypeId() == TYPEID_PLAYER) : (GetTypeId() == TYPEID_PLAYER))
-        || (GetTypeId() == TYPEID_UNIT && ((Creature*)this)->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)))
-        || GetDiminishingReturnsGroupType(group) == DRTYPE_ALL)
-    {
-        DiminishingLevels diminish = Level;
-        switch(diminish)
-        {
-            case DIMINISHING_LEVEL_1: break;
-            case DIMINISHING_LEVEL_2: mod = 0.5f; break;
-            case DIMINISHING_LEVEL_3: mod = 0.25f; break;
-            case DIMINISHING_LEVEL_IMMUNE: mod = 0.0f; break;
-            default: break;
-        }
-    }
-
-    duration = int32(duration * mod);
-    return mod;
-}
-
-void Unit::ApplyDiminishingAura(DiminishingGroup group, bool apply)
-{
-    // Checking for existing in the table
-    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
-    {
-        if (i->DRGroup != group)
-            continue;
-
-        if (apply)
-            i->stack += 1;
-        else if (i->stack)
-        {
-            i->stack -= 1;
-            // Remember time after last aura from group removed
-            if (i->stack == 0)
-                i->hitTime = getMSTime();
-        }
-        break;
-    }
-}
-
-uint32 Unit::GetSpellMaxRangeForTarget(Unit* target,const SpellRangeEntry * rangeEntry)
-{
-    if (!rangeEntry)
-        return 0;
-    if (rangeEntry->maxRangeHostile == rangeEntry->maxRangeFriend)
-        return uint32(rangeEntry->maxRangeFriend);
-    if (IsHostileTo(target))
-        return uint32(rangeEntry->maxRangeHostile);
-    return uint32(rangeEntry->maxRangeFriend);
-};
-uint32 Unit::GetSpellMinRangeForTarget(Unit* target,const SpellRangeEntry * rangeEntry)
-{
-    if (!rangeEntry)
-        return 0;
-    if (rangeEntry->minRangeHostile == rangeEntry->minRangeFriend)
-        return uint32(rangeEntry->minRangeFriend);
-    if (IsHostileTo(target))
-        return uint32(rangeEntry->minRangeHostile);
-    return uint32(rangeEntry->minRangeFriend);
-};
-uint32 Unit::GetSpellRadiusForTarget(Unit* target,const SpellRadiusEntry * radiusEntry)
-{
-    if (!radiusEntry)
-        return 0;
-    if (radiusEntry->radiusHostile == radiusEntry->radiusFriend)
-        return uint32(radiusEntry->radiusFriend);
-    if (IsHostileTo(target))
-        return uint32(radiusEntry->radiusHostile);
-    return uint32(radiusEntry->radiusFriend);
-};
-
-Unit* Unit::GetUnit(WorldObject& object, uint64 guid)
-{
-    return ObjectAccessor::GetUnit(object,guid);
-}
-
-Player* Unit::GetPlayer(WorldObject& object, uint64 guid)
-{
-    return ObjectAccessor::GetPlayer(object,guid);
-}
-
-Creature* Unit::GetCreature(WorldObject& object, uint64 guid)
-{
-    return object.GetMap()->GetCreature(guid);
-}
-
-bool Unit::isVisibleForInState(Player const* u, bool inVisibleList) const
-{
-    return u->canSeeOrDetect(this, false, inVisibleList, false);
-}
-
-uint32 Unit::GetCreatureType() const
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        SpellShapeshiftEntry const* ssEntry = sSpellShapeshiftStore.LookupEntry(m_form);
-        if (ssEntry && ssEntry->creatureType > 0)
-            return ssEntry->creatureType;
-        else
-            return CREATURE_TYPE_HUMANOID;
-    }
-    else
-        return this->ToCreature()->GetCreatureInfo()->type;
-}
-
-/*#######################################
-########                         ########
-########       STAT SYSTEM       ########
-########                         ########
-#######################################*/
-
-bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, float amount, bool apply)
-{
-    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
-    {
-        sLog.outError("ERROR in HandleStatModifier(): non existed UnitMods or wrong UnitModifierType!");
-        return false;
-    }
-
-    switch (modifierType)
-    {
-        case BASE_VALUE:
-        case TOTAL_VALUE:
-            m_auraModifiersGroup[unitMod][modifierType] += apply ? amount : -amount;
-            break;
-        case BASE_PCT:
-        case TOTAL_PCT:
-            m_auraModifiersGroup[unitMod][modifierType] += (apply ? amount : -amount) / 100.0f;
-            break;
-        default:
-            break;
-    }
-
-    if (!CanModifyStats())
-        return false;
-
-    switch(unitMod)
-    {
-        case UNIT_MOD_STAT_STRENGTH:
-        case UNIT_MOD_STAT_AGILITY:
-        case UNIT_MOD_STAT_STAMINA:
-        case UNIT_MOD_STAT_INTELLECT:
-        case UNIT_MOD_STAT_SPIRIT:         UpdateStats(GetStatByAuraGroup(unitMod));  break;
-
-        case UNIT_MOD_ARMOR:               UpdateArmor();           break;
-        case UNIT_MOD_HEALTH:              UpdateMaxHealth();       break;
-
-        case UNIT_MOD_MANA:
-        case UNIT_MOD_RAGE:
-        case UNIT_MOD_FOCUS:
-        case UNIT_MOD_ENERGY:
-        case UNIT_MOD_HAPPINESS:
-        case UNIT_MOD_RUNE:
-        case UNIT_MOD_RUNIC_POWER:          UpdateMaxPower(GetPowerTypeByAuraGroup(unitMod));          break;
-
-        case UNIT_MOD_RESISTANCE_HOLY:
-        case UNIT_MOD_RESISTANCE_FIRE:
-        case UNIT_MOD_RESISTANCE_NATURE:
-        case UNIT_MOD_RESISTANCE_FROST:
-        case UNIT_MOD_RESISTANCE_SHADOW:
-        case UNIT_MOD_RESISTANCE_ARCANE:   UpdateResistances(GetSpellSchoolByAuraGroup(unitMod));      break;
-
-        case UNIT_MOD_ATTACK_POWER:        UpdateAttackPowerAndDamage();         break;
-        case UNIT_MOD_ATTACK_POWER_RANGED: UpdateAttackPowerAndDamage(true);     break;
-
-        case UNIT_MOD_DAMAGE_MAINHAND:     UpdateDamagePhysical(BASE_ATTACK);    break;
-        case UNIT_MOD_DAMAGE_OFFHAND:      UpdateDamagePhysical(OFF_ATTACK);     break;
-        case UNIT_MOD_DAMAGE_RANGED:       UpdateDamagePhysical(RANGED_ATTACK);  break;
-
-        default:
-            break;
-    }
-
-    return true;
-}
-
-float Unit::GetModifierValue(UnitMods unitMod, UnitModifierType modifierType) const
-{
-    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
-    {
-        sLog.outError("trial to access non existed modifier value from UnitMods!");
-        return 0.0f;
-    }
-
-    if (modifierType == TOTAL_PCT && m_auraModifiersGroup[unitMod][modifierType] <= 0.0f)
-        return 0.0f;
-
-    return m_auraModifiersGroup[unitMod][modifierType];
-}
-
-float Unit::GetTotalStatValue(Stats stat) const
-{
-    UnitMods unitMod = UnitMods(UNIT_MOD_STAT_START + stat);
-
-    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
-        return 0.0f;
-
-    // value = ((base_value * base_pct) + total_value) * total_pct
-    float value  = m_auraModifiersGroup[unitMod][BASE_VALUE] + GetCreateStat(stat);
-    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
-    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
-    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
-
-    return value;
-}
-
-float Unit::GetTotalAuraModValue(UnitMods unitMod) const
-{
-    if (unitMod >= UNIT_MOD_END)
-    {
-        sLog.outError("trial to access non existed UnitMods in GetTotalAuraModValue()!");
-        return 0.0f;
-    }
-
-    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
-        return 0.0f;
-
-    float value = m_auraModifiersGroup[unitMod][BASE_VALUE];
-    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
-    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
-    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
-
-    return value;
-}
-
-SpellSchools Unit::GetSpellSchoolByAuraGroup(UnitMods unitMod) const
-{
-    SpellSchools school = SPELL_SCHOOL_NORMAL;
-
-    switch(unitMod)
-    {
-        case UNIT_MOD_RESISTANCE_HOLY:     school = SPELL_SCHOOL_HOLY;          break;
-        case UNIT_MOD_RESISTANCE_FIRE:     school = SPELL_SCHOOL_FIRE;          break;
-        case UNIT_MOD_RESISTANCE_NATURE:   school = SPELL_SCHOOL_NATURE;        break;
-        case UNIT_MOD_RESISTANCE_FROST:    school = SPELL_SCHOOL_FROST;         break;
-        case UNIT_MOD_RESISTANCE_SHADOW:   school = SPELL_SCHOOL_SHADOW;        break;
-        case UNIT_MOD_RESISTANCE_ARCANE:   school = SPELL_SCHOOL_ARCANE;        break;
-
-        default:
-            break;
-    }
-
-    return school;
-}
-
-Stats Unit::GetStatByAuraGroup(UnitMods unitMod) const
-{
-    Stats stat = STAT_STRENGTH;
-
-    switch(unitMod)
-    {
-        case UNIT_MOD_STAT_STRENGTH:    stat = STAT_STRENGTH;      break;
-        case UNIT_MOD_STAT_AGILITY:     stat = STAT_AGILITY;       break;
-        case UNIT_MOD_STAT_STAMINA:     stat = STAT_STAMINA;       break;
-        case UNIT_MOD_STAT_INTELLECT:   stat = STAT_INTELLECT;     break;
-        case UNIT_MOD_STAT_SPIRIT:      stat = STAT_SPIRIT;        break;
-
-        default:
-            break;
-    }
-
-    return stat;
-}
-
-Powers Unit::GetPowerTypeByAuraGroup(UnitMods unitMod) const
-{
-    switch (unitMod)
-    {
-        case UNIT_MOD_RAGE:        return POWER_RAGE;
-        case UNIT_MOD_FOCUS:       return POWER_FOCUS;
-        case UNIT_MOD_ENERGY:      return POWER_ENERGY;
-        case UNIT_MOD_HAPPINESS:   return POWER_HAPPINESS;
-        case UNIT_MOD_RUNE:        return POWER_RUNE;
-        case UNIT_MOD_RUNIC_POWER: return POWER_RUNIC_POWER;
-        default:
-        case UNIT_MOD_MANA:        return POWER_MANA;
-    }
-}
-
-float Unit::GetTotalAttackPowerValue(WeaponAttackType attType) const
-{
-    if (attType == RANGED_ATTACK)
-    {
-        int32 ap = GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER) + GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER_MODS);
-        if (ap < 0)
-            return 0.0f;
-        return ap * (1.0f + GetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER));
-    }
-    else
-    {
-        int32 ap = GetInt32Value(UNIT_FIELD_ATTACK_POWER) + GetInt32Value(UNIT_FIELD_ATTACK_POWER_MODS);
-        if (ap < 0)
-            return 0.0f;
-        return ap * (1.0f + GetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER));
-    }
-}
-
-float Unit::GetWeaponDamageRange(WeaponAttackType attType ,WeaponDamageRange type) const
-{
-    if (attType == OFF_ATTACK && !haveOffhandWeapon())
-        return 0.0f;
-
-    return m_weaponDamage[attType][type];
-}
-
-void Unit::SetLevel(uint8 lvl)
-{
-    SetUInt32Value(UNIT_FIELD_LEVEL, lvl);
-
-    // group update
-    if (GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->GetGroup())
-        this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_LEVEL);
-}
-
-void Unit::SetHealth(uint32 val)
-{
-    if (getDeathState() == JUST_DIED)
-        val = 0;
-    else if (GetTypeId() == TYPEID_PLAYER && (getDeathState() == DEAD || getDeathState() == DEAD_FALLING))
-        val = 1;
-    else
-    {
-        uint32 maxHealth = GetMaxHealth();
-        if (maxHealth < val)
-            val = maxHealth;
-    }
-
-    SetUInt32Value(UNIT_FIELD_HEALTH, val);
-
-    // group update
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (this->ToPlayer()->GetGroup())
-            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_HP);
-    }
-    else if (this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_HP);
-        }
-    }
-}
-
-void Unit::SetMaxHealth(uint32 val)
-{
-    if (!val)
-        val = 1;
-
-    uint32 health = GetHealth();
-    SetUInt32Value(UNIT_FIELD_MAXHEALTH, val);
-
-    // group update
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (this->ToPlayer()->GetGroup())
-            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_HP);
-    }
-    else if (this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_HP);
-        }
-    }
-
-    if (val < health)
-        SetHealth(val);
-}
-
-void Unit::SetPower(Powers power, uint32 val)
-{
-    if (GetPower(power) == val)
-        return;
-
-    uint32 maxPower = GetMaxPower(power);
-    if (maxPower < val)
-        val = maxPower;
-
-    SetStatInt32Value(UNIT_FIELD_POWER1 + power, val);
-
-    WorldPacket data(SMSG_POWER_UPDATE);
-    data.append(GetPackGUID());
-    data << uint8(power);
-    data << uint32(val);
-    SendMessageToSet(&data, GetTypeId() == TYPEID_PLAYER ? true : false);
-
-    // group update
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (this->ToPlayer()->GetGroup())
-            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
-    }
-    else if (this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
-        }
-
-        // Update the pet's character sheet with happiness damage bonus
-        if (pet->getPetType() == HUNTER_PET && power == POWER_HAPPINESS)
-            pet->UpdateDamagePhysical(BASE_ATTACK);
-    }
-}
-
-void Unit::SetMaxPower(Powers power, uint32 val)
-{
-    uint32 cur_power = GetPower(power);
-    SetStatInt32Value(UNIT_FIELD_MAXPOWER1 + power, val);
-
-    // group update
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (this->ToPlayer()->GetGroup())
-            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
-    }
-    else if (this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
-        }
-    }
-
-    if (val < cur_power)
-        SetPower(power, val);
-}
-
-void Unit::ApplyPowerMod(Powers power, uint32 val, bool apply)
-{
-    ApplyModUInt32Value(UNIT_FIELD_POWER1+power, val, apply);
-
-    // group update
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (this->ToPlayer()->GetGroup())
-            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
-    }
-    else if (this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
-        }
-    }
-}
-
-void Unit::ApplyMaxPowerMod(Powers power, uint32 val, bool apply)
-{
-    ApplyModUInt32Value(UNIT_FIELD_MAXPOWER1+power, val, apply);
-
-    // group update
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        if (this->ToPlayer()->GetGroup())
-            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
-    }
-    else if (this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
-        }
-    }
-}
-
-uint32 Unit::GetCreatePowers(Powers power) const
-{
-    // POWER_FOCUS and POWER_HAPPINESS only have hunter pet
-    switch (power)
-    {
-        case POWER_MANA:      return GetCreateMana();
-        case POWER_RAGE:      return 1000;
-        case POWER_FOCUS:     return (GetTypeId() == TYPEID_PLAYER || !((Creature const*)this)->isPet() || ((Pet const*)this)->getPetType() != HUNTER_PET ? 0 : 100);
-        case POWER_ENERGY:    return 100;
-        case POWER_HAPPINESS: return (GetTypeId() == TYPEID_PLAYER || !((Creature const*)this)->isPet() || ((Pet const*)this)->getPetType() != HUNTER_PET ? 0 : 1050000);
-        case POWER_RUNIC_POWER: return 1000;
-        case POWER_RUNE:      return 0;
-        case POWER_HEALTH:    return 0;
-        default:
-            break;
-    }
-
-    return 0;
-}
-
-void Unit::AddToWorld()
-{
-    if (!IsInWorld())
-    {
-        WorldObject::AddToWorld();
-    }
-}
-
-void Unit::RemoveFromWorld()
-{
-    // cleanup
-    ASSERT(GetGUID());
-
-    if (IsInWorld())
-    {
-        m_duringRemoveFromWorld = true;
-        if (IsVehicle())
-            GetVehicleKit()->Uninstall();
-
-        RemoveCharmAuras();
-        RemoveBindSightAuras();
-        RemoveNotOwnSingleTargetAuras();
-
-        RemoveAllGameObjects();
-        RemoveAllDynObjects();
-
-        ExitVehicle();
-        UnsummonAllTotems();
-        RemoveAllControlled();
-
-        RemoveAreaAurasDueToLeaveWorld();
-
-        if (GetCharmerGUID())
-        {
-            sLog.outCrash("Unit %u has charmer guid when removed from world", GetEntry());
-            ASSERT(false);
-        }
-
-        if (Unit *owner = GetOwner())
-        {
-            if (owner->m_Controlled.find(this) != owner->m_Controlled.end())
-            {
-                sLog.outCrash("Unit %u is in controlled list of %u when removed from world", GetEntry(), owner->GetEntry());
-                ASSERT(false);
-            }
-        }
-
-        WorldObject::RemoveFromWorld();
-        m_duringRemoveFromWorld = false;
-    }
-}
-
-void Unit::CleanupsBeforeDelete(bool finalCleanup)
-{
-    if (IsInWorld())
-        RemoveFromWorld();
-
-    ASSERT(GetGUID());
-
-    //A unit may be in removelist and not in world, but it is still in grid
-    //and may have some references during delete
-    RemoveAllAuras();
-
-    if (finalCleanup)
-        m_cleanupDone = true;
-
-    InterruptNonMeleeSpells(true);
-    m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
-    CombatStop();
-    ClearComboPointHolders();
-    DeleteThreatList();
-    getHostileRefManager().setOnlineOfflineState(false);
-    GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.
-}
-
-void Unit::UpdateCharmAI()
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-        return;
-
-    if (i_disabledAI) // disabled AI must be primary AI
-    {
-        if (!isCharmed())
-        {
-            delete i_AI;
-            i_AI = i_disabledAI;
-            i_disabledAI = NULL;
-        }
-    }
-    else
-    {
-        if (isCharmed())
-        {
-            i_disabledAI = i_AI;
-            if (isPossessed() || IsVehicle())
-                i_AI = new PossessedAI(this->ToCreature());
-            else
-                i_AI = new PetAI(this->ToCreature());
-        }
-    }
-}
-
-CharmInfo* Unit::InitCharmInfo()
-{
-    if (!m_charmInfo)
-        m_charmInfo = new CharmInfo(this);
-
-    return m_charmInfo;
-}
-
-void Unit::DeleteCharmInfo()
-{
-    if (!m_charmInfo)
-        return;
-
-    delete m_charmInfo;
-    m_charmInfo = NULL;
-}
-
-CharmInfo::CharmInfo(Unit* unit)
-: m_unit(unit), m_CommandState(COMMAND_FOLLOW), m_petnumber(0), m_barInit(false),
-  m_isCommandAttack(false), m_isAtStay(false), m_isFollowing(false), m_isReturning(false)
-{
-    for (uint8 i = 0; i < MAX_SPELL_CHARM; ++i)
-        m_charmspells[i].SetActionAndType(0,ACT_DISABLED);
-
-    if (m_unit->GetTypeId() == TYPEID_UNIT)
-    {
-        m_oldReactState = m_unit->ToCreature()->GetReactState();
-        m_unit->ToCreature()->SetReactState(REACT_PASSIVE);
-    }
-
-}
-
-CharmInfo::~CharmInfo()
-{
-    if (m_unit->GetTypeId() == TYPEID_UNIT)
-        if (Creature *pCreature = m_unit->ToCreature())
-            pCreature->SetReactState(m_oldReactState);
-}
-
-void CharmInfo::InitPetActionBar()
-{
-    // the first 3 SpellOrActions are attack, follow and stay
-    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_START - ACTION_BAR_INDEX_START; ++i)
-        SetActionBar(ACTION_BAR_INDEX_START + i,COMMAND_ATTACK - i,ACT_COMMAND);
-
-    // middle 4 SpellOrActions are spells/special attacks/abilities
-    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_END-ACTION_BAR_INDEX_PET_SPELL_START; ++i)
-        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_START + i,0,ACT_PASSIVE);
-
-    // last 3 SpellOrActions are reactions
-    for (uint32 i = 0; i < ACTION_BAR_INDEX_END - ACTION_BAR_INDEX_PET_SPELL_END; ++i)
-        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_END + i,COMMAND_ATTACK - i,ACT_REACTION);
-}
-
-void CharmInfo::InitEmptyActionBar(bool withAttack)
-{
-    if (withAttack)
-        SetActionBar(ACTION_BAR_INDEX_START,COMMAND_ATTACK,ACT_COMMAND);
-    else
-        SetActionBar(ACTION_BAR_INDEX_START,0,ACT_PASSIVE);
-    for (uint32 x = ACTION_BAR_INDEX_START+1; x < ACTION_BAR_INDEX_END; ++x)
-        SetActionBar(x,0,ACT_PASSIVE);
-}
-
-void CharmInfo::InitPossessCreateSpells()
-{
-    InitEmptyActionBar();
-    if (m_unit->GetTypeId() == TYPEID_UNIT)
-    {
-        for (uint32 i = 0; i < CREATURE_MAX_SPELLS; ++i)
-        {
-            uint32 spellId = m_unit->ToCreature()->m_spells[i];
-            SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-            if (spellInfo && spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD)
-                spellId = 0;
-            if (IsPassiveSpell(spellId))
-                m_unit->CastSpell(m_unit, spellId, true);
-            else
-                AddSpellToActionBar(m_unit->ToCreature()->m_spells[i], ACT_PASSIVE);
-        }
-    }
-}
-
-void CharmInfo::InitCharmCreateSpells()
-{
-    if (m_unit->GetTypeId() == TYPEID_PLAYER)                //charmed players don't have spells
-    {
-        InitEmptyActionBar();
-        return;
-    }
-
-    InitPetActionBar();
-
-    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
-    {
-        uint32 spellId = m_unit->ToCreature()->m_spells[x];
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-        if (spellInfo && spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD)
-            spellId = 0;
-
-        if (!spellId)
-        {
-            m_charmspells[x].SetActionAndType(spellId,ACT_DISABLED);
-            continue;
-        }
-
-        if (IsPassiveSpell(spellId))
-        {
-            m_unit->CastSpell(m_unit, spellId, true);
-            m_charmspells[x].SetActionAndType(spellId,ACT_PASSIVE);
-        }
-        else
-        {
-            m_charmspells[x].SetActionAndType(spellId,ACT_DISABLED);
-
-            ActiveStates newstate = ACT_PASSIVE;
-            if (spellInfo)
-            {
-                if (!IsAutocastableSpell(spellId))
-                    newstate = ACT_PASSIVE;
-                else
-                {
-                    bool autocast = false;
-                    for (uint32 i = 0; i < MAX_SPELL_EFFECTS && !autocast; ++i)
-                        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET)
-                            autocast = true;
-
-                    if (autocast)
-                    {
-                        newstate = ACT_ENABLED;
-                        ToggleCreatureAutocast(spellId, true);
-                    }
-                    else
-                        newstate = ACT_DISABLED;
-                }
-            }
-
-            AddSpellToActionBar(spellId, newstate);
-        }
-    }
-}
-
-bool CharmInfo::AddSpellToActionBar(uint32 spell_id, ActiveStates newstate)
-{
-    uint32 first_id = sSpellMgr.GetFirstSpellInChain(spell_id);
-
-    // new spell rank can be already listed
-    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
-    {
-        if (uint32 action = PetActionBar[i].GetAction())
-        {
-            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr.GetFirstSpellInChain(action) == first_id)
-            {
-                PetActionBar[i].SetAction(spell_id);
-                return true;
-            }
-        }
-    }
-
-    // or use empty slot in other case
-    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
-    {
-        if (!PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
-        {
-            SetActionBar(i,spell_id,newstate == ACT_DECIDE ? IsAutocastableSpell(spell_id) ? ACT_DISABLED : ACT_PASSIVE : newstate);
-            return true;
-        }
-    }
-    return false;
-}
-
-bool CharmInfo::RemoveSpellFromActionBar(uint32 spell_id)
-{
-    uint32 first_id = sSpellMgr.GetFirstSpellInChain(spell_id);
-
-    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
-    {
-        if (uint32 action = PetActionBar[i].GetAction())
-        {
-            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr.GetFirstSpellInChain(action) == first_id)
-            {
-                SetActionBar(i,0,ACT_PASSIVE);
-                return true;
-            }
-        }
-    }
-
-    return false;
-}
-
-void CharmInfo::ToggleCreatureAutocast(uint32 spellid, bool apply)
-{
-    if (IsPassiveSpell(spellid))
-        return;
-
-    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
-        if (spellid == m_charmspells[x].GetAction())
-            m_charmspells[x].SetType(apply ? ACT_ENABLED : ACT_DISABLED);
-}
-
-void CharmInfo::SetPetNumber(uint32 petnumber, bool statwindow)
-{
-    m_petnumber = petnumber;
-    if (statwindow)
-        m_unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, m_petnumber);
-    else
-        m_unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, 0);
-}
-
-void CharmInfo::LoadPetActionBar(const std::string& data)
-{
-    InitPetActionBar();
-
-    Tokens tokens = StrSplit(data, " ");
-
-    if (tokens.size() != (ACTION_BAR_INDEX_END-ACTION_BAR_INDEX_START)*2)
-        return;                                             // non critical, will reset to default
-
-    uint8 index;
-    Tokens::iterator iter;
-    for (iter = tokens.begin(), index = ACTION_BAR_INDEX_START; index < ACTION_BAR_INDEX_END; ++iter, ++index)
-    {
-        // use unsigned cast to avoid sign negative format use at long-> ActiveStates (int) conversion
-        ActiveStates type  = ActiveStates(atol(iter->c_str()));
-        ++iter;
-        uint32 action = uint32(atol(iter->c_str()));
-
-        PetActionBar[index].SetActionAndType(action, type);
-
-        // check correctness
-        if (PetActionBar[index].IsActionBarForSpell())
-        {
-            if (!sSpellStore.LookupEntry(PetActionBar[index].GetAction()))
-                SetActionBar(index, 0, ACT_PASSIVE);
-            else if (!IsAutocastableSpell(PetActionBar[index].GetAction()))
-                SetActionBar(index, PetActionBar[index].GetAction(), ACT_PASSIVE);
-        }
-    }
-}
-
-void CharmInfo::BuildActionBar(WorldPacket* data)
-{
-    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
-        *data << uint32(PetActionBar[i].packedData);
-}
-
-void CharmInfo::SetSpellAutocast(uint32 spell_id, bool state)
-{
-    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
-    {
-        if (spell_id == PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
-        {
-            PetActionBar[i].SetType(state ? ACT_ENABLED : ACT_DISABLED);
-            break;
-        }
-    }
-}
-
-bool Unit::isFrozen() const
-{
-    return HasAuraState(AURA_STATE_FROZEN);
-}
-
-struct ProcTriggeredData
-{
-    ProcTriggeredData(Aura* _aura)
-        : aura(_aura)
-    {
-        effMask = 0;
-        spellProcEvent = NULL;
-    }
-    SpellProcEventEntry const *spellProcEvent;
-    Aura * aura;
-    uint32 effMask;
-};
-
-typedef std::list< ProcTriggeredData > ProcTriggeredList;
-
-// List of auras that CAN be trigger but may not exist in spell_proc_event
-// in most case need for drop charges
-// in some types of aura need do additional check
-// for example SPELL_AURA_MECHANIC_IMMUNITY - need check for mechanic
-bool InitTriggerAuraData()
-{
-    for (uint16 i = 0; i < TOTAL_AURAS; ++i)
-    {
-        isTriggerAura[i]=false;
-        isNonTriggerAura[i] = false;
-        isAlwaysTriggeredAura[i] = false;
-    }
-    isTriggerAura[SPELL_AURA_DUMMY] = true;
-    isTriggerAura[SPELL_AURA_MOD_CONFUSE] = true;
-    isTriggerAura[SPELL_AURA_MOD_THREAT] = true;
-    isTriggerAura[SPELL_AURA_MOD_STUN] = true; // Aura not have charges but need remove him on trigger
-    isTriggerAura[SPELL_AURA_MOD_DAMAGE_DONE] = true;
-    isTriggerAura[SPELL_AURA_MOD_DAMAGE_TAKEN] = true;
-    isTriggerAura[SPELL_AURA_MOD_RESISTANCE] = true;
-    isTriggerAura[SPELL_AURA_MOD_STEALTH] = true;
-    isTriggerAura[SPELL_AURA_MOD_FEAR] = true; // Aura not have charges but need remove him on trigger
-    isTriggerAura[SPELL_AURA_MOD_ROOT] = true;
-    isTriggerAura[SPELL_AURA_TRANSFORM] = true;
-    isTriggerAura[SPELL_AURA_REFLECT_SPELLS] = true;
-    isTriggerAura[SPELL_AURA_DAMAGE_IMMUNITY] = true;
-    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL] = true;
-    isTriggerAura[SPELL_AURA_PROC_TRIGGER_DAMAGE] = true;
-    isTriggerAura[SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK] = true;
-    isTriggerAura[SPELL_AURA_SCHOOL_ABSORB] = true; // Savage Defense untested
-    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT] = true;
-    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL] = true;
-    isTriggerAura[SPELL_AURA_REFLECT_SPELLS_SCHOOL] = true;
-    isTriggerAura[SPELL_AURA_MECHANIC_IMMUNITY] = true;
-    isTriggerAura[SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN] = true;
-    isTriggerAura[SPELL_AURA_SPELL_MAGNET] = true;
-    isTriggerAura[SPELL_AURA_MOD_ATTACK_POWER] = true;
-    isTriggerAura[SPELL_AURA_ADD_CASTER_HIT_TRIGGER] = true;
-    isTriggerAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
-    isTriggerAura[SPELL_AURA_MOD_MECHANIC_RESISTANCE] = true;
-    isTriggerAura[SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS] = true;
-    isTriggerAura[SPELL_AURA_MOD_HASTE] = true;
-    isTriggerAura[SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE]=true;
-    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE] = true;
-    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE] = true;
-    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE] = true;
-    isTriggerAura[SPELL_AURA_MOD_DAMAGE_FROM_CASTER] = true;
-    isTriggerAura[SPELL_AURA_MOD_SPELL_CRIT_CHANCE] = true;
-    isTriggerAura[SPELL_AURA_ABILITY_IGNORE_AURASTATE] = true;
-
-    isNonTriggerAura[SPELL_AURA_MOD_POWER_REGEN]=true;
-    isNonTriggerAura[SPELL_AURA_REDUCE_PUSHBACK]=true;
-
-    isAlwaysTriggeredAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
-    isAlwaysTriggeredAura[SPELL_AURA_MOD_FEAR] = true;
-    isAlwaysTriggeredAura[SPELL_AURA_MOD_ROOT] = true;
-    isAlwaysTriggeredAura[SPELL_AURA_MOD_STUN] = true;
-    isAlwaysTriggeredAura[SPELL_AURA_TRANSFORM] = true;
-    isAlwaysTriggeredAura[SPELL_AURA_SPELL_MAGNET] = true;
-    isAlwaysTriggeredAura[SPELL_AURA_SCHOOL_ABSORB] = true;
-    isAlwaysTriggeredAura[SPELL_AURA_MOD_STEALTH] = true;
-
-    return true;
-}
-
-uint32 createProcExtendMask(SpellNonMeleeDamage *damageInfo, SpellMissInfo missCondition)
-{
-    uint32 procEx = PROC_EX_NONE;
-    // Check victim state
-    if (missCondition != SPELL_MISS_NONE)
-        switch (missCondition)
-        {
-            case SPELL_MISS_MISS:    procEx|=PROC_EX_MISS;   break;
-            case SPELL_MISS_RESIST:  procEx|=PROC_EX_RESIST; break;
-            case SPELL_MISS_DODGE:   procEx|=PROC_EX_DODGE;  break;
-            case SPELL_MISS_PARRY:   procEx|=PROC_EX_PARRY;  break;
-            case SPELL_MISS_BLOCK:   procEx|=PROC_EX_BLOCK;  break;
-            case SPELL_MISS_EVADE:   procEx|=PROC_EX_EVADE;  break;
-            case SPELL_MISS_IMMUNE:  procEx|=PROC_EX_IMMUNE; break;
-            case SPELL_MISS_IMMUNE2: procEx|=PROC_EX_IMMUNE; break;
-            case SPELL_MISS_DEFLECT: procEx|=PROC_EX_DEFLECT;break;
-            case SPELL_MISS_ABSORB:  procEx|=PROC_EX_ABSORB; break;
-            case SPELL_MISS_REFLECT: procEx|=PROC_EX_REFLECT;break;
-            default:
-                break;
-        }
-    else
-    {
-        // On block
-        if (damageInfo->blocked)
-            procEx|=PROC_EX_BLOCK;
-        // On absorb
-        if (damageInfo->absorb)
-            procEx|=PROC_EX_ABSORB;
-        // On crit
-        if (damageInfo->HitInfo & SPELL_HIT_TYPE_CRIT)
-            procEx|=PROC_EX_CRITICAL_HIT;
-        else
-            procEx|=PROC_EX_NORMAL_HIT;
-    }
-    return procEx;
-}
-
-void Unit::ProcDamageAndSpellFor(bool isVictim, Unit * pTarget, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellEntry const * procSpell, uint32 damage, SpellEntry const * procAura)
-{
-    // Player is loaded now - do not allow passive spell casts to proc
-    if (GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->GetSession()->PlayerLoading())
-        return;
-    // For melee/ranged based attack need update skills and set some Aura states if victim present
-    if (procFlag & MELEE_BASED_TRIGGER_MASK && pTarget)
-    {
-        // Update skills here for players
-        if (GetTypeId() == TYPEID_PLAYER)
-        {
-            // On melee based hit/miss/resist need update skill (for victim and attacker)
-            if (procExtra&(PROC_EX_NORMAL_HIT|PROC_EX_MISS|PROC_EX_RESIST))
-            {
-                if (pTarget->GetTypeId() != TYPEID_PLAYER && pTarget->GetCreatureType() != CREATURE_TYPE_CRITTER)
-                    this->ToPlayer()->UpdateCombatSkills(pTarget, attType, isVictim);
-            }
-            // Update defence if player is victim and parry/dodge/block
-            else if (isVictim && procExtra&(PROC_EX_DODGE|PROC_EX_PARRY|PROC_EX_BLOCK))
-                this->ToPlayer()->UpdateCombatSkills(pTarget, attType, true);
-        }
-        // If exist crit/parry/dodge/block need update aura state (for victim and attacker)
-        if (procExtra & (PROC_EX_CRITICAL_HIT|PROC_EX_PARRY|PROC_EX_DODGE|PROC_EX_BLOCK))
-        {
-            // for victim
-            if (isVictim)
-            {
-                // if victim and dodge attack
-                if (procExtra&PROC_EX_DODGE)
-                {
-                    //Update AURA_STATE on dodge
-                    if (getClass() != CLASS_ROGUE) // skip Rogue Riposte
-                    {
-                        ModifyAuraState(AURA_STATE_DEFENSE, true);
-                        StartReactiveTimer(REACTIVE_DEFENSE);
-                    }
-                }
-                // if victim and parry attack
-                if (procExtra & PROC_EX_PARRY)
-                {
-                    // For Hunters only Counterattack (skip Mongoose bite)
-                    if (getClass() == CLASS_HUNTER)
-                    {
-                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
-                        StartReactiveTimer(REACTIVE_HUNTER_PARRY);
-                    }
-                    else
-                    {
-                        ModifyAuraState(AURA_STATE_DEFENSE, true);
-                        StartReactiveTimer(REACTIVE_DEFENSE);
-                    }
-                }
-                // if and victim block attack
-                if (procExtra & PROC_EX_BLOCK)
-                {
-                    ModifyAuraState(AURA_STATE_DEFENSE,true);
-                    StartReactiveTimer(REACTIVE_DEFENSE);
-                }
-            }
-            else //For attacker
-            {
-                // Overpower on victim dodge
-                if (procExtra&PROC_EX_DODGE && GetTypeId() == TYPEID_PLAYER && getClass() == CLASS_WARRIOR)
-                {
-                    this->ToPlayer()->AddComboPoints(pTarget, 1);
-                    StartReactiveTimer(REACTIVE_OVERPOWER);
-                }
-            }
-        }
-    }
-
-    ProcTriggeredList procTriggered;
-    // Fill procTriggered list
-    for (AuraApplicationMap::const_iterator itr = GetAppliedAuras().begin(); itr!= GetAppliedAuras().end(); ++itr)
-    {
-        // Do not allow auras to proc from effect triggered by itself
-        if (procAura && procAura->Id == itr->first)
-            continue;
-        ProcTriggeredData triggerData(itr->second->GetBase());
-        // Defensive procs are active on absorbs (so absorption effects are not a hindrance)
-        bool active = (damage > 0) || (procExtra & (PROC_EX_ABSORB|PROC_EX_BLOCK) && isVictim);
-        if (isVictim)
-            procExtra &= ~PROC_EX_INTERNAL_REQ_FAMILY;
-        SpellEntry const* spellProto = itr->second->GetBase()->GetSpellProto();
-        if(!IsTriggeredAtSpellProcEvent(pTarget, triggerData.aura, procSpell, procFlag, procExtra, attType, isVictim, active, triggerData.spellProcEvent))
-            continue;
-
-        // Triggered spells not triggering additional spells
-        bool triggered= !(spellProto->AttributesEx3 & SPELL_ATTR_EX3_CAN_PROC_TRIGGERED) ?
-            (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION)) : false;
-
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (itr->second->HasEffect(i))
-            {
-                AuraEffect * aurEff = itr->second->GetBase()->GetEffect(i);
-                // Skip this auras
-                if (isNonTriggerAura[aurEff->GetAuraType()])
-                    continue;
-                // If not trigger by default and spellProcEvent == NULL - skip
-                if (!isTriggerAura[aurEff->GetAuraType()] && triggerData.spellProcEvent == NULL)
-                    continue;
-                // Some spells must always trigger
-                if (!triggered || isAlwaysTriggeredAura[aurEff->GetAuraType()])
-                    triggerData.effMask |= 1<<i;
-            }
-        }
-        if (triggerData.effMask)
-            procTriggered.push_front(triggerData);
-    }
-
-    // Nothing found
-    if (procTriggered.empty())
-        return;
-
-    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
-        SetCantProc(true);
-
-    // Handle effects proceed this time
-    for (ProcTriggeredList::const_iterator i = procTriggered.begin(); i != procTriggered.end(); ++i)
-    {
-        // look for aura in auras list, it may be removed while proc event processing
-        if (i->aura->IsRemoved())
-            continue;
-
-        bool useCharges= i->aura->GetCharges()>0;
-        bool takeCharges = false;
-        SpellEntry const *spellInfo = i->aura->GetSpellProto();
-        uint32 Id = i->aura->GetId();
-
-        // For players set spell cooldown if need
-        uint32 cooldown = 0;
-        if (GetTypeId() == TYPEID_PLAYER && i->spellProcEvent && i->spellProcEvent->cooldown)
-            cooldown = i->spellProcEvent->cooldown;
-
-        if (spellInfo->AttributesEx3 & SPELL_ATTR_EX3_DISABLE_PROC)
-            SetCantProc(true);
-
-        // This bool is needed till separate aura effect procs are still here
-        bool handled = false;
-        if (HandleAuraProc(pTarget, damage, i->aura, procSpell, procFlag, procExtra, cooldown, &handled))
-        {
-            sLog.outDebug("ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), Id);
-            takeCharges = true;
-        }
-
-        if (!handled)
-        for (uint8 effIndex = 0; effIndex<MAX_SPELL_EFFECTS; ++effIndex)
-        {
-            if (!(i->effMask & (1<<effIndex)))
-                continue;
-
-            AuraEffect *triggeredByAura = i->aura->GetEffect(effIndex);
-            ASSERT(triggeredByAura);
-
-            switch(triggeredByAura->GetAuraType())
-            {
-                case SPELL_AURA_PROC_TRIGGER_SPELL:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: casting spell %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    // Don`t drop charge or add cooldown for not started trigger
-                    if (HandleProcTriggerSpell(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
-                        takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_PROC_TRIGGER_DAMAGE:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: doing %u damage from spell id %u (triggered by %s aura of spell %u)", triggeredByAura->GetAmount() , spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    SpellNonMeleeDamage damageInfo(this, pTarget, spellInfo->Id, spellInfo->SchoolMask);
-                    uint32 damage = SpellDamageBonus(pTarget, spellInfo, triggeredByAura->GetAmount(), SPELL_DIRECT_DAMAGE);
-                    CalculateSpellDamageTaken(&damageInfo, damage, spellInfo);
-                    DealDamageMods(damageInfo.target,damageInfo.damage,&damageInfo.absorb);
-                    SendSpellNonMeleeDamageLog(&damageInfo);
-                    DealSpellDamage(&damageInfo, true);
-                    takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_MANA_SHIELD:
-                case SPELL_AURA_DUMMY:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s dummy aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    if (HandleDummyAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
-                        takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_OBS_MOD_POWER:
-                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    if (HandleObsModEnergyAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN:
-                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    if (HandleModDamagePctTakenAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_MOD_HASTE:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s haste aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    if (HandleHasteAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
-                        takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_OVERRIDE_CLASS_SCRIPTS:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    if (HandleOverrideClassScriptAuraProc(pTarget, damage, triggeredByAura, procSpell, cooldown))
-                        takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)",
-                        (isVictim?"a victim's":"an attacker's"),triggeredByAura->GetId());
-
-                    HandleAuraRaidProcFromChargeWithValue(triggeredByAura);
-                    takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_RAID_PROC_FROM_CHARGE:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)",
-                        (isVictim?"a victim's":"an attacker's"),triggeredByAura->GetId());
-
-                    HandleAuraRaidProcFromCharge(triggeredByAura);
-                    takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE:
-                {
-                    sLog.outDebug("ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-
-                    if (HandleProcTriggerSpell(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
-                        takeCharges = true;
-                    break;
-                }
-                case SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK:
-                    // Skip melee hits or instant cast spells
-                    if (procSpell && GetSpellCastTime(procSpell) != 0)
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_REFLECT_SPELLS_SCHOOL:
-                    // Skip Melee hits and spells ws wrong school
-                    if (procSpell && (triggeredByAura->GetMiscValue() & procSpell->SchoolMask))         // School check
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT:
-                case SPELL_AURA_MOD_POWER_COST_SCHOOL:
-                    // Skip melee hits and spells ws wrong school or zero cost
-                    if (procSpell &&
-                        (procSpell->manaCost != 0 || procSpell->ManaCostPercentage != 0) && // Cost check
-                        (triggeredByAura->GetMiscValue() & procSpell->SchoolMask) == 0)         // School check
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_MECHANIC_IMMUNITY:
-                    // Compare mechanic
-                    if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_MOD_MECHANIC_RESISTANCE:
-                    // Compare mechanic
-                    if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_MOD_DAMAGE_FROM_CASTER:
-                    // Compare casters
-                    if (triggeredByAura->GetCasterGUID() == pTarget->GetGUID())
-                        takeCharges = true;
-                    break;
-                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
-                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s spell crit chance aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
-                    if (procSpell && HandleSpellCritChanceAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
-                        takeCharges = true;
-                    break;
-                // CC Auras which use their amount amount to drop
-                // Are there any more auras which need this?
-                case SPELL_AURA_MOD_CONFUSE:
-                case SPELL_AURA_MOD_FEAR:
-                case SPELL_AURA_MOD_STUN:
-                case SPELL_AURA_MOD_ROOT:
-                case SPELL_AURA_TRANSFORM:
-                {
-                    // chargeable mods are breaking on hit
-                    if (useCharges)
-                        takeCharges = true;
-                    else
-                    {
-                        // Spell own direct damage at apply wont break the CC
-                        if (procSpell && (procSpell->Id == triggeredByAura->GetId()))
-                        {
-                            Aura * aura = triggeredByAura->GetBase();
-                            // called from spellcast, should not have ticked yet
-                            if (aura->GetDuration() == aura->GetMaxDuration())
-                                break;
-                        }
-                        int32 damageLeft = triggeredByAura->GetAmount();
-                        // No damage left
-                        if (damageLeft < int32(damage))
-                            i->aura->Remove();
-                        else
-                            triggeredByAura->SetAmount(damageLeft - damage);
-                    }
-                    break;
-                }
-                //case SPELL_AURA_ADD_FLAT_MODIFIER:
-                //case SPELL_AURA_ADD_PCT_MODIFIER:
-                    // HandleSpellModAuraProc
-                    //break;
-                default:
-                    // nothing do, just charges counter
-                    takeCharges = true;
-                    break;
-            }
-        }
-        // Remove charge (aura can be removed by triggers)
-        if (useCharges && takeCharges)
-            i->aura->DropCharge();
-
-        if (spellInfo->AttributesEx3 & SPELL_ATTR_EX3_DISABLE_PROC)
-            SetCantProc(false);
-    }
-
-    // Cleanup proc requirements
-    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
-        SetCantProc(false);
-}
-
-SpellSchoolMask Unit::GetMeleeDamageSchoolMask() const
-{
-    return SPELL_SCHOOL_MASK_NORMAL;
-}
-
-Player* Unit::GetSpellModOwner() const
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-        return (Player*)this;
-    if (this->ToCreature()->isPet() || this->ToCreature()->isTotem())
-    {
-        Unit* owner = GetOwner();
-        if (owner && owner->GetTypeId() == TYPEID_PLAYER)
-            return (Player*)owner;
-    }
-    return NULL;
-}
-
-///----------Pet responses methods-----------------
-void Unit::SendPetCastFail(uint32 spellid, SpellCastResult msg)
-{
-    if (msg == SPELL_CAST_OK)
-        return;
-
-    Unit *owner = GetCharmerOrOwner();
-    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    WorldPacket data(SMSG_PET_CAST_FAILED, 1 + 4 + 1);
-    data << uint8(0);                                       // cast count?
-    data << uint32(spellid);
-    data << uint8(msg);
-    // uint32 for some reason
-    // uint32 for some reason
-    owner->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-void Unit::SendPetActionFeedback (uint8 msg)
-{
-    Unit* owner = GetOwner();
-    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    WorldPacket data(SMSG_PET_ACTION_FEEDBACK, 1);
-    data << uint8(msg);
-    owner->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-void Unit::SendPetTalk (uint32 pettalk)
-{
-    Unit* owner = GetOwner();
-    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    WorldPacket data(SMSG_PET_ACTION_SOUND, 8 + 4);
-    data << uint64(GetGUID());
-    data << uint32(pettalk);
-    owner->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-void Unit::SendPetAIReaction(uint64 guid)
-{
-    Unit* owner = GetOwner();
-    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    WorldPacket data(SMSG_AI_REACTION, 8 + 4);
-    data << uint64(guid);
-    data << uint32(AI_REACTION_HOSTILE);
-    owner->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-///----------End of Pet responses methods----------
-
-void Unit::StopMoving()
-{
-    clearUnitState(UNIT_STAT_MOVING);
-
-    // send explicit stop packet
-    // rely on vmaps here because for example stormwind is in air
-    //float z = sMapMgr.GetBaseMap(GetMapId())->GetHeight(GetPositionX(), GetPositionY(), GetPositionZ(), true);
-    //if (fabs(GetPositionZ() - z) < 2.0f)
-    //    Relocate(GetPositionX(), GetPositionY(), z);
-    //Relocate(GetPositionX(), GetPositionY(),GetPositionZ());
-
-    SendMonsterStop();
-}
-
-void Unit::SendMovementFlagUpdate()
-{
-    WorldPacket data;
-    BuildHeartBeatMsg(&data);
-    SendMessageToSet(&data, false);
-}
-
-bool Unit::IsSitState() const
-{
-    uint8 s = getStandState();
-    return
-        s == UNIT_STAND_STATE_SIT_CHAIR        || s == UNIT_STAND_STATE_SIT_LOW_CHAIR  ||
-        s == UNIT_STAND_STATE_SIT_MEDIUM_CHAIR || s == UNIT_STAND_STATE_SIT_HIGH_CHAIR ||
-        s == UNIT_STAND_STATE_SIT;
-}
-
-bool Unit::IsStandState() const
-{
-    uint8 s = getStandState();
-    return !IsSitState() && s != UNIT_STAND_STATE_SLEEP && s != UNIT_STAND_STATE_KNEEL;
-}
-
-void Unit::SetStandState(uint8 state)
-{
-    SetByteValue(UNIT_FIELD_BYTES_1, 0, state);
-
-    if (IsStandState())
-       RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_SEATED);
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        WorldPacket data(SMSG_STANDSTATE_UPDATE, 1);
-        data << (uint8)state;
-        this->ToPlayer()->GetSession()->SendPacket(&data);
-    }
-}
-
-bool Unit::IsPolymorphed() const
-{
-    uint32 transformId = getTransForm();
-    if (!transformId)
-        return false;
-
-    const SpellEntry *spellInfo=sSpellStore.LookupEntry(transformId);
-    if (!spellInfo)
-        return false;
-
-    return GetSpellSpecific(spellInfo) == SPELL_SPECIFIC_MAGE_POLYMORPH;
-}
-
-void Unit::SetDisplayId(uint32 modelId)
-{
-    SetUInt32Value(UNIT_FIELD_DISPLAYID, modelId);
-
-    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (!pet->isControlled())
-            return;
-        Unit *owner = GetOwner();
-        if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-            owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MODEL_ID);
-    }
-}
-
-void Unit::ClearComboPointHolders()
-{
-    while (!m_ComboPointHolders.empty())
-    {
-        uint32 lowguid = *m_ComboPointHolders.begin();
-
-        Player* plr = sObjectMgr.GetPlayer(MAKE_NEW_GUID(lowguid, 0, HIGHGUID_PLAYER));
-        if (plr && plr->GetComboTarget() == GetGUID())         // recheck for safe
-            plr->ClearComboPoints();                        // remove also guid from m_ComboPointHolders;
-        else
-            m_ComboPointHolders.erase(lowguid);             // or remove manually
-    }
-}
-
-void Unit::ClearAllReactives()
-{
-    for (uint8 i=0; i < MAX_REACTIVE; ++i)
-        m_reactiveTimer[i] = 0;
-
-    if (HasAuraState(AURA_STATE_DEFENSE))
-        ModifyAuraState(AURA_STATE_DEFENSE, false);
-    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
-        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
-    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->ClearComboPoints();
-}
-
-void Unit::UpdateReactives(uint32 p_time)
-{
-    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
-    {
-        ReactiveType reactive = ReactiveType(i);
-
-        if (!m_reactiveTimer[reactive])
-            continue;
-
-        if (m_reactiveTimer[reactive] <= p_time)
-        {
-            m_reactiveTimer[reactive] = 0;
-
-            switch (reactive)
-            {
-                case REACTIVE_DEFENSE:
-                    if (HasAuraState(AURA_STATE_DEFENSE))
-                        ModifyAuraState(AURA_STATE_DEFENSE, false);
-                    break;
-                case REACTIVE_HUNTER_PARRY:
-                    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
-                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
-                    break;
-                case REACTIVE_OVERPOWER:
-                    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
-                        this->ToPlayer()->ClearComboPoints();
-                    break;
-                default:
-                    break;
-            }
-        }
-        else
-        {
-            m_reactiveTimer[reactive] -= p_time;
-        }
-    }
-}
-
-Unit* Unit::SelectNearbyTarget(float dist) const
-{
-    std::list<Unit *> targets;
-    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(this, this, dist);
-    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(this, targets, u_check);
-    VisitNearbyObject(dist, searcher);
-
-    // remove current target
-    if (getVictim())
-        targets.remove(getVictim());
-
-    // remove not LoS targets
-    for (std::list<Unit *>::iterator tIter = targets.begin(); tIter != targets.end();)
-    {
-        if (!IsWithinLOSInMap(*tIter))
-        {
-            std::list<Unit *>::iterator tIter2 = tIter;
-            ++tIter;
-            targets.erase(tIter2);
-        }
-        else
-            ++tIter;
-    }
-
-    // no appropriate targets
-    if (targets.empty())
-        return NULL;
-
-    // select random
-    uint32 rIdx = urand(0,targets.size()-1);
-    std::list<Unit *>::const_iterator tcIter = targets.begin();
-    for (uint32 i = 0; i < rIdx; ++i)
-        ++tcIter;
-
-    return *tcIter;
-}
-
-void Unit::ApplyAttackTimePercentMod(WeaponAttackType att,float val, bool apply)
-{
-    float remainingTimePct = (float)m_attackTimer[att] / (GetAttackTime(att) * m_modAttackSpeedPct[att]);
-    if (val > 0)
-    {
-        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], val, !apply);
-        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att,val,!apply);
-    }
-    else
-    {
-        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], -val, apply);
-        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att,-val,apply);
-    }
-    m_attackTimer[att] = uint32(GetAttackTime(att) * m_modAttackSpeedPct[att] * remainingTimePct);
-}
-
-void Unit::ApplyCastTimePercentMod(float val, bool apply)
-{
-    if (val > 0)
-        ApplyPercentModFloatValue(UNIT_MOD_CAST_SPEED,val,!apply);
-    else
-        ApplyPercentModFloatValue(UNIT_MOD_CAST_SPEED,-val,apply);
-}
-
-uint32 Unit::GetCastingTimeForBonus(SpellEntry const *spellProto, DamageEffectType damagetype, uint32 CastingTime)
-{
-    // Not apply this to creature casted spells with casttime == 0
-    if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !this->ToCreature()->isPet())
-        return 3500;
-
-    if (CastingTime > 7000) CastingTime = 7000;
-    if (CastingTime < 1500) CastingTime = 1500;
-
-    if (damagetype == DOT && !IsChanneledSpell(spellProto))
-        CastingTime = 3500;
-
-    int32 overTime    = 0;
-    uint8 effects     = 0;
-    bool DirectDamage = false;
-    bool AreaEffect   = false;
-
-    for (uint32 i=0; i<MAX_SPELL_EFFECTS; i++)
-    {
-        switch (spellProto->Effect[i])
-        {
-            case SPELL_EFFECT_SCHOOL_DAMAGE:
-            case SPELL_EFFECT_POWER_DRAIN:
-            case SPELL_EFFECT_HEALTH_LEECH:
-            case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
-            case SPELL_EFFECT_POWER_BURN:
-            case SPELL_EFFECT_HEAL:
-                DirectDamage = true;
-                break;
-            case SPELL_EFFECT_APPLY_AURA:
-                switch (spellProto->EffectApplyAuraName[i])
-                {
-                    case SPELL_AURA_PERIODIC_DAMAGE:
-                    case SPELL_AURA_PERIODIC_HEAL:
-                    case SPELL_AURA_PERIODIC_LEECH:
-                        if (GetSpellDuration(spellProto))
-                            overTime = GetSpellDuration(spellProto);
-                        break;
-                    default:
-                        // -5% per additional effect
-                        ++effects;
-                        break;
-                }
-            default:
-                break;
-        }
-
-        if (IsAreaEffectTarget[spellProto->EffectImplicitTargetA[i]] || IsAreaEffectTarget[spellProto->EffectImplicitTargetB[i]])
-            AreaEffect = true;
-    }
-
-    // Combined Spells with Both Over Time and Direct Damage
-    if (overTime > 0 && CastingTime > 0 && DirectDamage)
-    {
-        // mainly for DoTs which are 3500 here otherwise
-        uint32 OriginalCastTime = GetSpellCastTime(spellProto);
-        if (OriginalCastTime > 7000) OriginalCastTime = 7000;
-        if (OriginalCastTime < 1500) OriginalCastTime = 1500;
-        // Portion to Over Time
-        float PtOT = (overTime / 15000.0f) / ((overTime / 15000.0f) + (OriginalCastTime / 3500.0f));
-
-        if (damagetype == DOT)
-            CastingTime = uint32(CastingTime * PtOT);
-        else if (PtOT < 1.0f)
-            CastingTime  = uint32(CastingTime * (1 - PtOT));
-        else
-            CastingTime = 0;
-    }
-
-    // Area Effect Spells receive only half of bonus
-    if (AreaEffect)
-        CastingTime /= 2;
-
-    // -5% of total per any additional effect
-    for (uint8 i=0; i<effects; ++i)
-    {
-        if (CastingTime > 175)
-        {
-            CastingTime -= 175;
-        }
-        else
-        {
-            CastingTime = 0;
-            break;
-        }
-    }
-
-    return CastingTime;
-}
-
-void Unit::UpdateAuraForGroup(uint8 slot)
-{
-    if (slot >= MAX_AURAS)                        // slot not found, return
-        return;
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        Player* player = (Player*)this;
-        if (player->GetGroup())
-        {
-            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_AURAS);
-            player->SetAuraUpdateMaskForRaid(slot);
-        }
-    }
-    else if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isPet())
-    {
-        Pet *pet = ((Pet*)this);
-        if (pet->isControlled())
-        {
-            Unit *owner = GetOwner();
-            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
-            {
-                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_AURAS);
-                pet->SetAuraUpdateMaskForRaid(slot);
-            }
-        }
-    }
-}
-
-float Unit::GetAPMultiplier(WeaponAttackType attType, bool normalized)
-{
-    if (!normalized || GetTypeId() != TYPEID_PLAYER)
-        return float(GetAttackTime(attType))/1000.0f;
-
-    Item *Weapon = this->ToPlayer()->GetWeaponForAttack(attType, true);
-    if (!Weapon)
-        return 2.4f;                                         // fist attack
-
-    switch (Weapon->GetProto()->InventoryType)
-    {
-        case INVTYPE_2HWEAPON:
-            return 3.3f;
-        case INVTYPE_RANGED:
-        case INVTYPE_RANGEDRIGHT:
-        case INVTYPE_THROWN:
-            return 2.8f;
-        case INVTYPE_WEAPON:
-        case INVTYPE_WEAPONMAINHAND:
-        case INVTYPE_WEAPONOFFHAND:
-        default:
-            return Weapon->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ? 1.7f : 2.4f;
-    }
-}
-
-bool Unit::IsUnderLastManaUseEffect() const
-{
-    return  getMSTimeDiff(m_lastManaUse,getMSTime()) < 5000;
-}
-
-void Unit::SetContestedPvP(Player *attackedPlayer)
-{
-    Player* player = GetCharmerOrOwnerPlayerOrPlayerItself();
-
-    if (!player || (attackedPlayer && (attackedPlayer == player || (player->duel && player->duel->opponent == attackedPlayer))))
-        return;
-
-    player->SetContestedPvPTimer(30000);
-    if (!player->hasUnitState(UNIT_STAT_ATTACK_PLAYER))
-    {
-        player->addUnitState(UNIT_STAT_ATTACK_PLAYER);
-        player->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
-        // call MoveInLineOfSight for nearby contested guards
-        player->SetVisibility(player->GetVisibility());
-    }
-    if (!hasUnitState(UNIT_STAT_ATTACK_PLAYER))
-    {
-        addUnitState(UNIT_STAT_ATTACK_PLAYER);
-        // call MoveInLineOfSight for nearby contested guards
-        SetVisibility(GetVisibility());
-    }
-}
-
-void Unit::AddPetAura(PetAura const* petSpell)
-{
-    if (GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    m_petAuras.insert(petSpell);
-    if (Pet* pet = this->ToPlayer()->GetPet())
-        pet->CastPetAura(petSpell);
-}
-
-void Unit::RemovePetAura(PetAura const* petSpell)
-{
-    if (GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    m_petAuras.erase(petSpell);
-    if (Pet* pet = this->ToPlayer()->GetPet())
-        pet->RemoveAurasDueToSpell(petSpell->GetAura(pet->GetEntry()));
-}
-
-Pet* Unit::CreateTamedPetFrom(Creature* creatureTarget,uint32 spell_id)
-{
-    if (GetTypeId() != TYPEID_PLAYER)
-        return NULL;
-
-    Pet* pet = new Pet((Player*)this, HUNTER_PET);
-
-    if (!pet->CreateBaseAtCreature(creatureTarget))
-    {
-        delete pet;
-        return NULL;
-    }
-
-    uint8 level = (creatureTarget->getLevel() < (getLevel() - 5)) ? (getLevel() - 5) : creatureTarget->getLevel();
-
-    InitTamedPet(pet, level, spell_id);
-
-    return pet;
-}
-
-Pet* Unit::CreateTamedPetFrom(uint32 creatureEntry, uint32 spell_id)
-{
-    if (GetTypeId() != TYPEID_PLAYER)
-        return NULL;
-
-    CreatureInfo const* creatureInfo = sObjectMgr.GetCreatureTemplate(creatureEntry);
-    if (!creatureInfo)
-        return NULL;
-
-    Pet* pet = new Pet((Player*)this, HUNTER_PET);
-
-    if (!pet->CreateBaseAtCreatureInfo(creatureInfo, this) || !InitTamedPet(pet, getLevel(), spell_id))
-    {
-        delete pet;
-        return NULL;
-    }
-
-    return pet;
-}
-
-bool Unit::InitTamedPet(Pet * pet, uint8 level, uint32 spell_id)
-{
-    pet->SetCreatorGUID(GetGUID());
-    pet->setFaction(getFaction());
-    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, spell_id);
-
-    if (GetTypeId() == TYPEID_PLAYER)
-        pet->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
-
-    if (!pet->InitStatsForLevel(level))
-    {
-        sLog.outError("Pet::InitStatsForLevel() failed for creature (Entry: %u)!",pet->GetEntry());
-        return false;
-    }
-
-    pet->GetCharmInfo()->SetPetNumber(sObjectMgr.GeneratePetNumber(), true);
-    // this enables pet details window (Shift+P)
-    pet->InitPetCreateSpells();
-    //pet->InitLevelupSpellsForLevel();
-    pet->SetFullHealth();
-    return true;
-}
-
-bool Unit::IsTriggeredAtSpellProcEvent(Unit *pVictim, Aura * aura, SpellEntry const* procSpell, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, bool isVictim, bool active, SpellProcEventEntry const *& spellProcEvent)
-{
-    SpellEntry const *spellProto = aura->GetSpellProto();
-
-    // Get proc Event Entry
-    spellProcEvent = sSpellMgr.GetSpellProcEvent(spellProto->Id);
-
-    // Get EventProcFlag
-    uint32 EventProcFlag;
-    if (spellProcEvent && spellProcEvent->procFlags) // if exist get custom spellProcEvent->procFlags
-        EventProcFlag = spellProcEvent->procFlags;
-    else
-        EventProcFlag = spellProto->procFlags;       // else get from spell proto
-    // Continue if no trigger exist
-    if (!EventProcFlag)
-        return false;
-
-    // Additional checks for triggered spells (ignore trap casts)
-    if (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION))
-    {
-        if (!(spellProto->AttributesEx3 & SPELL_ATTR_EX3_CAN_PROC_TRIGGERED))
-            return false;
-    }
-
-    // Check spellProcEvent data requirements
-    if (!sSpellMgr.IsSpellProcEventCanTriggeredBy(spellProcEvent, EventProcFlag, procSpell, procFlag, procExtra, active))
-        return false;
-    // In most cases req get honor or XP from kill
-    if (EventProcFlag & PROC_FLAG_KILL && GetTypeId() == TYPEID_PLAYER)
-    {
-        bool allow = false;
-
-        if (pVictim)
-            allow = ToPlayer()->isHonorOrXPTarget(pVictim);
-
-        // Shadow Word: Death - can trigger from every kill
-        if (aura->GetId() == 32409)
-            allow = true;
-        if (!allow)
-            return false;
-    }
-    // Aura added by spell can`t trigger from self (prevent drop charges/do triggers)
-    // But except periodic and kill triggers (can triggered from self)
-    if (procSpell && procSpell->Id == spellProto->Id
-        && !(spellProto->procFlags&(PROC_FLAG_TAKEN_PERIODIC | PROC_FLAG_KILL)))
-        return false;
-
-    // Check if current equipment allows aura to proc
-    if (!isVictim && GetTypeId() == TYPEID_PLAYER)
-    {
-        if (spellProto->EquippedItemClass == ITEM_CLASS_WEAPON)
-        {
-            Item *item = NULL;
-            if (attType == BASE_ATTACK)
-                item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
-            else if (attType == OFF_ATTACK)
-                item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
-            else
-                item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
-
-            if (this->ToPlayer()->IsInFeralForm())
-                return false;
-
-            if (!item || item->IsBroken() || item->GetProto()->Class != ITEM_CLASS_WEAPON || !((1<<item->GetProto()->SubClass) & spellProto->EquippedItemSubClassMask))
-                return false;
-        }
-        else if (spellProto->EquippedItemClass == ITEM_CLASS_ARMOR)
-        {
-            // Check if player is wearing shield
-            Item *item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
-            if (!item || item->IsBroken() || item->GetProto()->Class != ITEM_CLASS_ARMOR || !((1<<item->GetProto()->SubClass) & spellProto->EquippedItemSubClassMask))
-                return false;
-        }
-    }
-    // Get chance from spell
-    float chance = float(spellProto->procChance);
-    // If in spellProcEvent exist custom chance, chance = spellProcEvent->customChance;
-    if (spellProcEvent && spellProcEvent->customChance)
-        chance = spellProcEvent->customChance;
-    // If PPM exist calculate chance from PPM
-    if (spellProcEvent && spellProcEvent->ppmRate != 0)
-    {
-        if (!isVictim)
-        {
-            uint32 WeaponSpeed = GetAttackTime(attType);
-            chance = GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);
-        }
-        else
-        {
-            uint32 WeaponSpeed = pVictim->GetAttackTime(attType);
-            chance = pVictim->GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);
-        }
-    }
-    // Apply chance modifer aura
-    if (Player* modOwner = GetSpellModOwner())
-    {
-        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_CHANCE_OF_SUCCESS,chance);
-    }
-    return roll_chance_f(chance);
-}
-
-bool Unit::HandleAuraRaidProcFromChargeWithValue(AuraEffect *triggeredByAura)
-{
-    // aura can be deleted at casts
-    SpellEntry const *spellProto = triggeredByAura->GetSpellProto();
-    uint32 effIdx = triggeredByAura->GetEffIndex();
-    int32 heal = triggeredByAura->GetAmount();
-    uint64 caster_guid = triggeredByAura->GetCasterGUID();
-
-    //Currently only Prayer of Mending
-    if (!(spellProto->SpellFamilyName == SPELLFAMILY_PRIEST && spellProto->SpellFamilyFlags[1] & 0x20))
-    {
-        sLog.outDebug("Unit::HandleAuraRaidProcFromChargeWithValue, received not handled spell: %u", spellProto->Id);
-        return false;
-    }
-
-    // jumps
-    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;
-
-    // current aura expire
-    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease
-
-    // next target selection
-    if (jumps > 0)
-    {
-        float radius;
-        if (spellProto->EffectRadiusIndex[effIdx])
-            radius = (float)GetSpellRadiusForTarget(triggeredByAura->GetCaster(), sSpellRadiusStore.LookupEntry(spellProto->EffectRadiusIndex[effIdx]));
-        else
-            radius = (float)GetSpellMaxRangeForTarget(triggeredByAura->GetCaster(), sSpellRangeStore.LookupEntry(spellProto->rangeIndex));
-
-        if (Unit * caster = triggeredByAura->GetCaster())
-        {
-            if (Player * modOwner = caster->GetSpellModOwner())
-                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_RADIUS, radius, NULL);
-
-            if (Unit *target = GetNextRandomRaidMemberOrPet(radius))
-            {
-                CastCustomSpell(target, spellProto->Id, &heal, NULL, NULL, true, NULL, triggeredByAura, caster_guid);
-                if (Aura * aura = target->GetAura(spellProto->Id, caster->GetGUID()))
-                    aura->SetCharges(jumps);
-            }
-        }
-    }
-
-    // heal
-    CastCustomSpell(this, 33110, &heal, NULL, NULL, true, NULL, NULL, caster_guid);
-    return true;
-
-}
-bool Unit::HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura)
-{
-    // aura can be deleted at casts
-    SpellEntry const* spellProto = triggeredByAura->GetSpellProto();
-
-    uint32 damageSpellId;
-    switch (spellProto->Id)
-    {
-        case 57949:            //shiver
-            damageSpellId = 57952;
-            //animationSpellId = 57951; dummy effects for jump spell have unknown use (see also 41637)
-            break;
-        case 59978:            //shiver
-            damageSpellId = 59979;
-            break;
-        case 43593:            //Cold Stare
-            damageSpellId = 43594;
-            break;
-        default:
-            sLog.outError("Unit::HandleAuraRaidProcFromCharge, received not handled spell: %u", spellProto->Id);
-            return false;
-    }
-
-    uint64 caster_guid = triggeredByAura->GetCasterGUID();
-    uint32 effIdx = triggeredByAura->GetEffIndex();
-
-    // jumps
-    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;
-
-    // current aura expire
-    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease
-
-    // next target selection
-    if (jumps > 0)
-    {
-        float radius;
-        if (spellProto->EffectRadiusIndex[effIdx])
-            radius = (float)GetSpellRadiusForTarget(triggeredByAura->GetCaster(), sSpellRadiusStore.LookupEntry(spellProto->EffectRadiusIndex[effIdx]));
-        else
-            radius = (float)GetSpellMaxRangeForTarget(triggeredByAura->GetCaster() ,sSpellRangeStore.LookupEntry(spellProto->rangeIndex));
-
-        if (Unit * caster = triggeredByAura->GetCaster())
-        {
-            if (Player * modOwner = caster->GetSpellModOwner())
-                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_RADIUS, radius, NULL);
-
-            if (Unit* target= GetNextRandomRaidMemberOrPet(radius))
-            {
-                CastSpell(target, spellProto, true,NULL,triggeredByAura,caster_guid);
-                if (Aura * aura = target->GetAura(spellProto->Id, caster->GetGUID()))
-                    aura->SetCharges(jumps);
-            }
-        }
-    }
-
-    CastSpell(this, damageSpellId, true,NULL,triggeredByAura,caster_guid);
-
-    return true;
-}
-
-void Unit::Kill(Unit *pVictim, bool durabilityLoss)
-{
-    // Prevent killing unit twice (and giving reward from kill twice)
-    if (!pVictim->GetHealth())
-        return;
-
-    // Inform pets (if any) when player kills target)
-    if (this->ToPlayer())
-    {
-        Pet *pPet = this->ToPlayer()->GetPet();
-        if (pPet && pPet->isAlive() && pPet->isControlled())
-            pPet->AI()->KilledUnit(pVictim);
-    }
-
-    // find player: owner of controlled `this` or `this` itself maybe
-    Player *player = GetCharmerOrOwnerPlayerOrPlayerItself();
-    Creature *creature = pVictim->ToCreature();
-
-    bool bRewardIsAllowed = true;
-    if (creature)
-    {
-        bRewardIsAllowed = creature->IsDamageEnoughForLootingAndReward();
-        if (!bRewardIsAllowed)
-            creature->SetLootRecipient(NULL);
-    }
-
-    if (bRewardIsAllowed && creature && creature->GetLootRecipient())
-        player = creature->GetLootRecipient();
-
-    // Reward player, his pets, and group/raid members
-    // call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)
-    if (bRewardIsAllowed && player && player != pVictim)
-    {
-        WorldPacket data(SMSG_PARTYKILLLOG, (8+8)); //send event PARTY_KILL
-        data << uint64(player->GetGUID()); //player with killing blow
-        data << uint64(pVictim->GetGUID()); //victim
-
-        Player* pLooter = player;
-
-        if (Group *group = player->GetGroup())
-        {
-            group->BroadcastPacket(&data, group->GetMemberGroup(player->GetGUID()));
-
-            if (creature)
-            {
-                group->UpdateLooterGuid(creature, true);
-                if (group->GetLooterGuid())
-                {
-                    pLooter = sObjectMgr.GetPlayer(group->GetLooterGuid());
-                    if (pLooter)
-                    {
-                        creature->SetLootRecipient(pLooter);   // update creature loot recipient to the allowed looter.
-                        group->SendLooter(creature, pLooter);
-                    }
-                    else
-                        group->SendLooter(creature, NULL);
-                }
-                else
-                    group->SendLooter(creature, NULL);
-
-                group->UpdateLooterGuid(creature);
-            }
-        }
-        else
-        {
-            player->SendDirectMessage(&data);
-
-            if (creature)
-            {
-                WorldPacket data2(SMSG_LOOT_LIST, (8+1+1));
-                data2 << uint64(creature->GetGUID());
-                data2 << uint8(0); // unk1
-                data2 << uint8(0); // no group looter
-                player->SendMessageToSet(&data2, true);
-            }
-        }
-
-        if (creature)
-        {
-            Loot* loot = &creature->loot;
-            if (creature->lootForPickPocketed)
-                creature->lootForPickPocketed = false;
-
-            loot->clear();
-            if (uint32 lootid = creature->GetCreatureInfo()->lootid)
-                loot->FillLoot(lootid, LootTemplates_Creature, pLooter, false, false, creature->GetLootMode());
-
-            loot->generateMoneyLoot(creature->GetCreatureInfo()->mingold,creature->GetCreatureInfo()->maxgold);
-        }
-
-        player->RewardPlayerAndGroupAtKill(pVictim);
-    }
-
-    // Do KILL and KILLED procs. KILL proc is called only for the unit who landed the killing blow (and its owner - for pets and totems) regardless of who tapped the victim
-    if (isPet() || isTotem())
-        if (Unit *owner = GetOwner())
-            owner->ProcDamageAndSpell(pVictim, PROC_FLAG_KILL, PROC_FLAG_NONE, PROC_EX_NONE, 0);
-
-    if (pVictim->GetCreatureType() != CREATURE_TYPE_CRITTER)
-        ProcDamageAndSpell(pVictim, PROC_FLAG_KILL, PROC_FLAG_KILLED, PROC_EX_NONE, 0);
-
-    // Proc auras on death - must be before aura/combat remove
-    pVictim->ProcDamageAndSpell(NULL, PROC_FLAG_DEATH, PROC_FLAG_NONE, PROC_EX_NONE, 0, BASE_ATTACK, 0);
-
-    // if talent known but not triggered (check priest class for speedup check)
-    bool SpiritOfRedemption = false;
-    if (pVictim->GetTypeId() == TYPEID_PLAYER && pVictim->getClass() == CLASS_PRIEST)
-    {
-        AuraEffectList const& vDummyAuras = pVictim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
-        for (AuraEffectList::const_iterator itr = vDummyAuras.begin(); itr != vDummyAuras.end(); ++itr)
-        {
-            if ((*itr)->GetSpellProto()->SpellIconID == 1654)
-            {
-                // save value before aura remove
-                uint32 ressSpellId = pVictim->GetUInt32Value(PLAYER_SELF_RES_SPELL);
-                if (!ressSpellId)
-                    ressSpellId = pVictim->ToPlayer()->GetResurrectionSpellId();
-                //Remove all expected to remove at death auras (most important negative case like DoT or periodic triggers)
-                pVictim->RemoveAllAurasOnDeath();
-                // restore for use at real death
-                pVictim->SetUInt32Value(PLAYER_SELF_RES_SPELL,ressSpellId);
-
-                // FORM_SPIRITOFREDEMPTION and related auras
-                pVictim->CastSpell(pVictim,27827,true,NULL,*itr);
-                SpiritOfRedemption = true;
-                break;
-            }
-        }
-    }
-
-    if (!SpiritOfRedemption)
-    {
-        sLog.outStaticDebug("SET JUST_DIED");
-        pVictim->setDeathState(JUST_DIED);
-    }
-
-    // 10% durability loss on death
-    // clean InHateListOf
-    if (pVictim->GetTypeId() == TYPEID_PLAYER)
-    {
-        // remember victim PvP death for corpse type and corpse reclaim delay
-        // at original death (not at SpiritOfRedemtionTalent timeout)
-        pVictim->ToPlayer()->SetPvPDeath(player != NULL);
-
-        // only if not player and not controlled by player pet. And not at BG
-        if ((durabilityLoss && !player && !pVictim->ToPlayer()->InBattleground()) || (player && sWorld.getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
-        {
-            sLog.outStaticDebug("We are dead, losing %f percent durability", sWorld.getRate(RATE_DURABILITY_LOSS_ON_DEATH));
-            pVictim->ToPlayer()->DurabilityLossAll(sWorld.getRate(RATE_DURABILITY_LOSS_ON_DEATH),false);
-            // durability lost message
-            WorldPacket data(SMSG_DURABILITY_DAMAGE_DEATH, 0);
-            pVictim->ToPlayer()->GetSession()->SendPacket(&data);
-        }
-        // Call KilledUnit for creatures
-        if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->IsAIEnabled)
-            this->ToCreature()->AI()->KilledUnit(pVictim);
-
-        // last damage from non duel opponent or opponent controlled creature
-        if (pVictim->ToPlayer()->duel)
-        {
-            pVictim->ToPlayer()->duel->opponent->CombatStopWithPets(true);
-            pVictim->ToPlayer()->CombatStopWithPets(true);
-            pVictim->ToPlayer()->DuelComplete(DUEL_INTERUPTED);
-        }
-    }
-    else                                                // creature died
-    {
-        sLog.outStaticDebug("DealDamageNotPlayer");
-
-        if (!creature->isPet())
-        {
-            creature->DeleteThreatList();
-            CreatureInfo const* cInfo = creature->GetCreatureInfo();
-            if (cInfo && (cInfo->lootid || cInfo->maxgold > 0))
-                creature->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
-        }
-
-        // Call KilledUnit for creatures, this needs to be called after the lootable flag is set
-        if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->IsAIEnabled)
-            this->ToCreature()->AI()->KilledUnit(pVictim);
-
-        // Call creature just died function
-        if (creature->IsAIEnabled)
-            creature->AI()->JustDied(this);
-
-        // Dungeon specific stuff, only applies to players killing creatures
-        if (creature->GetInstanceId())
-        {
-            Map *m = creature->GetMap();
-            Player *creditedPlayer = GetCharmerOrOwnerPlayerOrPlayerItself();
-            // TODO: do instance binding anyway if the charmer/owner is offline
-
-            if (m->IsDungeon() && creditedPlayer)
-            {
-                if (m->IsRaidOrHeroicDungeon())
-                {
-                    if (creature->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
-                        ((InstanceMap *)m)->PermBindAllPlayers(creditedPlayer);
-                }
-                else
-                {
-                    // the reset time is set but not added to the scheduler
-                    // until the players leave the instance
-                    time_t resettime = creature->GetRespawnTimeEx() + 2 * HOUR;
-                    if (InstanceSave *save = sInstanceSaveMgr.GetInstanceSave(creature->GetInstanceId()))
-                        if (save->GetResetTime() < resettime) save->SetResetTime(resettime);
-                }
-            }
-        }
-    }
-
-    // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
-    // handle player kill only if not suicide (spirit of redemption for example)
-    if (player && this != pVictim)
-        if (OutdoorPvP * pvp = player->GetOutdoorPvP())
-            pvp->HandleKill(player, pVictim);
-
-    //if (pVictim->GetTypeId() == TYPEID_PLAYER)
-    //    if (OutdoorPvP * pvp = pVictim->ToPlayer()->GetOutdoorPvP())
-    //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
-
-    // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
-    if (player && player->InBattleground())
-    {
-        if (Battleground *bg = player->GetBattleground())
-        {
-            if (pVictim->GetTypeId() == TYPEID_PLAYER)
-                bg->HandleKillPlayer((Player*)pVictim, player);
-            else
-                bg->HandleKillUnit(pVictim->ToCreature(), player);
-        }
-    }
-
-    // achievement stuff
-    if (pVictim->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (GetTypeId() == TYPEID_UNIT)
-            pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_CREATURE, GetEntry());
-        else if (GetTypeId() == TYPEID_PLAYER && pVictim != this)
-            pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_PLAYER, 1, this->ToPlayer()->GetTeam());
-    }
-
-    //Hook for OnPVPKill Event
-    if (this->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (pVictim->GetTypeId() == TYPEID_PLAYER)
-        {
-            Player *killer = this->ToPlayer();
-            Player *killed = pVictim->ToPlayer();
-            sScriptMgr.OnPVPKill(killer, killed);
-        }
-        else if (pVictim->GetTypeId() == TYPEID_UNIT)
-        {
-            Player *killer = this->ToPlayer();
-            Creature *killed = pVictim->ToCreature();
-            sScriptMgr.OnCreatureKill(killer, killed);
-        }
-    }
-    else if (this->GetTypeId() == TYPEID_UNIT)
-    {
-        if (pVictim->GetTypeId() == TYPEID_PLAYER)
-        {
-            Creature *killer = this->ToCreature();
-            Player *killed = pVictim->ToPlayer();
-            sScriptMgr.OnPlayerKilledByCreature(killer, killed);
-        }
-    }
-}
-
-void Unit::SetControlled(bool apply, UnitState state)
-{
-    if (apply)
-    {
-        if (hasUnitState(state))
-            return;
-
-        addUnitState(state);
-        switch(state)
-        {
-            case UNIT_STAT_STUNNED:
-                SetStunned(true);
-                CastStop();
-                break;
-            case UNIT_STAT_ROOT:
-                if (!hasUnitState(UNIT_STAT_STUNNED))
-                    SetRooted(true);
-                break;
-            case UNIT_STAT_CONFUSED:
-                if (!hasUnitState(UNIT_STAT_STUNNED))
-                {
-                    SetConfused(true);
-                    CastStop();
-                }
-                break;
-            case UNIT_STAT_FLEEING:
-                if (!hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_CONFUSED))
-                {
-                    SetFeared(true);
-                    CastStop();
-                }
-                break;
-            default:
-                break;
-        }
-    }
-    else
-    {
-        switch(state)
-        {
-            case UNIT_STAT_STUNNED: if (HasAuraType(SPELL_AURA_MOD_STUN))    return;
-                                    else    SetStunned(false);    break;
-            case UNIT_STAT_ROOT:    if (HasAuraType(SPELL_AURA_MOD_ROOT) || GetVehicle())    return;
-                                    else    SetRooted(false);     break;
-            case UNIT_STAT_CONFUSED:if (HasAuraType(SPELL_AURA_MOD_CONFUSE)) return;
-                                    else    SetConfused(false);   break;
-            case UNIT_STAT_FLEEING: if (HasAuraType(SPELL_AURA_MOD_FEAR))    return;
-                                    else    SetFeared(false);     break;
-            default: return;
-        }
-
-        clearUnitState(state);
-
-        if (hasUnitState(UNIT_STAT_STUNNED))
-            SetStunned(true);
-        else
-        {
-            if (hasUnitState(UNIT_STAT_ROOT))
-                SetRooted(true);
-
-            if (hasUnitState(UNIT_STAT_CONFUSED))
-                SetConfused(true);
-            else if (hasUnitState(UNIT_STAT_FLEEING))
-                SetFeared(true);
-        }
-    }
-}
-
-void Unit::SetStunned(bool apply)
-{
-    if (apply)
-    {
-        SetUInt64Value(UNIT_FIELD_TARGET, 0);
-        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
-        CastStop();
-//        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
-
-        // Creature specific
-        if (GetTypeId() != TYPEID_PLAYER)
-            this->ToCreature()->StopMoving();
-        else
-            SetStandState(UNIT_STAND_STATE_STAND);
-
-        WorldPacket data(SMSG_FORCE_MOVE_ROOT, 8);
-        data.append(GetPackGUID());
-        data << uint32(0);
-        SendMessageToSet(&data,true);
-    }
-    else
-    {
-        if (isAlive() && getVictim())
-            SetUInt64Value(UNIT_FIELD_TARGET, getVictim()->GetGUID());
-
-        // don't remove UNIT_FLAG_STUNNED for pet when owner is mounted (disabled pet's interface)
-        Unit *pOwner = GetOwner();
-        if (!pOwner || (pOwner->GetTypeId() == TYPEID_PLAYER && !pOwner->ToPlayer()->IsMounted()))
-            RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
-
-        if (!hasUnitState(UNIT_STAT_ROOT))         // prevent allow move if have also root effect
-        {
-            WorldPacket data(SMSG_FORCE_MOVE_UNROOT, 8+4);
-            data.append(GetPackGUID());
-            data << uint32(0);
-            SendMessageToSet(&data,true);
-
-//            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
-        }
-    }
-}
-
-void Unit::SetRooted(bool apply)
-{
-    if (apply)
-    {
-        if (m_rootTimes > 0) //blizzard internal check?
-            m_rootTimes++;
-
-//        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
-
-        WorldPacket data(SMSG_FORCE_MOVE_ROOT, 10);
-        data.append(GetPackGUID());
-        data << m_rootTimes;
-        SendMessageToSet(&data,true);
-
-        if (GetTypeId() != TYPEID_PLAYER)
-            ToCreature()->StopMoving();
-    }
-    else
-    {
-        if (!hasUnitState(UNIT_STAT_STUNNED))      // prevent allow move if have also stun effect
-        {
-            m_rootTimes++; //blizzard internal check?
-
-            WorldPacket data(SMSG_FORCE_MOVE_UNROOT, 10);
-            data.append(GetPackGUID());
-            data << m_rootTimes;
-            SendMessageToSet(&data,true);
-
-//            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
-        }
-    }
-}
-
-void Unit::SetFeared(bool apply)
-{
-    if (apply)
-    {
-        SetUInt64Value(UNIT_FIELD_TARGET, 0);
-
-        Unit *caster = NULL;
-        Unit::AuraEffectList const& fearAuras = GetAuraEffectsByType(SPELL_AURA_MOD_FEAR);
-        if (!fearAuras.empty())
-            caster = ObjectAccessor::GetUnit(*this, fearAuras.front()->GetCasterGUID());
-        if (!caster)
-            caster = getAttackerForHelper();
-        GetMotionMaster()->MoveFleeing(caster, fearAuras.empty() ? sWorld.getIntConfig(CONFIG_CREATURE_FAMILY_FLEE_DELAY) : 0);             // caster == NULL processed in MoveFleeing
-    }
-    else
-    {
-        if (isAlive())
-        {
-            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == FLEEING_MOTION_TYPE)
-                GetMotionMaster()->MovementExpired();
-            if (getVictim())
-                SetUInt64Value(UNIT_FIELD_TARGET, getVictim()->GetGUID());
-        }
-    }
-
-    if (GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->SetClientControl(this, !apply);
-}
-
-void Unit::SetConfused(bool apply)
-{
-    if (apply)
-    {
-        SetUInt64Value(UNIT_FIELD_TARGET, 0);
-        GetMotionMaster()->MoveConfused();
-    }
-    else
-    {
-        if (isAlive())
-        {
-            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == CONFUSED_MOTION_TYPE)
-                GetMotionMaster()->MovementExpired();
-            if (getVictim())
-                SetUInt64Value(UNIT_FIELD_TARGET, getVictim()->GetGUID());
-        }
-    }
-
-    if (GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->SetClientControl(this, !apply);
-}
-
-bool Unit::SetCharmedBy(Unit* charmer, CharmType type)
-{
-    if (!charmer)
-        return false;
-
-    // unmount players when charmed
-    if (GetTypeId() == TYPEID_PLAYER)
-        Unmount();
-
-    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);
-    ASSERT((type == CHARM_TYPE_VEHICLE) == IsVehicle());
-
-    sLog.outDebug("SetCharmedBy: charmer %u (GUID %u), charmed %u (GUID %u), type %u.", charmer->GetEntry(), charmer->GetGUIDLow(), GetEntry(), GetGUIDLow(), uint32(type));
-
-    if (this == charmer)
-    {
-        sLog.outCrash("Unit::SetCharmedBy: Unit %u (GUID %u) is trying to charm itself!", GetEntry(), GetGUIDLow());
-        return false;
-    }
-
-    //if (hasUnitState(UNIT_STAT_UNATTACKABLE))
-    //    return false;
-
-    if (GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->GetTransport())
-    {
-        sLog.outCrash("Unit::SetCharmedBy: Player on transport is trying to charm %u (GUID %u)", GetEntry(), GetGUIDLow());
-        return false;
-    }
-
-    // Already charmed
-    if (GetCharmerGUID())
-    {
-        sLog.outCrash("Unit::SetCharmedBy: %u (GUID %u) has already been charmed but %u (GUID %u) is trying to charm it!", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());
-        return false;
-    }
-
-    CastStop();
-    CombatStop(); //TODO: CombatStop(true) may cause crash (interrupt spells)
-    DeleteThreatList();
-
-    // Charmer stop charming
-    if (charmer->GetTypeId() == TYPEID_PLAYER)
-    {
-        charmer->ToPlayer()->StopCastingCharm();
-        charmer->ToPlayer()->StopCastingBindSight();
-    }
-
-    // Charmed stop charming
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        this->ToPlayer()->StopCastingCharm();
-        this->ToPlayer()->StopCastingBindSight();
-    }
-
-    // StopCastingCharm may remove a possessed pet?
-    if (!IsInWorld())
-    {
-        sLog.outCrash("Unit::SetCharmedBy: %u (GUID %u) is not in world but %u (GUID %u) is trying to charm it!", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());
-        return false;
-    }
-
-    // Set charmed
-    Map* pMap = GetMap();
-    if (!IsVehicle() || (IsVehicle() && pMap && !pMap->IsBattleground()))
-        setFaction(charmer->getFaction());
-
-    charmer->SetCharm(this, true);
-
-    if (GetTypeId() == TYPEID_UNIT)
-    {
-        this->ToCreature()->AI()->OnCharmed(true);
-        GetMotionMaster()->MoveIdle();
-    }
-    else
-    {
-        if (this->ToPlayer()->isAFK())
-            this->ToPlayer()->ToggleAFK();
-        this->ToPlayer()->SetClientControl(this, 0);
-    }
-
-    // Pets already have a properly initialized CharmInfo, don't overwrite it.
-    if (type != CHARM_TYPE_VEHICLE && !GetCharmInfo())
-    {
-        CharmInfo *charmInfo = InitCharmInfo();
-        if (type == CHARM_TYPE_POSSESS)
-            charmInfo->InitPossessCreateSpells();
-        else
-            charmInfo->InitCharmCreateSpells();
-    }
-
-    if (charmer->GetTypeId() == TYPEID_PLAYER)
-    {
-        switch(type)
-        {
-            case CHARM_TYPE_VEHICLE:
-                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
-                charmer->ToPlayer()->SetClientControl(this, 1);
-                charmer->ToPlayer()->SetViewpoint(this, true);
-                charmer->ToPlayer()->VehicleSpellInitialize();
-                break;
-            case CHARM_TYPE_POSSESS:
-                addUnitState(UNIT_STAT_POSSESSED);
-                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
-                charmer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
-                charmer->ToPlayer()->SetClientControl(this, 1);
-                charmer->ToPlayer()->SetViewpoint(this, true);
-                charmer->ToPlayer()->PossessSpellInitialize();
-                break;
-            case CHARM_TYPE_CHARM:
-                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
-                {
-                    CreatureInfo const *cinfo = this->ToCreature()->GetCreatureInfo();
-                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
-                    {
-                        //to prevent client crash
-                        SetByteValue(UNIT_FIELD_BYTES_0, 1, (uint8)CLASS_MAGE);
-
-                        //just to enable stat window
-                        if (GetCharmInfo())
-                            GetCharmInfo()->SetPetNumber(sObjectMgr.GeneratePetNumber(), true);
-
-                        //if charmed two demons the same session, the 2nd gets the 1st one's name
-                        SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped
-                    }
-                }
-                charmer->ToPlayer()->CharmSpellInitialize();
-                break;
-            default:
-            case CHARM_TYPE_CONVERT:
-                break;
-        }
-    }
-    return true;
-}
-
-void Unit::RemoveCharmedBy(Unit *charmer)
-{
-    if (!isCharmed())
-        return;
-
-    if (!charmer)
-        charmer = GetCharmer();
-    if (charmer != GetCharmer()) // one aura overrides another?
-    {
-//        sLog.outCrash("Unit::RemoveCharmedBy: this: " UI64FMTD " true charmer: " UI64FMTD " false charmer: " UI64FMTD,
-//            GetGUID(), GetCharmerGUID(), charmer->GetGUID());
-//        ASSERT(false);
-        return;
-    }
-
-    CharmType type;
-    if (hasUnitState(UNIT_STAT_POSSESSED))
-        type = CHARM_TYPE_POSSESS;
-    else if (charmer->IsOnVehicle(this))
-        type = CHARM_TYPE_VEHICLE;
-    else
-        type = CHARM_TYPE_CHARM;
-
-    CastStop();
-    CombatStop(); //TODO: CombatStop(true) may cause crash (interrupt spells)
-    getHostileRefManager().deleteReferences();
-    DeleteThreatList();
-    Map* pMap = GetMap();
-    if (!IsVehicle() || (IsVehicle() && pMap && !pMap->IsBattleground()))
-        RestoreFaction();
-    GetMotionMaster()->InitDefault();
-
-    if (type == CHARM_TYPE_POSSESS)
-    {
-        clearUnitState(UNIT_STAT_POSSESSED);
-        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
-    }
-
-    if (GetTypeId() == TYPEID_UNIT)
-    {
-        this->ToCreature()->AI()->OnCharmed(false);
-
-        if (type != CHARM_TYPE_VEHICLE)//Vehicles' AI is never modified
-        {
-            this->ToCreature()->AIM_Initialize();
-
-            if (this->ToCreature()->AI() && charmer && charmer->isAlive())
-                this->ToCreature()->AI()->AttackStart(charmer);
-        }
-    }
-    else
-        this->ToPlayer()->SetClientControl(this, 1);
-
-    // If charmer still exists
-    if (!charmer)
-        return;
-
-    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);
-    ASSERT(type != CHARM_TYPE_VEHICLE || (GetTypeId() == TYPEID_UNIT && IsVehicle()));
-
-    charmer->SetCharm(this, false);
-
-    if (charmer->GetTypeId() == TYPEID_PLAYER)
-    {
-        switch(type)
-        {
-            case CHARM_TYPE_VEHICLE:
-                charmer->ToPlayer()->SetClientControl(charmer, 1);
-                charmer->ToPlayer()->SetViewpoint(this, false);
-                break;
-            case CHARM_TYPE_POSSESS:
-                charmer->ToPlayer()->SetClientControl(charmer, 1);
-                charmer->ToPlayer()->SetViewpoint(this, false);
-                charmer->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
-                break;
-            case CHARM_TYPE_CHARM:
-                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
-                {
-                    CreatureInfo const *cinfo = this->ToCreature()->GetCreatureInfo();
-                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
-                    {
-                        SetByteValue(UNIT_FIELD_BYTES_0, 1, uint8(cinfo->unit_class));
-                        if (GetCharmInfo())
-                            GetCharmInfo()->SetPetNumber(0, true);
-                        else
-                            sLog.outError("Aura::HandleModCharm: target="UI64FMTD" with typeid=%d has a charm aura but no charm info!", GetGUID(), GetTypeId());
-                    }
-                }
-                break;
-            default:
-            case CHARM_TYPE_CONVERT:
-                break;
-        }
-    }
-
-    //a guardian should always have charminfo
-    if (charmer->GetTypeId() == TYPEID_PLAYER && this != charmer->GetFirstControlled())
-        charmer->ToPlayer()->SendRemoveControlBar();
-    else if (GetTypeId() == TYPEID_PLAYER || (GetTypeId() == TYPEID_UNIT && !this->ToCreature()->isGuardian()))
-        DeleteCharmInfo();
-}
-
-void Unit::RestoreFaction()
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->setFactionForRace(getRace());
-    else
-    {
-        if (HasUnitTypeMask(UNIT_MASK_MINION))
-        {
-            if (Unit* owner = GetOwner())
-            {
-                setFaction(owner->getFaction());
-                return;
-            }
-        }
-
-        if (CreatureInfo const *cinfo = this->ToCreature()->GetCreatureInfo())  // normal creature
-        {
-            FactionTemplateEntry const *faction = getFactionTemplateEntry();
-            setFaction((faction && faction->friendlyMask & 0x004) ? cinfo->faction_H : cinfo->faction_A);
-        }
-    }
-}
-
-bool Unit::CreateVehicleKit(uint32 id)
-{
-    VehicleEntry const *vehInfo = sVehicleStore.LookupEntry(id);
-    if (!vehInfo)
-        return false;
-
-    m_vehicleKit = new Vehicle(this, vehInfo);
-    m_updateFlag |= UPDATEFLAG_VEHICLE;
-    m_unitTypeMask |= UNIT_MASK_VEHICLE;
-    return true;
-}
-
-void Unit::RemoveVehicleKit()
-{
-    if (!m_vehicleKit)
-        return;
-
-    m_vehicleKit->Uninstall();
-    delete m_vehicleKit;
-
-    m_vehicleKit = NULL;
-
-    m_updateFlag &= ~UPDATEFLAG_VEHICLE;
-    m_unitTypeMask &= ~UNIT_MASK_VEHICLE;
-    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
-    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_PLAYER_VEHICLE);
-}
-
-Unit *Unit::GetVehicleBase() const
-{
-    return m_vehicle ? m_vehicle->GetBase() : NULL;
-}
-
-Creature *Unit::GetVehicleCreatureBase() const
-{
-    if (Unit *veh = GetVehicleBase())
-        if (Creature *c = veh->ToCreature())
-            return c;
-
-    return NULL;
-}
-
-uint64 Unit::GetTransGUID() const
-{
-    if (GetVehicle())
-        return GetVehicle()->GetBase()->GetGUID();
-    if (GetTransport())
-        return GetTransport()->GetGUID();
-
-    return 0;
-}
-
-bool Unit::IsInPartyWith(Unit const *unit) const
-{
-    if (this == unit)
-        return true;
-
-    const Unit *u1 = GetCharmerOrOwnerOrSelf();
-    const Unit *u2 = unit->GetCharmerOrOwnerOrSelf();
-    if (u1 == u2)
-        return true;
-
-    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
-      return u1->ToPlayer()->IsInSameGroupWith(u2->ToPlayer());
-    else
-        return false;
-}
-
-bool Unit::IsInRaidWith(Unit const *unit) const
-{
-    if (this == unit)
-        return true;
-
-    const Unit *u1 = GetCharmerOrOwnerOrSelf();
-    const Unit *u2 = unit->GetCharmerOrOwnerOrSelf();
-    if (u1 == u2)
-        return true;
-
-    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
-      return u1->ToPlayer()->IsInSameRaidWith(u2->ToPlayer());
-    else
-        return false;
-}
-
-void Unit::GetRaidMember(std::list<Unit*> &nearMembers, float radius)
-{
-    Player *owner = GetCharmerOrOwnerPlayerOrPlayerItself();
-    if (!owner)
-        return;
-
-    Group *pGroup = owner->GetGroup();
-    if (pGroup)
-    {
-        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player* Target = itr->getSource();
-
-            if (Target && !IsHostileTo(Target))
-            {
-                if (Target->isAlive() && IsWithinDistInMap(Target, radius))
-                    nearMembers.push_back(Target);
-
-                if (Guardian* pet = Target->GetGuardianPet())
-                    if (pet->isAlive() &&  IsWithinDistInMap(pet, radius))
-                        nearMembers.push_back(pet);
-            }
-        }
-    }
-    else
-    {
-        if (owner->isAlive() && (owner == this || IsWithinDistInMap(owner, radius)))
-            nearMembers.push_back(owner);
-        if (Guardian* pet = owner->GetGuardianPet())
-            if (pet->isAlive() && (pet == this && IsWithinDistInMap(pet, radius)))
-                nearMembers.push_back(pet);
-    }
-}
-
-void Unit::GetPartyMemberInDist(std::list<Unit*> &TagUnitMap, float radius)
-{
-    Unit *owner = GetCharmerOrOwnerOrSelf();
-    Group *pGroup = NULL;
-    if (owner->GetTypeId() == TYPEID_PLAYER)
-        pGroup = owner->ToPlayer()->GetGroup();
-
-    if (pGroup)
-    {
-        uint8 subgroup = owner->ToPlayer()->GetSubGroup();
-
-        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player* Target = itr->getSource();
-
-            // IsHostileTo check duel and controlled by enemy
-            if (Target && Target->GetSubGroup() == subgroup && !IsHostileTo(Target))
-            {
-                if (Target->isAlive() && IsWithinDistInMap(Target, radius))
-                    TagUnitMap.push_back(Target);
-
-                if (Guardian* pet = Target->GetGuardianPet())
-                    if (pet->isAlive() &&  IsWithinDistInMap(pet, radius))
-                        TagUnitMap.push_back(pet);
-            }
-        }
-    }
-    else
-    {
-        if (owner->isAlive() && (owner == this || IsWithinDistInMap(owner, radius)))
-            TagUnitMap.push_back(owner);
-        if (Guardian* pet = owner->GetGuardianPet())
-            if (pet->isAlive() && (pet == this && IsWithinDistInMap(pet, radius)))
-                TagUnitMap.push_back(pet);
-    }
-}
-
-void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
-{
-    Unit *owner = GetCharmerOrOwnerOrSelf();
-    Group *pGroup = NULL;
-    if (owner->GetTypeId() == TYPEID_PLAYER)
-        pGroup = owner->ToPlayer()->GetGroup();
-
-    if (pGroup)
-    {
-        uint8 subgroup = owner->ToPlayer()->GetSubGroup();
-
-        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player* Target = itr->getSource();
-
-            // IsHostileTo check duel and controlled by enemy
-            if (Target && Target->GetSubGroup() == subgroup && !IsHostileTo(Target))
-            {
-                if (Target->isAlive() && IsInMap(Target))
-                    TagUnitMap.push_back(Target);
-
-                if (Guardian* pet = Target->GetGuardianPet())
-                    if (pet->isAlive() && IsInMap(Target))
-                        TagUnitMap.push_back(pet);
-            }
-        }
-    }
-    else
-    {
-        if (owner->isAlive() && (owner == this || IsInMap(owner)))
-            TagUnitMap.push_back(owner);
-        if (Guardian* pet = owner->GetGuardianPet())
-            if (pet->isAlive() && (pet == this || IsInMap(pet)))
-                TagUnitMap.push_back(pet);
-    }
-}
-
-Aura * Unit::AddAura(uint32 spellId, Unit *target)
-{
-    if (!target || !target->isAlive())
-        return NULL;
-
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return NULL;
-
-    return AddAura(spellInfo, MAX_EFFECT_MASK, target);
-}
-
-Aura * Unit::AddAura(SpellEntry const *spellInfo, uint8 effMask, Unit *target)
-{
-    if (!spellInfo)
-        return NULL;
-
-    if (target->IsImmunedToSpell(spellInfo))
-        return NULL;
-
-    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (!(effMask & (1<<i)))
-            continue;
-        if (target->IsImmunedToSpellEffect(spellInfo, i))
-            effMask &= ~(1<<i);
-    }
-
-    if (Aura * aura = Aura::TryCreate(spellInfo, effMask, target, this))
-    {
-        aura->ApplyForTargets();
-        return aura;
-    }
-    return NULL;
-}
-
-void Unit::SetAuraStack(uint32 spellId, Unit *target, uint32 stack)
-{
-    Aura *aura = target->GetAura(spellId, GetGUID());
-    if (!aura)
-        aura = AddAura(spellId, target);
-    if (aura && stack)
-        aura->SetStackAmount(stack);
-}
-
-void Unit::ApplyResilience(const Unit *pVictim, float *crit, int32 *damage, bool isCrit, CombatRating type) const
-{
-    if (IsVehicle() || pVictim->IsVehicle())
-        return;
-
-    const Unit *source = ToPlayer();
-    if (!source)
-    {
-        source = ToCreature();
-        if (source)
-        {
-            source = source->ToCreature()->GetOwner();
-            if (source)
-                source = source->ToPlayer();
-        }
-    }
-
-    const Unit *target = pVictim->ToPlayer();
-    if (!target)
-    {
-        target = pVictim->ToCreature();
-        if (target)
-        {
-            target = target->ToCreature()->GetOwner();
-            if (target)
-                target = target->ToPlayer();
-        }
-    }
-
-    if (!target)
-        return;
-
-    switch (type)
-    {
-        case CR_CRIT_TAKEN_MELEE:
-            // Crit chance reduction works against nonpets
-            if (crit)
-                *crit -= target->ToPlayer()->GetMeleeCritChanceReduction();
-            if (source && damage)
-            {
-                if (isCrit)
-                    *damage -= target->ToPlayer()->GetMeleeCritDamageReduction(*damage);
-                *damage -= target->ToPlayer()->GetMeleeDamageReduction(*damage);
-            }
-            break;
-        case CR_CRIT_TAKEN_RANGED:
-            // Crit chance reduction works against nonpets
-            if (crit)
-                *crit -= target->ToPlayer()->GetRangedCritChanceReduction();
-            if (source && damage)
-            {
-                if (isCrit)
-                    *damage -= target->ToPlayer()->GetRangedCritDamageReduction(*damage);
-                *damage -= target->ToPlayer()->GetRangedDamageReduction(*damage);
-            }
-            break;
-        case CR_CRIT_TAKEN_SPELL:
-            // Crit chance reduction works against nonpets
-            if (crit)
-                *crit -= target->ToPlayer()->GetSpellCritChanceReduction();
-            if (source && damage)
-            {
-                if (isCrit)
-                    *damage -= target->ToPlayer()->GetSpellCritDamageReduction(*damage);
-                *damage -= target->ToPlayer()->GetSpellDamageReduction(*damage);
-            }
-            break;
-        default:
-            break;
-    }
-}
-
-// Melee based spells can be miss, parry or dodge on this step
-// Crit or block - determined on damage calculation phase! (and can be both in some time)
-float Unit::MeleeSpellMissChance(const Unit *pVictim, WeaponAttackType attType, int32 skillDiff, uint32 spellId) const
-{
-    // Calculate hit chance (more correct for chance mod)
-    int32 HitChance;
-
-    // PvP - PvE melee chances
-    if (spellId || attType == RANGED_ATTACK || !haveOffhandWeapon())
-        HitChance = 95;
-    else
-        HitChance = 76;
-
-    // Hit chance depends from victim auras
-    if (attType == RANGED_ATTACK)
-        HitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
-    else
-        HitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
-
-    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
-    if (spellId)
-    {
-        if (Player *modOwner = GetSpellModOwner())
-            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_MISS_CHANCE, HitChance);
-    }
-
-    // Miss = 100 - hit
-    float miss_chance = 100.0f - HitChance;
-
-    // Bonuses from attacker aura and ratings
-    if (attType == RANGED_ATTACK)
-        miss_chance -= m_modRangedHitChance;
-    else
-        miss_chance -= m_modMeleeHitChance;
-
-    // bonus from skills is 0.04%
-    //miss_chance -= skillDiff * 0.04f;
-    int32 diff = -skillDiff;
-    if (pVictim->GetTypeId() == TYPEID_PLAYER)
-        miss_chance += diff > 0 ? diff * 0.04f : diff * 0.02f;
-    else
-        miss_chance += diff > 10 ? 2 + (diff - 10) * 0.4f : diff * 0.1f;
-
-    // Limit miss chance from 0 to 60%
-    if (miss_chance < 0.0f)
-        return 0.0f;
-    if (miss_chance > 60.0f)
-        return 60.0f;
-    return miss_chance;
-}
-
-void Unit::SetPhaseMask(uint32 newPhaseMask, bool update)
-{
-    if (newPhaseMask == GetPhaseMask())
-        return;
-
-    if (IsInWorld())
-        RemoveNotOwnSingleTargetAuras(newPhaseMask);        // we can lost access to caster or target
-
-    WorldObject::SetPhaseMask(newPhaseMask,update);
-
-    if (!IsInWorld())
-        return;
-
-    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
-        if ((*itr)->GetTypeId() == TYPEID_UNIT)
-            (*itr)->SetPhaseMask(newPhaseMask,true);
-
-    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
-        if (m_SummonSlot[i])
-            if (Creature *summon = GetMap()->GetCreature(m_SummonSlot[i]))
-                summon->SetPhaseMask(newPhaseMask,true);
-}
-
-void Unit::UpdateObjectVisibility(bool forced)
-{
-    if (!forced)
-        AddToNotify(NOTIFY_VISIBILITY_CHANGED);
-    else
-    {
-        WorldObject::UpdateObjectVisibility(true);
-        // call MoveInLineOfSight for nearby creatures
-        Trinity::AIRelocationNotifier notifier(*this);
-        VisitNearbyObject(GetMap()->GetVisibilityDistance(), notifier);
-    }
-}
-
-void Unit::KnockbackFrom(float x, float y, float speedXY, float speedZ)
-{
-    Player *player = NULL;
-    if (GetTypeId() == TYPEID_PLAYER)
-        player = (Player*)this;
-    else
-    {
-        player = dynamic_cast<Player*>(GetCharmer());
-        if (player && player->m_mover != this)
-            player = NULL;
-    }
-
-    if (!player)
-    {
-        GetMotionMaster()->MoveKnockbackFrom(x, y, speedXY, speedZ);
-    }
-    else
-    {
-        float vcos, vsin;
-        GetSinCos(x, y, vsin, vcos);
-
-        WorldPacket data(SMSG_MOVE_KNOCK_BACK, (8+4+4+4+4+4));
-        data.append(GetPackGUID());
-        data << uint32(0);                                      // Sequence
-        data << float(vcos);                                    // x direction
-        data << float(vsin);                                    // y direction
-        data << float(speedXY);                                 // Horizontal speed
-        data << float(-speedZ);                                 // Z Movement speed (vertical)
-
-        player->GetSession()->SendPacket(&data);
-    }
-}
-
-float Unit::GetCombatRatingReduction(CombatRating cr) const
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-        return ((Player const*)this)->GetRatingBonusValue(cr);
-    else if (((Creature const*)this)->isPet())
-    {
-        // Player's pet get resilience from owner
-        if (Unit* owner = GetOwner())
-            if (owner->GetTypeId() == TYPEID_PLAYER)
-                return ((Player*)owner)->GetRatingBonusValue(cr);
-    }
-
-    return 0.0f;
-}
-
-uint32 Unit::GetCombatRatingDamageReduction(CombatRating cr, float rate, float cap, uint32 damage) const
-{
-    float percent = GetCombatRatingReduction(cr) * rate;
-    if (percent > cap)
-        percent = cap;
-    return uint32 (percent * damage / 100.0f);
-}
-
-uint32 Unit::GetModelForForm(ShapeshiftForm form)
-{
-    switch(form)
-    {
-        case FORM_CAT:
-            // Based on Hair color
-            if (getRace() == RACE_NIGHTELF)
-            {
-                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
-                switch (hairColor)
-                {
-                    case 7: // Violet
-                    case 8:
-                        return 29405;
-                    case 3: // Light Blue
-                        return 29406;
-                    case 0: // Green
-                    case 1: // Light Green
-                    case 2: // Dark Green
-                        return 29407;
-                    case 4: // White
-                        return 29408;
-                    default: // original - Dark Blue
-                        return 892;
-                }
-            }
-            // Based on Skin color
-            else if (getRace() == RACE_TAUREN)
-            {
-                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
-                // Male
-                if (getGender() == GENDER_MALE)
-                {
-                    switch(skinColor)
-                    {
-                        case 12: // White
-                        case 13:
-                        case 14:
-                        case 18: // Completly White
-                            return 29409;
-                        case 9: // Light Brown
-                        case 10:
-                        case 11:
-                            return 29410;
-                        case 6: // Brown
-                        case 7:
-                        case 8:
-                            return 29411;
-                        case 0: // Dark
-                        case 1:
-                        case 2:
-                        case 3: // Dark Grey
-                        case 4:
-                        case 5:
-                            return 29412;
-                        default: // original - Grey
-                            return 8571;
-                    }
-                }
-                // Female
-                else switch (skinColor)
-                {
-                    case 10: // White
-                        return 29409;
-                    case 6: // Light Brown
-                    case 7:
-                        return 29410;
-                    case 4: // Brown
-                    case 5:
-                        return 29411;
-                    case 0: // Dark
-                    case 1:
-                    case 2:
-                    case 3:
-                        return 29412;
-                    default: // original - Grey
-                        return 8571;
-                }
-            }
-            else if (Player::TeamForRace(getRace()) == ALLIANCE)
-                return 892;
-            else
-                return 8571;
-        case FORM_DIREBEAR:
-        case FORM_BEAR:
-            // Based on Hair color
-            if (getRace() == RACE_NIGHTELF)
-            {
-                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
-                switch (hairColor)
-                {
-                    case 0: // Green
-                    case 1: // Light Green
-                    case 2: // Dark Green
-                        return 29413; // 29415?
-                    case 6: // Dark Blue
-                        return 29414;
-                    case 4: // White
-                        return 29416;
-                    case 3: // Light Blue
-                        return 29417;
-                    default: // original - Violet
-                        return 2281;
-                }
-            }
-            // Based on Skin color
-            else if (getRace() == RACE_TAUREN)
-            {
-                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
-                // Male
-                if (getGender() == GENDER_MALE)
-                {
-                    switch (skinColor)
-                    {
-                        case 0: // Dark (Black)
-                        case 1:
-                        case 2:
-                            return 29418;
-                        case 3: // White
-                        case 4:
-                        case 5:
-                        case 12:
-                        case 13:
-                        case 14:
-                            return 29419;
-                        case 9: // Light Brown/Grey
-                        case 10:
-                        case 11:
-                        case 15:
-                        case 16:
-                        case 17:
-                            return 29420;
-                        case 18: // Completly White
-                            return 29421;
-                        default: // original - Brown
-                            return 2289;
-                    }
-                }
-                // Female
-                else switch (skinColor)
-                {
-                    case 0: // Dark (Black)
-                    case 1:
-                        return 29418;
-                    case 2: // White
-                    case 3:
-                        return 29419;
-                    case 6: // Light Brown/Grey
-                    case 7:
-                    case 8:
-                    case 9:
-                        return 29420;
-                    case 10: // Completly White
-                        return 29421;
-                    default: // original - Brown
-                        return 2289;
-                }
-            }
-            else if (Player::TeamForRace(getRace()) == ALLIANCE)
-                return 2281;
-            else
-                return 2289;
-        case FORM_TRAVEL:
-            return 632;
-        case FORM_AQUA:
-            if (Player::TeamForRace(getRace()) == ALLIANCE)
-                return 2428;
-            else
-                return 2428;
-        case FORM_GHOUL:
-            return 24994;
-        case FORM_CREATUREBEAR:
-            return 902;
-        case FORM_GHOSTWOLF:
-            return 4613;
-        case FORM_FLIGHT:
-            if (Player::TeamForRace(getRace()) == ALLIANCE)
-                return 20857;
-            else
-                return 20872;
-        case FORM_MOONKIN:
-            if (Player::TeamForRace(getRace()) == ALLIANCE)
-                return 15374;
-            else
-                return 15375;
-        case FORM_FLIGHT_EPIC:
-            if (Player::TeamForRace(getRace()) == ALLIANCE)
-                return 21243;
-            else
-                return 21244;
-        case FORM_METAMORPHOSIS:
-            return 25277;
-        case FORM_MASTER_ANGLER:
-            return 15234;
-        case FORM_TREE:
-            return 864;
-        case FORM_SPIRITOFREDEMPTION:
-            return 16031;
-        default:
-            break;
-    }
-    return 0;
-}
-
-uint32 Unit::GetModelForTotem(PlayerTotemType totemType)
-{
-    switch(getRace())
-    {
-        case RACE_ORC:
-        {
-            switch(totemType)
-            {
-                case SUMMON_TYPE_TOTEM_FIRE:    //fire
-                    return 30758;
-                case SUMMON_TYPE_TOTEM_EARTH:   //earth
-                    return 30757;
-                case SUMMON_TYPE_TOTEM_WATER:   //water
-                    return 30759;
-                case SUMMON_TYPE_TOTEM_AIR:     //air
-                    return 30756;
-            }
-            break;
-        }
-        case RACE_DWARF:
-        {
-            switch(totemType)
-            {
-                case SUMMON_TYPE_TOTEM_FIRE:    //fire
-                    return 30754;
-                case SUMMON_TYPE_TOTEM_EARTH:   //earth
-                    return 30753;
-                case SUMMON_TYPE_TOTEM_WATER:   //water
-                    return 30755;
-                case SUMMON_TYPE_TOTEM_AIR:     //air
-                    return 30736;
-            }
-            break;
-        }
-        case RACE_TROLL:
-        {
-            switch(totemType)
-            {
-                case SUMMON_TYPE_TOTEM_FIRE:    //fire
-                    return 30762;
-                case SUMMON_TYPE_TOTEM_EARTH:   //earth
-                    return 30761;
-                case SUMMON_TYPE_TOTEM_WATER:   //water
-                    return 30763;
-                case SUMMON_TYPE_TOTEM_AIR:     //air
-                    return 30760;
-            }
-            break;
-        }
-        case RACE_TAUREN:
-        {
-            switch(totemType)
-            {
-                case SUMMON_TYPE_TOTEM_FIRE:    //fire
-                    return 4589;
-                case SUMMON_TYPE_TOTEM_EARTH:   //earth
-                    return 4588;
-                case SUMMON_TYPE_TOTEM_WATER:   //water
-                    return 4587;
-                case SUMMON_TYPE_TOTEM_AIR:     //air
-                    return 4590;
-            }
-            break;
-        }
-        case RACE_DRAENEI:
-        {
-            switch(totemType)
-            {
-                case SUMMON_TYPE_TOTEM_FIRE:    //fire
-                    return 19074;
-                case SUMMON_TYPE_TOTEM_EARTH:   //earth
-                    return 19073;
-                case SUMMON_TYPE_TOTEM_WATER:   //water
-                    return 19075;
-                case SUMMON_TYPE_TOTEM_AIR:     //air
-                    return 19071;
-            }
-            break;
-        }
-    }
-    return 0;
-}
-
-void Unit::JumpTo(float speedXY, float speedZ, bool forward)
-{
-    float angle = forward ? 0 : M_PI;
-    if (GetTypeId() == TYPEID_UNIT)
-        GetMotionMaster()->MoveJumpTo(angle, speedXY, speedZ);
-    else
-    {
-        float vcos = cos(angle+GetOrientation());
-        float vsin = sin(angle+GetOrientation());
-
-        WorldPacket data(SMSG_MOVE_KNOCK_BACK, (8+4+4+4+4+4));
-        data.append(GetPackGUID());
-        data << uint32(0);                                      // Sequence
-        data << float(vcos);                                    // x direction
-        data << float(vsin);                                    // y direction
-        data << float(speedXY);                                 // Horizontal speed
-        data << float(-speedZ);                                 // Z Movement speed (vertical)
-
-        this->ToPlayer()->GetSession()->SendPacket(&data);
-    }
-}
-
-void Unit::JumpTo(WorldObject *obj, float speedZ)
-{
-    float x, y, z;
-    obj->GetContactPoint(this, x, y, z);
-    float speedXY = GetExactDist2d(x, y) * 10.0f / speedZ;
-    GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
-}
-
-bool Unit::CheckPlayerCondition(Player* pPlayer)
-{
-    switch(GetEntry())
-    {
-            case 35644: //Argent Warhorse
-            case 36558: //Argent Battleworg
-                if (!pPlayer->HasItemOrGemWithIdEquipped(46106,1)) //Check item Argent Lance
-                    return false;
-            default:
-                return true;
-    }
-}
-
-void Unit::EnterVehicle(Vehicle *vehicle, int8 seatId)
-{
-    if (!isAlive() || GetVehicleKit() == vehicle)
-        return;
-
-    if (m_vehicle)
-    {
-        if (m_vehicle == vehicle)
-        {
-            if (seatId >= 0)
-            {
-                sLog.outDebug("EnterVehicle: %u leave vehicle %u seat %d and enter %d.", GetEntry(), m_vehicle->GetBase()->GetEntry(), GetTransSeat(), seatId);
-                ChangeSeat(seatId);
-            }
-            return;
-        }
-        else
-        {
-            sLog.outDebug("EnterVehicle: %u exit %u and enter %u.", GetEntry(), m_vehicle->GetBase()->GetEntry(), vehicle->GetBase()->GetEntry());
-            ExitVehicle();
-        }
-    }
-
-    if (Player* plr = ToPlayer())
-    {
-        if (vehicle->GetBase()->GetTypeId() == TYPEID_PLAYER && plr->isInCombat())
-            return;
-
-        InterruptNonMeleeSpells(false);
-        plr->StopCastingCharm();
-        plr->StopCastingBindSight();
-        Unmount();
-        RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-        // drop flag at invisible in bg
-        if (Battleground *bg = plr->GetBattleground())
-            bg->EventPlayerDroppedFlag(plr);
-    }
-
-    ASSERT(!m_vehicle);
-    m_vehicle = vehicle;
-    if (!m_vehicle->AddPassenger(this, seatId))
-    {
-        m_vehicle = NULL;
-        return;
-    }
-
-    SetControlled(true, UNIT_STAT_ROOT);
-    //movementInfo is set in AddPassenger
-    //packets are sent in AddPassenger
-
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        //this->ToPlayer()->SetClientControl(vehicle, 1);
-        WorldPacket data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
-        this->ToPlayer()->GetSession()->SendPacket(&data);
-    }
-}
-
-void Unit::ChangeSeat(int8 seatId, bool next)
-{
-    if (!m_vehicle)
-        return;
-
-    if (seatId < 0)
-    {
-        seatId = m_vehicle->GetNextEmptySeat(GetTransSeat(), next);
-        if (seatId < 0)
-            return;
-    }
-    else if (seatId == GetTransSeat() || !m_vehicle->HasEmptySeat(seatId))
-        return;
-
-    m_vehicle->RemovePassenger(this);
-    if (!m_vehicle->AddPassenger(this, seatId))
-        ASSERT(false);
-}
-
-void Unit::ExitVehicle()
-{
-    if (!m_vehicle)
-        return;
-
-    Unit *vehicleBase = m_vehicle->GetBase();
-    const AuraEffectList &modAuras = vehicleBase->GetAuraEffectsByType(SPELL_AURA_CONTROL_VEHICLE);
-    for (AuraEffectList::const_iterator itr = modAuras.begin(); itr != modAuras.end(); ++itr)
-    {
-        if ((*itr)->GetBase()->GetOwner() == this)
-        {
-            vehicleBase->RemoveAura((*itr)->GetBase());
-            break; // there should be no case that a vehicle has two auras for one owner
-        }
-    }
-
-    if (!m_vehicle)
-        return;
-
-    //sLog.outError("exit vehicle");
-
-    m_vehicle->RemovePassenger(this);
-
-    // This should be done before dismiss, because there may be some aura removal
-    Vehicle *vehicle = m_vehicle;
-    m_vehicle = NULL;
-
-    SetControlled(false, UNIT_STAT_ROOT);
-
-    RemoveUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT);
-    m_movementInfo.t_pos.Relocate(0, 0, 0, 0);
-    m_movementInfo.t_time = 0;
-    m_movementInfo.t_seat = 0;
-
-    Relocate(vehicle->GetBase());
-
-    //Send leave vehicle, not correct
-    if (GetTypeId() == TYPEID_PLAYER)
-    {
-        //this->ToPlayer()->SetClientControl(this, 1);
-        this->ToPlayer()->SendTeleportAckPacket();
-        this->ToPlayer()->SetFallInformation(0, GetPositionZ());
-    }
-    WorldPacket data;
-    BuildHeartBeatMsg(&data);
-    SendMessageToSet(&data, false);
-
-    if (vehicle->GetBase()->HasUnitTypeMask(UNIT_MASK_MINION))
-        if (((Minion*)vehicle->GetBase())->GetOwner() == this)
-            vehicle->Dismiss();
-}
-
-void Unit::BuildMovementPacket(ByteBuffer *data) const
-{
-    switch (GetTypeId())
-    {
-        case TYPEID_UNIT:
-            if (canFly())
-                const_cast<Unit*>(this)->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-            break;
-        case TYPEID_PLAYER:
-            // remove unknown, unused etc flags for now
-            const_cast<Unit*>(this)->RemoveUnitMovementFlag(MOVEMENTFLAG_SPLINE_ENABLED);
-            if (isInFlight())
-            {
-                WPAssert(const_cast<Unit*>(this)->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE);
-                const_cast<Unit*>(this)->AddUnitMovementFlag(MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_SPLINE_ENABLED);
-            }
-            break;
-        default:
-            break;
-    }
-
-    *data << uint32(GetUnitMovementFlags()); // movement flags
-    *data << uint16(m_movementInfo.flags2);    // 2.3.0
-    *data << uint32(getMSTime());            // time
-    *data << GetPositionX();
-    *data << GetPositionY();
-    *data << GetPositionZ();
-    *data << GetOrientation();
-
-    // 0x00000200
-    if (GetUnitMovementFlags() & MOVEMENTFLAG_ONTRANSPORT)
-    {
-        if (m_vehicle)
-            data->append(m_vehicle->GetBase()->GetPackGUID());
-        else if (GetTransport())
-            data->append(GetTransport()->GetPackGUID());
-        else
-        {
-            sLog.outError("Unit %u does not have transport!", GetEntry());
-            *data << (uint8)0;
-        }
-        *data << float (GetTransOffsetX());
-        *data << float (GetTransOffsetY());
-        *data << float (GetTransOffsetZ());
-        *data << float (GetTransOffsetO());
-        *data << uint32(GetTransTime());
-        *data << uint8 (GetTransSeat());
-    }
-
-    // 0x02200000
-    if ((GetUnitMovementFlags() & (MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_FLYING))
-        || (m_movementInfo.flags2 & MOVEMENTFLAG2_ALWAYS_ALLOW_PITCHING))
-        *data << (float)m_movementInfo.pitch;
-
-    *data << (uint32)m_movementInfo.fallTime;
-
-    // 0x00001000
-    if (GetUnitMovementFlags() & MOVEMENTFLAG_JUMPING)
-    {
-        *data << (float)m_movementInfo.j_zspeed;
-        *data << (float)m_movementInfo.j_sinAngle;
-        *data << (float)m_movementInfo.j_cosAngle;
-        *data << (float)m_movementInfo.j_xyspeed;
-    }
-
-    // 0x04000000
-    if (GetUnitMovementFlags() & MOVEMENTFLAG_SPLINE_ELEVATION)
-        *data << (float)m_movementInfo.splineElevation;
-}
-
-void Unit::SetFlying(bool apply)
-{
-    if (apply)
-    {
-        SetByteFlag(UNIT_FIELD_BYTES_1, 3, 0x02);
-        AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING);
-    }
-    else
-    {
-        RemoveByteFlag(UNIT_FIELD_BYTES_1, 3, 0x02);
-        RemoveUnitMovementFlag(MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING);
-    }
-}
-
-void Unit::NearTeleportTo(float x, float y, float z, float orientation, bool casting /*= false*/)
-{
-    if (GetTypeId() == TYPEID_PLAYER)
-        this->ToPlayer()->TeleportTo(GetMapId(), x, y, z, orientation, TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (casting ? TELE_TO_SPELL : 0));
-    else
-    {
-        // FIXME: this interrupts spell visual
-        DestroyForNearbyPlayers();
-        SetPosition(x, y, z, orientation, true);
-    }
-}
-
-bool Unit::SetPosition(float x, float y, float z, float orientation, bool teleport)
-{
-    // prevent crash when a bad coord is sent by the client
-    if (!Trinity::IsValidMapCoord(x,y,z,orientation))
-    {
-        sLog.outDebug("Unit::SetPosition(%f, %f, %f) .. bad coordinates!",x,y,z);
-        return false;
-    }
-
-    bool turn = (GetOrientation() != orientation);
-    bool relocated = (teleport || GetPositionX() != x || GetPositionY() != y || GetPositionZ() != z);
-
-    if (turn)
-        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
-
-    if (relocated)
-    {
-        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
-
-        // move and update visible state if need
-        if (GetTypeId() == TYPEID_PLAYER)
-            GetMap()->PlayerRelocation((Player*)this, x, y, z, orientation);
-        else
-            GetMap()->CreatureRelocation(this->ToCreature(), x, y, z, orientation);
-    }
-    else if (turn)
-        SetOrientation(orientation);
-
-    if ((relocated || turn) && IsVehicle())
-        GetVehicleKit()->RelocatePassengers(x,y,z,orientation);
-
-    return (relocated || turn);
-}
-
-void Unit::SendThreatListUpdate()
-{
-    if (uint32 count = getThreatManager().getThreatList().size())
-    {
-        //sLog.outDebug("WORLD: Send SMSG_THREAT_UPDATE Message");
-        WorldPacket data(SMSG_THREAT_UPDATE, 8 + count * 8);
-        data.append(GetPackGUID());
-        data << uint32(count);
-        std::list<HostileReference*>& tlist = getThreatManager().getThreatList();
-        for (std::list<HostileReference*>::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)
-        {
-            data.appendPackGUID((*itr)->getUnitGuid());
-            data << uint32((*itr)->getThreat());
-        }
-        SendMessageToSet(&data, false);
-    }
-}
-
-void Unit::SendChangeCurrentVictimOpcode(HostileReference* pHostileReference)
-{
-    if (uint32 count = getThreatManager().getThreatList().size())
-    {
-        sLog.outDebug("WORLD: Send SMSG_HIGHEST_THREAT_UPDATE Message");
-        WorldPacket data(SMSG_HIGHEST_THREAT_UPDATE, 8 + 8 + count * 8);
-        data.append(GetPackGUID());
-        data.appendPackGUID(pHostileReference->getUnitGuid());
-        data << uint32(count);
-        std::list<HostileReference*>& tlist = getThreatManager().getThreatList();
-        for (std::list<HostileReference*>::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)
-        {
-            data.appendPackGUID((*itr)->getUnitGuid());
-            data << uint32((*itr)->getThreat());
-        }
-        SendMessageToSet(&data, false);
-    }
-}
-
-void Unit::SendClearThreatListOpcode()
-{
-    sLog.outDebug("WORLD: Send SMSG_THREAT_CLEAR Message");
-    WorldPacket data(SMSG_THREAT_CLEAR, 8);
-    data.append(GetPackGUID());
-    SendMessageToSet(&data, false);
-}
-
-void Unit::SendRemoveFromThreatListOpcode(HostileReference* pHostileReference)
-{
-    sLog.outDebug("WORLD: Send SMSG_THREAT_REMOVE Message");
-    WorldPacket data(SMSG_THREAT_REMOVE, 8 + 8);
-    data.append(GetPackGUID());
-    data.appendPackGUID(pHostileReference->getUnitGuid());
-    SendMessageToSet(&data, false);
-}
-
-void Unit::RewardRage(uint32 damage, uint32 weaponSpeedHitFactor, bool attacker)
-{
-    float addRage;
-
-    float rageconversion = ((0.0091107836f * getLevel()*getLevel())+3.225598133f*getLevel())+4.2652911f;
-
-    // Unknown if correct, but lineary adjust rage conversion above level 70
-    if (getLevel() > 70)
-        rageconversion += 13.27f*(getLevel()-70);
-
-    if (attacker)
-    {
-        addRage = ((damage/rageconversion*7.5f + weaponSpeedHitFactor)/2);
-
-        // talent who gave more rage on attack
-        addRage *= 1.0f + GetTotalAuraModifier(SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT) / 100.0f;
-    }
-    else
-    {
-        addRage = damage/rageconversion*2.5f;
-
-        // Berserker Rage effect
-        if (HasAura(18499))
-            addRage *= 2.0f;
-    }
-
-    addRage *= sWorld.getRate(RATE_POWER_RAGE_INCOME);
-
-    ModifyPower(POWER_RAGE, uint32(addRage*10));
-}
-
-void Unit::StopAttackFaction(uint32 faction_id)
-{
-    if (Unit* victim = getVictim())
-    {
-        if (victim->getFactionTemplateEntry()->faction == faction_id)
-        {
-            AttackStop();
-            if (IsNonMeleeSpellCasted(false))
-                InterruptNonMeleeSpells(false);
-
-            // melee and ranged forced attack cancel
-            if (GetTypeId() == TYPEID_PLAYER)
-                this->ToPlayer()->SendAttackSwingCancelAttack();
-        }
-    }
-
-    AttackerSet const& attackers = getAttackers();
-    for (AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
-    {
-        if ((*itr)->getFactionTemplateEntry()->faction == faction_id)
-        {
-            (*itr)->AttackStop();
-            itr = attackers.begin();
-        }
-        else
-            ++itr;
-    }
-
-    getHostileRefManager().deleteReferencesForFaction(faction_id);
-
-    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
-            (*itr)->StopAttackFaction(faction_id);
-}
-
-void Unit::OutDebugInfo() const
-{
-    sLog.outError("Unit::OutDebugInfo");
-    sLog.outString("GUID "UI64FMTD", entry %u, type %u, name %s", GetGUID(), GetEntry(), (uint32)GetTypeId(), GetName());
-    sLog.outString("OwnerGUID "UI64FMTD", MinionGUID "UI64FMTD", CharmerGUID "UI64FMTD", CharmedGUID "UI64FMTD, GetOwnerGUID(), GetMinionGUID(), GetCharmerGUID(), GetCharmGUID());
-    sLog.outString("In world %u, unit type mask %u", (uint32)(IsInWorld() ? 1 : 0), m_unitTypeMask);
-    if (IsInWorld())
-        sLog.outString("Mapid %u", GetMapId());
-
-    sLog.outStringInLine("Summon Slot: ");
-    for (uint32 i = 0; i < MAX_SUMMON_SLOT; ++i)
-        sLog.outStringInLine(UI64FMTD", ", m_SummonSlot[i]);
-    sLog.outString();
-
-    sLog.outStringInLine("Controlled List: ");
-    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
-        sLog.outStringInLine(UI64FMTD", ", (*itr)->GetGUID());
-    sLog.outString();
-
-    sLog.outStringInLine("Aura List: ");
-    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.begin(); itr != m_appliedAuras.end(); ++itr)
-        sLog.outStringInLine("%u, ", itr->first);
-    sLog.outString();
-
-    if (IsVehicle())
-    {
-        sLog.outStringInLine("Passenger List: ");
-        for (SeatMap::iterator itr = GetVehicleKit()->m_Seats.begin(); itr != GetVehicleKit()->m_Seats.end(); ++itr)
-            if (Unit *passenger = itr->second.passenger)
-                sLog.outStringInLine(UI64FMTD", ", passenger->GetGUID());
-        sLog.outString();
-    }
-
-    if (GetVehicle())
-        sLog.outString("On vehicle %u.", GetVehicleBase()->GetEntry());
-}
-
-uint32 Unit::GetRemainingDotDamage(uint64 caster, uint32 spellId, uint8 effectIndex) const
-{
-    uint32 amount = 0;
-    AuraEffectList const& DoTAuras = GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
-    for (AuraEffectList::const_iterator i = DoTAuras.begin(); i != DoTAuras.end(); ++i)
-    {
-        if ((*i)->GetCasterGUID() != caster || (*i)->GetId() != spellId || (*i)->GetEffIndex() != effectIndex)
-            continue;
-        amount += ((*i)->GetAmount() * ((*i)->GetTotalTicks() - ((*i)->GetTickNumber()))) / (*i)->GetTotalTicks();
-        break;
-    }
-
-    return amount;
-}
-
-void CharmInfo::SetIsCommandAttack(bool val)
-{
-    m_isCommandAttack = val;
-}
-
-bool CharmInfo::IsCommandAttack()
-{
-    return m_isCommandAttack;
-}
-
-void CharmInfo::SaveStayPosition()
-{
-    m_unit->GetPosition(m_stayX, m_stayY, m_stayZ);
-}
-
-void CharmInfo::GetStayPosition(float &x, float &y, float &z)
-{
-    x = m_stayX;
-    y = m_stayY;
-    z = m_stayZ;
-}
-
-void CharmInfo::SetIsAtStay(bool val)
-{
-    m_isAtStay = val;
-}
-
-bool CharmInfo::IsAtStay()
-{
-    return m_isAtStay;
-}
-
-void CharmInfo::SetIsFollowing(bool val)
-{
-    m_isFollowing = val;
-}
-
-bool CharmInfo::IsFollowing()
-{
-    return m_isFollowing;
-}
-
-void CharmInfo::SetIsReturning(bool val)
-{
-    m_isReturning = val;
-}
-
-bool CharmInfo::IsReturning()
-{
-    return m_isReturning;
-}
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "CreatureAIImpl.h"
+#include "Log.h"
+#include "Opcodes.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "SpellMgr.h"
+#include "Unit.h"
+#include "QuestDef.h"
+#include "Player.h"
+#include "Creature.h"
+#include "Spell.h"
+#include "Group.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "MapManager.h"
+#include "ObjectAccessor.h"
+#include "CreatureAI.h"
+#include "Formulas.h"
+#include "Pet.h"
+#include "Util.h"
+#include "Totem.h"
+#include "Battleground.h"
+#include "OutdoorPvP.h"
+#include "InstanceSaveMgr.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+#include "Path.h"
+#include "CreatureGroups.h"
+#include "PetAI.h"
+#include "PassiveAI.h"
+#include "Traveller.h"
+#include "TemporarySummon.h"
+#include "Vehicle.h"
+#include "Transport.h"
+
+#include <math.h>
+
+float baseMoveSpeed[MAX_MOVE_TYPE] =
+{
+    2.5f,                  // MOVE_WALK
+    7.0f,                  // MOVE_RUN
+    2.5f,                  // MOVE_RUN_BACK
+    4.722222f,             // MOVE_SWIM
+    4.5f,                  // MOVE_SWIM_BACK
+    3.141594f,             // MOVE_TURN_RATE
+    7.0f,                  // MOVE_FLIGHT
+    4.5f,                  // MOVE_FLIGHT_BACK
+    3.14f                  // MOVE_PITCH_RATE
+};
+float playerBaseMoveSpeed[MAX_MOVE_TYPE] = {
+    2.5f,                  // MOVE_WALK
+    7.0f,                  // MOVE_RUN
+    2.5f,                  // MOVE_RUN_BACK
+    4.722222f,             // MOVE_SWIM
+    4.5f,                  // MOVE_SWIM_BACK
+    3.141594f,             // MOVE_TURN_RATE
+    7.0f,                  // MOVE_FLIGHT
+    4.5f,                  // MOVE_FLIGHT_BACK
+    3.14f                  // MOVE_PITCH_RATE
+};
+
+// Used for prepare can/can`t triggr aura
+static bool InitTriggerAuraData();
+// Define can trigger auras
+static bool isTriggerAura[TOTAL_AURAS];
+// Define can`t trigger auras (need for disable second trigger)
+static bool isNonTriggerAura[TOTAL_AURAS];
+// Triggered always, even from triggered spells
+static bool isAlwaysTriggeredAura[TOTAL_AURAS];
+// Prepare lists
+static bool procPrepared = InitTriggerAuraData();
+
+// we can disable this warning for this since it only
+// causes undefined behavior when passed to the base class constructor
+#ifdef _MSC_VER
+#pragma warning(disable:4355)
+#endif
+Unit::Unit(): WorldObject(),
+m_movedPlayer(NULL), IsAIEnabled(false), NeedChangeAI(false),
+m_ControlledByPlayer(false), i_AI(NULL), i_disabledAI(NULL), m_procDeep(0),
+m_removedAurasCount(0), i_motionMaster(this), m_ThreatManager(this), m_vehicle(NULL),
+m_vehicleKit(NULL), m_unitTypeMask(UNIT_MASK_NONE), m_HostileRefManager(this)
+{
+#ifdef _MSC_VER
+#pragma warning(default:4355)
+#endif
+    m_objectType |= TYPEMASK_UNIT;
+    m_objectTypeId = TYPEID_UNIT;
+
+    m_updateFlag = (UPDATEFLAG_HIGHGUID | UPDATEFLAG_LIVING | UPDATEFLAG_HAS_POSITION);
+
+    m_attackTimer[BASE_ATTACK] = 0;
+    m_attackTimer[OFF_ATTACK] = 0;
+    m_attackTimer[RANGED_ATTACK] = 0;
+    m_modAttackSpeedPct[BASE_ATTACK] = 1.0f;
+    m_modAttackSpeedPct[OFF_ATTACK] = 1.0f;
+    m_modAttackSpeedPct[RANGED_ATTACK] = 1.0f;
+
+    m_extraAttacks = 0;
+    m_canDualWield = false;
+
+    m_rootTimes = 0;
+
+    m_state = 0;
+    m_form = FORM_NONE;
+    m_deathState = ALIVE;
+
+    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
+        m_currentSpells[i] = NULL;
+
+    m_addDmgOnce = 0;
+
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        m_SummonSlot[i] = 0;
+
+    m_ObjectSlot[0] = m_ObjectSlot[1] = m_ObjectSlot[2] = m_ObjectSlot[3] = 0;
+
+    m_auraUpdateIterator = m_ownedAuras.end();
+    m_Visibility = VISIBILITY_ON;
+
+    m_interruptMask = 0;
+    m_detectInvisibilityMask = 0;
+    m_invisibilityMask = 0;
+    m_transform = 0;
+    m_ShapeShiftFormSpellId = 0;
+    m_canModifyStats = false;
+
+    for (uint8 i = 0; i < MAX_SPELL_IMMUNITY; ++i)
+        m_spellImmune[i].clear();
+    for (uint8 i = 0; i < UNIT_MOD_END; ++i)
+    {
+        m_auraModifiersGroup[i][BASE_VALUE] = 0.0f;
+        m_auraModifiersGroup[i][BASE_PCT] = 1.0f;
+        m_auraModifiersGroup[i][TOTAL_VALUE] = 0.0f;
+        m_auraModifiersGroup[i][TOTAL_PCT] = 1.0f;
+    }
+                                                            // implement 50% base damage from offhand
+    m_auraModifiersGroup[UNIT_MOD_DAMAGE_OFFHAND][TOTAL_PCT] = 0.5f;
+
+    for (uint8 i = 0; i < MAX_ATTACK; ++i)
+    {
+        m_weaponDamage[i][MINDAMAGE] = BASE_MINDAMAGE;
+        m_weaponDamage[i][MAXDAMAGE] = BASE_MAXDAMAGE;
+    }
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+        m_createStats[i] = 0.0f;
+
+    m_attacking = NULL;
+    m_modMeleeHitChance = 0.0f;
+    m_modRangedHitChance = 0.0f;
+    m_modSpellHitChance = 0.0f;
+    m_baseSpellCritChance = 5;
+
+    m_CombatTimer = 0;
+    m_lastManaUse = 0;
+
+    //m_victimThreat = 0.0f;
+    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
+        m_threatModifier[i] = 1.0f;
+    m_isSorted = true;
+    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
+        m_speed_rate[i] = 1.0f;
+
+    m_charmInfo = NULL;
+    //m_unit_movement_flags = 0;
+    m_reducedThreatPercent = 0;
+    m_misdirectionTargetGUID = 0;
+
+    // remove aurastates allowing special moves
+    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
+        m_reactiveTimer[i] = 0;
+
+    m_cleanupDone = false;
+    m_duringRemoveFromWorld = false;
+}
+
+Unit::~Unit()
+{
+    // set current spells as deletable
+    for (uint8 i = 0; i < CURRENT_MAX_SPELL; ++i)
+    {
+        if (m_currentSpells[i])
+        {
+            m_currentSpells[i]->SetReferencedFromCurrent(false);
+            m_currentSpells[i] = NULL;
+        }
+    }
+
+    RemoveAllGameObjects();
+    RemoveAllDynObjects();
+    _DeleteRemovedAuras();
+
+    delete m_charmInfo;
+    delete m_vehicleKit;
+
+    ASSERT(!m_duringRemoveFromWorld);
+    ASSERT(!m_attacking);
+    ASSERT(m_attackers.empty());
+    ASSERT(m_sharedVision.empty());
+    ASSERT(m_Controlled.empty());
+    ASSERT(m_appliedAuras.empty());
+    ASSERT(m_ownedAuras.empty());
+    ASSERT(m_removedAuras.empty());
+}
+
+void Unit::Update(uint32 p_time)
+{
+    // WARNING! Order of execution here is important, do not change.
+    // Spells must be processed with event system BEFORE they go to _UpdateSpells.
+    // Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.
+    m_Events.Update(p_time);
+
+    if (!IsInWorld())
+        return;
+
+    _UpdateSpells(p_time);
+
+    // If this is set during update SetCantProc(false) call is missing somewhere in the code
+    // Having this would prevent spells from being proced, so let's crash
+    ASSERT(!m_procDeep);
+
+    if (CanHaveThreatList() && getThreatManager().isNeedUpdateToClient(p_time))
+        SendThreatListUpdate();
+
+    // update combat timer only for players and pets (only pets with PetAI)
+    if (isInCombat() && (GetTypeId() == TYPEID_PLAYER || (ToCreature()->isPet() && IsControlledByPlayer())))
+    {
+        // Check UNIT_STAT_MELEE_ATTACKING or UNIT_STAT_CHASE (without UNIT_STAT_FOLLOW in this case) so pets can reach far away
+        // targets without stopping half way there and running off.
+        // These flags are reset after target dies or another command is given.
+        if (m_HostileRefManager.isEmpty())
+        {
+            // m_CombatTimer set at aura start and it will be freeze until aura removing
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
+
+    //not implemented before 3.0.2
+    //if (!hasUnitState(UNIT_STAT_CASTING))
+    {
+        if (uint32 base_att = getAttackTimer(BASE_ATTACK))
+            setAttackTimer(BASE_ATTACK, (p_time >= base_att ? 0 : base_att - p_time));
+        if (uint32 ranged_att = getAttackTimer(RANGED_ATTACK))
+            setAttackTimer(RANGED_ATTACK, (p_time >= ranged_att ? 0 : ranged_att - p_time));
+        if (uint32 off_att = getAttackTimer(OFF_ATTACK))
+            setAttackTimer(OFF_ATTACK, (p_time >= off_att ? 0 : off_att - p_time));
+    }
+
+    // update abilities available only for fraction of time
+    UpdateReactives(p_time);
+
+    ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, HealthBelowPct(20));
+    ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, HealthBelowPct(35));
+    ModifyAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT, HealthAbovePct(75));
+
+    i_motionMaster.UpdateMotion(p_time);
+}
+
+bool Unit::haveOffhandWeapon() const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        return this->ToPlayer()->GetWeaponForAttack(OFF_ATTACK,true);
+    else
+        return m_canDualWield;
+}
+
+void Unit::SendMonsterMoveWithSpeedToCurrentDestination(Player* player)
+{
+    float x, y, z;
+    if (GetMotionMaster()->GetDestination(x, y, z))
+        SendMonsterMoveWithSpeed(x, y, z, 0, player);
+}
+
+
+void Unit::SendMonsterMoveWithSpeed(float x, float y, float z, uint32 transitTime, Player* player)
+{
+    if (!transitTime)
+    {
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            Traveller<Player> traveller(*(Player*)this);
+            transitTime = traveller.GetTotalTrevelTimeTo(x,y,z);
+        }
+        else
+        {
+            Traveller<Creature> traveller(*this->ToCreature());
+            transitTime = traveller.GetTotalTrevelTimeTo(x,y,z);
+        }
+    }
+    //float orientation = (float)atan2((double)dy, (double)dx);
+    SendMonsterMove(x, y, z, transitTime, player);
+}
+
+void Unit::SendMonsterStop(bool on_death)
+{
+    WorldPacket data(SMSG_MONSTER_MOVE, (17 + GetPackGUID().size()));
+    data.append(GetPackGUID());
+    data << uint8(0);                                       // new in 3.1
+    data << GetPositionX() << GetPositionY() << GetPositionZ();
+    data << getMSTime();
+
+    if (on_death == true)
+    {
+        data << uint8(0);
+        data << uint32((GetUnitMovementFlags() & MOVEMENTFLAG_LEVITATING) ? SPLINEFLAG_FLYING : SPLINEFLAG_WALKING);
+        data << uint32(0);                                      // Time in between points
+        data << uint32(1);                                      // 1 single waypoint
+        data << GetPositionX() << GetPositionY() << GetPositionZ();
+    }
+    else
+        data << uint8(1);
+
+    SendMessageToSet(&data, true);
+
+    clearUnitState(UNIT_STAT_MOVE);
+}
+
+void Unit::SendMonsterMove(float NewPosX, float NewPosY, float NewPosZ, uint32 Time, Player* player)
+{
+    WorldPacket data(SMSG_MONSTER_MOVE, 1+12+4+1+4+4+4+12+GetPackGUID().size());
+    data.append(GetPackGUID());
+
+    data << uint8(0);                                       // new in 3.1
+    data << GetPositionX() << GetPositionY() << GetPositionZ();
+    data << getMSTime();
+
+    data << uint8(0);
+    data << uint32((GetUnitMovementFlags() & MOVEMENTFLAG_LEVITATING) ? SPLINEFLAG_FLYING : SPLINEFLAG_WALKING);
+    data << Time;                                           // Time in between points
+    data << uint32(1);                                      // 1 single waypoint
+    data << NewPosX << NewPosY << NewPosZ;                  // the single waypoint Point B
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        SendMessageToSet(&data, true);
+
+    addUnitState(UNIT_STAT_MOVE);
+}
+
+void Unit::SendMonsterMove(float NewPosX, float NewPosY, float NewPosZ, uint32 MoveFlags, uint32 time, float speedZ, Player *player)
+{
+    WorldPacket data(SMSG_MONSTER_MOVE, 12+4+1+4+4+4+12+GetPackGUID().size());
+    data.append(GetPackGUID());
+
+    data << uint8(0);                                       // new in 3.1
+    data << GetPositionX() << GetPositionY() << GetPositionZ();
+    data << getMSTime();
+
+    data << uint8(0);
+    data << MoveFlags;
+
+    if (MoveFlags & SPLINEFLAG_TRAJECTORY)
+    {
+        data << time;
+        data << speedZ;
+        data << (uint32)0; // walk time after jump
+    }
+    else
+        data << time;
+
+    data << uint32(1);                                      // 1 single waypoint
+    data << NewPosX << NewPosY << NewPosZ;                  // the single waypoint Point B
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        SendMessageToSet(&data, true);
+}
+
+void Unit::SendMonsterMoveTransport(Unit *vehicleOwner)
+{
+    WorldPacket data(SMSG_MONSTER_MOVE_TRANSPORT, GetPackGUID().size()+vehicleOwner->GetPackGUID().size());
+    data.append(GetPackGUID());
+    data.append(vehicleOwner->GetPackGUID());
+    data << int8(GetTransSeat());
+    data << uint8(0);
+    data << GetPositionX() - vehicleOwner->GetPositionX();
+    data << GetPositionY() - vehicleOwner->GetPositionY();
+    data << GetPositionZ() - vehicleOwner->GetPositionZ();
+    data << uint32(getMSTime());
+    data << uint8(4);
+    data << GetTransOffsetO();
+    data << uint32(SPLINEFLAG_TRANSPORT);
+    data << uint32(0);// move time
+    data << uint32(0);//GetTransOffsetX();
+    data << uint32(0);//GetTransOffsetY();
+    data << uint32(0);//GetTransOffsetZ();
+    SendMessageToSet(&data, true);
+}
+
+void Unit::resetAttackTimer(WeaponAttackType type)
+{
+    m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type]);
+}
+
+bool Unit::IsWithinCombatRange(const Unit *obj, float dist2compare) const
+{
+    if (!obj || !IsInMap(obj)) return false;
+
+    float dx = GetPositionX() - obj->GetPositionX();
+    float dy = GetPositionY() - obj->GetPositionY();
+    float dz = GetPositionZ() - obj->GetPositionZ();
+    float distsq = dx*dx + dy*dy + dz*dz;
+
+    float sizefactor = GetCombatReach() + obj->GetCombatReach();
+    float maxdist = dist2compare + sizefactor;
+
+    return distsq < maxdist * maxdist;
+}
+
+bool Unit::IsWithinMeleeRange(const Unit *obj, float dist) const
+{
+    if (!obj || !IsInMap(obj)) return false;
+
+    float dx = GetPositionX() - obj->GetPositionX();
+    float dy = GetPositionY() - obj->GetPositionY();
+    float dz = GetPositionZ() - obj->GetPositionZ();
+    float distsq = dx*dx + dy*dy + dz*dz;
+
+    float sizefactor = GetMeleeReach() + obj->GetMeleeReach();
+    float maxdist = dist + sizefactor;
+
+    return distsq < maxdist * maxdist;
+}
+
+void Unit::GetRandomContactPoint(const Unit* obj, float &x, float &y, float &z, float distance2dMin, float distance2dMax) const
+{
+    float combat_reach = GetCombatReach();
+    if (combat_reach < 0.1) // sometimes bugged for players
+    {
+        //sLog.outError("Unit %u (Type: %u) has invalid combat_reach %f",GetGUIDLow(),GetTypeId(),combat_reach);
+        //if (GetTypeId() == TYPEID_UNIT)
+        //    sLog.outError("Creature entry %u has invalid combat_reach", this->ToCreature()->GetEntry());
+        combat_reach = DEFAULT_COMBAT_REACH;
+    }
+    uint32 attacker_number = getAttackers().size();
+    if (attacker_number > 0)
+        --attacker_number;
+    GetNearPoint(obj,x,y,z,obj->GetCombatReach(), distance2dMin+(distance2dMax-distance2dMin)*(float)rand_norm()
+        , GetAngle(obj) + (attacker_number ? (static_cast<float>(M_PI/2) - static_cast<float>(M_PI) * (float)rand_norm()) * float(attacker_number) / combat_reach * 0.3f : 0));
+}
+
+void Unit::UpdateInterruptMask()
+{
+    m_interruptMask = 0;
+    for (AuraApplicationList::const_iterator i = m_interruptableAuras.begin(); i != m_interruptableAuras.end(); ++i)
+        m_interruptMask |= (*i)->GetBase()->GetSpellProto()->AuraInterruptFlags;
+
+    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
+        if (spell->getState() == SPELL_STATE_CASTING)
+            m_interruptMask |= spell->m_spellInfo->ChannelInterruptFlags;
+}
+
+bool Unit::HasAuraTypeWithFamilyFlags(AuraType auraType, uint32 familyName, uint32 familyFlags) const
+{
+    if (!HasAuraType(auraType))
+        return false;
+    AuraEffectList const &auras = GetAuraEffectsByType(auraType);
+    for (AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        if (SpellEntry const *iterSpellProto = (*itr)->GetSpellProto())
+            if (iterSpellProto->SpellFamilyName == familyName && iterSpellProto->SpellFamilyFlags[0] & familyFlags)
+                return true;
+    return false;
+}
+
+void Unit::DealDamageMods(Unit *pVictim, uint32 &damage, uint32* absorb)
+{
+    if (!pVictim->isAlive() || pVictim->hasUnitState(UNIT_STAT_UNATTACKABLE) || (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode()))
+    {
+        if (absorb)
+            *absorb += damage;
+        damage = 0;
+        return;
+    }
+
+    //You don't lose health from damage taken from another player while in a sanctuary
+    //You still see it in the combat log though
+    if (pVictim != this && IsControlledByPlayer() && pVictim->IsControlledByPlayer())
+    {
+        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
+        if (area && area->IsSanctuary())      //sanctuary
+        {
+            if (absorb)
+                *absorb += damage;
+            damage = 0;
+        }
+    }
+
+    uint32 originalDamage = damage;
+
+    if (absorb && originalDamage > damage)
+        *absorb += (originalDamage - damage);
+}
+
+uint32 Unit::DealDamage(Unit *pVictim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellSchoolMask damageSchoolMask, SpellEntry const *spellProto, bool durabilityLoss)
+{
+    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsAIEnabled)
+        pVictim->ToCreature()->AI()->DamageTaken(this, damage);
+
+    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->IsAIEnabled)
+        this->ToCreature()->AI()->DamageDealt(pVictim, damage);
+
+    if (damagetype != NODAMAGE)
+    {
+        // interrupting auras with AURA_INTERRUPT_FLAG_DAMAGE before checking !damage (absorbed damage breaks that type of auras)
+        pVictim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TAKE_DAMAGE, spellProto ? spellProto->Id : 0);
+
+        // copy damage to casters of this aura
+        AuraEffectList const& vCopyDamage = pVictim->GetAuraEffectsByType(SPELL_AURA_SHARE_DAMAGE_PCT);
+        for (AuraEffectList::const_iterator i = vCopyDamage.begin(); i != vCopyDamage.end(); ++i)
+        {
+            // check damage school mask
+            if (((*i)->GetMiscValue() & damageSchoolMask) == 0)
+                continue;
+
+            Unit * shareDamageTarget = (*i)->GetCaster();
+            if (!shareDamageTarget)
+                continue;
+            SpellEntry const * spell = (*i)->GetSpellProto();
+
+            uint32 share = uint32(damage * (float((*i)->GetAmount()) / 100.0f));
+
+            // TODO: check packets if damage is done by pVictim, or by attacker of pVictim
+            DealDamageMods(shareDamageTarget, share, NULL);
+            DealDamage(shareDamageTarget, share, NULL, NODAMAGE, GetSpellSchoolMask(spell), spell, false);
+        }
+    }
+
+    // Rage from Damage made (only from direct weapon damage)
+    if (cleanDamage && damagetype == DIRECT_DAMAGE && this != pVictim && getPowerType() == POWER_RAGE)
+    {
+        uint32 weaponSpeedHitFactor;
+        uint32 rage_damage = damage + cleanDamage->absorbed_damage;
+
+        switch(cleanDamage->attackType)
+        {
+            case BASE_ATTACK:
+            {
+                weaponSpeedHitFactor = uint32(GetAttackTime(cleanDamage->attackType) / 1000.0f * 3.5f);
+                if (cleanDamage->hitOutCome == MELEE_HIT_CRIT)
+                    weaponSpeedHitFactor *= 2;
+
+                RewardRage(rage_damage, weaponSpeedHitFactor, true);
+
+                break;
+            }
+            case OFF_ATTACK:
+            {
+                weaponSpeedHitFactor = uint32(GetAttackTime(cleanDamage->attackType) / 1000.0f * 1.75f);
+                if (cleanDamage->hitOutCome == MELEE_HIT_CRIT)
+                    weaponSpeedHitFactor *= 2;
+
+                RewardRage(rage_damage, weaponSpeedHitFactor, true);
+
+                break;
+            }
+            case RANGED_ATTACK:
+                break;
+            default:
+                break;
+        }
+    }
+
+    if (!damage)
+    {
+        // Rage from absorbed damage
+        if (cleanDamage && cleanDamage->absorbed_damage && pVictim->getPowerType() == POWER_RAGE)
+            pVictim->RewardRage(cleanDamage->absorbed_damage, 0, false);
+
+        return 0;
+    }
+
+    sLog.outStaticDebug("DealDamageStart");
+
+    uint32 health = pVictim->GetHealth();
+    sLog.outDetail("deal dmg:%d to health:%d ",damage,health);
+
+    // duel ends when player has 1 or less hp
+    bool duel_hasEnded = false;
+    if (pVictim->GetTypeId() == TYPEID_PLAYER && pVictim->ToPlayer()->duel && damage >= (health-1))
+    {
+        // prevent kill only if killed in duel and killed by opponent or opponent controlled creature
+        if (pVictim->ToPlayer()->duel->opponent == this || pVictim->ToPlayer()->duel->opponent->GetGUID() == GetOwnerGUID())
+            damage = health - 1;
+
+        duel_hasEnded = true;
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER && this != pVictim)
+    {
+        Player *killer = this->ToPlayer();
+
+        // in bg, count dmg if victim is also a player
+        if (pVictim->GetTypeId() == TYPEID_PLAYER)
+            if (Battleground *bg = killer->GetBattleground())
+                bg->UpdatePlayerScore(killer, SCORE_DAMAGE_DONE, damage);
+
+        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, damage, 0, pVictim);
+        killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_DEALT, damage);
+    }
+
+    if (pVictim->GetTypeId() == TYPEID_PLAYER)
+        pVictim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_RECEIVED, damage);
+    else if (!pVictim->IsControlledByPlayer())
+    {
+        if (!pVictim->ToCreature()->hasLootRecipient())
+            pVictim->ToCreature()->SetLootRecipient(this);
+
+        if (IsControlledByPlayer())
+            pVictim->ToCreature()->LowerPlayerDamageReq(health < damage ?  health : damage);
+    }
+
+    if (health <= damage)
+    {
+        sLog.outStaticDebug("DealDamage: victim just died");
+
+        if (pVictim->GetTypeId() == TYPEID_PLAYER)
+        {
+            pVictim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, health);
+
+            // call before auras are removed
+            if (Player* killer = this->ToPlayer()) // keep the this-> for clarity
+                killer->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 0, 0, pVictim);
+        }
+
+        Kill(pVictim, durabilityLoss);
+    }
+    else
+    {
+        sLog.outStaticDebug("DealDamageAlive");
+
+        if (pVictim->GetTypeId() == TYPEID_PLAYER)
+            pVictim->ToPlayer()->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_DAMAGE_RECEIVED, damage);
+
+        pVictim->ModifyHealth(- (int32)damage);
+
+        if (damagetype == DIRECT_DAMAGE || damagetype == SPELL_DIRECT_DAMAGE)
+            pVictim->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_DIRECT_DAMAGE, spellProto ? spellProto->Id : 0);
+
+        if (pVictim->GetTypeId() != TYPEID_PLAYER)
+        {
+            if (spellProto && IsDamageToThreatSpell(spellProto))
+                pVictim->AddThreat(this, damage * 2.0f, damageSchoolMask, spellProto);
+            else
+                pVictim->AddThreat(this, (float)damage, damageSchoolMask, spellProto);
+        }
+        else                                                // victim is a player
+        {
+            // random durability for items (HIT TAKEN)
+            if (roll_chance_f(sWorld.getRate(RATE_DURABILITY_LOSS_DAMAGE)))
+            {
+                EquipmentSlots slot = EquipmentSlots(urand(0,EQUIPMENT_SLOT_END-1));
+                pVictim->ToPlayer()->DurabilityPointLossForEquipSlot(slot);
+            }
+        }
+
+        // Rage from damage received
+        if (this != pVictim && pVictim->getPowerType() == POWER_RAGE)
+        {
+            uint32 rage_damage = damage + (cleanDamage ? cleanDamage->absorbed_damage : 0);
+            pVictim->RewardRage(rage_damage, 0, false);
+        }
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // random durability for items (HIT DONE)
+            if (roll_chance_f(sWorld.getRate(RATE_DURABILITY_LOSS_DAMAGE)))
+            {
+                EquipmentSlots slot = EquipmentSlots(urand(0,EQUIPMENT_SLOT_END-1));
+                this->ToPlayer()->DurabilityPointLossForEquipSlot(slot);
+            }
+        }
+
+        if (damagetype != NODAMAGE && damage)
+        {
+            if (pVictim != this && pVictim->GetTypeId() == TYPEID_PLAYER) // does not support creature push_back
+            {
+                if (damagetype != DOT)
+                {
+                    if (Spell* spell = pVictim->m_currentSpells[CURRENT_GENERIC_SPELL])
+                    {
+                        if (spell->getState() == SPELL_STATE_PREPARING)
+                        {
+                            uint32 interruptFlags = spell->m_spellInfo->InterruptFlags;
+                            if (interruptFlags & SPELL_INTERRUPT_FLAG_ABORT_ON_DMG)
+                                pVictim->InterruptNonMeleeSpells(false);
+                            else if (interruptFlags & SPELL_INTERRUPT_FLAG_PUSH_BACK)
+                                spell->Delayed();
+                        }
+                    }
+                }
+
+                if (Spell* spell = pVictim->m_currentSpells[CURRENT_CHANNELED_SPELL])
+                {
+                    if (spell->getState() == SPELL_STATE_CASTING)
+                    {
+                        uint32 channelInterruptFlags = spell->m_spellInfo->ChannelInterruptFlags;
+                        if (((channelInterruptFlags & CHANNEL_FLAG_DELAY) != 0) && (damagetype != DOT))
+                            spell->DelayedChannel();
+                    }
+                }
+            }
+        }
+
+        // last damage from duel opponent
+        if (duel_hasEnded)
+        {
+            ASSERT(pVictim->GetTypeId() == TYPEID_PLAYER);
+            Player *he = pVictim->ToPlayer();
+
+            ASSERT(he->duel);
+
+            he->SetHealth(1);
+
+            he->duel->opponent->CombatStopWithPets(true);
+            he->CombatStopWithPets(true);
+
+            he->CastSpell(he, 7267, true);                  // beg
+            he->DuelComplete(DUEL_WON);
+        }
+    }
+
+    sLog.outStaticDebug("DealDamageEnd returned %d damage", damage);
+
+    return damage;
+}
+
+void Unit::CastStop(uint32 except_spellid)
+{
+    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
+        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id != except_spellid)
+            InterruptSpell(CurrentSpellTypes(i),false);
+}
+
+void Unit::CastSpell(Unit* Victim, uint32 spellId, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+
+    if (!spellInfo)
+    {
+        sLog.outError("CastSpell: unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    CastSpell(Victim,spellInfo,triggered,castItem,triggeredByAura, originalCaster);
+}
+
+void Unit::CastSpell(Unit* Victim,SpellEntry const *spellInfo, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
+{
+    if (!spellInfo)
+    {
+        sLog.outError("CastSpell: unknown spell by caster: %s %u)", (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    if (!originalCaster && GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem() && IsControlledByPlayer())
+        if (Unit * owner = GetOwner())
+            originalCaster=owner->GetGUID();
+
+    SpellCastTargets targets;
+    targets.setUnitTarget(Victim);
+
+    if (castItem)
+        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
+
+    if (!originalCaster && triggeredByAura)
+        originalCaster = triggeredByAura->GetCasterGUID();
+
+    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
+
+    spell->m_CastItem = castItem;
+    spell->prepare(&targets, triggeredByAura);
+}
+
+void Unit::CastCustomSpell(Unit* target, uint32 spellId, int32 const* bp0, int32 const* bp1, int32 const* bp2, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
+{
+    CustomSpellValues values;
+    if (bp0)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT0, *bp0);
+    if (bp1)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT1, *bp1);
+    if (bp2)
+        values.AddSpellMod(SPELLVALUE_BASE_POINT2, *bp2);
+    CastCustomSpell(spellId, values, target, triggered, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastCustomSpell(uint32 spellId, SpellValueMod mod, int32 value, Unit* target, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
+{
+    CustomSpellValues values;
+    values.AddSpellMod(mod, value);
+    CastCustomSpell(spellId, values, target, triggered, castItem, triggeredByAura, originalCaster);
+}
+
+void Unit::CastCustomSpell(uint32 spellId, CustomSpellValues const &value, Unit* Victim, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+    {
+        sLog.outError("CastSpell: unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    SpellCastTargets targets;
+    targets.setUnitTarget(Victim);
+
+    if (!originalCaster && triggeredByAura)
+        originalCaster = triggeredByAura->GetCasterGUID();
+
+    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
+
+    if (castItem)
+    {
+        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
+        spell->m_CastItem = castItem;
+    }
+
+    for (CustomSpellValues::const_iterator itr = value.begin(); itr != value.end(); ++itr)
+        spell->SetSpellValue(itr->first, itr->second);
+
+    spell->prepare(&targets, triggeredByAura);
+}
+
+// used for scripting
+void Unit::CastSpell(float x, float y, float z, uint32 spellId, bool triggered, Item *castItem, AuraEffect const * triggeredByAura, uint64 originalCaster, Unit* OriginalVictim)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+
+    if (!spellInfo)
+    {
+        sLog.outError("CastSpell(x,y,z): unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    if (castItem)
+        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
+
+    if (!originalCaster && triggeredByAura)
+        originalCaster = triggeredByAura->GetCasterGUID();
+
+    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
+
+    SpellCastTargets targets;
+    targets.setDst(x, y, z, GetOrientation());
+    if (OriginalVictim)
+        targets.setUnitTarget(OriginalVictim);
+    spell->m_CastItem = castItem;
+    spell->prepare(&targets, triggeredByAura);
+}
+
+// used for scripting
+void Unit::CastSpell(GameObject *go, uint32 spellId, bool triggered, Item *castItem, AuraEffect* triggeredByAura, uint64 originalCaster)
+{
+    if (!go)
+        return;
+
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+
+    if (!spellInfo)
+    {
+        sLog.outError("CastSpell(x,y,z): unknown spell id %i by caster: %s %u)", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    if (!(spellInfo->Targets & (TARGET_FLAG_OBJECT | TARGET_FLAG_OBJECT_CASTER)))
+    {
+        sLog.outError("CastSpell: spell id %i by caster: %s %u) is not gameobject spell", spellId,(GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"),(GetTypeId() == TYPEID_PLAYER ? GetGUIDLow() : GetEntry()));
+        return;
+    }
+
+    if (castItem)
+        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
+
+    if (!originalCaster && triggeredByAura)
+        originalCaster = triggeredByAura->GetCasterGUID();
+
+    Spell *spell = new Spell(this, spellInfo, triggered, originalCaster);
+
+    SpellCastTargets targets;
+    targets.setGOTarget(go);
+    spell->m_CastItem = castItem;
+    spell->prepare(&targets, triggeredByAura);
+}
+
+// Obsolete func need remove, here only for comotability vs another patches
+uint32 Unit::SpellNonMeleeDamageLog(Unit *pVictim, uint32 spellID, uint32 damage)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellID);
+    SpellNonMeleeDamage damageInfo(this, pVictim, spellInfo->Id, spellInfo->SchoolMask);
+    damage = SpellDamageBonus(pVictim, spellInfo, damage, SPELL_DIRECT_DAMAGE);
+    CalculateSpellDamageTaken(&damageInfo, damage, spellInfo);
+    DealDamageMods(damageInfo.target,damageInfo.damage,&damageInfo.absorb);
+    SendSpellNonMeleeDamageLog(&damageInfo);
+    DealSpellDamage(&damageInfo, true);
+    return damageInfo.damage;
+}
+
+void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage *damageInfo, int32 damage, SpellEntry const *spellInfo, WeaponAttackType attackType, bool crit)
+{
+    if (damage < 0)
+        return;
+
+    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_FIXED_DAMAGE)
+    {
+        damageInfo->damage = damage;
+        return;
+    }
+
+    Unit *pVictim = damageInfo->target;
+    if (!pVictim || !pVictim->isAlive())
+        return;
+
+    SpellSchoolMask damageSchoolMask = SpellSchoolMask(damageInfo->schoolMask);
+    uint32 crTypeMask = pVictim->GetCreatureTypeMask();
+
+    if (IsDamageReducedByArmor(damageSchoolMask, spellInfo))
+        damage = CalcArmorReducedDamage(pVictim, damage, spellInfo, attackType);
+
+    bool blocked = false;
+    // Per-school calc
+    switch (spellInfo->DmgClass)
+    {
+        // Melee and Ranged Spells
+        case SPELL_DAMAGE_CLASS_RANGED:
+        case SPELL_DAMAGE_CLASS_MELEE:
+            {
+                // Physical Damage
+                if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+                {
+                    // Get blocked status
+                    blocked = isSpellBlocked(pVictim, spellInfo, attackType);
+                }
+
+                if (crit)
+                {
+                    damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;
+
+                    // Calculate crit bonus
+                    uint32 crit_bonus = damage;
+                    // Apply crit_damage bonus for melee spells
+                    if (Player* modOwner = GetSpellModOwner())
+                        modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);
+                    damage += crit_bonus;
+
+                    // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
+                    int32 critPctDamageMod = 0;
+                    if (attackType == RANGED_ATTACK)
+                        critPctDamageMod += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
+                    else
+                    {
+                        critPctDamageMod += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
+                        critPctDamageMod += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS_MELEE);
+                    }
+                    // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS
+                    critPctDamageMod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);
+
+                    if (critPctDamageMod != 0)
+                        damage = int32(damage * float((100.0f + critPctDamageMod)/100.0f));
+                }
+
+                // Spell weapon based damage CAN BE crit & blocked at same time
+                if (blocked)
+                {
+                    damageInfo->blocked = pVictim->GetShieldBlockValue();
+                    //double blocked amount if block is critical
+                    if (pVictim->isBlockCritical())
+                        damageInfo->blocked += damageInfo->blocked;
+                    if (damage < int32(damageInfo->blocked))
+                        damageInfo->blocked = uint32(damage);
+                    damage -= damageInfo->blocked;
+                }
+
+                if (attackType != RANGED_ATTACK)
+                    ApplyResilience(pVictim, NULL, &damage, crit, CR_CRIT_TAKEN_MELEE);
+                else
+                    ApplyResilience(pVictim, NULL, &damage, crit, CR_CRIT_TAKEN_RANGED);
+            }
+            break;
+        // Magical Attacks
+        case SPELL_DAMAGE_CLASS_NONE:
+        case SPELL_DAMAGE_CLASS_MAGIC:
+            {
+                // If crit add critical bonus
+                if (crit)
+                {
+                    damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;
+                    damage = SpellCriticalDamageBonus(spellInfo, damage, pVictim);
+                }
+
+                ApplyResilience(pVictim, NULL, &damage, crit, CR_CRIT_TAKEN_SPELL);
+            }
+            break;
+    }
+
+    // Calculate absorb resist
+    if (damage > 0)
+    {
+        // Chaos Bolt - "Chaos Bolt cannot be resisted, and pierces through all absorption effects."
+        if (spellInfo->SpellIconID != 3178)
+        {
+            CalcAbsorbResist(pVictim, damageSchoolMask, SPELL_DIRECT_DAMAGE, damage, &damageInfo->absorb, &damageInfo->resist, spellInfo);
+            damage -= damageInfo->absorb + damageInfo->resist;
+        }
+    }
+    else
+        damage = 0;
+
+    damageInfo->damage = damage;
+}
+
+void Unit::DealSpellDamage(SpellNonMeleeDamage *damageInfo, bool durabilityLoss)
+{
+    if (damageInfo == 0)
+        return;
+
+    Unit *pVictim = damageInfo->target;
+
+    if (!pVictim)
+        return;
+
+    if (!pVictim->isAlive() || pVictim->hasUnitState(UNIT_STAT_UNATTACKABLE) || (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode()))
+        return;
+
+    SpellEntry const *spellProto = sSpellStore.LookupEntry(damageInfo->SpellID);
+    if (spellProto == NULL)
+    {
+        sLog.outDebug("Unit::DealSpellDamage have wrong damageInfo->SpellID: %u", damageInfo->SpellID);
+        return;
+    }
+
+    //You don't lose health from damage taken from another player while in a sanctuary
+    //You still see it in the combat log though
+    if (pVictim != this && IsControlledByPlayer() && pVictim->IsControlledByPlayer())
+    {
+        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
+
+        if (area && area->IsSanctuary())       // sanctuary
+            return;
+    }
+
+    // Call default DealDamage
+    CleanDamage cleanDamage(damageInfo->cleanDamage, damageInfo->absorb, BASE_ATTACK, MELEE_HIT_NORMAL);
+    DealDamage(pVictim, damageInfo->damage, &cleanDamage, SPELL_DIRECT_DAMAGE, SpellSchoolMask(damageInfo->schoolMask), spellProto, durabilityLoss);
+}
+
+//TODO for melee need create structure as in
+void Unit::CalculateMeleeDamage(Unit *pVictim, uint32 damage, CalcDamageInfo *damageInfo, WeaponAttackType attackType)
+{
+    damageInfo->attacker         = this;
+    damageInfo->target           = pVictim;
+    damageInfo->damageSchoolMask = GetMeleeDamageSchoolMask();
+    damageInfo->attackType       = attackType;
+    damageInfo->damage           = 0;
+    damageInfo->cleanDamage      = 0;
+    damageInfo->absorb           = 0;
+    damageInfo->resist           = 0;
+    damageInfo->blocked_amount   = 0;
+
+    damageInfo->TargetState      = 0;
+    damageInfo->HitInfo          = 0;
+    damageInfo->procAttacker     = PROC_FLAG_NONE;
+    damageInfo->procVictim       = PROC_FLAG_NONE;
+    damageInfo->procEx           = PROC_EX_NONE;
+    damageInfo->hitOutCome       = MELEE_HIT_EVADE;
+
+    if (!pVictim)
+        return;
+    if (!isAlive() || !pVictim->isAlive())
+        return;
+
+    // Select HitInfo/procAttacker/procVictim flag based on attack type
+    switch (attackType)
+    {
+        case BASE_ATTACK:
+            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_MAINHAND_ATTACK;
+            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
+            damageInfo->HitInfo      = HITINFO_NORMALSWING2;
+            break;
+        case OFF_ATTACK:
+            damageInfo->procAttacker = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_OFFHAND_ATTACK;
+            damageInfo->procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
+            damageInfo->HitInfo = HITINFO_LEFTSWING;
+            break;
+        default:
+            return;
+    }
+
+    // Physical Immune check
+    if (damageInfo->target->IsImmunedToDamage(SpellSchoolMask(damageInfo->damageSchoolMask)))
+    {
+       damageInfo->HitInfo       |= HITINFO_NORMALSWING;
+       damageInfo->TargetState    = VICTIMSTATE_IS_IMMUNE;
+
+       damageInfo->procEx        |= PROC_EX_IMMUNE;
+       damageInfo->damage         = 0;
+       damageInfo->cleanDamage    = 0;
+       return;
+    }
+
+    damage += CalculateDamage(damageInfo->attackType, false, true);
+    // Add melee damage bonus
+    MeleeDamageBonus(damageInfo->target, &damage, damageInfo->attackType);
+
+    // Calculate armor reduction
+    if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
+    {
+        damageInfo->damage = CalcArmorReducedDamage(damageInfo->target, damage, NULL , damageInfo->attackType);
+        damageInfo->cleanDamage += damage - damageInfo->damage;
+    }
+    else
+        damageInfo->damage = damage;
+
+    damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
+
+    switch (damageInfo->hitOutCome)
+    {
+        case MELEE_HIT_EVADE:
+            {
+                damageInfo->HitInfo    |= HITINFO_MISS|HITINFO_SWINGNOHITSOUND;
+                damageInfo->TargetState = VICTIMSTATE_EVADES;
+
+                damageInfo->procEx|=PROC_EX_EVADE;
+                damageInfo->damage = 0;
+                damageInfo->cleanDamage = 0;
+            }
+            return;
+        case MELEE_HIT_MISS:
+            {
+                damageInfo->HitInfo    |= HITINFO_MISS;
+                damageInfo->TargetState = VICTIMSTATE_INTACT;
+
+                damageInfo->procEx |= PROC_EX_MISS;
+                damageInfo->damage  = 0;
+                damageInfo->cleanDamage = 0;
+            }
+            break;
+        case MELEE_HIT_NORMAL:
+            damageInfo->TargetState = VICTIMSTATE_HIT;
+            damageInfo->procEx|=PROC_EX_NORMAL_HIT;
+            break;
+        case MELEE_HIT_CRIT:
+            {
+                damageInfo->HitInfo     |= HITINFO_CRITICALHIT;
+                damageInfo->TargetState  = VICTIMSTATE_HIT;
+
+                damageInfo->procEx      |= PROC_EX_CRITICAL_HIT;
+                // Crit bonus calc
+                damageInfo->damage += damageInfo->damage;
+                int32 mod = 0;
+                // Apply SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE or SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE
+                if (damageInfo->attackType == RANGED_ATTACK)
+                    mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_DAMAGE);
+                else
+                {
+                    mod += damageInfo->target->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_DAMAGE);
+                    mod += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_DAMAGE_BONUS_MELEE);
+                }
+
+                uint32 crTypeMask = damageInfo->target->GetCreatureTypeMask();
+
+                // Increase crit damage from SPELL_AURA_MOD_CRIT_PERCENT_VERSUS
+                mod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, crTypeMask);
+                if (mod != 0)
+                    damageInfo->damage = int32((damageInfo->damage) * float((100.0f + mod)/100.0f));
+            }
+            break;
+        case MELEE_HIT_PARRY:
+            damageInfo->TargetState  = VICTIMSTATE_PARRY;
+            damageInfo->procEx      |= PROC_EX_PARRY;
+            damageInfo->cleanDamage += damageInfo->damage;
+            damageInfo->damage = 0;
+            break;
+        case MELEE_HIT_DODGE:
+            damageInfo->TargetState  = VICTIMSTATE_DODGE;
+            damageInfo->procEx      |= PROC_EX_DODGE;
+            damageInfo->cleanDamage += damageInfo->damage;
+            damageInfo->damage = 0;
+            break;
+        case MELEE_HIT_BLOCK:
+            {
+                damageInfo->TargetState = VICTIMSTATE_HIT;
+                damageInfo->HitInfo    |= HITINFO_BLOCK;
+                damageInfo->procEx     |= PROC_EX_BLOCK;
+                damageInfo->blocked_amount = damageInfo->target->GetShieldBlockValue();
+                //double blocked amount if block is critical
+                if (damageInfo->target->isBlockCritical())
+                    damageInfo->blocked_amount+=damageInfo->blocked_amount;
+                if (damageInfo->blocked_amount >= damageInfo->damage)
+                {
+                    damageInfo->TargetState = VICTIMSTATE_BLOCKS;
+                    damageInfo->blocked_amount = damageInfo->damage;
+                    damageInfo->procEx |= PROC_EX_FULL_BLOCK;
+                }
+                else
+                    damageInfo->procEx  |= PROC_EX_NORMAL_HIT;
+                damageInfo->damage      -= damageInfo->blocked_amount;
+                damageInfo->cleanDamage += damageInfo->blocked_amount;
+            }
+            break;
+        case MELEE_HIT_GLANCING:
+            {
+                damageInfo->HitInfo     |= HITINFO_GLANCING;
+                damageInfo->TargetState  = VICTIMSTATE_HIT;
+                damageInfo->procEx      |= PROC_EX_NORMAL_HIT;
+                int32 leveldif = int32(pVictim->getLevel()) - int32(getLevel());
+                if (leveldif > 3)
+                    leveldif = 3;
+                float reducePercent = 1 - leveldif * 0.1f;
+                damageInfo->cleanDamage += damageInfo->damage-uint32(reducePercent * damageInfo->damage);
+                damageInfo->damage   = uint32(reducePercent * damageInfo->damage);
+            }
+            break;
+        case MELEE_HIT_CRUSHING:
+            {
+                damageInfo->HitInfo     |= HITINFO_CRUSHING;
+                damageInfo->TargetState  = VICTIMSTATE_HIT;
+                damageInfo->procEx      |= PROC_EX_NORMAL_HIT;
+                // 150% normal damage
+                damageInfo->damage += (damageInfo->damage / 2);
+            }
+        break;
+        default:
+            break;
+    }
+
+    int32 resilienceReduction = damageInfo->damage;
+    if (attackType != RANGED_ATTACK)
+        ApplyResilience(pVictim, NULL, &resilienceReduction, (damageInfo->hitOutCome == MELEE_HIT_CRIT), CR_CRIT_TAKEN_MELEE);
+    else
+        ApplyResilience(pVictim, NULL, &resilienceReduction, (damageInfo->hitOutCome == MELEE_HIT_CRIT), CR_CRIT_TAKEN_RANGED);
+    resilienceReduction = damageInfo->damage - resilienceReduction;
+    damageInfo->damage      -= resilienceReduction;
+    damageInfo->cleanDamage += resilienceReduction;
+
+    // Calculate absorb resist
+    if (int32(damageInfo->damage) > 0)
+    {
+        damageInfo->procVictim |= PROC_FLAG_TAKEN_DAMAGE;
+        // Calculate absorb & resists
+        CalcAbsorbResist(damageInfo->target, SpellSchoolMask(damageInfo->damageSchoolMask), DIRECT_DAMAGE, damageInfo->damage, &damageInfo->absorb, &damageInfo->resist);
+        damageInfo->damage -= damageInfo->absorb + damageInfo->resist;
+        if (damageInfo->absorb)
+        {
+            damageInfo->HitInfo |= HITINFO_ABSORB;
+            damageInfo->procEx  |= PROC_EX_ABSORB;
+        }
+        if (damageInfo->resist)
+            damageInfo->HitInfo |= HITINFO_RESIST;
+    }
+    else // Impossible get negative result but....
+        damageInfo->damage = 0;
+}
+
+void Unit::DealMeleeDamage(CalcDamageInfo *damageInfo, bool durabilityLoss)
+{
+    Unit *pVictim = damageInfo->target;
+
+    if (!pVictim->isAlive() || pVictim->hasUnitState(UNIT_STAT_UNATTACKABLE) || (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode()))
+        return;
+
+    //You don't lose health from damage taken from another player while in a sanctuary
+    //You still see it in the combat log though
+    if (pVictim != this && IsControlledByPlayer() && pVictim->IsControlledByPlayer())
+    {
+        const AreaTableEntry *area = GetAreaEntryByAreaID(pVictim->GetAreaId());
+        if (area && area->IsSanctuary())      // sanctuary
+            return;
+    }
+
+    // Hmmmm dont like this emotes client must by self do all animations
+    if (damageInfo->HitInfo&HITINFO_CRITICALHIT)
+        pVictim->HandleEmoteCommand(EMOTE_ONESHOT_WOUNDCRITICAL);
+    if (damageInfo->blocked_amount && damageInfo->TargetState != VICTIMSTATE_BLOCKS)
+        pVictim->HandleEmoteCommand(EMOTE_ONESHOT_PARRYSHIELD);
+
+    if (damageInfo->TargetState == VICTIMSTATE_PARRY)
+    {
+        // Get attack timers
+        float offtime  = float(pVictim->getAttackTimer(OFF_ATTACK));
+        float basetime = float(pVictim->getAttackTimer(BASE_ATTACK));
+        // Reduce attack time
+        if (pVictim->haveOffhandWeapon() && offtime < basetime)
+        {
+            float percent20 = pVictim->GetAttackTime(OFF_ATTACK) * 0.20f;
+            float percent60 = 3.0f * percent20;
+            if (offtime > percent20 && offtime <= percent60)
+                pVictim->setAttackTimer(OFF_ATTACK, uint32(percent20));
+            else if (offtime > percent60)
+            {
+                offtime -= 2.0f * percent20;
+                pVictim->setAttackTimer(OFF_ATTACK, uint32(offtime));
+            }
+        }
+        else
+        {
+            float percent20 = pVictim->GetAttackTime(BASE_ATTACK) * 0.20f;
+            float percent60 = 3.0f * percent20;
+            if (basetime > percent20 && basetime <= percent60)
+                pVictim->setAttackTimer(BASE_ATTACK, uint32(percent20));
+            else if (basetime > percent60)
+            {
+                basetime -= 2.0f * percent20;
+                pVictim->setAttackTimer(BASE_ATTACK, uint32(basetime));
+            }
+        }
+    }
+
+    // Call default DealDamage
+    CleanDamage cleanDamage(damageInfo->cleanDamage,damageInfo->absorb,damageInfo->attackType,damageInfo->hitOutCome);
+    DealDamage(pVictim, damageInfo->damage, &cleanDamage, DIRECT_DAMAGE, SpellSchoolMask(damageInfo->damageSchoolMask), NULL, durabilityLoss);
+
+    // If this is a creature and it attacks from behind it has a probability to daze it's victim
+    if ((damageInfo->hitOutCome == MELEE_HIT_CRIT || damageInfo->hitOutCome == MELEE_HIT_CRUSHING || damageInfo->hitOutCome == MELEE_HIT_NORMAL || damageInfo->hitOutCome == MELEE_HIT_GLANCING) &&
+        GetTypeId() != TYPEID_PLAYER && !this->ToCreature()->IsControlledByPlayer() && !pVictim->HasInArc(M_PI, this)
+        && (pVictim->GetTypeId() == TYPEID_PLAYER || !pVictim->ToCreature()->isWorldBoss()))
+    {
+        // -probability is between 0% and 40%
+        // 20% base chance
+        float Probability = 20.0f;
+
+        //there is a newbie protection, at level 10 just 7% base chance; assuming linear function
+        if (pVictim->getLevel() < 30)
+            Probability = 0.65f * pVictim->getLevel() + 0.5f;
+
+        uint32 VictimDefense=pVictim->GetDefenseSkillValue();
+        uint32 AttackerMeleeSkill=GetUnitMeleeSkill();
+
+        Probability *= AttackerMeleeSkill/(float)VictimDefense;
+
+        if (Probability > 40.0f)
+            Probability = 40.0f;
+
+        if (roll_chance_f(Probability))
+            CastSpell(pVictim, 1604, true);
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->CastItemCombatSpell(pVictim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+
+    // Do effect if any damage done to target
+    if (damageInfo->damage)
+    {
+        AuraEffectList const& vDamageShields = pVictim->GetAuraEffectsByType(SPELL_AURA_DAMAGE_SHIELD);
+        for (AuraEffectList::const_iterator dmgShieldItr = vDamageShields.begin(); dmgShieldItr != vDamageShields.end(); ++dmgShieldItr)
+        {
+            SpellEntry const *i_spellProto = (*dmgShieldItr)->GetSpellProto();
+            // Damage shield can be resisted...
+            if (SpellMissInfo missInfo = pVictim->SpellHitResult(this, i_spellProto ,false))
+            {
+                pVictim->SendSpellMiss(this, i_spellProto->Id, missInfo);
+                continue;
+            }
+
+            // ...or immuned
+            if (IsImmunedToDamage(i_spellProto))
+            {
+                pVictim->SendSpellDamageImmune(this, i_spellProto->Id);
+                continue;
+            }
+
+            uint32 damage = (*dmgShieldItr)->GetAmount();
+
+            // No Unit::CalcAbsorbResist here - opcode doesn't send that data - this damage is probably not affected by that
+            pVictim->DealDamageMods(this,damage,NULL);
+
+            // TODO: Move this to a packet handler
+            WorldPacket data(SMSG_SPELLDAMAGESHIELD,(8+8+4+4+4+4));
+            data << uint64(pVictim->GetGUID());
+            data << uint64(GetGUID());
+            data << uint32(i_spellProto->Id);
+            data << uint32(damage);                  // Damage
+            int32 overkill = int32(damage) - int32(GetHealth());
+            data << uint32(overkill > 0 ? overkill : 0); // Overkill
+            data << uint32(i_spellProto->SchoolMask);
+            pVictim->SendMessageToSet(&data, true);
+
+            pVictim->DealDamage(this, damage, 0, SPELL_DIRECT_DAMAGE, GetSpellSchoolMask(i_spellProto), i_spellProto, true);
+        }
+    }
+}
+
+void Unit::HandleEmoteCommand(uint32 anim_id)
+{
+    WorldPacket data(SMSG_EMOTE, 4 + 8);
+    data << uint32(anim_id);
+    data << uint64(GetGUID());
+    SendMessageToSet(&data, true);
+}
+
+bool Unit::IsDamageReducedByArmor(SpellSchoolMask schoolMask, SpellEntry const *spellInfo, uint8 effIndex)
+{
+    // only physical spells damage gets reduced by armor
+    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
+        return false;
+    if (spellInfo)
+    {
+        // there are spells with no specific attribute but they have "ignores armor" in tooltip
+        if (sSpellMgr.GetSpellCustomAttr(spellInfo->Id) & SPELL_ATTR_CU_IGNORE_ARMOR)
+            return false;
+
+        // bleeding effects are not reduced by armor
+        if (effIndex != MAX_SPELL_EFFECTS && spellInfo->EffectApplyAuraName[effIndex] == SPELL_AURA_PERIODIC_DAMAGE)
+            if (GetSpellMechanicMask(spellInfo, effIndex) & (1<<MECHANIC_BLEED))
+                return false;
+    }
+    return true;
+}
+
+uint32 Unit::CalcArmorReducedDamage(Unit* pVictim, const uint32 damage, SpellEntry const *spellInfo, WeaponAttackType /*attackType*/)
+{
+    uint32 newdamage = 0;
+    float armor = float(pVictim->GetArmor());
+
+    // Ignore enemy armor by SPELL_AURA_MOD_TARGET_RESISTANCE aura
+    armor += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_NORMAL);
+
+    if (spellInfo)
+        if (Player *modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_IGNORE_ARMOR, armor);
+
+    AuraEffectList const& ResIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);
+    for (AuraEffectList::const_iterator j = ResIgnoreAurasAb.begin(); j != ResIgnoreAurasAb.end(); ++j)
+    {
+        if ((*j)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL
+            && (*j)->IsAffectedOnSpell(spellInfo))
+            armor = floor(float(armor) * (float(100 - (*j)->GetAmount()) / 100.0f));
+    }
+
+    AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
+    for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)
+    {
+        if ((*j)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
+            armor = floor(float(armor) * (float(100 - (*j)->GetAmount()) / 100.0f));
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        AuraEffectList const& ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_ARMOR_PENETRATION_PCT);
+        for (AuraEffectList::const_iterator itr = ResIgnoreAuras.begin(); itr != ResIgnoreAuras.end(); ++itr)
+        {
+            // item neutral spell
+            if ((*itr)->GetSpellProto()->EquippedItemClass == -1)
+            {
+                armor = floor(float(armor) * (float(100 - (*itr)->GetAmount()) / 100.0f));
+                continue;
+            }
+
+            // item dependent spell - check curent weapons
+            for (int i = 0; i < MAX_ATTACK; ++i)
+            {
+                Item *weapon = ToPlayer()->GetWeaponForAttack(WeaponAttackType(i), true);
+
+                if (weapon && weapon->IsFitToSpellRequirements((*itr)->GetSpellProto()))
+                {
+                    armor = floor(float(armor) * (float(100 - (*itr)->GetAmount()) / 100.0f));
+                    break;
+                }
+            }
+        }
+    }
+
+    // Apply Player CR_ARMOR_PENETRATION rating
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        float maxArmorPen=0;
+        if (getLevel() < 60)
+            maxArmorPen = float(400 + 85 * pVictim->getLevel());
+        else
+            maxArmorPen = 400 + 85 * pVictim->getLevel() + 4.5f * 85 * (pVictim->getLevel() - 59);
+        // Cap armor penetration to this number
+        maxArmorPen = std::min(((armor+maxArmorPen) / 3),armor);
+        // Figure out how much armor do we ignore
+        float armorPen = maxArmorPen * this->ToPlayer()->GetRatingBonusValue(CR_ARMOR_PENETRATION) / 100.0f;
+        // Got the value, apply it
+        armor -= armorPen;
+    }
+
+    if (armor < 0.0f)
+        armor = 0.0f;
+
+    float levelModifier = getLevel();
+    if (levelModifier > 59)
+        levelModifier = levelModifier + (4.5f * (levelModifier-59));
+
+    float tmpvalue = 0.1f * armor / (8.5f * levelModifier + 40);
+    tmpvalue = tmpvalue/(1.0f + tmpvalue);
+
+    if (tmpvalue < 0.0f)
+        tmpvalue = 0.0f;
+    if (tmpvalue > 0.75f)
+        tmpvalue = 0.75f;
+
+    newdamage = uint32(damage - (damage * tmpvalue));
+
+    return (newdamage > 1) ? newdamage : 1;
+}
+
+void Unit::CalcAbsorbResist(Unit *pVictim, SpellSchoolMask schoolMask, DamageEffectType damagetype, const uint32 damage, uint32 *absorb, uint32 *resist, SpellEntry const *spellInfo)
+{
+    if (!pVictim || !pVictim->isAlive() || !damage)
+        return;
+
+    // Magic damage, check for resists
+    if ((schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
+    {
+        float baseVictimResistance = (float) pVictim->GetResistance(GetFirstSchoolInMask(schoolMask));
+        float ignoredResistance = (float) GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask);
+        float victimResistance = baseVictimResistance + ignoredResistance;
+
+        uint32 BOSS_LEVEL = 83;
+        float BOSS_RESISTANCE_CONSTANT = 510.0;
+        uint32 level = getLevel();
+        float resistanceConstant = 0.0f;
+
+        if (level == BOSS_LEVEL)
+            resistanceConstant = BOSS_RESISTANCE_CONSTANT;
+        else
+            resistanceConstant = level * 5.0f;
+
+        float averageResist = victimResistance / (victimResistance + resistanceConstant);
+        float discreteResistProbability[11];
+        for (int i = 0; i < 11; i++)
+        {
+            discreteResistProbability[i] = 0.5f - 2.5f * fabs(0.1f * i - averageResist);
+            if (discreteResistProbability[i] < 0.0f)
+                discreteResistProbability[i] = 0.0f;
+        }
+
+        if (averageResist <= 0.1f)
+        {
+            discreteResistProbability[0] = 1.0f - 7.5f * averageResist;
+            discreteResistProbability[1] = 5.0f * averageResist;
+            discreteResistProbability[2] = 2.5f * averageResist;
+        }
+
+        float r = (float)rand_norm();
+        int i = 0;
+        float probabilitySum = discreteResistProbability[0];
+
+        while (r >= probabilitySum && i < 10)
+        {
+            i++;
+            probabilitySum += discreteResistProbability[i];
+        }
+
+        uint32 damageResisted = damage * i / 10;
+
+        *resist += damageResisted;
+
+        AuraEffectList const &ResIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);
+        for (AuraEffectList::const_iterator j = ResIgnoreAurasAb.begin(); j != ResIgnoreAurasAb.end(); ++j)
+        {
+            if ((*j)->GetMiscValue() & schoolMask
+                && (*j)->IsAffectedOnSpell(spellInfo))
+                *resist= int32(float(*resist) * (float(100-(*j)->GetAmount())/100.0f));
+        }
+
+        AuraEffectList const &ResIgnoreAuras = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
+        for (AuraEffectList::const_iterator j = ResIgnoreAuras.begin(); j != ResIgnoreAuras.end(); ++j)
+        {
+            if ((*j)->GetMiscValue() & schoolMask)
+                *resist= int32(float(*resist) * (float(100-(*j)->GetAmount())/100.0f));
+        }
+    }
+    else
+        *resist = 0;
+
+    int32 RemainingDamage = damage - *resist;
+    int32 TotalAbsorb = RemainingDamage;
+    // Get unit state (need for some absorb check)
+    uint32 unitflag = pVictim->GetUInt32Value(UNIT_FIELD_FLAGS);
+    // Death Prevention Aura
+    SpellEntry const* preventDeathSpell = NULL;
+    int32 preventDeathAmount = 0;
+    // Need remove expired auras after
+    bool existExpired = false;
+    TriggeredSpellInfoVct triggeredSpells;
+
+    // Incanter's Absorption, for converting to spell power
+    int32 incanterAbsorption = 0;
+
+    // absorb without mana cost
+    AuraEffectList const& vSchoolAbsorb = pVictim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_ABSORB);
+    for (AuraEffectList::const_iterator i = vSchoolAbsorb.begin(); i != vSchoolAbsorb.end() && RemainingDamage > 0; ++i)
+    {
+        if (!((*i)->GetMiscValue() & schoolMask))
+            continue;
+
+        SpellEntry const* spellProto = (*i)->GetSpellProto();
+
+        // Max Amount can be absorbed by this aura
+        int32  currentAbsorb = (*i)->GetAmount();
+
+        // Found empty aura (impossible but..)
+        if (currentAbsorb <= 0)
+        {
+            existExpired = true;
+            continue;
+        }
+        // Handle custom absorb auras
+        // TODO: try find better way
+        switch (spellProto->SpellFamilyName)
+        {
+            case SPELLFAMILY_GENERIC:
+            {
+                // Astral Shift
+                if (spellProto->SpellIconID == 3066)
+                {
+                    //reduces all damage taken while stun, fear or silence
+                    if (unitflag & (UNIT_FLAG_STUNNED|UNIT_FLAG_FLEEING|UNIT_FLAG_SILENCED))
+                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
+                    continue;
+                }
+                // Nerves of Steel
+                if (spellProto->SpellIconID == 2115)
+                {
+                    // while affected by Stun and Fear
+                    if (unitflag&(UNIT_FLAG_STUNNED|UNIT_FLAG_FLEEING))
+                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
+                    continue;
+                }
+                // Spell Deflection
+                if (spellProto->SpellIconID == 3006)
+                {
+                    // You have a chance equal to your Parry chance
+                    if (damagetype == DIRECT_DAMAGE &&                   // Only for direct damage
+                        roll_chance_f(pVictim->GetUnitParryChance()))    // Roll chance
+                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
+                    continue;
+                }
+                // Reflective Shield (Lady Malande boss)
+                if (spellProto->Id == 41475)
+                {
+                    triggeredSpells.push_back(TriggeredSpellInfo(33619, pVictim, this,
+                        std::min(RemainingDamage, currentAbsorb) / 2, *i));
+                    break;
+                }
+                if (spellProto->Id == 39228 || // Argussian Compass
+                    spellProto->Id == 60218)   // Essence of Gossamer
+                {
+                    // Max absorb stored in 1 dummy effect
+                    int32 maxAbsorb = SpellMgr::CalculateSpellEffectAmount(spellProto, 1);
+                    if (maxAbsorb < currentAbsorb)
+                        currentAbsorb = maxAbsorb;
+                    break;
+                }
+                break;
+            }
+            case SPELLFAMILY_DRUID:
+            {
+                // Primal Tenacity
+                if (spellProto->SpellIconID == 2253)
+                {
+                    //reduces all damage taken while Stunned
+                    if (pVictim->m_form == FORM_CAT && (unitflag & UNIT_FLAG_STUNNED))
+                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
+                    continue;
+                }
+                // Savage Defense
+                if (spellProto->SpellIconID == 146)
+                {
+                    if (RemainingDamage < currentAbsorb)
+                        currentAbsorb = RemainingDamage;
+
+                    (*i)->SetAmount(0);     // guarantee removal
+                    existExpired = true;    // maybe hacky but not crashy
+
+                    RemainingDamage -= currentAbsorb;
+                    continue;
+                }
+                // Moonkin Form passive
+                if (spellProto->Id == 69366)
+                {
+                    //reduces all damage taken while Stunned
+                    if (unitflag & UNIT_FLAG_STUNNED)
+                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
+                    continue;
+                }
+                break;
+            }
+            case SPELLFAMILY_ROGUE:
+            {
+                // Cheat Death (make less prio with Guardian Spirit case)
+                if (spellProto->SpellIconID == 2109)
+                {
+                    if (!preventDeathSpell &&
+                        pVictim->GetTypeId() == TYPEID_PLAYER &&        // Only players
+                        !pVictim->ToPlayer()->HasSpellCooldown(31231) && // Only if no cooldown
+                        roll_chance_i((*i)->GetAmount()))               // Only if roll
+                    {
+                        preventDeathSpell = (*i)->GetSpellProto();
+                    }
+                    continue;
+                }
+                break;
+            }
+            case SPELLFAMILY_PRIEST:
+            {
+                // Guardian Spirit
+                if (spellProto->SpellIconID == 2873)
+                {
+                    preventDeathSpell = (*i)->GetSpellProto();
+                    preventDeathAmount = (*i)->GetAmount();
+                    continue;
+                }
+
+                // Power Word: Shield
+                if (spellProto->SpellFamilyFlags.IsEqual(0x1, 0, 0x400))
+                {
+                    if (pVictim == this)
+                        break;
+                    Unit* caster = (*i)->GetCaster();
+                    if (!caster)
+                        break;
+                    // Reflective Shield
+                    if (AuraEffect const * aurEff = caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST, 566, 0))
+                    {
+                        switch(aurEff->GetMiscValue())
+                        {
+                            case 5065:                          // Rank 1
+                            case 5064:                          // Rank 2
+                                triggeredSpells.push_back(TriggeredSpellInfo(33619, pVictim, this,
+                                    std::min(RemainingDamage, currentAbsorb) * aurEff->GetAmount() / 100, *i));
+                                break;
+                            default:
+                                sLog.outError("Unit::CalcAbsorbResist: unknown Reflective Shield spell %d", aurEff->GetId());
+                                break;
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_PALADIN:
+            {
+                // Ardent Defender
+                if (spellProto->SpellIconID == 2135 && pVictim->GetTypeId() == TYPEID_PLAYER)
+                {
+                    int32 remainingHealth = pVictim->GetHealth() - RemainingDamage;
+                    uint32 allowedHealth = pVictim->CountPctFromMaxHealth(35);
+                    // If damage kills us
+                    if (remainingHealth <= 0 && !pVictim->ToPlayer()->HasSpellCooldown(66235))
+                    {
+                        // Cast healing spell, completely avoid damage
+                        RemainingDamage = 0;
+
+                        uint32 defenseSkillValue = pVictim->GetDefenseSkillValue();
+                        // Max heal when defense skill denies critical hits from raid bosses
+                        // Formula: max defense at level + 140 (raiting from gear)
+                        uint32 reqDefForMaxHeal  = pVictim->getLevel() * 5 + 140;
+                        float pctFromDefense = (defenseSkillValue >= reqDefForMaxHeal)
+                            ? 1.0f
+                            : float(defenseSkillValue) / float(reqDefForMaxHeal);
+
+                        int32 healAmount = int32(pVictim->CountPctFromMaxHealth(uint32((*i)->GetAmount() * pctFromDefense)));
+                        pVictim->CastCustomSpell(pVictim, 66235, &healAmount, NULL, NULL, true);
+                        pVictim->ToPlayer()->AddSpellCooldown(66235,0,time(NULL) + 120);
+                    }
+                    else if (remainingHealth < int32(allowedHealth))
+                    {
+                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                        uint32 damageToReduce = (pVictim->GetHealth() < allowedHealth)
+                            ? RemainingDamage
+                            : allowedHealth - remainingHealth;
+                        RemainingDamage -= damageToReduce * currentAbsorb / 100;
+                    }
+                    continue;
+
+                }
+                break;
+            }
+            case SPELLFAMILY_SHAMAN:
+            {
+                // Astral Shift
+                if (spellProto->SpellIconID == 3066)
+                {
+                    //reduces all damage taken while stun, fear or silence
+                    if (unitflag & (UNIT_FLAG_STUNNED|UNIT_FLAG_FLEEING|UNIT_FLAG_SILENCED))
+                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
+                    continue;
+                }
+                break;
+            }
+            case SPELLFAMILY_DEATHKNIGHT:
+            {
+                switch (spellProto->Id)
+                {
+                    case 51271: // Unbreakable Armor
+                        if (Unit *caster = (*i)->GetCaster())
+                        {
+                            uint32 absorbed = uint32(currentAbsorb * caster->GetArmor() * 0.01f);
+
+                            // Glyph of Unbreakable Armor
+                            if (AuraEffect *aurEff = caster->GetAuraEffect(58635, 0))
+                                absorbed += uint32(absorbed * aurEff->GetAmount() / 100);
+
+                            RemainingDamage -= absorbed;
+                        }
+                        continue;
+                    case 52284: // Will of the Necropolis
+                    case 52285:
+                    case 52286:
+                    {
+                        int32 remainingHp = (int32)pVictim->GetHealth() - RemainingDamage;
+
+                        // min pct of hp is stored in effect 0 of talent spell
+                        uint32 rank = sSpellMgr.GetSpellRank(spellProto->Id);
+                        SpellEntry const * talentProto = sSpellStore.LookupEntry(sSpellMgr.GetSpellWithRank(49189, rank));
+
+                        int32 minHp = int32(pVictim->CountPctFromMaxHealth(SpellMgr::CalculateSpellEffectAmount(talentProto, 0, (*i)->GetCaster())));
+                        // Damage that would take you below [effect0] health or taken while you are at [effect0]
+                        if (remainingHp < minHp)
+                        {
+                            uint32 absorbed = uint32(currentAbsorb * RemainingDamage * 0.01f);
+                            RemainingDamage -= absorbed;
+                        }
+                        continue;
+                    }
+                    case 48707: // Anti-Magic Shell (on self)
+                    {
+                        // damage absorbed by Anti-Magic Shell energizes the DK with additional runic power.
+                        // This, if I'm not mistaken, shows that we get back ~2% of the absorbed damage as runic power.
+                        int32 absorbed = RemainingDamage * currentAbsorb / 100;
+                        RemainingDamage -= absorbed;
+                        triggeredSpells.push_back(TriggeredSpellInfo(49088, pVictim, pVictim, absorbed * 2 / 10, *i));
+                        continue;
+                    }
+                    case 50462: // Anti-Magic Shell (on single party/raid member)
+                        RemainingDamage -= RemainingDamage * currentAbsorb / 100;
+                        continue;
+                    case 50461: // Anti-Magic Zone
+                        if (Unit *caster = (*i)->GetCaster())
+                        {
+                            int32 absorbed = RemainingDamage * currentAbsorb / 100;
+                            int32 canabsorb = caster->GetHealth();
+                            if (canabsorb < absorbed)
+                                absorbed = canabsorb;
+
+                            RemainingDamage -= absorbed;
+                        }
+                        continue;
+                    default:
+                        break;
+                }
+                break;
+            }
+            default:
+                break;
+        }
+
+        // currentAbsorb - damage can be absorbed by shield
+        // If need absorb less damage
+        if (RemainingDamage < currentAbsorb)
+            currentAbsorb = RemainingDamage;
+
+        RemainingDamage -= currentAbsorb;
+
+        // Fire Ward or Frost Ward or Ice Barrier (or Mana Shield)
+        // for Incanter's Absorption converting to spell power
+        if (spellProto->SpellFamilyName == SPELLFAMILY_MAGE && spellProto->SpellFamilyFlags[2] & 0x000008)
+            incanterAbsorption += currentAbsorb;
+
+        // Reduce shield amount
+        (*i)->SetAmount((*i)->GetAmount() -currentAbsorb);
+        // Need remove it later
+        if ((*i)->GetAmount() <= 0)
+            existExpired = true;
+    }
+
+    for (TriggeredSpellInfoVct::const_iterator itr = triggeredSpells.begin(); itr != triggeredSpells.end(); ++itr)
+    {
+        if (itr->spell)
+            itr->source->CastCustomSpell(itr->spell, SPELLVALUE_BASE_POINT0, itr->amount, itr->target, true, NULL, itr->auraEff);
+        else if (itr->amount > 0)
+        {
+            uint32 damage = uint32(itr->amount);
+            itr->source->DealDamageMods(itr->target, damage, NULL);
+            itr->source->DealDamage(itr->target, damage, NULL, damagetype, schoolMask, 0, false);
+        }
+    }
+
+    // Remove all expired absorb auras
+    if (existExpired)
+    {
+        for (AuraEffectList::const_iterator i = vSchoolAbsorb.begin(); i != vSchoolAbsorb.end();)
+        {
+            AuraEffect * auraEff =(*i);
+            ++i;
+            if (auraEff->GetAmount() <= 0)
+            {
+                uint32 removedAuras = pVictim->m_removedAurasCount;
+                auraEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+                if (removedAuras+1<pVictim->m_removedAurasCount)
+                    i=vSchoolAbsorb.begin();
+            }
+        }
+    }
+
+    // absorb by mana cost
+    AuraEffectList const& vManaShield = pVictim->GetAuraEffectsByType(SPELL_AURA_MANA_SHIELD);
+    for (AuraEffectList::const_iterator i = vManaShield.begin(), next; i != vManaShield.end() && RemainingDamage > 0; i = next)
+    {
+        next = i; ++next;
+
+        // check damage school mask
+        if (((*i)->GetMiscValue() & schoolMask) == 0)
+            continue;
+
+        int32 currentAbsorb;
+        if (RemainingDamage >= (*i)->GetAmount())
+            currentAbsorb = (*i)->GetAmount();
+        else
+            currentAbsorb = RemainingDamage;
+
+        if (float manaMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier((*i)->GetSpellProto(), (*i)->GetEffIndex(), (*i)->GetCaster()))
+        {
+            int32 maxAbsorb = int32(pVictim->GetPower(POWER_MANA) / manaMultiplier);
+            if (currentAbsorb > maxAbsorb)
+                currentAbsorb = maxAbsorb;
+
+            int32 manaReduction = int32(currentAbsorb * manaMultiplier);
+            pVictim->ApplyPowerMod(POWER_MANA, manaReduction, false);
+        }
+
+        // Mana Shield (or Fire Ward or Frost Ward or Ice Barrier)
+        // for Incanter's Absorption converting to spell power
+        if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_MAGE && (*i)->GetSpellProto()->SpellFamilyFlags[2] & 0x000008)
+            incanterAbsorption += currentAbsorb;
+
+        (*i)->SetAmount((*i)->GetAmount()-currentAbsorb);
+        if ((*i)->GetAmount() <= 0)
+        {
+            (*i)->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+            next = vManaShield.begin();
+        }
+
+        RemainingDamage -= currentAbsorb;
+    }
+
+    // only split damage if not damaging yourself
+    if (pVictim != this)
+    {
+        AuraEffectList const& vSplitDamageFlat = pVictim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_FLAT);
+        for (AuraEffectList::const_iterator i = vSplitDamageFlat.begin(), next; i != vSplitDamageFlat.end() && RemainingDamage >= 0; i = next)
+        {
+            next = i; ++next;
+
+            // check damage school mask
+            if (((*i)->GetMiscValue() & schoolMask) == 0)
+                continue;
+
+            // Damage can be splitted only if aura has an alive caster
+            Unit *caster = (*i)->GetCaster();
+            if (!caster || caster == pVictim || !caster->IsInWorld() || !caster->isAlive())
+                continue;
+
+            int32 currentAbsorb;
+            if (RemainingDamage >= (*i)->GetAmount())
+                currentAbsorb = (*i)->GetAmount();
+            else
+                currentAbsorb = RemainingDamage;
+
+            RemainingDamage -= currentAbsorb;
+
+            uint32 splitted = currentAbsorb;
+            uint32 splitted_absorb = 0;
+            DealDamageMods(caster,splitted,&splitted_absorb);
+
+            SendSpellNonMeleeDamageLog(caster, (*i)->GetSpellProto()->Id, splitted, schoolMask, splitted_absorb, 0, false, 0, false);
+
+            CleanDamage cleanDamage = CleanDamage(splitted, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
+            DealDamage(caster, splitted, &cleanDamage, DIRECT_DAMAGE, schoolMask, (*i)->GetSpellProto(), false);
+        }
+
+        AuraEffectList const& vSplitDamagePct = pVictim->GetAuraEffectsByType(SPELL_AURA_SPLIT_DAMAGE_PCT);
+        for (AuraEffectList::const_iterator i = vSplitDamagePct.begin(), next; i != vSplitDamagePct.end() && RemainingDamage >= 0; i = next)
+        {
+            next = i;
+            ++next;
+
+            // check damage school mask
+            if (((*i)->GetMiscValue() & schoolMask) == 0)
+                continue;
+
+            // Damage can be splitted only if aura has an alive caster
+            Unit *caster = (*i)->GetCaster();
+            if (!caster || caster == pVictim || !caster->IsInWorld() || !caster->isAlive())
+                continue;
+
+            uint32 splitted = uint32(RemainingDamage * (*i)->GetAmount() / 100.0f);
+
+            RemainingDamage -=  int32(splitted);
+
+            uint32 split_absorb = 0;
+            DealDamageMods(caster,splitted,&split_absorb);
+
+            SendSpellNonMeleeDamageLog(caster, (*i)->GetSpellProto()->Id, splitted, schoolMask, split_absorb, 0, false, 0, false);
+
+            CleanDamage cleanDamage = CleanDamage(splitted, 0, BASE_ATTACK, MELEE_HIT_NORMAL);
+            DealDamage(caster, splitted, &cleanDamage, DIRECT_DAMAGE, schoolMask, (*i)->GetSpellProto(), false);
+        }
+    }
+
+    TotalAbsorb = (TotalAbsorb - RemainingDamage > 0) ? TotalAbsorb - RemainingDamage : 0;
+    // TODO: School should be checked for absorbing auras or for attacks?
+    int32 auraAbsorbMod = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_TARGET_ABSORB_SCHOOL);
+    AuraEffectList const& AbsIgnoreAurasAb = GetAuraEffectsByType(SPELL_AURA_MOD_TARGET_ABILITY_ABSORB_SCHOOL);
+    for (AuraEffectList::const_iterator i = AbsIgnoreAurasAb.begin(); i != AbsIgnoreAurasAb.end(); ++i)
+    {
+        if ((*i)->GetAmount() > auraAbsorbMod
+            && (*i)->IsAffectedOnSpell(spellInfo))
+            auraAbsorbMod = (*i)->GetAmount();
+    }
+
+    // Ignore absorb - add reduced amount again to damage
+    RemainingDamage += auraAbsorbMod * TotalAbsorb / 100;
+
+    // Apply death prevention spells effects
+    if (preventDeathSpell && RemainingDamage >= int32(pVictim->GetHealth()))
+    {
+        switch(preventDeathSpell->SpellFamilyName)
+        {
+            case SPELLFAMILY_ROGUE:
+            {
+                // Cheat Death
+                if (preventDeathSpell->SpellIconID == 2109)
+                {
+                    pVictim->CastSpell(pVictim, 31231, true);
+                    pVictim->ToPlayer()->AddSpellCooldown(31231, 0, time(NULL) + 60);
+
+                    // with health > 10% lost health until health == 10%, in other case no losses
+                    uint32 health10 = pVictim->CountPctFromMaxHealth(10);
+                    RemainingDamage = pVictim->GetHealth() > health10 ? pVictim->GetHealth() - health10 : 0;
+                }
+                break;
+            }
+            case SPELLFAMILY_PRIEST:
+            {
+                // Guardian Spirit
+                if (preventDeathSpell->SpellIconID == 2873)
+                {
+                    int32 healAmount = int32(pVictim->CountPctFromMaxHealth(preventDeathAmount));
+                    pVictim->RemoveAurasDueToSpell(preventDeathSpell->Id);
+                    pVictim->CastCustomSpell(pVictim, 48153, &healAmount, NULL, NULL, true);
+                    RemainingDamage = 0;
+                }
+                break;
+            }
+        }
+    }
+
+    *absorb = RemainingDamage > 0 ? (damage - RemainingDamage - *resist) : (damage - *resist);
+
+    // Incanter's Absorption, if have affective absorbing
+    if (incanterAbsorption)
+    {
+        // Incanter's Absorption
+        // TODO: move this code to procflag
+        if (AuraEffect const * aurEff = pVictim->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 2941, 0))
+        {
+            // Get total damage bonus from auras
+            int32 current_dmg = 0;
+            std::pair<AuraApplicationMap::const_iterator, AuraApplicationMap::const_iterator> range = pVictim->GetAppliedAuras().equal_range(44413);
+            for (AuraApplicationMap::const_iterator iter = range.first; iter != range.second; ++iter)
+                if (AuraEffect const * bonusEff = iter->second->GetBase()->GetEffect(0))
+                    current_dmg += bonusEff->GetAmount();
+
+            int32 new_dmg = (int32)*absorb * aurEff->GetAmount() / 100;
+            if (new_dmg > 0)
+                pVictim->CastCustomSpell(pVictim, 44413, &new_dmg, NULL, NULL, true);
+        }
+    }
+}
+
+void Unit::CalcHealAbsorb(Unit *pVictim, const SpellEntry *healSpell, uint32 &healAmount, uint32 &absorb)
+{
+    if (!healAmount)
+        return;
+
+    int32 RemainingHeal = healAmount;
+
+    // Need remove expired auras after
+    bool existExpired = false;
+
+    // absorb without mana cost
+    AuraEffectList const& vHealAbsorb = pVictim->GetAuraEffectsByType(SPELL_AURA_SCHOOL_HEAL_ABSORB);
+    for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end() && RemainingHeal > 0; ++i)
+    {
+        if (!((*i)->GetMiscValue() & healSpell->SchoolMask))
+            continue;
+
+        // Max Amount can be absorbed by this aura
+        int32 currentAbsorb = (*i)->GetAmount();
+
+        // Found empty aura (impossible but..)
+        if (currentAbsorb <= 0)
+        {
+            existExpired = true;
+            continue;
+        }
+
+        // currentAbsorb - damage can be absorbed by shield
+        // If need absorb less damage
+        if (RemainingHeal < currentAbsorb)
+            currentAbsorb = RemainingHeal;
+
+        RemainingHeal -= currentAbsorb;
+
+        // Reduce shield amount
+        (*i)->SetAmount((*i)->GetAmount() - currentAbsorb);
+        // Need remove it later
+        if ((*i)->GetAmount() <= 0)
+            existExpired = true;
+    }
+
+    // Remove all expired absorb auras
+    if (existExpired)
+    {
+        for (AuraEffectList::const_iterator i = vHealAbsorb.begin(); i != vHealAbsorb.end();)
+        {
+            AuraEffect *auraEff = *i;
+            ++i;
+            if (auraEff->GetAmount() <= 0)
+            {
+                uint32 removedAuras = pVictim->m_removedAurasCount;
+                auraEff->GetBase()->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+                if (removedAuras+1 < pVictim->m_removedAurasCount)
+                    i = vHealAbsorb.begin();
+            }
+        }
+    }
+
+    absorb = RemainingHeal > 0 ? (healAmount - RemainingHeal) : healAmount;
+    healAmount = RemainingHeal;
+}
+
+void Unit::AttackerStateUpdate (Unit *pVictim, WeaponAttackType attType, bool extra)
+{
+    if (hasUnitState(UNIT_STAT_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+        return;
+
+    if (!pVictim->isAlive())
+        return;
+
+    if ((attType == BASE_ATTACK || attType == OFF_ATTACK) && !this->IsWithinLOSInMap(pVictim))
+        return;
+
+    CombatStart(pVictim);
+    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
+
+    uint32 hitInfo;
+    if (attType == BASE_ATTACK)
+        hitInfo = HITINFO_NORMALSWING2;
+    else if (attType == OFF_ATTACK)
+        hitInfo = HITINFO_LEFTSWING;
+    else
+        return;                                             // ignore ranged case
+
+    // melee attack spell casted at main hand attack only - no normal melee dmg dealt
+    if (attType == BASE_ATTACK && m_currentSpells[CURRENT_MELEE_SPELL])
+        m_currentSpells[CURRENT_MELEE_SPELL]->cast();
+    else
+    {
+        // attack can be redirected to another target
+        pVictim = SelectMagnetTarget(pVictim);
+
+        CalcDamageInfo damageInfo;
+        CalculateMeleeDamage(pVictim, 0, &damageInfo, attType);
+        // Send log damage message to client
+        DealDamageMods(pVictim, damageInfo.damage, &damageInfo.absorb);
+        SendAttackStateUpdate(&damageInfo);
+
+        ProcDamageAndSpell(damageInfo.target, damageInfo.procAttacker, damageInfo.procVictim, damageInfo.procEx, damageInfo.damage, damageInfo.attackType);
+        DealMeleeDamage(&damageInfo,true);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+            sLog.outStaticDebug("AttackerStateUpdate: (Player) %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
+                GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
+        else
+            sLog.outStaticDebug("AttackerStateUpdate: (NPC)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
+                GetGUIDLow(), pVictim->GetGUIDLow(), pVictim->GetTypeId(), damageInfo.damage, damageInfo.absorb, damageInfo.blocked_amount, damageInfo.resist);
+    }
+
+    if(!extra && m_extraAttacks)
+    {
+        while(m_extraAttacks)
+        {
+            AttackerStateUpdate(pVictim, BASE_ATTACK, true);
+            if(m_extraAttacks > 0)
+                --m_extraAttacks;
+        }
+    }
+}
+
+MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(const Unit *pVictim, WeaponAttackType attType) const
+{
+    // This is only wrapper
+
+    // Miss chance based on melee
+    //float miss_chance = MeleeMissChanceCalc(pVictim, attType);
+    float miss_chance = MeleeSpellMissChance(pVictim, attType, int32(GetWeaponSkillValue(attType,pVictim)) - int32(pVictim->GetDefenseSkillValue(this)), 0);
+
+    // Critical hit chance
+    float crit_chance = GetUnitCriticalChance(attType, pVictim);
+
+    // stunned target cannot dodge and this is check in GetUnitDodgeChance() (returned 0 in this case)
+    float dodge_chance = pVictim->GetUnitDodgeChance();
+    float block_chance = pVictim->GetUnitBlockChance();
+    float parry_chance = pVictim->GetUnitParryChance();
+
+    // Useful if want to specify crit & miss chances for melee, else it could be removed
+    sLog.outStaticDebug("MELEE OUTCOME: miss %f crit %f dodge %f parry %f block %f", miss_chance,crit_chance,dodge_chance,parry_chance,block_chance);
+
+    return RollMeleeOutcomeAgainst(pVictim, attType, int32(crit_chance*100), int32(miss_chance*100), int32(dodge_chance*100),int32(parry_chance*100),int32(block_chance*100));
+}
+
+MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit *pVictim, WeaponAttackType attType, int32 crit_chance, int32 miss_chance, int32 dodge_chance, int32 parry_chance, int32 block_chance) const
+{
+    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode())
+        return MELEE_HIT_EVADE;
+
+    int32 attackerMaxSkillValueForLevel = GetMaxSkillValueForLevel(pVictim);
+    int32 victimMaxSkillValueForLevel = pVictim->GetMaxSkillValueForLevel(this);
+
+    int32 attackerWeaponSkill = GetWeaponSkillValue(attType,pVictim);
+    int32 victimDefenseSkill = pVictim->GetDefenseSkillValue(this);
+
+    // bonus from skills is 0.04%
+    int32    skillBonus  = 4 * (attackerWeaponSkill - victimMaxSkillValueForLevel);
+    int32    sum = 0, tmp = 0;
+    int32    roll = urand (0, 10000);
+
+    sLog.outStaticDebug ("RollMeleeOutcomeAgainst: skill bonus of %d for attacker", skillBonus);
+    sLog.outStaticDebug ("RollMeleeOutcomeAgainst: rolled %d, miss %d, dodge %d, parry %d, block %d, crit %d",
+        roll, miss_chance, dodge_chance, parry_chance, block_chance, crit_chance);
+
+    tmp = miss_chance;
+
+    if (tmp > 0 && roll < (sum += tmp))
+    {
+        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: MISS");
+        return MELEE_HIT_MISS;
+    }
+
+    // always crit against a sitting target (except 0 crit chance)
+    if (pVictim->GetTypeId() == TYPEID_PLAYER && crit_chance > 0 && !pVictim->IsStandState())
+    {
+        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRIT (sitting victim)");
+        return MELEE_HIT_CRIT;
+    }
+
+    // Dodge chance
+
+    // only players can't dodge if attacker is behind
+    if (pVictim->GetTypeId() == TYPEID_PLAYER && !pVictim->HasInArc(M_PI,this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
+    }
+    else
+    {
+        // Reduce dodge chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            dodge_chance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType)*100);
+        else
+            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
+
+        // Modify dodge chance by attacker SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
+        dodge_chance+= GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE)*100;
+        dodge_chance = int32 (float (dodge_chance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));
+
+        tmp = dodge_chance;
+        if ((tmp > 0)                                        // check if unit _can_ dodge
+            && ((tmp -= skillBonus) > 0)
+            && roll < (sum += tmp))
+        {
+            sLog.outStaticDebug ("RollMeleeOutcomeAgainst: DODGE <%d, %d)", sum-tmp, sum);
+            return MELEE_HIT_DODGE;
+        }
+    }
+
+    // parry & block chances
+
+    // check if attack comes from behind, nobody can parry or block if attacker is behind
+    if (!pVictim->HasInArc(M_PI, this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: attack came from behind.");
+    else
+    {
+        // Reduce parry chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            parry_chance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType)*100);
+        else
+            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
+
+        if (pVictim->GetTypeId() == TYPEID_PLAYER || !(pVictim->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY))
+        {
+            int32 tmp2 = int32(parry_chance);
+            if (tmp2 > 0                                         // check if unit _can_ parry
+                && (tmp2 -= skillBonus) > 0
+                && roll < (sum += tmp2))
+            {
+                sLog.outStaticDebug ("RollMeleeOutcomeAgainst: PARRY <%d, %d)", sum-tmp2, sum);
+                return MELEE_HIT_PARRY;
+            }
+        }
+
+        if (pVictim->GetTypeId() == TYPEID_PLAYER || !(pVictim->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+        {
+            tmp = block_chance;
+            if (tmp > 0                                          // check if unit _can_ block
+                && (tmp -= skillBonus) > 0
+                && roll < (sum += tmp))
+            {
+                sLog.outStaticDebug ("RollMeleeOutcomeAgainst: BLOCK <%d, %d)", sum-tmp, sum);
+                return MELEE_HIT_BLOCK;
+            }
+        }
+    }
+
+    // Critical chance
+    tmp = crit_chance;
+
+    if (tmp > 0 && roll < (sum += tmp))
+    {
+        sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRIT <%d, %d)", sum-tmp, sum);
+        if (GetTypeId() == TYPEID_UNIT && (this->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRIT))
+            sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRIT DISABLED)");
+        else
+            return MELEE_HIT_CRIT;
+    }
+
+    // Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)
+    if (attType != RANGED_ATTACK &&
+        (GetTypeId() == TYPEID_PLAYER || this->ToCreature()->isPet()) &&
+        pVictim->GetTypeId() != TYPEID_PLAYER && !pVictim->ToCreature()->isPet() &&
+        getLevel() < pVictim->getLevelForTarget(this))
+    {
+        // cap possible value (with bonuses > max skill)
+        int32 skill = attackerWeaponSkill;
+        int32 maxskill = attackerMaxSkillValueForLevel;
+        skill = (skill > maxskill) ? maxskill : skill;
+
+        tmp = (10 + (victimDefenseSkill - skill)) * 100;
+        tmp = tmp > 4000 ? 4000 : tmp;
+        if (roll < (sum += tmp))
+        {
+            sLog.outStaticDebug ("RollMeleeOutcomeAgainst: GLANCING <%d, %d)", sum-4000, sum);
+            return MELEE_HIT_GLANCING;
+        }
+    }
+
+    // mobs can score crushing blows if they're 4 or more levels above victim
+    if (getLevelForTarget(pVictim) >= pVictim->getLevelForTarget(this) + 4 &&
+        // can be from by creature (if can) or from controlled player that considered as creature
+        !IsControlledByPlayer() &&
+        !(GetTypeId() == TYPEID_UNIT && this->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRUSH))
+    {
+        // when their weapon skill is 15 or more above victim's defense skill
+        tmp = victimDefenseSkill;
+        int32 tmpmax = victimMaxSkillValueForLevel;
+        // having defense above your maximum (from items, talents etc.) has no effect
+        tmp = tmp > tmpmax ? tmpmax : tmp;
+        // tmp = mob's level * 5 - player's current defense skill
+        tmp = attackerMaxSkillValueForLevel - tmp;
+        if (tmp >= 15)
+        {
+            // add 2% chance per lacking skill point, min. is 15%
+            tmp = tmp * 200 - 1500;
+            if (roll < (sum += tmp))
+            {
+                sLog.outStaticDebug ("RollMeleeOutcomeAgainst: CRUSHING <%d, %d)", sum-tmp, sum);
+                return MELEE_HIT_CRUSHING;
+            }
+        }
+    }
+
+    sLog.outStaticDebug ("RollMeleeOutcomeAgainst: NORMAL");
+    return MELEE_HIT_NORMAL;
+}
+
+uint32 Unit::CalculateDamage(WeaponAttackType attType, bool normalized, bool addTotalPct)
+{
+    float min_damage, max_damage;
+
+    if (GetTypeId() == TYPEID_PLAYER && (normalized || !addTotalPct))
+        this->ToPlayer()->CalculateMinMaxDamage(attType,normalized,addTotalPct,min_damage, max_damage);
+    else
+    {
+        switch (attType)
+        {
+            case RANGED_ATTACK:
+                min_damage = GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE);
+                max_damage = GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE);
+                break;
+            case BASE_ATTACK:
+                min_damage = GetFloatValue(UNIT_FIELD_MINDAMAGE);
+                max_damage = GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+                break;
+            case OFF_ATTACK:
+                min_damage = GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE);
+                max_damage = GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE);
+                break;
+                // Just for good manner
+            default:
+                min_damage = 0.0f;
+                max_damage = 0.0f;
+                break;
+        }
+    }
+
+    if (min_damage > max_damage)
+        std::swap(min_damage,max_damage);
+
+    if (max_damage == 0.0f)
+        max_damage = 5.0f;
+
+    return urand((uint32)min_damage, (uint32)max_damage);
+}
+
+float Unit::CalculateLevelPenalty(SpellEntry const* spellProto) const
+{
+    if (spellProto->spellLevel <= 0 || spellProto->spellLevel >= spellProto->maxLevel)
+        return 1.0f;
+
+    float LvlPenalty = 0.0f;
+
+    if (spellProto->spellLevel < 20)
+        LvlPenalty = 20.0f - spellProto->spellLevel * 3.75f;
+    float LvlFactor = (float(spellProto->spellLevel) + 6.0f) / float(getLevel());
+    if (LvlFactor > 1.0f)
+        LvlFactor = 1.0f;
+
+    return (100.0f - LvlPenalty) * LvlFactor / 100.0f;
+}
+
+void Unit::SendMeleeAttackStart(Unit* pVictim)
+{
+    WorldPacket data(SMSG_ATTACKSTART, 8 + 8);
+    data << uint64(GetGUID());
+    data << uint64(pVictim->GetGUID());
+
+    SendMessageToSet(&data, true);
+    sLog.outStaticDebug("WORLD: Sent SMSG_ATTACKSTART");
+}
+
+void Unit::SendMeleeAttackStop(Unit* victim)
+{
+    if (!victim)
+        return;
+
+    WorldPacket data(SMSG_ATTACKSTOP, (8+8+4));            // we guess size
+    data.append(GetPackGUID());
+    data.append(victim->GetPackGUID());                     // can be 0x00...
+    data << uint32(0);                                      // can be 0x1
+    SendMessageToSet(&data, true);
+    sLog.outDetail("%s %u stopped attacking %s %u", (GetTypeId() == TYPEID_PLAYER ? "player" : "creature"), GetGUIDLow(), (victim->GetTypeId() == TYPEID_PLAYER ? "player" : "creature"),victim->GetGUIDLow());
+}
+
+bool Unit::isSpellBlocked(Unit *pVictim, SpellEntry const * /*spellProto*/, WeaponAttackType attackType)
+{
+    if (pVictim->HasInArc(M_PI,this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        // Check creatures flags_extra for disable block
+        if (pVictim->GetTypeId() == TYPEID_UNIT &&
+           pVictim->ToCreature()->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                return false;
+
+        float blockChance = pVictim->GetUnitBlockChance();
+        blockChance += (int32(GetWeaponSkillValue(attackType)) - int32(pVictim->GetMaxSkillValueForLevel()))*0.04f;
+        if (roll_chance_f(blockChance))
+            return true;
+    }
+    return false;
+}
+
+bool Unit::isBlockCritical()
+{
+    if (roll_chance_i(GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_CRIT_CHANCE)))
+        return true;
+    return false;
+}
+
+int32 Unit::GetMechanicResistChance(const SpellEntry *spell)
+{
+    if (!spell)
+        return 0;
+    int32 resist_mech = 0;
+    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
+    {
+        if (spell->Effect[eff] == 0)
+           break;
+        int32 effect_mech = GetEffectMechanic(spell, eff);
+        if (effect_mech)
+        {
+            int32 temp = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);
+            if (resist_mech < temp)
+                resist_mech = temp;
+        }
+    }
+    return resist_mech;
+}
+
+// Melee based spells hit result calculations
+SpellMissInfo Unit::MeleeSpellHitResult(Unit *pVictim, SpellEntry const *spell)
+{
+    WeaponAttackType attType = BASE_ATTACK;
+
+    // Check damage class instead of attack type to correctly handle judgements
+    // - they are meele, but can't be dodged/parried/deflected because of ranged dmg class
+    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
+        attType = RANGED_ATTACK;
+
+    int32 attackerWeaponSkill;
+    // skill value for these spells (for example judgements) is 5* level
+    if (spell->DmgClass == SPELL_DAMAGE_CLASS_RANGED && !IsRangedWeaponSpell(spell))
+        attackerWeaponSkill = getLevel() * 5;
+    // bonus from skills is 0.04% per skill Diff
+    else
+        attackerWeaponSkill = int32(GetWeaponSkillValue(attType,pVictim));
+
+    int32 skillDiff = attackerWeaponSkill - int32(pVictim->GetMaxSkillValueForLevel(this));
+    int32 fullSkillDiff = attackerWeaponSkill - int32(pVictim->GetDefenseSkillValue(this));
+
+    uint32 roll = urand (0, 10000);
+
+    uint32 missChance = uint32(MeleeSpellMissChance(pVictim, attType, fullSkillDiff, spell->Id)*100.0f);
+    // Roll miss
+    uint32 tmp = missChance;
+    if (roll < tmp)
+        return SPELL_MISS_MISS;
+
+    // Chance resist mechanic (select max value from every mechanic spell effect)
+    int32 resist_mech = 0;
+    // Get effects mechanic and chance
+    for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
+    {
+        int32 effect_mech = GetEffectMechanic(spell, eff);
+        if (effect_mech)
+        {
+            int32 temp = pVictim->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MECHANIC_RESISTANCE, effect_mech);
+            if (resist_mech < temp*100)
+                resist_mech = temp*100;
+        }
+    }
+    // Roll chance
+    tmp += resist_mech;
+    if (roll < tmp)
+        return SPELL_MISS_RESIST;
+
+    bool canDodge = true;
+    bool canParry = true;
+    bool canBlock = spell->AttributesEx3 & SPELL_ATTR_EX3_BLOCKABLE_SPELL;
+
+    // Same spells cannot be parry/dodge
+    if (spell->Attributes & SPELL_ATTR_IMPOSSIBLE_DODGE_PARRY_BLOCK)
+        return SPELL_MISS_NONE;
+
+    // Chance resist mechanic
+    int32 resist_chance = pVictim->GetMechanicResistChance(spell)*100;
+    tmp += resist_chance;
+    if (roll < tmp)
+        return SPELL_MISS_RESIST;
+
+    // Ranged attacks can only miss, resist and deflect
+    if (attType == RANGED_ATTACK)
+    {
+        // only if in front
+        if (pVictim->HasInArc(M_PI,this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+        {
+            int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS)*100;
+            tmp+=deflect_chance;
+            if (roll < tmp)
+                return SPELL_MISS_DEFLECT;
+        }
+        return SPELL_MISS_NONE;
+    }
+
+    // Check for attack from behind
+    if (!pVictim->HasInArc(M_PI,this) && !pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        // Can`t dodge from behind in PvP (but its possible in PvE)
+        if (pVictim->GetTypeId() == TYPEID_PLAYER)
+            canDodge = false;
+        // Can`t parry or block
+        canParry = false;
+        canBlock = false;
+    }
+    // Check creatures flags_extra for disable parry
+    if (pVictim->GetTypeId() == TYPEID_UNIT)
+    {
+        uint32 flagEx = pVictim->ToCreature()->GetCreatureInfo()->flags_extra;
+        if (flagEx & CREATURE_FLAG_EXTRA_NO_PARRY)
+            canParry = false;
+        // Check creatures flags_extra for disable block
+        if (flagEx & CREATURE_FLAG_EXTRA_NO_BLOCK)
+            canBlock = false;
+    }
+    // Ignore combat result aura
+    AuraEffectList const &ignore = GetAuraEffectsByType(SPELL_AURA_IGNORE_COMBAT_RESULT);
+    for (AuraEffectList::const_iterator i = ignore.begin(); i != ignore.end(); ++i)
+    {
+        if (!(*i)->IsAffectedOnSpell(spell))
+            continue;
+        switch ((*i)->GetMiscValue())
+        {
+            case MELEE_HIT_DODGE: canDodge = false; break;
+            case MELEE_HIT_BLOCK: canBlock = false; break;
+            case MELEE_HIT_PARRY: canParry = false; break;
+            default:
+                sLog.outStaticDebug("Spell %u SPELL_AURA_IGNORE_COMBAT_RESULT have unhandled state %d", (*i)->GetId(), (*i)->GetMiscValue());
+                break;
+        }
+    }
+
+    if (canDodge)
+    {
+        // Roll dodge
+        int32 dodgeChance = int32(pVictim->GetUnitDodgeChance()*100.0f) - skillDiff * 4;
+        // Reduce enemy dodge chance by SPELL_AURA_MOD_COMBAT_RESULT_CHANCE
+        dodgeChance += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_COMBAT_RESULT_CHANCE, VICTIMSTATE_DODGE)*100;
+        dodgeChance = int32(float(dodgeChance) * GetTotalAuraMultiplier(SPELL_AURA_MOD_ENEMY_DODGE));
+        // Reduce dodge chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            dodgeChance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);
+        else
+            dodgeChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
+        if (dodgeChance < 0)
+            dodgeChance = 0;
+
+        if (roll < (tmp += dodgeChance))
+            return SPELL_MISS_DODGE;
+    }
+
+    if (canParry)
+    {
+        // Roll parry
+        int32 parryChance = int32(pVictim->GetUnitParryChance()*100.0f)  - skillDiff * 4;
+        // Reduce parry chance by attacker expertise rating
+        if (GetTypeId() == TYPEID_PLAYER)
+            parryChance -= int32(this->ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100.0f);
+        else
+            parryChance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE)*25;
+        if (parryChance < 0)
+            parryChance = 0;
+
+        tmp += parryChance;
+        if (roll < tmp)
+            return SPELL_MISS_PARRY;
+    }
+
+    if (canBlock)
+    {
+        int32 blockChance = int32(pVictim->GetUnitBlockChance()*100.0f)  - skillDiff * 4;
+        if (blockChance < 0)
+            blockChance = 0;
+        tmp += blockChance;
+
+        if (roll < tmp)
+            return SPELL_MISS_BLOCK;
+    }
+
+    return SPELL_MISS_NONE;
+}
+
+// TODO need use unit spell resistances in calculations
+SpellMissInfo Unit::MagicSpellHitResult(Unit *pVictim, SpellEntry const *spell)
+{
+    // Can`t miss on dead target (on skinning for example)
+    if (!pVictim->isAlive() && pVictim->GetTypeId() != TYPEID_PLAYER)
+        return SPELL_MISS_NONE;
+
+    SpellSchoolMask schoolMask = GetSpellSchoolMask(spell);
+    // PvP - PvE spell misschances per leveldif > 2
+    int32 lchance = pVictim->GetTypeId() == TYPEID_PLAYER ? 7 : 11;
+    int32 leveldif = int32(pVictim->getLevelForTarget(this)) - int32(getLevelForTarget(pVictim));
+
+    // Base hit chance from attacker and victim levels
+    int32 modHitChance;
+    if (leveldif < 3)
+        modHitChance = 96 - leveldif;
+    else
+        modHitChance = 94 - (leveldif - 2) * lchance;
+
+    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
+    if (Player *modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spell->Id, SPELLMOD_RESIST_MISS_CHANCE, modHitChance);
+    // Increase from attacker SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT auras
+    modHitChance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, schoolMask);
+    // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
+    modHitChance += pVictim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, schoolMask);
+    // Reduce spell hit chance for Area of effect spells from victim SPELL_AURA_MOD_AOE_AVOIDANCE aura
+    if (IsAreaOfEffectSpell(spell))
+        modHitChance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_AOE_AVOIDANCE);
+
+    int32 HitChance = modHitChance * 100;
+    // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
+    HitChance += int32(m_modSpellHitChance * 100.0f);
+
+    // Decrease hit chance from victim rating bonus
+    if (pVictim->GetTypeId() == TYPEID_PLAYER)
+        HitChance -= int32(pVictim->ToPlayer()->GetRatingBonusValue(CR_HIT_TAKEN_SPELL) * 100.0f);
+
+    if (HitChance < 100)
+        HitChance = 100;
+    else if (HitChance > 10000)
+        HitChance = 10000;
+
+    int32 tmp = 10000 - HitChance;
+
+    int32 rand = irand(0, 10000);
+
+    if (rand < tmp)
+        return SPELL_MISS_MISS;
+
+    // Chance resist mechanic (select max value from every mechanic spell effect)
+    int32 resist_chance = pVictim->GetMechanicResistChance(spell) * 100;
+    tmp += resist_chance;
+
+    // Chance resist debuff
+    if (!IsPositiveSpell(spell->Id))
+    {
+        bool bNegativeAura = false;
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spell->EffectApplyAuraName[i] != 0)
+            {
+                bNegativeAura = true;
+                break;
+            }
+        }
+
+        if (bNegativeAura)
+        {
+            tmp += pVictim->GetMaxPositiveAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spell->Dispel)) * 100;
+            tmp += pVictim->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spell->Dispel)) * 100;
+        }
+    }
+
+   // Roll chance
+    if (rand < tmp)
+        return SPELL_MISS_RESIST;
+
+    // cast by caster in front of victim
+    if (pVictim->HasInArc(M_PI, this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        int32 deflect_chance = pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * 100;
+        tmp += deflect_chance;
+        if (rand < tmp)
+            return SPELL_MISS_DEFLECT;
+    }
+
+    return SPELL_MISS_NONE;
+}
+
+// Calculate spell hit result can be:
+// Every spell can: Evade/Immune/Reflect/Sucesful hit
+// For melee based spells:
+//   Miss
+//   Dodge
+//   Parry
+// For spells
+//   Resist
+SpellMissInfo Unit::SpellHitResult(Unit *pVictim, SpellEntry const *spell, bool CanReflect)
+{
+    // Return evade for units in evade mode
+    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsInEvadeMode() && this != pVictim)
+        return SPELL_MISS_EVADE;
+
+    // Check for immune
+    if (pVictim->IsImmunedToSpell(spell))
+        return SPELL_MISS_IMMUNE;
+
+    // All positive spells can`t miss
+    // TODO: client not show miss log for this spells - so need find info for this in dbc and use it!
+    if (IsPositiveSpell(spell->Id)
+        &&(!IsHostileTo(pVictim)))  //prevent from affecting enemy by "positive" spell
+        return SPELL_MISS_NONE;
+    // Check for immune
+    if (pVictim->IsImmunedToDamage(spell))
+        return SPELL_MISS_IMMUNE;
+
+    if (this == pVictim)
+        return SPELL_MISS_NONE;
+
+    // Try victim reflect spell
+    if (CanReflect)
+    {
+        int32 reflectchance = pVictim->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS);
+        Unit::AuraEffectList const& mReflectSpellsSchool = pVictim->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
+        for (Unit::AuraEffectList::const_iterator i = mReflectSpellsSchool.begin(); i != mReflectSpellsSchool.end(); ++i)
+            if ((*i)->GetMiscValue() & GetSpellSchoolMask(spell))
+                reflectchance += (*i)->GetAmount();
+        if (reflectchance > 0 && roll_chance_i(reflectchance))
+        {
+            // Start triggers for remove charges if need (trigger only for victim, and mark as active spell)
+            ProcDamageAndSpell(pVictim, PROC_FLAG_NONE, PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG, PROC_EX_REFLECT, 1, BASE_ATTACK, spell);
+            return SPELL_MISS_REFLECT;
+        }
+    }
+
+    switch (spell->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_RANGED:
+        case SPELL_DAMAGE_CLASS_MELEE:
+            return MeleeSpellHitResult(pVictim, spell);
+        case SPELL_DAMAGE_CLASS_NONE:
+            return SPELL_MISS_NONE;
+        case SPELL_DAMAGE_CLASS_MAGIC:
+            return MagicSpellHitResult(pVictim, spell);
+    }
+    return SPELL_MISS_NONE;
+}
+
+uint32 Unit::GetDefenseSkillValue(Unit const* target) const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        // in PvP use full skill instead current skill value
+        uint32 value = (target && target->GetTypeId() == TYPEID_PLAYER)
+            ? this->ToPlayer()->GetMaxSkillValue(SKILL_DEFENSE)
+            : this->ToPlayer()->GetSkillValue(SKILL_DEFENSE);
+        value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_DEFENSE_SKILL));
+        return value;
+    }
+    else
+        return GetUnitMeleeSkill(target);
+}
+
+float Unit::GetUnitDodgeChance() const
+{
+    if (hasUnitState(UNIT_STAT_STUNNED))
+        return 0.0f;
+    if (GetTypeId() == TYPEID_PLAYER)
+        return GetFloatValue(PLAYER_DODGE_PERCENTAGE);
+    else
+    {
+        if (((Creature const*)this)->isTotem())
+            return 0.0f;
+        else
+        {
+            float dodge = 5.0f;
+            dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
+            return dodge > 0.0f ? dodge : 0.0f;
+        }
+    }
+}
+
+float Unit::GetUnitParryChance() const
+{
+    if (IsNonMeleeSpellCasted(false) || hasUnitState(UNIT_STAT_STUNNED))
+        return 0.0f;
+
+    float chance = 0.0f;
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player const* player = (Player const*)this;
+        if (player->CanParry())
+        {
+            Item *tmpitem = player->GetWeaponForAttack(BASE_ATTACK,true);
+            if (!tmpitem)
+                tmpitem = player->GetWeaponForAttack(OFF_ATTACK,true);
+
+            if (tmpitem)
+                chance = GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+        }
+    }
+    else if (GetTypeId() == TYPEID_UNIT)
+    {
+        if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
+        {
+            chance = 5.0f;
+            chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
+        }
+    }
+
+    return chance > 0.0f ? chance : 0.0f;
+}
+
+float Unit::GetUnitBlockChance() const
+{
+    if (IsNonMeleeSpellCasted(false) || hasUnitState(UNIT_STAT_STUNNED))
+        return 0.0f;
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player const* player = (Player const*)this;
+        if (player->CanBlock())
+        {
+            Item *tmpitem = player->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+            if (tmpitem && !tmpitem->IsBroken() && tmpitem->GetProto()->Block)
+                return GetFloatValue(PLAYER_BLOCK_PERCENTAGE);
+        }
+        // is player but has no block ability or no not broken shield equipped
+        return 0.0f;
+    }
+    else
+    {
+        if (((Creature const*)this)->isTotem())
+            return 0.0f;
+        else
+        {
+            float block = 5.0f;
+            block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
+            return block > 0.0f ? block : 0.0f;
+        }
+    }
+}
+
+float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit *pVictim) const
+{
+    float crit;
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        switch(attackType)
+        {
+            case BASE_ATTACK:
+                crit = GetFloatValue(PLAYER_CRIT_PERCENTAGE);
+                break;
+            case OFF_ATTACK:
+                crit = GetFloatValue(PLAYER_OFFHAND_CRIT_PERCENTAGE);
+                break;
+            case RANGED_ATTACK:
+                crit = GetFloatValue(PLAYER_RANGED_CRIT_PERCENTAGE);
+                break;
+                // Just for good manner
+            default:
+                crit = 0.0f;
+                break;
+        }
+    }
+    else
+    {
+        crit = 5.0f;
+        crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
+        crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
+    }
+
+    // flat aura mods
+    if (attackType == RANGED_ATTACK)
+        crit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_CRIT_CHANCE);
+    else
+        crit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_CRIT_CHANCE);
+
+    crit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
+
+    // reduce crit chance from Rating for players
+    if (attackType != RANGED_ATTACK)
+    {
+        ApplyResilience(pVictim, &crit, NULL, false, CR_CRIT_TAKEN_MELEE);
+        // Glyph of barkskin
+        if (pVictim->HasAura(63057) && pVictim->HasAura(22812))
+            crit -= 25.0f;
+    }
+    else
+        ApplyResilience(pVictim, &crit, NULL, false, CR_CRIT_TAKEN_RANGED);
+
+    // Apply crit chance from defence skill
+    crit += (int32(GetMaxSkillValueForLevel(pVictim)) - int32(pVictim->GetDefenseSkillValue(this))) * 0.04f;
+
+    if (crit < 0.0f)
+        crit = 0.0f;
+    return crit;
+}
+
+uint32 Unit::GetWeaponSkillValue (WeaponAttackType attType, Unit const* target) const
+{
+    uint32 value = 0;
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Item* item = this->ToPlayer()->GetWeaponForAttack(attType,true);
+
+        // feral or unarmed skill only for base attack
+        if (attType != BASE_ATTACK && !item)
+            return 0;
+
+        if (IsInFeralForm())
+            return GetMaxSkillValueForLevel();              // always maximized SKILL_FERAL_COMBAT in fact
+
+        // weapon skill or (unarmed for base attack and fist weapons)
+        uint32 skill;
+        if (item && item->GetSkill() != SKILL_FIST_WEAPONS)
+            skill = item->GetSkill();
+        else
+            skill = SKILL_UNARMED;
+
+        // in PvP use full skill instead current skill value
+        value = (target && target->IsControlledByPlayer())
+            ? this->ToPlayer()->GetMaxSkillValue(skill)
+            : this->ToPlayer()->GetSkillValue(skill);
+        // Modify value from ratings
+        value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL));
+        switch (attType)
+        {
+            case BASE_ATTACK:   value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL_MAINHAND)); break;
+            case OFF_ATTACK:    value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL_OFFHAND));  break;
+            case RANGED_ATTACK: value += uint32(this->ToPlayer()->GetRatingBonusValue(CR_WEAPON_SKILL_RANGED));   break;
+            default: break;
+        }
+    }
+    else
+        value = GetUnitMeleeSkill(target);
+   return value;
+}
+
+void Unit::_DeleteRemovedAuras()
+{
+    while (!m_removedAuras.empty())
+    {
+        delete m_removedAuras.front();
+        m_removedAuras.pop_front();
+    }
+}
+
+void Unit::_UpdateSpells(uint32 time)
+{
+    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
+        _UpdateAutoRepeatSpell();
+
+    // remove finished spells from current pointers
+    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
+    {
+        if (m_currentSpells[i] && m_currentSpells[i]->getState() == SPELL_STATE_FINISHED)
+        {
+            m_currentSpells[i]->SetReferencedFromCurrent(false);
+            m_currentSpells[i] = NULL;                      // remove pointer
+        }
+    }
+
+    // m_auraUpdateIterator can be updated in indirect called code at aura remove to skip next planned to update but removed auras
+    for (m_auraUpdateIterator = m_ownedAuras.begin(); m_auraUpdateIterator != m_ownedAuras.end();)
+    {
+        Aura * i_aura = m_auraUpdateIterator->second;
+        ++m_auraUpdateIterator;                            // need shift to next for allow update if need into aura update
+        i_aura->UpdateOwner(time, this);
+    }
+
+    // remove expired auras - do that after updates(used in scripts?)
+    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end();)
+    {
+        if (i->second->IsExpired())
+            RemoveOwnedAura(i, AURA_REMOVE_BY_EXPIRE);
+        else
+            ++i;
+    }
+
+    for (VisibleAuraMap::iterator itr = m_visibleAuras.begin(); itr != m_visibleAuras.end(); ++itr)
+        if (itr->second->IsNeedClientUpdate())
+            itr->second->ClientUpdate();
+
+    _DeleteRemovedAuras();
+
+    if (!m_gameObj.empty())
+    {
+        GameObjectList::iterator itr;
+        for (itr = m_gameObj.begin(); itr != m_gameObj.end();)
+        {
+            if (!(*itr)->isSpawned())
+            {
+                (*itr)->SetOwnerGUID(0);
+                (*itr)->SetRespawnTime(0);
+                (*itr)->Delete();
+                m_gameObj.erase(itr++);
+            }
+            else
+                ++itr;
+        }
+    }
+}
+
+void Unit::_UpdateAutoRepeatSpell()
+{
+    //check "realtime" interrupts
+    if ((GetTypeId() == TYPEID_PLAYER && ((Player*)this)->isMoving()) || IsNonMeleeSpellCasted(false,false,true,m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == 75))
+    {
+        // cancel wand shoot
+        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+        m_AutoRepeatFirstCast = true;
+        return;
+    }
+
+    //apply delay (Auto Shot (spellID 75) not affected)
+    if (m_AutoRepeatFirstCast && getAttackTimer(RANGED_ATTACK) < 500 && m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+        setAttackTimer(RANGED_ATTACK,500);
+    m_AutoRepeatFirstCast = false;
+
+    //castroutine
+    if (isAttackReady(RANGED_ATTACK))
+    {
+        // Check if able to cast
+        if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->CheckCast(true) != SPELL_CAST_OK)
+        {
+            InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            return;
+        }
+
+        // we want to shoot
+        Spell* spell = new Spell(this, m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo, true);
+        spell->prepare(&(m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_targets));
+
+        // all went good, reset attack
+        resetAttackTimer(RANGED_ATTACK);
+    }
+}
+
+void Unit::SetCurrentCastedSpell(Spell * pSpell)
+{
+    ASSERT(pSpell);                                         // NULL may be never passed here, use InterruptSpell or InterruptNonMeleeSpells
+
+    CurrentSpellTypes CSpellType = pSpell->GetCurrentContainer();
+
+    if (pSpell == m_currentSpells[CSpellType]) return;      // avoid breaking self
+
+    // break same type spell if it is not delayed
+    InterruptSpell(CSpellType,false);
+
+    // special breakage effects:
+    switch (CSpellType)
+    {
+        case CURRENT_GENERIC_SPELL:
+        {
+            // generic spells always break channeled not delayed spells
+            InterruptSpell(CURRENT_CHANNELED_SPELL,false);
+
+            // autorepeat breaking
+            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
+            {
+                // break autorepeat if not Auto Shot
+                if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+                    InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                m_AutoRepeatFirstCast = true;
+            }
+            addUnitState(UNIT_STAT_CASTING);
+        } break;
+
+        case CURRENT_CHANNELED_SPELL:
+        {
+            // channel spells always break generic non-delayed and any channeled spells
+            InterruptSpell(CURRENT_GENERIC_SPELL,false);
+            InterruptSpell(CURRENT_CHANNELED_SPELL);
+
+            // it also does break autorepeat if not Auto Shot
+            if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] &&
+                m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id != 75)
+                InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            addUnitState(UNIT_STAT_CASTING);
+        } break;
+
+        case CURRENT_AUTOREPEAT_SPELL:
+        {
+            // only Auto Shoot does not break anything
+            if (pSpell->m_spellInfo->Id != 75)
+            {
+                // generic autorepeats break generic non-delayed and channeled non-delayed spells
+                InterruptSpell(CURRENT_GENERIC_SPELL,false);
+                InterruptSpell(CURRENT_CHANNELED_SPELL,false);
+            }
+            // special action: set first cast flag
+            m_AutoRepeatFirstCast = true;
+        } break;
+
+        default:
+        {
+            // other spell types don't break anything now
+        } break;
+    }
+
+    // current spell (if it is still here) may be safely deleted now
+    if (m_currentSpells[CSpellType])
+        m_currentSpells[CSpellType]->SetReferencedFromCurrent(false);
+
+    // set new current spell
+    m_currentSpells[CSpellType] = pSpell;
+    pSpell->SetReferencedFromCurrent(true);
+
+    pSpell->m_selfContainer = &(m_currentSpells[pSpell->GetCurrentContainer()]);
+}
+
+void Unit::InterruptSpell(CurrentSpellTypes spellType, bool withDelayed, bool withInstant)
+{
+    ASSERT(spellType < CURRENT_MAX_SPELL);
+
+    //sLog.outDebug("Interrupt spell for unit %u.", GetEntry());
+    Spell *spell = m_currentSpells[spellType];
+    if (spell
+        && (withDelayed || spell->getState() != SPELL_STATE_DELAYED)
+        && (withInstant || spell->GetCastTime() > 0))
+    {
+        // for example, do not let self-stun aura interrupt itself
+        if (!spell->IsInterruptable())
+            return;
+
+        m_currentSpells[spellType] = NULL;
+
+        // send autorepeat cancel message for autorepeat spells
+        if (spellType == CURRENT_AUTOREPEAT_SPELL)
+        {
+            if (GetTypeId() == TYPEID_PLAYER)
+                this->ToPlayer()->SendAutoRepeatCancel(this);
+        }
+
+        if (spell->getState() != SPELL_STATE_FINISHED)
+            spell->cancel();
+        spell->SetReferencedFromCurrent(false);
+    }
+}
+
+void Unit::FinishSpell(CurrentSpellTypes spellType, bool ok /*= true*/)
+{
+    Spell* spell = m_currentSpells[spellType];
+    if (!spell)
+        return;
+
+    if (spellType == CURRENT_CHANNELED_SPELL)
+        spell->SendChannelUpdate(0);
+
+    spell->finish(ok);
+}
+
+bool Unit::IsNonMeleeSpellCasted(bool withDelayed, bool skipChanneled, bool skipAutorepeat, bool isAutoshoot, bool skipInstant) const
+{
+    // We don't do loop here to explicitly show that melee spell is excluded.
+    // Maybe later some special spells will be excluded too.
+
+    // if checkInstant then instant spells shouldn't count as being casted
+    if (!skipInstant && m_currentSpells[CURRENT_GENERIC_SPELL] && !m_currentSpells[CURRENT_GENERIC_SPELL]->GetCastTime())
+        return false;
+
+    // generic spells are casted when they are not finished and not delayed
+    if (m_currentSpells[CURRENT_GENERIC_SPELL] &&
+        (m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_FINISHED) &&
+        (withDelayed || m_currentSpells[CURRENT_GENERIC_SPELL]->getState() != SPELL_STATE_DELAYED))
+    {
+        if (!isAutoshoot || !(m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_RESET_AUTO_ACTIONS))
+            return(true);
+    }
+    // channeled spells may be delayed, but they are still considered casted
+    else if (!skipChanneled && m_currentSpells[CURRENT_CHANNELED_SPELL] &&
+        (m_currentSpells[CURRENT_CHANNELED_SPELL]->getState() != SPELL_STATE_FINISHED))
+    {
+        if (!isAutoshoot || !(m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_RESET_AUTO_ACTIONS))
+            return(true);
+    }
+    // autorepeat spells may be finished or delayed, but they are still considered casted
+    else if (!skipAutorepeat && m_currentSpells[CURRENT_AUTOREPEAT_SPELL])
+        return(true);
+
+    return(false);
+}
+
+void Unit::InterruptNonMeleeSpells(bool withDelayed, uint32 spell_id, bool withInstant)
+{
+    // generic spells are interrupted if they are not finished or delayed
+    if (m_currentSpells[CURRENT_GENERIC_SPELL] && (!spell_id || m_currentSpells[CURRENT_GENERIC_SPELL]->m_spellInfo->Id == spell_id))
+        InterruptSpell(CURRENT_GENERIC_SPELL,withDelayed,withInstant);
+
+    // autorepeat spells are interrupted if they are not finished or delayed
+    if (m_currentSpells[CURRENT_AUTOREPEAT_SPELL] && (!spell_id || m_currentSpells[CURRENT_AUTOREPEAT_SPELL]->m_spellInfo->Id == spell_id))
+        InterruptSpell(CURRENT_AUTOREPEAT_SPELL,withDelayed,withInstant);
+
+    // channeled spells are interrupted if they are not finished, even if they are delayed
+    if (m_currentSpells[CURRENT_CHANNELED_SPELL] && (!spell_id || m_currentSpells[CURRENT_CHANNELED_SPELL]->m_spellInfo->Id == spell_id))
+        InterruptSpell(CURRENT_CHANNELED_SPELL,true,true);
+}
+
+Spell* Unit::FindCurrentSpellBySpellId(uint32 spell_id) const
+{
+    for (uint32 i = 0; i < CURRENT_MAX_SPELL; i++)
+        if (m_currentSpells[i] && m_currentSpells[i]->m_spellInfo->Id == spell_id)
+            return m_currentSpells[i];
+    return NULL;
+}
+
+int32 Unit::GetCurrentSpellCastTime(uint32 spell_id) const
+{
+    if (Spell const * spell = FindCurrentSpellBySpellId(spell_id))
+        return spell->GetCastTime();
+    return 0;
+}
+
+bool Unit::isInFrontInMap(Unit const* target, float distance,  float arc) const
+{
+    return IsWithinDistInMap(target, distance) && HasInArc(arc, target);
+}
+
+bool Unit::isInBackInMap(Unit const* target, float distance, float arc) const
+{
+    return IsWithinDistInMap(target, distance) && !HasInArc(2 * M_PI - arc, target);
+}
+
+void Unit::SetFacingToObject(WorldObject* pObject)
+{
+    // update orientation at server
+    SetOrientation(GetAngle(pObject));
+
+    // and client
+    WorldPacket data;
+    BuildHeartBeatMsg(&data);
+    SendMessageToSet(&data, false);
+}
+
+bool Unit::isInAccessiblePlaceFor(Creature const* c) const
+{
+    if (IsInWater())
+        return c->canSwim();
+    else
+        return c->canWalk() || c->canFly();
+}
+
+bool Unit::IsInWater() const
+{
+    return GetBaseMap()->IsInWater(GetPositionX(),GetPositionY(), GetPositionZ());
+}
+
+bool Unit::IsUnderWater() const
+{
+    return GetBaseMap()->IsUnderWater(GetPositionX(),GetPositionY(),GetPositionZ());
+}
+
+void Unit::DeMorph()
+{
+    SetDisplayId(GetNativeDisplayId());
+}
+
+void Unit::_AddAura(UnitAura * aura, Unit * caster)
+{
+    ASSERT(!m_cleanupDone);
+    m_ownedAuras.insert(AuraMap::value_type(aura->GetId(), aura));
+
+    // passive and Incanter's Absorption and auras with different type can stack with themselves any number of times
+    if (!aura->IsPassive() && aura->GetId() != 44413)
+    {
+        // find current aura from spell and change it's stackamount
+        if (Aura * foundAura = GetOwnedAura(aura->GetId(), aura->GetCasterGUID(), 0, aura))
+        {
+            if (aura->GetSpellProto()->StackAmount)
+            {
+                aura->ModStackAmount(foundAura->GetStackAmount());
+            }
+            // Update periodic timers from the previous aura
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                AuraEffect *existingEff = foundAura->GetEffect(i);
+                AuraEffect *newEff = aura->GetEffect(i);
+                if (!existingEff || !newEff)
+                    continue;
+                newEff->SetPeriodicTimer(existingEff->GetPeriodicTimer());
+            }
+
+            // Use the new one to replace the old one
+            // This is the only place where AURA_REMOVE_BY_STACK should be used
+            RemoveOwnedAura(foundAura, AURA_REMOVE_BY_STACK);
+        }
+    }
+    _RemoveNoStackAurasDueToAura(aura);
+
+    if (aura->IsRemoved())
+        return;
+
+    aura->SetIsSingleTarget(caster && IsSingleTargetSpell(aura->GetSpellProto()));
+    if (aura->IsSingleTarget())
+    {
+        ASSERT((IsInWorld() && !IsDuringRemoveFromWorld()) || (aura->GetCasterGUID() == GetGUID()));
+        // register single target aura
+        caster->GetSingleCastAuras().push_back(aura);
+        // remove other single target auras
+        Unit::AuraList& scAuras = caster->GetSingleCastAuras();
+        for (Unit::AuraList::iterator itr = scAuras.begin(); itr != scAuras.end();)
+        {
+            if ((*itr) != aura &&
+                IsSingleTargetSpells((*itr)->GetSpellProto(), aura->GetSpellProto()))
+            {
+                (*itr)->Remove();
+                itr = scAuras.begin();
+            }
+            else
+                ++itr;
+        }
+    }
+}
+
+// creates aura application instance and registers it in lists
+// aura application effects are handled separately to prevent aura list corruption
+AuraApplication * Unit::_CreateAuraApplication(Aura * aura, uint8 effMask)
+{
+    // can't apply aura on unit which is going to be deleted - to not create a memory leak
+    ASSERT(!m_cleanupDone);
+    // aura musn't be removed
+    ASSERT(!aura->IsRemoved());
+
+    SpellEntry const* aurSpellInfo = aura->GetSpellProto();
+    uint32 aurId = aurSpellInfo->Id;
+
+    // ghost spell check, allow apply any auras at player loading in ghost mode (will be cleanup after load)
+    if (!isAlive() && !IsDeathPersistentSpell(aurSpellInfo) &&
+        (GetTypeId() != TYPEID_PLAYER || !this->ToPlayer()->GetSession()->PlayerLoading()))
+        return NULL;
+
+    Unit * caster = aura->GetCaster();
+
+    AuraApplication * aurApp = new AuraApplication(this, caster, aura, effMask);
+    m_appliedAuras.insert(AuraApplicationMap::value_type(aurId, aurApp));
+
+    if (aurSpellInfo->AuraInterruptFlags)
+    {
+        m_interruptableAuras.push_back(aurApp);
+        AddInterruptMask(aurSpellInfo->AuraInterruptFlags);
+    }
+
+    if (AuraState aState = GetSpellAuraState(aura->GetSpellProto()))
+        m_auraStateAuras.insert(AuraStateAurasMap::value_type(aState, aurApp));
+
+    aura->_ApplyForTarget(this, caster, aurApp);
+    return aurApp;
+}
+
+void Unit::_ApplyAuraEffect(Aura * aura, uint8 effIndex)
+{
+    ASSERT(aura);
+    ASSERT(aura->HasEffect(effIndex));
+    AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID());
+    ASSERT(aurApp);
+    if (!aurApp->GetEffectMask())
+        _ApplyAura(aurApp, 1<<effIndex);
+    else
+        aurApp->_HandleEffect(effIndex, true);
+}
+
+// handles effects of aura application
+// should be done after registering aura in lists
+void Unit::_ApplyAura(AuraApplication * aurApp, uint8 effMask)
+{
+    Aura * aura = aurApp->GetBase();
+
+    _RemoveNoStackAurasDueToAura(aura);
+
+    if (aurApp->GetRemoveMode())
+        return;
+
+    // Update target aura state flag
+    if (AuraState aState = GetSpellAuraState(aura->GetSpellProto()))
+        ModifyAuraState(aState, true);
+
+    if (aurApp->GetRemoveMode())
+        return;
+
+    // Sitdown on apply aura req seated
+    if (aura->GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED && !IsSitState())
+        SetStandState(UNIT_STAND_STATE_SIT);
+
+    Unit * caster = aura->GetCaster();
+
+    if (aurApp->GetRemoveMode())
+        return;
+
+    aura->HandleAuraSpecificMods(aurApp, caster, true);
+
+    // apply effects of the aura
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (effMask & 1<<i && (!aurApp->GetRemoveMode()))
+            aurApp->_HandleEffect(i, true);
+    }
+}
+
+// removes aura application from lists and unapplies effects
+void Unit::_UnapplyAura(AuraApplicationMap::iterator &i, AuraRemoveMode removeMode)
+{
+    AuraApplication * aurApp = i->second;
+    ASSERT(aurApp);
+    ASSERT(!aurApp->GetRemoveMode());
+    ASSERT(aurApp->GetTarget() == this);
+    aurApp->SetRemoveMode(removeMode);
+    Aura * aura = aurApp->GetBase();
+    sLog.outDebug("Aura %u now is remove mode %d", aura->GetId(), removeMode);
+
+    // dead loop is killing the server probably
+    ASSERT(m_removedAurasCount < 0xFFFFFFFF);
+
+    ++m_removedAurasCount;
+
+    Unit * caster = aura->GetCaster();
+
+    // Remove all pointers from lists here to prevent possible pointer invalidation on spellcast/auraapply/auraremove
+    m_appliedAuras.erase(i);
+
+    if (aura->GetSpellProto()->AuraInterruptFlags)
+    {
+        m_interruptableAuras.remove(aurApp);
+        UpdateInterruptMask();
+    }
+
+    bool auraStateFound = false;
+    AuraState auraState = GetSpellAuraState(aura->GetSpellProto());
+    if (auraState)
+    {
+        bool canBreak = false;
+        // Get mask of all aurastates from remaining auras
+        for (AuraStateAurasMap::iterator itr = m_auraStateAuras.lower_bound(auraState); itr != m_auraStateAuras.upper_bound(auraState) && !(auraStateFound && canBreak);)
+        {
+            if (itr->second == aurApp)
+            {
+                m_auraStateAuras.erase(itr);
+                itr = m_auraStateAuras.lower_bound(auraState);
+                canBreak = true;
+                continue;
+            }
+            auraStateFound = true;
+            ++itr;
+        }
+    }
+
+    aurApp->_Remove();
+    aura->_UnapplyForTarget(this, caster, aurApp);
+
+    // remove effects of the spell - needs to be done after removing aura from lists
+    for (uint8 itr = 0 ; itr < MAX_SPELL_EFFECTS; ++itr)
+    {
+        if (aurApp->HasEffect(itr))
+            aurApp->_HandleEffect(itr, false);
+    }
+
+    // all effect mustn't be applied
+    ASSERT(!aurApp->GetEffectMask());
+
+    // Remove totem at next update if totem looses its aura
+    if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE && GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem()&& this->ToTotem()->GetSummonerGUID() == aura->GetCasterGUID())
+    {
+        if (this->ToTotem()->GetSpell() == aura->GetId() && this->ToTotem()->GetTotemType() == TOTEM_PASSIVE)
+            this->ToTotem()->setDeathState(JUST_DIED);
+    }
+
+    // Remove aurastates only if were not found
+    if (!auraStateFound)
+        ModifyAuraState(auraState, false);
+
+    aura->HandleAuraSpecificMods(aurApp, caster, false);
+
+    // only way correctly remove all auras from list
+    //if (removedAuras != m_removedAurasCount) new aura may be added
+        i = m_appliedAuras.begin();
+}
+
+void Unit::_UnapplyAura(AuraApplication * aurApp, AuraRemoveMode removeMode)
+{
+    // aura can be removed from unit only if it's applied on it, shouldn't happen
+    ASSERT(aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) == aurApp);
+    uint32 spellId = aurApp->GetBase()->GetId();
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
+    {
+        if (iter->second == aurApp)
+        {
+            _UnapplyAura(iter, removeMode);
+            return;
+        }
+        else
+            ++iter;
+    }
+    ASSERT(false);
+}
+
+void Unit::_RemoveNoStackAuraApplicationsDueToAura(Aura * aura)
+{
+    // dynobj auras can stack infinite number of times
+    if (aura->GetType() == DYNOBJ_AURA_TYPE)
+        return;
+
+    SpellEntry const* spellProto = aura->GetSpellProto();
+
+    uint32 spellId = spellProto->Id;
+
+    // passive spell special case (only non stackable with ranks)
+    if (IsPassiveSpell(spellId) && IsPassiveSpellStackableWithRanks(spellProto))
+        return;
+
+    bool remove = false;
+    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
+    {
+        if (remove)
+        {
+            remove = false;
+            i = m_appliedAuras.begin();
+        }
+
+        if (!_IsNoStackAuraDueToAura(aura, i->second->GetBase()))
+            continue;
+
+        RemoveAura(i, AURA_REMOVE_BY_DEFAULT);
+        if (i == m_appliedAuras.end())
+            break;
+        remove = true;
+    }
+}
+
+void Unit::_RemoveNoStackAurasDueToAura(Aura * aura)
+{
+    SpellEntry const* spellProto = aura->GetSpellProto();
+
+    uint32 spellId = spellProto->Id;
+
+    // passive spell special case (only non stackable with ranks)
+    if (IsPassiveSpell(spellId) && IsPassiveSpellStackableWithRanks(spellProto))
+        return;
+
+    bool remove = false;
+    for (AuraMap::iterator i = m_ownedAuras.begin(); i != m_ownedAuras.end(); ++i)
+    {
+        if (remove)
+        {
+            remove = false;
+            i = m_ownedAuras.begin();
+        }
+
+        if (!_IsNoStackAuraDueToAura(aura, i->second))
+            continue;
+
+        RemoveOwnedAura(i, AURA_REMOVE_BY_DEFAULT);
+        if (i == m_ownedAuras.end())
+            break;
+        remove = true;
+    }
+}
+
+bool Unit::_IsNoStackAuraDueToAura(Aura * appliedAura, Aura * existingAura) const
+{
+    SpellEntry const* spellProto = appliedAura->GetSpellProto();
+    // Do not check already applied aura
+    if (existingAura == appliedAura)
+        return false;
+
+    // Do not check dynobj auras for stacking
+    if (existingAura->GetType() != UNIT_AURA_TYPE)
+        return false;
+
+    SpellEntry const* i_spellProto = existingAura->GetSpellProto();
+    uint32 i_spellId = i_spellProto->Id;
+    bool sameCaster = appliedAura->GetCasterGUID() == existingAura->GetCasterGUID();
+
+    if (IsPassiveSpell(i_spellId))
+    {
+        // passive non-stackable spells not stackable only for same caster
+        if (!sameCaster)
+            return false;
+
+        // passive non-stackable spells not stackable only with another rank of same spell
+        if (!sSpellMgr.IsRankSpellDueToSpell(spellProto, i_spellId))
+            return false;
+    }
+
+    bool is_triggered_by_spell = false;
+    // prevent triggering aura of removing aura that triggered it
+    // prevent triggered aura of removing aura that triggering it (triggered effect early some aura of parent spell
+    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        if (i_spellProto->EffectTriggerSpell[j] == spellProto->Id
+            || spellProto->EffectTriggerSpell[j] == i_spellProto->Id) // I do not know what is this for
+        {
+            is_triggered_by_spell = true;
+            break;
+        }
+    }
+
+    if (is_triggered_by_spell)
+        return false;
+
+    if (sSpellMgr.CanAurasStack(spellProto, i_spellProto, sameCaster))
+        return false;
+    return true;
+}
+
+void Unit::_HandleAuraEffect(AuraEffect * aurEff, bool apply)
+{
+    if (apply)
+        m_modAuras[aurEff->GetAuraType()].push_back(aurEff);
+    else
+        m_modAuras[aurEff->GetAuraType()].remove(aurEff);
+}
+
+// All aura base removes should go threw this function!
+void Unit::RemoveOwnedAura(AuraMap::iterator &i, AuraRemoveMode removeMode)
+{
+    Aura * aura = i->second;
+    ASSERT(!aura->IsRemoved());
+
+    // if unit currently update aura list then make safe update iterator shift to next
+    if (m_auraUpdateIterator == i)
+        ++m_auraUpdateIterator;
+
+    m_ownedAuras.erase(i);
+    m_removedAuras.push_back(aura);
+
+    // Unregister single target aura
+    if (aura->IsSingleTarget())
+        aura->UnregisterSingleTarget();
+
+    aura->_Remove(removeMode);
+
+    i = m_ownedAuras.begin();
+}
+
+void Unit::RemoveOwnedAura(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)
+{
+    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId);)
+        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!caster || itr->second->GetCasterGUID() == caster))
+        {
+            RemoveOwnedAura(itr, removeMode);
+            itr = m_ownedAuras.lower_bound(spellId);
+        }
+        else
+            ++itr;
+}
+
+void Unit::RemoveOwnedAura(Aura * aura, AuraRemoveMode removeMode)
+{
+    if (aura->IsRemoved())
+        return;
+
+    ASSERT(aura->GetOwner() == this);
+
+    uint32 spellId = aura->GetId();
+    for (AuraMap::iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)
+        if (itr->second == aura)
+        {
+            RemoveOwnedAura(itr, removeMode);
+            return;
+        }
+    ASSERT(false);
+}
+
+Aura * Unit::GetOwnedAura(uint32 spellId, uint64 caster, uint8 reqEffMask, Aura * except) const
+{
+    for (AuraMap::const_iterator itr = m_ownedAuras.lower_bound(spellId); itr != m_ownedAuras.upper_bound(spellId); ++itr)
+        if (((itr->second->GetEffectMask() & reqEffMask) == reqEffMask) && (!caster || itr->second->GetCasterGUID() == caster) && (!except || except != itr->second))
+            return itr->second;
+    return NULL;
+}
+
+void Unit::RemoveAura(AuraApplicationMap::iterator &i, AuraRemoveMode mode)
+{
+    AuraApplication * aurApp = i->second;
+    // Do not remove aura which is already being removed
+    if (aurApp->GetRemoveMode())
+        return;
+    Aura * aura = aurApp->GetBase();
+    _UnapplyAura(i, mode);
+    // Remove aura - for Area and Target auras
+    if (aura->GetOwner() == this)
+        aura->Remove(mode);
+}
+
+void Unit::RemoveAura(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
+    {
+        Aura const * aura = iter->second->GetBase();
+        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
+            && (!caster || aura->GetCasterGUID() == caster))
+        {
+            RemoveAura(iter, removeMode);
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAura(AuraApplication * aurApp, AuraRemoveMode mode)
+{
+    ASSERT(aurApp->GetBase()->GetApplicationOfTarget(GetGUID()) == aurApp);
+    // no need to remove
+    if (aurApp->GetRemoveMode() || aurApp->GetBase()->IsRemoved())
+        return;
+    uint32 spellId = aurApp->GetBase()->GetId();
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
+    {
+        if (aurApp == iter->second)
+        {
+            RemoveAura(iter, mode);
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAura(Aura * aura, AuraRemoveMode mode)
+{
+    if (aura->IsRemoved())
+        return;
+    if (AuraApplication * aurApp = aura->GetApplicationOfTarget(GetGUID()))
+        RemoveAura(aurApp, mode);
+    else
+        ASSERT(false);
+}
+
+void Unit::RemoveAurasDueToSpell(uint32 spellId, uint64 caster, uint8 reqEffMask, AuraRemoveMode removeMode)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
+    {
+        Aura const * aura = iter->second->GetBase();
+        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask)
+            && (!caster || aura->GetCasterGUID() == caster))
+        {
+            RemoveAura(iter, removeMode);
+            iter = m_appliedAuras.lower_bound(spellId);
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAuraFromStack(uint32 spellId, uint64 caster, AuraRemoveMode removeMode)
+{
+    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
+    {
+        Aura const * aura = iter->second;
+        if ((aura->GetType() == UNIT_AURA_TYPE)
+            && (!caster || aura->GetCasterGUID() == caster))
+        {
+            RemoveAuraFromStack(iter, removeMode);
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+inline void Unit::RemoveAuraFromStack(AuraMap::iterator &iter, AuraRemoveMode removeMode)
+{
+    if (iter->second->ModStackAmount(-1))
+        RemoveOwnedAura(iter, removeMode);
+}
+
+void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint64 casterGUID, Unit *dispeller)
+{
+    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
+    {
+        Aura * aura = iter->second;
+        if (aura->GetCasterGUID() == casterGUID)
+        {
+            if (aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES)
+                aura->DropCharge();
+            else
+                RemoveAuraFromStack(iter, AURA_REMOVE_BY_ENEMY_SPELL);
+
+            // Unstable Affliction (crash if before removeaura?)
+            if (aura->GetSpellProto()->SpellFamilyName == SPELLFAMILY_WARLOCK && (aura->GetSpellProto()->SpellFamilyFlags[1] & 0x0100))
+            {
+                if (AuraEffect const * aurEff = aura->GetEffect(0))
+                {
+                    int32 damage = aurEff->GetAmount()*9;
+                    // backfire damage and silence
+                    dispeller->CastCustomSpell(dispeller, 31117, &damage, NULL, NULL, true, NULL, NULL, aura->GetCasterGUID());
+                }
+            }
+            // Flame Shock
+            if (aura->GetSpellProto()->SpellFamilyName == SPELLFAMILY_SHAMAN && (aura->GetSpellProto()->SpellFamilyFlags[0] & 0x10000000))
+            {
+                Unit * caster = aura->GetCaster();
+                if (caster)
+                {
+                    uint32 triggeredSpellId = 0;
+                    // Lava Flows
+                    if (AuraEffect const * aurEff = caster->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 3087, 0))
+                    {
+                        switch(aurEff->GetId())
+                        {
+                            case 51482: // Rank 3
+                                triggeredSpellId = 65264;
+                                break;
+                            case 51481: // Rank 2
+                                triggeredSpellId = 65263;
+                                break;
+                            case 51480: // Rank 1
+                                triggeredSpellId = 64694;
+                                break;
+                            default:
+                                sLog.outError("Aura::HandleAuraSpecificMods: Unknown rank of Lava Flows (%d) found", aurEff->GetId());
+                        }
+                    }
+                    if (triggeredSpellId)
+                        caster->CastSpell(caster, triggeredSpellId, true);
+                }
+            }
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasDueToSpellBySteal(uint32 spellId, uint64 casterGUID, Unit *stealer)
+{
+    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);)
+    {
+        Aura * aura = iter->second;
+        if (aura->GetCasterGUID() == casterGUID)
+        {
+            int32 damage[MAX_SPELL_EFFECTS];
+            int32 baseDamage[MAX_SPELL_EFFECTS];
+            uint8 effMask = 0;
+            uint8 recalculateMask = 0;
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                if (aura->GetEffect(i))
+                {
+                    baseDamage[i] = aura->GetEffect(i)->GetBaseAmount();
+                    damage[i] = aura->GetEffect(i)->GetAmount();
+                    effMask |= (1<<i);
+                    if (aura->GetEffect(i)->CanBeRecalculated())
+                        recalculateMask |= (1<<i);
+                }
+                else
+                {
+                    baseDamage[i] = NULL;
+                    damage[i] = NULL;
+                }
+            }
+
+            bool stealCharge = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
+
+            if (stealCharge)
+                aura->DropCharge();
+            else
+                RemoveAuraFromStack(iter, AURA_REMOVE_BY_ENEMY_SPELL);
+
+
+            if (Aura * newAura = stealCharge ? stealer->GetAura(aura->GetId(), aura->GetCasterGUID()) : NULL)
+            {
+                uint8 newCharges = newAura->GetCharges() + 1;
+                uint8 maxCharges = newAura->GetSpellProto()->procCharges;
+                // We must be able to steal as much charges as original caster can have
+                if (Unit * caster = newAura->GetCaster())
+                    if (Player* modOwner = caster->GetSpellModOwner())
+                        modOwner->ApplySpellMod(aura->GetId(), SPELLMOD_CHARGES, maxCharges);
+                newAura->SetCharges(maxCharges < newCharges ? maxCharges : newCharges);
+            }
+            else
+            {
+                int32 dur = (2*MINUTE*IN_MILLISECONDS < aura->GetDuration() || aura->GetDuration() < 0) ? 2*MINUTE*IN_MILLISECONDS : aura->GetDuration();
+
+                newAura = Aura::TryCreate(aura->GetSpellProto(), effMask, stealer, NULL, &baseDamage[0], NULL, aura->GetCasterGUID());
+                if (!newAura)
+                    return;
+                // strange but intended behaviour: Stolen single target auras won't be treated as single targeted
+                if (newAura->IsSingleTarget())
+                    newAura->UnregisterSingleTarget();
+                newAura->SetLoadedState(dur, dur, stealCharge ? 1 : aura->GetCharges(), aura->GetStackAmount(), recalculateMask, &damage[0]);
+                newAura->ApplyForTargets();
+            }
+            return;
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasDueToItemSpell(Item* castItem,uint32 spellId)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.lower_bound(spellId); iter != m_appliedAuras.upper_bound(spellId);)
+    {
+        if (!castItem || iter->second->GetBase()->GetCastItemGUID() == castItem->GetGUID())
+        {
+            RemoveAura(iter);
+            iter = m_appliedAuras.upper_bound(spellId);          // overwrite by more appropriate
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAurasByType(AuraType auraType, uint64 casterGUID, Aura * except, bool negative, bool positive)
+{
+    for (AuraEffectList::iterator iter = m_modAuras[auraType].begin(); iter != m_modAuras[auraType].end();)
+    {
+        Aura * aura = (*iter)->GetBase();
+        AuraApplication * aurApp = aura ->GetApplicationOfTarget(GetGUID());
+
+        ++iter;
+        if (aura != except && (!casterGUID || aura->GetCasterGUID() == casterGUID)
+            && ((negative && !aurApp->IsPositive()) || (positive && aurApp->IsPositive())))
+        {
+            uint32 removedAuras = m_removedAurasCount;
+            RemoveAura(aurApp);
+            if (m_removedAurasCount > removedAuras + 1)
+                iter = m_modAuras[auraType].begin();
+        }
+    }
+}
+
+void Unit::RemoveAurasWithAttribute(uint32 flags)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        SpellEntry const *spell = iter->second->GetBase()->GetSpellProto();
+        if (spell->Attributes & flags)
+            RemoveAura(iter);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveNotOwnSingleTargetAuras(uint32 newPhase)
+{
+    // single target auras from other casters
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        AuraApplication const * aurApp = iter->second;
+        Aura const * aura = aurApp->GetBase();
+
+        if (aura->GetCasterGUID() != GetGUID() && IsSingleTargetSpell(aura->GetSpellProto()))
+        {
+            if (!newPhase)
+                RemoveAura(iter);
+            else
+            {
+                Unit* caster = aura->GetCaster();
+                if (!caster || !caster->InSamePhase(newPhase))
+                    RemoveAura(iter);
+                else
+                    ++iter;
+            }
+        }
+        else
+            ++iter;
+    }
+
+    // single target auras at other targets
+    AuraList& scAuras = GetSingleCastAuras();
+    for (AuraList::iterator iter = scAuras.begin(); iter != scAuras.end();)
+    {
+        Aura * aura = *iter;
+        if (aura->GetUnitOwner() != this && !aura->GetUnitOwner()->InSamePhase(newPhase))
+        {
+            aura->Remove();
+            iter = scAuras.begin();
+        }
+        else
+            ++iter;
+    }
+}
+
+
+void Unit::RemoveAurasWithInterruptFlags(uint32 flag, uint32 except)
+{
+    if (!(m_interruptMask & flag))
+        return;
+
+    // interrupt auras
+    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end();)
+    {
+        Aura * aura = (*iter)->GetBase();
+        ++iter;
+        if ((aura->GetSpellProto()->AuraInterruptFlags & flag) && (!except || aura->GetId() != except))
+        {
+            uint32 removedAuras = m_removedAurasCount;
+            RemoveAura(aura);
+            if (m_removedAurasCount > removedAuras + 1)
+                iter = m_interruptableAuras.begin();
+        }
+    }
+
+    // interrupt channeled spell
+    if (Spell* spell = m_currentSpells[CURRENT_CHANNELED_SPELL])
+        if (spell->getState() == SPELL_STATE_CASTING
+            && (spell->m_spellInfo->ChannelInterruptFlags & flag)
+            && spell->m_spellInfo->Id != except)
+            InterruptNonMeleeSpells(false);
+
+    UpdateInterruptMask();
+}
+
+void Unit::RemoveAurasWithFamily(SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const * aura = iter->second->GetBase();
+        if (!casterGUID || aura->GetCasterGUID() == casterGUID)
+        {
+            SpellEntry const *spell = aura->GetSpellProto();
+            if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
+            {
+                RemoveAura(iter);
+                continue;
+            }
+        }
+        ++iter;
+    }
+}
+
+void Unit::RemoveMovementImpairingAuras()
+{
+    RemoveAurasWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT));
+}
+
+void Unit::RemoveAurasWithMechanic(uint32 mechanic_mask, AuraRemoveMode removemode, uint32 except)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const * aura = iter->second->GetBase();
+        if (!except || aura->GetId() != except)
+        {
+            if (GetAllSpellMechanicMask(aura->GetSpellProto()) & mechanic_mask)
+            {
+                RemoveAura(iter, removemode);
+                continue;
+            }
+        }
+        ++iter;
+    }
+}
+
+void Unit::RemoveAreaAurasDueToLeaveWorld()
+{
+    // make sure that all area auras not applied on self are removed - prevent access to deleted pointer later
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura * aura = iter->second;
+        ++iter;
+        Aura::ApplicationMap const & appMap = aura->GetApplicationMap();
+        for (Aura::ApplicationMap::const_iterator itr = appMap.begin(); itr!= appMap.end();)
+        {
+            AuraApplication * aurApp = itr->second;
+            ++itr;
+            Unit * target = aurApp->GetTarget();
+            if (target == this)
+                continue;
+            target->RemoveAura(aurApp);
+            // things linked on aura remove may apply new area aura - so start from the beginning
+            iter = m_ownedAuras.begin();
+        }
+    }
+
+    // remove area auras owned by others
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        if (iter->second->GetBase()->GetOwner() != this)
+        {
+            RemoveAura(iter);
+        }
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllAuras()
+{
+    // this may be a dead loop if some events on aura remove will continiously apply aura on remove
+    // we want to have all auras removed, so use your brain when linking events
+    while (!m_appliedAuras.empty() || !m_ownedAuras.empty())
+    {
+        AuraApplicationMap::iterator aurAppIter;
+        for (aurAppIter = m_appliedAuras.begin(); aurAppIter != m_appliedAuras.end();)
+            _UnapplyAura(aurAppIter, AURA_REMOVE_BY_DEFAULT);
+
+        AuraMap::iterator aurIter;
+        for (aurIter = m_ownedAuras.begin(); aurIter != m_ownedAuras.end();)
+            RemoveOwnedAura(aurIter);
+    }
+}
+
+void Unit::RemoveArenaAuras(bool onleave)
+{
+    // in join, remove positive buffs, on end, remove negative
+    // used to remove positive visible auras in arenas
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        AuraApplication const * aurApp = iter->second;
+        Aura const * aura = aurApp->GetBase();
+        if (!(aura->GetSpellProto()->AttributesEx4 & SPELL_ATTR_EX4_UNK21) // don't remove stances, shadowform, pally/hunter auras
+            && !aura->IsPassive()                               // don't remove passive auras
+            && (!(aura->GetSpellProto()->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY) || !(aura->GetSpellProto()->Attributes & SPELL_ATTR_UNK8))   // not unaffected by invulnerability auras or not having that unknown flag (that seemed the most probable)
+            && (aurApp->IsPositive() ^ onleave))                   // remove positive buffs on enter, negative buffs on leave
+            RemoveAura(iter);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllAurasOnDeath()
+{
+    // used just after dieing to remove all visible auras
+    // and disable the mods for the passive ones
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const * aura = iter->second->GetBase();
+        if (!aura->IsPassive() && !aura->IsDeathPersistent())
+            _UnapplyAura(iter, AURA_REMOVE_BY_DEATH);
+        else
+            ++iter;
+    }
+
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura * aura = iter->second;
+        if (!aura->IsPassive() && !aura->IsDeathPersistent())
+            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEATH);
+        else
+            ++iter;
+    }
+}
+
+void Unit::RemoveAllAurasRequiringDeadTarget()
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
+    {
+        Aura const * aura = iter->second->GetBase();
+        if (!aura->IsPassive() && IsRequiringDeadTargetSpell(aura->GetSpellProto()))
+            _UnapplyAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+
+    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
+    {
+        Aura * aura = iter->second;
+        if (!aura->IsPassive() && IsRequiringDeadTargetSpell(aura->GetSpellProto()))
+            RemoveOwnedAura(iter, AURA_REMOVE_BY_DEFAULT);
+        else
+            ++iter;
+    }
+}
+
+void Unit::DelayOwnedAuras(uint32 spellId, uint64 caster, int32 delaytime)
+{
+    for (AuraMap::iterator iter = m_ownedAuras.lower_bound(spellId); iter != m_ownedAuras.upper_bound(spellId);++iter)
+    {
+        Aura * aura = iter->second;
+        if (!caster || aura->GetCasterGUID() == caster)
+        {
+            if (aura->GetDuration() < delaytime)
+                aura->SetDuration(0);
+            else
+                aura->SetDuration(aura->GetDuration() - delaytime);
+
+            // update for out of range group members (on 1 slot use)
+            aura->SetNeedClientUpdateForTargets();
+            sLog.outDebug("Aura %u partially interrupted on unit %u, new duration: %u ms",aura->GetId() , GetGUIDLow(), aura->GetDuration());
+        }
+    }
+}
+
+void Unit::_RemoveAllAuraStatMods()
+{
+    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
+        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, false);
+}
+
+void Unit::_ApplyAllAuraStatMods()
+{
+    for (AuraApplicationMap::iterator i = m_appliedAuras.begin(); i != m_appliedAuras.end(); ++i)
+        (*i).second->GetBase()->HandleAllEffects(i->second, AURA_EFFECT_HANDLE_STAT, true);
+}
+
+AuraEffect * Unit::GetAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
+{
+    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
+        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
+            return itr->second->GetBase()->GetEffect(effIndex);
+    return NULL;
+}
+
+AuraEffect * Unit::GetAuraEffectOfRankedSpell(uint32 spellId, uint8 effIndex, uint64 caster) const
+{
+    uint32 rankSpell = sSpellMgr.GetFirstSpellInChain(spellId);
+    while (true)
+    {
+        if (AuraEffect * aurEff = GetAuraEffect(rankSpell, effIndex, caster))
+            return aurEff;
+        SpellChainNode const * chainNode = sSpellMgr.GetSpellChainNode(rankSpell);
+        if (!chainNode)
+            break;
+        else
+            rankSpell = chainNode->next;
+    }
+    return NULL;
+}
+
+AuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames name, uint32 iconId, uint8 effIndex) const
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(type);
+    for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        if (effIndex != (*itr)->GetEffIndex())
+            continue;
+        SpellEntry const * spell = (*itr)->GetSpellProto();
+        if (spell->SpellIconID == iconId && spell->SpellFamilyName == uint32(name) && !spell->SpellFamilyFlags)
+            return *itr;
+    }
+    return NULL;
+}
+
+AuraEffect* Unit::GetAuraEffect(AuraType type, SpellFamilyNames family, uint32 familyFlag1, uint32 familyFlag2, uint32 familyFlag3, uint64 casterGUID)
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(type);
+    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+    {
+        SpellEntry const *spell = (*i)->GetSpellProto();
+        if (spell->SpellFamilyName == uint32(family) && spell->SpellFamilyFlags.HasFlag(familyFlag1, familyFlag2, familyFlag3))
+        {
+            if (casterGUID && (*i)->GetCasterGUID() != casterGUID)
+                continue;
+            return (*i);
+        }
+    }
+    return NULL;
+}
+
+AuraApplication * Unit::GetAuraApplication(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraApplication * except) const
+{
+    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
+    {
+        Aura const * aura = itr->second->GetBase();
+        if (((aura->GetEffectMask() & reqEffMask) == reqEffMask) && (!casterGUID || aura->GetCasterGUID() == casterGUID) && (!except || except != itr->second))
+            return itr->second;
+    }
+    return NULL;
+}
+
+Aura * Unit::GetAura(uint32 spellId, uint64 casterGUID, uint8 reqEffMask) const
+{
+    AuraApplication * aurApp = GetAuraApplication(spellId, casterGUID, reqEffMask);
+    return aurApp ? aurApp->GetBase():NULL;
+}
+
+AuraApplication * Unit::GetAuraApplicationOfRankedSpel(uint32 spellId, uint64 casterGUID, uint8 reqEffMask, AuraApplication * except) const
+{
+    uint32 rankSpell = sSpellMgr.GetFirstSpellInChain(spellId);
+    while (true)
+    {
+        if (AuraApplication * aurApp = GetAuraApplication(rankSpell, casterGUID, reqEffMask, except))
+            return aurApp;
+        SpellChainNode const * chainNode = sSpellMgr.GetSpellChainNode(rankSpell);
+        if (!chainNode)
+            break;
+        else
+            rankSpell = chainNode->next;
+    }
+    return NULL;
+}
+
+Aura * Unit::GetAuraOfRankedSpell(uint32 spellId, uint64 casterGUID, uint8 reqEffMask) const
+{
+    AuraApplication * aurApp = GetAuraApplicationOfRankedSpel(spellId, casterGUID, reqEffMask);
+    return aurApp ? aurApp->GetBase() : NULL;
+}
+
+bool Unit::HasAuraEffect(uint32 spellId, uint8 effIndex, uint64 caster) const
+{
+    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.lower_bound(spellId); itr != m_appliedAuras.upper_bound(spellId); ++itr)
+        if (itr->second->HasEffect(effIndex) && (!caster || itr->second->GetBase()->GetCasterGUID() == caster))
+            return true;
+    return false;
+}
+
+bool Unit::HasAura(uint32 spellId, uint64 caster, uint8 reqEffMask) const
+{
+    if (GetAuraApplication(spellId, caster, reqEffMask))
+        return true;
+    return false;
+}
+
+bool Unit::HasAuraType(AuraType auraType) const
+{
+    return (!m_modAuras[auraType].empty());
+}
+
+bool Unit::HasAuraTypeWithMiscvalue(AuraType auratype, int32 miscvalue) const
+{
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if (miscvalue == (*i)->GetMiscValue())
+            return true;
+    return false;
+}
+
+bool Unit::HasAuraTypeWithAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
+{
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if ((*i)->IsAffectedOnSpell(affectedSpell))
+            return true;
+    return false;
+}
+
+bool Unit::HasAuraTypeWithValue(AuraType auratype, int32 value) const
+{
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if (value == (*i)->GetAmount())
+            return true;
+    return false;
+}
+
+bool Unit::HasNegativeAuraWithInterruptFlag(uint32 flag, uint64 guid)
+{
+    if (!(m_interruptMask & flag))
+        return false;
+    for (AuraApplicationList::iterator iter = m_interruptableAuras.begin(); iter != m_interruptableAuras.end(); ++iter)
+    {
+        if (!(*iter)->IsPositive() && (*iter)->GetBase()->GetSpellProto()->AuraInterruptFlags & flag && (!guid || (*iter)->GetBase()->GetCasterGUID() == guid))
+            return true;
+    }
+    return false;
+}
+
+bool Unit::HasNegativeAuraWithAttribute(uint32 flag, uint64 guid)
+{
+    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
+    {
+        Aura const *aura = iter->second->GetBase();
+        if (!iter->second->IsPositive() && aura->GetSpellProto()->Attributes & flag && (!guid || aura->GetCasterGUID() == guid))
+            return true;
+    }
+    return false;
+}
+
+AuraEffect * Unit::IsScriptOverriden(SpellEntry const * spell, int32 script) const
+{
+    AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == script)
+            if ((*i)->IsAffectedOnSpell(spell))
+                return (*i);
+    }
+    return NULL;
+}
+
+uint32 Unit::GetDiseasesByCaster(uint64 casterGUID, bool remove)
+{
+    static const AuraType diseaseAuraTypes[] =
+    {
+        SPELL_AURA_PERIODIC_DAMAGE, // Frost Fever and Blood Plague
+        SPELL_AURA_LINKED,          // Crypt Fever and Ebon Plague
+        SPELL_AURA_NONE
+    };
+
+    uint32 diseases=0;
+    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
+    {
+        for (AuraEffectList::iterator i = m_modAuras[*itr].begin(); i != m_modAuras[*itr].end();)
+        {
+            // Get auras with disease dispel type by caster
+            if ((*i)->GetSpellProto()->Dispel == DISPEL_DISEASE
+                && (*i)->GetCasterGUID() == casterGUID)
+            {
+                ++diseases;
+
+                if (remove)
+                {
+                    RemoveAura((*i)->GetId(), (*i)->GetCasterGUID());
+                    i = m_modAuras[*itr].begin();
+                    continue;
+                }
+            }
+            ++i;
+        }
+    }
+    return diseases;
+}
+
+uint32 Unit::GetDoTsByCaster(uint64 casterGUID) const
+{
+    static const AuraType diseaseAuraTypes[] =
+    {
+        SPELL_AURA_PERIODIC_DAMAGE,
+        SPELL_AURA_PERIODIC_DAMAGE_PERCENT,
+        SPELL_AURA_NONE
+    };
+
+    uint32 dots=0;
+    for (AuraType const* itr = &diseaseAuraTypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
+    {
+        Unit::AuraEffectList const& auras = GetAuraEffectsByType(*itr);
+        for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+        {
+            // Get auras by caster
+            if ((*i)->GetCasterGUID() == casterGUID)
+                ++dots;
+        }
+    }
+    return dots;
+}
+
+int32 Unit::GetTotalAuraModifier(AuraType auratype) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        modifier += (*i)->GetAmount();
+
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplier(AuraType auratype) const
+{
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
+
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifier(AuraType auratype)
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifier(AuraType auratype) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if ((*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+
+    return modifier;
+}
+
+int32 Unit::GetTotalAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue()& misc_mask)
+            modifier += (*i)->GetAmount();
+    }
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplierByMiscMask(AuraType auratype, uint32 misc_mask) const
+{
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue()& misc_mask)
+            multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
+    }
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifierByMiscMask(AuraType auratype, uint32 misc_mask) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue()& misc_mask && (*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetTotalAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value)
+            modifier += (*i)->GetAmount();
+    }
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value)
+            multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
+    }
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifierByMiscValue(AuraType auratype, int32 misc_value) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->GetMiscValue() == misc_value && (*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetTotalAuraModifierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectedOnSpell(affectedSpell))
+            modifier += (*i)->GetAmount();
+    }
+    return modifier;
+}
+
+float Unit::GetTotalAuraMultiplierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
+{
+    float multiplier = 1.0f;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectedOnSpell(affectedSpell))
+            multiplier *= (100.0f + (*i)->GetAmount())/100.0f;
+    }
+    return multiplier;
+}
+
+int32 Unit::GetMaxPositiveAuraModifierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectedOnSpell(affectedSpell) && (*i)->GetAmount() > modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+int32 Unit::GetMaxNegativeAuraModifierByAffectMask(AuraType auratype, SpellEntry const * affectedSpell) const
+{
+    int32 modifier = 0;
+
+    AuraEffectList const& mTotalAuraList = GetAuraEffectsByType(auratype);
+    for (AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+    {
+        if ((*i)->IsAffectedOnSpell(affectedSpell) && (*i)->GetAmount() < modifier)
+            modifier = (*i)->GetAmount();
+    }
+
+    return modifier;
+}
+
+void Unit::AddDynObject(DynamicObject* dynObj)
+{
+    m_dynObjGUIDs.push_back(dynObj->GetGUID());
+}
+
+void Unit::RemoveDynObject(uint32 spellid)
+{
+    if (m_dynObjGUIDs.empty())
+        return;
+    for (DynObjectGUIDs::iterator i = m_dynObjGUIDs.begin(); i != m_dynObjGUIDs.end();)
+    {
+        DynamicObject* dynObj = GetMap()->GetDynamicObject(*i);
+        if (!dynObj) // may happen if a dynobj is removed when grid unload
+            i = m_dynObjGUIDs.erase(i);
+        else if (spellid == 0 || dynObj->GetSpellId() == spellid)
+        {
+            dynObj->Delete();
+            i = m_dynObjGUIDs.erase(i);
+        }
+        else
+            ++i;
+    }
+}
+
+void Unit::RemoveAllDynObjects()
+{
+    while (!m_dynObjGUIDs.empty())
+    {
+        DynamicObject* dynObj = GetMap()->GetDynamicObject(*m_dynObjGUIDs.begin());
+        if (dynObj)
+            dynObj->Delete();
+        m_dynObjGUIDs.erase(m_dynObjGUIDs.begin());
+    }
+}
+
+DynamicObject * Unit::GetDynObject(uint32 spellId)
+{
+    for (DynObjectGUIDs::iterator i = m_dynObjGUIDs.begin(); i != m_dynObjGUIDs.end();)
+    {
+        DynamicObject* dynObj = GetMap()->GetDynamicObject(*i);
+        if (!dynObj)
+        {
+            i = m_dynObjGUIDs.erase(i);
+            continue;
+        }
+
+        if (dynObj->GetSpellId() == spellId)
+            return dynObj;
+        ++i;
+    }
+    return NULL;
+}
+
+GameObject* Unit::GetGameObject(uint32 spellId) const
+{
+    for (GameObjectList::const_iterator i = m_gameObj.begin(); i != m_gameObj.end(); ++i)
+        if ((*i)->GetSpellId() == spellId)
+            return *i;
+
+    return NULL;
+}
+
+void Unit::AddGameObject(GameObject* gameObj)
+{
+    if (!gameObj || !gameObj->GetOwnerGUID() == 0) return;
+    m_gameObj.push_back(gameObj);
+    gameObj->SetOwnerGUID(GetGUID());
+
+    if (GetTypeId() == TYPEID_PLAYER && gameObj->GetSpellId())
+    {
+        SpellEntry const* createBySpell = sSpellStore.LookupEntry(gameObj->GetSpellId());
+        // Need disable spell use for owner
+        if (createBySpell && createBySpell->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
+            // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
+            this->ToPlayer()->AddSpellAndCategoryCooldowns(createBySpell,0,NULL,true);
+    }
+}
+
+void Unit::RemoveGameObject(GameObject* gameObj, bool del)
+{
+    if (!gameObj || !gameObj->GetOwnerGUID() == GetGUID()) return;
+
+    gameObj->SetOwnerGUID(0);
+
+    for (uint32 i = 0; i < 4; ++i)
+    {
+        if (m_ObjectSlot[i] == gameObj->GetGUID())
+        {
+            m_ObjectSlot[i] = 0;
+            break;
+        }
+    }
+
+    // GO created by some spell
+    if (uint32 spellid = gameObj->GetSpellId())
+    {
+        RemoveAurasDueToSpell(spellid);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            SpellEntry const* createBySpell = sSpellStore.LookupEntry(spellid);
+            // Need activate spell use for owner
+            if (createBySpell && createBySpell->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE)
+                // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
+                this->ToPlayer()->SendCooldownEvent(createBySpell);
+        }
+    }
+
+    m_gameObj.remove(gameObj);
+
+    if (del)
+    {
+        gameObj->SetRespawnTime(0);
+        gameObj->Delete();
+    }
+}
+
+void Unit::RemoveGameObject(uint32 spellid, bool del)
+{
+    if (m_gameObj.empty())
+        return;
+    GameObjectList::iterator i, next;
+    for (i = m_gameObj.begin(); i != m_gameObj.end(); i = next)
+    {
+        next = i;
+        if (spellid == 0 || (*i)->GetSpellId() == spellid)
+        {
+            (*i)->SetOwnerGUID(0);
+            if (del)
+            {
+                (*i)->SetRespawnTime(0);
+                (*i)->Delete();
+            }
+
+            next = m_gameObj.erase(i);
+        }
+        else
+            ++next;
+    }
+}
+
+void Unit::RemoveAllGameObjects()
+{
+    // remove references to unit
+    for (GameObjectList::iterator i = m_gameObj.begin(); i != m_gameObj.end();)
+    {
+        (*i)->SetOwnerGUID(0);
+        (*i)->SetRespawnTime(0);
+        (*i)->Delete();
+        i = m_gameObj.erase(i);
+    }
+}
+
+void Unit::SendSpellNonMeleeDamageLog(SpellNonMeleeDamage *log)
+{
+    WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG, (16+4+4+4+1+4+4+1+1+4+4+1)); // we guess size
+    data.append(log->target->GetPackGUID());
+    data.append(log->attacker->GetPackGUID());
+    data << uint32(log->SpellID);
+    data << uint32(log->damage);                            // damage amount
+    int32 overkill = log->damage - log->target->GetHealth();
+    data << uint32(overkill > 0 ? overkill : 0);            // overkill
+    data << uint8 (log->schoolMask);                        // damage school
+    data << uint32(log->absorb);                            // AbsorbedDamage
+    data << uint32(log->resist);                            // resist
+    data << uint8 (log->physicalLog);                       // if 1, then client show spell name (example: %s's ranged shot hit %s for %u school or %s suffers %u school damage from %s's spell_name
+    data << uint8 (log->unused);                            // unused
+    data << uint32(log->blocked);                           // blocked
+    data << uint32(log->HitInfo);
+    data << uint8 (0);                                      // flag to use extend data
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendSpellNonMeleeDamageLog(Unit *target, uint32 SpellID, uint32 Damage, SpellSchoolMask damageSchoolMask, uint32 AbsorbedDamage, uint32 Resist, bool PhysicalDamage, uint32 Blocked, bool CriticalHit)
+{
+    SpellNonMeleeDamage log(this, target, SpellID, damageSchoolMask);
+    log.damage = Damage - AbsorbedDamage - Resist - Blocked;
+    log.absorb = AbsorbedDamage;
+    log.resist = Resist;
+    log.physicalLog = PhysicalDamage;
+    log.blocked = Blocked;
+    log.HitInfo = SPELL_HIT_TYPE_UNK1 | SPELL_HIT_TYPE_UNK3 | SPELL_HIT_TYPE_UNK6;
+    if (CriticalHit)
+        log.HitInfo |= SPELL_HIT_TYPE_CRIT;
+    SendSpellNonMeleeDamageLog(&log);
+}
+
+void Unit::ProcDamageAndSpell(Unit *pVictim, uint32 procAttacker, uint32 procVictim, uint32 procExtra, uint32 amount, WeaponAttackType attType, SpellEntry const *procSpell, SpellEntry const * procAura)
+{
+     // Not much to do if no flags are set.
+    if (procAttacker)
+        ProcDamageAndSpellFor(false, pVictim,procAttacker, procExtra,attType, procSpell, amount, procAura);
+    // Now go on with a victim's events'n'auras
+    // Not much to do if no flags are set or there is no victim
+    if (pVictim && pVictim->isAlive() && procVictim)
+        pVictim->ProcDamageAndSpellFor(true, this, procVictim, procExtra, attType, procSpell, amount, procAura);
+}
+
+void Unit::SendPeriodicAuraLog(SpellPeriodicAuraLogInfo *pInfo)
+{
+    AuraEffect const * aura = pInfo->auraEff;
+
+    WorldPacket data(SMSG_PERIODICAURALOG, 30);
+    data.append(GetPackGUID());
+    data.appendPackGUID(aura->GetCasterGUID());
+    data << uint32(aura->GetId());                          // spellId
+    data << uint32(1);                                      // count
+    data << uint32(aura->GetAuraType());                    // auraId
+    switch(aura->GetAuraType())
+    {
+        case SPELL_AURA_PERIODIC_DAMAGE:
+        case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
+            data << uint32(pInfo->damage);                  // damage
+            data << uint32(pInfo->overDamage);              // overkill?
+            data << uint32(GetSpellSchoolMask(aura->GetSpellProto()));
+            data << uint32(pInfo->absorb);                  // absorb
+            data << uint32(pInfo->resist);                  // resist
+            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick
+            break;
+        case SPELL_AURA_PERIODIC_HEAL:
+        case SPELL_AURA_OBS_MOD_HEALTH:
+            data << uint32(pInfo->damage);                  // damage
+            data << uint32(pInfo->overDamage);              // overheal
+            data << uint32(pInfo->absorb);                  // absorb
+            data << uint8(pInfo->critical);                 // new 3.1.2 critical tick
+            break;
+        case SPELL_AURA_OBS_MOD_POWER:
+        case SPELL_AURA_PERIODIC_ENERGIZE:
+            data << uint32(aura->GetMiscValue());           // power type
+            data << uint32(pInfo->damage);                  // damage
+            break;
+        case SPELL_AURA_PERIODIC_MANA_LEECH:
+            data << uint32(aura->GetMiscValue());           // power type
+            data << uint32(pInfo->damage);                  // amount
+            data << float(pInfo->multiplier);               // gain multiplier
+            break;
+        default:
+            sLog.outError("Unit::SendPeriodicAuraLog: unknown aura %u", uint32(aura->GetAuraType()));
+            return;
+    }
+
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendSpellMiss(Unit *target, uint32 spellID, SpellMissInfo missInfo)
+{
+    WorldPacket data(SMSG_SPELLLOGMISS, (4+8+1+4+8+1));
+    data << uint32(spellID);
+    data << uint64(GetGUID());
+    data << uint8(0);                                       // can be 0 or 1
+    data << uint32(1);                                      // target count
+    // for (i = 0; i < target count; ++i)
+    data << uint64(target->GetGUID());                      // target GUID
+    data << uint8(missInfo);
+    // end loop
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendSpellDamageImmune(Unit * target, uint32 spellId)
+{
+    WorldPacket data(SMSG_SPELLORDAMAGE_IMMUNE, 8+8+4+1);
+    data << uint64(GetGUID());
+    data << uint64(target->GetGUID());
+    data << uint32(spellId);
+    data << uint8(0); // bool - log format: 0-default, 1-debug
+    SendMessageToSet(&data,true);
+}
+
+void Unit::SendAttackStateUpdate(CalcDamageInfo *damageInfo)
+{
+    sLog.outDebug("WORLD: Sending SMSG_ATTACKERSTATEUPDATE");
+
+    uint32 count = 1;
+    size_t maxsize = 4+5+5+4+4+1+4+4+4+4+4+1+4+4+4+4+4*12;
+    WorldPacket data(SMSG_ATTACKERSTATEUPDATE, maxsize);    // we guess size
+    data << uint32(damageInfo->HitInfo);
+    data.append(damageInfo->attacker->GetPackGUID());
+    data.append(damageInfo->target->GetPackGUID());
+    data << uint32(damageInfo->damage);                     // Full damage
+    int32 overkill = damageInfo->damage - damageInfo->target->GetHealth();
+    data << uint32(overkill < 0 ? 0 : overkill);            // Overkill
+    data << uint8(count);                                   // Sub damage count
+
+    for (uint32 i = 0; i < count; ++i)
+    {
+        data << uint32(damageInfo->damageSchoolMask);       // School of sub damage
+        data << float(damageInfo->damage);                  // sub damage
+        data << uint32(damageInfo->damage);                 // Sub Damage
+    }
+
+    if (damageInfo->HitInfo & (HITINFO_ABSORB | HITINFO_ABSORB2))
+    {
+        for (uint32 i = 0; i < count; ++i)
+            data << uint32(damageInfo->absorb);             // Absorb
+    }
+
+    if (damageInfo->HitInfo & (HITINFO_RESIST | HITINFO_RESIST2))
+    {
+        for (uint32 i = 0; i < count; ++i)
+            data << uint32(damageInfo->resist);             // Resist
+    }
+
+    data << uint8(damageInfo->TargetState);
+    data << uint32(0);
+    data << uint32(0);
+
+    if (damageInfo->HitInfo & HITINFO_BLOCK)
+        data << uint32(damageInfo->blocked_amount);
+
+    if (damageInfo->HitInfo & HITINFO_UNK3)
+        data << uint32(0);
+
+    if (damageInfo->HitInfo & HITINFO_UNK1)
+    {
+        data << uint32(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);
+        data << float(0);       // Found in a loop with 1 iteration
+        data << float(0);       // ditto ^
+        data << uint32(0);
+    }
+
+    SendMessageToSet(&data, true);
+}
+
+void Unit::SendAttackStateUpdate(uint32 HitInfo, Unit *target, uint8 /*SwingType*/, SpellSchoolMask damageSchoolMask, uint32 Damage, uint32 AbsorbDamage, uint32 Resist, VictimState TargetState, uint32 BlockedAmount)
+{
+    CalcDamageInfo dmgInfo;
+    dmgInfo.HitInfo = HitInfo;
+    dmgInfo.attacker = this;
+    dmgInfo.target = target;
+    dmgInfo.damage = Damage - AbsorbDamage - Resist - BlockedAmount;
+    dmgInfo.damageSchoolMask = damageSchoolMask;
+    dmgInfo.absorb = AbsorbDamage;
+    dmgInfo.resist = Resist;
+    dmgInfo.TargetState = TargetState;
+    dmgInfo.blocked_amount = BlockedAmount;
+    SendAttackStateUpdate(&dmgInfo);
+}
+
+bool Unit::HandleHasteAuraProc(Unit *pVictim, uint32 damage, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
+{
+    SpellEntry const *hasteSpell = triggeredByAura->GetSpellProto();
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+    Unit* target = pVictim;
+    int32 basepoints0 = 0;
+
+    switch(hasteSpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_ROGUE:
+        {
+            switch(hasteSpell->Id)
+            {
+                // Blade Flurry
+                case 13877:
+                case 33735:
+                {
+                    target = SelectNearbyTarget();
+                    if (!target || target == pVictim)
+                        return false;
+                    basepoints0 = damage;
+                    triggered_spell_id = 22482;
+                    break;
+                }
+            }
+            break;
+        }
+    }
+
+    // processed charge only counting case
+    if (!triggered_spell_id)
+        return true;
+
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!triggerEntry)
+    {
+        sLog.outError("Unit::HandleHasteAuraProc: Spell %u have not existed triggered spell %u",hasteSpell->Id,triggered_spell_id);
+        return false;
+    }
+
+    // default case
+    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
+        return false;
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
+        return false;
+
+    if (basepoints0)
+        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+    else
+        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
+
+    return true;
+}
+
+bool Unit::HandleSpellCritChanceAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
+{
+    SpellEntry const *triggeredByAuraSpell = triggeredByAura->GetSpellProto();
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+    Unit* target = pVictim;
+    int32 basepoints0 = 0;
+
+    switch(triggeredByAuraSpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_MAGE:
+        {
+            switch(triggeredByAuraSpell->Id)
+            {
+                // Focus Magic
+                case 54646:
+                {
+                    Unit* caster = triggeredByAura->GetCaster();
+                    if (!caster)
+                        return false;
+
+                    triggered_spell_id = 54648;
+                    target = caster;
+                    break;
+                }
+            }
+        }
+    }
+
+    // processed charge only counting case
+    if (!triggered_spell_id)
+        return true;
+
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!triggerEntry)
+    {
+        sLog.outError("Unit::HandleHasteAuraProc: Spell %u have not existed triggered spell %u",triggeredByAuraSpell->Id,triggered_spell_id);
+        return false;
+    }
+
+    // default case
+    if (!target || (target != this && !target->isAlive()))
+        return false;
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
+        return false;
+
+    if (basepoints0)
+        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+    else
+        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
+
+    return true;
+}
+
+bool Unit::HandleDummyAuraProc(Unit *pVictim, uint32 damage, AuraEffect* triggeredByAura, SpellEntry const * procSpell, uint32 procFlag, uint32 procEx, uint32 cooldown)
+{
+    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto();
+    uint32 effIndex = triggeredByAura->GetEffIndex();
+    int32  triggerAmount = triggeredByAura->GetAmount();
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+    uint32 cooldown_spell_id = 0; // for random trigger, will be one of the triggered spell to avoid repeatable triggers
+                                  // otherwise, it's the triggered_spell_id by default
+    Unit* target = pVictim;
+    int32 basepoints0 = 0;
+    uint64 originalCaster = 0;
+
+    switch(dummySpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch (dummySpell->Id)
+            {
+                // Bloodworms Health Leech
+                case 50453:
+                {
+                    if (Unit *owner = this->GetOwner())
+                    {
+                        basepoints0 = int32(damage*1.50);
+                        target = owner;
+                        triggered_spell_id = 50454;
+                        break;
+                    }
+                    return false;
+                }
+                // Eye for an Eye
+                case 9799:
+                case 25988:
+                {
+                    // return damage % to attacker but < 50% own total health
+                    basepoints0 = int32((triggerAmount * damage) /100);
+
+                    int32 halfMaxHealth = int32(CountPctFromMaxHealth(50));
+                    if (basepoints0 > halfMaxHealth)
+                        basepoints0 = halfMaxHealth;
+
+                    sLog.outDebug("DEBUG LINE: Data about Eye for an Eye ID %u, damage taken %u, unit max health %u, damage done %u", dummySpell->Id, damage, GetMaxHealth(), basepoints0);
+
+                    triggered_spell_id = 25997;
+
+                    break;
+                }
+                // Sweeping Strikes
+                case 18765:
+                case 35429:
+                {
+                    target = SelectNearbyTarget();
+                    if (!target)
+                        return false;
+
+                    triggered_spell_id = 26654;
+                    break;
+                }
+                // Unstable Power
+                case 24658:
+                {
+                    if (!procSpell || procSpell->Id == 24659)
+                        return false;
+                    // Need remove one 24659 aura
+                    RemoveAuraFromStack(24659);
+                    return true;
+                }
+                // Restless Strength
+                case 24661:
+                {
+                    // Need remove one 24662 aura
+                    RemoveAuraFromStack(24662);
+                    return true;
+                }
+                // Adaptive Warding (Frostfire Regalia set)
+                case 28764:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    // find Mage Armor
+                    if (!GetAuraEffect(SPELL_AURA_MOD_MANA_REGEN_INTERRUPT, SPELLFAMILY_MAGE, 0x10000000, 0, 0))
+                        return false;
+
+                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
+                    {
+                        case SPELL_SCHOOL_NORMAL:
+                        case SPELL_SCHOOL_HOLY:
+                            return false;                   // ignored
+                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 28765; break;
+                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 28768; break;
+                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 28766; break;
+                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 28769; break;
+                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 28770; break;
+                        default:
+                            return false;
+                    }
+
+                    target = this;
+                    break;
+                }
+                // Obsidian Armor (Justice Bearer`s Pauldrons shoulder)
+                case 27539:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
+                    {
+                        case SPELL_SCHOOL_NORMAL:
+                            return false;                   // ignore
+                        case SPELL_SCHOOL_HOLY:   triggered_spell_id = 27536; break;
+                        case SPELL_SCHOOL_FIRE:   triggered_spell_id = 27533; break;
+                        case SPELL_SCHOOL_NATURE: triggered_spell_id = 27538; break;
+                        case SPELL_SCHOOL_FROST:  triggered_spell_id = 27534; break;
+                        case SPELL_SCHOOL_SHADOW: triggered_spell_id = 27535; break;
+                        case SPELL_SCHOOL_ARCANE: triggered_spell_id = 27540; break;
+                        default:
+                            return false;
+                    }
+
+                    target = this;
+                    break;
+                }
+                // Mana Leech (Passive) (Priest Pet Aura)
+                case 28305:
+                {
+                    // Cast on owner
+                    target = GetOwner();
+                    if (!target)
+                        return false;
+
+                    triggered_spell_id = 34650;
+                    break;
+                }
+                // Spirit Walk
+                case 58875:
+                {
+                    // Cast on owner
+                    target = GetOwner();
+                    if (!target)
+                        return false;
+
+                    triggered_spell_id = 58876;
+                    break;
+                }
+                // Mark of Malice
+                case 33493:
+                {
+                    // Cast finish spell at last charge
+                    if (triggeredByAura->GetBase()->GetCharges() > 1)
+                        return false;
+
+                    target = this;
+                    triggered_spell_id = 33494;
+                    break;
+                }
+                // Twisted Reflection (boss spell)
+                case 21063:
+                    triggered_spell_id = 21064;
+                    break;
+                // Vampiric Aura (boss spell)
+                case 38196:
+                {
+                    basepoints0 = 3 * damage;               // 300%
+                    if (basepoints0 < 0)
+                        return false;
+
+                    triggered_spell_id = 31285;
+                    target = this;
+                    break;
+                }
+                // Aura of Madness (Darkmoon Card: Madness trinket)
+                //=====================================================
+                // 39511 Sociopath: +35 strength (Paladin, Rogue, Druid, Warrior)
+                // 40997 Delusional: +70 attack power (Rogue, Hunter, Paladin, Warrior, Druid)
+                // 40998 Kleptomania: +35 agility (Warrior, Rogue, Paladin, Hunter, Druid)
+                // 40999 Megalomania: +41 damage/healing (Druid, Shaman, Priest, Warlock, Mage, Paladin)
+                // 41002 Paranoia: +35 spell/melee/ranged crit strike rating (All classes)
+                // 41005 Manic: +35 haste (spell, melee and ranged) (All classes)
+                // 41009 Narcissism: +35 intellect (Druid, Shaman, Priest, Warlock, Mage, Paladin, Hunter)
+                // 41011 Martyr Complex: +35 stamina (All classes)
+                // 41406 Dementia: Every 5 seconds either gives you +5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
+                // 41409 Dementia: Every 5 seconds either gives you -5% damage/healing. (Druid, Shaman, Priest, Warlock, Mage, Paladin)
+                case 39446:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER || !this->isAlive())
+                        return false;
+
+                    // Select class defined buff
+                    switch (getClass())
+                    {
+                        case CLASS_PALADIN:                 // 39511,40997,40998,40999,41002,41005,41009,41011,41409
+                        case CLASS_DRUID:                   // 39511,40997,40998,40999,41002,41005,41009,41011,41409
+                            triggered_spell_id = RAND(39511,40997,40998,40999,41002,41005,41009,41011,41409);
+                            cooldown_spell_id = 39511;
+                            break;
+                        case CLASS_ROGUE:                   // 39511,40997,40998,41002,41005,41011
+                        case CLASS_WARRIOR:                 // 39511,40997,40998,41002,41005,41011
+                            triggered_spell_id = RAND(39511,40997,40998,41002,41005,41011);
+                            cooldown_spell_id = 39511;
+                            break;
+                        case CLASS_PRIEST:                  // 40999,41002,41005,41009,41011,41406,41409
+                        case CLASS_SHAMAN:                  // 40999,41002,41005,41009,41011,41406,41409
+                        case CLASS_MAGE:                    // 40999,41002,41005,41009,41011,41406,41409
+                        case CLASS_WARLOCK:                 // 40999,41002,41005,41009,41011,41406,41409
+                            triggered_spell_id = RAND(40999,41002,41005,41009,41011,41406,41409);
+                            cooldown_spell_id = 40999;
+                            break;
+                        case CLASS_HUNTER:                  // 40997,40999,41002,41005,41009,41011,41406,41409
+                            triggered_spell_id = RAND(40997,40999,41002,41005,41009,41011,41406,41409);
+                            cooldown_spell_id = 40997;
+                            break;
+                        default:
+                            return false;
+                    }
+
+                    target = this;
+                    if (roll_chance_i(10))
+                        this->ToPlayer()->Say("This is Madness!", LANG_UNIVERSAL);
+                    break;
+                }
+                // Sunwell Exalted Caster Neck (??? neck)
+                // cast ??? Light's Wrath if Exalted by Aldor
+                // cast ??? Arcane Bolt if Exalted by Scryers
+                case 46569:
+                    return false;                           // old unused version
+                // Sunwell Exalted Caster Neck (Shattered Sun Pendant of Acumen neck)
+                // cast 45479 Light's Wrath if Exalted by Aldor
+                // cast 45429 Arcane Bolt if Exalted by Scryers
+                case 45481:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45479;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        // triggered at positive/self casts also, current attack target used then
+                        if (IsFriendlyTo(target))
+                        {
+                            target = getVictim();
+                            if (!target)
+                            {
+                                uint64 selected_guid = ToPlayer()->GetSelection();
+                                target = ObjectAccessor::GetUnit(*this,selected_guid);
+                                if (!target)
+                                    return false;
+                            }
+                            if (IsFriendlyTo(target))
+                                return false;
+                        }
+
+                        triggered_spell_id = 45429;
+                        break;
+                    }
+                    return false;
+                }
+                // Sunwell Exalted Melee Neck (Shattered Sun Pendant of Might neck)
+                // cast 45480 Light's Strength if Exalted by Aldor
+                // cast 45428 Arcane Strike if Exalted by Scryers
+                case 45482:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45480;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        triggered_spell_id = 45428;
+                        break;
+                    }
+                    return false;
+                }
+                // Sunwell Exalted Tank Neck (Shattered Sun Pendant of Resolve neck)
+                // cast 45431 Arcane Insight if Exalted by Aldor
+                // cast 45432 Light's Ward if Exalted by Scryers
+                case 45483:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45432;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45431;
+                        break;
+                    }
+                    return false;
+                }
+                // Sunwell Exalted Healer Neck (Shattered Sun Pendant of Restoration neck)
+                // cast 45478 Light's Salvation if Exalted by Aldor
+                // cast 45430 Arcane Surge if Exalted by Scryers
+                case 45484:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    // Get Aldor reputation rank
+                    if (ToPlayer()->GetReputationRank(932) == REP_EXALTED)
+                    {
+                        target = this;
+                        triggered_spell_id = 45478;
+                        break;
+                    }
+                    // Get Scryers reputation rank
+                    if (ToPlayer()->GetReputationRank(934) == REP_EXALTED)
+                    {
+                        triggered_spell_id = 45430;
+                        break;
+                    }
+                    return false;
+                }
+                // Living Seed
+                case 48504:
+                {
+                    triggered_spell_id = 48503;
+                    basepoints0 = triggerAmount;
+                    target = this;
+                    break;
+                }
+                // Kill command
+                case 58914:
+                {
+                    // Remove aura stack from pet
+                    RemoveAuraFromStack(58914);
+                    Unit* owner = GetOwner();
+                    if (!owner)
+                        return true;
+                    // reduce the owner's aura stack
+                    owner->RemoveAuraFromStack(34027);
+                    return true;
+                }
+                // Vampiric Touch (generic, used by some boss)
+                case 52723:
+                case 60501:
+                {
+                    triggered_spell_id = 52724;
+                    basepoints0 = damage / 2;
+                    target = this;
+                    break;
+                }
+                // Shadowfiend Death (Gain mana if pet dies with Glyph of Shadowfiend)
+                case 57989:
+                {
+                    Unit *owner = GetOwner();
+                    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+                        return false;
+                    // Glyph of Shadowfiend (need cast as self cast for owner, no hidden cooldown)
+                    owner->CastSpell(owner,58227,true,castItem,triggeredByAura);
+                    return true;
+                }
+                // Divine purpose
+                case 31871:
+                case 31872:
+                {
+                    // Roll chane
+                    if (!pVictim || !pVictim->isAlive() || !roll_chance_i(triggerAmount))
+                        return false;
+
+                    // Remove any stun effect on target
+                    pVictim->RemoveAurasWithMechanic(1<<MECHANIC_STUN, AURA_REMOVE_BY_ENEMY_SPELL);
+                    return true;
+                }
+                // Glyph of Life Tap
+                case 63320:
+                {
+                    triggered_spell_id = 63321; // Life Tap
+                    break;
+                }
+                case 71519: // Deathbringer's Will Normal
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    std::vector<uint32> RandomSpells;
+                    switch (getClass())
+                    {
+                        case CLASS_WARRIOR:
+                        case CLASS_PALADIN:
+                        case CLASS_DEATH_KNIGHT:
+                            RandomSpells.push_back(71484);
+                            RandomSpells.push_back(71491);
+                            RandomSpells.push_back(71492);
+                            break;
+                        case CLASS_SHAMAN:
+                        case CLASS_ROGUE:
+                            RandomSpells.push_back(71486);
+                            RandomSpells.push_back(71485);
+                            RandomSpells.push_back(71492);
+                            break;
+                        case CLASS_DRUID:
+                            RandomSpells.push_back(71484);
+                            RandomSpells.push_back(71485);
+                            RandomSpells.push_back(71486);
+                            break;
+                        case CLASS_HUNTER:
+                            RandomSpells.push_back(71486);
+                            RandomSpells.push_back(71491);
+                            RandomSpells.push_back(71485);
+                            break;
+                        default:
+                            return false;
+                    }
+                    if (RandomSpells.empty()) //shouldn't happen
+                        return false;
+
+                    uint8 rand_spell = irand(0,(RandomSpells.size() - 1));
+                    CastSpell(target,RandomSpells[rand_spell],true,castItem,triggeredByAura, originalCaster);
+                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)
+                    {
+                        if (!ToPlayer()->HasSpellCooldown(*itr))
+                            ToPlayer()->AddSpellCooldown(*itr,0,time(NULL) + cooldown);
+                    }
+                    break;
+                }
+                case 71562: // Deathbringer's Will Heroic
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    std::vector<uint32> RandomSpells;
+                    switch (getClass())
+                    {
+                        case CLASS_WARRIOR:
+                        case CLASS_PALADIN:
+                        case CLASS_DEATH_KNIGHT:
+                            RandomSpells.push_back(71561);
+                            RandomSpells.push_back(71559);
+                            RandomSpells.push_back(71560);
+                            break;
+                        case CLASS_SHAMAN:
+                        case CLASS_ROGUE:
+                            RandomSpells.push_back(71558);
+                            RandomSpells.push_back(71556);
+                            RandomSpells.push_back(71560);
+                            break;
+                        case CLASS_DRUID:
+                            RandomSpells.push_back(71561);
+                            RandomSpells.push_back(71556);
+                            RandomSpells.push_back(71558);
+                            break;
+                        case CLASS_HUNTER:
+                            RandomSpells.push_back(71558);
+                            RandomSpells.push_back(71559);
+                            RandomSpells.push_back(71556);
+                            break;
+                        default:
+                            return false;
+                    }
+                    if (RandomSpells.empty()) //shouldn't happen
+                        return false;
+
+                    uint8 rand_spell = irand(0,(RandomSpells.size() - 1));
+                    CastSpell(target,RandomSpells[rand_spell],true,castItem,triggeredByAura, originalCaster);
+                    for (std::vector<uint32>::iterator itr = RandomSpells.begin(); itr != RandomSpells.end(); ++itr)
+                    {
+                        if (!ToPlayer()->HasSpellCooldown(*itr))
+                            ToPlayer()->AddSpellCooldown(*itr,0,time(NULL) + cooldown);
+                    }
+                    break;
+                }
+                // Item - Shadowmourne Legendary
+                case 71903:
+                {
+                    if (!pVictim || !pVictim->isAlive() || HasAura(73422))  // cant collect shards while under effect of Chaos Bane buff
+                        return false;
+
+                    CastSpell(this, 71905, true, NULL, triggeredByAura);
+
+                    // this can't be handled in AuraScript because we need to know pVictim
+                    Aura const* dummy = GetAura(71905);
+                    if (!dummy || dummy->GetStackAmount() < 10)
+                        return false;
+
+                    RemoveAurasDueToSpell(71905);
+                    triggered_spell_id = 71904;
+                    target = pVictim;
+                    break;
+                }
+                // Shadow's Fate (Shadowmourne questline)
+                case 71169:
+                {
+                    triggered_spell_id = 71203;
+                    target = triggeredByAura->GetCaster();
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_MAGE:
+        {
+            // Magic Absorption
+            if (dummySpell->SpellIconID == 459)             // only this spell have SpellIconID == 459 and dummy aura
+            {
+                if (getPowerType() != POWER_MANA)
+                    return false;
+
+                // mana reward
+                basepoints0 = (triggerAmount * GetMaxPower(POWER_MANA) / 100);
+                target = this;
+                triggered_spell_id = 29442;
+                break;
+            }
+            // Master of Elements
+            if (dummySpell->SpellIconID == 1920)
+            {
+                if (!procSpell)
+                    return false;
+
+                // mana cost save
+                int32 cost = procSpell->manaCost + procSpell->ManaCostPercentage * GetCreateMana() / 100;
+                basepoints0 = cost * triggerAmount/100;
+                if (basepoints0 <= 0)
+                    return false;
+
+                target = this;
+                triggered_spell_id = 29077;
+                break;
+            }
+            // Arcane Potency
+            if (dummySpell->SpellIconID == 2120)
+            {
+                if (!procSpell)
+                    return false;
+
+                target = this;
+                switch (dummySpell->Id)
+                {
+                    case 31571: triggered_spell_id = 57529; break;
+                    case 31572: triggered_spell_id = 57531; break;
+                    default:
+                        sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u",dummySpell->Id);
+                        return false;
+                }
+                break;
+            }
+
+            // Hot Streak
+            if (dummySpell->SpellIconID == 2999)
+            {
+                if (effIndex != 0)
+                    return false;
+                AuraEffect *counter = triggeredByAura->GetBase()->GetEffect(1);
+                if (!counter)
+                    return true;
+
+                // Count spell criticals in a row in second aura
+                if (procEx & PROC_EX_CRITICAL_HIT)
+                {
+                    counter->SetAmount(counter->GetAmount()*2);
+                    if (counter->GetAmount() < 100) // not enough
+                        return true;
+                    // Crititcal counted -> roll chance
+                    if (roll_chance_i(triggerAmount))
+                       CastSpell(this, 48108, true, castItem, triggeredByAura);
+                }
+                counter->SetAmount(25);
+                return true;
+            }
+            // Burnout
+            if (dummySpell->SpellIconID == 2998)
+            {
+                if (!procSpell)
+                    return false;
+
+                int32 cost = procSpell->manaCost + procSpell->ManaCostPercentage * GetCreateMana() / 100;
+                basepoints0 = cost * triggerAmount/100;
+                if (basepoints0 <= 0)
+                    return false;
+                triggered_spell_id = 44450;
+                target = this;
+                break;
+            }
+            // Incanter's Regalia set (add trigger chance to Mana Shield)
+            if (dummySpell->SpellFamilyFlags[0] & 0x8000)
+            {
+                if (GetTypeId() != TYPEID_PLAYER)
+                    return false;
+
+                target = this;
+                triggered_spell_id = 37436;
+                break;
+            }
+            switch(dummySpell->Id)
+            {
+                // Glyph of Polymorph
+                case 56375:
+                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE, 0, target->GetAura(32409)); // SW:D shall not be removed.
+                    target->RemoveAurasByType(SPELL_AURA_PERIODIC_DAMAGE_PERCENT);
+                    return true;
+                // Glyph of Icy Veins
+                case 56374:
+                {
+                    RemoveAurasByType(SPELL_AURA_MOD_HASTE, 0, 0, true, false);
+                    RemoveAurasByType(SPELL_AURA_MOD_DECREASE_SPEED);
+                    return true;
+                }
+                // Ignite
+                case 11119:
+                case 11120:
+                case 12846:
+                case 12847:
+                case 12848:
+                {
+                    switch (dummySpell->Id)
+                    {
+                        case 11119: basepoints0 = int32(0.04f*damage); break;
+                        case 11120: basepoints0 = int32(0.08f*damage); break;
+                        case 12846: basepoints0 = int32(0.12f*damage); break;
+                        case 12847: basepoints0 = int32(0.16f*damage); break;
+                        case 12848: basepoints0 = int32(0.20f*damage); break;
+                        default:
+                            sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u (IG)",dummySpell->Id);
+                            return false;
+                    }
+
+                    triggered_spell_id = 12654;
+                    basepoints0 += pVictim->GetRemainingDotDamage(GetGUID(), triggered_spell_id);
+                    break;
+                }
+                // Glyph of Ice Block
+                case 56372:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    SpellCooldowns const SpellCDs = this->ToPlayer()->GetSpellCooldowns();
+                    // remove cooldowns on all ranks of Frost Nova
+                    for (SpellCooldowns::const_iterator itr = SpellCDs.begin(); itr != SpellCDs.end(); itr++)
+                    {
+                        SpellEntry const* SpellCDs_entry = sSpellStore.LookupEntry(itr->first);
+                        // Frost Nova
+                        if (SpellCDs_entry && SpellCDs_entry->SpellFamilyName == SPELLFAMILY_MAGE
+                           && SpellCDs_entry->SpellFamilyFlags[0] & 0x00000040)
+                            this->ToPlayer()->RemoveSpellCooldown(SpellCDs_entry->Id, true);
+                    }
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            switch(dummySpell->Id)
+            {
+                // Sweeping Strikes
+                case 12328:
+                {
+                    target = SelectNearbyTarget();
+                    if (!target)
+                        return false;
+
+                    triggered_spell_id = 26654;
+                    break;
+                }
+                // Improved Spell Reflection
+                case 59088:
+                case 59089:
+                {
+                    triggered_spell_id = 59725;
+                    target = this;
+                    break;
+                }
+            }
+
+            // Retaliation
+            if (dummySpell->SpellFamilyFlags[1] & 0x8)
+            {
+                // check attack comes not from behind
+                if (!HasInArc(M_PI, pVictim))
+                    return false;
+
+                triggered_spell_id = 22858;
+                break;
+            }
+            // Second Wind
+            if (dummySpell->SpellIconID == 1697)
+            {
+                // only for spells and hit/crit (trigger start always) and not start from self casted spells (5530 Mace Stun Effect for example)
+                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == pVictim)
+                    return false;
+                // Need stun or root mechanic
+                if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_STUN))))
+                    return false;
+
+                switch (dummySpell->Id)
+                {
+                    case 29838: triggered_spell_id=29842; break;
+                    case 29834: triggered_spell_id=29841; break;
+                    case 42770: triggered_spell_id=42771; break;
+                    default:
+                        sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u (SW)",dummySpell->Id);
+                    return false;
+                }
+
+                target = this;
+                break;
+            }
+            // Damage Shield
+            if (dummySpell->SpellIconID == 3214)
+            {
+                triggered_spell_id = 59653;
+                // % of amount blocked
+                basepoints0 = GetShieldBlockValue() * triggerAmount / 100;
+                break;
+            }
+            // Glyph of Blocking
+            if (dummySpell->Id == 58375)
+            {
+                triggered_spell_id = 58374;
+                break;
+            }
+            // Glyph of Sunder Armor
+            if (dummySpell->Id == 58387)
+            {
+                if (!pVictim || !pVictim->isAlive() || !procSpell)
+                    return false;
+
+                target = SelectNearbyTarget();
+                if (!target || target == pVictim)
+                    return false;
+
+                CastSpell(target, 58567, true);
+                return true;
+            }
+            break;
+        }
+        case SPELLFAMILY_WARLOCK:
+        {
+            // Seed of Corruption
+            if (dummySpell->SpellFamilyFlags[1] & 0x00000010)
+            {
+                if (procSpell && procSpell->Id == 27285)
+                    return false;
+                // if damage is more than need or target die from damage deal finish spell
+                if (triggeredByAura->GetAmount() <= int32(damage) || GetHealth() <= damage)
+                {
+                    // remember guid before aura delete
+                    uint64 casterGuid = triggeredByAura->GetCasterGUID();
+
+                    // Remove aura (before cast for prevent infinite loop handlers)
+                    RemoveAurasDueToSpell(triggeredByAura->GetId());
+
+                    // Cast finish spell (triggeredByAura already not exist!)
+                    if (Unit* caster = GetUnit(*this, casterGuid))
+                        caster->CastSpell(this, 27285, true, castItem);
+                    return true;                            // no hidden cooldown
+                }
+
+                // Damage counting
+                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);
+                return true;
+            }
+            // Seed of Corruption (Mobs cast) - no die req
+            if (dummySpell->SpellFamilyFlags.IsEqual(0, 0, 0) && dummySpell->SpellIconID == 1932)
+            {
+                // if damage is more than need deal finish spell
+                if (triggeredByAura->GetAmount() <= int32(damage))
+                {
+                    // remember guid before aura delete
+                    uint64 casterGuid = triggeredByAura->GetCasterGUID();
+
+                    // Remove aura (before cast for prevent infinite loop handlers)
+                    RemoveAurasDueToSpell(triggeredByAura->GetId());
+
+                    // Cast finish spell (triggeredByAura already not exist!)
+                    if (Unit* caster = GetUnit(*this, casterGuid))
+                        caster->CastSpell(this, 32865, true, castItem);
+                    return true;                            // no hidden cooldown
+                }
+                // Damage counting
+                triggeredByAura->SetAmount(triggeredByAura->GetAmount() - damage);
+                return true;
+            }
+            // Fel Synergy
+            if (dummySpell->SpellIconID == 3222)
+            {
+                target = GetGuardianPet();
+                if (!target)
+                    return false;
+                basepoints0 = damage * triggerAmount / 100;
+                triggered_spell_id = 54181;
+                break;
+            }
+            switch (dummySpell->Id)
+            {
+                // Siphon Life
+                case 63108:
+                {
+                    // Glyph of Siphon Life
+                    if (HasAura(56216))
+                        triggerAmount += triggerAmount / 4;
+                    triggered_spell_id = 63106;
+                    target = this;
+                    basepoints0 = int32(damage*triggerAmount/100);
+                    break;
+                }
+                // Glyph of Shadowflame
+                case 63310:
+                {
+                    triggered_spell_id = 63311;
+                    break;
+                }
+                // Nightfall
+                case 18094:
+                case 18095:
+                // Glyph of corruption
+                case 56218:
+                {
+                    target = this;
+                    triggered_spell_id = 17941;
+                    break;
+                }
+                //Soul Leech
+                case 30293:
+                case 30295:
+                case 30296:
+                {
+                    // Improved Soul Leech
+                    AuraEffectList const& SoulLeechAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+                    for (Unit::AuraEffectList::const_iterator i = SoulLeechAuras.begin(); i != SoulLeechAuras.end(); ++i)
+                    {
+                        if ((*i)->GetId() == 54117 || (*i)->GetId() == 54118)
+                        {
+                            if ((*i)->GetEffIndex() != 0)
+                                continue;
+                            basepoints0 = int32((*i)->GetAmount());
+                            target = GetGuardianPet();
+                            if (target)
+                            {
+                                // regen mana for pet
+                                CastCustomSpell(target,54607,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+                            }
+                            // regen mana for caster
+                            CastCustomSpell(this,59117,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+                            // Get second aura of spell for replenishment effect on party
+                            if (AuraEffect const * aurEff = (*i)->GetBase()->GetEffect(1))
+                            {
+                                // Replenishment - roll chance
+                                if (roll_chance_i(aurEff->GetAmount()))
+                                {
+                                    CastSpell(this,57669,true, castItem, triggeredByAura);
+                                }
+                            }
+                            break;
+                        }
+                    }
+                    // health
+                    basepoints0 = int32(damage*triggerAmount/100);
+                    target = this;
+                    triggered_spell_id = 30294;
+                    break;
+                }
+                // Shadowflame (Voidheart Raiment set bonus)
+                case 37377:
+                {
+                    triggered_spell_id = 37379;
+                    break;
+                }
+                // Pet Healing (Corruptor Raiment or Rift Stalker Armor)
+                case 37381:
+                {
+                    target = GetGuardianPet();
+                    if (!target)
+                        return false;
+
+                    // heal amount
+                    basepoints0 = damage * triggerAmount/100;
+                    triggered_spell_id = 37382;
+                    break;
+                }
+                // Shadowflame Hellfire (Voidheart Raiment set bonus)
+                case 39437:
+                {
+                    triggered_spell_id = 37378;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_PRIEST:
+        {
+            // Vampiric Touch
+            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)
+            {
+                if (!pVictim || !pVictim->isAlive())
+                    return false;
+
+                if (effIndex != 0)
+                    return false;
+
+                // pVictim is caster of aura
+                if (triggeredByAura->GetCasterGUID() != pVictim->GetGUID())
+                    return false;
+
+                // Energize 0.25% of max. mana
+                pVictim->CastSpell(pVictim,57669,true,castItem,triggeredByAura);
+                return true;                                // no hidden cooldown
+            }
+            // Divine Aegis
+            if (dummySpell->SpellIconID == 2820)
+            {
+                // Multiple effects stack, so let's try to find this aura.
+                int32 bonus = 0;
+                if (AuraEffect *aurEff = target->GetAuraEffect(47753, 0))
+                    bonus = aurEff->GetAmount();
+
+                basepoints0 = damage * triggerAmount/100 + bonus;
+                if (basepoints0 > target->getLevel() * 125)
+                    basepoints0 = target->getLevel() * 125;
+
+                triggered_spell_id = 47753;
+                break;
+            }
+            // Body and Soul
+            if (dummySpell->SpellIconID == 2218)
+            {
+                // Proc only from Abolish desease on self cast
+                if (procSpell->Id != 552 || pVictim != this || !roll_chance_i(triggerAmount))
+                    return false;
+                triggered_spell_id = 64136;
+                target = this;
+                break;
+            }
+            switch(dummySpell->Id)
+            {
+                // Vampiric Embrace
+                case 15286:
+                {
+                    if (!pVictim || !pVictim->isAlive())
+                        return false;
+
+                    // heal amount
+                    int32 team = triggerAmount*damage/500;
+                    int32 self = triggerAmount*damage/100 - team;
+                    CastCustomSpell(this,15290,&team,&self,NULL,true,castItem,triggeredByAura);
+                    return true;                                // no hidden cooldown
+                }
+                // Priest Tier 6 Trinket (Ashtongue Talisman of Acumen)
+                case 40438:
+                {
+                    // Shadow Word: Pain
+                    if (procSpell->SpellFamilyFlags[0] & 0x8000)
+                        triggered_spell_id = 40441;
+                    // Renew
+                    else if (procSpell->SpellFamilyFlags[0] & 0x40)
+                        triggered_spell_id = 40440;
+                    else
+                        return false;
+
+                    target = this;
+                    break;
+                }
+                // Glyph of Prayer of Healing
+                case 55680:
+                {
+                    triggered_spell_id = 56161;
+
+                    SpellEntry const* GoPoH = sSpellStore.LookupEntry(triggered_spell_id);
+                    if (!GoPoH)
+                        return false;
+
+                    int EffIndex = 0;
+                    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)
+                    {
+                        if (GoPoH->Effect[i] == SPELL_EFFECT_APPLY_AURA)
+                        {
+                            EffIndex = i;
+                            break;
+                        }
+                    }
+                    int32 tickcount = GetSpellMaxDuration(GoPoH) / GoPoH->EffectAmplitude[EffIndex];
+                    if (!tickcount)
+                        return false;
+
+                    basepoints0 = damage * triggerAmount / tickcount / 100;
+                    break;
+                }
+                // Improved Shadowform
+                case 47570:
+                case 47569:
+                {
+                    if (!roll_chance_i(triggerAmount))
+                        return false;
+
+                    RemoveMovementImpairingAuras();
+                    break;
+                }
+                // Glyph of Dispel Magic
+                case 55677:
+                {
+                    // Dispel Magic shares spellfamilyflag with abolish disease
+                    if (procSpell->SpellIconID != 74)
+                        return false;
+                    if (!target || !target->IsFriendlyTo(this))
+                        return false;
+
+                    basepoints0 = int32(target->CountPctFromMaxHealth(triggerAmount));
+                    triggered_spell_id = 56131;
+                    break;
+                }
+                // Oracle Healing Bonus ("Garments of the Oracle" set)
+                case 26169:
+                {
+                    // heal amount
+                    basepoints0 = int32(damage * 10/100);
+                    target = this;
+                    triggered_spell_id = 26170;
+                    break;
+                }
+                // Frozen Shadoweave (Shadow's Embrace set) warning! its not only priest set
+                case 39372:
+                {
+                    if (!procSpell || (GetSpellSchoolMask(procSpell) & (SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_SHADOW)) == 0)
+                        return false;
+
+                    // heal amount
+                    basepoints0 = damage * triggerAmount/100;
+                    target = this;
+                    triggered_spell_id = 39373;
+                    break;
+                }
+                // Greater Heal (Vestments of Faith (Priest Tier 3) - 4 pieces bonus)
+                case 28809:
+                {
+                    triggered_spell_id = 28810;
+                    break;
+                }
+                // Priest T10 Healer 2P Bonus
+                case 70770:
+                    // Flash Heal
+                    if (procSpell->SpellFamilyFlags[0] & 0x800)
+                    {
+                        triggered_spell_id = 70772;
+                        SpellEntry const* blessHealing = sSpellStore.LookupEntry(triggered_spell_id);
+                        if (!blessHealing)
+                            return false;
+                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(blessHealing) / blessHealing->EffectAmplitude[0]));
+                    }
+                    break;
+            }
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            switch(dummySpell->Id)
+            {
+                // Glyph of Innervate
+                case 54832:
+                {
+                    if (procSpell->SpellIconID != 62)
+                        return false;
+
+                    int32 mana_perc = SpellMgr::CalculateSpellEffectAmount(triggeredByAura->GetSpellProto(), triggeredByAura->GetEffIndex());
+                    basepoints0 = uint32((GetCreatePowers(POWER_MANA) * mana_perc / 100) / 10);
+                    triggered_spell_id = 54833;
+                    target = this;
+                    break;
+                }
+                // Glyph of Starfire
+                case 54845:
+                {
+                    triggered_spell_id = 54846;
+                    break;
+                }
+                // Glyph of Shred
+                case 54815:
+                {
+                    // try to find spell Rip on the target
+                    if (AuraEffect const *AurEff = target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00800000, 0x0, 0x0, GetGUID()))
+                    {
+                        // Rip's max duration, note: spells which modifies Rip's duration also counted like Glyph of Rip
+                        uint32 CountMin = AurEff->GetBase()->GetMaxDuration();
+
+                        // just Rip's max duration without other spells
+                        uint32 CountMax = GetSpellMaxDuration(AurEff->GetSpellProto());
+
+                        // add possible auras' and Glyph of Shred's max duration
+                        CountMax += 3 * triggerAmount * 1000;       // Glyph of Shred               -> +6 seconds
+                        CountMax += HasAura(54818) ? 4 * 1000 : 0;  // Glyph of Rip                 -> +4 seconds
+                        CountMax += HasAura(60141) ? 4 * 1000 : 0;  // Rip Duration/Lacerate Damage -> +4 seconds
+
+                        // if min < max -> that means caster didn't cast 3 shred yet
+                        // so set Rip's duration and max duration
+                        if (CountMin < CountMax)
+                        {
+                            AurEff->GetBase()->SetDuration(AurEff->GetBase()->GetDuration() + triggerAmount * 1000);
+                            AurEff->GetBase()->SetMaxDuration(CountMin + triggerAmount * 1000);
+                            return true;
+                        }
+                    }
+                    // if not found Rip
+                    return false;
+                }
+                // Glyph of Rake
+                case 54821:
+                {
+                    if (procSpell->SpellVisual[0] == 750 && procSpell->EffectApplyAuraName[1] == 3)
+                    {
+                        if (target->GetTypeId() == TYPEID_UNIT)
+                        {
+                            triggered_spell_id = 54820;
+                            break;
+                        }
+                    }
+                    return false;
+                }
+                // Leader of the Pack
+                case 24932:
+                {
+                   if (triggerAmount <= 0)
+                        return false;
+                    basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
+                    target = this;
+                    triggered_spell_id = 34299;
+                    if (triggeredByAura->GetCasterGUID() != GetGUID())
+                        break;
+                    int32 basepoints1 = triggerAmount * 2;
+                    // Improved Leader of the Pack
+                    // Check cooldown of heal spell cooldown
+                    if (GetTypeId() == TYPEID_PLAYER && !ToPlayer()->HasSpellCooldown(34299))
+                        CastCustomSpell(this,60889,&basepoints1,0,0,true,0,triggeredByAura);
+                    break;
+                }
+                // Healing Touch (Dreamwalker Raiment set)
+                case 28719:
+                {
+                    // mana back
+                    basepoints0 = int32(procSpell->manaCost * 30 / 100);
+                    target = this;
+                    triggered_spell_id = 28742;
+                    break;
+                }
+                // Glyph of Rejuvenation
+                case 54754:
+                {
+                    if (!pVictim || !pVictim->HealthBelowPct(uint32(triggerAmount)))
+                        return false;
+                    basepoints0 = int32(triggerAmount * damage / 100);
+                    triggered_spell_id = 54755;
+                    break;
+                }
+                // Healing Touch Refund (Idol of Longevity trinket)
+                case 28847:
+                {
+                    target = this;
+                    triggered_spell_id = 28848;
+                    break;
+                }
+                // Mana Restore (Malorne Raiment set / Malorne Regalia set)
+                case 37288:
+                case 37295:
+                {
+                    target = this;
+                    triggered_spell_id = 37238;
+                    break;
+                }
+                // Druid Tier 6 Trinket
+                case 40442:
+                {
+                    float  chance;
+
+                    // Starfire
+                    if (procSpell->SpellFamilyFlags[0] & 0x4)
+                    {
+                        triggered_spell_id = 40445;
+                        chance = 25.0f;
+                    }
+                    // Rejuvenation
+                    else if (procSpell->SpellFamilyFlags[0] & 0x10)
+                    {
+                        triggered_spell_id = 40446;
+                        chance = 25.0f;
+                    }
+                    // Mangle (Bear) and Mangle (Cat)
+                    else if (procSpell->SpellFamilyFlags[1] & 0x00000440)
+                    {
+                        triggered_spell_id = 40452;
+                        chance = 40.0f;
+                    }
+                    else
+                        return false;
+
+                    if (!roll_chance_f(chance))
+                        return false;
+
+                    target = this;
+                    break;
+                }
+                // Maim Interrupt
+                case 44835:
+                {
+                    // Deadly Interrupt Effect
+                    triggered_spell_id = 32747;
+                    break;
+                }
+                // Item - Druid T10 Balance 4P Bonus
+                case 70723:
+                {
+                    // Wrath & Starfire
+                    if ((procSpell->SpellFamilyFlags[0] & 0x5) && (procEx & PROC_EX_CRITICAL_HIT))
+                    {
+                        triggered_spell_id = 71023;
+                        SpellEntry const* triggeredSpell = sSpellStore.LookupEntry(triggered_spell_id);
+                        if (!triggeredSpell)
+                            return false;
+                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(triggeredSpell) / triggeredSpell->EffectAmplitude[0]));
+                    }
+                    break;
+                }
+            }
+            // Eclipse
+            if (dummySpell->SpellIconID == 2856 && GetTypeId() == TYPEID_PLAYER)
+            {
+                if (!procSpell || effIndex != 0)
+                    return false;
+
+                bool isWrathSpell = (procSpell->SpellFamilyFlags[0] & 1);
+
+                if (!roll_chance_f(dummySpell->procChance * (isWrathSpell ? 0.6f : 1.0f)))
+                    return false;
+
+                target = this;
+                if (target->HasAura(isWrathSpell ? 48517 : 48518))
+                    return false;
+
+                triggered_spell_id = isWrathSpell ? 48518 : 48517;
+                break;
+            }
+            // Living Seed
+            else if (dummySpell->SpellIconID == 2860)
+            {
+                triggered_spell_id = 48504;
+                basepoints0 = triggerAmount * damage / 100;
+                break;
+            }
+            // King of the Jungle
+            else if (dummySpell->SpellIconID == 2850)
+            {
+                // Effect 0 - mod damage while having Enrage
+                if (effIndex == 0)
+                {
+                    if (!(procSpell->SpellFamilyFlags[0] & 0x00080000))
+                        return false;
+                    triggered_spell_id = 51185;
+                    basepoints0 = triggerAmount;
+                    target = this;
+                    break;
+                }
+                // Effect 1 - Tiger's Fury restore energy
+                else if (effIndex == 1)
+                {
+                    if (!(procSpell->SpellFamilyFlags[2] & 0x00000800))
+                        return false;
+                    triggered_spell_id = 51178;
+                    basepoints0 = triggerAmount;
+                    target = this;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_ROGUE:
+        {
+            switch(dummySpell->Id)
+            {
+                // Glyph of Backstab
+                case 56800:
+                {
+                    triggered_spell_id = 63975;
+                    break;
+                }
+                // Deadly Throw Interrupt
+                case 32748:
+                {
+                    // Prevent cast Deadly Throw Interrupt on self from last effect (apply dummy) of Deadly Throw
+                    if (this == pVictim)
+                        return false;
+
+                    triggered_spell_id = 32747;
+                    break;
+                }
+            }
+            // Cut to the Chase
+            if (dummySpell->SpellIconID == 2909)
+            {
+                // "refresh your Slice and Dice duration to its 5 combo point maximum"
+                // lookup Slice and Dice
+                if (AuraEffect const* aur = GetAuraEffect(SPELL_AURA_MOD_HASTE, SPELLFAMILY_ROGUE,0x40000, 0, 0))
+                {
+                    aur->GetBase()->SetDuration(GetSpellMaxDuration(aur->GetSpellProto()), true);
+                    return true;
+                }
+                return false;
+            }
+            // Deadly Brew
+            else if (dummySpell->SpellIconID == 2963)
+            {
+                triggered_spell_id = 3409;
+                break;
+            }
+            // Quick Recovery
+            else if (dummySpell->SpellIconID == 2116)
+            {
+                if (!procSpell)
+                    return false;
+
+                // energy cost save
+                basepoints0 = procSpell->manaCost * triggerAmount/100;
+                if (basepoints0 <= 0)
+                    return false;
+
+                target = this;
+                triggered_spell_id = 31663;
+                break;
+            }
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // Thrill of the Hunt
+            if (dummySpell->SpellIconID == 2236)
+            {
+                if (!procSpell)
+                    return false;
+
+                // Explosive Shot
+                if (procSpell->SpellFamilyFlags[2] & 0x200)
+                {
+                    if (AuraEffect const* pEff = pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_HUNTER, 0x0, 0x80000000, 0x0, GetGUID()))
+                        basepoints0 = CalculatePowerCost(pEff->GetSpellProto(), this, SpellSchoolMask(pEff->GetSpellProto()->SchoolMask)) * 4/10/3;
+                }
+                else
+                    basepoints0 = CalculatePowerCost(procSpell, this, SpellSchoolMask(procSpell->SchoolMask)) * 4/10;
+                if (basepoints0 <= 0)
+                    return false;
+
+                basepoints0 += 1;   // standard basepoint increase for CastCustomSpell
+                target = this;
+                triggered_spell_id = 34720;
+                break;
+            }
+            // Hunting Party
+            if (dummySpell->SpellIconID == 3406)
+            {
+                triggered_spell_id = 57669;
+                target = this;
+                break;
+            }
+            // Improved Mend Pet
+            if (dummySpell->SpellIconID == 267)
+            {
+                int32 chance = SpellMgr::CalculateSpellEffectAmount(triggeredByAura->GetSpellProto(), triggeredByAura->GetEffIndex());
+                if (!roll_chance_i(chance))
+                    return false;
+
+                triggered_spell_id = 24406;
+                break;
+            }
+            // Lock and Load
+            if (dummySpell->SpellIconID == 3579)
+            {
+                // Proc only from periodic (from trap activation proc another aura of this spell)
+                if (!(procFlag & PROC_FLAG_DONE_PERIODIC) || !roll_chance_i(triggerAmount))
+                    return false;
+                triggered_spell_id = 56453;
+                target = this;
+                break;
+            }
+            // Rapid Recuperation
+            if (dummySpell->SpellIconID == 3560)
+            {
+                // This effect only from Rapid Killing (mana regen)
+                if (!(procSpell->SpellFamilyFlags[1] & 0x01000000))
+                    return false;
+                triggered_spell_id = 56654;
+
+                target = this;
+
+                switch(dummySpell->Id)
+                {
+                    case 53228:                             // Rank 1
+                        triggered_spell_id = 56654;
+                        break;
+                    case 53232:                             // Rank 2
+                        triggered_spell_id = 58882;
+                        break;
+                }
+                break;
+            }
+            // Glyph of Mend Pet
+            if(dummySpell->Id == 57870)
+            {
+                pVictim->CastSpell(pVictim, 57894, true, NULL, NULL, GetGUID());
+                return true;
+            }
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Seal of Righteousness - melee proc dummy (addition ${$MWS*(0.022*$AP+0.044*$SPH)} damage)
+            if (dummySpell->SpellFamilyFlags[0]&0x8000000)
+            {
+                if (effIndex != 0)
+                    return false;
+                triggered_spell_id = 25742;
+                float ap = GetTotalAttackPowerValue(BASE_ATTACK);
+                int32 holy = SpellBaseDamageBonus(SPELL_SCHOOL_MASK_HOLY) +
+                             SpellBaseDamageBonusForVictim(SPELL_SCHOOL_MASK_HOLY, pVictim);
+                basepoints0 = (int32)GetAttackTime(BASE_ATTACK) * int32(ap*0.022f + 0.044f * holy) / 1000;
+                break;
+            }
+            // Light's Beacon - Beacon of Light
+            if (dummySpell->Id == 53651)
+            {
+                // Get target of beacon of light
+                if (Unit * beaconTarget = triggeredByAura->GetBase()->GetCaster())
+                {
+                    // do not proc when target of beacon of light is healed
+                    if (beaconTarget == this)
+                        return false;
+                    // check if it was heal by paladin which casted this beacon of light
+                    if (beaconTarget->GetAura(53563, pVictim->GetGUID()))
+                    {
+                        if (beaconTarget->IsWithinLOSInMap(pVictim))
+                        {
+                            basepoints0 = damage;
+                            triggered_spell_id = 53654;
+                            target = beaconTarget;
+                            break;
+                        }
+                    }
+                }
+                return false;
+            }
+            // Judgements of the Wise
+            if (dummySpell->SpellIconID == 3017)
+            {
+                target = this;
+                triggered_spell_id = 31930;
+                // replenishment
+                CastSpell(this,57669,true, castItem, triggeredByAura);
+                break;
+            }
+            // Sanctified Wrath
+            if (dummySpell->SpellIconID == 3029)
+            {
+                triggered_spell_id = 57318;
+                target = this;
+                basepoints0 = triggerAmount;
+                CastCustomSpell(target,triggered_spell_id,&basepoints0,&basepoints0,NULL,true,castItem,triggeredByAura);
+                return true;
+            }
+            // Sacred Shield
+            if (dummySpell->SpellFamilyFlags[1]&0x00080000)
+            {
+                if (procFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)
+                {
+                    if (procSpell->SpellFamilyName == SPELLFAMILY_PALADIN
+                        && (procSpell->SpellFamilyFlags[0] & 0x40000000))
+                    {
+                        basepoints0 = int32(float(damage)/12.0f);
+                        CastCustomSpell(this,66922,&basepoints0,NULL,NULL,true,0,triggeredByAura, pVictim->GetGUID());
+                        return true;
+                    }
+                    else
+                        return false;
+                }
+                else
+                    triggered_spell_id = 58597;
+                target = this;
+                break;
+            }
+            // Righteous Vengeance
+            if (dummySpell->SpellIconID == 3025)
+            {
+                // 4 damage tick
+                basepoints0 = triggerAmount*damage/400;
+                triggered_spell_id = 61840;
+                // Add remaining ticks to damage done
+                basepoints0 += pVictim->GetRemainingDotDamage(GetGUID(), triggered_spell_id);
+                break;
+            }
+            // Sheath of Light
+            if (dummySpell->SpellIconID == 3030)
+            {
+                // 4 healing tick
+                basepoints0 = triggerAmount*damage/400;
+                triggered_spell_id = 54203;
+                break;
+            }
+            switch (dummySpell->Id)
+            {
+                // Heart of the Crusader
+                case 20335: // rank 1
+                    triggered_spell_id = 21183;
+                    break;
+                case 20336: // rank 2
+                    triggered_spell_id = 54498;
+                    break;
+                case 20337: // rank 3
+                    triggered_spell_id = 54499;
+                    break;
+                // Judgement of Light
+                case 20185:
+                {
+                    if (pVictim->getPowerType() == POWER_MANA)
+                    {
+                        // 2% of base mana
+                        basepoints0 = int32(pVictim->CountPctFromMaxHealth(2));
+                        pVictim->CastCustomSpell(pVictim, 20267, &basepoints0, 0, 0, true, 0, triggeredByAura);
+                    }
+                        return true;
+                }
+                // Judgement of Wisdom
+                case 20186:
+                {
+                    if (pVictim && pVictim->isAlive() && pVictim->getPowerType() == POWER_MANA)
+                    {
+                        // 2% of base mana
+                        basepoints0 = int32(pVictim->GetCreateMana() * 2 / 100);
+                        pVictim->CastCustomSpell(pVictim, 20268, &basepoints0, NULL, NULL, true, 0, triggeredByAura);
+                    }
+                    return true;
+                }
+                // Holy Power (Redemption Armor set)
+                case 28789:
+                {
+                    if (!pVictim)
+                        return false;
+
+                    // Set class defined buff
+                    switch (pVictim->getClass())
+                    {
+                        case CLASS_PALADIN:
+                        case CLASS_PRIEST:
+                        case CLASS_SHAMAN:
+                        case CLASS_DRUID:
+                            triggered_spell_id = 28795;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
+                            break;
+                        case CLASS_MAGE:
+                        case CLASS_WARLOCK:
+                            triggered_spell_id = 28793;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
+                            break;
+                        case CLASS_HUNTER:
+                        case CLASS_ROGUE:
+                            triggered_spell_id = 28791;     // Increases the friendly target's attack power by $s1 for $d.
+                            break;
+                        case CLASS_WARRIOR:
+                            triggered_spell_id = 28790;     // Increases the friendly target's armor
+                            break;
+                        default:
+                            return false;
+                    }
+                    break;
+                }
+                case 25899:                                 // Greater Blessing of Sanctuary
+                case 20911:                                 // Blessing of Sanctuary
+                {
+                    target = this;
+                    switch (target->getPowerType())
+                    {
+                        case POWER_MANA:
+                            triggered_spell_id = 57319;
+                            break;
+                        default:
+                            return false;
+                    }
+                    break;
+                }
+                // Seal of Vengeance (damage calc on apply aura)
+                case 31801:
+                {
+                    if (effIndex != 0)                       // effect 1,2 used by seal unleashing code
+                        return false;
+
+                    // At melee attack or Hammer of the Righteous spell damage considered as melee attack
+                    if ((procFlag & PROC_FLAG_DONE_MELEE_AUTO_ATTACK) || (procSpell && procSpell->Id == 53595))
+                        triggered_spell_id = 31803;
+                    // On target with 5 stacks of Holy Vengeance direct damage is done
+                    if (Aura * aur = pVictim->GetAura(triggered_spell_id, GetGUID()))
+                    {
+                        if (aur->GetStackAmount() == 5)
+                        {
+                            aur->RefreshDuration();
+                            CastSpell(pVictim, 42463, true);
+                            return true;
+                        }
+                    }
+
+                    // Only Autoattack can stack debuff
+                    if (procFlag & PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS)
+                        return false;
+                    break;
+                }
+                // Seal of Corruption
+                case 53736:
+                {
+                    if (effIndex != 0)                       // effect 1,2 used by seal unleashing code
+                        return false;
+
+                    // At melee attack or Hammer of the Righteous spell damage considered as melee attack
+                    if ((procFlag & PROC_FLAG_DONE_MELEE_AUTO_ATTACK) || (procSpell && procSpell->Id == 53595))
+                        triggered_spell_id = 53742;
+                    // On target with 5 stacks of Blood Corruption direct damage is done
+                    if (Aura * aur = pVictim->GetAura(triggered_spell_id, GetGUID()))
+                    {
+                        if (aur->GetStackAmount() == 5)
+                        {
+                            aur->RefreshDuration();
+                            CastSpell(pVictim, 53739, true);
+                            return true;
+                        }
+                    }
+
+                    // Only Autoattack can stack debuff
+                    if (procFlag & PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS)
+                        return false;
+                    break;
+                }
+                // Spiritual Attunement
+                case 31785:
+                case 33776:
+                {
+                    // if healed by another unit (pVictim)
+                    if (this == pVictim)
+                        return false;
+
+                    // heal amount
+                    basepoints0 = triggerAmount*(std::min(damage,GetMaxHealth() - GetHealth()))/100;
+                    target = this;
+
+                    if (basepoints0)
+                        triggered_spell_id = 31786;
+                    break;
+                }
+                // Paladin Tier 6 Trinket (Ashtongue Talisman of Zeal)
+                case 40470:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    float  chance;
+
+                    // Flash of light/Holy light
+                    if (procSpell->SpellFamilyFlags[0] & 0xC0000000)
+                    {
+                        triggered_spell_id = 40471;
+                        chance = 15.0f;
+                    }
+                    // Judgement (any)
+                    else if (GetSpellSpecific(procSpell) == SPELL_SPECIFIC_JUDGEMENT)
+                    {
+                        triggered_spell_id = 40472;
+                        chance = 50.0f;
+                    }
+                    else
+                        return false;
+
+                    if (!roll_chance_f(chance))
+                        return false;
+
+                    break;
+                }
+                // Glyph of Divinity
+                case 54939:
+                {
+                    // Lookup base amount mana restore
+                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; i++)
+                        if (procSpell->Effect[i] == SPELL_EFFECT_ENERGIZE)
+                        {
+                            int32 mana = SpellMgr::CalculateSpellEffectAmount(procSpell, i);
+                            CastCustomSpell(this, 54986, 0, &mana, 0, true, castItem, triggeredByAura);
+                            break;
+                        }
+                    return true;
+                }
+                // Glyph of Flash of Light
+                case 54936:
+                {
+                    triggered_spell_id = 54957;
+                    basepoints0 = triggerAmount*damage/100;
+                    break;
+                }
+                // Glyph of Holy Light
+                case 54937:
+                {
+                    triggered_spell_id = 54968;
+                    basepoints0 = triggerAmount*damage/100;
+                    break;
+                }
+                case 71406: // Tiny Abomination in a Jar
+                {
+                    if (!pVictim || !pVictim->isAlive())
+                        return false;
+
+                    CastSpell(this, 71432, true, NULL, triggeredByAura);
+
+                    Aura const* dummy = GetAura(71432);
+                    if (!dummy || dummy->GetStackAmount() < 8)
+                        return false;
+
+                    RemoveAurasDueToSpell(71432);
+                    triggered_spell_id = 71433;  // default main hand attack
+                    // roll if offhand
+                    if (Player const* player = ToPlayer())
+                        if (player->GetWeaponForAttack(OFF_ATTACK, true) && urand(0, 1))
+                            triggered_spell_id = 71434;
+                    target = pVictim;
+                    break;
+                }
+                case 71545: // Tiny Abomination in a Jar (Heroic)
+                {
+                    if (!pVictim || !pVictim->isAlive())
+                        return false;
+
+                    CastSpell(this, 71432, true, NULL, triggeredByAura);
+
+                    Aura const* dummy = GetAura(71432);
+                    if (!dummy || dummy->GetStackAmount() < 7)
+                        return false;
+
+                    RemoveAurasDueToSpell(71432);
+                    triggered_spell_id = 71433;  // default main hand attack
+                    // roll if offhand
+                    if (Player const* player = ToPlayer())
+                        if (player->GetWeaponForAttack(OFF_ATTACK, true) && urand(0, 1))
+                            triggered_spell_id = 71434;
+                    target = pVictim;
+                    break;
+                }
+                // Item - Paladin T10 Retribution 2P Bonus
+                case 70765:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    this->ToPlayer()->RemoveSpellCooldown(53385, true);
+                    return true;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_SHAMAN:
+        {
+            switch(dummySpell->Id)
+            {
+                // Earthen Power (Rank 1, 2)
+                case 51523:
+                case 51524:
+                {
+                    // Totem itself must be a caster of this spell
+                    Unit* caster = NULL;
+                    for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr) {
+                        if ((*itr)->GetEntry() != 2630)
+                            continue;
+
+                        caster = (*itr);
+                        break;
+                    }
+
+                    if (!caster)
+                        return false;
+
+                    caster->CastSpell(caster, 59566, true, castItem, triggeredByAura, originalCaster);
+                    return true;
+                }
+                // Tidal Force
+                case 55198:
+                {
+                    // Remove aura stack from  caster
+                    RemoveAuraFromStack(55166);
+                    // drop charges
+                    return false;
+                }
+                // Totemic Power (The Earthshatterer set)
+                case 28823:
+                {
+                    if (!pVictim)
+                        return false;
+
+                    // Set class defined buff
+                    switch (pVictim->getClass())
+                    {
+                        case CLASS_PALADIN:
+                        case CLASS_PRIEST:
+                        case CLASS_SHAMAN:
+                        case CLASS_DRUID:
+                            triggered_spell_id = 28824;     // Increases the friendly target's mana regeneration by $s1 per 5 sec. for $d.
+                            break;
+                        case CLASS_MAGE:
+                        case CLASS_WARLOCK:
+                            triggered_spell_id = 28825;     // Increases the friendly target's spell damage and healing by up to $s1 for $d.
+                            break;
+                        case CLASS_HUNTER:
+                        case CLASS_ROGUE:
+                            triggered_spell_id = 28826;     // Increases the friendly target's attack power by $s1 for $d.
+                            break;
+                        case CLASS_WARRIOR:
+                            triggered_spell_id = 28827;     // Increases the friendly target's armor
+                            break;
+                        default:
+                            return false;
+                    }
+                    break;
+                }
+                // Lesser Healing Wave (Totem of Flowing Water Relic)
+                case 28849:
+                {
+                    target = this;
+                    triggered_spell_id = 28850;
+                    break;
+                }
+                // Windfury Weapon (Passive) 1-5 Ranks
+                case 33757:
+                {
+                    if (GetTypeId() != TYPEID_PLAYER || !castItem || !castItem->IsEquipped()  || !pVictim || !pVictim->isAlive())
+                        return false;
+
+                    // custom cooldown processing case
+                    if (cooldown && ToPlayer()->HasSpellCooldown(dummySpell->Id))
+                        return false;
+
+                    if (triggeredByAura->GetBase() && castItem->GetGUID() != triggeredByAura->GetBase()->GetCastItemGUID())
+                        return false;
+
+                    WeaponAttackType attType = WeaponAttackType(this->ToPlayer()->GetAttackBySlot(castItem->GetSlot()));
+                    if ((attType != BASE_ATTACK && attType != OFF_ATTACK) || !isAttackReady(attType))
+                        return false;
+
+                    // Now compute real proc chance...
+                    uint32 chance = 20;
+                    this->ToPlayer()->ApplySpellMod(dummySpell->Id,SPELLMOD_CHANCE_OF_SUCCESS,chance);
+
+                    Item* addWeapon = this->ToPlayer()->GetWeaponForAttack(attType == BASE_ATTACK ? OFF_ATTACK : BASE_ATTACK, true);
+                    uint32 enchant_id_add = addWeapon ? addWeapon->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)) : 0;
+                    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id_add);
+                    if (pEnchant && pEnchant->spellid[0] == dummySpell->Id)
+                        chance += 14;
+
+                    if (!roll_chance_i(chance))
+                        return false;
+
+                    // Now amount of extra power stored in 1 effect of Enchant spell
+                    // Get it by item enchant id
+                    uint32 spellId;
+                    switch (castItem->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)))
+                    {
+                        case 283: spellId =  8232; break;   // 1 Rank
+                        case 284: spellId =  8235; break;   // 2 Rank
+                        case 525: spellId = 10486; break;   // 3 Rank
+                        case 1669:spellId = 16362; break;   // 4 Rank
+                        case 2636:spellId = 25505; break;   // 5 Rank
+                        case 3785:spellId = 58801; break;   // 6 Rank
+                        case 3786:spellId = 58803; break;   // 7 Rank
+                        case 3787:spellId = 58804; break;   // 8 Rank
+                        default:
+                        {
+                            sLog.outError("Unit::HandleDummyAuraProc: non handled item enchantment (rank?) %u for spell id: %u (Windfury)",
+                                castItem->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)),dummySpell->Id);
+                            return false;
+                        }
+                    }
+
+                    SpellEntry const* windfurySpellEntry = sSpellStore.LookupEntry(spellId);
+                    if (!windfurySpellEntry)
+                    {
+                        sLog.outError("Unit::HandleDummyAuraProc: non existed spell id: %u (Windfury)",spellId);
+                        return false;
+                    }
+
+                    int32 extra_attack_power = CalculateSpellDamage(pVictim, windfurySpellEntry, 1);
+
+                    // Value gained from additional AP
+                    basepoints0 = int32(extra_attack_power/14.0f * GetAttackTime(BASE_ATTACK)/1000);
+                    triggered_spell_id = 25504;
+
+                    // apply cooldown before cast to prevent processing itself
+                    if (cooldown)
+                        ToPlayer()->AddSpellCooldown(dummySpell->Id,0,time(NULL) + cooldown);
+
+                    // Attack Twice
+                    for (uint32 i = 0; i<2; ++i)
+                        CastCustomSpell(pVictim,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+
+                    return true;
+                }
+                // Shaman Tier 6 Trinket
+                case 40463:
+                {
+                    if (!procSpell)
+                        return false;
+
+                    float chance;
+                    if (procSpell->SpellFamilyFlags[0] & 0x1)
+                    {
+                        triggered_spell_id = 40465;         // Lightning Bolt
+                        chance = 15.0f;
+                    }
+                    else if (procSpell->SpellFamilyFlags[0] & 0x80)
+                    {
+                        triggered_spell_id = 40465;         // Lesser Healing Wave
+                        chance = 10.0f;
+                    }
+                    else if (procSpell->SpellFamilyFlags[1] & 0x00000010)
+                    {
+                        triggered_spell_id = 40466;         // Stormstrike
+                        chance = 50.0f;
+                    }
+                    else
+                        return false;
+
+                    if (!roll_chance_f(chance))
+                        return false;
+
+                    target = this;
+                    break;
+                }
+                // Glyph of Healing Wave
+                case 55440:
+                {
+                    // Not proc from self heals
+                    if (this == pVictim)
+                        return false;
+                    basepoints0 = triggerAmount * damage / 100;
+                    target = this;
+                    triggered_spell_id = 55533;
+                    break;
+                }
+                // Spirit Hunt
+                case 58877:
+                {
+                    // Cast on owner
+                    target = GetOwner();
+                    if (!target)
+                        return false;
+                    basepoints0 = triggerAmount * damage / 100;
+                    triggered_spell_id = 58879;
+                    break;
+                }
+                // Shaman T8 Elemental 4P Bonus
+                case 64928:
+                {
+                    basepoints0 = int32(triggerAmount * damage / 100);
+                    triggered_spell_id = 64930;            // Electrified
+                    break;
+                }
+                // Shaman T9 Elemental 4P Bonus
+                case 67228:
+                {
+                    // Lava Burst
+                    if (procSpell->SpellFamilyFlags[1] & 0x1000)
+                    {
+                        triggered_spell_id = 71824;
+                        SpellEntry const* triggeredSpell = sSpellStore.LookupEntry(triggered_spell_id);
+                        if (!triggeredSpell)
+                            return false;
+                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(triggeredSpell) / triggeredSpell->EffectAmplitude[0]));
+                    }
+                    break;
+                }
+                // Item - Shaman T10 Restoration 4P Bonus
+                case 70808:
+                {
+                    // Chain Heal
+                    if((procSpell->SpellFamilyFlags[0] & 0x100) && (procEx & PROC_EX_CRITICAL_HIT))
+                    {
+                        triggered_spell_id = 70809;
+                        SpellEntry const* triggeredSpell = sSpellStore.LookupEntry(triggered_spell_id);
+                        if (!triggeredSpell)
+                            return false;
+                        basepoints0 = int32(triggerAmount * damage / 100 / (GetSpellMaxDuration(triggeredSpell) / triggeredSpell->EffectAmplitude[0]));
+                    }
+                    break;
+                }
+                // Item - Shaman T10 Elemental 2P Bonus
+                case 70811:
+                {
+                    // Lightning Bolt & Chain Lightning
+                    if(procSpell->SpellFamilyFlags[0] & 0x3)
+                    {
+                        if (ToPlayer()->HasSpellCooldown(16166))
+                        {
+                            uint32 newCooldownDelay = ToPlayer()->GetSpellCooldownDelay(16166);
+                            if (newCooldownDelay < 3)
+                                newCooldownDelay = 0;
+                            else
+                                newCooldownDelay -= 2;
+                            ToPlayer()->AddSpellCooldown(16166,0, uint32(time(NULL) + newCooldownDelay));
+
+                            WorldPacket data(SMSG_MODIFY_COOLDOWN, 4+8+4);
+                            data << uint32(16166);                  // Spell ID
+                            data << uint64(GetGUID());              // Player GUID
+                            data << int32(-2000);                   // Cooldown mod in milliseconds
+                            ToPlayer()->GetSession()->SendPacket(&data);
+                            return true;
+                        }
+                    }
+                    return false;
+                }
+                case 63280: // Glyph of Totem of Wrath
+                {
+                    if (procSpell->SpellIconID != 2019)
+                        return false;
+
+                    AuraEffect * aurEffA = NULL;
+                    AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
+                    for (AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
+                    {
+                        SpellEntry const *spell = (*i)->GetSpellProto();
+                        if (spell->SpellFamilyName == uint32(SPELLFAMILY_SHAMAN) && spell->SpellFamilyFlags.HasFlag(0, 0x02000000, 0))
+                        {
+                            if ((*i)->GetCasterGUID() != GetGUID())
+                                continue;
+                            if (spell->Id == 63283)
+                                continue;
+                            aurEffA = (*i);
+                            break;
+                        }
+                    }
+                    if (aurEffA)
+                    {
+                        int32 bp0 = 0, bp1 = 0;
+                        bp0 = aurEffA->GetAmount() * triggerAmount / 100;
+                        if (AuraEffect * aurEffB = aurEffA->GetBase()->GetEffect(EFFECT_1))
+                            bp1 = aurEffB->GetAmount() * triggerAmount / 100;
+                        CastCustomSpell(this, 63283, &bp0, &bp1, NULL, true, NULL, triggeredByAura);
+                        return true;
+                    }
+                    return false;
+                }
+                break;
+            }
+            // Frozen Power
+            if (dummySpell->SpellIconID == 3780)
+            {
+                if (this->GetDistance(target) < 15.0f)
+                    return false;
+                float chance = (float)triggerAmount;
+                if (!roll_chance_f(chance))
+                    return false;
+
+                triggered_spell_id = 63685;
+                break;
+            }
+            // Storm, Earth and Fire
+            if (dummySpell->SpellIconID == 3063)
+            {
+                // Earthbind Totem summon only
+                if (procSpell->Id != 2484)
+                    return false;
+
+                float chance = (float)triggerAmount;
+                if (!roll_chance_f(chance))
+                    return false;
+
+                triggered_spell_id = 64695;
+                break;
+            }
+            // Ancestral Awakening
+            if (dummySpell->SpellIconID == 3065)
+            {
+                triggered_spell_id = 52759;
+                basepoints0 = triggerAmount * damage / 100;
+                target = this;
+                break;
+            }
+            // Earth Shield
+            if (dummySpell->SpellFamilyFlags[1] & 0x00000400)
+            {
+                // 3.0.8: Now correctly uses the Shaman's own spell critical strike chance to determine the chance of a critical heal.
+                originalCaster = triggeredByAura->GetCasterGUID();
+                target = this;
+                basepoints0 = triggerAmount;
+
+                // Glyph of Earth Shield
+                if (AuraEffect* aur = GetAuraEffect(63279,0))
+                {
+                    int32 aur_mod = aur->GetAmount();
+                    basepoints0 = int32(basepoints0 * (aur_mod + 100.0f) / 100.0f);
+                }
+                triggered_spell_id = 379;
+                break;
+            }
+            // Flametongue Weapon (Passive)
+            if (dummySpell->SpellFamilyFlags[0] & 0x200000)
+            {
+                if (GetTypeId() != TYPEID_PLAYER  || !pVictim || !pVictim->isAlive() || !castItem || !castItem->IsEquipped())
+                    return false;
+
+                float fire_onhit = (float)(SpellMgr::CalculateSpellEffectAmount(dummySpell, 0) / 100.0);
+
+                float add_spellpower = (float)(SpellBaseDamageBonus(SPELL_SCHOOL_MASK_FIRE)
+                                     + SpellBaseDamageBonusForVictim(SPELL_SCHOOL_MASK_FIRE, pVictim));
+
+                // 1.3speed = 5%, 2.6speed = 10%, 4.0 speed = 15%, so, 1.0speed = 3.84%
+                add_spellpower= add_spellpower / 100.0f * 3.84f;
+
+                // Enchant on Off-Hand and ready?
+                if (castItem->GetSlot() == EQUIPMENT_SLOT_OFFHAND && isAttackReady(OFF_ATTACK))
+                {
+                    float BaseWeaponSpeed = GetAttackTime(OFF_ATTACK)/1000.0f;
+
+                    // Value1: add the tooltip damage by swingspeed + Value2: add spelldmg by swingspeed
+                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));
+                    triggered_spell_id = 10444;
+                }
+
+                // Enchant on Main-Hand and ready?
+                else if (castItem->GetSlot() == EQUIPMENT_SLOT_MAINHAND && isAttackReady(BASE_ATTACK))
+                {
+                    float BaseWeaponSpeed = GetAttackTime(BASE_ATTACK)/1000.0f;
+
+                    // Value1: add the tooltip damage by swingspeed +  Value2: add spelldmg by swingspeed
+                    basepoints0 = int32((fire_onhit * BaseWeaponSpeed) + (add_spellpower * BaseWeaponSpeed));
+                    triggered_spell_id = 10444;
+                }
+
+                // If not ready, we should  return, shouldn't we?!
+                else
+                    return false;
+
+                CastCustomSpell(pVictim,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+                return true;
+            }
+            // Improved Water Shield
+            if (dummySpell->SpellIconID == 2287)
+            {
+                // Default chance for Healing Wave and Riptide
+                float chance = (float)triggeredByAura->GetAmount();
+
+                if (procSpell->SpellFamilyFlags[0] & 0x80)
+                    // Lesser Healing Wave - 0.6 of default
+                    chance *= 0.6f;
+                else if (procSpell->SpellFamilyFlags[0] & 0x100)
+                    // Chain heal - 0.3 of default
+                    chance *= 0.3f;
+
+                if (!roll_chance_f(chance))
+                    return false;
+
+                // Water Shield
+                if (AuraEffect const * aurEff = GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 0, 0x00000020, 0))
+                {
+                    uint32 spell = aurEff->GetSpellProto()->EffectTriggerSpell[aurEff->GetEffIndex()];
+                    CastSpell(this, spell, true, castItem, triggeredByAura);
+                    return true;
+                }
+                return false;
+            }
+            // Lightning Overload
+            if (dummySpell->SpellIconID == 2018)            // only this spell have SpellFamily Shaman SpellIconID == 2018 and dummy aura
+            {
+                if (!procSpell || GetTypeId() != TYPEID_PLAYER || !pVictim)
+                    return false;
+
+                // custom cooldown processing case
+                if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(dummySpell->Id))
+                    return false;
+
+                uint32 spellId = 0;
+                // Every Lightning Bolt and Chain Lightning spell have duplicate vs half damage and zero cost
+                switch (procSpell->Id)
+                {
+                    // Lightning Bolt
+                    case   403: spellId = 45284; break;     // Rank  1
+                    case   529: spellId = 45286; break;     // Rank  2
+                    case   548: spellId = 45287; break;     // Rank  3
+                    case   915: spellId = 45288; break;     // Rank  4
+                    case   943: spellId = 45289; break;     // Rank  5
+                    case  6041: spellId = 45290; break;     // Rank  6
+                    case 10391: spellId = 45291; break;     // Rank  7
+                    case 10392: spellId = 45292; break;     // Rank  8
+                    case 15207: spellId = 45293; break;     // Rank  9
+                    case 15208: spellId = 45294; break;     // Rank 10
+                    case 25448: spellId = 45295; break;     // Rank 11
+                    case 25449: spellId = 45296; break;     // Rank 12
+                    case 49237: spellId = 49239; break;     // Rank 13
+                    case 49238: spellId = 49240; break;     // Rank 14
+                    // Chain Lightning
+                    case   421: spellId = 45297; break;     // Rank  1
+                    case   930: spellId = 45298; break;     // Rank  2
+                    case  2860: spellId = 45299; break;     // Rank  3
+                    case 10605: spellId = 45300; break;     // Rank  4
+                    case 25439: spellId = 45301; break;     // Rank  5
+                    case 25442: spellId = 45302; break;     // Rank  6
+                    case 49270: spellId = 49268; break;     // Rank  7
+                    case 49271: spellId = 49269; break;     // Rank  8
+                    default:
+                        sLog.outError("Unit::HandleDummyAuraProc: non handled spell id: %u (LO)", procSpell->Id);
+                        return false;
+                }
+
+                // Chain Lightning
+                if (procSpell->SpellFamilyFlags[0] & 0x2)
+                {
+                    // Chain lightning has [LightOverload_Proc_Chance] / [Max_Number_of_Targets] chance to proc of each individual target hit.
+                    // A maxed LO would have a 33% / 3 = 11% chance to proc of each target.
+                    // LO chance was already "accounted" at the proc chance roll, now need to divide the chance by [Max_Number_of_Targets]
+                    float chance = 100.0f / procSpell->EffectChainTarget[effIndex];
+                    if (!roll_chance_f(chance))
+                        return false;
+
+                    // Remove cooldown (Chain Lightning - have Category Recovery time)
+                    ToPlayer()->RemoveSpellCooldown(spellId);
+                }
+
+                CastSpell(pVictim, spellId, true, castItem, triggeredByAura);
+
+                if (cooldown && GetTypeId() == TYPEID_PLAYER)
+                    ToPlayer()->AddSpellCooldown(dummySpell->Id, 0, time(NULL) + cooldown);
+
+                return true;
+            }
+            // Static Shock
+            if (dummySpell->SpellIconID == 3059)
+            {
+                // Lightning Shield
+                if (AuraEffect const * aurEff = GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_SHAMAN, 0x400, 0, 0))
+                {
+                    uint32 spell = sSpellMgr.GetSpellWithRank(26364, sSpellMgr.GetSpellRank(aurEff->GetId()));
+
+                    // custom cooldown processing case
+                    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(spell))
+                        ToPlayer()->RemoveSpellCooldown(spell);
+
+                    CastSpell(target, spell, true, castItem, triggeredByAura);
+                    aurEff->GetBase()->DropCharge();
+                    return true;
+                }
+                return false;
+            }
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Blood-Caked Strike - Blood-Caked Blade
+            if (dummySpell->SpellIconID == 138)
+            {
+                if (!target || !target->isAlive())
+                    return false;
+
+                triggered_spell_id = dummySpell->EffectTriggerSpell[effIndex];
+                break;
+            }
+            // Improved Blood Presence
+            if (dummySpell->SpellIconID == 2636)
+            {
+                if (GetTypeId() != TYPEID_PLAYER)
+                    return false;
+                basepoints0 = triggerAmount * damage / 100;
+                break;
+            }
+            // Butchery
+            if (dummySpell->SpellIconID == 2664)
+            {
+                basepoints0 = triggerAmount;
+                triggered_spell_id = 50163;
+                target = this;
+                break;
+            }
+            // Dancing Rune Weapon
+            if (dummySpell->Id == 49028)
+            {
+                // 1 dummy aura for dismiss rune blade
+                if (effIndex != 1)
+                    return false;
+
+                Unit* pPet = NULL;
+                for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr) //Find Rune Weapon
+                    if ((*itr)->GetEntry() == 27893)
+                    {
+                        pPet = (*itr);
+                        break;
+                    }
+
+                if (pPet && pPet->getVictim() && damage && procSpell)
+                {
+                    uint32 procDmg = damage / 2;
+                    pPet->SendSpellNonMeleeDamageLog(pPet->getVictim(),procSpell->Id,procDmg,GetSpellSchoolMask(procSpell),0,0,false,0,false);
+                    pPet->DealDamage(pPet->getVictim(),procDmg,NULL,SPELL_DIRECT_DAMAGE,GetSpellSchoolMask(procSpell),procSpell,true);
+                    break;
+                }
+                else
+                    return false;
+            }
+            // Mark of Blood
+            if (dummySpell->Id == 49005)
+            {
+                // TODO: need more info (cooldowns/PPM)
+                triggered_spell_id = 61607;
+                break;
+            }
+            // Unholy Blight
+            if (dummySpell->Id == 49194)
+            {
+                basepoints0 = triggerAmount * damage / 100;
+                // Glyph of Unholy Blight
+                if (AuraEffect *glyph=GetAuraEffect(63332,0))
+                    basepoints0 += basepoints0 * glyph->GetAmount() / 100;
+                // Find replaced aura to use it's remaining amount
+                AuraEffectList const& DoTAuras = target->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
+                for (Unit::AuraEffectList::const_iterator i = DoTAuras.begin(); i != DoTAuras.end(); ++i)
+                {
+                     if ((*i)->GetCasterGUID() != GetGUID() || (*i)->GetId() != 50536)
+                         continue;
+                     basepoints0 += ((*i)->GetAmount() * ((*i)->GetTotalTicks() - ((*i)->GetTickNumber()))) / (*i)->GetTotalTicks();
+                     break;
+                }
+
+                triggered_spell_id = 50536;
+                break;
+            }
+            // Vendetta
+            if (dummySpell->SpellFamilyFlags[0] & 0x10000)
+            {
+                basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
+                triggered_spell_id = 50181;
+                target = this;
+                break;
+            }
+            // Necrosis
+            if (dummySpell->SpellIconID == 2709)
+            {
+                basepoints0 = triggerAmount * damage / 100;
+                triggered_spell_id = 51460;
+                break;
+            }
+            // Threat of Thassarian
+            if (dummySpell->SpellIconID == 2023)
+            {
+                // Must Dual Wield
+                if (!procSpell || !haveOffhandWeapon())
+                    return false;
+                // Chance as basepoints for dummy aura
+                if (!roll_chance_i(triggerAmount))
+                    return false;
+
+                switch (procSpell->Id)
+                {
+                    // Obliterate
+                    case 49020: triggered_spell_id = 66198; break;                            // Rank 1
+                    case 51423: triggered_spell_id = 66972; break;                            // Rank 2
+                    case 51424: triggered_spell_id = 66973; break;                            // Rank 3
+                    case 51425: triggered_spell_id = 66974; break;                            // Rank 4
+
+                    // Frost Strike
+                    case 49143: triggered_spell_id = 66196; break;                            // Rank 1
+                    case 51416: triggered_spell_id = 66958; break;                            // Rank 2
+                    case 51417: triggered_spell_id = 66959; break;                            // Rank 3
+                    case 51418: triggered_spell_id = 66960; break;                            // Rank 4
+                    case 51419: triggered_spell_id = 66961; break;                            // Rank 5
+                    case 55268: triggered_spell_id = 66962; break;                            // Rank 6
+
+                    // Plague Strike
+                    case 45462: triggered_spell_id = 66216; break;                            // Rank 1
+                    case 49917: triggered_spell_id = 66988; break;                            // Rank 2
+                    case 49918: triggered_spell_id = 66989; break;                            // Rank 3
+                    case 49919: triggered_spell_id = 66990; break;                            // Rank 4
+                    case 49920: triggered_spell_id = 66991; break;                            // Rank 5
+                    case 49921: triggered_spell_id = 66992; break;                            // Rank 6
+
+                    // Death Strike
+                    case 49998: triggered_spell_id = 66188; break;                            // Rank 1
+                    case 49999: triggered_spell_id = 66950; break;                            // Rank 2
+                    case 45463: triggered_spell_id = 66951; break;                            // Rank 3
+                    case 49923: triggered_spell_id = 66952; break;                            // Rank 4
+                    case 49924: triggered_spell_id = 66953; break;                            // Rank 5
+
+                    // Rune Strike
+                    case 56815: triggered_spell_id = 66217; break;                            // Rank 1
+
+                    // Blood Strike
+                    case 45902: triggered_spell_id = 66215; break;                            // Rank 1
+                    case 49926: triggered_spell_id = 66975; break;                            // Rank 2
+                    case 49927: triggered_spell_id = 66976; break;                            // Rank 3
+                    case 49928: triggered_spell_id = 66977; break;                            // Rank 4
+                    case 49929: triggered_spell_id = 66978; break;                            // Rank 5
+                    case 49930: triggered_spell_id = 66979; break;                            // Rank 6
+                    default:
+                        return false;
+                }
+                break;
+            }
+            // Runic Power Back on Snare/Root
+            if (dummySpell->Id == 61257)
+            {
+                // only for spells and hit/crit (trigger start always) and not start from self casted spells
+                if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == pVictim)
+                    return false;
+                // Need snare or root mechanic
+                if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_ROOT)|(1<<MECHANIC_SNARE))))
+                    return false;
+                triggered_spell_id = 61258;
+                target = this;
+                break;
+            }
+            // Wandering Plague
+            if (dummySpell->SpellIconID == 1614)
+            {
+                if (!roll_chance_f(GetUnitCriticalChance(BASE_ATTACK, pVictim)))
+                    return false;
+                basepoints0 = triggerAmount * damage / 100;
+                triggered_spell_id = 50526;
+                break;
+            }
+            // Sudden Doom
+            if (dummySpell->SpellIconID == 1939 && GetTypeId() == TYPEID_PLAYER)
+            {
+                SpellChainNode const* chain = NULL;
+                // get highest rank of the Death Coil spell
+                const PlayerSpellMap& sp_list = this->ToPlayer()->GetSpellMap();
+                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
+                {
+                    // check if shown in spell book
+                    if (!itr->second->active || itr->second->disabled || itr->second->state == PLAYERSPELL_REMOVED)
+                        continue;
+
+                    SpellEntry const *spellProto = sSpellStore.LookupEntry(itr->first);
+                    if (!spellProto)
+                        continue;
+
+                    if (spellProto->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT
+                        && spellProto->SpellFamilyFlags[0] & 0x2000)
+                    {
+                        SpellChainNode const* newChain = sSpellMgr.GetSpellChainNode(itr->first);
+
+                        // No chain entry or entry lower than found entry
+                        if (!chain || !newChain || (chain->rank < newChain->rank))
+                        {
+                            triggered_spell_id = itr->first;
+                            chain = newChain;
+                        }
+                        else
+                            continue;
+                        // Found spell is last in chain - do not need to look more
+                        // Optimisation for most common case
+                        if (chain && chain->last == itr->first)
+                            break;
+                    }
+                }
+            }
+            // Item - Death Knight T10 Melee 4P Bonus
+            if (dummySpell->Id == 70656)
+            {
+                if (!this->ToPlayer())
+                    return false;
+
+                for (uint32 i = 0; i < MAX_RUNES; ++i)
+                    if (this->ToPlayer()->GetRuneCooldown(i) == 0)
+                        return false;
+            }
+            break;
+        }
+        case SPELLFAMILY_POTION:
+        {
+            // alchemist's stone
+            if (dummySpell->Id == 17619)
+            {
+                if (procSpell->SpellFamilyName == SPELLFAMILY_POTION)
+                {
+                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; i++)
+                    {
+                        if (procSpell->Effect[i] == SPELL_EFFECT_HEAL)
+                        {
+                            triggered_spell_id = 21399;
+                        }
+                        else if (procSpell->Effect[i] == SPELL_EFFECT_ENERGIZE)
+                        {
+                            triggered_spell_id = 21400;
+                        }
+                        else
+                            continue;
+
+                        basepoints0 = int32(CalculateSpellDamage(this, procSpell,i) * 0.4f);
+                        CastCustomSpell(this,triggered_spell_id,&basepoints0,NULL,NULL,true,NULL,triggeredByAura);
+                    }
+                    return true;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_PET:
+        {
+            switch (dummySpell->SpellIconID)
+            {
+                // Guard Dog
+                case 201:
+                {
+                    triggered_spell_id = 54445;
+                    target = this;
+                    float addThreat = SpellMgr::CalculateSpellEffectAmount(procSpell, 0, this) * triggerAmount / 100.0f;
+                    pVictim->AddThreat(this, addThreat);
+                    break;
+                }
+                // Silverback
+                case 1582:
+                    triggered_spell_id = dummySpell->Id == 62765 ? 62801 : 62800;
+                    target = this;
+                    break;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    // if not handled by custom case, get triggered spell from dummySpell proto
+    if (!triggered_spell_id)
+        triggered_spell_id = dummySpell->EffectTriggerSpell[triggeredByAura->GetEffIndex()];
+
+    // processed charge only counting case
+    if (!triggered_spell_id)
+        return true;
+
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
+    if (!triggerEntry)
+    {
+        sLog.outError("Unit::HandleDummyAuraProc: Spell %u have not existed triggered spell %u",dummySpell->Id,triggered_spell_id);
+        return false;
+    }
+
+    // default case
+    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
+        return false;
+
+    if (cooldown_spell_id == 0)
+        cooldown_spell_id = triggered_spell_id;
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(cooldown_spell_id))
+        return false;
+
+    if (basepoints0)
+        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura, originalCaster);
+    else
+        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura, originalCaster);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->AddSpellCooldown(cooldown_spell_id,0,time(NULL) + cooldown);
+
+    return true;
+}
+bool Unit::HandleObsModEnergyAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
+{
+    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto ();
+    //uint32 effIndex = triggeredByAura->GetEffIndex();
+    //int32  triggerAmount = triggeredByAura->GetAmount();
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+    Unit* target = pVictim;
+    int32 basepoints0 = 0;
+
+    switch(dummySpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_HUNTER:
+        {
+            // Aspect of the Viper
+            if (dummySpell->SpellFamilyFlags[1] & 0x40000)
+            {
+                uint32 maxmana = GetMaxPower(POWER_MANA);
+                basepoints0 = uint32(maxmana* GetAttackTime(RANGED_ATTACK)/1000.0f/100.0f);
+                target = this;
+                triggered_spell_id = 34075;
+                break;
+            }
+            break;
+        }
+    }
+    // processed charge only counting case
+    if (!triggered_spell_id)
+        return true;
+
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
+
+    // Try handle unknown trigger spells
+    if (!triggerEntry)
+    {
+        sLog.outError("Unit::HandleObsModEnergyAuraProc: Spell %u have not existed triggered spell %u",dummySpell->Id,triggered_spell_id);
+        return false;
+    }
+
+    // default case
+    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
+        return false;
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
+        return false;
+    if (basepoints0)
+        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+    else
+        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
+    return true;
+}
+bool Unit::HandleModDamagePctTakenAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect* triggeredByAura, SpellEntry const * /*procSpell*/, uint32 /*procFlag*/, uint32 /*procEx*/, uint32 cooldown)
+{
+    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto ();
+    //uint32 effIndex = triggeredByAura->GetEffIndex();
+    //int32  triggerAmount = triggeredByAura->GetAmount();
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+    Unit* target = pVictim;
+    int32 basepoints0 = 0;
+
+    switch(dummySpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_PALADIN:
+        {
+            // Blessing of Sanctuary
+            if (dummySpell->SpellFamilyFlags[0] & 0x10000000)
+            {
+                switch (getPowerType())
+                {
+                    case POWER_MANA:   triggered_spell_id = 57319; break;
+                    default:
+                        return false;
+                }
+            }
+            break;
+        }
+    }
+    // processed charge only counting case
+    if (!triggered_spell_id)
+        return true;
+
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!triggerEntry)
+    {
+        sLog.outError("Unit::HandleModDamagePctTakenAuraProc: Spell %u have not existed triggered spell %u",dummySpell->Id,triggered_spell_id);
+        return false;
+    }
+
+    // default case
+    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
+        return false;
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
+        return false;
+
+    if (basepoints0)
+        CastCustomSpell(target,triggered_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+    else
+        CastSpell(target,triggered_spell_id,true,castItem,triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
+
+    return true;
+}
+
+// Used in case when access to whole aura is needed
+// All procs should be handled like this...
+bool Unit::HandleAuraProc(Unit * pVictim, uint32 damage, Aura * triggeredByAura, SpellEntry const * procSpell, uint32 /*procFlag*/, uint32 procEx, uint32 /*cooldown*/, bool * handled)
+{
+    SpellEntry const *dummySpell = triggeredByAura->GetSpellProto();
+
+    switch(dummySpell->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+            switch (dummySpell->Id)
+            {
+                // Nevermelting Ice Crystal
+                case 71564:
+                    RemoveAuraFromStack(71564);
+                    *handled = true;
+                    break;
+            }
+            break;
+        case SPELLFAMILY_PALADIN:
+        {
+            // Infusion of Light
+            if (dummySpell->SpellIconID == 3021)
+            {
+                // Flash of Light HoT on Flash of Light when Sacred Shield active
+                if (procSpell->SpellFamilyFlags[0] & 0x40000000 && procSpell->SpellIconID == 242)
+                {
+                    *handled = true;
+                    if (pVictim->HasAura(53601))
+                    {
+                        int32 bp0 = (damage/12) * SpellMgr::CalculateSpellEffectAmount(dummySpell, 2)/100;
+                        CastCustomSpell(pVictim, 66922, &bp0, NULL, NULL, true);
+                        return true;
+                    }
+                }
+                // but should not proc on non-critical Holy Shocks
+                else if ((procSpell->SpellFamilyFlags[0] & 0x200000 || procSpell->SpellFamilyFlags[1] & 0x10000) && !(procEx & PROC_EX_CRITICAL_HIT))
+                    *handled = true;
+                break;
+            }
+            break;
+        }
+        case SPELLFAMILY_MAGE:
+        {
+            // Combustion
+            switch (dummySpell->Id)
+            {
+                case 11129:
+                {
+                    *handled = true;
+                    Unit *caster = triggeredByAura->GetCaster();
+                    if (!caster || !damage)
+                        return false;
+
+                    //last charge and crit
+                    if (triggeredByAura->GetCharges() <= 1 && (procEx & PROC_EX_CRITICAL_HIT))
+                    {
+                        RemoveAurasDueToSpell(28682);       //-> remove Combustion auras
+                        return true;                        // charge counting (will removed)
+                    }
+
+                    // This function can be called twice during one spell hit (Area of Effect spells)
+                    // Make sure 28682 wasn't already removed by previous call
+                    if (HasAura(28682))
+                        this->CastSpell(this, 28682, true);
+
+                    return false; // ordinary chrages will be removed during crit chance computations.
+                }
+                // Empowered Fire
+                case 31656:
+                case 31657:
+                case 31658:
+                {
+                    *handled = true;
+
+                    SpellEntry const *spInfo = sSpellStore.LookupEntry(67545);
+                    if (!spInfo)
+                        return false;
+
+                    int32 bp0 = this->GetCreateMana() * SpellMgr::CalculateSpellEffectAmount(spInfo, 0) / 100;
+                    this->CastCustomSpell(this, 67545, &bp0, NULL, NULL, true, NULL, triggeredByAura->GetEffect(0), this->GetGUID());
+                    return true;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Blood of the North
+            // Reaping
+            // Death Rune Mastery
+            if (dummySpell->SpellIconID == 3041 || dummySpell->SpellIconID == 22 || dummySpell->SpellIconID == 2622)
+            {
+                *handled = true;
+                // Convert recently used Blood Rune to Death Rune
+                if (GetTypeId() == TYPEID_PLAYER)
+                {
+                    if (this->ToPlayer()->getClass() != CLASS_DEATH_KNIGHT)
+                        return false;
+                    RuneType rune = this->ToPlayer()->GetLastUsedRune();
+                    // can't proc from death rune use
+                    if (rune == RUNE_DEATH)
+                        return false;
+                    AuraEffect * aurEff = triggeredByAura->GetEffect(0);
+                    if (!aurEff)
+                        return false;
+                    // Reset amplitude - set death rune remove timer to 30s
+                    aurEff->ResetPeriodic(true);
+                    uint32 runesLeft;
+
+                    if (dummySpell->SpellIconID == 2622)
+                        runesLeft = 2;
+                    else
+                        runesLeft = 1;
+
+                    for (uint8 i=0; i < MAX_RUNES && runesLeft; ++i)
+                    {
+                        if (dummySpell->SpellIconID == 2622)
+                        {
+                            if (((Player*)this)->GetCurrentRune(i) == RUNE_DEATH ||
+                                ((Player*)this)->GetBaseRune(i) == RUNE_BLOOD)
+                                continue;
+                        }
+                        else
+                        {
+                            if (((Player*)this)->GetCurrentRune(i) == RUNE_DEATH ||
+                                ((Player*)this)->GetBaseRune(i) != RUNE_BLOOD)
+                                continue;
+                        }
+                        if (((Player*)this)->GetRuneCooldown(i) != ((Player*)this)->GetRuneBaseCooldown(i))
+                            continue;
+
+                        --runesLeft;
+                        // Mark aura as used
+                        ((Player*)this)->AddRuneByAuraEffect(i, RUNE_DEATH, aurEff);
+                    }
+                    return true;
+                }
+                return false;
+            }
+
+            switch(dummySpell->Id)
+            {
+                // Hungering Cold aura drop
+                case 51209:
+                    *handled = true;
+                    // Drop only in not disease case
+                    if (procSpell && procSpell->Dispel == DISPEL_DISEASE)
+                        return false;
+                    return true;
+            }
+            break;
+        }
+    }
+    return false;
+}
+
+bool Unit::HandleProcTriggerSpell(Unit *pVictim, uint32 damage, AuraEffect* triggeredByAura, SpellEntry const *procSpell, uint32 procFlags, uint32 procEx, uint32 cooldown)
+{
+    // Get triggered aura spell info
+    SpellEntry const* auraSpellInfo = triggeredByAura->GetSpellProto();
+
+    // Basepoints of trigger aura
+    int32 triggerAmount = triggeredByAura->GetAmount();
+
+    // Set trigger spell id, target, custom basepoints
+    uint32 trigger_spell_id = auraSpellInfo->EffectTriggerSpell[triggeredByAura->GetEffIndex()];
+
+    Unit*  target = NULL;
+    int32  basepoints0 = 0;
+
+    if (triggeredByAura->GetAuraType() == SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE)
+        basepoints0 = triggerAmount;
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    // Try handle unknown trigger spells
+    if (sSpellStore.LookupEntry(trigger_spell_id) == NULL)
+    {
+        switch (auraSpellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_GENERIC:
+                switch (auraSpellInfo->Id)
+                {
+                    case 23780:             // Aegis of Preservation (Aegis of Preservation trinket)
+                        trigger_spell_id = 23781;
+                        break;
+                    case 33896:             // Desperate Defense (Stonescythe Whelp, Stonescythe Alpha, Stonescythe Ambusher)
+                        trigger_spell_id = 33898;
+                        break;
+                    case 43820:             // Charm of the Witch Doctor (Amani Charm of the Witch Doctor trinket)
+                        // Pct value stored in dummy
+                        basepoints0 = pVictim->GetCreateHealth() * SpellMgr::CalculateSpellEffectAmount(auraSpellInfo, 1) / 100;
+                        target = pVictim;
+                        break;
+                    case 57345:             // Darkmoon Card: Greatness
+                    {
+                        float stat = 0.0f;
+                        // strength
+                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 60229;stat = GetStat(STAT_STRENGTH); }
+                        // agility
+                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 60233;stat = GetStat(STAT_AGILITY);  }
+                        // intellect
+                        if (GetStat(STAT_INTELLECT)> stat) { trigger_spell_id = 60234;stat = GetStat(STAT_INTELLECT);}
+                        // spirit
+                        if (GetStat(STAT_SPIRIT)   > stat) { trigger_spell_id = 60235;                               }
+                        break;
+                    }
+                    case 67702:             // Death's Choice, Item - Coliseum 25 Normal Melee Trinket
+                    {
+                        float stat = 0.0f;
+                        // strength
+                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67708;stat = GetStat(STAT_STRENGTH); }
+                        // agility
+                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67703;                               }
+                        break;
+                    }
+                    case 67771:             // Death's Choice (heroic), Item - Coliseum 25 Heroic Melee Trinket
+                    {
+                        float stat = 0.0f;
+                        // strength
+                        if (GetStat(STAT_STRENGTH) > stat) { trigger_spell_id = 67773;stat = GetStat(STAT_STRENGTH); }
+                        // agility
+                        if (GetStat(STAT_AGILITY)  > stat) { trigger_spell_id = 67772;                               }
+                        break;
+                    }
+                    // Mana Drain Trigger
+                    case 27522:
+                    case 40336:
+                    {
+                        // On successful melee or ranged attack gain $29471s1 mana and if possible drain $27526s1 mana from the target.
+                        if (this && this->isAlive())
+                            CastSpell(this, 29471, true, castItem, triggeredByAura);
+                        if (pVictim && pVictim->isAlive())
+                            CastSpell(pVictim, 27526, true, castItem, triggeredByAura);
+                        return true;
+                    }
+					  // Mark of the Fallen Champion
+                    case 72293:
+                        if(pVictim && pVictim->HasAura(72293) && !pVictim->isAlive())
+                        {
+                            Creature* saurfang = pVictim->FindNearestCreature(37813, 500.0f, true);
+                                if(saurfang && saurfang->isAlive())
+                                   saurfang->CastSpell(saurfang, 72260, true);
+                        }
+                        return true;
+
+                }
+                break;
+            case SPELLFAMILY_MAGE:
+                if (auraSpellInfo->SpellIconID == 2127)     // Blazing Speed
+                {
+                    switch (auraSpellInfo->Id)
+                    {
+                        case 31641:  // Rank 1
+                        case 31642:  // Rank 2
+                            trigger_spell_id = 31643;
+                            break;
+                        default:
+                            sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Blazing Speed",auraSpellInfo->Id);
+                            return false;
+                    }
+                }
+                break;
+            case SPELLFAMILY_WARRIOR:
+                if (auraSpellInfo->Id == 50421)             // Scent of Blood
+                    trigger_spell_id = 50422;
+                break;
+            case SPELLFAMILY_WARLOCK:
+            {
+                // Drain Soul
+                if (auraSpellInfo->SpellFamilyFlags[0] & 0x4000)
+                {
+                    // Improved Drain Soul
+                    Unit::AuraEffectList const& mAddFlatModifier = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+                    for (Unit::AuraEffectList::const_iterator i = mAddFlatModifier.begin(); i != mAddFlatModifier.end(); ++i)
+                    {
+                        if ((*i)->GetMiscValue() == SPELLMOD_CHANCE_OF_SUCCESS && (*i)->GetSpellProto()->SpellIconID == 113)
+                        {
+                            int32 value2 = CalculateSpellDamage(this, (*i)->GetSpellProto(),2);
+                            basepoints0 = value2 * GetMaxPower(POWER_MANA) / 100;
+                            // Drain Soul
+                            CastCustomSpell(this, 18371, &basepoints0, NULL, NULL, true, castItem, triggeredByAura);
+                            break;
+                        }
+                    }
+                    // Not remove charge (aura removed on death in any cases)
+                    // Need for correct work Drain Soul SPELL_AURA_CHANNEL_DEATH_ITEM aura
+                    return false;
+                }
+                // Nether Protection
+                else if (auraSpellInfo->SpellIconID == 1985)
+                {
+                    if (!procSpell)
+                        return false;
+                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
+                    {
+                        case SPELL_SCHOOL_NORMAL:
+                            return false;                   // ignore
+                        case SPELL_SCHOOL_HOLY:   trigger_spell_id = 54370; break;
+                        case SPELL_SCHOOL_FIRE:   trigger_spell_id = 54371; break;
+                        case SPELL_SCHOOL_NATURE: trigger_spell_id = 54375; break;
+                        case SPELL_SCHOOL_FROST:  trigger_spell_id = 54372; break;
+                        case SPELL_SCHOOL_SHADOW: trigger_spell_id = 54374; break;
+                        case SPELL_SCHOOL_ARCANE: trigger_spell_id = 54373; break;
+                        default:
+                            return false;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_PRIEST:
+            {
+                // Greater Heal Refund
+                if (auraSpellInfo->Id == 37594)
+                    trigger_spell_id = 37595;
+                // Blessed Recovery
+                else if (auraSpellInfo->SpellIconID == 1875)
+                {
+                    switch (auraSpellInfo->Id)
+                    {
+                        case 27811: trigger_spell_id = 27813; break;
+                        case 27815: trigger_spell_id = 27817; break;
+                        case 27816: trigger_spell_id = 27818; break;
+                        default:
+                            sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in BR", auraSpellInfo->Id);
+                        return false;
+                    }
+                    basepoints0 = damage * triggerAmount / 100 / 3;
+                    target = this;
+                }
+                break;
+            }
+            case SPELLFAMILY_DRUID:
+            {
+                // Druid Forms Trinket
+                if (auraSpellInfo->Id == 37336)
+                {
+                    switch(m_form)
+                    {
+                        case FORM_NONE:     trigger_spell_id = 37344;break;
+                        case FORM_CAT:      trigger_spell_id = 37341;break;
+                        case FORM_BEAR:
+                        case FORM_DIREBEAR: trigger_spell_id = 37340;break;
+                        case FORM_TREE:     trigger_spell_id = 37342;break;
+                        case FORM_MOONKIN:  trigger_spell_id = 37343;break;
+                        default:
+                            return false;
+                    }
+                }
+                // Druid T9 Feral Relic (Lacerate, Swipe, Mangle, and Shred)
+                else if (auraSpellInfo->Id == 67353)
+                {
+                    switch(m_form)
+                    {
+                        case FORM_CAT:      trigger_spell_id = 67355; break;
+                        case FORM_BEAR:
+                        case FORM_DIREBEAR: trigger_spell_id = 67354; break;
+                        default:
+                            return false;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_HUNTER:
+            {
+                if (auraSpellInfo->SpellIconID == 3247)     // Piercing Shots
+                {
+                    switch (auraSpellInfo->Id)
+                    {
+                        case 53234:  // Rank 1
+                        case 53237:  // Rank 2
+                        case 53238:  // Rank 3
+                            trigger_spell_id = 63468;
+                            break;
+                        default:
+                            sLog.outError("Unit::HandleProcTriggerSpell: Spell %u miss posibly Piercing Shots",auraSpellInfo->Id);
+                            return false;
+                    }
+                    SpellEntry const *TriggerPS = sSpellStore.LookupEntry(trigger_spell_id);
+                    if (!TriggerPS)
+                        return false;
+
+                    basepoints0 = int32(damage * triggerAmount / 100 / (GetSpellMaxDuration(TriggerPS) / TriggerPS->EffectAmplitude[0]));
+                    basepoints0 += pVictim->GetRemainingDotDamage(GetGUID(), trigger_spell_id);
+                    break;
+                }
+                break;
+            }
+            case SPELLFAMILY_PALADIN:
+            {
+                switch (auraSpellInfo->Id)
+                {
+                    // Healing Discount
+                    case 37705:
+                    {
+                        trigger_spell_id = 37706;
+                        target = this;
+                        break;
+                    }
+                    // Soul Preserver
+                    case 60510:
+                    {
+                        trigger_spell_id = 60515;
+                        target = this;
+                        break;
+                    }
+                    // Lightning Capacitor
+                    case 37657:
+                    {
+                        if (!pVictim || !pVictim->isAlive())
+                            return false;
+                        // stacking
+                        CastSpell(this, 37658, true, NULL, triggeredByAura);
+
+                        Aura * dummy = GetAura(37658);
+                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
+                        if (!dummy || dummy->GetStackAmount() < triggerAmount)
+                            return false;
+
+                        RemoveAurasDueToSpell(37658);
+                        trigger_spell_id = 37661;
+                        target = pVictim;
+                        break;
+                    }
+                    // Thunder Capacitor
+                    case 54841:
+                    {
+                        if (!pVictim || !pVictim->isAlive())
+                            return false;
+                        // stacking
+                        CastSpell(this, 54842, true, NULL, triggeredByAura);
+
+                        // counting
+                        Aura * dummy = GetAura(54842);
+                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
+                        if (!dummy || dummy->GetStackAmount() < triggerAmount)
+                            return false;
+
+                        RemoveAurasDueToSpell(54842);
+                        trigger_spell_id = 54843;
+                        target = pVictim;
+                        break;
+                    }
+                    //Item - Coliseum 25 Normal Caster Trinket
+                    case 67712:
+                    {
+                        if(!pVictim || !pVictim->isAlive())
+                            return false;
+                        // stacking
+                        CastSpell(this, 67713, true, NULL, triggeredByAura);
+
+                        Aura * dummy = GetAura(67713);
+                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
+                        if(!dummy || dummy->GetStackAmount() < triggerAmount)
+                            return false;
+
+                        RemoveAurasDueToSpell(67713);
+                        trigger_spell_id = 67714;
+                        target = pVictim;
+                        break;
+                    }
+                    //Item - Coliseum 25 Heroic Caster Trinket
+                    case 67758:
+                    {
+                        if(!pVictim || !pVictim->isAlive())
+                            return false;
+                        // stacking
+                        CastSpell(this, 67759, true, NULL, triggeredByAura);
+
+                        Aura * dummy = GetAura(67759);
+                        // release at 3 aura in stack (cont contain in basepoint of trigger aura)
+                        if(!dummy || dummy->GetStackAmount() < triggerAmount)
+                            return false;
+
+                        RemoveAurasDueToSpell(67759);
+                        trigger_spell_id = 67760;
+                        target = pVictim;
+                        break;
+                    }
+                    default:
+                        // Illumination
+                        if (auraSpellInfo->SpellIconID == 241)
+                        {
+                            if (!procSpell)
+                                return false;
+                            // procspell is triggered spell but we need mana cost of original casted spell
+                            uint32 originalSpellId = procSpell->Id;
+                            // Holy Shock heal
+                            if (procSpell->SpellFamilyFlags[1] & 0x00010000)
+                            {
+                                switch(procSpell->Id)
+                                {
+                                    case 25914: originalSpellId = 20473; break;
+                                    case 25913: originalSpellId = 20929; break;
+                                    case 25903: originalSpellId = 20930; break;
+                                    case 27175: originalSpellId = 27174; break;
+                                    case 33074: originalSpellId = 33072; break;
+                                    case 48820: originalSpellId = 48824; break;
+                                    case 48821: originalSpellId = 48825; break;
+                                    default:
+                                        sLog.outError("Unit::HandleProcTriggerSpell: Spell %u not handled in HShock",procSpell->Id);
+                                       return false;
+                                }
+                            }
+                            SpellEntry const *originalSpell = sSpellStore.LookupEntry(originalSpellId);
+                            if (!originalSpell)
+                            {
+                                sLog.outError("Unit::HandleProcTriggerSpell: Spell %u unknown but selected as original in Illu",originalSpellId);
+                                return false;
+                            }
+                            // percent stored in effect 1 (class scripts) base points
+                            int32 cost = originalSpell->manaCost + originalSpell->ManaCostPercentage * GetCreateMana() / 100;
+                            basepoints0 = cost*SpellMgr::CalculateSpellEffectAmount(auraSpellInfo, 1)/100;
+                            trigger_spell_id = 20272;
+                            target = this;
+                        }
+                        break;
+                }
+                break;
+            }
+            case SPELLFAMILY_SHAMAN:
+            {
+                switch (auraSpellInfo->Id)
+                {
+                    // Lightning Shield (The Ten Storms set)
+                    case 23551:
+                    {
+                        trigger_spell_id = 23552;
+                        target = pVictim;
+                        break;
+                    }
+                    // Damage from Lightning Shield (The Ten Storms set)
+                    case 23552:
+                    {
+                        trigger_spell_id = 27635;
+                        break;
+                    }
+                    // Mana Surge (The Earthfury set)
+                    case 23572:
+                    {
+                        if (!procSpell)
+                            return false;
+                        basepoints0 = procSpell->manaCost * 35 / 100;
+                        trigger_spell_id = 23571;
+                        target = this;
+                        break;
+                    }
+                    default:
+                    {
+                        // Lightning Shield (overwrite non existing triggered spell call in spell.dbc
+                        if (auraSpellInfo->SpellFamilyFlags[0] & 0x400)
+                        {
+                            trigger_spell_id = sSpellMgr.GetSpellWithRank(26364, sSpellMgr.GetSpellRank(auraSpellInfo->Id));
+                        }
+                        // Nature's Guardian
+                        else if (auraSpellInfo->SpellIconID == 2013)
+                        {
+                            // Check health condition - should drop to less 30% (damage deal after this!)
+                            if (!HealthBelowPctDamaged(30, damage))
+                                return false;
+
+                             if (pVictim && pVictim->isAlive())
+                                 pVictim->getThreatManager().modifyThreatPercent(this,-10);
+
+                            basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
+                            trigger_spell_id = 31616;
+                            target = this;
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_DEATHKNIGHT:
+            {
+                // Acclimation
+                if (auraSpellInfo->SpellIconID == 1930)
+                {
+                    if (!procSpell)
+                        return false;
+                    switch(GetFirstSchoolInMask(GetSpellSchoolMask(procSpell)))
+                    {
+                        case SPELL_SCHOOL_NORMAL:
+                            return false;                   // ignore
+                        case SPELL_SCHOOL_HOLY:   trigger_spell_id = 50490; break;
+                        case SPELL_SCHOOL_FIRE:   trigger_spell_id = 50362; break;
+                        case SPELL_SCHOOL_NATURE: trigger_spell_id = 50488; break;
+                        case SPELL_SCHOOL_FROST:  trigger_spell_id = 50485; break;
+                        case SPELL_SCHOOL_SHADOW: trigger_spell_id = 50489; break;
+                        case SPELL_SCHOOL_ARCANE: trigger_spell_id = 50486; break;
+                        default:
+                            return false;
+                    }
+                }
+                // Blood Presence (Improved)
+                else if (auraSpellInfo->Id == 63611)
+                {
+                    if (GetTypeId() != TYPEID_PLAYER)
+                        return false;
+
+                    trigger_spell_id = 50475;
+                    basepoints0 = damage * triggerAmount / 100;
+                }
+                break;
+            }
+            default:
+                 break;
+        }
+    }
+
+    // All ok. Check current trigger spell
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(trigger_spell_id);
+    if (triggerEntry == NULL)
+    {
+        // Not cast unknown spell
+        // sLog.outError("Unit::HandleProcTriggerSpell: Spell %u have 0 in EffectTriggered[%d], not handled custom case?",auraSpellInfo->Id,triggeredByAura->GetEffIndex());
+        return false;
+    }
+
+    // not allow proc extra attack spell at extra attack
+    if (m_extraAttacks && IsSpellHaveEffect(triggerEntry, SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+        return false;
+
+    // Custom requirements (not listed in procEx) Warning! damage dealing after this
+    // Custom triggered spells
+    switch (auraSpellInfo->Id)
+    {
+        // Persistent Shield (Scarab Brooch trinket)
+        // This spell originally trigger 13567 - Dummy Trigger (vs dummy efect)
+        case 26467:
+        {
+            basepoints0 = damage * 15 / 100;
+            target = pVictim;
+            trigger_spell_id = 26470;
+            break;
+        }
+        // Unyielding Knights (item exploit 29108\29109)
+        case 38164:
+        {
+            if (!pVictim || pVictim->GetEntry() != 19457)  // Proc only if your target is Grillok
+                return false;
+            break;
+        }
+        // Deflection
+        case 52420:
+        {
+            if (!HealthBelowPct(35))
+                return false;
+            break;
+        }
+
+        // Cheat Death
+        case 28845:
+        {
+            // When your health drops below 20%
+            if (HealthBelowPctDamaged(20, damage) || HealthBelowPct(20))
+                return false;
+            break;
+        }
+        // Deadly Swiftness (Rank 1)
+        case 31255:
+        {
+            // whenever you deal damage to a target who is below 20% health.
+            if (!pVictim || !pVictim->isAlive() || pVictim->HealthAbovePct(20))
+                return false;
+
+            target = this;
+            trigger_spell_id = 22588;
+        }
+        // Greater Heal Refund (Avatar Raiment set)
+        case 37594:
+        {
+            if (!pVictim || !pVictim->isAlive())
+                return false;
+
+            // Not give if target already have full health
+            if (pVictim->IsFullHealth())
+                return false;
+            // If your Greater Heal brings the target to full health, you gain $37595s1 mana.
+            if (pVictim->GetHealth() + damage < pVictim->GetMaxHealth())
+                return false;
+            break;
+        }
+        // Bonus Healing (Crystal Spire of Karabor mace)
+        case 40971:
+        {
+            // If your target is below $s1% health
+            if (!pVictim || !pVictim->isAlive() || pVictim->HealthAbovePct(triggerAmount))
+                return false;
+            break;
+        }
+        // Evasive Maneuvers (Commendation of Kael`thas trinket)
+        case 45057:
+        {
+            // reduce you below $s1% health
+            if (GetHealth() - damage > GetMaxHealth() * triggerAmount / 100)
+                return false;
+            break;
+        }
+        // Rapid Recuperation
+        case 53228:
+        case 53232:
+        {
+            // This effect only from Rapid Fire (ability cast)
+            if (!(procSpell->SpellFamilyFlags[0] & 0x20))
+                return false;
+            break;
+        }
+        // Blessing of Ancient Kings (Val'anyr, Hammer of Ancient Kings)
+        case 64411:
+        {
+            basepoints0 = damage * 15 / 100;
+            target = pVictim;
+            trigger_spell_id = 64413;
+            break;
+        }
+        // Decimation
+        case 63156:
+        case 63158:
+            // Can proc only if target has hp below 35%
+            if (!pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, procSpell, this))
+                return false;
+            break;
+        // Deathbringer Saurfang - Rune of Blood
+        case 72408:
+            // can proc only if target is marked with rune
+            if (!pVictim->HasAura(72410))
+                return false;
+            break;
+        // Deathbringer Saurfang - Blood Beast's Blood Link
+        case 72176:
+            basepoints0 = 3;
+            break;
+    }
+
+    // Blade Barrier
+    if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 85)
+    {
+        Player * plr = this->ToPlayer();
+        if (this->GetTypeId() != TYPEID_PLAYER || !plr || plr->getClass() != CLASS_DEATH_KNIGHT)
+            return false;
+
+        if (!plr->IsBaseRuneSlotsOnCooldown(RUNE_BLOOD))
+            return false;
+    }
+
+    // Rime
+    else if (auraSpellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && auraSpellInfo->SpellIconID == 56)
+    {
+        if (GetTypeId() != TYPEID_PLAYER)
+            return false;
+
+        // Howling Blast
+        this->ToPlayer()->RemoveSpellCategoryCooldown(1248, true);
+    }
+
+    // Custom basepoints/target for exist spell
+    // dummy basepoints or other customs
+    switch(trigger_spell_id)
+    {
+        // Auras which should proc on area aura source (caster in this case):
+        // Turn the Tables
+        case 52914:
+        case 52915:
+        case 52910:
+        // Honor Among Thieves
+        case 52916:
+        {
+            target = triggeredByAura->GetBase()->GetCaster();
+            if (!target)
+                return false;
+
+            if (cooldown && target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->HasSpellCooldown(trigger_spell_id))
+                return false;
+
+            target->CastSpell(target,trigger_spell_id,true,castItem,triggeredByAura);
+
+            if (cooldown && GetTypeId() == TYPEID_PLAYER)
+                this->ToPlayer()->AddSpellCooldown(trigger_spell_id,0,time(NULL) + cooldown);
+            return true;
+        }
+        // Cast positive spell on enemy target
+        case 7099:  // Curse of Mending
+        case 39647: // Curse of Mending
+        case 29494: // Temptation
+        case 20233: // Improved Lay on Hands (cast on target)
+        {
+            target = pVictim;
+            break;
+        }
+        // Combo points add triggers (need add combopoint only for main target, and after possible combopoints reset)
+        case 15250: // Rogue Setup
+        {
+            if (!pVictim || pVictim != getVictim())   // applied only for main target
+                return false;
+            break;                                   // continue normal case
+        }
+        // Finish movies that add combo
+        case 14189: // Seal Fate (Netherblade set)
+        case 14157: // Ruthlessness
+        {
+            if (!pVictim || pVictim == this)
+                return false;
+            // Need add combopoint AFTER finish movie (or they dropped in finish phase)
+            break;
+        }
+        // Bloodthirst (($m/100)% of max health)
+        case 23880:
+        {
+            basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
+            break;
+        }
+        // Shamanistic Rage triggered spell
+        case 30824:
+        {
+            basepoints0 = int32(GetTotalAttackPowerValue(BASE_ATTACK) * triggerAmount / 100);
+            break;
+        }
+        // Enlightenment (trigger only from mana cost spells)
+        case 35095:
+        {
+            if (!procSpell || procSpell->powerType != POWER_MANA || (procSpell->manaCost == 0 && procSpell->ManaCostPercentage == 0 && procSpell->manaCostPerlevel == 0))
+                return false;
+            break;
+        }
+        // Demonic Pact
+        case 48090:
+        {
+            // Get talent aura from owner
+            if (isPet())
+                if (Unit * owner = GetOwner())
+                {
+                    if (AuraEffect * aurEff = owner->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 3220, 0))
+                    {
+                        basepoints0 = int32((aurEff->GetAmount() * owner->SpellBaseDamageBonus(SpellSchoolMask(SPELL_SCHOOL_MASK_MAGIC)) + 100.0f) / 100.0f);
+                        CastCustomSpell(this,trigger_spell_id,&basepoints0,&basepoints0,NULL,true,castItem,triggeredByAura);
+                        return true;
+                    }
+                }
+            break;
+        }
+        // Sword and Board
+        case 50227:
+        {
+            // Remove cooldown on Shield Slam
+            if (GetTypeId() == TYPEID_PLAYER)
+                this->ToPlayer()->RemoveSpellCategoryCooldown(1209, true);
+            break;
+        }
+        // Maelstrom Weapon
+        case 53817:
+        {
+            // have rank dependent proc chance, ignore too often cases
+            // PPM = 2.5 * (rank of talent),
+            uint32 rank = sSpellMgr.GetSpellRank(auraSpellInfo->Id);
+            // 5 rank -> 100% 4 rank -> 80% and etc from full rate
+            if (!roll_chance_i(20*rank))
+                return false;
+            break;
+        }
+        // Astral Shift
+        case 52179:
+        {
+            if (procSpell == 0 || !(procEx & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) || this == pVictim)
+                return false;
+
+            // Need stun, fear or silence mechanic
+            if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_SILENCE)|(1<<MECHANIC_STUN)|(1<<MECHANIC_FEAR))))
+                return false;
+            break;
+        }
+        // Burning Determination
+        case 54748:
+        {
+            if (!procSpell)
+                return false;
+            // Need Interrupt or Silenced mechanic
+            if (!(GetAllSpellMechanicMask(procSpell) & ((1<<MECHANIC_INTERRUPT)|(1<<MECHANIC_SILENCE))))
+                return false;
+            break;
+        }
+        // Lock and Load
+        case 56453:
+        {
+            // Proc only from Frost/Freezing trap activation or from Freezing Arrow (the periodic dmg proc handled elsewhere)
+            if (!(procFlags & PROC_FLAG_DONE_TRAP_ACTIVATION) || !procSpell || !(procSpell->SchoolMask & SPELL_SCHOOL_MASK_FROST) || !roll_chance_i(triggerAmount))
+                return false;
+            break;
+        }
+        // Glyph of Death's Embrace
+        case 58679:
+        {
+            // Proc only from healing part of Death Coil. Check is essential as all Death Coil spells have 0x2000 mask in SpellFamilyFlags
+            if (!procSpell || !(procSpell->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && procSpell->SpellFamilyFlags[0] == 0x80002000))
+                return false;
+            break;
+        }
+        // Glyph of Death Grip
+        case 58628:
+        {
+            // remove cooldown of Death Grip
+            if (GetTypeId() == TYPEID_PLAYER)
+                this->ToPlayer()->RemoveCategoryCooldown(82);
+            return true;
+        }
+        // Savage Defense
+        case 62606:
+        {
+            basepoints0 = int32(GetTotalAttackPowerValue(BASE_ATTACK) * triggerAmount / 100.0f);
+            break;
+        }
+        // Body and Soul
+        case 64128:
+        case 65081:
+        {
+            // Proc only from PW:S cast
+            if (!(procSpell->SpellFamilyFlags[0] & 0x00000001))
+                return false;
+            break;
+        }
+        // Shadow's Fate (Shadowmourne questline)
+        case 71169:
+            if (GetTypeId() != TYPEID_PLAYER)
+                return false;
+            if (ToPlayer()->GetQuestStatus(24547) != QUEST_STATUS_INCOMPLETE)   // A Feast of Souls
+                return false;
+            if (pVictim->GetTypeId() != TYPEID_UNIT)
+                return false;
+            // critters are not allowed
+            if (pVictim->GetCreatureType() == CREATURE_TYPE_CRITTER)
+                return false;
+            break;
+    }
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER && ToPlayer()->HasSpellCooldown(trigger_spell_id))
+        return false;
+
+    // try detect target manually if not set
+    if (target == NULL)
+       target = !(procFlags & (PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS | PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS)) && IsPositiveSpell(trigger_spell_id) ? this : pVictim;
+
+    // default case
+    if ((!target && !sSpellMgr.IsSrcTargetSpell(triggerEntry)) || (target && target != this && !target->isAlive()))
+        return false;
+
+    if (basepoints0)
+        CastCustomSpell(target,trigger_spell_id,&basepoints0,NULL,NULL,true,castItem,triggeredByAura);
+    else
+        CastSpell(target,trigger_spell_id,true,castItem,triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        ToPlayer()->AddSpellCooldown(trigger_spell_id,0,time(NULL) + cooldown);
+
+    return true;
+}
+
+bool Unit::HandleOverrideClassScriptAuraProc(Unit *pVictim, uint32 /*damage*/, AuraEffect *triggeredByAura, SpellEntry const *procSpell, uint32 cooldown)
+{
+    int32 scriptId = triggeredByAura->GetMiscValue();
+
+    if (!pVictim || !pVictim->isAlive())
+        return false;
+
+    Item* castItem = triggeredByAura->GetBase()->GetCastItemGUID() && GetTypeId() == TYPEID_PLAYER
+        ? this->ToPlayer()->GetItemByGuid(triggeredByAura->GetBase()->GetCastItemGUID()) : NULL;
+
+    uint32 triggered_spell_id = 0;
+
+    switch(scriptId)
+    {
+        case 836:                                           // Improved Blizzard (Rank 1)
+        {
+            if (!procSpell || procSpell->SpellVisual[0] != 9487)
+                return false;
+            triggered_spell_id = 12484;
+            break;
+        }
+        case 988:                                           // Improved Blizzard (Rank 2)
+        {
+            if (!procSpell || procSpell->SpellVisual[0] != 9487)
+                return false;
+            triggered_spell_id = 12485;
+            break;
+        }
+        case 989:                                           // Improved Blizzard (Rank 3)
+        {
+            if (!procSpell || procSpell->SpellVisual[0] != 9487)
+                return false;
+            triggered_spell_id = 12486;
+            break;
+        }
+        case 4533:                                          // Dreamwalker Raiment 2 pieces bonus
+        {
+            // Chance 50%
+            if (!roll_chance_i(50))
+                return false;
+
+            switch (pVictim->getPowerType())
+            {
+                case POWER_MANA:   triggered_spell_id = 28722; break;
+                case POWER_RAGE:   triggered_spell_id = 28723; break;
+                case POWER_ENERGY: triggered_spell_id = 28724; break;
+                default:
+                    return false;
+            }
+            break;
+        }
+        case 4537:                                          // Dreamwalker Raiment 6 pieces bonus
+            triggered_spell_id = 28750;                     // Blessing of the Claw
+            break;
+        case 5497:                                          // Improved Mana Gems
+            triggered_spell_id = 37445;                     // Mana Surge
+            break;
+        case 7010:  // Revitalize - can proc on full hp target
+        case 7011:
+        case 7012:
+        {
+            if (!roll_chance_i(triggeredByAura->GetAmount()))
+                return false;
+            switch(pVictim->getPowerType())
+            {
+                case POWER_MANA:   triggered_spell_id = 48542; break;
+                case POWER_RAGE:   triggered_spell_id = 48541; break;
+                case POWER_ENERGY: triggered_spell_id = 48540; break;
+                case POWER_RUNIC_POWER: triggered_spell_id = 48543; break;
+                default:
+                    break;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    // not processed
+    if (!triggered_spell_id)
+        return false;
+
+    // standard non-dummy case
+    SpellEntry const* triggerEntry = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!triggerEntry)
+    {
+        sLog.outError("Unit::HandleOverrideClassScriptAuraProc: Spell %u triggering for class script id %u",triggered_spell_id,scriptId);
+        return false;
+    }
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->HasSpellCooldown(triggered_spell_id))
+        return false;
+
+    CastSpell(pVictim, triggered_spell_id, true, castItem, triggeredByAura);
+
+    if (cooldown && GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->AddSpellCooldown(triggered_spell_id,0,time(NULL) + cooldown);
+
+    return true;
+}
+
+void Unit::setPowerType(Powers new_powertype)
+{
+    SetByteValue(UNIT_FIELD_BYTES_0, 3, new_powertype);
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (this->ToPlayer()->GetGroup())
+            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POWER_TYPE);
+    }
+    else if (this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_POWER_TYPE);
+        }
+    }
+
+    switch(new_powertype)
+    {
+        default:
+        case POWER_MANA:
+            break;
+        case POWER_RAGE:
+            SetMaxPower(POWER_RAGE, GetCreatePowers(POWER_RAGE));
+            SetPower(POWER_RAGE, 0);
+            break;
+        case POWER_FOCUS:
+            SetMaxPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
+            SetPower(POWER_FOCUS, GetCreatePowers(POWER_FOCUS));
+            break;
+        case POWER_ENERGY:
+            SetMaxPower(POWER_ENERGY, GetCreatePowers(POWER_ENERGY));
+            break;
+        case POWER_HAPPINESS:
+            SetMaxPower(POWER_HAPPINESS, GetCreatePowers(POWER_HAPPINESS));
+            SetPower(POWER_HAPPINESS, GetCreatePowers(POWER_HAPPINESS));
+            break;
+    }
+}
+
+FactionTemplateEntry const* Unit::getFactionTemplateEntry() const
+{
+    FactionTemplateEntry const* entry = sFactionTemplateStore.LookupEntry(getFaction());
+    if (!entry)
+    {
+        static uint64 guid = 0;                             // prevent repeating spam same faction problem
+
+        if (GetGUID() != guid)
+        {
+            if (const Player *player = ToPlayer())
+                sLog.outError("Player %s has invalid faction (faction template id) #%u", player->GetName(), getFaction());
+            else if (const Creature *creature = ToCreature())
+                sLog.outError("Creature (template id: %u) has invalid faction (faction template id) #%u", creature->GetCreatureInfo()->Entry, getFaction());
+            else
+                sLog.outError("Unit (name=%s, type=%u) has invalid faction (faction template id) #%u", GetName(), uint32(GetTypeId()), getFaction());
+
+            guid = GetGUID();
+        }
+    }
+    return entry;
+}
+
+bool Unit::IsHostileTo(Unit const* unit) const
+{
+    if (!unit)
+        return false;
+    // always non-hostile to self
+    if (unit == this)
+        return false;
+
+    // always non-hostile to GM in GM mode
+    if (unit->GetTypeId() == TYPEID_PLAYER && ((Player const*)unit)->isGameMaster())
+        return false;
+
+    // always hostile to enemy
+    if (getVictim() == unit || unit->getVictim() == this)
+        return true;
+
+    // test pet/charm masters instead pers/charmeds
+    Unit const* testerOwner = GetCharmerOrOwner();
+    Unit const* targetOwner = unit->GetCharmerOrOwner();
+
+    // always hostile to owner's enemy
+    if (testerOwner && (testerOwner->getVictim() == unit || unit->getVictim() == testerOwner))
+        return true;
+
+    // always hostile to enemy owner
+    if (targetOwner && (getVictim() == targetOwner || targetOwner->getVictim() == this))
+        return true;
+
+    // always hostile to owner of owner's enemy
+    if (testerOwner && targetOwner && (testerOwner->getVictim() == targetOwner || targetOwner->getVictim() == testerOwner))
+        return true;
+
+    Unit const* tester = testerOwner ? testerOwner : this;
+    Unit const* target = targetOwner ? targetOwner : unit;
+
+    // always non-hostile to target with common owner, or to owner/pet
+    if (tester == target)
+        return false;
+
+    // special cases (Duel, etc)
+    if (tester->GetTypeId() == TYPEID_PLAYER && target->GetTypeId() == TYPEID_PLAYER)
+    {
+        Player const* pTester = (Player const*)tester;
+        Player const* pTarget = (Player const*)target;
+
+        // Duel
+        if (pTester->duel && pTester->duel->opponent == pTarget && pTester->duel->startTime != 0)
+            return true;
+
+        // Group
+        if (pTester->GetGroup() && pTester->GetGroup() == pTarget->GetGroup())
+            return false;
+
+        // Sanctuary
+        if (pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY) && pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY))
+            return false;
+
+        // PvP FFA state
+        if (pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) && pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            return true;
+
+        //= PvP states
+        // Green/Blue (can't attack)
+        if (!pTester->HasAuraType(SPELL_AURA_MOD_FACTION) && !pTarget->HasAuraType(SPELL_AURA_MOD_FACTION))
+        {
+            if (pTester->GetTeam() == pTarget->GetTeam())
+                return false;
+
+            // Red (can attack) if true, Blue/Yellow (can't attack) in another case
+            return pTester->IsPvP() && pTarget->IsPvP();
+        }
+    }
+
+    // faction base cases
+    FactionTemplateEntry const*tester_faction = tester->getFactionTemplateEntry();
+    FactionTemplateEntry const*target_faction = target->getFactionTemplateEntry();
+    if (!tester_faction || !target_faction)
+        return false;
+
+    if (target->isAttackingPlayer() && tester->IsContestedGuard())
+        return true;
+
+    // PvC forced reaction and reputation case
+    if (tester->GetTypeId() == TYPEID_PLAYER && !tester->HasAuraType(SPELL_AURA_MOD_FACTION))
+    {
+        // forced reaction
+        if (target_faction->faction)
+        {
+            if (ReputationRank const* force =tester->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(target_faction))
+                return *force <= REP_HOSTILE;
+
+            // if faction have reputation then hostile state for tester at 100% dependent from at_war state
+            if (FactionEntry const* raw_target_faction = sFactionStore.LookupEntry(target_faction->faction))
+                if (FactionState const* factionState = tester->ToPlayer()->GetReputationMgr().GetState(raw_target_faction))
+                    return (factionState->Flags & FACTION_FLAG_AT_WAR);
+        }
+    }
+    // CvP forced reaction and reputation case
+    else if (target->GetTypeId() == TYPEID_PLAYER && !target->HasAuraType(SPELL_AURA_MOD_FACTION))
+    {
+        // forced reaction
+        if (tester_faction->faction)
+        {
+            if (ReputationRank const* force = target->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(tester_faction))
+                return *force <= REP_HOSTILE;
+
+            // apply reputation state
+            FactionEntry const* raw_tester_faction = sFactionStore.LookupEntry(tester_faction->faction);
+            if (raw_tester_faction && raw_tester_faction->reputationListID >=0)
+                return ((Player const*)target)->GetReputationMgr().GetRank(raw_tester_faction) <= REP_HOSTILE;
+        }
+    }
+
+    // common faction based case (CvC,PvC,CvP)
+    return tester_faction->IsHostileTo(*target_faction);
+}
+
+bool Unit::IsFriendlyTo(Unit const* unit) const
+{
+    // always friendly to self
+    if (unit == this)
+        return true;
+
+    // always friendly to GM in GM mode
+    if (unit->GetTypeId() == TYPEID_PLAYER && ((Player const*)unit)->isGameMaster())
+        return true;
+
+    // always non-friendly to enemy
+    if (getVictim() == unit || unit->getVictim() == this)
+        return false;
+
+    // test pet/charm masters instead pers/charmeds
+    Unit const* testerOwner = GetCharmerOrOwner();
+    Unit const* targetOwner = unit->GetCharmerOrOwner();
+
+    // always non-friendly to owner's enemy
+    if (testerOwner && (testerOwner->getVictim() == unit || unit->getVictim() == testerOwner))
+        return false;
+
+    // always non-friendly to enemy owner
+    if (targetOwner && (getVictim() == targetOwner || targetOwner->getVictim() == this))
+        return false;
+
+    // always non-friendly to owner of owner's enemy
+    if (testerOwner && targetOwner && (testerOwner->getVictim() == targetOwner || targetOwner->getVictim() == testerOwner))
+        return false;
+
+    Unit const* tester = testerOwner ? testerOwner : this;
+    Unit const* target = targetOwner ? targetOwner : unit;
+
+    // always friendly to target with common owner, or to owner/pet
+    if (tester == target)
+        return true;
+
+    // special cases (Duel)
+    if (tester->GetTypeId() == TYPEID_PLAYER && target->GetTypeId() == TYPEID_PLAYER)
+    {
+        Player const* pTester = (Player const*)tester;
+        Player const* pTarget = (Player const*)target;
+
+        // Duel
+        if (pTester->duel && pTester->duel->opponent == target && pTester->duel->startTime != 0)
+            return false;
+
+        // Group
+        if (pTester->GetGroup() && pTester->GetGroup() == pTarget->GetGroup())
+            return true;
+
+        // Sanctuary
+        if (pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY) && pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY))
+            return true;
+
+        // PvP FFA state
+        if (pTester->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) && pTarget->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            return false;
+
+        //= PvP states
+        // Green/Blue (non-attackable)
+        if (!pTester->HasAuraType(SPELL_AURA_MOD_FACTION) && !pTarget->HasAuraType(SPELL_AURA_MOD_FACTION))
+        {
+            if (pTester->GetTeam() == pTarget->GetTeam())
+                return true;
+
+            // Blue (friendly/non-attackable) if not PVP, or Yellow/Red in another case (attackable)
+            return !pTarget->IsPvP();
+        }
+    }
+
+    // faction base cases
+    FactionTemplateEntry const *tester_faction = tester->getFactionTemplateEntry();
+    FactionTemplateEntry const *target_faction = target->getFactionTemplateEntry();
+    if (!tester_faction || !target_faction)
+        return false;
+
+    if (target->isAttackingPlayer() && tester->IsContestedGuard())
+        return false;
+
+    // PvC forced reaction and reputation case
+    if (tester->GetTypeId() == TYPEID_PLAYER && !tester->HasAuraType(SPELL_AURA_MOD_FACTION))
+    {
+        // forced reaction
+        if (target_faction->faction)
+        {
+            if (ReputationRank const *force =tester->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(target_faction))
+                return *force >= REP_FRIENDLY;
+
+            // if faction have reputation then friendly state for tester at 100% dependent from at_war state
+            if (FactionEntry const *raw_target_faction = sFactionStore.LookupEntry(target_faction->faction))
+                if (FactionState const *factionState = tester->ToPlayer()->GetReputationMgr().GetState(raw_target_faction))
+                    return !(factionState->Flags & FACTION_FLAG_AT_WAR);
+        }
+    }
+    // CvP forced reaction and reputation case
+    else if (target->GetTypeId() == TYPEID_PLAYER && !target->HasAuraType(SPELL_AURA_MOD_FACTION))
+    {
+        // forced reaction
+        if (tester_faction->faction)
+        {
+            if (ReputationRank const *force =target->ToPlayer()->GetReputationMgr().GetForcedRankIfAny(tester_faction))
+                return *force >= REP_FRIENDLY;
+
+            // apply reputation state
+            if (FactionEntry const *raw_tester_faction = sFactionStore.LookupEntry(tester_faction->faction))
+                if (raw_tester_faction->reputationListID >= 0)
+                    return ((Player const*)target)->GetReputationMgr().GetRank(raw_tester_faction) >= REP_FRIENDLY;
+        }
+    }
+
+    // common faction based case (CvC,PvC,CvP)
+    return tester_faction->IsFriendlyTo(*target_faction);
+}
+
+bool Unit::IsHostileToPlayers() const
+{
+    FactionTemplateEntry const *my_faction = getFactionTemplateEntry();
+    if (!my_faction || !my_faction->faction)
+        return false;
+
+    FactionEntry const *raw_faction = sFactionStore.LookupEntry(my_faction->faction);
+    if (raw_faction && raw_faction->reputationListID >= 0)
+        return false;
+
+    return my_faction->IsHostileToPlayers();
+}
+
+bool Unit::IsNeutralToAll() const
+{
+    FactionTemplateEntry const *my_faction = getFactionTemplateEntry();
+    if (!my_faction || !my_faction->faction)
+        return true;
+
+    FactionEntry const *raw_faction = sFactionStore.LookupEntry(my_faction->faction);
+    if (raw_faction && raw_faction->reputationListID >= 0)
+        return false;
+
+    return my_faction->IsNeutralToAll();
+}
+
+bool Unit::Attack(Unit *victim, bool meleeAttack)
+{
+    if (!victim || victim == this)
+        return false;
+
+    // dead units can neither attack nor be attacked
+    if (!isAlive() || !victim->IsInWorld() || !victim->isAlive())
+        return false;
+
+    // player cannot attack in mount state
+    if (GetTypeId() == TYPEID_PLAYER && IsMounted())
+        return false;
+
+    // nobody can attack GM in GM-mode
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->ToPlayer()->isGameMaster())
+            return false;
+    }
+    else
+    {
+        if (victim->ToCreature()->IsInEvadeMode())
+            return false;
+    }
+
+    // remove SPELL_AURA_MOD_UNATTACKABLE at attack (in case non-interruptible spells stun aura applied also that not let attack)
+    if (HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+        RemoveAurasByType(SPELL_AURA_MOD_UNATTACKABLE);
+
+    if (m_attacking)
+    {
+        if (m_attacking == victim)
+        {
+            // switch to melee attack from ranged/magic
+            if (meleeAttack)
+            {
+                if (!hasUnitState(UNIT_STAT_MELEE_ATTACKING))
+                {
+                    addUnitState(UNIT_STAT_MELEE_ATTACKING);
+                    SendMeleeAttackStart(victim);
+                    return true;
+                }
+            }
+            else if (hasUnitState(UNIT_STAT_MELEE_ATTACKING))
+            {
+                clearUnitState(UNIT_STAT_MELEE_ATTACKING);
+                SendMeleeAttackStop(victim);
+                return true;
+            }
+            return false;
+        }
+
+        //switch target
+        InterruptSpell(CURRENT_MELEE_SPELL);
+        if (!meleeAttack)
+            clearUnitState(UNIT_STAT_MELEE_ATTACKING);
+    }
+
+    if (m_attacking)
+        m_attacking->_removeAttacker(this);
+
+    m_attacking = victim;
+    m_attacking->_addAttacker(this);
+
+    // Set our target
+    SetUInt64Value(UNIT_FIELD_TARGET, victim->GetGUID());
+
+    if (meleeAttack)
+        addUnitState(UNIT_STAT_MELEE_ATTACKING);
+
+    // set position before any AI calls/assistance
+    //if (GetTypeId() == TYPEID_UNIT)
+    //    this->ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
+
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        // should not let player enter combat by right clicking target
+        SetInCombatWith(victim);
+        if (victim->GetTypeId() == TYPEID_PLAYER)
+            victim->SetInCombatWith(this);
+        AddThreat(victim, 0.0f);
+
+        this->ToCreature()->SendAIReaction(AI_REACTION_HOSTILE);
+        this->ToCreature()->CallAssistance();
+    }
+
+    // delay offhand weapon attack to next attack time
+    if (haveOffhandWeapon())
+        resetAttackTimer(OFF_ATTACK);
+
+    if (meleeAttack)
+        SendMeleeAttackStart(victim);
+
+    return true;
+}
+
+bool Unit::AttackStop()
+{
+    if (!m_attacking)
+        return false;
+
+    Unit* victim = m_attacking;
+
+    m_attacking->_removeAttacker(this);
+    m_attacking = NULL;
+
+    // Clear our target
+    SetUInt64Value(UNIT_FIELD_TARGET, 0);
+
+    clearUnitState(UNIT_STAT_MELEE_ATTACKING);
+
+    InterruptSpell(CURRENT_MELEE_SPELL);
+
+    // reset only at real combat stop
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        this->ToCreature()->SetNoCallAssistance(false);
+
+        if (this->ToCreature()->HasSearchedAssistance())
+        {
+            this->ToCreature()->SetNoSearchAssistance(false);
+            UpdateSpeed(MOVE_RUN, false);
+        }
+    }
+
+    SendMeleeAttackStop(victim);
+
+    return true;
+}
+
+void Unit::CombatStop(bool includingCast)
+{
+    if (includingCast && IsNonMeleeSpellCasted(false))
+        InterruptNonMeleeSpells(false);
+
+    AttackStop();
+    RemoveAllAttackers();
+    if (GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel
+    ClearInCombat();
+}
+
+void Unit::CombatStopWithPets(bool includingCast)
+{
+    CombatStop(includingCast);
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        (*itr)->CombatStop(includingCast);
+}
+
+bool Unit::isAttackingPlayer() const
+{
+    if (hasUnitState(UNIT_STAT_ATTACK_PLAYER))
+        return true;
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->isAttackingPlayer())
+            return true;
+
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        if (m_SummonSlot[i])
+            if (Creature *summon = GetMap()->GetCreature(m_SummonSlot[i]))
+                if (summon->isAttackingPlayer())
+                    return true;
+
+    return false;
+}
+
+void Unit::RemoveAllAttackers()
+{
+    while (!m_attackers.empty())
+    {
+        AttackerSet::iterator iter = m_attackers.begin();
+        if (!(*iter)->AttackStop())
+        {
+            sLog.outError("WORLD: Unit has an attacker that isn't attacking it!");
+            m_attackers.erase(iter);
+        }
+    }
+}
+
+void Unit::ModifyAuraState(AuraState flag, bool apply)
+{
+    if (apply)
+    {
+        if (!HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1)))
+        {
+            SetFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
+            if (GetTypeId() == TYPEID_PLAYER)
+            {
+                PlayerSpellMap const& sp_list = this->ToPlayer()->GetSpellMap();
+                for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
+                {
+                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled) continue;
+                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(itr->first);
+                    if (!spellInfo || !IsPassiveSpell(itr->first)) continue;
+                    if (spellInfo->CasterAuraState == uint32(flag))
+                        CastSpell(this, itr->first, true, NULL);
+                }
+            }
+            else if (this->ToCreature()->isPet())
+            {
+                Pet *pet = ((Pet*)this);
+                for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+                {
+                    if (itr->second.state == PETSPELL_REMOVED) continue;
+                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(itr->first);
+                    if (!spellInfo || !IsPassiveSpell(itr->first)) continue;
+                    if (spellInfo->CasterAuraState == uint32(flag))
+                        CastSpell(this, itr->first, true, NULL);
+                }
+            }
+        }
+    }
+    else
+    {
+        if (HasFlag(UNIT_FIELD_AURASTATE,1<<(flag-1)))
+        {
+            RemoveFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
+
+            if (flag != AURA_STATE_ENRAGE)                  // enrage aura state triggering continues auras
+            {
+                Unit::AuraApplicationMap& tAuras = GetAppliedAuras();
+                for (Unit::AuraApplicationMap::iterator itr = tAuras.begin(); itr != tAuras.end();)
+                {
+                    SpellEntry const* spellProto = (*itr).second->GetBase()->GetSpellProto();
+                    if (spellProto->CasterAuraState == uint32(flag))
+                        RemoveAura(itr);
+                    else
+                        ++itr;
+                }
+            }
+        }
+    }
+}
+
+uint32 Unit::BuildAuraStateUpdateForTarget(Unit * target) const
+{
+    uint32 auraStates = GetUInt32Value(UNIT_FIELD_AURASTATE) &~(PER_CASTER_AURA_STATE_MASK);
+    for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.begin(); itr != m_auraStateAuras.end(); ++itr)
+        if ((1<<(itr->first-1)) & PER_CASTER_AURA_STATE_MASK)
+            if (itr->second->GetBase()->GetCasterGUID() == target->GetGUID())
+                auraStates |= (1<<(itr->first-1));
+
+    return auraStates;
+}
+
+bool Unit::HasAuraState(AuraState flag, SpellEntry const *spellProto, Unit const * Caster) const
+{
+    if (Caster)
+    {
+        if (spellProto)
+        {
+            AuraEffectList const& stateAuras = Caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_IGNORE_AURASTATE);
+            for (AuraEffectList::const_iterator j = stateAuras.begin(); j != stateAuras.end(); ++j)
+                if ((*j)->IsAffectedOnSpell(spellProto))
+                    return true;
+        }
+        // Check per caster aura state
+        // If aura with aurastate by caster not found return false
+        if ((1<<(flag-1)) & PER_CASTER_AURA_STATE_MASK)
+        {
+            for (AuraStateAurasMap::const_iterator itr = m_auraStateAuras.lower_bound(flag); itr != m_auraStateAuras.upper_bound(flag); ++itr)
+                if (itr->second->GetBase()->GetCasterGUID() == Caster->GetGUID())
+                    return true;
+            return false;
+        }
+    }
+
+    return HasFlag(UNIT_FIELD_AURASTATE, 1<<(flag-1));
+}
+
+Unit *Unit::GetOwner() const
+{
+    if (uint64 ownerid = GetOwnerGUID())
+    {
+        return ObjectAccessor::GetUnit(*this, ownerid);
+    }
+    return NULL;
+}
+
+Unit *Unit::GetCharmer() const
+{
+    if (uint64 charmerid = GetCharmerGUID())
+        return ObjectAccessor::GetUnit(*this, charmerid);
+    return NULL;
+}
+
+Player* Unit::GetCharmerOrOwnerPlayerOrPlayerItself() const
+{
+    uint64 guid = GetCharmerOrOwnerGUID();
+    if (IS_PLAYER_GUID(guid))
+        return ObjectAccessor::GetPlayer(*this, guid);
+
+    return GetTypeId() == TYPEID_PLAYER ? (Player*)this : NULL;
+}
+
+Minion *Unit::GetFirstMinion() const
+{
+    if (uint64 pet_guid = GetMinionGUID())
+    {
+        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
+            if (pet->HasUnitTypeMask(UNIT_MASK_MINION))
+                return (Minion*)pet;
+
+        sLog.outError("Unit::GetFirstMinion: Minion %u not exist.",GUID_LOPART(pet_guid));
+        const_cast<Unit*>(this)->SetMinionGUID(0);
+    }
+
+    return NULL;
+}
+
+Guardian* Unit::GetGuardianPet() const
+{
+    if (uint64 pet_guid = GetPetGUID())
+    {
+        if (Creature* pet = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, pet_guid))
+            if (pet->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+                return (Guardian*)pet;
+
+        sLog.outCrash("Unit::GetGuardianPet: Guardian " UI64FMTD " not exist.", pet_guid);
+        const_cast<Unit*>(this)->SetPetGUID(0);
+    }
+
+    return NULL;
+}
+
+Unit* Unit::GetCharm() const
+{
+    if (uint64 charm_guid = GetCharmGUID())
+    {
+        if (Unit* pet = ObjectAccessor::GetUnit(*this, charm_guid))
+            return pet;
+
+        sLog.outError("Unit::GetCharm: Charmed creature %u not exist.",GUID_LOPART(charm_guid));
+        const_cast<Unit*>(this)->SetUInt64Value(UNIT_FIELD_CHARM, 0);
+    }
+
+    return NULL;
+}
+
+void Unit::SetMinion(Minion *minion, bool apply)
+{
+    sLog.outDebug("SetMinion %u for %u, apply %u", minion->GetEntry(), GetEntry(), apply);
+
+    if (apply)
+    {
+        if (!minion->AddUInt64Value(UNIT_FIELD_SUMMONEDBY, GetGUID()))
+        {
+            sLog.outCrash("SetMinion: Minion %u is not the minion of owner %u", minion->GetEntry(), GetEntry());
+            return;
+        }
+
+        m_Controlled.insert(minion);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            minion->m_ControlledByPlayer = true;
+            minion->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+        }
+
+        // Can only have one pet. If a new one is summoned, dismiss the old one.
+        if (minion->IsGuardianPet())
+        {
+            if (Guardian* oldPet = GetGuardianPet())
+            {
+                if (oldPet != minion && (oldPet->isPet() || minion->isPet() || oldPet->GetEntry() != minion->GetEntry()))
+                {
+                    // remove existing minion pet
+                    if (oldPet->isPet())
+                        ((Pet*)oldPet)->Remove(PET_SAVE_AS_CURRENT);
+                    else
+                        oldPet->UnSummon();
+                    SetPetGUID(minion->GetGUID());
+                    SetMinionGUID(0);
+                }
+            }
+            else
+            {
+                SetPetGUID(minion->GetGUID());
+                SetMinionGUID(0);
+            }
+        }
+
+        if (minion->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
+        {
+            if (AddUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))
+            {
+            }
+        }
+
+        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
+        {
+            SetCritterGUID(minion->GetGUID());
+        }
+
+        // PvP, FFAPvP
+        minion->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+        // FIXME: hack, speed must be set only at follow
+        if (GetTypeId() == TYPEID_PLAYER && minion->isPet())
+            for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
+                minion->SetSpeed(UnitMoveType(i), m_speed_rate[i], true);
+
+        // Ghoul pets have energy instead of mana (is anywhere better place for this code?)
+        if (minion->IsPetGhoul())
+            minion->setPowerType(POWER_ENERGY);
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // Send infinity cooldown - client does that automatically but after relog cooldown needs to be set again
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE))
+                this->ToPlayer()->AddSpellAndCategoryCooldowns(spellInfo, 0, NULL ,true);
+        }
+    }
+    else
+    {
+        if (minion->GetOwnerGUID() != GetGUID())
+        {
+            sLog.outCrash("SetMinion: Minion %u is not the minion of owner %u", minion->GetEntry(), GetEntry());
+            return;
+        }
+
+        m_Controlled.erase(minion);
+
+        if (minion->m_Properties && minion->m_Properties->Type == SUMMON_TYPE_MINIPET)
+        {
+            if (GetCritterGUID() == minion->GetGUID())
+                SetCritterGUID(0);
+        }
+
+        if (minion->IsGuardianPet())
+        {
+            if (GetPetGUID() == minion->GetGUID())
+                SetPetGUID(0);
+        }
+        else if (minion->isTotem())
+        {
+            // All summoned by totem minions must disappear when it is removed.
+        if (const SpellEntry* spInfo = sSpellStore.LookupEntry(minion->ToTotem()->GetSpell()))
+            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                if (spInfo->Effect[i] != SPELL_EFFECT_SUMMON)
+                    continue;
+
+                this->RemoveAllMinionsByEntry(spInfo->EffectMiscValue[i]);
+            }
+        }
+
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(minion->GetUInt32Value(UNIT_CREATED_BY_SPELL));
+            // Remove infinity cooldown
+            if (spellInfo && (spellInfo->Attributes & SPELL_ATTR_DISABLED_WHILE_ACTIVE))
+                this->ToPlayer()->SendCooldownEvent(spellInfo);
+        }
+
+        //if (minion->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+        {
+            if (RemoveUInt64Value(UNIT_FIELD_SUMMON, minion->GetGUID()))
+            {
+                //Check if there is another minion
+                for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+                {
+                    // do not use this check, creature do not have charm guid
+                    //if (GetCharmGUID() == (*itr)->GetGUID())
+                    if (GetGUID() == (*itr)->GetCharmerGUID())
+                        continue;
+
+                    //ASSERT((*itr)->GetOwnerGUID() == GetGUID());
+                    if ((*itr)->GetOwnerGUID() != GetGUID())
+                    {
+                        OutDebugInfo();
+                        (*itr)->OutDebugInfo();
+                        ASSERT(false);
+                    }
+                    ASSERT((*itr)->GetTypeId() == TYPEID_UNIT);
+
+                    if (!(*itr)->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
+                        continue;
+
+                    if (AddUInt64Value(UNIT_FIELD_SUMMON, (*itr)->GetGUID()))
+                    {
+                        //show another pet bar if there is no charm bar
+                        if (GetTypeId() == TYPEID_PLAYER && !GetCharmGUID())
+                        {
+                            if ((*itr)->isPet())
+                                this->ToPlayer()->PetSpellInitialize();
+                            else
+                                this->ToPlayer()->CharmSpellInitialize();
+                        }
+                    }
+                    break;
+                }
+            }
+        }
+    }
+}
+
+void Unit::GetAllMinionsByEntry(std::list<Creature*>& Minions, uint32 entry)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)
+    {
+        Unit *unit = *itr;
+        ++itr;
+        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT
+            && unit->ToCreature()->isSummon()) // minion, actually
+            Minions.push_back(unit->ToCreature());
+    }
+}
+
+void Unit::RemoveAllMinionsByEntry(uint32 entry)
+{
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end();)
+    {
+        Unit *unit = *itr;
+        ++itr;
+        if (unit->GetEntry() == entry && unit->GetTypeId() == TYPEID_UNIT
+            && unit->ToCreature()->isSummon()) // minion, actually
+            unit->ToTempSummon()->UnSummon();
+        // i think this is safe because i have never heard that a despawned minion will trigger a same minion
+    }
+}
+
+void Unit::SetCharm(Unit* charm, bool apply)
+{
+    if (apply)
+    {
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            if (!AddUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))
+                sLog.outCrash("Player %s is trying to charm unit %u, but it already has a charmed unit " UI64FMTD "", GetName(), charm->GetEntry(), GetCharmGUID());
+
+            charm->m_ControlledByPlayer = true;
+            // TODO: maybe we can use this flag to check if controlled by player
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+        }
+        else
+            charm->m_ControlledByPlayer = false;
+
+        // PvP, FFAPvP
+        charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+        if (!charm->AddUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))
+            sLog.outCrash("Unit %u is being charmed, but it already has a charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());
+
+        if (charm->HasUnitMovementFlag(MOVEMENTFLAG_WALKING))
+        {
+            charm->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
+            charm->SendMovementFlagUpdate();
+        }
+
+        m_Controlled.insert(charm);
+    }
+    else
+    {
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            if (!RemoveUInt64Value(UNIT_FIELD_CHARM, charm->GetGUID()))
+                sLog.outCrash("Player %s is trying to uncharm unit %u, but it has another charmed unit " UI64FMTD "", GetName(), charm->GetEntry(), GetCharmGUID());
+        }
+
+        if (!charm->RemoveUInt64Value(UNIT_FIELD_CHARMEDBY, GetGUID()))
+            sLog.outCrash("Unit %u is being uncharmed, but it has another charmer " UI64FMTD "", charm->GetEntry(), charm->GetCharmerGUID());
+
+        if (charm->GetTypeId() == TYPEID_PLAYER)
+        {
+            charm->m_ControlledByPlayer = true;
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+            charm->ToPlayer()->UpdatePvPState();
+        }
+        else if (Player *player = charm->GetCharmerOrOwnerPlayerOrPlayerItself())
+        {
+            charm->m_ControlledByPlayer = true;
+            charm->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, player->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+        else
+        {
+            charm->m_ControlledByPlayer = false;
+            charm->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+            charm->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+        }
+
+        if (charm->GetTypeId() == TYPEID_PLAYER
+            || !charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_MINION)
+            || charm->GetOwnerGUID() != GetGUID())
+            m_Controlled.erase(charm);
+    }
+}
+
+int32 Unit::DealHeal(Unit *pVictim, uint32 addhealth)
+{
+    int32 gain = 0;
+
+    if (pVictim->GetTypeId() == TYPEID_UNIT && pVictim->ToCreature()->IsAIEnabled)
+        pVictim->ToCreature()->AI()->HealReceived(this, addhealth);
+
+    if (addhealth)
+        gain = pVictim->ModifyHealth(int32(addhealth));
+
+    Unit* unit = this;
+
+    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem())
+        unit = GetOwner();
+
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (Battleground *bg = unit->ToPlayer()->GetBattleground())
+            bg->UpdatePlayerScore((Player*)unit, SCORE_HEALING_DONE, gain);
+
+        // use the actual gain, as the overheal shall not be counted, skip gain 0 (it ignored anyway in to criteria)
+        if (gain)
+            unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HEALING_DONE, gain, 0, pVictim);
+
+        unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEAL_CASTED, addhealth);
+    }
+
+    if (pVictim->GetTypeId() == TYPEID_PLAYER)
+    {
+        pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_TOTAL_HEALING_RECEIVED, gain);
+        pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HEALING_RECEIVED, addhealth);
+    }
+
+    return gain;
+}
+
+Unit* Unit::SelectMagnetTarget(Unit *victim, SpellEntry const *spellInfo)
+{
+    if (!victim)
+        return NULL;
+
+    // Magic case
+    if (spellInfo && (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC))
+    {
+        //I am not sure if this should be redirected.
+        if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE)
+            return victim;
+
+        Unit::AuraEffectList const& magnetAuras = victim->GetAuraEffectsByType(SPELL_AURA_SPELL_MAGNET);
+        for (Unit::AuraEffectList::const_iterator itr = magnetAuras.begin(); itr != magnetAuras.end(); ++itr)
+            if (Unit* magnet = (*itr)->GetBase()->GetUnitOwner())
+                if (magnet->isAlive())
+                {
+                    (*itr)->GetBase()->DropCharge();
+                    return magnet;
+                }
+    }
+    // Melee && ranged case
+    else
+    {
+        AuraEffectList const& hitTriggerAuras = victim->GetAuraEffectsByType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER);
+        for (AuraEffectList::const_iterator i = hitTriggerAuras.begin(); i != hitTriggerAuras.end(); ++i)
+            if (Unit* magnet = (*i)->GetBase()->GetCaster())
+                if (magnet->isAlive() && magnet->IsWithinLOSInMap(this))
+                    if (roll_chance_i((*i)->GetAmount()))
+                    {
+                        (*i)->GetBase()->DropCharge();
+                        return magnet;
+                    }
+    }
+
+    return victim;
+}
+
+Unit* Unit::GetFirstControlled() const
+{
+    //Sequence: charmed, pet, other guardians
+    Unit *unit = GetCharm();
+    if (!unit)
+        if (uint64 guid = GetUInt64Value(UNIT_FIELD_SUMMON))
+            unit = ObjectAccessor::GetUnit(*this, guid);
+
+    return unit;
+}
+
+void Unit::RemoveAllControlled()
+{
+    //possessed pet and vehicle
+    if (GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->StopCastingCharm();
+
+    while (!m_Controlled.empty())
+    {
+        Unit *target = *m_Controlled.begin();
+        m_Controlled.erase(m_Controlled.begin());
+        if (target->GetCharmerGUID() == GetGUID())
+            target->RemoveCharmAuras();
+        else if (target->GetOwnerGUID() == GetGUID() && target->isSummon())
+            target->ToTempSummon()->UnSummon();
+        else
+            sLog.outError("Unit %u is trying to release unit %u which is neither charmed nor owned by it", GetEntry(), target->GetEntry());
+    }
+    if (GetPetGUID())
+        sLog.outCrash("Unit %u is not able to release its pet " UI64FMTD, GetEntry(), GetPetGUID());
+    if (GetMinionGUID())
+        sLog.outCrash("Unit %u is not able to release its minion " UI64FMTD, GetEntry(), GetMinionGUID());
+    if (GetCharmGUID())
+        sLog.outCrash("Unit %u is not able to release its charm " UI64FMTD, GetEntry(), GetCharmGUID());
+}
+
+Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
+{
+    Player* player = NULL;
+    if (GetTypeId() == TYPEID_PLAYER)
+        player = (Player*)this;
+    // Should we enable this also for charmed units?
+    else if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isPet())
+        player = (Player*)GetOwner();
+
+    if (!player)
+        return NULL;
+    Group *pGroup = player->GetGroup();
+    //When there is no group check pet presence
+    if (!pGroup)
+    {
+        // We are pet now, return owner
+        if (player != this)
+            return IsWithinDistInMap(player, radius) ? player : NULL;
+        Unit * pet = GetGuardianPet();
+        //No pet, no group, nothing to return
+        if (!pet)
+            return NULL;
+        // We are owner now, return pet
+        return IsWithinDistInMap(pet, radius) ? pet : NULL;
+    }
+
+    std::vector<Unit*> nearMembers;
+    //reserve place for players and pets because resizing vector every unit push is unefficient (vector is reallocated then)
+    nearMembers.reserve(pGroup->GetMembersCount()*2);
+
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        if (Player *Target = itr->getSource())
+        {
+            // IsHostileTo check duel and controlled by enemy
+            if (Target !=this && Target->isAlive() && IsWithinDistInMap(Target, radius) && !IsHostileTo(Target))
+                nearMembers.push_back(Target);
+
+        // Push player's pet to vector
+        if (Unit *pet = Target->GetGuardianPet())
+            if (pet != this && pet->isAlive() && IsWithinDistInMap(pet, radius) && !IsHostileTo(pet))
+                nearMembers.push_back(pet);
+        }
+
+    if (nearMembers.empty())
+        return NULL;
+
+    uint32 randTarget = urand(0,nearMembers.size()-1);
+    return nearMembers[randTarget];
+}
+
+//only called in Player::SetSeer
+// so move it to Player?
+void Unit::AddPlayerToVision(Player* plr)
+{
+    if (m_sharedVision.empty())
+    {
+        setActive(true);
+        SetWorldObject(true);
+    }
+    m_sharedVision.push_back(plr);
+}
+
+//only called in Player::SetSeer
+void Unit::RemovePlayerFromVision(Player* plr)
+{
+    m_sharedVision.remove(plr);
+    if (m_sharedVision.empty())
+    {
+        setActive(false);
+        SetWorldObject(false);
+    }
+}
+
+void Unit::RemoveBindSightAuras()
+{
+    RemoveAurasByType(SPELL_AURA_BIND_SIGHT);
+}
+
+void Unit::RemoveCharmAuras()
+{
+    RemoveAurasByType(SPELL_AURA_MOD_CHARM);
+    RemoveAurasByType(SPELL_AURA_MOD_POSSESS_PET);
+    RemoveAurasByType(SPELL_AURA_MOD_POSSESS);
+    RemoveAurasByType(SPELL_AURA_AOE_CHARM);
+}
+
+void Unit::UnsummonAllTotems()
+{
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+    {
+        if (!m_SummonSlot[i])
+            continue;
+
+        if (Creature *OldTotem = GetMap()->GetCreature(m_SummonSlot[i]))
+            if (OldTotem->isSummon())
+                OldTotem->ToTempSummon()->UnSummon();
+    }
+}
+
+void Unit::SendHealSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, uint32 OverHeal, uint32 Absorb, bool critical)
+{
+    // we guess size
+    WorldPacket data(SMSG_SPELLHEALLOG, (8+8+4+4+4+4+1+1));
+    data.append(pVictim->GetPackGUID());
+    data.append(GetPackGUID());
+    data << uint32(SpellID);
+    data << uint32(Damage);
+    data << uint32(OverHeal);
+    data << uint32(Absorb); // Absorb amount
+    data << uint8(critical ? 1 : 0);
+    data << uint8(0); // unused
+    SendMessageToSet(&data, true);
+}
+
+int32 Unit::HealBySpell(Unit * pVictim, SpellEntry const * spellInfo, uint32 addHealth, bool critical)
+{
+    uint32 absorb = 0;
+    // calculate heal absorb and reduce healing
+    CalcHealAbsorb(pVictim, spellInfo, addHealth, absorb);
+
+    int32 gain = DealHeal(pVictim, addHealth);
+    SendHealSpellLog(pVictim, spellInfo->Id, addHealth, uint32(addHealth - gain), absorb, critical);
+    return gain;
+}
+
+void Unit::SendEnergizeSpellLog(Unit *pVictim, uint32 SpellID, uint32 Damage, Powers powertype)
+{
+    WorldPacket data(SMSG_SPELLENERGIZELOG, (8+8+4+4+4+1));
+    data.append(pVictim->GetPackGUID());
+    data.append(GetPackGUID());
+    data << uint32(SpellID);
+    data << uint32(powertype);
+    data << uint32(Damage);
+    SendMessageToSet(&data, true);
+}
+
+void Unit::EnergizeBySpell(Unit *pVictim, uint32 SpellID, uint32 Damage, Powers powertype)
+{
+    SendEnergizeSpellLog(pVictim, SpellID, Damage, powertype);
+    // needs to be called after sending spell log
+    pVictim->ModifyPower(powertype, Damage);
+}
+
+uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)
+{
+    if (!spellProto || !pVictim || damagetype == DIRECT_DAMAGE)
+        return pdamage;
+
+    // For totems get damage bonus from owner
+    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem())
+        if (Unit *owner = GetOwner())
+            return owner->SpellDamageBonus(pVictim, spellProto, pdamage, damagetype);
+
+    // Taken/Done total percent damage auras
+    float DoneTotalMod = 1.0f;
+    float ApCoeffMod = 1.0f;
+    int32 DoneTotal = 0;
+    int32 TakenTotal = 0;
+
+    // ..done
+    // Pet damage
+    if (GetTypeId() == TYPEID_UNIT && !this->ToCreature()->isPet())
+        DoneTotalMod *= this->ToCreature()->GetSpellDamageMod(this->ToCreature()->GetCreatureInfo()->rank);
+
+    AuraEffectList const &mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
+    for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
+        if (((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto)) &&
+            (*i)->GetSpellProto()->EquippedItemClass == -1 &&          // -1 == any item class (not wand)
+            (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0) // 0 == any inventory type (not wand)
+            DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+
+    uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
+    // Add flat bonus from spell damage versus
+    DoneTotal += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_FLAT_SPELL_DAMAGE_VERSUS, creatureTypeMask);
+    AuraEffectList const &mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
+        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+            DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+
+    // bonus against aurastate
+    AuraEffectList const &mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
+        if (pVictim->HasAuraState(AuraState((*i)->GetMiscValue())))
+            DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
+
+    // done scripted mod (take it from owner)
+    Unit * owner = GetOwner() ? GetOwner() : this;
+    AuraEffectList const &mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
+    {
+        if (!(*i)->IsAffectedOnSpell(spellProto))
+            continue;
+
+        switch ((*i)->GetMiscValue())
+        {
+            case 4920: // Molten Fury
+            case 4919:
+            case 6917: // Death's Embrace
+            case 6926:
+            case 6928:
+            {
+                if (pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))
+                    DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
+                break;
+            }
+            // Soul Siphon
+            case 4992:
+            case 4993:
+            {
+                // effect 1 m_amount
+                int32 maxPercent = (*i)->GetAmount();
+                // effect 0 m_amount
+                int32 stepPercent = CalculateSpellDamage(this, (*i)->GetSpellProto(), 0);
+                // count affliction effects and calc additional damage in percentage
+                int32 modPercent = 0;
+                AuraApplicationMap const &victimAuras = pVictim->GetAppliedAuras();
+                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)
+                {
+                    Aura const * aura = itr->second->GetBase();
+                    SpellEntry const *m_spell = aura->GetSpellProto();
+                    if (m_spell->SpellFamilyName != SPELLFAMILY_WARLOCK || !(m_spell->SpellFamilyFlags[1] & 0x0004071B || m_spell->SpellFamilyFlags[0] & 0x8044C402))
+                        continue;
+                    modPercent += stepPercent * aura->GetStackAmount();
+                    if (modPercent >= maxPercent)
+                    {
+                        modPercent = maxPercent;
+                        break;
+                    }
+                }
+                DoneTotalMod *= (modPercent+100.0f)/100.0f;
+                break;
+            }
+            case 6916: // Death's Embrace
+            case 6925:
+            case 6927:
+                if (HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, spellProto, this))
+                    DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
+                break;
+            case 5481: // Starfire Bonus
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x200002, 0, 0))
+                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                break;
+            }
+            case 4418: // Increased Shock Damage
+            case 4554: // Increased Lightning Damage
+            case 4555: // Improved Moonfire
+            case 5142: // Increased Lightning Damage
+            case 5147: // Improved Consecration / Libram of Resurgence
+            case 5148: // Idol of the Shooting Star
+            case 6008: // Increased Lightning Damage
+            case 8627: // Totem of Hex
+            {
+                DoneTotal += (*i)->GetAmount();
+                break;
+            }
+            // Tundra Stalker
+            // Merciless Combat
+            case 7277:
+            {
+                // Merciless Combat
+                if ((*i)->GetSpellProto()->SpellIconID == 2656)
+                {
+                    if (!pVictim->HealthAbovePct(35))
+                        DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
+                }
+                // Tundra Stalker
+                else
+                {
+                    // Frost Fever (target debuff)
+                    if (pVictim->HasAura(55095))
+                        DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                    break;
+                }
+                break;
+            }
+            // Rage of Rivendare
+            case 7293:
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0,0x02000000,0))
+                {
+                    if (SpellChainNode const *chain = sSpellMgr.GetSpellChainNode((*i)->GetId()))
+                        DoneTotalMod *= (chain->rank * 2.0f + 100.0f)/100.0f;
+                }
+                break;
+            }
+            // Twisted Faith
+            case 7377:
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0,0, GetGUID()))
+                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                break;
+            }
+            // Marked for Death
+            case 7598:
+            case 7599:
+            case 7600:
+            case 7601:
+            case 7602:
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400, 0, 0))
+                    DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
+                break;
+            }
+        }
+    }
+
+    // Custom scripted damage
+    switch(spellProto->SpellFamilyName)
+    {
+        case SPELLFAMILY_MAGE:
+            // Ice Lance
+            if (spellProto->SpellIconID == 186)
+            {
+                if (pVictim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
+                {
+                    // Glyph of Ice Lance
+                    if (owner->HasAura(56377) && pVictim->getLevel() > owner->getLevel())
+                        DoneTotalMod *= 4.0f;
+                    else
+                        DoneTotalMod *= 3.0f;
+                }
+            }
+
+            // Torment the weak
+            if (spellProto->SpellFamilyFlags[0]&0x20200021 || spellProto->SpellFamilyFlags[1]& 0x9000)
+                if (pVictim->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED))
+                {
+                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)
+                        if ((*i)->GetSpellProto()->SpellIconID == 3263)
+                        {
+                            DoneTotalMod *= float((*i)->GetAmount() + 100.f) / 100.f;
+                            break;
+                        }
+                }
+        break;
+        case SPELLFAMILY_PRIEST:
+            if (spellProto->SpellFamilyFlags[0] & 0x800000)
+            {
+                // Glyph of Shadow Word: Pain
+                if (AuraEffect * aurEff = GetAuraEffect(55687, 0))
+                    // Increase Mind Flay damage if Shadow Word: Pain present on target
+                    if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0,0, GetGUID()))
+                        DoneTotalMod *= (aurEff->GetAmount() + 100.0f) / 100.f;
+
+                // Twisted Faith - Mind Flay part
+                if (AuraEffect * aurEff = GetAuraEffect(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS, SPELLFAMILY_PRIEST, 2848, 1))
+                    // Increase Mind Flay damage if Shadow Word: Pain present on target
+                    if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0,0, GetGUID()))
+                        DoneTotalMod *= (aurEff->GetAmount() + 100.0f) / 100.f;
+            }
+        break;
+        case SPELLFAMILY_PALADIN:
+            // Judgement of Vengeance/Judgement of Corruption
+            if ((spellProto->SpellFamilyFlags[1] & 0x400000) && spellProto->SpellIconID == 2292)
+            {
+                // Get stack of Holy Vengeance/Blood Corruption on the target added by caster
+                uint32 stacks = 0;
+                Unit::AuraEffectList const& auras = pVictim->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
+                for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    if (((*itr)->GetId() == 31803 || (*itr)->GetId() == 53742) && (*itr)->GetCasterGUID() == GetGUID())
+                    {
+                        stacks = (*itr)->GetBase()->GetStackAmount();
+                        break;
+                    }
+                // + 10% for each application of Holy Vengeance/Blood Corruption on the target
+                if (stacks)
+                    DoneTotalMod *= (10.0f + float(stacks)) / 10.0f;
+            }
+        break;
+        case SPELLFAMILY_WARLOCK:
+            //Fire and Brimstone
+            if (spellProto->SpellFamilyFlags[1] & 0x00020040)
+                if (pVictim->HasAuraState(AURA_STATE_CONFLAGRATE))
+                {
+                    AuraEffectList const& mDumyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+                    for (AuraEffectList::const_iterator i = mDumyAuras.begin(); i != mDumyAuras.end(); ++i)
+                        if ((*i)->GetSpellProto()->SpellIconID == 3173)
+                        {
+                            DoneTotalMod *= float((*i)->GetAmount() + 100.f) / 100.f;
+                            break;
+                        }
+                }
+            // Drain Soul - increased damage for targets under 25 % HP
+            if (spellProto->SpellFamilyFlags[0] & 0x00004000)
+                if (HasAura(200000))
+                    DoneTotalMod *= 4;
+        break;
+        case SPELLFAMILY_DEATHKNIGHT:
+            // Improved Icy Touch
+            if (spellProto->SpellFamilyFlags[0] & 0x2)
+                if (AuraEffect * aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2721, 0))
+                    DoneTotalMod *= (100.0f + aurEff->GetAmount()) / 100.0f;
+            // Glacier Rot
+            if (spellProto->SpellFamilyFlags[0] & 0x2 || spellProto->SpellFamilyFlags[1] & 0x6)
+                if (AuraEffect * aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 196, 0))
+                    if (pVictim->GetDiseasesByCaster(owner->GetGUID()) > 0)
+                        DoneTotalMod *= (100.0f + aurEff->GetAmount()) / 100.0f;
+             // Sigil of the Vengeful Heart (Death Coil part)
+                 if (spellProto->SpellFamilyFlags[0] & 0x2000)
+                     if (AuraEffect * aurEff = GetAuraEffect(64962, 1))
+                         DoneTotal += aurEff->GetAmount();
+            // Impurity (dummy effect)
+            if (GetTypeId() == TYPEID_PLAYER)
+            {
+                PlayerSpellMap playerSpells = this->ToPlayer()->GetSpellMap();
+                for (PlayerSpellMap::const_iterator itr = playerSpells.begin(); itr != playerSpells.end(); ++itr)
+                {
+                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+                        continue;
+                    switch (itr->first)
+                    {
+                        case 49220:
+                        case 49633:
+                        case 49635:
+                        case 49636:
+                        case 49638:
+                        {
+                            if (const SpellEntry *proto=sSpellStore.LookupEntry(itr->first))
+                                ApCoeffMod *= (100.0f + SpellMgr::CalculateSpellEffectAmount(proto, 0)) / 100.0f;
+                        }
+                        break;
+                    }
+                }
+            }
+        break;
+    }
+
+    // ..taken
+    int32 maxPositiveMod = 0; // max of the positive amount aura (that increase the damage taken)
+    int32 sumNegativeMod = 0; // sum the negative amount aura (that reduce the damage taken)
+    AuraEffectList const& mModDamagePercentTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
+    for (AuraEffectList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
+        if ((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto))
+        {
+            if ((*i)->GetAmount() > 0)
+            {
+                if ((*i)->GetAmount() > maxPositiveMod)
+                    maxPositiveMod = (*i)->GetAmount();
+            }
+            else
+                sumNegativeMod += (*i)->GetAmount();
+        }
+
+    // .. taken pct: dummy auras
+    AuraEffectList const& mDummyAuras = pVictim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+    {
+        switch((*i)->GetSpellProto()->SpellIconID)
+        {
+            // Cheat Death
+            case 2109:
+                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
+                {
+                    if (pVictim->GetTypeId() != TYPEID_PLAYER)
+                        continue;
+                    float mod = pVictim->ToPlayer()->GetRatingBonusValue(CR_CRIT_TAKEN_MELEE)*(-8.0f);
+                    if (mod < (*i)->GetAmount())
+                        mod = (float)(*i)->GetAmount();
+                    sumNegativeMod += int32(mod);
+                }
+                break;
+            // Ebon Plague
+            case 1933:
+                if ((*i)->GetMiscValue() & (spellProto ? GetSpellSchoolMask(spellProto) : 0))
+                {
+                    if ((*i)->GetAmount() > maxPositiveMod)
+                        maxPositiveMod = (*i)->GetAmount();
+                }
+                break;
+        }
+    }
+
+    // From caster spells
+    AuraEffectList const& mOwnerTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
+    for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
+        if ((*i)->GetCasterGUID() == GetGUID() && (*i)->IsAffectedOnSpell(spellProto))
+            sumNegativeMod += (*i)->GetAmount();
+
+    // Mod damage from spell mechanic
+    if (uint32 mechanicMask = GetAllSpellMechanicMask(spellProto))
+    {
+        AuraEffectList const& mDamageDoneMechanic = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
+        for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
+            if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))
+                sumNegativeMod += (*i)->GetAmount();
+    }
+
+    float TakenTotalMod = (sumNegativeMod+maxPositiveMod+100.0f)/100.0f;
+
+    // Taken/Done fixed damage bonus auras
+    int32 DoneAdvertisedBenefit  = SpellBaseDamageBonus(GetSpellSchoolMask(spellProto));
+    int32 TakenAdvertisedBenefit = SpellBaseDamageBonusForVictim(GetSpellSchoolMask(spellProto), pVictim);
+    // Pets just add their bonus damage to their spell damage
+    // note that their spell damage is just gain of their own auras
+    if (HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+        DoneAdvertisedBenefit += ((Guardian*)this)->GetBonusDamage();
+
+    // Check for table values
+    float coeff = 0;
+    SpellBonusEntry const *bonus = sSpellMgr.GetSpellBonusData(spellProto->Id);
+    if (bonus)
+    {
+        if (damagetype == DOT)
+        {
+            coeff = bonus->dot_damage;
+            if (bonus->ap_dot_bonus > 0)
+            {
+                WeaponAttackType attType = (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK;
+                float APbonus = attType == BASE_ATTACK ? pVictim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS) : pVictim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
+                APbonus += GetTotalAttackPowerValue(attType);
+                DoneTotal += int32(bonus->ap_dot_bonus * stack * ApCoeffMod * APbonus);
+            }
+        }
+        else
+        {
+            coeff = bonus->direct_damage;
+            if (bonus->ap_bonus > 0)
+            {
+                WeaponAttackType attType = (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass != SPELL_DAMAGE_CLASS_MELEE) ? RANGED_ATTACK : BASE_ATTACK;
+                float APbonus = attType == BASE_ATTACK ? pVictim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS) : pVictim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
+                APbonus += GetTotalAttackPowerValue(attType);
+                DoneTotal += int32(bonus->ap_bonus * stack * ApCoeffMod * APbonus);
+            }
+        }
+    }
+    // Default calculation
+    if (DoneAdvertisedBenefit || TakenAdvertisedBenefit)
+    {
+        if (!bonus || coeff < 0)
+        {
+            // Damage Done from spell damage bonus
+            int32 CastingTime = IsChanneledSpell(spellProto) ? GetSpellDuration(spellProto) : GetSpellCastTime(spellProto);
+            // Damage over Time spells bonus calculation
+            float DotFactor = 1.0f;
+            if (damagetype == DOT)
+            {
+                int32 DotDuration = GetSpellDuration(spellProto);
+                // 200% limit
+                if (DotDuration > 0)
+                {
+                    if (DotDuration > 30000)
+                        DotDuration = 30000;
+                    if (!IsChanneledSpell(spellProto))
+                        DotFactor = DotDuration / 15000.0f;
+                    uint8 x = 0;
+                    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+                    {
+                        if (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && (
+                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_DAMAGE ||
+                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
+                        {
+                            x = j;
+                            break;
+                        }
+                    }
+                    int32 DotTicks = 6;
+                    if (spellProto->EffectAmplitude[x] != 0)
+                        DotTicks = DotDuration / spellProto->EffectAmplitude[x];
+                    if (DotTicks)
+                    {
+                        DoneAdvertisedBenefit /= DotTicks;
+                        TakenAdvertisedBenefit /= DotTicks;
+                    }
+                }
+            }
+            // Distribute Damage over multiple effects, reduce by AoE
+            CastingTime = GetCastingTimeForBonus(spellProto, damagetype, CastingTime);
+
+            // 50% for damage and healing spells for leech spells from damage bonus and 0% from healing
+            for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+            {
+                if (spellProto->Effect[j] == SPELL_EFFECT_HEALTH_LEECH ||
+                    (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
+                {
+                    CastingTime /= 2;
+                    break;
+                }
+            }
+            if (spellProto->SchoolMask != SPELL_SCHOOL_MASK_NORMAL)
+                coeff = (CastingTime / 3500.0f) * DotFactor;
+            else
+                coeff = DotFactor;
+        }
+
+        float coeff2 = CalculateLevelPenalty(spellProto) * stack;
+        if (spellProto->SpellFamilyName) //TODO: fix this
+            TakenTotal+= int32(TakenAdvertisedBenefit * coeff * coeff2);
+        if (Player* modOwner = GetSpellModOwner())
+        {
+            coeff *= 100.0f;
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
+            coeff /= 100.0f;
+        }
+        DoneTotal += int32(DoneAdvertisedBenefit * coeff * coeff2);
+    }
+
+    // Some spells don't benefit from done mods
+    if (spellProto->AttributesEx3 & SPELL_ATTR_EX3_NO_DONE_BONUS)
+    {
+        DoneTotal = 0;
+        DoneTotalMod = 1.0f;
+    }
+
+    float tmpDamage = (int32(pdamage) + DoneTotal) * DoneTotalMod;
+    // apply spellmod to Done damage (flat and pct)
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, tmpDamage);
+
+    tmpDamage = (tmpDamage + TakenTotal) * TakenTotalMod;
+
+    return uint32(std::max(tmpDamage, 0.0f));
+}
+
+int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
+{
+    int32 DoneAdvertisedBenefit = 0;
+
+    // ..done
+    AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
+    for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)
+        if (((*i)->GetMiscValue() & schoolMask) != 0 &&
+        (*i)->GetSpellProto()->EquippedItemClass == -1 &&
+                                                            // -1 == any item class (not wand then)
+        (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0)
+                                                            // 0 == any inventory type (not wand then)
+            DoneAdvertisedBenefit += (*i)->GetAmount();
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        // Base value
+        DoneAdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
+
+        // Damage bonus from stats
+        AuraEffectList const& mDamageDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT);
+        for (AuraEffectList::const_iterator i = mDamageDoneOfStatPercent.begin(); i != mDamageDoneOfStatPercent.end(); ++i)
+        {
+            if ((*i)->GetMiscValue() & schoolMask)
+            {
+                // stat used stored in miscValueB for this aura
+                Stats usedStat = Stats((*i)->GetMiscValueB());
+                DoneAdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetAmount() / 100.0f);
+            }
+        }
+        // ... and attack power
+        AuraEffectList const& mDamageDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER);
+        for (AuraEffectList::const_iterator i =mDamageDonebyAP.begin(); i != mDamageDonebyAP.end(); ++i)
+            if ((*i)->GetMiscValue() & schoolMask)
+                DoneAdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetAmount() / 100.0f);
+
+    }
+    return DoneAdvertisedBenefit > 0 ? DoneAdvertisedBenefit : 0;
+}
+
+int32 Unit::SpellBaseDamageBonusForVictim(SpellSchoolMask schoolMask, Unit *pVictim)
+{
+    uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
+
+    int32 TakenAdvertisedBenefit = 0;
+    // ..done (for creature type by mask) in taken
+    AuraEffectList const& mDamageDoneCreature = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
+    for (AuraEffectList::const_iterator i = mDamageDoneCreature.begin(); i != mDamageDoneCreature.end(); ++i)
+        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+            TakenAdvertisedBenefit += (*i)->GetAmount();
+
+    // ..taken
+    AuraEffectList const& mDamageTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
+    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
+        if (((*i)->GetMiscValue() & schoolMask) != 0)
+            TakenAdvertisedBenefit += (*i)->GetAmount();
+
+    return TakenAdvertisedBenefit > 0 ? TakenAdvertisedBenefit : 0;
+}
+
+bool Unit::isSpellCrit(Unit *pVictim, SpellEntry const *spellProto, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    // Mobs can't crit with spells.
+    if (IS_CREATURE_GUID(GetGUID()))
+        return false;
+
+    // not critting spell
+    if ((spellProto->AttributesEx2 & SPELL_ATTR_EX2_CANT_CRIT))
+        return false;
+
+    float crit_chance = 0.0f;
+    switch(spellProto->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_NONE:  // Exception for Earth Shield and Lifebloom Final Bloom
+            if (spellProto->Id != 379 && spellProto->Id != 33778) // We need more spells to find a general way (if there is any)
+                return false;
+        case SPELL_DAMAGE_CLASS_MAGIC:
+        {
+            if (schoolMask & SPELL_SCHOOL_MASK_NORMAL)
+                crit_chance = 0.0f;
+            // For other schools
+            else if (GetTypeId() == TYPEID_PLAYER)
+                crit_chance = GetFloatValue(PLAYER_SPELL_CRIT_PERCENTAGE1 + GetFirstSchoolInMask(schoolMask));
+            else
+            {
+                crit_chance = (float)m_baseSpellCritChance;
+                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
+            }
+            // taken
+            if (pVictim)
+            {
+                if (!IsPositiveSpell(spellProto->Id))
+                {
+                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE
+                    crit_chance += pVictim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, schoolMask);
+                    // Modify critical chance by victim SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE
+                    crit_chance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE);
+                    ApplyResilience(pVictim, &crit_chance, NULL, false, CR_CRIT_TAKEN_SPELL);
+                }
+                // scripted (increase crit chance ... against ... target by x%
+                AuraEffectList const& mOverrideClassScript = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+                for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
+                {
+                    if (!((*i)->IsAffectedOnSpell(spellProto)))
+                        continue;
+                    int32 modChance=0;
+                    switch((*i)->GetMiscValue())
+                    {
+                        // Shatter
+                        case  911: modChance+= 16;
+                        case  910: modChance+= 17;
+                        case  849: modChance+= 17;
+                            if (!pVictim->HasAuraState(AURA_STATE_FROZEN, spellProto, this))
+                                break;
+                            crit_chance+=modChance;
+                            break;
+                        case 7917: // Glyph of Shadowburn
+                            if (pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))
+                                crit_chance+=(*i)->GetAmount();
+                            break;
+                        case 7997: // Renewed Hope
+                        case 7998:
+                            if (pVictim->HasAura(6788))
+                                crit_chance+=(*i)->GetAmount();
+                            break;
+                        case   21: // Test of Faith
+                        case 6935:
+                        case 6918:
+                            if (pVictim->HealthBelowPct(50))
+                                crit_chance+=(*i)->GetAmount();
+                            break;
+                        default:
+                            break;
+                    }
+                }
+                // Custom crit by class
+                switch (spellProto->SpellFamilyName)
+                {
+                    case SPELLFAMILY_DRUID:
+                        // Starfire
+                        if (spellProto->SpellFamilyFlags[0] & 0x4 && spellProto->SpellIconID == 1485)
+                        {
+                            // Improved Insect Swarm
+                            if (AuraEffect const * aurEff = GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))
+                                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00000002, 0, 0))
+                                    crit_chance+=aurEff->GetAmount();
+                           break;
+                        }
+                    break;
+                    case SPELLFAMILY_ROGUE:
+                        // Shiv-applied poisons can't crit
+                        if (FindCurrentSpellBySpellId(5938))
+                            crit_chance = 0.0f;
+                        break;
+                    case SPELLFAMILY_PALADIN:
+                        // Flash of light
+                        if (spellProto->SpellFamilyFlags[0] & 0x40000000)
+                        {
+                            // Sacred Shield
+                            AuraEffect const* aura = pVictim->GetAuraEffect(58597,1);
+                            if (aura && aura->GetCasterGUID() == GetGUID())
+                                crit_chance+=aura->GetAmount();
+                            break;
+                        }
+                        // Exorcism
+                        else if (spellProto->Category == 19)
+                        {
+                            if (pVictim->GetCreatureTypeMask() & CREATURE_TYPEMASK_DEMON_OR_UNDEAD)
+                                return true;
+                            break;
+                        }
+                    break;
+                    case SPELLFAMILY_SHAMAN:
+                        // Lava Burst
+                        if (spellProto->SpellFamilyFlags[1] & 0x00001000)
+                        {
+                            if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0,0, GetGUID()))
+                                return true;
+                            break;
+                        }
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELL_DAMAGE_CLASS_MELEE:
+            if (pVictim)
+            {
+                // Custom crit by class
+                switch(spellProto->SpellFamilyName)
+                {
+                    case SPELLFAMILY_DRUID:
+                        // Rend and Tear - bonus crit chance for Ferocious Bite on bleeding targets
+                        if (spellProto->SpellFamilyFlags[0] & 0x00800000
+                            && spellProto->SpellIconID == 1680
+                            && pVictim->HasAuraState(AURA_STATE_BLEEDING))
+                        {
+                            if (AuraEffect const *rendAndTear = GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 1))
+                                crit_chance += rendAndTear->GetAmount();
+                            break;
+                        }
+                    break;
+                    case SPELLFAMILY_PALADIN:
+                        // Judgement of Command proc always crits on stunned target
+                        if (spellProto->SpellFamilyName == SPELLFAMILY_PALADIN)
+                            if (spellProto->SpellFamilyFlags[0] & 0x0000000000800000LL && spellProto->SpellIconID == 561)
+                                if (pVictim->hasUnitState(UNIT_STAT_STUNNED))
+                                    return true;
+                }
+            }
+        case SPELL_DAMAGE_CLASS_RANGED:
+        {
+            if (pVictim)
+            {
+                crit_chance += GetUnitCriticalChance(attackType, pVictim);
+                crit_chance += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_SPELL_CRIT_CHANCE_SCHOOL, schoolMask);
+            }
+            break;
+        }
+        default:
+            return false;
+    }
+    // percent done
+    // only players use intelligence for critical chance computations
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance);
+
+    crit_chance = crit_chance > 0.0f ? crit_chance : 0.0f;
+    if (roll_chance_f(crit_chance))
+        return true;
+    return false;
+}
+
+uint32 Unit::SpellCriticalDamageBonus(SpellEntry const *spellProto, uint32 damage, Unit *pVictim)
+{
+    // Calculate critical bonus
+    int32 crit_bonus;
+    switch(spellProto->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_MELEE:                      // for melee based spells is 100%
+        case SPELL_DAMAGE_CLASS_RANGED:
+            // TODO: write here full calculation for melee/ranged spells
+            crit_bonus = damage;
+            break;
+        default:
+            crit_bonus = damage / 2;                        // for spells is 50%
+            break;
+    }
+
+    // adds additional damage to crit_bonus (from talents)
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRIT_DAMAGE_BONUS, crit_bonus);
+
+    if (pVictim)
+    {
+        uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
+        crit_bonus = int32(crit_bonus * GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, creatureTypeMask));
+    }
+
+    if (crit_bonus > 0)
+        damage += crit_bonus;
+
+    return damage;
+}
+
+uint32 Unit::SpellCriticalHealingBonus(SpellEntry const *spellProto, uint32 damage, Unit *pVictim)
+{
+    // Calculate critical bonus
+    int32 crit_bonus;
+    switch(spellProto->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_MELEE:                      // for melee based spells is 100%
+        case SPELL_DAMAGE_CLASS_RANGED:
+            // TODO: write here full calculation for melee/ranged spells
+            crit_bonus = damage;
+            break;
+        default:
+            crit_bonus = damage / 2;                        // for spells is 50%
+            break;
+    }
+
+    if (pVictim)
+    {
+        uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
+        crit_bonus = int32(crit_bonus * GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CRIT_PERCENT_VERSUS, creatureTypeMask));
+    }
+
+    if (crit_bonus > 0)
+        damage += crit_bonus;
+
+    damage = int32(float(damage) * GetTotalAuraMultiplier(SPELL_AURA_MOD_CRITICAL_HEALING_AMOUNT));
+
+    return damage;
+}
+
+uint32 Unit::SpellHealingBonus(Unit *pVictim, SpellEntry const *spellProto, uint32 healamount, DamageEffectType damagetype, uint32 stack)
+{
+    // For totems get healing bonus from owner (statue isn't totem in fact)
+    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isTotem())
+        if (Unit* owner = GetOwner())
+            return owner->SpellHealingBonus(pVictim, spellProto, healamount, damagetype, stack);
+
+    // no bonus for heal potions/bandages
+    if (spellProto->SpellFamilyName == SPELLFAMILY_POTION)
+        return healamount;
+
+    // Healing Done
+    // Taken/Done total percent damage auras
+    float  DoneTotalMod = 1.0f;
+    float  TakenTotalMod = 1.0f;
+    int32  DoneTotal = 0;
+    int32  TakenTotal = 0;
+
+    // Healing done percent
+    AuraEffectList const& mHealingDonePct = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE_PERCENT);
+    for (AuraEffectList::const_iterator i = mHealingDonePct.begin(); i != mHealingDonePct.end(); ++i)
+        DoneTotalMod *= (100.0f + (*i)->GetAmount()) / 100.0f;
+
+    // done scripted mod (take it from owner)
+    Unit *owner = GetOwner() ? GetOwner() : this;
+    AuraEffectList const &mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
+    {
+        if (!(*i)->IsAffectedOnSpell(spellProto))
+            continue;
+        switch((*i)->GetMiscValue())
+        {
+            case 4415: // Increased Rejuvenation Healing
+            case 4953:
+            case 3736: // Hateful Totem of the Third Wind / Increased Lesser Healing Wave / LK Arena (4/5/6) Totem of the Third Wind / Savage Totem of the Third Wind
+                DoneTotal+=(*i)->GetAmount();
+                break;
+            case 7997: // Renewed Hope
+            case 7998:
+                if (pVictim->HasAura(6788))
+                    DoneTotalMod *=((*i)->GetAmount() + 100.0f)/100.0f;
+                break;
+            case   21: // Test of Faith
+            case 6935:
+            case 6918:
+                if (pVictim->HealthBelowPct(50))
+                    DoneTotalMod *=((*i)->GetAmount() + 100.0f)/100.0f;
+                break;
+            case 7798: // Glyph of Regrowth
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0, 0))
+                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                break;
+            }
+            case 8477: // Nourish Heal Boost
+            {
+                int32 stepPercent = (*i)->GetAmount();
+                int32 modPercent = 0;
+                AuraApplicationMap const& victimAuras = pVictim->GetAppliedAuras();
+                for (AuraApplicationMap::const_iterator itr = victimAuras.begin(); itr != victimAuras.end(); ++itr)
+                {
+                    Aura const * aura = itr->second->GetBase();
+                    if (aura->GetCasterGUID() != GetGUID())
+                        continue;
+                    SpellEntry const* m_spell = aura->GetSpellProto();
+                    if (m_spell->SpellFamilyName != SPELLFAMILY_DRUID ||
+                        !(m_spell->SpellFamilyFlags[1] & 0x00000010 || m_spell->SpellFamilyFlags[0] & 0x50))
+                        continue;
+                    modPercent += stepPercent * aura->GetStackAmount();
+                }
+                DoneTotalMod *= (modPercent+100.0f)/100.0f;
+                break;
+            }
+            case 7871: // Glyph of Lesser Healing Wave
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 0 , 0x00000400, 0, GetGUID()))
+                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                break;
+            }
+            default:
+                break;
+        }
+    }
+
+    // Taken/Done fixed damage bonus auras
+    int32 DoneAdvertisedBenefit  = SpellBaseHealingBonus(GetSpellSchoolMask(spellProto));
+    int32 TakenAdvertisedBenefit = SpellBaseHealingBonusForVictim(GetSpellSchoolMask(spellProto), pVictim);
+
+    bool scripted = false;
+
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spellProto->EffectApplyAuraName[i])
+        {
+            // These auras do not use healing coeff
+            case SPELL_AURA_PERIODIC_LEECH:
+            case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
+                scripted = true;
+                break;
+        }
+    }
+
+    // Check for table values
+    SpellBonusEntry const* bonus = !scripted ? sSpellMgr.GetSpellBonusData(spellProto->Id) : NULL;
+    float coeff = 0;
+    float factorMod = 1.0f;
+    if (bonus)
+    {
+        if (damagetype == DOT)
+        {
+            coeff = bonus->dot_damage;
+            if (bonus->ap_dot_bonus > 0)
+                DoneTotal += int32(bonus->ap_dot_bonus * stack * GetTotalAttackPowerValue(
+                    (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE)? RANGED_ATTACK : BASE_ATTACK));
+        }
+        else
+        {
+            coeff = bonus->direct_damage;
+            if (bonus->ap_bonus > 0)
+                DoneTotal += int32(bonus->ap_bonus * stack * GetTotalAttackPowerValue(
+                    (IsRangedWeaponSpell(spellProto) && spellProto->DmgClass !=SPELL_DAMAGE_CLASS_MELEE)? RANGED_ATTACK : BASE_ATTACK));
+        }
+    }
+    else // scripted bonus
+    {
+        // Gift of the Naaru
+        if (spellProto->SpellFamilyFlags[2] & 0x80000000 && spellProto->SpellIconID == 329)
+        {
+            scripted = true;
+            int32 apBonus = int32(std::max(GetTotalAttackPowerValue(BASE_ATTACK), GetTotalAttackPowerValue(RANGED_ATTACK)));
+            if (apBonus > DoneAdvertisedBenefit)
+                DoneTotal += int32(apBonus * 0.22f); // 22% of AP per tick
+            else
+                DoneTotal += int32(DoneAdvertisedBenefit * 0.377f); //37.7% of BH per tick
+        }
+        // Earthliving - 0.45% of normal hot coeff
+        else if (spellProto->SpellFamilyName == SPELLFAMILY_SHAMAN && spellProto->SpellFamilyFlags[1] & 0x80000)
+            factorMod *= 0.45f;
+        // Already set to scripted? so not uses healing bonus coefficient
+        // No heal coeff for SPELL_DAMAGE_CLASS_NONE class spells by default
+        else if (scripted || spellProto->DmgClass == SPELL_DAMAGE_CLASS_NONE)
+        {
+            scripted = true;
+            coeff = 0.0f;
+        }
+    }
+
+    // Default calculation
+    if (DoneAdvertisedBenefit || TakenAdvertisedBenefit)
+    {
+        if ((!bonus && !scripted) || coeff < 0)
+        {
+            // Damage Done from spell damage bonus
+            int32 CastingTime = !IsChanneledSpell(spellProto) ? GetSpellCastTime(spellProto) : GetSpellDuration(spellProto);
+            // Damage over Time spells bonus calculation
+            float DotFactor = 1.0f;
+            if (damagetype == DOT)
+            {
+                int32 DotDuration = GetSpellDuration(spellProto);
+                // 200% limit
+                if (DotDuration > 0)
+                {
+                    if (DotDuration > 30000) DotDuration = 30000;
+                    if (!IsChanneledSpell(spellProto)) DotFactor = DotDuration / 15000.0f;
+                    uint32 x = 0;
+                    for (uint8 j = 0; j < MAX_SPELL_EFFECTS; j++)
+                    {
+                        if (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && (
+                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_DAMAGE ||
+                            spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
+                        {
+                            x = j;
+                            break;
+                        }
+                    }
+                    int32 DotTicks = 6;
+                    if (spellProto->EffectAmplitude[x] != 0)
+                        DotTicks = DotDuration / spellProto->EffectAmplitude[x];
+                    if (DotTicks)
+                    {
+                        DoneAdvertisedBenefit = DoneAdvertisedBenefit * int32(stack) / DotTicks;
+                        TakenAdvertisedBenefit = TakenAdvertisedBenefit * int32(stack) / DotTicks;
+                    }
+                }
+            }
+            // Distribute Damage over multiple effects, reduce by AoE
+            CastingTime = GetCastingTimeForBonus(spellProto, damagetype, CastingTime);
+            // 50% for damage and healing spells for leech spells from damage bonus and 0% from healing
+            for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+            {
+                if (spellProto->Effect[j] == SPELL_EFFECT_HEALTH_LEECH ||
+                    (spellProto->Effect[j] == SPELL_EFFECT_APPLY_AURA && spellProto->EffectApplyAuraName[j] == SPELL_AURA_PERIODIC_LEECH))
+                {
+                    CastingTime /= 2;
+                    break;
+                }
+            }
+            // As wowwiki says: C = (Cast Time / 3.5) * 1.88 (for healing spells)
+            coeff = (CastingTime / 3500.0f) * DotFactor * 1.88f;
+        }
+
+        factorMod *= CalculateLevelPenalty(spellProto)* stack;
+        TakenTotal += int32(TakenAdvertisedBenefit * coeff * factorMod);
+        if (Player* modOwner = GetSpellModOwner())
+        {
+            coeff *= 100.0f;
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_BONUS_MULTIPLIER, coeff);
+            coeff /= 100.0f;
+        }
+        DoneTotal += int32(DoneAdvertisedBenefit * coeff * factorMod);
+    }
+
+    // use float as more appropriate for negative values and percent applying
+    float heal = (int32(healamount) + DoneTotal) * DoneTotalMod;
+    // apply spellmod to Done amount
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
+
+    // Nourish cast
+    if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[1] & 0x2000000)
+    {
+        // Rejuvenation, Regrowth, Lifebloom, or Wild Growth
+        if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x50, 0x4000010, 0))
+            //increase healing by 20%
+            TakenTotalMod *= 1.2f;
+    }
+
+    // Taken mods
+
+    // Healing Wave
+    if (spellProto->SpellFamilyName == SPELLFAMILY_SHAMAN && spellProto->SpellFamilyFlags[0] & 0x40)
+    {
+        // Search for Healing Way on Victim
+        if (AuraEffect const* HealingWay = pVictim->GetAuraEffect(29203, 0))
+            TakenTotalMod *= (HealingWay->GetAmount() + 100.0f) / 100.0f;
+    }
+
+    // Tenacity increase healing % taken
+    if (AuraEffect const* Tenacity = pVictim->GetAuraEffect(58549, 0))
+        TakenTotalMod *= (Tenacity->GetAmount() + 100.0f) / 100.0f;
+
+
+    // Healing taken percent
+    float minval = (float)pVictim->GetMaxNegativeAuraModifier(SPELL_AURA_MOD_HEALING_PCT);
+    if (minval)
+        TakenTotalMod *= (100.0f + minval) / 100.0f;
+
+    float maxval = (float)pVictim->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HEALING_PCT);
+    if (maxval)
+        TakenTotalMod *= (100.0f + maxval) / 100.0f;
+
+    if (damagetype == DOT)
+    {
+        // Healing over time taken percent
+        float minval_hot = (float)pVictim->GetMaxNegativeAuraModifier(SPELL_AURA_MOD_HOT_PCT);
+        if (minval_hot)
+            TakenTotalMod *= (100.0f + minval_hot) / 100.0f;
+
+        float maxval_hot = (float)pVictim->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HOT_PCT);
+        if (maxval_hot)
+            TakenTotalMod *= (100.0f + maxval_hot) / 100.0f;
+    }
+
+    AuraEffectList const& mHealingGet= pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_RECEIVED);
+    for (AuraEffectList::const_iterator i = mHealingGet.begin(); i != mHealingGet.end(); ++i)
+        if (GetGUID() == (*i)->GetCasterGUID() && (*i)->IsAffectedOnSpell(spellProto))
+            TakenTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
+
+    heal = (int32(heal) + TakenTotal) * TakenTotalMod;
+
+    return uint32(std::max(heal, 0.0f));
+}
+
+int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
+{
+    int32 AdvertisedBenefit = 0;
+
+    AuraEffectList const& mHealingDone = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE);
+    for (AuraEffectList::const_iterator i = mHealingDone.begin(); i != mHealingDone.end(); ++i)
+        if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
+            AdvertisedBenefit += (*i)->GetAmount();
+
+    // Healing bonus of spirit, intellect and strength
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        // Base value
+        AdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
+
+        // Healing bonus from stats
+        AuraEffectList const& mHealingDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT);
+        for (AuraEffectList::const_iterator i = mHealingDoneOfStatPercent.begin(); i != mHealingDoneOfStatPercent.end(); ++i)
+        {
+            // stat used dependent from misc value (stat index)
+            Stats usedStat = Stats((*i)->GetSpellProto()->EffectMiscValue[(*i)->GetEffIndex()]);
+            AdvertisedBenefit += int32(GetStat(usedStat) * (*i)->GetAmount() / 100.0f);
+        }
+
+        // ... and attack power
+        AuraEffectList const& mHealingDonebyAP = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER);
+        for (AuraEffectList::const_iterator i = mHealingDonebyAP.begin(); i != mHealingDonebyAP.end(); ++i)
+            if ((*i)->GetMiscValue() & schoolMask)
+                AdvertisedBenefit += int32(GetTotalAttackPowerValue(BASE_ATTACK) * (*i)->GetAmount() / 100.0f);
+    }
+    return AdvertisedBenefit;
+}
+
+int32 Unit::SpellBaseHealingBonusForVictim(SpellSchoolMask schoolMask, Unit *pVictim)
+{
+    int32 AdvertisedBenefit = 0;
+    AuraEffectList const& mDamageTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_HEALING);
+    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
+        if (((*i)->GetMiscValue() & schoolMask) != 0)
+            AdvertisedBenefit += (*i)->GetAmount();
+    return AdvertisedBenefit;
+}
+
+bool Unit::IsImmunedToDamage(SpellSchoolMask shoolMask)
+{
+    //If m_immuneToSchool type contain this school type, IMMUNE damage.
+    SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
+    for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
+        if (itr->type & shoolMask)
+            return true;
+
+    //If m_immuneToDamage type contain magic, IMMUNE damage.
+    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];
+    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)
+        if (itr->type & shoolMask)
+            return true;
+
+    return false;
+}
+
+bool Unit::IsImmunedToDamage(SpellEntry const* spellInfo)
+{
+    if (spellInfo->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return false;
+
+    uint32 shoolMask = GetSpellSchoolMask(spellInfo);
+    if (spellInfo->Id != 42292 && spellInfo->Id !=59752)
+    {
+        //If m_immuneToSchool type contain this school type, IMMUNE damage.
+        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
+        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
+            if (itr->type & shoolMask && !CanSpellPierceImmuneAura(spellInfo, sSpellStore.LookupEntry(itr->spellId)))
+                return true;
+    }
+
+    //If m_immuneToDamage type contain magic, IMMUNE damage.
+    SpellImmuneList const& damageList = m_spellImmune[IMMUNITY_DAMAGE];
+    for (SpellImmuneList::const_iterator itr = damageList.begin(); itr != damageList.end(); ++itr)
+        if (itr->type & shoolMask)
+            return true;
+
+    return false;
+}
+
+bool Unit::IsImmunedToSpell(SpellEntry const* spellInfo)
+{
+    if (!spellInfo)
+        return false;
+
+    // Single spell immunity.
+    SpellImmuneList const& idList = m_spellImmune[IMMUNITY_ID];
+    for (SpellImmuneList::const_iterator itr = idList.begin(); itr != idList.end(); ++itr)
+        if (itr->type == spellInfo->Id)
+            return true;
+
+    if (spellInfo->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return false;
+
+    if (spellInfo->Dispel)
+    {
+        SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
+        for (SpellImmuneList::const_iterator itr = dispelList.begin(); itr != dispelList.end(); ++itr)
+            if (itr->type == spellInfo->Dispel)
+                return true;
+    }
+
+    if (spellInfo->Mechanic)
+    {
+        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];
+        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)
+            if (itr->type == spellInfo->Mechanic)
+                return true;
+    }
+
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        // State/effect immunities applied by aura expect full spell immunity
+        // Ignore effects with mechanic, they are supposed to be checked separately
+        if (!spellInfo->EffectMechanic[i])
+            if (IsImmunedToSpellEffect(spellInfo, i))
+                return true;
+    }
+
+    if (spellInfo->Id != 42292 && spellInfo->Id !=59752)
+    {
+        SpellImmuneList const& schoolList = m_spellImmune[IMMUNITY_SCHOOL];
+        for (SpellImmuneList::const_iterator itr = schoolList.begin(); itr != schoolList.end(); ++itr)
+            if ((itr->type & GetSpellSchoolMask(spellInfo))
+                && !(IsPositiveSpell(itr->spellId) && IsPositiveSpell(spellInfo->Id))
+                && !CanSpellPierceImmuneAura(spellInfo, sSpellStore.LookupEntry(itr->spellId)))
+                return true;
+    }
+
+    return false;
+}
+
+bool Unit::IsImmunedToSpellEffect(SpellEntry const* spellInfo, uint32 index) const
+{
+    if (!spellInfo)
+        return false;
+    //If m_immuneToEffect type contain this effect type, IMMUNE effect.
+    uint32 effect = spellInfo->Effect[index];
+    SpellImmuneList const& effectList = m_spellImmune[IMMUNITY_EFFECT];
+    for (SpellImmuneList::const_iterator itr = effectList.begin(); itr != effectList.end(); ++itr)
+        if (itr->type == effect)
+            return true;
+
+    if (uint32 mechanic = spellInfo->EffectMechanic[index])
+    {
+        SpellImmuneList const& mechanicList = m_spellImmune[IMMUNITY_MECHANIC];
+        for (SpellImmuneList::const_iterator itr = mechanicList.begin(); itr != mechanicList.end(); ++itr)
+            if (itr->type == mechanic)
+                return true;
+    }
+
+    if (uint32 aura = spellInfo->EffectApplyAuraName[index])
+    {
+        SpellImmuneList const& list = m_spellImmune[IMMUNITY_STATE];
+        for (SpellImmuneList::const_iterator itr = list.begin(); itr != list.end(); ++itr)
+            if (itr->type == aura)
+                return true;
+        // Check for immune to application of harmful magical effects
+        AuraEffectList const& immuneAuraApply = GetAuraEffectsByType(SPELL_AURA_MOD_IMMUNE_AURA_APPLY_SCHOOL);
+        for (AuraEffectList::const_iterator iter = immuneAuraApply.begin(); iter != immuneAuraApply.end(); ++iter)
+            if (spellInfo->Dispel == DISPEL_MAGIC &&                                      // Magic debuff
+                ((*iter)->GetMiscValue() & GetSpellSchoolMask(spellInfo)) &&  // Check school
+                !IsPositiveEffect(spellInfo->Id, index))                                  // Harmful
+                return true;
+    }
+
+    return false;
+}
+
+bool Unit::IsDamageToThreatSpell(SpellEntry const * spellInfo) const
+{
+    if (!spellInfo)
+        return false;
+
+    switch(spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_WARLOCK:
+            if (spellInfo->SpellFamilyFlags[0] == 0x100) // Searing Pain
+                return true;
+            break;
+        case SPELLFAMILY_SHAMAN:
+            if (spellInfo->SpellFamilyFlags[0] == SPELLFAMILYFLAG_SHAMAN_FROST_SHOCK)
+                return true;
+            break;
+        case SPELLFAMILY_DEATHKNIGHT:
+            if (spellInfo->SpellFamilyFlags[1] == 0x20000000) // Rune Strike
+                return true;
+            break;
+    }
+
+    return false;
+}
+
+void Unit::MeleeDamageBonus(Unit *pVictim, uint32 *pdamage, WeaponAttackType attType, SpellEntry const *spellProto)
+{
+    if (!pVictim)
+        return;
+
+    if (*pdamage == 0)
+        return;
+
+    uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
+
+    // Taken/Done fixed damage bonus auras
+    int32 DoneFlatBenefit = 0;
+    int32 TakenFlatBenefit = 0;
+
+    // ..done (for creature type by mask) in taken
+    AuraEffectList const& mDamageDoneCreature = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_CREATURE);
+    for (AuraEffectList::const_iterator i = mDamageDoneCreature.begin(); i != mDamageDoneCreature.end(); ++i)
+        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+            DoneFlatBenefit += (*i)->GetAmount();
+
+    // ..done
+    // SPELL_AURA_MOD_DAMAGE_DONE included in weapon damage
+
+    // ..done (base at attack power for marked target and base at attack power for creature type)
+    int32 APbonus = 0;
+
+    if (attType == RANGED_ATTACK)
+    {
+        APbonus += pVictim->GetTotalAuraModifier(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS);
+
+        // ..done (base at attack power and creature type)
+        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_ATTACK_POWER_VERSUS);
+        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
+            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+                APbonus += (*i)->GetAmount();
+    }
+    else
+    {
+        APbonus += pVictim->GetTotalAuraModifier(SPELL_AURA_MELEE_ATTACK_POWER_ATTACKER_BONUS);
+
+        // ..done (base at attack power and creature type)
+        AuraEffectList const& mCreatureAttackPower = GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_ATTACK_POWER_VERSUS);
+        for (AuraEffectList::const_iterator i = mCreatureAttackPower.begin(); i != mCreatureAttackPower.end(); ++i)
+            if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+                APbonus += (*i)->GetAmount();
+    }
+
+    if (APbonus != 0)                                       // Can be negative
+    {
+        bool normalized = false;
+        if (spellProto)
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                if (spellProto->Effect[i] == SPELL_EFFECT_NORMALIZED_WEAPON_DMG)
+                {
+                    normalized = true;
+                    break;
+                }
+        DoneFlatBenefit += int32(APbonus/14.0f * GetAPMultiplier(attType,normalized));
+    }
+
+    // ..taken
+    AuraEffectList const& mDamageTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_TAKEN);
+    for (AuraEffectList::const_iterator i = mDamageTaken.begin(); i != mDamageTaken.end(); ++i)
+        if ((*i)->GetMiscValue() & GetMeleeDamageSchoolMask())
+            TakenFlatBenefit += (*i)->GetAmount();
+
+    if (attType != RANGED_ATTACK)
+        TakenFlatBenefit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN);
+    else
+        TakenFlatBenefit += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN);
+
+    // Done/Taken total percent damage auras
+    float DoneTotalMod = 1.0f;
+    float TakenTotalMod = 1.0f;
+
+    // ..done
+    // SPELL_AURA_MOD_DAMAGE_PERCENT_DONE included in weapon damage
+    // SPELL_AURA_MOD_OFFHAND_DAMAGE_PCT  included in weapon damage
+
+    // SPELL_AURA_MOD_DAMAGE_PERCENT_DONE for non-physical spells like Scourge Strike, Frost Strike, this is NOT included in weapon damage
+    if (spellProto)
+        if (GetSpellSchoolMask(spellProto) != SPELL_SCHOOL_MASK_NORMAL)
+        {
+            AuraEffectList const &mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
+            for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
+                if (((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto)) && !((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL))
+                    DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+        }
+
+    AuraEffectList const &mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersus.begin(); i != mDamageDoneVersus.end(); ++i)
+        if (creatureTypeMask & uint32((*i)->GetMiscValue()))
+            DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+
+    // bonus against aurastate
+    AuraEffectList const &mDamageDoneVersusAurastate = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS_AURASTATE);
+    for (AuraEffectList::const_iterator i = mDamageDoneVersusAurastate.begin(); i != mDamageDoneVersusAurastate.end(); ++i)
+        if (pVictim->HasAuraState(AuraState((*i)->GetMiscValue())))
+            DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
+
+    // done scripted mod (take it from owner)
+    Unit * owner = GetOwner() ? GetOwner() : this;
+    AuraEffectList const &mOverrideClassScript= owner->GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = mOverrideClassScript.begin(); i != mOverrideClassScript.end(); ++i)
+    {
+        if (!(*i)->IsAffectedOnSpell(spellProto))
+            continue;
+
+        switch ((*i)->GetMiscValue())
+        {
+            // Tundra Stalker
+            // Merciless Combat
+            case 7277:
+            {
+                // Merciless Combat
+                if ((*i)->GetSpellProto()->SpellIconID == 2656)
+                {
+                    if (!pVictim->HealthAbovePct(35))
+                        DoneTotalMod *= (100.0f+(*i)->GetAmount())/100.0f;
+                }
+                // Tundra Stalker
+                else
+                {
+                    // Frost Fever (target debuff)
+                    if (pVictim->HasAura(55095))
+                        DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                }
+                break;
+            }
+            // Rage of Rivendare
+            case 7293:
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0,0x02000000,0))
+                    if (SpellChainNode const *chain = sSpellMgr.GetSpellChainNode((*i)->GetId()))
+                        DoneTotalMod *= (chain->rank * 2.0f + 100.0f)/100.0f;
+                break;
+            }
+            // Marked for Death
+            case 7598:
+            case 7599:
+            case 7600:
+            case 7601:
+            case 7602:
+            {
+                if (pVictim->GetAuraEffect(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400, 0, 0))
+                    DoneTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
+                break;
+            }
+        }
+    }
+
+    // Custom scripted damage
+    if (spellProto)
+        switch(spellProto->SpellFamilyName)
+        {
+            case SPELLFAMILY_DEATHKNIGHT:
+                // Glacier Rot
+                if (spellProto->SpellFamilyFlags[0] & 0x2 || spellProto->SpellFamilyFlags[1] & 0x6)
+                    if (AuraEffect * aurEff = GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 196, 0))
+                        if (pVictim->GetDiseasesByCaster(owner->GetGUID()) > 0)
+                            DoneTotalMod *= (100.0f + aurEff->GetAmount()) / 100.0f;
+            break;
+        }
+
+    // ..taken
+    AuraEffectList const& mModDamagePercentTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN);
+    for (AuraEffectList::const_iterator i = mModDamagePercentTaken.begin(); i != mModDamagePercentTaken.end(); ++i)
+        if ((*i)->GetMiscValue() & GetMeleeDamageSchoolMask())
+            TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+
+    // From caster spells
+    AuraEffectList const& mOwnerTaken = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_FROM_CASTER);
+    for (AuraEffectList::const_iterator i = mOwnerTaken.begin(); i != mOwnerTaken.end(); ++i)
+        if ((*i)->GetCasterGUID() == GetGUID() && (*i)->IsAffectedOnSpell(spellProto))
+            TakenTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
+
+    // .. taken pct (special attacks)
+    if (spellProto)
+    {
+        // Mod damage from spell mechanic
+        uint32 mechanicMask = GetAllSpellMechanicMask(spellProto);
+
+        // Shred, Maul - "Effects which increase Bleed damage also increase Shred damage"
+        if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[0] & 0x00008800)
+            mechanicMask |= (1<<MECHANIC_BLEED);
+
+        if (mechanicMask)
+        {
+            AuraEffectList const& mDamageDoneMechanic = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT);
+            for (AuraEffectList::const_iterator i = mDamageDoneMechanic.begin(); i != mDamageDoneMechanic.end(); ++i)
+                if (mechanicMask & uint32(1<<((*i)->GetMiscValue())))
+                    TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+        }
+    }
+
+    // .. taken pct: dummy auras
+    AuraEffectList const& mDummyAuras = pVictim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+    for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
+    {
+        switch((*i)->GetSpellProto()->SpellIconID)
+        {
+            //Cheat Death
+            case 2109:
+                if ((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)
+                {
+                    if (pVictim->GetTypeId() != TYPEID_PLAYER)
+                        continue;
+                    float mod = pVictim->ToPlayer()->GetRatingBonusValue(CR_CRIT_TAKEN_MELEE)*(-8.0f);
+                    if (mod < (*i)->GetAmount())
+                        mod = (float)(*i)->GetAmount();
+                    TakenTotalMod *= (mod+100.0f)/100.0f;
+                }
+                break;
+            // Blessing of Sanctuary
+            // Greater Blessing of Sanctuary
+            case 19:
+            case 1804:
+            {
+                if ((*i)->GetSpellProto()->SpellFamilyName != SPELLFAMILY_PALADIN)
+                    continue;
+
+                if ((*i)->GetMiscValue() & (spellProto ? GetSpellSchoolMask(spellProto) : 0))
+                    TakenTotalMod *= ((*i)->GetAmount() + 100.0f) / 100.0f;
+                break;
+            }
+            // Ebon Plague
+            case 1933:
+                if ((*i)->GetMiscValue() & (spellProto ? GetSpellSchoolMask(spellProto) : 0))
+                    TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                break;
+        }
+    }
+
+    // .. taken pct: class scripts
+    AuraEffectList const& mclassScritAuras = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
+    for (AuraEffectList::const_iterator i = mclassScritAuras.begin(); i != mclassScritAuras.end(); ++i)
+    {
+        switch((*i)->GetMiscValue())
+        {
+            case 6427: case 6428:                           // Dirty Deeds
+                if (pVictim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, spellProto, this))
+                {
+                    AuraEffect* eff0 = (*i)->GetBase()->GetEffect(0);
+                    if (!eff0 || (*i)->GetEffIndex() != 1)
+                    {
+                        sLog.outError("Spell structure of DD (%u) changed.",(*i)->GetId());
+                        continue;
+                    }
+
+                    // effect 0 have expected value but in negative state
+                    TakenTotalMod *= (-eff0->GetAmount()+100.0f)/100.0f;
+                }
+                break;
+        }
+    }
+
+    if (attType != RANGED_ATTACK)
+    {
+        AuraEffectList const& mModMeleeDamageTakenPercent = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_MELEE_DAMAGE_TAKEN_PCT);
+        for (AuraEffectList::const_iterator i = mModMeleeDamageTakenPercent.begin(); i != mModMeleeDamageTakenPercent.end(); ++i)
+            TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+    }
+    else
+    {
+        AuraEffectList const& mModRangedDamageTakenPercent = pVictim->GetAuraEffectsByType(SPELL_AURA_MOD_RANGED_DAMAGE_TAKEN_PCT);
+        for (AuraEffectList::const_iterator i = mModRangedDamageTakenPercent.begin(); i != mModRangedDamageTakenPercent.end(); ++i)
+            TakenTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+    }
+
+    float tmpDamage = float(int32(*pdamage) + DoneFlatBenefit) * DoneTotalMod;
+
+    // apply spellmod to Done damage
+    if (spellProto)
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_DAMAGE, tmpDamage);
+
+    tmpDamage = (tmpDamage + TakenFlatBenefit)*TakenTotalMod;
+
+    // bonus result can be negative
+    *pdamage = uint32(std::max(tmpDamage, 0.0f));
+}
+
+void Unit::ApplySpellImmune(uint32 spellId, uint32 op, uint32 type, bool apply)
+{
+    if (apply)
+    {
+        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(), next; itr != m_spellImmune[op].end(); itr = next)
+        {
+            next = itr; ++next;
+            if (itr->type == type)
+            {
+                m_spellImmune[op].erase(itr);
+                next = m_spellImmune[op].begin();
+            }
+        }
+        SpellImmune Immune;
+        Immune.spellId = spellId;
+        Immune.type = type;
+        m_spellImmune[op].push_back(Immune);
+    }
+    else
+    {
+        for (SpellImmuneList::iterator itr = m_spellImmune[op].begin(); itr != m_spellImmune[op].end(); ++itr)
+        {
+            if (itr->spellId == spellId)
+            {
+                m_spellImmune[op].erase(itr);
+                break;
+            }
+        }
+    }
+
+}
+
+void Unit::ApplySpellDispelImmunity(const SpellEntry * spellProto, DispelType type, bool apply)
+{
+    ApplySpellImmune(spellProto->Id,IMMUNITY_DISPEL, type, apply);
+
+    if (apply && spellProto->AttributesEx & SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY)
+    {
+        // Create dispel mask by dispel type
+        uint32 dispelMask = GetDispellMask(type);
+        // Dispel all existing auras vs current dispel type
+        AuraApplicationMap& auras = GetAppliedAuras();
+        for (AuraApplicationMap::iterator itr = auras.begin(); itr != auras.end();)
+        {
+            SpellEntry const* spell = itr->second->GetBase()->GetSpellProto();
+            if ((1<<spell->Dispel) & dispelMask)
+            {
+                // Dispel aura
+                RemoveAura(itr);
+            }
+            else
+                ++itr;
+        }
+    }
+}
+
+float Unit::GetWeaponProcChance() const
+{
+    // normalized proc chance for weapon attack speed
+    // (odd formula...)
+    if (isAttackReady(BASE_ATTACK))
+        return (GetAttackTime(BASE_ATTACK) * 1.8f / 1000.0f);
+    else if (haveOffhandWeapon() && isAttackReady(OFF_ATTACK))
+        return (GetAttackTime(OFF_ATTACK) * 1.6f / 1000.0f);
+    return 0;
+}
+
+float Unit::GetPPMProcChance(uint32 WeaponSpeed, float PPM, const SpellEntry * spellProto) const
+{
+    // proc per minute chance calculation
+    if (PPM <= 0) return 0.0f;
+    // Apply chance modifer aura
+    if (spellProto)
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_PROC_PER_MINUTE,PPM);
+
+    return floor((WeaponSpeed * PPM) / 600.0f);   // result is chance in percents (probability = Speed_in_sec * (PPM / 60))
+}
+
+void Unit::Mount(uint32 mount, uint32 VehicleId, uint32 creatureEntry)
+{
+    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOUNT);
+
+    if (mount)
+        SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, mount);
+
+    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);
+
+    // unsummon pet
+    if (Player* plr = ToPlayer())
+    {
+        Pet* pet = plr->GetPet();
+        if (pet)
+        {
+            Battleground *bg = ToPlayer()->GetBattleground();
+            // don't unsummon pet in arena but SetFlag UNIT_FLAG_STUNNED to disable pet's interface
+            if (bg && bg->isArena())
+                pet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+            else
+                plr->UnsummonPetTemporaryIfAny();
+        }
+
+        if (VehicleId)
+        {
+            if (CreateVehicleKit(VehicleId))
+            {
+                GetVehicleKit()->Reset();
+
+                // mounts can also have accessories
+                GetVehicleKit()->InstallAllAccessories(creatureEntry);
+
+                // Send others that we now have a vehicle
+                WorldPacket data(SMSG_PLAYER_VEHICLE_DATA, GetPackGUID().size()+4);
+                data.appendPackGUID(GetGUID());
+                data << uint32(VehicleId);
+                SendMessageToSet(&data,true);
+
+                data.Initialize(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
+                plr->GetSession()->SendPacket(&data);
+            }
+        }
+    }
+
+}
+
+void Unit::Unmount()
+{
+    if (!IsMounted())
+        return;
+
+    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);
+
+    SetUInt32Value(UNIT_FIELD_MOUNTDISPLAYID, 0);
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_MOUNT);
+
+    // only resummon old pet if the player is already added to a map
+    // this prevents adding a pet to a not created map which would otherwise cause a crash
+    // (it could probably happen when logging in after a previous crash)
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (Pet *pPet = this->ToPlayer()->GetPet())
+        {
+            if (pPet && pPet->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) && !pPet->hasUnitState(UNIT_STAT_STUNNED))
+                pPet->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+        }
+        else
+            this->ToPlayer()->ResummonPetTemporaryUnSummonedIfAny();
+    }
+    if (GetTypeId() == TYPEID_PLAYER && GetVehicleKit())
+    {
+        // Send other players that we are no longer a vehicle
+        WorldPacket data(SMSG_PLAYER_VEHICLE_DATA, 8+4);
+        data.appendPackGUID(GetGUID());
+        data << uint32(0);
+        this->ToPlayer()->SendMessageToSet(&data, true);
+        // Remove vehicle class from player
+        RemoveVehicleKit();
+    }
+}
+
+void Unit::SetInCombatWith(Unit* enemy)
+{
+    Unit* eOwner = enemy->GetCharmerOrOwnerOrSelf();
+    if (eOwner->IsPvP())
+    {
+        SetInCombatState(true,enemy);
+        return;
+    }
+
+    //check for duel
+    if (eOwner->GetTypeId() == TYPEID_PLAYER && eOwner->ToPlayer()->duel)
+    {
+        Unit const* myOwner = GetCharmerOrOwnerOrSelf();
+        if (((Player const*)eOwner)->duel->opponent == myOwner)
+        {
+            SetInCombatState(true,enemy);
+            return;
+        }
+    }
+    SetInCombatState(false,enemy);
+}
+
+void Unit::CombatStart(Unit* target, bool initialAggro)
+{
+    if (initialAggro)
+    {
+        if (!target->IsStandState())
+            target->SetStandState(UNIT_STAND_STATE_STAND);
+
+        if (!target->isInCombat() && target->GetTypeId() != TYPEID_PLAYER
+            && !target->ToCreature()->HasReactState(REACT_PASSIVE) && target->ToCreature()->IsAIEnabled)
+        {
+            target->ToCreature()->AI()->AttackStart(this);
+        }
+
+        SetInCombatWith(target);
+        target->SetInCombatWith(this);
+    }
+    Unit *who = target->GetCharmerOrOwnerOrSelf();
+    if (who->GetTypeId() == TYPEID_PLAYER)
+      SetContestedPvP(who->ToPlayer());
+
+    Player *me = GetCharmerOrOwnerPlayerOrPlayerItself();
+    if (me && who->IsPvP()
+        && (who->GetTypeId() != TYPEID_PLAYER
+        || !me->duel || me->duel->opponent != who))
+    {
+        me->UpdatePvP(true);
+        me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT);
+    }
+}
+
+void Unit::SetInCombatState(bool PvP, Unit* enemy)
+{
+    // only alive units can be in combat
+    if (!isAlive())
+        return;
+
+    if (PvP)
+        m_CombatTimer = 5000;
+
+    if (isInCombat() || hasUnitState(UNIT_STAT_EVADE))
+        return;
+
+    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
+
+    if (GetTypeId() != TYPEID_PLAYER)
+    {
+        // Set home position at place of engaging combat for escorted creatures
+        if ((IsAIEnabled && this->ToCreature()->AI()->IsEscorted()) ||
+            GetMotionMaster()->GetCurrentMovementGeneratorType() == WAYPOINT_MOTION_TYPE ||
+            GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
+            this->ToCreature()->SetHomePosition(GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
+
+        if (enemy)
+        {
+            if (IsAIEnabled)
+            {
+                this->ToCreature()->AI()->EnterCombat(enemy);
+                RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);//always remove Out of Combat Non Attackable flag if we enter combat and AI is enabled
+            }
+            if (this->ToCreature()->GetFormation())
+                this->ToCreature()->GetFormation()->MemberAttackStart(this->ToCreature(), enemy);
+        }
+
+        if (isPet())
+        {
+            UpdateSpeed(MOVE_RUN, true);
+            UpdateSpeed(MOVE_SWIM, true);
+            UpdateSpeed(MOVE_FLIGHT, true);
+        }
+    }
+
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+    {
+        (*itr)->SetInCombatState(PvP, enemy);
+        (*itr)->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
+    }
+}
+
+void Unit::ClearInCombat()
+{
+    m_CombatTimer = 0;
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
+
+    // Player's state will be cleared in Player::UpdateContestedPvP
+    if (GetTypeId() != TYPEID_PLAYER)
+    {
+        Creature* creature = this->ToCreature();
+        if (creature->GetCreatureInfo() && creature->GetCreatureInfo()->unit_flags & UNIT_FLAG_OOC_NOT_ATTACKABLE)
+            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);//re-apply Out of Combat Non Attackable flag if we leave combat, can be overriden in scripts in EnterEvadeMode()
+
+        clearUnitState(UNIT_STAT_ATTACK_PLAYER);
+        if (HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_TAPPED))
+            SetUInt32Value(UNIT_DYNAMIC_FLAGS, ((Creature*)this)->GetCreatureInfo()->dynamicflags);
+    }
+    else
+        this->ToPlayer()->UpdatePotionCooldown();
+
+    if (GetTypeId() != TYPEID_PLAYER && ((Creature*)this)->isPet())
+    {
+        if (Unit *owner = GetOwner())
+            for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
+                if (owner->GetSpeedRate(UnitMoveType(i)) > GetSpeedRate(UnitMoveType(i)))
+                    SetSpeed(UnitMoveType(i), owner->GetSpeedRate(UnitMoveType(i)), true);
+    }
+    else if (!isCharmed())
+        return;
+
+    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
+}
+
+//TODO: remove this function
+bool Unit::isTargetableForAttack() const
+{
+    return isAttackableByAOE() && !hasUnitState(UNIT_STAT_DIED);
+}
+
+bool Unit::canAttack(Unit const* target, bool force) const
+{
+    ASSERT(target);
+
+    if (force)
+    {
+        if (IsFriendlyTo(target))
+            return false;
+
+        if (GetTypeId()!=TYPEID_PLAYER)
+        {
+            if (isPet())
+            {
+                if (Unit *owner = GetOwner())
+                    if (!(owner->canAttack(target)))
+                        return false;
+            }
+            else if (!IsHostileTo(target))
+                return false;
+        }
+    }
+    else if (!IsHostileTo(target))
+        return false;
+
+    if (!target->isAttackableByAOE() || target->hasUnitState(UNIT_STAT_DIED))
+        return false;
+
+    // shaman totem quests: spell 8898, shaman can detect elementals but elementals cannot see shaman
+    if (m_invisibilityMask || target->m_invisibilityMask)
+        if (!canDetectInvisibilityOf(target) && !target->canDetectInvisibilityOf(this))
+            return false;
+
+    if (target->GetVisibility() == VISIBILITY_GROUP_STEALTH && !canDetectStealthOf(target, GetDistance(target)))
+        return false;
+
+    if (m_vehicle)
+        if (IsOnVehicle(target) || m_vehicle->GetBase()->IsOnVehicle(target))
+            return false;
+
+    return true;
+}
+
+bool Unit::isAttackableByAOE(bool requireDeadTarget) const
+{
+    if (isAlive() == requireDeadTarget)
+        return false;
+
+    if (HasFlag(UNIT_FIELD_FLAGS,
+        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_OOC_NOT_ATTACKABLE))
+        return false;
+
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->isGameMaster())
+        return false;
+
+    return !hasUnitState(UNIT_STAT_UNATTACKABLE);
+}
+
+int32 Unit::ModifyHealth(int32 dVal)
+{
+    int32 gain = 0;
+
+    if (dVal == 0)
+        return 0;
+
+    int32 curHealth = (int32)GetHealth();
+
+    int32 val = dVal + curHealth;
+    if (val <= 0)
+    {
+        SetHealth(0);
+        return -curHealth;
+    }
+
+    int32 maxHealth = (int32)GetMaxHealth();
+
+    if (val < maxHealth)
+    {
+        SetHealth(val);
+        gain = val - curHealth;
+    }
+    else if (curHealth != maxHealth)
+    {
+        SetHealth(maxHealth);
+        gain = maxHealth - curHealth;
+    }
+
+    return gain;
+}
+
+int32 Unit::GetHealthGain(int32 dVal)
+{
+    int32 gain = 0;
+
+    if (dVal == 0)
+        return 0;
+
+    int32 curHealth = (int32)GetHealth();
+
+    int32 val = dVal + curHealth;
+    if (val <= 0)
+    {
+        return -curHealth;
+    }
+
+    int32 maxHealth = (int32)GetMaxHealth();
+
+    if (val < maxHealth)
+        gain = dVal;
+    else if (curHealth != maxHealth)
+        gain = maxHealth - curHealth;
+
+    return gain;
+}
+
+int32 Unit::ModifyPower(Powers power, int32 dVal)
+{
+    int32 gain = 0;
+
+    if (dVal == 0)
+        return 0;
+
+    int32 curPower = (int32)GetPower(power);
+
+    int32 val = dVal + curPower;
+    if (val <= 0)
+    {
+        SetPower(power,0);
+        return -curPower;
+    }
+
+    int32 maxPower = (int32)GetMaxPower(power);
+
+    if (val < maxPower)
+    {
+        SetPower(power,val);
+        gain = val - curPower;
+    }
+    else if (curPower != maxPower)
+    {
+        SetPower(power,maxPower);
+        gain = maxPower - curPower;
+    }
+
+    return gain;
+}
+
+bool Unit::isVisibleForOrDetect(Unit const* u, bool detect, bool inVisibleList, bool is3dDistance) const
+{
+    if (!u || !IsInMap(u))
+        return false;
+
+    return u->canSeeOrDetect(this, detect, inVisibleList, is3dDistance);
+}
+
+bool Unit::canSeeOrDetect(Unit const* /*u*/, bool /*detect*/, bool /*inVisibleList*/, bool /*is3dDistance*/) const
+{
+    return true;
+}
+
+bool Unit::canDetectInvisibilityOf(Unit const* u) const
+{
+    if (m_invisibilityMask & u->m_invisibilityMask) // same group
+        return true;
+    AuraEffectList const& auras = u->GetAuraEffectsByType(SPELL_AURA_MOD_STALKED); // Hunter mark
+    for (AuraEffectList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+        if ((*iter)->GetCasterGUID() == GetGUID())
+            return true;
+
+    if (uint32 mask = (m_detectInvisibilityMask & u->m_invisibilityMask))
+    {
+        for (uint8 i = 0; i < 10; ++i)
+        {
+            if (((1 << i) & mask) == 0)
+                continue;
+
+            // find invisibility level
+            uint32 invLevel = 0;
+            Unit::AuraEffectList const& iAuras = u->GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY);
+            for (Unit::AuraEffectList::const_iterator itr = iAuras.begin(); itr != iAuras.end(); ++itr)
+                if (uint8((*itr)->GetMiscValue()) == i && int32(invLevel) < (*itr)->GetAmount())
+                    invLevel = (*itr)->GetAmount();
+
+            // find invisibility detect level
+            uint32 detectLevel = 0;
+            if (i == 6 && GetTypeId() == TYPEID_PLAYER)          // special drunk detection case
+            {
+                detectLevel = this->ToPlayer()->GetDrunkValue();
+            }
+            else
+            {
+                Unit::AuraEffectList const& dAuras = GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY_DETECTION);
+                for (Unit::AuraEffectList::const_iterator itr = dAuras.begin(); itr != dAuras.end(); ++itr)
+                    if (uint8((*itr)->GetMiscValue()) == i && int32(detectLevel) < (*itr)->GetAmount())
+                        detectLevel = (*itr)->GetAmount();
+            }
+
+            if (invLevel <= detectLevel)
+                return true;
+        }
+    }
+
+    return false;
+}
+
+bool Unit::canDetectStealthOf(Unit const* target, float distance) const
+{
+    if (hasUnitState(UNIT_STAT_STUNNED))
+        return false;
+    if (distance < 0.24f) //collision
+        return true;
+    if (HasAuraType(SPELL_AURA_DETECT_STEALTH))
+        return true;
+
+    AuraEffectList const &auras = target->GetAuraEffectsByType(SPELL_AURA_MOD_STALKED); // Hunter mark
+    for (AuraEffectList::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+        if ((*iter)->GetCasterGUID() == GetGUID())
+            return true;
+
+    //Visible distance based on stealth value (stealth rank 4 300MOD, 10.5 - 3 = 7.5)
+    float visibleDistance = 10.5f - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH) / 100.0f;
+    //Visible distance is modified by -Level Diff (every level diff = 1.0f in visible distance)
+    visibleDistance += int32(getLevelForTarget(target)) - int32(target->getLevelForTarget(this));
+    //-Stealth Mod(positive like Master of Deception) and Stealth Detection(negative like paranoia)
+    //based on wowwiki every 5 mod we have 1 more level diff in calculation
+    visibleDistance += (float)(GetTotalAuraModifier(SPELL_AURA_MOD_DETECT) - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH_LEVEL)) / 5.0f;
+    visibleDistance = visibleDistance > MAX_PLAYER_STEALTH_DETECT_RANGE ? MAX_PLAYER_STEALTH_DETECT_RANGE : visibleDistance;
+
+if (!HasInArc(M_PI/6, target))          // (M_PI/3 - M_PI/6) -75% detection distance
+      {
+		  if (!HasInArc(M_PI/3, target))      // (M_PI - M_PI/3) -50% detection distance
+               {
+                       if (!HasInArc(M_PI, target))    // (over M_PI) -25% detection distance
+                       {
+                               visibleDistance *= 0.25f;
+                       }
+                       else visibleDistance *= 0.5f;
+               }
+               else visibleDistance *= 0.75f;
+       }
+    return distance < visibleDistance;
+}
+
+void Unit::SetVisibility(UnitVisibility x)
+{
+    m_Visibility = x;
+
+    if (m_Visibility == VISIBILITY_GROUP_STEALTH)
+        DestroyForNearbyPlayers();
+
+    UpdateObjectVisibility();
+}
+
+void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
+{
+    int32 main_speed_mod  = 0;
+    float stack_bonus     = 1.0f;
+    float non_stack_bonus = 1.0f;
+
+    switch(mtype)
+    {
+        // Only apply debuffs
+        case MOVE_FLIGHT_BACK:
+        case MOVE_RUN_BACK:
+        case MOVE_SWIM_BACK:
+            break;
+        case MOVE_WALK:
+            return;
+        case MOVE_RUN:
+        {
+            if (IsMounted()) // Use on mount auras
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS);
+                non_stack_bonus = (100.0f + GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK))/100.0f;
+            }
+            else
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_SPEED_ALWAYS);
+                non_stack_bonus = (100.0f + GetMaxPositiveAuraModifier(SPELL_AURA_MOD_SPEED_NOT_STACK))/100.0f;
+            }
+            break;
+        }
+        case MOVE_SWIM:
+        {
+            main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_SWIM_SPEED);
+            break;
+        }
+        case MOVE_FLIGHT:
+        {
+            if (GetTypeId() == TYPEID_UNIT && IsControlledByPlayer()) // not sure if good for pet
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS);
+
+                // for some spells this mod is applied on vehicle owner
+                int32 owner_speed_mod = 0;
+
+                if (Unit * owner = GetCharmer())
+                    owner_speed_mod = owner->GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
+
+                main_speed_mod = std::max(main_speed_mod, owner_speed_mod);
+            }
+            else if (IsMounted())
+            {
+                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+                stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS);
+            }
+            else             // Use not mount (shapeshift for example) auras (should stack)
+                main_speed_mod  = GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED) + GetTotalAuraModifier(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
+
+            non_stack_bonus = (100.0f + GetMaxPositiveAuraModifier(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK))/100.0f;
+
+            // Update speed for vehicle if available
+            if (GetTypeId() == TYPEID_PLAYER && GetVehicle())
+                GetVehicleBase()->UpdateSpeed(MOVE_FLIGHT, true);
+            break;
+        }
+        default:
+            sLog.outError("Unit::UpdateSpeed: Unsupported move type (%d)", mtype);
+            return;
+    }
+
+    float bonus = non_stack_bonus > stack_bonus ? non_stack_bonus : stack_bonus;
+
+    // now we ready for speed calculation
+    float speed  = main_speed_mod ? bonus*(100.0f + main_speed_mod)/100.0f : bonus;
+
+    switch(mtype)
+    {
+        case MOVE_RUN:
+        case MOVE_SWIM:
+        case MOVE_FLIGHT:
+        {
+            // Set creature speed rate from CreatureInfo
+            if (GetTypeId() == TYPEID_UNIT)
+                speed *= this->ToCreature()->GetCreatureInfo()->speed_walk;
+
+            // Normalize speed by 191 aura SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED if need
+            // TODO: possible affect only on MOVE_RUN
+            if (int32 normalization = GetMaxPositiveAuraModifier(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED))
+            {
+                // Use speed from aura
+                float max_speed = normalization / (IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
+                if (speed > max_speed)
+                    speed = max_speed;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    // for creature case, we check explicit if mob searched for assistance
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        if (this->ToCreature()->HasSearchedAssistance())
+            speed *= 0.66f;                                 // best guessed value, so this will be 33% reduction. Based off initial speed, mob can then "run", "walk fast" or "walk".
+    }
+
+    // Apply strongest slow aura mod to speed
+    int32 slow = GetMaxNegativeAuraModifier(SPELL_AURA_MOD_DECREASE_SPEED);
+    if (slow)
+    {
+        speed *=(100.0f + slow)/100.0f;
+        if (float minSpeedMod = (float)GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MINIMUM_SPEED))
+        {
+            float min_speed = minSpeedMod / 100.0f;
+            if (speed < min_speed)
+                speed = min_speed;
+        }
+    }
+    SetSpeed(mtype, speed, forced);
+}
+
+float Unit::GetSpeed(UnitMoveType mtype) const
+{
+    return m_speed_rate[mtype]*(IsControlledByPlayer() ? playerBaseMoveSpeed[mtype] : baseMoveSpeed[mtype]);
+}
+
+void Unit::SetSpeed(UnitMoveType mtype, float rate, bool forced)
+{
+    if (rate < 0)
+        rate = 0.0f;
+
+    // Update speed only on change
+    if (m_speed_rate[mtype] == rate)
+        return;
+
+    m_speed_rate[mtype] = rate;
+
+    propagateSpeedChange();
+
+    WorldPacket data;
+    if (!forced)
+    {
+        switch(mtype)
+        {
+            case MOVE_WALK:
+                data.Initialize(MSG_MOVE_SET_WALK_SPEED, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_RUN:
+                data.Initialize(MSG_MOVE_SET_RUN_SPEED, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_RUN_BACK:
+                data.Initialize(MSG_MOVE_SET_RUN_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_SWIM:
+                data.Initialize(MSG_MOVE_SET_SWIM_SPEED, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_SWIM_BACK:
+                data.Initialize(MSG_MOVE_SET_SWIM_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_TURN_RATE:
+                data.Initialize(MSG_MOVE_SET_TURN_RATE, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_FLIGHT:
+                data.Initialize(MSG_MOVE_SET_FLIGHT_SPEED, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_FLIGHT_BACK:
+                data.Initialize(MSG_MOVE_SET_FLIGHT_BACK_SPEED, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            case MOVE_PITCH_RATE:
+                data.Initialize(MSG_MOVE_SET_PITCH_RATE, 8+4+2+4+4+4+4+4+4+4);
+                break;
+            default:
+                sLog.outError("Unit::SetSpeed: Unsupported move type (%d), data not sent to client.",mtype);
+                return;
+        }
+
+        data.append(GetPackGUID());
+        data << uint32(0);                                  // movement flags
+        data << uint16(0);                                  // unk flags
+        data << uint32(getMSTime());
+        data << float(GetPositionX());
+        data << float(GetPositionY());
+        data << float(GetPositionZ());
+        data << float(GetOrientation());
+        data << uint32(0);                                  // fall time
+        data << float(GetSpeed(mtype));
+        SendMessageToSet(&data, true);
+    }
+    else
+    {
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // register forced speed changes for WorldSession::HandleForceSpeedChangeAck
+            // and do it only for real sent packets and use run for run/mounted as client expected
+            ++this->ToPlayer()->m_forced_speed_changes[mtype];
+
+            if (!isInCombat())
+                if (Pet* pet = this->ToPlayer()->GetPet())
+                    pet->SetSpeed(mtype, m_speed_rate[mtype], forced);
+        }
+
+        switch(mtype)
+        {
+            case MOVE_WALK:
+                data.Initialize(SMSG_FORCE_WALK_SPEED_CHANGE, 16);
+                break;
+            case MOVE_RUN:
+                data.Initialize(SMSG_FORCE_RUN_SPEED_CHANGE, 17);
+                break;
+            case MOVE_RUN_BACK:
+                data.Initialize(SMSG_FORCE_RUN_BACK_SPEED_CHANGE, 16);
+                break;
+            case MOVE_SWIM:
+                data.Initialize(SMSG_FORCE_SWIM_SPEED_CHANGE, 16);
+                break;
+            case MOVE_SWIM_BACK:
+                data.Initialize(SMSG_FORCE_SWIM_BACK_SPEED_CHANGE, 16);
+                break;
+            case MOVE_TURN_RATE:
+                data.Initialize(SMSG_FORCE_TURN_RATE_CHANGE, 16);
+                break;
+            case MOVE_FLIGHT:
+                data.Initialize(SMSG_FORCE_FLIGHT_SPEED_CHANGE, 16);
+                break;
+            case MOVE_FLIGHT_BACK:
+                data.Initialize(SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE, 16);
+                break;
+            case MOVE_PITCH_RATE:
+                data.Initialize(SMSG_FORCE_PITCH_RATE_CHANGE, 16);
+                break;
+            default:
+                sLog.outError("Unit::SetSpeed: Unsupported move type (%d), data not sent to client.",mtype);
+                return;
+        }
+        data.append(GetPackGUID());
+        data << (uint32)0;                                  // moveEvent, NUM_PMOVE_EVTS = 0x39
+        if (mtype == MOVE_RUN)
+            data << uint8(0);                               // new 2.1.0
+        data << float(GetSpeed(mtype));
+        SendMessageToSet(&data, true);
+    }
+}
+
+void Unit::SetHover(bool on)
+{
+    if (on)
+        CastSpell(this, 11010, true);
+    else
+        RemoveAurasDueToSpell(11010);
+}
+
+void Unit::setDeathState(DeathState s)
+{
+    // death state needs to be updated before RemoveAllAurasOnDeath() calls HandleChannelDeathItem(..) so that
+    // it can be used to check creation of death items (such as soul shards).
+    DeathState oldDeathState = m_deathState;
+    m_deathState = s;
+
+    if (s != ALIVE && s != JUST_ALIVED)
+    {
+        CombatStop();
+        DeleteThreatList();
+        getHostileRefManager().deleteReferences();
+        ClearComboPointHolders();                           // any combo points pointed to unit lost at it death
+
+        if (IsNonMeleeSpellCasted(false))
+            InterruptNonMeleeSpells(false);
+
+        UnsummonAllTotems();
+        RemoveAllControlled();
+        RemoveAllAurasOnDeath();
+        ExitVehicle();
+    }
+
+    if (s == JUST_DIED)
+    {
+        ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, false);
+        ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, false);
+        // remove aurastates allowing special moves
+        ClearAllReactives();
+        ClearDiminishings();
+        GetMotionMaster()->Clear(false);
+        GetMotionMaster()->MoveIdle();
+        if (m_vehicleKit)
+            m_vehicleKit->Die();
+        SendMonsterStop(true);
+        //without this when removing IncreaseMaxHealth aura player may stuck with 1 hp
+        //do not why since in IncreaseMaxHealth currenthealth is checked
+        SetHealth(0);
+        SetPower(getPowerType(),0);
+    }
+    else if (s == JUST_ALIVED)
+        RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE); // clear skinnable for creature and player (at battleground)
+
+    if (oldDeathState != ALIVE && s == ALIVE)
+    {
+        // Reset display id on resurection - needed by corpse explosion to cleanup after display change
+        // TODO: fix this
+        if (!HasAuraType(SPELL_AURA_TRANSFORM))
+            SetDisplayId(GetNativeDisplayId());
+    }
+}
+
+/*########################################
+########                          ########
+########       AGGRO SYSTEM       ########
+########                          ########
+########################################*/
+bool Unit::CanHaveThreatList() const
+{
+    // only creatures can have threat list
+    if (GetTypeId() != TYPEID_UNIT)
+        return false;
+
+    // only alive units can have threat list
+    if (!isAlive())
+        return false;
+
+    // totems can not have threat list
+    if (this->ToCreature()->isTotem())
+        return false;
+
+    // vehicles can not have threat list
+    //if (this->ToCreature()->IsVehicle())
+    //    return false;
+
+    // summons can not have a threat list, unless they are controlled by a creature
+    if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && IS_PLAYER_GUID(((Pet*)this)->GetOwnerGUID()))
+        return false;
+
+    return true;
+}
+
+//======================================================================
+
+float Unit::ApplyTotalThreatModifier(float fThreat, SpellSchoolMask schoolMask)
+{
+    if (!HasAuraType(SPELL_AURA_MOD_THREAT) || fThreat < 0)
+        return fThreat;
+
+    SpellSchools school = GetFirstSchoolInMask(schoolMask);
+
+    return fThreat * m_threatModifier[school];
+}
+
+//======================================================================
+
+void Unit::AddThreat(Unit* pVictim, float fThreat, SpellSchoolMask schoolMask, SpellEntry const *threatSpell)
+{
+    // Only mobs can manage threat lists
+    if (CanHaveThreatList())
+        m_ThreatManager.addThreat(pVictim, fThreat, schoolMask, threatSpell);
+}
+
+//======================================================================
+
+void Unit::DeleteThreatList()
+{
+    if (CanHaveThreatList() && !m_ThreatManager.isThreatListEmpty())
+        SendClearThreatListOpcode();
+    m_ThreatManager.clearReferences();
+}
+
+//======================================================================
+
+void Unit::TauntApply(Unit* taunter)
+{
+    ASSERT(GetTypeId() == TYPEID_UNIT);
+
+    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))
+        return;
+
+    if (!CanHaveThreatList())
+        return;
+
+    if (this->ToCreature()->HasReactState(REACT_PASSIVE))
+        return;
+
+    Unit *target = getVictim();
+    if (target && target == taunter)
+        return;
+
+    SetInFront(taunter);
+    if (this->ToCreature()->IsAIEnabled)
+        this->ToCreature()->AI()->AttackStart(taunter);
+
+    //m_ThreatManager.tauntApply(taunter);
+}
+
+//======================================================================
+
+void Unit::TauntFadeOut(Unit *taunter)
+{
+    ASSERT(GetTypeId() == TYPEID_UNIT);
+
+    if (!taunter || (taunter->GetTypeId() == TYPEID_PLAYER && taunter->ToPlayer()->isGameMaster()))
+        return;
+
+    if (!CanHaveThreatList())
+        return;
+
+    if (this->ToCreature()->HasReactState(REACT_PASSIVE))
+        return;
+
+    Unit *target = getVictim();
+    if (!target || target != taunter)
+        return;
+
+    if (m_ThreatManager.isThreatListEmpty())
+    {
+        if (this->ToCreature()->IsAIEnabled)
+            this->ToCreature()->AI()->EnterEvadeMode();
+        return;
+    }
+
+    //m_ThreatManager.tauntFadeOut(taunter);
+    target = m_ThreatManager.getHostilTarget();
+
+    if (target && target != taunter)
+    {
+        SetInFront(target);
+        if (this->ToCreature()->IsAIEnabled)
+            this->ToCreature()->AI()->AttackStart(target);
+    }
+}
+
+//======================================================================
+
+Unit* Creature::SelectVictim()
+{
+    //function provides main threat functionality
+    //next-victim-selection algorithm and evade mode are called
+    //threat list sorting etc.
+
+    Unit* target = NULL;
+    // First checking if we have some taunt on us
+    const AuraEffectList& tauntAuras = GetAuraEffectsByType(SPELL_AURA_MOD_TAUNT);
+    if (!tauntAuras.empty())
+    {
+        Unit* caster = tauntAuras.back()->GetCaster();
+
+        // The last taunt aura caster is alive an we are happy to attack him
+        if (caster && caster->isAlive())
+            return getVictim();
+        else if (tauntAuras.size() > 1)
+        {
+            // We do not have last taunt aura caster but we have more taunt auras,
+            // so find first available target
+
+            // Auras are pushed_back, last caster will be on the end
+            AuraEffectList::const_iterator aura = --tauntAuras.end();
+            do
+            {
+                --aura;
+                caster = (*aura)->GetCaster();
+                if (caster && caster->IsInMap(this) && canAttack(caster) && caster->isInAccessiblePlaceFor(this->ToCreature()))
+                {
+                    target = caster;
+                    break;
+                }
+            } while (aura != tauntAuras.begin());
+        }
+        else
+            target = getVictim();
+    }
+
+    if (CanHaveThreatList())
+    {
+        if (!target && !m_ThreatManager.isThreatListEmpty())
+            // No taunt aura or taunt aura caster is dead standard target selection
+            target = m_ThreatManager.getHostilTarget();
+    }
+    else if (!HasReactState(REACT_PASSIVE))
+    {
+        // We have player pet probably
+        target = getAttackerForHelper();
+        if (!target && isSummon())
+        {
+            if (Unit * owner = this->ToTempSummon()->GetOwner())
+            {
+                if (owner->isInCombat())
+                    target = owner->getAttackerForHelper();
+                if (!target)
+                {
+                    for (ControlList::const_iterator itr = owner->m_Controlled.begin(); itr != owner->m_Controlled.end(); ++itr)
+                    {
+                        if ((*itr)->isInCombat())
+                        {
+                            target = (*itr)->getAttackerForHelper();
+                            if (target) break;
+                        }
+                    }
+                }
+            }
+        }
+    }
+    else
+        return NULL;
+
+    if (target && _IsTargetAcceptable(target))
+    {
+        SetInFront(target);
+        return target;
+    }
+
+    // last case when creature don't must go to evade mode:
+    // it in combat but attacker not make any damage and not enter to aggro radius to have record in threat list
+    // for example at owner command to pet attack some far away creature
+    // Note: creature not have targeted movement generator but have attacker in this case
+    for (AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
+    {
+        if ((*itr) && !canCreatureAttack(*itr) && (*itr)->GetTypeId() != TYPEID_PLAYER
+        && !(*itr)->ToCreature()->HasUnitTypeMask(UNIT_MASK_CONTROLABLE_GUARDIAN))
+            return NULL;
+    }
+
+    // TODO: a vehicle may eat some mob, so mob should not evade
+    if (GetVehicle())
+        return NULL;
+
+    // search nearby enemy before enter evade mode
+    if (HasReactState(REACT_AGGRESSIVE))
+    {
+        target = SelectNearestTargetInAttackDistance();
+        if (target && _IsTargetAcceptable(target))
+                return target;
+    }
+
+    if (m_invisibilityMask)
+    {
+        Unit::AuraEffectList const& iAuras = GetAuraEffectsByType(SPELL_AURA_MOD_INVISIBILITY);
+        for (Unit::AuraEffectList::const_iterator itr = iAuras.begin(); itr != iAuras.end(); ++itr)
+            if ((*itr)->GetBase()->IsPermanent())
+            {
+                AI()->EnterEvadeMode();
+                break;
+            }
+        return NULL;
+    }
+
+    // enter in evade mode in other case
+    AI()->EnterEvadeMode();
+
+    return NULL;
+}
+
+//======================================================================
+//======================================================================
+//======================================================================
+
+int32 Unit::ApplyEffectModifiers(SpellEntry const* spellProto, uint8 effect_index, int32 value) const
+{
+    if (Player* modOwner = GetSpellModOwner())
+    {
+        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_ALL_EFFECTS, value);
+        switch (effect_index)
+        {
+            case 0:
+                modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_EFFECT1, value);
+                break;
+            case 1:
+                modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_EFFECT2, value);
+                break;
+            case 2:
+                modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_EFFECT3, value);
+                break;
+        }
+    }
+    return value;
+}
+
+// function uses real base points (typically value - 1)
+int32 Unit::CalculateSpellDamage(Unit const* target, SpellEntry const* spellProto, uint8 effect_index, int32 const* basePoints) const
+{
+    return SpellMgr::CalculateSpellEffectAmount(spellProto, effect_index, this, basePoints, target);
+}
+
+int32 Unit::CalcSpellDuration(SpellEntry const* spellProto)
+{
+    uint8 comboPoints = m_movedPlayer ? m_movedPlayer->GetComboPoints() : 0;
+
+    int32 minduration = GetSpellDuration(spellProto);
+    int32 maxduration = GetSpellMaxDuration(spellProto);
+
+    int32 duration;
+
+    if (comboPoints && minduration != -1 && minduration != maxduration)
+        duration = minduration + int32((maxduration - minduration) * comboPoints / 5);
+    else
+        duration = minduration;
+
+    return duration;
+}
+
+int32 Unit::ModSpellDuration(SpellEntry const* spellProto, Unit const* target, int32 duration, bool positive)
+{
+    //don't mod permament auras duration
+    if (duration < 0)
+        return duration;
+
+    //cut duration only of negative effects
+    if (!positive)
+    {
+        int32 mechanic = GetAllSpellMechanicMask(spellProto);
+
+        int32 durationMod;
+        int32 durationMod_always = 0;
+        int32 durationMod_not_stack = 0;
+
+        for (uint8 i = 1; i <= MECHANIC_ENRAGED; ++i)
+        {
+            if (!(mechanic & 1<<i))
+                continue;
+            // Find total mod value (negative bonus)
+            int32 new_durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD, i);
+            // Find max mod (negative bonus)
+            int32 new_durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MECHANIC_DURATION_MOD_NOT_STACK, i);
+            // Check if mods applied before were weaker
+            if (new_durationMod_always < durationMod_always)
+                durationMod_always = new_durationMod_always;
+            if (new_durationMod_not_stack < durationMod_not_stack)
+                durationMod_not_stack = new_durationMod_not_stack;
+        }
+
+        // Select strongest negative mod
+        if (durationMod_always > durationMod_not_stack)
+            durationMod = durationMod_not_stack;
+        else
+            durationMod = durationMod_always;
+
+        if (durationMod != 0)
+            duration = int32(float(duration) * float(100.0f+durationMod) / 100.0f);
+
+        // there are only negative mods currently
+        durationMod_always = target->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL, spellProto->Dispel);
+        durationMod_not_stack = target->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK, spellProto->Dispel);
+
+        durationMod = 0;
+        if (durationMod_always > durationMod_not_stack)
+            durationMod += durationMod_not_stack;
+        else
+            durationMod += durationMod_always;
+
+        if (durationMod != 0)
+            duration = int32(float(duration) * float(100.0f+durationMod) / 100.0f);
+    }
+    else
+    {
+        //else positive mods here, there are no currently
+        //when there will be, change GetTotalAuraModifierByMiscValue to GetTotalPositiveAuraModifierByMiscValue
+
+        // Mixology - duration boost
+        if (target->GetTypeId() == TYPEID_PLAYER)
+        {
+            if (spellProto->SpellFamilyName == SPELLFAMILY_POTION && (
+                sSpellMgr.IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_BATTLE) ||
+                sSpellMgr.IsSpellMemberOfSpellGroup(spellProto->Id, SPELL_GROUP_ELIXIR_GUARDIAN)))
+            {
+                if (target->HasAura(53042) && target->HasSpell(spellProto->EffectTriggerSpell[0]))
+                    duration *= 2;
+            }
+        }
+    }
+
+    // Glyphs which increase duration of selfcasted buffs
+    if (target == this)
+    {
+        switch (spellProto->SpellFamilyName)
+        {
+            case SPELLFAMILY_DRUID:
+                if (spellProto->SpellFamilyFlags[0] & 0x100)
+                {
+                    // Glyph of Thorns
+                    if (AuraEffect * aurEff = GetAuraEffect(57862, 0))
+                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
+                }
+                break;
+            case SPELLFAMILY_PALADIN:
+                if (spellProto->SpellFamilyFlags[0] & 0x00000002)
+                {
+                    // Glyph of Blessing of Might
+                    if (AuraEffect * aurEff = GetAuraEffect(57958, 0))
+                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
+                }
+                else if (spellProto->SpellFamilyFlags[0] & 0x00010000)
+                {
+                    // Glyph of Blessing of Wisdom
+                    if (AuraEffect * aurEff = GetAuraEffect(57979, 0))
+                        duration += aurEff->GetAmount() * MINUTE * IN_MILLISECONDS;
+                }
+                break;
+        }
+    }
+    return duration > 0 ? duration : 0;
+}
+
+void Unit::ModSpellCastTime(SpellEntry const* spellProto, int32 & castTime, Spell * spell)
+{
+    if (!spellProto || castTime < 0)
+        return;
+    //called from caster
+    if (Player* modOwner = GetSpellModOwner())
+        modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CASTING_TIME, castTime, spell);
+
+    if (!(spellProto->Attributes & (SPELL_ATTR_UNK4|SPELL_ATTR_TRADESPELL)) && spellProto->SpellFamilyName)
+        castTime = int32(float(castTime) * GetFloatValue(UNIT_MOD_CAST_SPEED));
+    else if (spellProto->Attributes & SPELL_ATTR_REQ_AMMO && !(spellProto->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG))
+        castTime = int32(float(castTime) * m_modAttackSpeedPct[RANGED_ATTACK]);
+    else if (spellProto->SpellVisual[0] == 3881 && HasAura(67556)) // cooking with Chef Hat.
+        castTime = 500;
+}
+
+DiminishingLevels Unit::GetDiminishing(DiminishingGroup group)
+{
+    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
+    {
+        if (i->DRGroup != group)
+            continue;
+
+        if (!i->hitCount)
+            return DIMINISHING_LEVEL_1;
+
+        if (!i->hitTime)
+            return DIMINISHING_LEVEL_1;
+
+        // If last spell was casted more than 15 seconds ago - reset the count.
+        if (i->stack == 0 && getMSTimeDiff(i->hitTime,getMSTime()) > 15000)
+        {
+            i->hitCount = DIMINISHING_LEVEL_1;
+            return DIMINISHING_LEVEL_1;
+        }
+        // or else increase the count.
+        else
+            return DiminishingLevels(i->hitCount);
+    }
+    return DIMINISHING_LEVEL_1;
+}
+
+void Unit::IncrDiminishing(DiminishingGroup group)
+{
+    // Checking for existing in the table
+    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
+    {
+        if (i->DRGroup != group)
+            continue;
+        if (int32(i->hitCount) < GetDiminishingReturnsMaxLevel(group))
+            i->hitCount += 1;
+        return;
+    }
+    m_Diminishing.push_back(DiminishingReturn(group,getMSTime(),DIMINISHING_LEVEL_2));
+}
+
+float Unit::ApplyDiminishingToDuration(DiminishingGroup group, int32 &duration,Unit* caster,DiminishingLevels Level, int32 limitduration)
+{
+    if (duration == -1 || group == DIMINISHING_NONE || caster->IsFriendlyTo(this))
+        return 1.0f;
+
+    // test pet/charm masters instead pets/charmeds
+    Unit const* targetOwner = GetCharmerOrOwner();
+    Unit const* casterOwner = caster->GetCharmerOrOwner();
+
+    // Duration of crowd control abilities on pvp target is limited by 10 sec. (2.2.0)
+    if (limitduration > 0 && duration > limitduration)
+    {
+        Unit const* target = targetOwner ? targetOwner : this;
+        Unit const* source = casterOwner ? casterOwner : caster;
+
+        if ((target->GetTypeId() == TYPEID_PLAYER
+            || ((Creature*)target)->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)
+            && source->GetTypeId() == TYPEID_PLAYER)
+            duration = limitduration;
+    }
+
+    float mod = 1.0f;
+
+    if (group == DIMINISHING_TAUNT)
+    {
+        if (GetTypeId() == TYPEID_UNIT && (((Creature*)this)->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_TAUNT_DIMINISH))
+        {
+            DiminishingLevels diminish = Level;
+            switch(diminish)
+            {
+                case DIMINISHING_LEVEL_1: break;
+                case DIMINISHING_LEVEL_2: mod = 0.65f; break;
+                case DIMINISHING_LEVEL_3: mod = 0.4225f; break;
+                case DIMINISHING_LEVEL_4: mod = 0.274625f; break;
+                case DIMINISHING_LEVEL_TAUNT_IMMUNE: mod = 0.0f; break;
+                default: break;
+            }
+        }
+    }
+    // Some diminishings applies to mobs too (for example, Stun)
+    else if ((GetDiminishingReturnsGroupType(group) == DRTYPE_PLAYER
+        && ((targetOwner ? (targetOwner->GetTypeId() == TYPEID_PLAYER) : (GetTypeId() == TYPEID_PLAYER))
+        || (GetTypeId() == TYPEID_UNIT && ((Creature*)this)->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_ALL_DIMINISH)))
+        || GetDiminishingReturnsGroupType(group) == DRTYPE_ALL)
+    {
+        DiminishingLevels diminish = Level;
+        switch(diminish)
+        {
+            case DIMINISHING_LEVEL_1: break;
+            case DIMINISHING_LEVEL_2: mod = 0.5f; break;
+            case DIMINISHING_LEVEL_3: mod = 0.25f; break;
+            case DIMINISHING_LEVEL_IMMUNE: mod = 0.0f; break;
+            default: break;
+        }
+    }
+
+    duration = int32(duration * mod);
+    return mod;
+}
+
+void Unit::ApplyDiminishingAura(DiminishingGroup group, bool apply)
+{
+    // Checking for existing in the table
+    for (Diminishing::iterator i = m_Diminishing.begin(); i != m_Diminishing.end(); ++i)
+    {
+        if (i->DRGroup != group)
+            continue;
+
+        if (apply)
+            i->stack += 1;
+        else if (i->stack)
+        {
+            i->stack -= 1;
+            // Remember time after last aura from group removed
+            if (i->stack == 0)
+                i->hitTime = getMSTime();
+        }
+        break;
+    }
+}
+
+uint32 Unit::GetSpellMaxRangeForTarget(Unit* target,const SpellRangeEntry * rangeEntry)
+{
+    if (!rangeEntry)
+        return 0;
+    if (rangeEntry->maxRangeHostile == rangeEntry->maxRangeFriend)
+        return uint32(rangeEntry->maxRangeFriend);
+    if (IsHostileTo(target))
+        return uint32(rangeEntry->maxRangeHostile);
+    return uint32(rangeEntry->maxRangeFriend);
+};
+uint32 Unit::GetSpellMinRangeForTarget(Unit* target,const SpellRangeEntry * rangeEntry)
+{
+    if (!rangeEntry)
+        return 0;
+    if (rangeEntry->minRangeHostile == rangeEntry->minRangeFriend)
+        return uint32(rangeEntry->minRangeFriend);
+    if (IsHostileTo(target))
+        return uint32(rangeEntry->minRangeHostile);
+    return uint32(rangeEntry->minRangeFriend);
+};
+uint32 Unit::GetSpellRadiusForTarget(Unit* target,const SpellRadiusEntry * radiusEntry)
+{
+    if (!radiusEntry)
+        return 0;
+    if (radiusEntry->radiusHostile == radiusEntry->radiusFriend)
+        return uint32(radiusEntry->radiusFriend);
+    if (IsHostileTo(target))
+        return uint32(radiusEntry->radiusHostile);
+    return uint32(radiusEntry->radiusFriend);
+};
+
+Unit* Unit::GetUnit(WorldObject& object, uint64 guid)
+{
+    return ObjectAccessor::GetUnit(object,guid);
+}
+
+Player* Unit::GetPlayer(WorldObject& object, uint64 guid)
+{
+    return ObjectAccessor::GetPlayer(object,guid);
+}
+
+Creature* Unit::GetCreature(WorldObject& object, uint64 guid)
+{
+    return object.GetMap()->GetCreature(guid);
+}
+
+bool Unit::isVisibleForInState(Player const* u, bool inVisibleList) const
+{
+    return u->canSeeOrDetect(this, false, inVisibleList, false);
+}
+
+uint32 Unit::GetCreatureType() const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        SpellShapeshiftEntry const* ssEntry = sSpellShapeshiftStore.LookupEntry(m_form);
+        if (ssEntry && ssEntry->creatureType > 0)
+            return ssEntry->creatureType;
+        else
+            return CREATURE_TYPE_HUMANOID;
+    }
+    else
+        return this->ToCreature()->GetCreatureInfo()->type;
+}
+
+/*#######################################
+########                         ########
+########       STAT SYSTEM       ########
+########                         ########
+#######################################*/
+
+bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, float amount, bool apply)
+{
+    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
+    {
+        sLog.outError("ERROR in HandleStatModifier(): non existed UnitMods or wrong UnitModifierType!");
+        return false;
+    }
+
+    switch (modifierType)
+    {
+        case BASE_VALUE:
+        case TOTAL_VALUE:
+            m_auraModifiersGroup[unitMod][modifierType] += apply ? amount : -amount;
+            break;
+        case BASE_PCT:
+        case TOTAL_PCT:
+            m_auraModifiersGroup[unitMod][modifierType] += (apply ? amount : -amount) / 100.0f;
+            break;
+        default:
+            break;
+    }
+
+    if (!CanModifyStats())
+        return false;
+
+    switch(unitMod)
+    {
+        case UNIT_MOD_STAT_STRENGTH:
+        case UNIT_MOD_STAT_AGILITY:
+        case UNIT_MOD_STAT_STAMINA:
+        case UNIT_MOD_STAT_INTELLECT:
+        case UNIT_MOD_STAT_SPIRIT:         UpdateStats(GetStatByAuraGroup(unitMod));  break;
+
+        case UNIT_MOD_ARMOR:               UpdateArmor();           break;
+        case UNIT_MOD_HEALTH:              UpdateMaxHealth();       break;
+
+        case UNIT_MOD_MANA:
+        case UNIT_MOD_RAGE:
+        case UNIT_MOD_FOCUS:
+        case UNIT_MOD_ENERGY:
+        case UNIT_MOD_HAPPINESS:
+        case UNIT_MOD_RUNE:
+        case UNIT_MOD_RUNIC_POWER:          UpdateMaxPower(GetPowerTypeByAuraGroup(unitMod));          break;
+
+        case UNIT_MOD_RESISTANCE_HOLY:
+        case UNIT_MOD_RESISTANCE_FIRE:
+        case UNIT_MOD_RESISTANCE_NATURE:
+        case UNIT_MOD_RESISTANCE_FROST:
+        case UNIT_MOD_RESISTANCE_SHADOW:
+        case UNIT_MOD_RESISTANCE_ARCANE:   UpdateResistances(GetSpellSchoolByAuraGroup(unitMod));      break;
+
+        case UNIT_MOD_ATTACK_POWER:        UpdateAttackPowerAndDamage();         break;
+        case UNIT_MOD_ATTACK_POWER_RANGED: UpdateAttackPowerAndDamage(true);     break;
+
+        case UNIT_MOD_DAMAGE_MAINHAND:     UpdateDamagePhysical(BASE_ATTACK);    break;
+        case UNIT_MOD_DAMAGE_OFFHAND:      UpdateDamagePhysical(OFF_ATTACK);     break;
+        case UNIT_MOD_DAMAGE_RANGED:       UpdateDamagePhysical(RANGED_ATTACK);  break;
+
+        default:
+            break;
+    }
+
+    return true;
+}
+
+float Unit::GetModifierValue(UnitMods unitMod, UnitModifierType modifierType) const
+{
+    if (unitMod >= UNIT_MOD_END || modifierType >= MODIFIER_TYPE_END)
+    {
+        sLog.outError("trial to access non existed modifier value from UnitMods!");
+        return 0.0f;
+    }
+
+    if (modifierType == TOTAL_PCT && m_auraModifiersGroup[unitMod][modifierType] <= 0.0f)
+        return 0.0f;
+
+    return m_auraModifiersGroup[unitMod][modifierType];
+}
+
+float Unit::GetTotalStatValue(Stats stat) const
+{
+    UnitMods unitMod = UnitMods(UNIT_MOD_STAT_START + stat);
+
+    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
+        return 0.0f;
+
+    // value = ((base_value * base_pct) + total_value) * total_pct
+    float value  = m_auraModifiersGroup[unitMod][BASE_VALUE] + GetCreateStat(stat);
+    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
+    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
+    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
+
+    return value;
+}
+
+float Unit::GetTotalAuraModValue(UnitMods unitMod) const
+{
+    if (unitMod >= UNIT_MOD_END)
+    {
+        sLog.outError("trial to access non existed UnitMods in GetTotalAuraModValue()!");
+        return 0.0f;
+    }
+
+    if (m_auraModifiersGroup[unitMod][TOTAL_PCT] <= 0.0f)
+        return 0.0f;
+
+    float value = m_auraModifiersGroup[unitMod][BASE_VALUE];
+    value *= m_auraModifiersGroup[unitMod][BASE_PCT];
+    value += m_auraModifiersGroup[unitMod][TOTAL_VALUE];
+    value *= m_auraModifiersGroup[unitMod][TOTAL_PCT];
+
+    return value;
+}
+
+SpellSchools Unit::GetSpellSchoolByAuraGroup(UnitMods unitMod) const
+{
+    SpellSchools school = SPELL_SCHOOL_NORMAL;
+
+    switch(unitMod)
+    {
+        case UNIT_MOD_RESISTANCE_HOLY:     school = SPELL_SCHOOL_HOLY;          break;
+        case UNIT_MOD_RESISTANCE_FIRE:     school = SPELL_SCHOOL_FIRE;          break;
+        case UNIT_MOD_RESISTANCE_NATURE:   school = SPELL_SCHOOL_NATURE;        break;
+        case UNIT_MOD_RESISTANCE_FROST:    school = SPELL_SCHOOL_FROST;         break;
+        case UNIT_MOD_RESISTANCE_SHADOW:   school = SPELL_SCHOOL_SHADOW;        break;
+        case UNIT_MOD_RESISTANCE_ARCANE:   school = SPELL_SCHOOL_ARCANE;        break;
+
+        default:
+            break;
+    }
+
+    return school;
+}
+
+Stats Unit::GetStatByAuraGroup(UnitMods unitMod) const
+{
+    Stats stat = STAT_STRENGTH;
+
+    switch(unitMod)
+    {
+        case UNIT_MOD_STAT_STRENGTH:    stat = STAT_STRENGTH;      break;
+        case UNIT_MOD_STAT_AGILITY:     stat = STAT_AGILITY;       break;
+        case UNIT_MOD_STAT_STAMINA:     stat = STAT_STAMINA;       break;
+        case UNIT_MOD_STAT_INTELLECT:   stat = STAT_INTELLECT;     break;
+        case UNIT_MOD_STAT_SPIRIT:      stat = STAT_SPIRIT;        break;
+
+        default:
+            break;
+    }
+
+    return stat;
+}
+
+Powers Unit::GetPowerTypeByAuraGroup(UnitMods unitMod) const
+{
+    switch (unitMod)
+    {
+        case UNIT_MOD_RAGE:        return POWER_RAGE;
+        case UNIT_MOD_FOCUS:       return POWER_FOCUS;
+        case UNIT_MOD_ENERGY:      return POWER_ENERGY;
+        case UNIT_MOD_HAPPINESS:   return POWER_HAPPINESS;
+        case UNIT_MOD_RUNE:        return POWER_RUNE;
+        case UNIT_MOD_RUNIC_POWER: return POWER_RUNIC_POWER;
+        default:
+        case UNIT_MOD_MANA:        return POWER_MANA;
+    }
+}
+
+float Unit::GetTotalAttackPowerValue(WeaponAttackType attType) const
+{
+    if (attType == RANGED_ATTACK)
+    {
+        int32 ap = GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER) + GetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER_MODS);
+        if (ap < 0)
+            return 0.0f;
+        return ap * (1.0f + GetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER));
+    }
+    else
+    {
+        int32 ap = GetInt32Value(UNIT_FIELD_ATTACK_POWER) + GetInt32Value(UNIT_FIELD_ATTACK_POWER_MODS);
+        if (ap < 0)
+            return 0.0f;
+        return ap * (1.0f + GetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER));
+    }
+}
+
+float Unit::GetWeaponDamageRange(WeaponAttackType attType ,WeaponDamageRange type) const
+{
+    if (attType == OFF_ATTACK && !haveOffhandWeapon())
+        return 0.0f;
+
+    return m_weaponDamage[attType][type];
+}
+
+void Unit::SetLevel(uint8 lvl)
+{
+    SetUInt32Value(UNIT_FIELD_LEVEL, lvl);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->GetGroup())
+        this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_LEVEL);
+}
+
+void Unit::SetHealth(uint32 val)
+{
+    if (getDeathState() == JUST_DIED)
+        val = 0;
+    else if (GetTypeId() == TYPEID_PLAYER && (getDeathState() == DEAD || getDeathState() == DEAD_FALLING))
+        val = 1;
+    else
+    {
+        uint32 maxHealth = GetMaxHealth();
+        if (maxHealth < val)
+            val = maxHealth;
+    }
+
+    SetUInt32Value(UNIT_FIELD_HEALTH, val);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (this->ToPlayer()->GetGroup())
+            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_HP);
+    }
+    else if (this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_HP);
+        }
+    }
+}
+
+void Unit::SetMaxHealth(uint32 val)
+{
+    if (!val)
+        val = 1;
+
+    uint32 health = GetHealth();
+    SetUInt32Value(UNIT_FIELD_MAXHEALTH, val);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (this->ToPlayer()->GetGroup())
+            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_HP);
+    }
+    else if (this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_HP);
+        }
+    }
+
+    if (val < health)
+        SetHealth(val);
+}
+
+void Unit::SetPower(Powers power, uint32 val)
+{
+    if (GetPower(power) == val)
+        return;
+
+    uint32 maxPower = GetMaxPower(power);
+    if (maxPower < val)
+        val = maxPower;
+
+    SetStatInt32Value(UNIT_FIELD_POWER1 + power, val);
+
+    WorldPacket data(SMSG_POWER_UPDATE);
+    data.append(GetPackGUID());
+    data << uint8(power);
+    data << uint32(val);
+    SendMessageToSet(&data, GetTypeId() == TYPEID_PLAYER ? true : false);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (this->ToPlayer()->GetGroup())
+            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
+    }
+    else if (this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
+        }
+
+        // Update the pet's character sheet with happiness damage bonus
+        if (pet->getPetType() == HUNTER_PET && power == POWER_HAPPINESS)
+            pet->UpdateDamagePhysical(BASE_ATTACK);
+    }
+}
+
+void Unit::SetMaxPower(Powers power, uint32 val)
+{
+    uint32 cur_power = GetPower(power);
+    SetStatInt32Value(UNIT_FIELD_MAXPOWER1 + power, val);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (this->ToPlayer()->GetGroup())
+            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
+    }
+    else if (this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
+        }
+    }
+
+    if (val < cur_power)
+        SetPower(power, val);
+}
+
+void Unit::ApplyPowerMod(Powers power, uint32 val, bool apply)
+{
+    ApplyModUInt32Value(UNIT_FIELD_POWER1+power, val, apply);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (this->ToPlayer()->GetGroup())
+            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
+    }
+    else if (this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_CUR_POWER);
+        }
+    }
+}
+
+void Unit::ApplyMaxPowerMod(Powers power, uint32 val, bool apply)
+{
+    ApplyModUInt32Value(UNIT_FIELD_MAXPOWER1+power, val, apply);
+
+    // group update
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        if (this->ToPlayer()->GetGroup())
+            this->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_POWER);
+    }
+    else if (this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MAX_POWER);
+        }
+    }
+}
+
+uint32 Unit::GetCreatePowers(Powers power) const
+{
+    // POWER_FOCUS and POWER_HAPPINESS only have hunter pet
+    switch (power)
+    {
+        case POWER_MANA:      return GetCreateMana();
+        case POWER_RAGE:      return 1000;
+        case POWER_FOCUS:     return (GetTypeId() == TYPEID_PLAYER || !((Creature const*)this)->isPet() || ((Pet const*)this)->getPetType() != HUNTER_PET ? 0 : 100);
+        case POWER_ENERGY:    return 100;
+        case POWER_HAPPINESS: return (GetTypeId() == TYPEID_PLAYER || !((Creature const*)this)->isPet() || ((Pet const*)this)->getPetType() != HUNTER_PET ? 0 : 1050000);
+        case POWER_RUNIC_POWER: return 1000;
+        case POWER_RUNE:      return 0;
+        case POWER_HEALTH:    return 0;
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+void Unit::AddToWorld()
+{
+    if (!IsInWorld())
+    {
+        WorldObject::AddToWorld();
+    }
+}
+
+void Unit::RemoveFromWorld()
+{
+    // cleanup
+    ASSERT(GetGUID());
+
+    if (IsInWorld())
+    {
+        m_duringRemoveFromWorld = true;
+        if (IsVehicle())
+            GetVehicleKit()->Uninstall();
+
+        RemoveCharmAuras();
+        RemoveBindSightAuras();
+        RemoveNotOwnSingleTargetAuras();
+
+        RemoveAllGameObjects();
+        RemoveAllDynObjects();
+
+        ExitVehicle();
+        UnsummonAllTotems();
+        RemoveAllControlled();
+
+        RemoveAreaAurasDueToLeaveWorld();
+
+        if (GetCharmerGUID())
+        {
+            sLog.outCrash("Unit %u has charmer guid when removed from world", GetEntry());
+            ASSERT(false);
+        }
+
+        if (Unit *owner = GetOwner())
+        {
+            if (owner->m_Controlled.find(this) != owner->m_Controlled.end())
+            {
+                sLog.outCrash("Unit %u is in controlled list of %u when removed from world", GetEntry(), owner->GetEntry());
+                ASSERT(false);
+            }
+        }
+
+        WorldObject::RemoveFromWorld();
+        m_duringRemoveFromWorld = false;
+    }
+}
+
+void Unit::CleanupsBeforeDelete(bool finalCleanup)
+{
+    if (IsInWorld())
+        RemoveFromWorld();
+
+    ASSERT(GetGUID());
+
+    //A unit may be in removelist and not in world, but it is still in grid
+    //and may have some references during delete
+    RemoveAllAuras();
+
+    if (finalCleanup)
+        m_cleanupDone = true;
+
+    InterruptNonMeleeSpells(true);
+    m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
+    CombatStop();
+    ClearComboPointHolders();
+    DeleteThreatList();
+    getHostileRefManager().setOnlineOfflineState(false);
+    GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.
+}
+
+void Unit::UpdateCharmAI()
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        return;
+
+    if (i_disabledAI) // disabled AI must be primary AI
+    {
+        if (!isCharmed())
+        {
+            delete i_AI;
+            i_AI = i_disabledAI;
+            i_disabledAI = NULL;
+        }
+    }
+    else
+    {
+        if (isCharmed())
+        {
+            i_disabledAI = i_AI;
+            if (isPossessed() || IsVehicle())
+                i_AI = new PossessedAI(this->ToCreature());
+            else
+                i_AI = new PetAI(this->ToCreature());
+        }
+    }
+}
+
+CharmInfo* Unit::InitCharmInfo()
+{
+    if (!m_charmInfo)
+        m_charmInfo = new CharmInfo(this);
+
+    return m_charmInfo;
+}
+
+void Unit::DeleteCharmInfo()
+{
+    if (!m_charmInfo)
+        return;
+
+    delete m_charmInfo;
+    m_charmInfo = NULL;
+}
+
+CharmInfo::CharmInfo(Unit* unit)
+: m_unit(unit), m_CommandState(COMMAND_FOLLOW), m_petnumber(0), m_barInit(false),
+  m_isCommandAttack(false), m_isAtStay(false), m_isFollowing(false), m_isReturning(false)
+{
+    for (uint8 i = 0; i < MAX_SPELL_CHARM; ++i)
+        m_charmspells[i].SetActionAndType(0,ACT_DISABLED);
+
+    if (m_unit->GetTypeId() == TYPEID_UNIT)
+    {
+        m_oldReactState = m_unit->ToCreature()->GetReactState();
+        m_unit->ToCreature()->SetReactState(REACT_PASSIVE);
+    }
+
+}
+
+CharmInfo::~CharmInfo()
+{
+    if (m_unit->GetTypeId() == TYPEID_UNIT)
+        if (Creature *pCreature = m_unit->ToCreature())
+            pCreature->SetReactState(m_oldReactState);
+}
+
+void CharmInfo::InitPetActionBar()
+{
+    // the first 3 SpellOrActions are attack, follow and stay
+    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_START - ACTION_BAR_INDEX_START; ++i)
+        SetActionBar(ACTION_BAR_INDEX_START + i,COMMAND_ATTACK - i,ACT_COMMAND);
+
+    // middle 4 SpellOrActions are spells/special attacks/abilities
+    for (uint32 i = 0; i < ACTION_BAR_INDEX_PET_SPELL_END-ACTION_BAR_INDEX_PET_SPELL_START; ++i)
+        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_START + i,0,ACT_PASSIVE);
+
+    // last 3 SpellOrActions are reactions
+    for (uint32 i = 0; i < ACTION_BAR_INDEX_END - ACTION_BAR_INDEX_PET_SPELL_END; ++i)
+        SetActionBar(ACTION_BAR_INDEX_PET_SPELL_END + i,COMMAND_ATTACK - i,ACT_REACTION);
+}
+
+void CharmInfo::InitEmptyActionBar(bool withAttack)
+{
+    if (withAttack)
+        SetActionBar(ACTION_BAR_INDEX_START,COMMAND_ATTACK,ACT_COMMAND);
+    else
+        SetActionBar(ACTION_BAR_INDEX_START,0,ACT_PASSIVE);
+    for (uint32 x = ACTION_BAR_INDEX_START+1; x < ACTION_BAR_INDEX_END; ++x)
+        SetActionBar(x,0,ACT_PASSIVE);
+}
+
+void CharmInfo::InitPossessCreateSpells()
+{
+    InitEmptyActionBar();
+    if (m_unit->GetTypeId() == TYPEID_UNIT)
+    {
+        for (uint32 i = 0; i < CREATURE_MAX_SPELLS; ++i)
+        {
+            uint32 spellId = m_unit->ToCreature()->m_spells[i];
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+            if (spellInfo && spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD)
+                spellId = 0;
+            if (IsPassiveSpell(spellId))
+                m_unit->CastSpell(m_unit, spellId, true);
+            else
+                AddSpellToActionBar(m_unit->ToCreature()->m_spells[i], ACT_PASSIVE);
+        }
+    }
+}
+
+void CharmInfo::InitCharmCreateSpells()
+{
+    if (m_unit->GetTypeId() == TYPEID_PLAYER)                //charmed players don't have spells
+    {
+        InitEmptyActionBar();
+        return;
+    }
+
+    InitPetActionBar();
+
+    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
+    {
+        uint32 spellId = m_unit->ToCreature()->m_spells[x];
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+        if (spellInfo && spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD)
+            spellId = 0;
+
+        if (!spellId)
+        {
+            m_charmspells[x].SetActionAndType(spellId,ACT_DISABLED);
+            continue;
+        }
+
+        if (IsPassiveSpell(spellId))
+        {
+            m_unit->CastSpell(m_unit, spellId, true);
+            m_charmspells[x].SetActionAndType(spellId,ACT_PASSIVE);
+        }
+        else
+        {
+            m_charmspells[x].SetActionAndType(spellId,ACT_DISABLED);
+
+            ActiveStates newstate = ACT_PASSIVE;
+            if (spellInfo)
+            {
+                if (!IsAutocastableSpell(spellId))
+                    newstate = ACT_PASSIVE;
+                else
+                {
+                    bool autocast = false;
+                    for (uint32 i = 0; i < MAX_SPELL_EFFECTS && !autocast; ++i)
+                        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET)
+                            autocast = true;
+
+                    if (autocast)
+                    {
+                        newstate = ACT_ENABLED;
+                        ToggleCreatureAutocast(spellId, true);
+                    }
+                    else
+                        newstate = ACT_DISABLED;
+                }
+            }
+
+            AddSpellToActionBar(spellId, newstate);
+        }
+    }
+}
+
+bool CharmInfo::AddSpellToActionBar(uint32 spell_id, ActiveStates newstate)
+{
+    uint32 first_id = sSpellMgr.GetFirstSpellInChain(spell_id);
+
+    // new spell rank can be already listed
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (uint32 action = PetActionBar[i].GetAction())
+        {
+            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr.GetFirstSpellInChain(action) == first_id)
+            {
+                PetActionBar[i].SetAction(spell_id);
+                return true;
+            }
+        }
+    }
+
+    // or use empty slot in other case
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (!PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
+        {
+            SetActionBar(i,spell_id,newstate == ACT_DECIDE ? IsAutocastableSpell(spell_id) ? ACT_DISABLED : ACT_PASSIVE : newstate);
+            return true;
+        }
+    }
+    return false;
+}
+
+bool CharmInfo::RemoveSpellFromActionBar(uint32 spell_id)
+{
+    uint32 first_id = sSpellMgr.GetFirstSpellInChain(spell_id);
+
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (uint32 action = PetActionBar[i].GetAction())
+        {
+            if (PetActionBar[i].IsActionBarForSpell() && sSpellMgr.GetFirstSpellInChain(action) == first_id)
+            {
+                SetActionBar(i,0,ACT_PASSIVE);
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+void CharmInfo::ToggleCreatureAutocast(uint32 spellid, bool apply)
+{
+    if (IsPassiveSpell(spellid))
+        return;
+
+    for (uint32 x = 0; x < MAX_SPELL_CHARM; ++x)
+        if (spellid == m_charmspells[x].GetAction())
+            m_charmspells[x].SetType(apply ? ACT_ENABLED : ACT_DISABLED);
+}
+
+void CharmInfo::SetPetNumber(uint32 petnumber, bool statwindow)
+{
+    m_petnumber = petnumber;
+    if (statwindow)
+        m_unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, m_petnumber);
+    else
+        m_unit->SetUInt32Value(UNIT_FIELD_PETNUMBER, 0);
+}
+
+void CharmInfo::LoadPetActionBar(const std::string& data)
+{
+    InitPetActionBar();
+
+    Tokens tokens = StrSplit(data, " ");
+
+    if (tokens.size() != (ACTION_BAR_INDEX_END-ACTION_BAR_INDEX_START)*2)
+        return;                                             // non critical, will reset to default
+
+    uint8 index;
+    Tokens::iterator iter;
+    for (iter = tokens.begin(), index = ACTION_BAR_INDEX_START; index < ACTION_BAR_INDEX_END; ++iter, ++index)
+    {
+        // use unsigned cast to avoid sign negative format use at long-> ActiveStates (int) conversion
+        ActiveStates type  = ActiveStates(atol(iter->c_str()));
+        ++iter;
+        uint32 action = uint32(atol(iter->c_str()));
+
+        PetActionBar[index].SetActionAndType(action, type);
+
+        // check correctness
+        if (PetActionBar[index].IsActionBarForSpell())
+        {
+            if (!sSpellStore.LookupEntry(PetActionBar[index].GetAction()))
+                SetActionBar(index, 0, ACT_PASSIVE);
+            else if (!IsAutocastableSpell(PetActionBar[index].GetAction()))
+                SetActionBar(index, PetActionBar[index].GetAction(), ACT_PASSIVE);
+        }
+    }
+}
+
+void CharmInfo::BuildActionBar(WorldPacket* data)
+{
+    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+        *data << uint32(PetActionBar[i].packedData);
+}
+
+void CharmInfo::SetSpellAutocast(uint32 spell_id, bool state)
+{
+    for (uint8 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
+    {
+        if (spell_id == PetActionBar[i].GetAction() && PetActionBar[i].IsActionBarForSpell())
+        {
+            PetActionBar[i].SetType(state ? ACT_ENABLED : ACT_DISABLED);
+            break;
+        }
+    }
+}
+
+bool Unit::isFrozen() const
+{
+    return HasAuraState(AURA_STATE_FROZEN);
+}
+
+struct ProcTriggeredData
+{
+    ProcTriggeredData(Aura* _aura)
+        : aura(_aura)
+    {
+        effMask = 0;
+        spellProcEvent = NULL;
+    }
+    SpellProcEventEntry const *spellProcEvent;
+    Aura * aura;
+    uint32 effMask;
+};
+
+typedef std::list< ProcTriggeredData > ProcTriggeredList;
+
+// List of auras that CAN be trigger but may not exist in spell_proc_event
+// in most case need for drop charges
+// in some types of aura need do additional check
+// for example SPELL_AURA_MECHANIC_IMMUNITY - need check for mechanic
+bool InitTriggerAuraData()
+{
+    for (uint16 i = 0; i < TOTAL_AURAS; ++i)
+    {
+        isTriggerAura[i]=false;
+        isNonTriggerAura[i] = false;
+        isAlwaysTriggeredAura[i] = false;
+    }
+    isTriggerAura[SPELL_AURA_DUMMY] = true;
+    isTriggerAura[SPELL_AURA_MOD_CONFUSE] = true;
+    isTriggerAura[SPELL_AURA_MOD_THREAT] = true;
+    isTriggerAura[SPELL_AURA_MOD_STUN] = true; // Aura not have charges but need remove him on trigger
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_DONE] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_TAKEN] = true;
+    isTriggerAura[SPELL_AURA_MOD_RESISTANCE] = true;
+    isTriggerAura[SPELL_AURA_MOD_STEALTH] = true;
+    isTriggerAura[SPELL_AURA_MOD_FEAR] = true; // Aura not have charges but need remove him on trigger
+    isTriggerAura[SPELL_AURA_MOD_ROOT] = true;
+    isTriggerAura[SPELL_AURA_TRANSFORM] = true;
+    isTriggerAura[SPELL_AURA_REFLECT_SPELLS] = true;
+    isTriggerAura[SPELL_AURA_DAMAGE_IMMUNITY] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_DAMAGE] = true;
+    isTriggerAura[SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK] = true;
+    isTriggerAura[SPELL_AURA_SCHOOL_ABSORB] = true; // Savage Defense untested
+    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT] = true;
+    isTriggerAura[SPELL_AURA_MOD_POWER_COST_SCHOOL] = true;
+    isTriggerAura[SPELL_AURA_REFLECT_SPELLS_SCHOOL] = true;
+    isTriggerAura[SPELL_AURA_MECHANIC_IMMUNITY] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN] = true;
+    isTriggerAura[SPELL_AURA_SPELL_MAGNET] = true;
+    isTriggerAura[SPELL_AURA_MOD_ATTACK_POWER] = true;
+    isTriggerAura[SPELL_AURA_ADD_CASTER_HIT_TRIGGER] = true;
+    isTriggerAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
+    isTriggerAura[SPELL_AURA_MOD_MECHANIC_RESISTANCE] = true;
+    isTriggerAura[SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS] = true;
+    isTriggerAura[SPELL_AURA_MOD_HASTE] = true;
+    isTriggerAura[SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE]=true;
+    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE] = true;
+    isTriggerAura[SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE] = true;
+    isTriggerAura[SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE] = true;
+    isTriggerAura[SPELL_AURA_MOD_DAMAGE_FROM_CASTER] = true;
+    isTriggerAura[SPELL_AURA_MOD_SPELL_CRIT_CHANCE] = true;
+    isTriggerAura[SPELL_AURA_ABILITY_IGNORE_AURASTATE] = true;
+
+    isNonTriggerAura[SPELL_AURA_MOD_POWER_REGEN]=true;
+    isNonTriggerAura[SPELL_AURA_REDUCE_PUSHBACK]=true;
+
+    isAlwaysTriggeredAura[SPELL_AURA_OVERRIDE_CLASS_SCRIPTS] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_FEAR] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_ROOT] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_STUN] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_TRANSFORM] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_SPELL_MAGNET] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_SCHOOL_ABSORB] = true;
+    isAlwaysTriggeredAura[SPELL_AURA_MOD_STEALTH] = true;
+
+    return true;
+}
+
+uint32 createProcExtendMask(SpellNonMeleeDamage *damageInfo, SpellMissInfo missCondition)
+{
+    uint32 procEx = PROC_EX_NONE;
+    // Check victim state
+    if (missCondition != SPELL_MISS_NONE)
+        switch (missCondition)
+        {
+            case SPELL_MISS_MISS:    procEx|=PROC_EX_MISS;   break;
+            case SPELL_MISS_RESIST:  procEx|=PROC_EX_RESIST; break;
+            case SPELL_MISS_DODGE:   procEx|=PROC_EX_DODGE;  break;
+            case SPELL_MISS_PARRY:   procEx|=PROC_EX_PARRY;  break;
+            case SPELL_MISS_BLOCK:   procEx|=PROC_EX_BLOCK;  break;
+            case SPELL_MISS_EVADE:   procEx|=PROC_EX_EVADE;  break;
+            case SPELL_MISS_IMMUNE:  procEx|=PROC_EX_IMMUNE; break;
+            case SPELL_MISS_IMMUNE2: procEx|=PROC_EX_IMMUNE; break;
+            case SPELL_MISS_DEFLECT: procEx|=PROC_EX_DEFLECT;break;
+            case SPELL_MISS_ABSORB:  procEx|=PROC_EX_ABSORB; break;
+            case SPELL_MISS_REFLECT: procEx|=PROC_EX_REFLECT;break;
+            default:
+                break;
+        }
+    else
+    {
+        // On block
+        if (damageInfo->blocked)
+            procEx|=PROC_EX_BLOCK;
+        // On absorb
+        if (damageInfo->absorb)
+            procEx|=PROC_EX_ABSORB;
+        // On crit
+        if (damageInfo->HitInfo & SPELL_HIT_TYPE_CRIT)
+            procEx|=PROC_EX_CRITICAL_HIT;
+        else
+            procEx|=PROC_EX_NORMAL_HIT;
+    }
+    return procEx;
+}
+
+void Unit::ProcDamageAndSpellFor(bool isVictim, Unit * pTarget, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, SpellEntry const * procSpell, uint32 damage, SpellEntry const * procAura)
+{
+    // Player is loaded now - do not allow passive spell casts to proc
+    if (GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->GetSession()->PlayerLoading())
+        return;
+    // For melee/ranged based attack need update skills and set some Aura states if victim present
+    if (procFlag & MELEE_BASED_TRIGGER_MASK && pTarget)
+    {
+        // Update skills here for players
+        if (GetTypeId() == TYPEID_PLAYER)
+        {
+            // On melee based hit/miss/resist need update skill (for victim and attacker)
+            if (procExtra&(PROC_EX_NORMAL_HIT|PROC_EX_MISS|PROC_EX_RESIST))
+            {
+                if (pTarget->GetTypeId() != TYPEID_PLAYER && pTarget->GetCreatureType() != CREATURE_TYPE_CRITTER)
+                    this->ToPlayer()->UpdateCombatSkills(pTarget, attType, isVictim);
+            }
+            // Update defence if player is victim and parry/dodge/block
+            else if (isVictim && procExtra&(PROC_EX_DODGE|PROC_EX_PARRY|PROC_EX_BLOCK))
+                this->ToPlayer()->UpdateCombatSkills(pTarget, attType, true);
+        }
+        // If exist crit/parry/dodge/block need update aura state (for victim and attacker)
+        if (procExtra & (PROC_EX_CRITICAL_HIT|PROC_EX_PARRY|PROC_EX_DODGE|PROC_EX_BLOCK))
+        {
+            // for victim
+            if (isVictim)
+            {
+                // if victim and dodge attack
+                if (procExtra&PROC_EX_DODGE)
+                {
+                    //Update AURA_STATE on dodge
+                    if (getClass() != CLASS_ROGUE) // skip Rogue Riposte
+                    {
+                        ModifyAuraState(AURA_STATE_DEFENSE, true);
+                        StartReactiveTimer(REACTIVE_DEFENSE);
+                    }
+                }
+                // if victim and parry attack
+                if (procExtra & PROC_EX_PARRY)
+                {
+                    // For Hunters only Counterattack (skip Mongoose bite)
+                    if (getClass() == CLASS_HUNTER)
+                    {
+                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
+                        StartReactiveTimer(REACTIVE_HUNTER_PARRY);
+                    }
+                    else
+                    {
+                        ModifyAuraState(AURA_STATE_DEFENSE, true);
+                        StartReactiveTimer(REACTIVE_DEFENSE);
+                    }
+                }
+                // if and victim block attack
+                if (procExtra & PROC_EX_BLOCK)
+                {
+                    ModifyAuraState(AURA_STATE_DEFENSE,true);
+                    StartReactiveTimer(REACTIVE_DEFENSE);
+                }
+            }
+            else //For attacker
+            {
+                // Overpower on victim dodge
+                if (procExtra&PROC_EX_DODGE && GetTypeId() == TYPEID_PLAYER && getClass() == CLASS_WARRIOR)
+                {
+                    this->ToPlayer()->AddComboPoints(pTarget, 1);
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+            }
+        }
+    }
+
+    ProcTriggeredList procTriggered;
+    // Fill procTriggered list
+    for (AuraApplicationMap::const_iterator itr = GetAppliedAuras().begin(); itr!= GetAppliedAuras().end(); ++itr)
+    {
+        // Do not allow auras to proc from effect triggered by itself
+        if (procAura && procAura->Id == itr->first)
+            continue;
+        ProcTriggeredData triggerData(itr->second->GetBase());
+        // Defensive procs are active on absorbs (so absorption effects are not a hindrance)
+        bool active = (damage > 0) || (procExtra & (PROC_EX_ABSORB|PROC_EX_BLOCK) && isVictim);
+        if (isVictim)
+            procExtra &= ~PROC_EX_INTERNAL_REQ_FAMILY;
+        SpellEntry const* spellProto = itr->second->GetBase()->GetSpellProto();
+        if(!IsTriggeredAtSpellProcEvent(pTarget, triggerData.aura, procSpell, procFlag, procExtra, attType, isVictim, active, triggerData.spellProcEvent))
+            continue;
+
+        // Triggered spells not triggering additional spells
+        bool triggered= !(spellProto->AttributesEx3 & SPELL_ATTR_EX3_CAN_PROC_TRIGGERED) ?
+            (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION)) : false;
+
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (itr->second->HasEffect(i))
+            {
+                AuraEffect * aurEff = itr->second->GetBase()->GetEffect(i);
+                // Skip this auras
+                if (isNonTriggerAura[aurEff->GetAuraType()])
+                    continue;
+                // If not trigger by default and spellProcEvent == NULL - skip
+                if (!isTriggerAura[aurEff->GetAuraType()] && triggerData.spellProcEvent == NULL)
+                    continue;
+                // Some spells must always trigger
+                if (!triggered || isAlwaysTriggeredAura[aurEff->GetAuraType()])
+                    triggerData.effMask |= 1<<i;
+            }
+        }
+        if (triggerData.effMask)
+            procTriggered.push_front(triggerData);
+    }
+
+    // Nothing found
+    if (procTriggered.empty())
+        return;
+
+    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
+        SetCantProc(true);
+
+    // Handle effects proceed this time
+    for (ProcTriggeredList::const_iterator i = procTriggered.begin(); i != procTriggered.end(); ++i)
+    {
+        // look for aura in auras list, it may be removed while proc event processing
+        if (i->aura->IsRemoved())
+            continue;
+
+        bool useCharges= i->aura->GetCharges()>0;
+        bool takeCharges = false;
+        SpellEntry const *spellInfo = i->aura->GetSpellProto();
+        uint32 Id = i->aura->GetId();
+
+        // For players set spell cooldown if need
+        uint32 cooldown = 0;
+        if (GetTypeId() == TYPEID_PLAYER && i->spellProcEvent && i->spellProcEvent->cooldown)
+            cooldown = i->spellProcEvent->cooldown;
+
+        if (spellInfo->AttributesEx3 & SPELL_ATTR_EX3_DISABLE_PROC)
+            SetCantProc(true);
+
+        // This bool is needed till separate aura effect procs are still here
+        bool handled = false;
+        if (HandleAuraProc(pTarget, damage, i->aura, procSpell, procFlag, procExtra, cooldown, &handled))
+        {
+            sLog.outDebug("ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), Id);
+            takeCharges = true;
+        }
+
+        if (!handled)
+        for (uint8 effIndex = 0; effIndex<MAX_SPELL_EFFECTS; ++effIndex)
+        {
+            if (!(i->effMask & (1<<effIndex)))
+                continue;
+
+            AuraEffect *triggeredByAura = i->aura->GetEffect(effIndex);
+            ASSERT(triggeredByAura);
+
+            switch(triggeredByAura->GetAuraType())
+            {
+                case SPELL_AURA_PROC_TRIGGER_SPELL:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: casting spell %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    // Don`t drop charge or add cooldown for not started trigger
+                    if (HandleProcTriggerSpell(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                        takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_PROC_TRIGGER_DAMAGE:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: doing %u damage from spell id %u (triggered by %s aura of spell %u)", triggeredByAura->GetAmount() , spellInfo->Id, (isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    SpellNonMeleeDamage damageInfo(this, pTarget, spellInfo->Id, spellInfo->SchoolMask);
+                    uint32 damage = SpellDamageBonus(pTarget, spellInfo, triggeredByAura->GetAmount(), SPELL_DIRECT_DAMAGE);
+                    CalculateSpellDamageTaken(&damageInfo, damage, spellInfo);
+                    DealDamageMods(damageInfo.target,damageInfo.damage,&damageInfo.absorb);
+                    SendSpellNonMeleeDamageLog(&damageInfo);
+                    DealSpellDamage(&damageInfo, true);
+                    takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_MANA_SHIELD:
+                case SPELL_AURA_DUMMY:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s dummy aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    if (HandleDummyAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                        takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_OBS_MOD_POWER:
+                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    if (HandleObsModEnergyAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN:
+                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    if (HandleModDamagePctTakenAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_MOD_HASTE:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s haste aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    if (HandleHasteAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                        takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_OVERRIDE_CLASS_SCRIPTS:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    if (HandleOverrideClassScriptAuraProc(pTarget, damage, triggeredByAura, procSpell, cooldown))
+                        takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)",
+                        (isVictim?"a victim's":"an attacker's"),triggeredByAura->GetId());
+
+                    HandleAuraRaidProcFromChargeWithValue(triggeredByAura);
+                    takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_RAID_PROC_FROM_CHARGE:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: casting mending (triggered by %s dummy aura of spell %u)",
+                        (isVictim?"a victim's":"an attacker's"),triggeredByAura->GetId());
+
+                    HandleAuraRaidProcFromCharge(triggeredByAura);
+                    takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_PROC_TRIGGER_SPELL_WITH_VALUE:
+                {
+                    sLog.outDebug("ProcDamageAndSpell: casting spell %u (triggered with value by %s aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+
+                    if (HandleProcTriggerSpell(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                        takeCharges = true;
+                    break;
+                }
+                case SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK:
+                    // Skip melee hits or instant cast spells
+                    if (procSpell && GetSpellCastTime(procSpell) != 0)
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_REFLECT_SPELLS_SCHOOL:
+                    // Skip Melee hits and spells ws wrong school
+                    if (procSpell && (triggeredByAura->GetMiscValue() & procSpell->SchoolMask))         // School check
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_MOD_POWER_COST_SCHOOL_PCT:
+                case SPELL_AURA_MOD_POWER_COST_SCHOOL:
+                    // Skip melee hits and spells ws wrong school or zero cost
+                    if (procSpell &&
+                        (procSpell->manaCost != 0 || procSpell->ManaCostPercentage != 0) && // Cost check
+                        (triggeredByAura->GetMiscValue() & procSpell->SchoolMask) == 0)         // School check
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_MECHANIC_IMMUNITY:
+                    // Compare mechanic
+                    if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_MOD_MECHANIC_RESISTANCE:
+                    // Compare mechanic
+                    if (procSpell && procSpell->Mechanic == uint32(triggeredByAura->GetMiscValue()))
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_MOD_DAMAGE_FROM_CASTER:
+                    // Compare casters
+                    if (triggeredByAura->GetCasterGUID() == pTarget->GetGUID())
+                        takeCharges = true;
+                    break;
+                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
+                    sLog.outDebug("ProcDamageAndSpell: casting spell id %u (triggered by %s spell crit chance aura of spell %u)", spellInfo->Id,(isVictim?"a victim's":"an attacker's"), triggeredByAura->GetId());
+                    if (procSpell && HandleSpellCritChanceAuraProc(pTarget, damage, triggeredByAura, procSpell, procFlag, procExtra, cooldown))
+                        takeCharges = true;
+                    break;
+                // CC Auras which use their amount amount to drop
+                // Are there any more auras which need this?
+                case SPELL_AURA_MOD_CONFUSE:
+                case SPELL_AURA_MOD_FEAR:
+                case SPELL_AURA_MOD_STUN:
+                case SPELL_AURA_MOD_ROOT:
+                case SPELL_AURA_TRANSFORM:
+                {
+                    // chargeable mods are breaking on hit
+                    if (useCharges)
+                        takeCharges = true;
+                    else
+                    {
+                        // Spell own direct damage at apply wont break the CC
+                        if (procSpell && (procSpell->Id == triggeredByAura->GetId()))
+                        {
+                            Aura * aura = triggeredByAura->GetBase();
+                            // called from spellcast, should not have ticked yet
+                            if (aura->GetDuration() == aura->GetMaxDuration())
+                                break;
+                        }
+                        int32 damageLeft = triggeredByAura->GetAmount();
+                        // No damage left
+                        if (damageLeft < int32(damage))
+                            i->aura->Remove();
+                        else
+                            triggeredByAura->SetAmount(damageLeft - damage);
+                    }
+                    break;
+                }
+                //case SPELL_AURA_ADD_FLAT_MODIFIER:
+                //case SPELL_AURA_ADD_PCT_MODIFIER:
+                    // HandleSpellModAuraProc
+                    //break;
+                default:
+                    // nothing do, just charges counter
+                    takeCharges = true;
+                    break;
+            }
+        }
+        // Remove charge (aura can be removed by triggers)
+        if (useCharges && takeCharges)
+            i->aura->DropCharge();
+
+        if (spellInfo->AttributesEx3 & SPELL_ATTR_EX3_DISABLE_PROC)
+            SetCantProc(false);
+    }
+
+    // Cleanup proc requirements
+    if (procExtra & (PROC_EX_INTERNAL_TRIGGERED | PROC_EX_INTERNAL_CANT_PROC))
+        SetCantProc(false);
+}
+
+SpellSchoolMask Unit::GetMeleeDamageSchoolMask() const
+{
+    return SPELL_SCHOOL_MASK_NORMAL;
+}
+
+Player* Unit::GetSpellModOwner() const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        return (Player*)this;
+    if (this->ToCreature()->isPet() || this->ToCreature()->isTotem())
+    {
+        Unit* owner = GetOwner();
+        if (owner && owner->GetTypeId() == TYPEID_PLAYER)
+            return (Player*)owner;
+    }
+    return NULL;
+}
+
+///----------Pet responses methods-----------------
+void Unit::SendPetCastFail(uint32 spellid, SpellCastResult msg)
+{
+    if (msg == SPELL_CAST_OK)
+        return;
+
+    Unit *owner = GetCharmerOrOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_PET_CAST_FAILED, 1 + 4 + 1);
+    data << uint8(0);                                       // cast count?
+    data << uint32(spellid);
+    data << uint8(msg);
+    // uint32 for some reason
+    // uint32 for some reason
+    owner->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Unit::SendPetActionFeedback (uint8 msg)
+{
+    Unit* owner = GetOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_PET_ACTION_FEEDBACK, 1);
+    data << uint8(msg);
+    owner->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Unit::SendPetTalk (uint32 pettalk)
+{
+    Unit* owner = GetOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_PET_ACTION_SOUND, 8 + 4);
+    data << uint64(GetGUID());
+    data << uint32(pettalk);
+    owner->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Unit::SendPetAIReaction(uint64 guid)
+{
+    Unit* owner = GetOwner();
+    if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_AI_REACTION, 8 + 4);
+    data << uint64(guid);
+    data << uint32(AI_REACTION_HOSTILE);
+    owner->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+///----------End of Pet responses methods----------
+
+void Unit::StopMoving()
+{
+    clearUnitState(UNIT_STAT_MOVING);
+
+    // send explicit stop packet
+    // rely on vmaps here because for example stormwind is in air
+    //float z = sMapMgr.GetBaseMap(GetMapId())->GetHeight(GetPositionX(), GetPositionY(), GetPositionZ(), true);
+    //if (fabs(GetPositionZ() - z) < 2.0f)
+    //    Relocate(GetPositionX(), GetPositionY(), z);
+    //Relocate(GetPositionX(), GetPositionY(),GetPositionZ());
+
+    SendMonsterStop();
+}
+
+void Unit::SendMovementFlagUpdate()
+{
+    WorldPacket data;
+    BuildHeartBeatMsg(&data);
+    SendMessageToSet(&data, false);
+}
+
+bool Unit::IsSitState() const
+{
+    uint8 s = getStandState();
+    return
+        s == UNIT_STAND_STATE_SIT_CHAIR        || s == UNIT_STAND_STATE_SIT_LOW_CHAIR  ||
+        s == UNIT_STAND_STATE_SIT_MEDIUM_CHAIR || s == UNIT_STAND_STATE_SIT_HIGH_CHAIR ||
+        s == UNIT_STAND_STATE_SIT;
+}
+
+bool Unit::IsStandState() const
+{
+    uint8 s = getStandState();
+    return !IsSitState() && s != UNIT_STAND_STATE_SLEEP && s != UNIT_STAND_STATE_KNEEL;
+}
+
+void Unit::SetStandState(uint8 state)
+{
+    SetByteValue(UNIT_FIELD_BYTES_1, 0, state);
+
+    if (IsStandState())
+       RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_SEATED);
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        WorldPacket data(SMSG_STANDSTATE_UPDATE, 1);
+        data << (uint8)state;
+        this->ToPlayer()->GetSession()->SendPacket(&data);
+    }
+}
+
+bool Unit::IsPolymorphed() const
+{
+    uint32 transformId = getTransForm();
+    if (!transformId)
+        return false;
+
+    const SpellEntry *spellInfo=sSpellStore.LookupEntry(transformId);
+    if (!spellInfo)
+        return false;
+
+    return GetSpellSpecific(spellInfo) == SPELL_SPECIFIC_MAGE_POLYMORPH;
+}
+
+void Unit::SetDisplayId(uint32 modelId)
+{
+    SetUInt32Value(UNIT_FIELD_DISPLAYID, modelId);
+
+    if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (!pet->isControlled())
+            return;
+        Unit *owner = GetOwner();
+        if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+            owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_MODEL_ID);
+    }
+}
+
+void Unit::ClearComboPointHolders()
+{
+    while (!m_ComboPointHolders.empty())
+    {
+        uint32 lowguid = *m_ComboPointHolders.begin();
+
+        Player* plr = sObjectMgr.GetPlayer(MAKE_NEW_GUID(lowguid, 0, HIGHGUID_PLAYER));
+        if (plr && plr->GetComboTarget() == GetGUID())         // recheck for safe
+            plr->ClearComboPoints();                        // remove also guid from m_ComboPointHolders;
+        else
+            m_ComboPointHolders.erase(lowguid);             // or remove manually
+    }
+}
+
+void Unit::ClearAllReactives()
+{
+    for (uint8 i=0; i < MAX_REACTIVE; ++i)
+        m_reactiveTimer[i] = 0;
+
+    if (HasAuraState(AURA_STATE_DEFENSE))
+        ModifyAuraState(AURA_STATE_DEFENSE, false);
+    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->ClearComboPoints();
+}
+
+void Unit::UpdateReactives(uint32 p_time)
+{
+    for (uint8 i = 0; i < MAX_REACTIVE; ++i)
+    {
+        ReactiveType reactive = ReactiveType(i);
+
+        if (!m_reactiveTimer[reactive])
+            continue;
+
+        if (m_reactiveTimer[reactive] <= p_time)
+        {
+            m_reactiveTimer[reactive] = 0;
+
+            switch (reactive)
+            {
+                case REACTIVE_DEFENSE:
+                    if (HasAuraState(AURA_STATE_DEFENSE))
+                        ModifyAuraState(AURA_STATE_DEFENSE, false);
+                    break;
+                case REACTIVE_HUNTER_PARRY:
+                    if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                        ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+                    break;
+                case REACTIVE_OVERPOWER:
+                    if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+                        this->ToPlayer()->ClearComboPoints();
+                    break;
+                default:
+                    break;
+            }
+        }
+        else
+        {
+            m_reactiveTimer[reactive] -= p_time;
+        }
+    }
+}
+
+Unit* Unit::SelectNearbyTarget(float dist) const
+{
+    std::list<Unit *> targets;
+    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(this, this, dist);
+    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(this, targets, u_check);
+    VisitNearbyObject(dist, searcher);
+
+    // remove current target
+    if (getVictim())
+        targets.remove(getVictim());
+
+    // remove not LoS targets
+    for (std::list<Unit *>::iterator tIter = targets.begin(); tIter != targets.end();)
+    {
+        if (!IsWithinLOSInMap(*tIter))
+        {
+            std::list<Unit *>::iterator tIter2 = tIter;
+            ++tIter;
+            targets.erase(tIter2);
+        }
+        else
+            ++tIter;
+    }
+
+    // no appropriate targets
+    if (targets.empty())
+        return NULL;
+
+    // select random
+    uint32 rIdx = urand(0,targets.size()-1);
+    std::list<Unit *>::const_iterator tcIter = targets.begin();
+    for (uint32 i = 0; i < rIdx; ++i)
+        ++tcIter;
+
+    return *tcIter;
+}
+
+void Unit::ApplyAttackTimePercentMod(WeaponAttackType att,float val, bool apply)
+{
+    float remainingTimePct = (float)m_attackTimer[att] / (GetAttackTime(att) * m_modAttackSpeedPct[att]);
+    if (val > 0)
+    {
+        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], val, !apply);
+        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att,val,!apply);
+    }
+    else
+    {
+        ApplyPercentModFloatVar(m_modAttackSpeedPct[att], -val, apply);
+        ApplyPercentModFloatValue(UNIT_FIELD_BASEATTACKTIME+att,-val,apply);
+    }
+    m_attackTimer[att] = uint32(GetAttackTime(att) * m_modAttackSpeedPct[att] * remainingTimePct);
+}
+
+void Unit::ApplyCastTimePercentMod(float val, bool apply)
+{
+    if (val > 0)
+        ApplyPercentModFloatValue(UNIT_MOD_CAST_SPEED,val,!apply);
+    else
+        ApplyPercentModFloatValue(UNIT_MOD_CAST_SPEED,-val,apply);
+}
+
+uint32 Unit::GetCastingTimeForBonus(SpellEntry const *spellProto, DamageEffectType damagetype, uint32 CastingTime)
+{
+    // Not apply this to creature casted spells with casttime == 0
+    if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !this->ToCreature()->isPet())
+        return 3500;
+
+    if (CastingTime > 7000) CastingTime = 7000;
+    if (CastingTime < 1500) CastingTime = 1500;
+
+    if (damagetype == DOT && !IsChanneledSpell(spellProto))
+        CastingTime = 3500;
+
+    int32 overTime    = 0;
+    uint8 effects     = 0;
+    bool DirectDamage = false;
+    bool AreaEffect   = false;
+
+    for (uint32 i=0; i<MAX_SPELL_EFFECTS; i++)
+    {
+        switch (spellProto->Effect[i])
+        {
+            case SPELL_EFFECT_SCHOOL_DAMAGE:
+            case SPELL_EFFECT_POWER_DRAIN:
+            case SPELL_EFFECT_HEALTH_LEECH:
+            case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
+            case SPELL_EFFECT_POWER_BURN:
+            case SPELL_EFFECT_HEAL:
+                DirectDamage = true;
+                break;
+            case SPELL_EFFECT_APPLY_AURA:
+                switch (spellProto->EffectApplyAuraName[i])
+                {
+                    case SPELL_AURA_PERIODIC_DAMAGE:
+                    case SPELL_AURA_PERIODIC_HEAL:
+                    case SPELL_AURA_PERIODIC_LEECH:
+                        if (GetSpellDuration(spellProto))
+                            overTime = GetSpellDuration(spellProto);
+                        break;
+                    default:
+                        // -5% per additional effect
+                        ++effects;
+                        break;
+                }
+            default:
+                break;
+        }
+
+        if (IsAreaEffectTarget[spellProto->EffectImplicitTargetA[i]] || IsAreaEffectTarget[spellProto->EffectImplicitTargetB[i]])
+            AreaEffect = true;
+    }
+
+    // Combined Spells with Both Over Time and Direct Damage
+    if (overTime > 0 && CastingTime > 0 && DirectDamage)
+    {
+        // mainly for DoTs which are 3500 here otherwise
+        uint32 OriginalCastTime = GetSpellCastTime(spellProto);
+        if (OriginalCastTime > 7000) OriginalCastTime = 7000;
+        if (OriginalCastTime < 1500) OriginalCastTime = 1500;
+        // Portion to Over Time
+        float PtOT = (overTime / 15000.0f) / ((overTime / 15000.0f) + (OriginalCastTime / 3500.0f));
+
+        if (damagetype == DOT)
+            CastingTime = uint32(CastingTime * PtOT);
+        else if (PtOT < 1.0f)
+            CastingTime  = uint32(CastingTime * (1 - PtOT));
+        else
+            CastingTime = 0;
+    }
+
+    // Area Effect Spells receive only half of bonus
+    if (AreaEffect)
+        CastingTime /= 2;
+
+    // -5% of total per any additional effect
+    for (uint8 i=0; i<effects; ++i)
+    {
+        if (CastingTime > 175)
+        {
+            CastingTime -= 175;
+        }
+        else
+        {
+            CastingTime = 0;
+            break;
+        }
+    }
+
+    return CastingTime;
+}
+
+void Unit::UpdateAuraForGroup(uint8 slot)
+{
+    if (slot >= MAX_AURAS)                        // slot not found, return
+        return;
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* player = (Player*)this;
+        if (player->GetGroup())
+        {
+            player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_AURAS);
+            player->SetAuraUpdateMaskForRaid(slot);
+        }
+    }
+    else if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->isPet())
+    {
+        Pet *pet = ((Pet*)this);
+        if (pet->isControlled())
+        {
+            Unit *owner = GetOwner();
+            if (owner && (owner->GetTypeId() == TYPEID_PLAYER) && owner->ToPlayer()->GetGroup())
+            {
+                owner->ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET_AURAS);
+                pet->SetAuraUpdateMaskForRaid(slot);
+            }
+        }
+    }
+}
+
+float Unit::GetAPMultiplier(WeaponAttackType attType, bool normalized)
+{
+    if (!normalized || GetTypeId() != TYPEID_PLAYER)
+        return float(GetAttackTime(attType))/1000.0f;
+
+    Item *Weapon = this->ToPlayer()->GetWeaponForAttack(attType, true);
+    if (!Weapon)
+        return 2.4f;                                         // fist attack
+
+    switch (Weapon->GetProto()->InventoryType)
+    {
+        case INVTYPE_2HWEAPON:
+            return 3.3f;
+        case INVTYPE_RANGED:
+        case INVTYPE_RANGEDRIGHT:
+        case INVTYPE_THROWN:
+            return 2.8f;
+        case INVTYPE_WEAPON:
+        case INVTYPE_WEAPONMAINHAND:
+        case INVTYPE_WEAPONOFFHAND:
+        default:
+            return Weapon->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ? 1.7f : 2.4f;
+    }
+}
+
+bool Unit::IsUnderLastManaUseEffect() const
+{
+    return  getMSTimeDiff(m_lastManaUse,getMSTime()) < 5000;
+}
+
+void Unit::SetContestedPvP(Player *attackedPlayer)
+{
+    Player* player = GetCharmerOrOwnerPlayerOrPlayerItself();
+
+    if (!player || (attackedPlayer && (attackedPlayer == player || (player->duel && player->duel->opponent == attackedPlayer))))
+        return;
+
+    player->SetContestedPvPTimer(30000);
+    if (!player->hasUnitState(UNIT_STAT_ATTACK_PLAYER))
+    {
+        player->addUnitState(UNIT_STAT_ATTACK_PLAYER);
+        player->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
+        // call MoveInLineOfSight for nearby contested guards
+        player->SetVisibility(player->GetVisibility());
+    }
+    if (!hasUnitState(UNIT_STAT_ATTACK_PLAYER))
+    {
+        addUnitState(UNIT_STAT_ATTACK_PLAYER);
+        // call MoveInLineOfSight for nearby contested guards
+        SetVisibility(GetVisibility());
+    }
+}
+
+void Unit::AddPetAura(PetAura const* petSpell)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    m_petAuras.insert(petSpell);
+    if (Pet* pet = this->ToPlayer()->GetPet())
+        pet->CastPetAura(petSpell);
+}
+
+void Unit::RemovePetAura(PetAura const* petSpell)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    m_petAuras.erase(petSpell);
+    if (Pet* pet = this->ToPlayer()->GetPet())
+        pet->RemoveAurasDueToSpell(petSpell->GetAura(pet->GetEntry()));
+}
+
+Pet* Unit::CreateTamedPetFrom(Creature* creatureTarget,uint32 spell_id)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return NULL;
+
+    Pet* pet = new Pet((Player*)this, HUNTER_PET);
+
+    if (!pet->CreateBaseAtCreature(creatureTarget))
+    {
+        delete pet;
+        return NULL;
+    }
+
+    uint8 level = (creatureTarget->getLevel() < (getLevel() - 5)) ? (getLevel() - 5) : creatureTarget->getLevel();
+
+    InitTamedPet(pet, level, spell_id);
+
+    return pet;
+}
+
+Pet* Unit::CreateTamedPetFrom(uint32 creatureEntry, uint32 spell_id)
+{
+    if (GetTypeId() != TYPEID_PLAYER)
+        return NULL;
+
+    CreatureInfo const* creatureInfo = sObjectMgr.GetCreatureTemplate(creatureEntry);
+    if (!creatureInfo)
+        return NULL;
+
+    Pet* pet = new Pet((Player*)this, HUNTER_PET);
+
+    if (!pet->CreateBaseAtCreatureInfo(creatureInfo, this) || !InitTamedPet(pet, getLevel(), spell_id))
+    {
+        delete pet;
+        return NULL;
+    }
+
+    return pet;
+}
+
+bool Unit::InitTamedPet(Pet * pet, uint8 level, uint32 spell_id)
+{
+    pet->SetCreatorGUID(GetGUID());
+    pet->setFaction(getFaction());
+    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, spell_id);
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        pet->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+
+    if (!pet->InitStatsForLevel(level))
+    {
+        sLog.outError("Pet::InitStatsForLevel() failed for creature (Entry: %u)!",pet->GetEntry());
+        return false;
+    }
+
+    pet->GetCharmInfo()->SetPetNumber(sObjectMgr.GeneratePetNumber(), true);
+    // this enables pet details window (Shift+P)
+    pet->InitPetCreateSpells();
+    //pet->InitLevelupSpellsForLevel();
+    pet->SetFullHealth();
+    return true;
+}
+
+bool Unit::IsTriggeredAtSpellProcEvent(Unit *pVictim, Aura * aura, SpellEntry const* procSpell, uint32 procFlag, uint32 procExtra, WeaponAttackType attType, bool isVictim, bool active, SpellProcEventEntry const *& spellProcEvent)
+{
+    SpellEntry const *spellProto = aura->GetSpellProto();
+
+    // Get proc Event Entry
+    spellProcEvent = sSpellMgr.GetSpellProcEvent(spellProto->Id);
+
+    // Get EventProcFlag
+    uint32 EventProcFlag;
+    if (spellProcEvent && spellProcEvent->procFlags) // if exist get custom spellProcEvent->procFlags
+        EventProcFlag = spellProcEvent->procFlags;
+    else
+        EventProcFlag = spellProto->procFlags;       // else get from spell proto
+    // Continue if no trigger exist
+    if (!EventProcFlag)
+        return false;
+
+    // Additional checks for triggered spells (ignore trap casts)
+    if (procExtra & PROC_EX_INTERNAL_TRIGGERED && !(procFlag & PROC_FLAG_DONE_TRAP_ACTIVATION))
+    {
+        if (!(spellProto->AttributesEx3 & SPELL_ATTR_EX3_CAN_PROC_TRIGGERED))
+            return false;
+    }
+
+    // Check spellProcEvent data requirements
+    if (!sSpellMgr.IsSpellProcEventCanTriggeredBy(spellProcEvent, EventProcFlag, procSpell, procFlag, procExtra, active))
+        return false;
+    // In most cases req get honor or XP from kill
+    if (EventProcFlag & PROC_FLAG_KILL && GetTypeId() == TYPEID_PLAYER)
+    {
+        bool allow = false;
+
+        if (pVictim)
+            allow = ToPlayer()->isHonorOrXPTarget(pVictim);
+
+        // Shadow Word: Death - can trigger from every kill
+        if (aura->GetId() == 32409)
+            allow = true;
+        if (!allow)
+            return false;
+    }
+    // Aura added by spell can`t trigger from self (prevent drop charges/do triggers)
+    // But except periodic and kill triggers (can triggered from self)
+    if (procSpell && procSpell->Id == spellProto->Id
+        && !(spellProto->procFlags&(PROC_FLAG_TAKEN_PERIODIC | PROC_FLAG_KILL)))
+        return false;
+
+    // Check if current equipment allows aura to proc
+    if (!isVictim && GetTypeId() == TYPEID_PLAYER)
+    {
+        if (spellProto->EquippedItemClass == ITEM_CLASS_WEAPON)
+        {
+            Item *item = NULL;
+            if (attType == BASE_ATTACK)
+                item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+            else if (attType == OFF_ATTACK)
+                item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+            else
+                item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+
+            if (this->ToPlayer()->IsInFeralForm())
+                return false;
+
+            if (!item || item->IsBroken() || item->GetProto()->Class != ITEM_CLASS_WEAPON || !((1<<item->GetProto()->SubClass) & spellProto->EquippedItemSubClassMask))
+                return false;
+        }
+        else if (spellProto->EquippedItemClass == ITEM_CLASS_ARMOR)
+        {
+            // Check if player is wearing shield
+            Item *item = this->ToPlayer()->GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+            if (!item || item->IsBroken() || item->GetProto()->Class != ITEM_CLASS_ARMOR || !((1<<item->GetProto()->SubClass) & spellProto->EquippedItemSubClassMask))
+                return false;
+        }
+    }
+    // Get chance from spell
+    float chance = float(spellProto->procChance);
+    // If in spellProcEvent exist custom chance, chance = spellProcEvent->customChance;
+    if (spellProcEvent && spellProcEvent->customChance)
+        chance = spellProcEvent->customChance;
+    // If PPM exist calculate chance from PPM
+    if (spellProcEvent && spellProcEvent->ppmRate != 0)
+    {
+        if (!isVictim)
+        {
+            uint32 WeaponSpeed = GetAttackTime(attType);
+            chance = GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);
+        }
+        else
+        {
+            uint32 WeaponSpeed = pVictim->GetAttackTime(attType);
+            chance = pVictim->GetPPMProcChance(WeaponSpeed, spellProcEvent->ppmRate, spellProto);
+        }
+    }
+    // Apply chance modifer aura
+    if (Player* modOwner = GetSpellModOwner())
+    {
+        modOwner->ApplySpellMod(spellProto->Id,SPELLMOD_CHANCE_OF_SUCCESS,chance);
+    }
+    return roll_chance_f(chance);
+}
+
+bool Unit::HandleAuraRaidProcFromChargeWithValue(AuraEffect *triggeredByAura)
+{
+    // aura can be deleted at casts
+    SpellEntry const *spellProto = triggeredByAura->GetSpellProto();
+    uint32 effIdx = triggeredByAura->GetEffIndex();
+    int32 heal = triggeredByAura->GetAmount();
+    uint64 caster_guid = triggeredByAura->GetCasterGUID();
+
+    //Currently only Prayer of Mending
+    if (!(spellProto->SpellFamilyName == SPELLFAMILY_PRIEST && spellProto->SpellFamilyFlags[1] & 0x20))
+    {
+        sLog.outDebug("Unit::HandleAuraRaidProcFromChargeWithValue, received not handled spell: %u", spellProto->Id);
+        return false;
+    }
+
+    // jumps
+    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;
+
+    // current aura expire
+    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease
+
+    // next target selection
+    if (jumps > 0)
+    {
+        float radius;
+        if (spellProto->EffectRadiusIndex[effIdx])
+            radius = (float)GetSpellRadiusForTarget(triggeredByAura->GetCaster(), sSpellRadiusStore.LookupEntry(spellProto->EffectRadiusIndex[effIdx]));
+        else
+            radius = (float)GetSpellMaxRangeForTarget(triggeredByAura->GetCaster(), sSpellRangeStore.LookupEntry(spellProto->rangeIndex));
+
+        if (Unit * caster = triggeredByAura->GetCaster())
+        {
+            if (Player * modOwner = caster->GetSpellModOwner())
+                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_RADIUS, radius, NULL);
+
+            if (Unit *target = GetNextRandomRaidMemberOrPet(radius))
+            {
+                CastCustomSpell(target, spellProto->Id, &heal, NULL, NULL, true, NULL, triggeredByAura, caster_guid);
+                if (Aura * aura = target->GetAura(spellProto->Id, caster->GetGUID()))
+                    aura->SetCharges(jumps);
+            }
+        }
+    }
+
+    // heal
+    CastCustomSpell(this, 33110, &heal, NULL, NULL, true, NULL, NULL, caster_guid);
+    return true;
+
+}
+bool Unit::HandleAuraRaidProcFromCharge(AuraEffect* triggeredByAura)
+{
+    // aura can be deleted at casts
+    SpellEntry const* spellProto = triggeredByAura->GetSpellProto();
+
+    uint32 damageSpellId;
+    switch (spellProto->Id)
+    {
+        case 57949:            //shiver
+            damageSpellId = 57952;
+            //animationSpellId = 57951; dummy effects for jump spell have unknown use (see also 41637)
+            break;
+        case 59978:            //shiver
+            damageSpellId = 59979;
+            break;
+        case 43593:            //Cold Stare
+            damageSpellId = 43594;
+            break;
+        default:
+            sLog.outError("Unit::HandleAuraRaidProcFromCharge, received not handled spell: %u", spellProto->Id);
+            return false;
+    }
+
+    uint64 caster_guid = triggeredByAura->GetCasterGUID();
+    uint32 effIdx = triggeredByAura->GetEffIndex();
+
+    // jumps
+    int32 jumps = triggeredByAura->GetBase()->GetCharges()-1;
+
+    // current aura expire
+    triggeredByAura->GetBase()->SetCharges(1);             // will removed at next charges decrease
+
+    // next target selection
+    if (jumps > 0)
+    {
+        float radius;
+        if (spellProto->EffectRadiusIndex[effIdx])
+            radius = (float)GetSpellRadiusForTarget(triggeredByAura->GetCaster(), sSpellRadiusStore.LookupEntry(spellProto->EffectRadiusIndex[effIdx]));
+        else
+            radius = (float)GetSpellMaxRangeForTarget(triggeredByAura->GetCaster() ,sSpellRangeStore.LookupEntry(spellProto->rangeIndex));
+
+        if (Unit * caster = triggeredByAura->GetCaster())
+        {
+            if (Player * modOwner = caster->GetSpellModOwner())
+                modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_RADIUS, radius, NULL);
+
+            if (Unit* target= GetNextRandomRaidMemberOrPet(radius))
+            {
+                CastSpell(target, spellProto, true,NULL,triggeredByAura,caster_guid);
+                if (Aura * aura = target->GetAura(spellProto->Id, caster->GetGUID()))
+                    aura->SetCharges(jumps);
+            }
+        }
+    }
+
+    CastSpell(this, damageSpellId, true,NULL,triggeredByAura,caster_guid);
+
+    return true;
+}
+
+void Unit::Kill(Unit *pVictim, bool durabilityLoss)
+{
+    // Prevent killing unit twice (and giving reward from kill twice)
+    if (!pVictim->GetHealth())
+        return;
+
+    // Inform pets (if any) when player kills target)
+    if (this->ToPlayer())
+    {
+        Pet *pPet = this->ToPlayer()->GetPet();
+        if (pPet && pPet->isAlive() && pPet->isControlled())
+            pPet->AI()->KilledUnit(pVictim);
+    }
+
+    // find player: owner of controlled `this` or `this` itself maybe
+    Player *player = GetCharmerOrOwnerPlayerOrPlayerItself();
+    Creature *creature = pVictim->ToCreature();
+
+    bool bRewardIsAllowed = true;
+    if (creature)
+    {
+        bRewardIsAllowed = creature->IsDamageEnoughForLootingAndReward();
+        if (!bRewardIsAllowed)
+            creature->SetLootRecipient(NULL);
+    }
+
+    if (bRewardIsAllowed && creature && creature->GetLootRecipient())
+        player = creature->GetLootRecipient();
+
+    // Reward player, his pets, and group/raid members
+    // call kill spell proc event (before real die and combat stop to triggering auras removed at death/combat stop)
+    if (bRewardIsAllowed && player && player != pVictim)
+    {
+        WorldPacket data(SMSG_PARTYKILLLOG, (8+8)); //send event PARTY_KILL
+        data << uint64(player->GetGUID()); //player with killing blow
+        data << uint64(pVictim->GetGUID()); //victim
+
+        Player* pLooter = player;
+
+        if (Group *group = player->GetGroup())
+        {
+            group->BroadcastPacket(&data, group->GetMemberGroup(player->GetGUID()));
+
+            if (creature)
+            {
+                group->UpdateLooterGuid(creature, true);
+                if (group->GetLooterGuid())
+                {
+                    pLooter = sObjectMgr.GetPlayer(group->GetLooterGuid());
+                    if (pLooter)
+                    {
+                        creature->SetLootRecipient(pLooter);   // update creature loot recipient to the allowed looter.
+                        group->SendLooter(creature, pLooter);
+                    }
+                    else
+                        group->SendLooter(creature, NULL);
+                }
+                else
+                    group->SendLooter(creature, NULL);
+
+                group->UpdateLooterGuid(creature);
+            }
+        }
+        else
+        {
+            player->SendDirectMessage(&data);
+
+            if (creature)
+            {
+                WorldPacket data2(SMSG_LOOT_LIST, (8+1+1));
+                data2 << uint64(creature->GetGUID());
+                data2 << uint8(0); // unk1
+                data2 << uint8(0); // no group looter
+                player->SendMessageToSet(&data2, true);
+            }
+        }
+
+        if (creature)
+        {
+            Loot* loot = &creature->loot;
+            if (creature->lootForPickPocketed)
+                creature->lootForPickPocketed = false;
+
+            loot->clear();
+            if (uint32 lootid = creature->GetCreatureInfo()->lootid)
+                loot->FillLoot(lootid, LootTemplates_Creature, pLooter, false, false, creature->GetLootMode());
+
+            loot->generateMoneyLoot(creature->GetCreatureInfo()->mingold,creature->GetCreatureInfo()->maxgold);
+        }
+
+        player->RewardPlayerAndGroupAtKill(pVictim);
+    }
+
+    // Do KILL and KILLED procs. KILL proc is called only for the unit who landed the killing blow (and its owner - for pets and totems) regardless of who tapped the victim
+    if (isPet() || isTotem())
+        if (Unit *owner = GetOwner())
+            owner->ProcDamageAndSpell(pVictim, PROC_FLAG_KILL, PROC_FLAG_NONE, PROC_EX_NONE, 0);
+
+    if (pVictim->GetCreatureType() != CREATURE_TYPE_CRITTER)
+        ProcDamageAndSpell(pVictim, PROC_FLAG_KILL, PROC_FLAG_KILLED, PROC_EX_NONE, 0);
+
+    // Proc auras on death - must be before aura/combat remove
+    pVictim->ProcDamageAndSpell(NULL, PROC_FLAG_DEATH, PROC_FLAG_NONE, PROC_EX_NONE, 0, BASE_ATTACK, 0);
+
+    // if talent known but not triggered (check priest class for speedup check)
+    bool SpiritOfRedemption = false;
+    if (pVictim->GetTypeId() == TYPEID_PLAYER && pVictim->getClass() == CLASS_PRIEST)
+    {
+        AuraEffectList const& vDummyAuras = pVictim->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+        for (AuraEffectList::const_iterator itr = vDummyAuras.begin(); itr != vDummyAuras.end(); ++itr)
+        {
+            if ((*itr)->GetSpellProto()->SpellIconID == 1654)
+            {
+                // save value before aura remove
+                uint32 ressSpellId = pVictim->GetUInt32Value(PLAYER_SELF_RES_SPELL);
+                if (!ressSpellId)
+                    ressSpellId = pVictim->ToPlayer()->GetResurrectionSpellId();
+                //Remove all expected to remove at death auras (most important negative case like DoT or periodic triggers)
+                pVictim->RemoveAllAurasOnDeath();
+                // restore for use at real death
+                pVictim->SetUInt32Value(PLAYER_SELF_RES_SPELL,ressSpellId);
+
+                // FORM_SPIRITOFREDEMPTION and related auras
+                pVictim->CastSpell(pVictim,27827,true,NULL,*itr);
+                SpiritOfRedemption = true;
+                break;
+            }
+        }
+    }
+
+    if (!SpiritOfRedemption)
+    {
+        sLog.outStaticDebug("SET JUST_DIED");
+        pVictim->setDeathState(JUST_DIED);
+    }
+
+    // 10% durability loss on death
+    // clean InHateListOf
+    if (pVictim->GetTypeId() == TYPEID_PLAYER)
+    {
+        // remember victim PvP death for corpse type and corpse reclaim delay
+        // at original death (not at SpiritOfRedemtionTalent timeout)
+        pVictim->ToPlayer()->SetPvPDeath(player != NULL);
+
+        // only if not player and not controlled by player pet. And not at BG
+        if ((durabilityLoss && !player && !pVictim->ToPlayer()->InBattleground()) || (player && sWorld.getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
+        {
+            sLog.outStaticDebug("We are dead, losing %f percent durability", sWorld.getRate(RATE_DURABILITY_LOSS_ON_DEATH));
+            pVictim->ToPlayer()->DurabilityLossAll(sWorld.getRate(RATE_DURABILITY_LOSS_ON_DEATH),false);
+            // durability lost message
+            WorldPacket data(SMSG_DURABILITY_DAMAGE_DEATH, 0);
+            pVictim->ToPlayer()->GetSession()->SendPacket(&data);
+        }
+        // Call KilledUnit for creatures
+        if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->IsAIEnabled)
+            this->ToCreature()->AI()->KilledUnit(pVictim);
+
+        // last damage from non duel opponent or opponent controlled creature
+        if (pVictim->ToPlayer()->duel)
+        {
+            pVictim->ToPlayer()->duel->opponent->CombatStopWithPets(true);
+            pVictim->ToPlayer()->CombatStopWithPets(true);
+            pVictim->ToPlayer()->DuelComplete(DUEL_INTERUPTED);
+        }
+    }
+    else                                                // creature died
+    {
+        sLog.outStaticDebug("DealDamageNotPlayer");
+
+        if (!creature->isPet())
+        {
+            creature->DeleteThreatList();
+            CreatureInfo const* cInfo = creature->GetCreatureInfo();
+            if (cInfo && (cInfo->lootid || cInfo->maxgold > 0))
+                creature->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+        }
+
+        // Call KilledUnit for creatures, this needs to be called after the lootable flag is set
+        if (GetTypeId() == TYPEID_UNIT && this->ToCreature()->IsAIEnabled)
+            this->ToCreature()->AI()->KilledUnit(pVictim);
+
+        // Call creature just died function
+        if (creature->IsAIEnabled)
+            creature->AI()->JustDied(this);
+
+        // Dungeon specific stuff, only applies to players killing creatures
+        if (creature->GetInstanceId())
+        {
+            Map *m = creature->GetMap();
+            Player *creditedPlayer = GetCharmerOrOwnerPlayerOrPlayerItself();
+            // TODO: do instance binding anyway if the charmer/owner is offline
+
+            if (m->IsDungeon() && creditedPlayer)
+            {
+                if (m->IsRaidOrHeroicDungeon())
+                {
+                    if (creature->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
+                        ((InstanceMap *)m)->PermBindAllPlayers(creditedPlayer);
+                }
+                else
+                {
+                    // the reset time is set but not added to the scheduler
+                    // until the players leave the instance
+                    time_t resettime = creature->GetRespawnTimeEx() + 2 * HOUR;
+                    if (InstanceSave *save = sInstanceSaveMgr.GetInstanceSave(creature->GetInstanceId()))
+                        if (save->GetResetTime() < resettime) save->SetResetTime(resettime);
+                }
+            }
+        }
+    }
+
+    // outdoor pvp things, do these after setting the death state, else the player activity notify won't work... doh...
+    // handle player kill only if not suicide (spirit of redemption for example)
+    if (player && this != pVictim)
+        if (OutdoorPvP * pvp = player->GetOutdoorPvP())
+            pvp->HandleKill(player, pVictim);
+
+    //if (pVictim->GetTypeId() == TYPEID_PLAYER)
+    //    if (OutdoorPvP * pvp = pVictim->ToPlayer()->GetOutdoorPvP())
+    //        pvp->HandlePlayerActivityChangedpVictim->ToPlayer();
+
+    // battleground things (do this at the end, so the death state flag will be properly set to handle in the bg->handlekill)
+    if (player && player->InBattleground())
+    {
+        if (Battleground *bg = player->GetBattleground())
+        {
+            if (pVictim->GetTypeId() == TYPEID_PLAYER)
+                bg->HandleKillPlayer((Player*)pVictim, player);
+            else
+                bg->HandleKillUnit(pVictim->ToCreature(), player);
+        }
+    }
+
+    // achievement stuff
+    if (pVictim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (GetTypeId() == TYPEID_UNIT)
+            pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_CREATURE, GetEntry());
+        else if (GetTypeId() == TYPEID_PLAYER && pVictim != this)
+            pVictim->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILLED_BY_PLAYER, 1, this->ToPlayer()->GetTeam());
+    }
+
+    //Hook for OnPVPKill Event
+    if (this->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (pVictim->GetTypeId() == TYPEID_PLAYER)
+        {
+            Player *killer = this->ToPlayer();
+            Player *killed = pVictim->ToPlayer();
+            sScriptMgr.OnPVPKill(killer, killed);
+        }
+        else if (pVictim->GetTypeId() == TYPEID_UNIT)
+        {
+            Player *killer = this->ToPlayer();
+            Creature *killed = pVictim->ToCreature();
+            sScriptMgr.OnCreatureKill(killer, killed);
+        }
+    }
+    else if (this->GetTypeId() == TYPEID_UNIT)
+    {
+        if (pVictim->GetTypeId() == TYPEID_PLAYER)
+        {
+            Creature *killer = this->ToCreature();
+            Player *killed = pVictim->ToPlayer();
+            sScriptMgr.OnPlayerKilledByCreature(killer, killed);
+        }
+    }
+}
+
+void Unit::SetControlled(bool apply, UnitState state)
+{
+    if (apply)
+    {
+        if (hasUnitState(state))
+            return;
+
+        addUnitState(state);
+        switch(state)
+        {
+            case UNIT_STAT_STUNNED:
+                SetStunned(true);
+                CastStop();
+                break;
+            case UNIT_STAT_ROOT:
+                if (!hasUnitState(UNIT_STAT_STUNNED))
+                    SetRooted(true);
+                break;
+            case UNIT_STAT_CONFUSED:
+                if (!hasUnitState(UNIT_STAT_STUNNED))
+                {
+                    SetConfused(true);
+                    CastStop();
+                }
+                break;
+            case UNIT_STAT_FLEEING:
+                if (!hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_CONFUSED))
+                {
+                    SetFeared(true);
+                    CastStop();
+                }
+                break;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        switch(state)
+        {
+            case UNIT_STAT_STUNNED: if (HasAuraType(SPELL_AURA_MOD_STUN))    return;
+                                    else    SetStunned(false);    break;
+            case UNIT_STAT_ROOT:    if (HasAuraType(SPELL_AURA_MOD_ROOT) || GetVehicle())    return;
+                                    else    SetRooted(false);     break;
+            case UNIT_STAT_CONFUSED:if (HasAuraType(SPELL_AURA_MOD_CONFUSE)) return;
+                                    else    SetConfused(false);   break;
+            case UNIT_STAT_FLEEING: if (HasAuraType(SPELL_AURA_MOD_FEAR))    return;
+                                    else    SetFeared(false);     break;
+            default: return;
+        }
+
+        clearUnitState(state);
+
+        if (hasUnitState(UNIT_STAT_STUNNED))
+            SetStunned(true);
+        else
+        {
+            if (hasUnitState(UNIT_STAT_ROOT))
+                SetRooted(true);
+
+            if (hasUnitState(UNIT_STAT_CONFUSED))
+                SetConfused(true);
+            else if (hasUnitState(UNIT_STAT_FLEEING))
+                SetFeared(true);
+        }
+    }
+}
+
+void Unit::SetStunned(bool apply)
+{
+    if (apply)
+    {
+        SetUInt64Value(UNIT_FIELD_TARGET, 0);
+        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+        CastStop();
+//        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
+
+        // Creature specific
+        if (GetTypeId() != TYPEID_PLAYER)
+            this->ToCreature()->StopMoving();
+        else
+            SetStandState(UNIT_STAND_STATE_STAND);
+
+        WorldPacket data(SMSG_FORCE_MOVE_ROOT, 8);
+        data.append(GetPackGUID());
+        data << uint32(0);
+        SendMessageToSet(&data,true);
+    }
+    else
+    {
+        if (isAlive() && getVictim())
+            SetUInt64Value(UNIT_FIELD_TARGET, getVictim()->GetGUID());
+
+        // don't remove UNIT_FLAG_STUNNED for pet when owner is mounted (disabled pet's interface)
+        Unit *pOwner = GetOwner();
+        if (!pOwner || (pOwner->GetTypeId() == TYPEID_PLAYER && !pOwner->ToPlayer()->IsMounted()))
+            RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+
+        if (!hasUnitState(UNIT_STAT_ROOT))         // prevent allow move if have also root effect
+        {
+            WorldPacket data(SMSG_FORCE_MOVE_UNROOT, 8+4);
+            data.append(GetPackGUID());
+            data << uint32(0);
+            SendMessageToSet(&data,true);
+
+//            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
+        }
+    }
+}
+
+void Unit::SetRooted(bool apply)
+{
+    if (apply)
+    {
+        if (m_rootTimes > 0) //blizzard internal check?
+            m_rootTimes++;
+
+//        AddUnitMovementFlag(MOVEMENTFLAG_ROOT);
+
+        WorldPacket data(SMSG_FORCE_MOVE_ROOT, 10);
+        data.append(GetPackGUID());
+        data << m_rootTimes;
+        SendMessageToSet(&data,true);
+
+        if (GetTypeId() != TYPEID_PLAYER)
+            ToCreature()->StopMoving();
+    }
+    else
+    {
+        if (!hasUnitState(UNIT_STAT_STUNNED))      // prevent allow move if have also stun effect
+        {
+            m_rootTimes++; //blizzard internal check?
+
+            WorldPacket data(SMSG_FORCE_MOVE_UNROOT, 10);
+            data.append(GetPackGUID());
+            data << m_rootTimes;
+            SendMessageToSet(&data,true);
+
+//            RemoveUnitMovementFlag(MOVEMENTFLAG_ROOT);
+        }
+    }
+}
+
+void Unit::SetFeared(bool apply)
+{
+    if (apply)
+    {
+        SetUInt64Value(UNIT_FIELD_TARGET, 0);
+
+        Unit *caster = NULL;
+        Unit::AuraEffectList const& fearAuras = GetAuraEffectsByType(SPELL_AURA_MOD_FEAR);
+        if (!fearAuras.empty())
+            caster = ObjectAccessor::GetUnit(*this, fearAuras.front()->GetCasterGUID());
+        if (!caster)
+            caster = getAttackerForHelper();
+        GetMotionMaster()->MoveFleeing(caster, fearAuras.empty() ? sWorld.getIntConfig(CONFIG_CREATURE_FAMILY_FLEE_DELAY) : 0);             // caster == NULL processed in MoveFleeing
+    }
+    else
+    {
+        if (isAlive())
+        {
+            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == FLEEING_MOTION_TYPE)
+                GetMotionMaster()->MovementExpired();
+            if (getVictim())
+                SetUInt64Value(UNIT_FIELD_TARGET, getVictim()->GetGUID());
+        }
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->SetClientControl(this, !apply);
+}
+
+void Unit::SetConfused(bool apply)
+{
+    if (apply)
+    {
+        SetUInt64Value(UNIT_FIELD_TARGET, 0);
+        GetMotionMaster()->MoveConfused();
+    }
+    else
+    {
+        if (isAlive())
+        {
+            if (GetMotionMaster()->GetCurrentMovementGeneratorType() == CONFUSED_MOTION_TYPE)
+                GetMotionMaster()->MovementExpired();
+            if (getVictim())
+                SetUInt64Value(UNIT_FIELD_TARGET, getVictim()->GetGUID());
+        }
+    }
+
+    if (GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->SetClientControl(this, !apply);
+}
+
+bool Unit::SetCharmedBy(Unit* charmer, CharmType type)
+{
+    if (!charmer)
+        return false;
+
+    // unmount players when charmed
+    if (GetTypeId() == TYPEID_PLAYER)
+        Unmount();
+
+    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);
+    ASSERT((type == CHARM_TYPE_VEHICLE) == IsVehicle());
+
+    sLog.outDebug("SetCharmedBy: charmer %u (GUID %u), charmed %u (GUID %u), type %u.", charmer->GetEntry(), charmer->GetGUIDLow(), GetEntry(), GetGUIDLow(), uint32(type));
+
+    if (this == charmer)
+    {
+        sLog.outCrash("Unit::SetCharmedBy: Unit %u (GUID %u) is trying to charm itself!", GetEntry(), GetGUIDLow());
+        return false;
+    }
+
+    //if (hasUnitState(UNIT_STAT_UNATTACKABLE))
+    //    return false;
+
+    if (GetTypeId() == TYPEID_PLAYER && this->ToPlayer()->GetTransport())
+    {
+        sLog.outCrash("Unit::SetCharmedBy: Player on transport is trying to charm %u (GUID %u)", GetEntry(), GetGUIDLow());
+        return false;
+    }
+
+    // Already charmed
+    if (GetCharmerGUID())
+    {
+        sLog.outCrash("Unit::SetCharmedBy: %u (GUID %u) has already been charmed but %u (GUID %u) is trying to charm it!", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());
+        return false;
+    }
+
+    CastStop();
+    CombatStop(); //TODO: CombatStop(true) may cause crash (interrupt spells)
+    DeleteThreatList();
+
+    // Charmer stop charming
+    if (charmer->GetTypeId() == TYPEID_PLAYER)
+    {
+        charmer->ToPlayer()->StopCastingCharm();
+        charmer->ToPlayer()->StopCastingBindSight();
+    }
+
+    // Charmed stop charming
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        this->ToPlayer()->StopCastingCharm();
+        this->ToPlayer()->StopCastingBindSight();
+    }
+
+    // StopCastingCharm may remove a possessed pet?
+    if (!IsInWorld())
+    {
+        sLog.outCrash("Unit::SetCharmedBy: %u (GUID %u) is not in world but %u (GUID %u) is trying to charm it!", GetEntry(), GetGUIDLow(), charmer->GetEntry(), charmer->GetGUIDLow());
+        return false;
+    }
+
+    // Set charmed
+    Map* pMap = GetMap();
+    if (!IsVehicle() || (IsVehicle() && pMap && !pMap->IsBattleground()))
+        setFaction(charmer->getFaction());
+
+    charmer->SetCharm(this, true);
+
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        this->ToCreature()->AI()->OnCharmed(true);
+        GetMotionMaster()->MoveIdle();
+    }
+    else
+    {
+        if (this->ToPlayer()->isAFK())
+            this->ToPlayer()->ToggleAFK();
+        this->ToPlayer()->SetClientControl(this, 0);
+    }
+
+    // Pets already have a properly initialized CharmInfo, don't overwrite it.
+    if (type != CHARM_TYPE_VEHICLE && !GetCharmInfo())
+    {
+        CharmInfo *charmInfo = InitCharmInfo();
+        if (type == CHARM_TYPE_POSSESS)
+            charmInfo->InitPossessCreateSpells();
+        else
+            charmInfo->InitCharmCreateSpells();
+    }
+
+    if (charmer->GetTypeId() == TYPEID_PLAYER)
+    {
+        switch(type)
+        {
+            case CHARM_TYPE_VEHICLE:
+                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+                charmer->ToPlayer()->SetClientControl(this, 1);
+                charmer->ToPlayer()->SetViewpoint(this, true);
+                charmer->ToPlayer()->VehicleSpellInitialize();
+                break;
+            case CHARM_TYPE_POSSESS:
+                addUnitState(UNIT_STAT_POSSESSED);
+                SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+                charmer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                charmer->ToPlayer()->SetClientControl(this, 1);
+                charmer->ToPlayer()->SetViewpoint(this, true);
+                charmer->ToPlayer()->PossessSpellInitialize();
+                break;
+            case CHARM_TYPE_CHARM:
+                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
+                {
+                    CreatureInfo const *cinfo = this->ToCreature()->GetCreatureInfo();
+                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
+                    {
+                        //to prevent client crash
+                        SetByteValue(UNIT_FIELD_BYTES_0, 1, (uint8)CLASS_MAGE);
+
+                        //just to enable stat window
+                        if (GetCharmInfo())
+                            GetCharmInfo()->SetPetNumber(sObjectMgr.GeneratePetNumber(), true);
+
+                        //if charmed two demons the same session, the 2nd gets the 1st one's name
+                        SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped
+                    }
+                }
+                charmer->ToPlayer()->CharmSpellInitialize();
+                break;
+            default:
+            case CHARM_TYPE_CONVERT:
+                break;
+        }
+    }
+    return true;
+}
+
+void Unit::RemoveCharmedBy(Unit *charmer)
+{
+    if (!isCharmed())
+        return;
+
+    if (!charmer)
+        charmer = GetCharmer();
+    if (charmer != GetCharmer()) // one aura overrides another?
+    {
+//        sLog.outCrash("Unit::RemoveCharmedBy: this: " UI64FMTD " true charmer: " UI64FMTD " false charmer: " UI64FMTD,
+//            GetGUID(), GetCharmerGUID(), charmer->GetGUID());
+//        ASSERT(false);
+        return;
+    }
+
+    CharmType type;
+    if (hasUnitState(UNIT_STAT_POSSESSED))
+        type = CHARM_TYPE_POSSESS;
+    else if (charmer->IsOnVehicle(this))
+        type = CHARM_TYPE_VEHICLE;
+    else
+        type = CHARM_TYPE_CHARM;
+
+    CastStop();
+    CombatStop(); //TODO: CombatStop(true) may cause crash (interrupt spells)
+    getHostileRefManager().deleteReferences();
+    DeleteThreatList();
+    Map* pMap = GetMap();
+    if (!IsVehicle() || (IsVehicle() && pMap && !pMap->IsBattleground()))
+        RestoreFaction();
+    GetMotionMaster()->InitDefault();
+
+    if (type == CHARM_TYPE_POSSESS)
+    {
+        clearUnitState(UNIT_STAT_POSSESSED);
+        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+    }
+
+    if (GetTypeId() == TYPEID_UNIT)
+    {
+        this->ToCreature()->AI()->OnCharmed(false);
+
+        if (type != CHARM_TYPE_VEHICLE)//Vehicles' AI is never modified
+        {
+            this->ToCreature()->AIM_Initialize();
+
+            if (this->ToCreature()->AI() && charmer && charmer->isAlive())
+                this->ToCreature()->AI()->AttackStart(charmer);
+        }
+    }
+    else
+        this->ToPlayer()->SetClientControl(this, 1);
+
+    // If charmer still exists
+    if (!charmer)
+        return;
+
+    ASSERT(type != CHARM_TYPE_POSSESS || charmer->GetTypeId() == TYPEID_PLAYER);
+    ASSERT(type != CHARM_TYPE_VEHICLE || (GetTypeId() == TYPEID_UNIT && IsVehicle()));
+
+    charmer->SetCharm(this, false);
+
+    if (charmer->GetTypeId() == TYPEID_PLAYER)
+    {
+        switch(type)
+        {
+            case CHARM_TYPE_VEHICLE:
+                charmer->ToPlayer()->SetClientControl(charmer, 1);
+                charmer->ToPlayer()->SetViewpoint(this, false);
+                break;
+            case CHARM_TYPE_POSSESS:
+                charmer->ToPlayer()->SetClientControl(charmer, 1);
+                charmer->ToPlayer()->SetViewpoint(this, false);
+                charmer->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
+                break;
+            case CHARM_TYPE_CHARM:
+                if (GetTypeId() == TYPEID_UNIT && charmer->getClass() == CLASS_WARLOCK)
+                {
+                    CreatureInfo const *cinfo = this->ToCreature()->GetCreatureInfo();
+                    if (cinfo && cinfo->type == CREATURE_TYPE_DEMON)
+                    {
+                        SetByteValue(UNIT_FIELD_BYTES_0, 1, uint8(cinfo->unit_class));
+                        if (GetCharmInfo())
+                            GetCharmInfo()->SetPetNumber(0, true);
+                        else
+                            sLog.outError("Aura::HandleModCharm: target="UI64FMTD" with typeid=%d has a charm aura but no charm info!", GetGUID(), GetTypeId());
+                    }
+                }
+                break;
+            default:
+            case CHARM_TYPE_CONVERT:
+                break;
+        }
+    }
+
+    //a guardian should always have charminfo
+    if (charmer->GetTypeId() == TYPEID_PLAYER && this != charmer->GetFirstControlled())
+        charmer->ToPlayer()->SendRemoveControlBar();
+    else if (GetTypeId() == TYPEID_PLAYER || (GetTypeId() == TYPEID_UNIT && !this->ToCreature()->isGuardian()))
+        DeleteCharmInfo();
+}
+
+void Unit::RestoreFaction()
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->setFactionForRace(getRace());
+    else
+    {
+        if (HasUnitTypeMask(UNIT_MASK_MINION))
+        {
+            if (Unit* owner = GetOwner())
+            {
+                setFaction(owner->getFaction());
+                return;
+            }
+        }
+
+        if (CreatureInfo const *cinfo = this->ToCreature()->GetCreatureInfo())  // normal creature
+        {
+            FactionTemplateEntry const *faction = getFactionTemplateEntry();
+            setFaction((faction && faction->friendlyMask & 0x004) ? cinfo->faction_H : cinfo->faction_A);
+        }
+    }
+}
+
+bool Unit::CreateVehicleKit(uint32 id)
+{
+    VehicleEntry const *vehInfo = sVehicleStore.LookupEntry(id);
+    if (!vehInfo)
+        return false;
+
+    m_vehicleKit = new Vehicle(this, vehInfo);
+    m_updateFlag |= UPDATEFLAG_VEHICLE;
+    m_unitTypeMask |= UNIT_MASK_VEHICLE;
+    return true;
+}
+
+void Unit::RemoveVehicleKit()
+{
+    if (!m_vehicleKit)
+        return;
+
+    m_vehicleKit->Uninstall();
+    delete m_vehicleKit;
+
+    m_vehicleKit = NULL;
+
+    m_updateFlag &= ~UPDATEFLAG_VEHICLE;
+    m_unitTypeMask &= ~UNIT_MASK_VEHICLE;
+    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
+    RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_PLAYER_VEHICLE);
+}
+
+Unit *Unit::GetVehicleBase() const
+{
+    return m_vehicle ? m_vehicle->GetBase() : NULL;
+}
+
+Creature *Unit::GetVehicleCreatureBase() const
+{
+    if (Unit *veh = GetVehicleBase())
+        if (Creature *c = veh->ToCreature())
+            return c;
+
+    return NULL;
+}
+
+uint64 Unit::GetTransGUID() const
+{
+    if (GetVehicle())
+        return GetVehicle()->GetBase()->GetGUID();
+    if (GetTransport())
+        return GetTransport()->GetGUID();
+
+    return 0;
+}
+
+bool Unit::IsInPartyWith(Unit const *unit) const
+{
+    if (this == unit)
+        return true;
+
+    const Unit *u1 = GetCharmerOrOwnerOrSelf();
+    const Unit *u2 = unit->GetCharmerOrOwnerOrSelf();
+    if (u1 == u2)
+        return true;
+
+    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
+      return u1->ToPlayer()->IsInSameGroupWith(u2->ToPlayer());
+    else
+        return false;
+}
+
+bool Unit::IsInRaidWith(Unit const *unit) const
+{
+    if (this == unit)
+        return true;
+
+    const Unit *u1 = GetCharmerOrOwnerOrSelf();
+    const Unit *u2 = unit->GetCharmerOrOwnerOrSelf();
+    if (u1 == u2)
+        return true;
+
+    if (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_PLAYER)
+      return u1->ToPlayer()->IsInSameRaidWith(u2->ToPlayer());
+    else
+        return false;
+}
+
+void Unit::GetRaidMember(std::list<Unit*> &nearMembers, float radius)
+{
+    Player *owner = GetCharmerOrOwnerPlayerOrPlayerItself();
+    if (!owner)
+        return;
+
+    Group *pGroup = owner->GetGroup();
+    if (pGroup)
+    {
+        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* Target = itr->getSource();
+
+            if (Target && !IsHostileTo(Target))
+            {
+                if (Target->isAlive() && IsWithinDistInMap(Target, radius))
+                    nearMembers.push_back(Target);
+
+                if (Guardian* pet = Target->GetGuardianPet())
+                    if (pet->isAlive() &&  IsWithinDistInMap(pet, radius))
+                        nearMembers.push_back(pet);
+            }
+        }
+    }
+    else
+    {
+        if (owner->isAlive() && (owner == this || IsWithinDistInMap(owner, radius)))
+            nearMembers.push_back(owner);
+        if (Guardian* pet = owner->GetGuardianPet())
+            if (pet->isAlive() && (pet == this && IsWithinDistInMap(pet, radius)))
+                nearMembers.push_back(pet);
+    }
+}
+
+void Unit::GetPartyMemberInDist(std::list<Unit*> &TagUnitMap, float radius)
+{
+    Unit *owner = GetCharmerOrOwnerOrSelf();
+    Group *pGroup = NULL;
+    if (owner->GetTypeId() == TYPEID_PLAYER)
+        pGroup = owner->ToPlayer()->GetGroup();
+
+    if (pGroup)
+    {
+        uint8 subgroup = owner->ToPlayer()->GetSubGroup();
+
+        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* Target = itr->getSource();
+
+            // IsHostileTo check duel and controlled by enemy
+            if (Target && Target->GetSubGroup() == subgroup && !IsHostileTo(Target))
+            {
+                if (Target->isAlive() && IsWithinDistInMap(Target, radius))
+                    TagUnitMap.push_back(Target);
+
+                if (Guardian* pet = Target->GetGuardianPet())
+                    if (pet->isAlive() &&  IsWithinDistInMap(pet, radius))
+                        TagUnitMap.push_back(pet);
+            }
+        }
+    }
+    else
+    {
+        if (owner->isAlive() && (owner == this || IsWithinDistInMap(owner, radius)))
+            TagUnitMap.push_back(owner);
+        if (Guardian* pet = owner->GetGuardianPet())
+            if (pet->isAlive() && (pet == this && IsWithinDistInMap(pet, radius)))
+                TagUnitMap.push_back(pet);
+    }
+}
+
+void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
+{
+    Unit *owner = GetCharmerOrOwnerOrSelf();
+    Group *pGroup = NULL;
+    if (owner->GetTypeId() == TYPEID_PLAYER)
+        pGroup = owner->ToPlayer()->GetGroup();
+
+    if (pGroup)
+    {
+        uint8 subgroup = owner->ToPlayer()->GetSubGroup();
+
+        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* Target = itr->getSource();
+
+            // IsHostileTo check duel and controlled by enemy
+            if (Target && Target->GetSubGroup() == subgroup && !IsHostileTo(Target))
+            {
+                if (Target->isAlive() && IsInMap(Target))
+                    TagUnitMap.push_back(Target);
+
+                if (Guardian* pet = Target->GetGuardianPet())
+                    if (pet->isAlive() && IsInMap(Target))
+                        TagUnitMap.push_back(pet);
+            }
+        }
+    }
+    else
+    {
+        if (owner->isAlive() && (owner == this || IsInMap(owner)))
+            TagUnitMap.push_back(owner);
+        if (Guardian* pet = owner->GetGuardianPet())
+            if (pet->isAlive() && (pet == this || IsInMap(pet)))
+                TagUnitMap.push_back(pet);
+    }
+}
+
+Aura * Unit::AddAura(uint32 spellId, Unit *target)
+{
+    if (!target || !target->isAlive())
+        return NULL;
+
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return NULL;
+
+    return AddAura(spellInfo, MAX_EFFECT_MASK, target);
+}
+
+Aura * Unit::AddAura(SpellEntry const *spellInfo, uint8 effMask, Unit *target)
+{
+    if (!spellInfo)
+        return NULL;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return NULL;
+
+    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (!(effMask & (1<<i)))
+            continue;
+        if (target->IsImmunedToSpellEffect(spellInfo, i))
+            effMask &= ~(1<<i);
+    }
+
+    if (Aura * aura = Aura::TryCreate(spellInfo, effMask, target, this))
+    {
+        aura->ApplyForTargets();
+        return aura;
+    }
+    return NULL;
+}
+
+void Unit::SetAuraStack(uint32 spellId, Unit *target, uint32 stack)
+{
+    Aura *aura = target->GetAura(spellId, GetGUID());
+    if (!aura)
+        aura = AddAura(spellId, target);
+    if (aura && stack)
+        aura->SetStackAmount(stack);
+}
+
+void Unit::ApplyResilience(const Unit *pVictim, float *crit, int32 *damage, bool isCrit, CombatRating type) const
+{
+    if (IsVehicle() || pVictim->IsVehicle())
+        return;
+
+    const Unit *source = ToPlayer();
+    if (!source)
+    {
+        source = ToCreature();
+        if (source)
+        {
+            source = source->ToCreature()->GetOwner();
+            if (source)
+                source = source->ToPlayer();
+        }
+    }
+
+    const Unit *target = pVictim->ToPlayer();
+    if (!target)
+    {
+        target = pVictim->ToCreature();
+        if (target)
+        {
+            target = target->ToCreature()->GetOwner();
+            if (target)
+                target = target->ToPlayer();
+        }
+    }
+
+    if (!target)
+        return;
+
+    switch (type)
+    {
+        case CR_CRIT_TAKEN_MELEE:
+            // Crit chance reduction works against nonpets
+            if (crit)
+                *crit -= target->ToPlayer()->GetMeleeCritChanceReduction();
+            if (source && damage)
+            {
+                if (isCrit)
+                    *damage -= target->ToPlayer()->GetMeleeCritDamageReduction(*damage);
+                *damage -= target->ToPlayer()->GetMeleeDamageReduction(*damage);
+            }
+            break;
+        case CR_CRIT_TAKEN_RANGED:
+            // Crit chance reduction works against nonpets
+            if (crit)
+                *crit -= target->ToPlayer()->GetRangedCritChanceReduction();
+            if (source && damage)
+            {
+                if (isCrit)
+                    *damage -= target->ToPlayer()->GetRangedCritDamageReduction(*damage);
+                *damage -= target->ToPlayer()->GetRangedDamageReduction(*damage);
+            }
+            break;
+        case CR_CRIT_TAKEN_SPELL:
+            // Crit chance reduction works against nonpets
+            if (crit)
+                *crit -= target->ToPlayer()->GetSpellCritChanceReduction();
+            if (source && damage)
+            {
+                if (isCrit)
+                    *damage -= target->ToPlayer()->GetSpellCritDamageReduction(*damage);
+                *damage -= target->ToPlayer()->GetSpellDamageReduction(*damage);
+            }
+            break;
+        default:
+            break;
+    }
+}
+
+// Melee based spells can be miss, parry or dodge on this step
+// Crit or block - determined on damage calculation phase! (and can be both in some time)
+float Unit::MeleeSpellMissChance(const Unit *pVictim, WeaponAttackType attType, int32 skillDiff, uint32 spellId) const
+{
+    // Calculate hit chance (more correct for chance mod)
+    int32 HitChance;
+
+    // PvP - PvE melee chances
+    if (spellId || attType == RANGED_ATTACK || !haveOffhandWeapon())
+        HitChance = 95;
+    else
+        HitChance = 76;
+
+    // Hit chance depends from victim auras
+    if (attType == RANGED_ATTACK)
+        HitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_RANGED_HIT_CHANCE);
+    else
+        HitChance += pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
+
+    // Spellmod from SPELLMOD_RESIST_MISS_CHANCE
+    if (spellId)
+    {
+        if (Player *modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_MISS_CHANCE, HitChance);
+    }
+
+    // Miss = 100 - hit
+    float miss_chance = 100.0f - HitChance;
+
+    // Bonuses from attacker aura and ratings
+    if (attType == RANGED_ATTACK)
+        miss_chance -= m_modRangedHitChance;
+    else
+        miss_chance -= m_modMeleeHitChance;
+
+    // bonus from skills is 0.04%
+    //miss_chance -= skillDiff * 0.04f;
+    int32 diff = -skillDiff;
+    if (pVictim->GetTypeId() == TYPEID_PLAYER)
+        miss_chance += diff > 0 ? diff * 0.04f : diff * 0.02f;
+    else
+        miss_chance += diff > 10 ? 2 + (diff - 10) * 0.4f : diff * 0.1f;
+
+    // Limit miss chance from 0 to 60%
+    if (miss_chance < 0.0f)
+        return 0.0f;
+    if (miss_chance > 60.0f)
+        return 60.0f;
+    return miss_chance;
+}
+
+void Unit::SetPhaseMask(uint32 newPhaseMask, bool update)
+{
+    if (newPhaseMask == GetPhaseMask())
+        return;
+
+    if (IsInWorld())
+        RemoveNotOwnSingleTargetAuras(newPhaseMask);        // we can lost access to caster or target
+
+    WorldObject::SetPhaseMask(newPhaseMask,update);
+
+    if (!IsInWorld())
+        return;
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->GetTypeId() == TYPEID_UNIT)
+            (*itr)->SetPhaseMask(newPhaseMask,true);
+
+    for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        if (m_SummonSlot[i])
+            if (Creature *summon = GetMap()->GetCreature(m_SummonSlot[i]))
+                summon->SetPhaseMask(newPhaseMask,true);
+}
+
+void Unit::UpdateObjectVisibility(bool forced)
+{
+    if (!forced)
+        AddToNotify(NOTIFY_VISIBILITY_CHANGED);
+    else
+    {
+        WorldObject::UpdateObjectVisibility(true);
+        // call MoveInLineOfSight for nearby creatures
+        Trinity::AIRelocationNotifier notifier(*this);
+        VisitNearbyObject(GetMap()->GetVisibilityDistance(), notifier);
+    }
+}
+
+void Unit::KnockbackFrom(float x, float y, float speedXY, float speedZ)
+{
+    Player *player = NULL;
+    if (GetTypeId() == TYPEID_PLAYER)
+        player = (Player*)this;
+    else
+    {
+        player = dynamic_cast<Player*>(GetCharmer());
+        if (player && player->m_mover != this)
+            player = NULL;
+    }
+
+    if (!player)
+    {
+        GetMotionMaster()->MoveKnockbackFrom(x, y, speedXY, speedZ);
+    }
+    else
+    {
+        float vcos, vsin;
+        GetSinCos(x, y, vsin, vcos);
+
+        WorldPacket data(SMSG_MOVE_KNOCK_BACK, (8+4+4+4+4+4));
+        data.append(GetPackGUID());
+        data << uint32(0);                                      // Sequence
+        data << float(vcos);                                    // x direction
+        data << float(vsin);                                    // y direction
+        data << float(speedXY);                                 // Horizontal speed
+        data << float(-speedZ);                                 // Z Movement speed (vertical)
+
+        player->GetSession()->SendPacket(&data);
+    }
+}
+
+float Unit::GetCombatRatingReduction(CombatRating cr) const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        return ((Player const*)this)->GetRatingBonusValue(cr);
+    else if (((Creature const*)this)->isPet())
+    {
+        // Player's pet get resilience from owner
+        if (Unit* owner = GetOwner())
+            if (owner->GetTypeId() == TYPEID_PLAYER)
+                return ((Player*)owner)->GetRatingBonusValue(cr);
+    }
+
+    return 0.0f;
+}
+
+uint32 Unit::GetCombatRatingDamageReduction(CombatRating cr, float rate, float cap, uint32 damage) const
+{
+    float percent = GetCombatRatingReduction(cr) * rate;
+    if (percent > cap)
+        percent = cap;
+    return uint32 (percent * damage / 100.0f);
+}
+
+uint32 Unit::GetModelForForm(ShapeshiftForm form)
+{
+    switch(form)
+    {
+        case FORM_CAT:
+            // Based on Hair color
+            if (getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                    case 7: // Violet
+                    case 8:
+                        return 29405;
+                    case 3: // Light Blue
+                        return 29406;
+                    case 0: // Green
+                    case 1: // Light Green
+                    case 2: // Dark Green
+                        return 29407;
+                    case 4: // White
+                        return 29408;
+                    default: // original - Dark Blue
+                        return 892;
+                }
+            }
+            // Based on Skin color
+            else if (getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                // Male
+                if (getGender() == GENDER_MALE)
+                {
+                    switch(skinColor)
+                    {
+                        case 12: // White
+                        case 13:
+                        case 14:
+                        case 18: // Completly White
+                            return 29409;
+                        case 9: // Light Brown
+                        case 10:
+                        case 11:
+                            return 29410;
+                        case 6: // Brown
+                        case 7:
+                        case 8:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3: // Dark Grey
+                        case 4:
+                        case 5:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                // Female
+                else switch (skinColor)
+                {
+                    case 10: // White
+                        return 29409;
+                    case 6: // Light Brown
+                    case 7:
+                        return 29410;
+                    case 4: // Brown
+                    case 5:
+                        return 29411;
+                    case 0: // Dark
+                    case 1:
+                    case 2:
+                    case 3:
+                        return 29412;
+                    default: // original - Grey
+                        return 8571;
+                }
+            }
+            else if (Player::TeamForRace(getRace()) == ALLIANCE)
+                return 892;
+            else
+                return 8571;
+        case FORM_DIREBEAR:
+        case FORM_BEAR:
+            // Based on Hair color
+            if (getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                    case 0: // Green
+                    case 1: // Light Green
+                    case 2: // Dark Green
+                        return 29413; // 29415?
+                    case 6: // Dark Blue
+                        return 29414;
+                    case 4: // White
+                        return 29416;
+                    case 3: // Light Blue
+                        return 29417;
+                    default: // original - Violet
+                        return 2281;
+                }
+            }
+            // Based on Skin color
+            else if (getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = GetByteValue(PLAYER_BYTES, 0);
+                // Male
+                if (getGender() == GENDER_MALE)
+                {
+                    switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                        case 2:
+                            return 29418;
+                        case 3: // White
+                        case 4:
+                        case 5:
+                        case 12:
+                        case 13:
+                        case 14:
+                            return 29419;
+                        case 9: // Light Brown/Grey
+                        case 10:
+                        case 11:
+                        case 15:
+                        case 16:
+                        case 17:
+                            return 29420;
+                        case 18: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                // Female
+                else switch (skinColor)
+                {
+                    case 0: // Dark (Black)
+                    case 1:
+                        return 29418;
+                    case 2: // White
+                    case 3:
+                        return 29419;
+                    case 6: // Light Brown/Grey
+                    case 7:
+                    case 8:
+                    case 9:
+                        return 29420;
+                    case 10: // Completly White
+                        return 29421;
+                    default: // original - Brown
+                        return 2289;
+                }
+            }
+            else if (Player::TeamForRace(getRace()) == ALLIANCE)
+                return 2281;
+            else
+                return 2289;
+        case FORM_TRAVEL:
+            return 632;
+        case FORM_AQUA:
+            if (Player::TeamForRace(getRace()) == ALLIANCE)
+                return 2428;
+            else
+                return 2428;
+        case FORM_GHOUL:
+            return 24994;
+        case FORM_CREATUREBEAR:
+            return 902;
+        case FORM_GHOSTWOLF:
+            return 4613;
+        case FORM_FLIGHT:
+            if (Player::TeamForRace(getRace()) == ALLIANCE)
+                return 20857;
+            else
+                return 20872;
+        case FORM_MOONKIN:
+            if (Player::TeamForRace(getRace()) == ALLIANCE)
+                return 15374;
+            else
+                return 15375;
+        case FORM_FLIGHT_EPIC:
+            if (Player::TeamForRace(getRace()) == ALLIANCE)
+                return 21243;
+            else
+                return 21244;
+        case FORM_METAMORPHOSIS:
+            return 25277;
+        case FORM_MASTER_ANGLER:
+            return 15234;
+        case FORM_TREE:
+            return 864;
+        case FORM_SPIRITOFREDEMPTION:
+            return 16031;
+        default:
+            break;
+    }
+    return 0;
+}
+
+uint32 Unit::GetModelForTotem(PlayerTotemType totemType)
+{
+    switch(getRace())
+    {
+        case RACE_ORC:
+        {
+            switch(totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    //fire
+                    return 30758;
+                case SUMMON_TYPE_TOTEM_EARTH:   //earth
+                    return 30757;
+                case SUMMON_TYPE_TOTEM_WATER:   //water
+                    return 30759;
+                case SUMMON_TYPE_TOTEM_AIR:     //air
+                    return 30756;
+            }
+            break;
+        }
+        case RACE_DWARF:
+        {
+            switch(totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    //fire
+                    return 30754;
+                case SUMMON_TYPE_TOTEM_EARTH:   //earth
+                    return 30753;
+                case SUMMON_TYPE_TOTEM_WATER:   //water
+                    return 30755;
+                case SUMMON_TYPE_TOTEM_AIR:     //air
+                    return 30736;
+            }
+            break;
+        }
+        case RACE_TROLL:
+        {
+            switch(totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    //fire
+                    return 30762;
+                case SUMMON_TYPE_TOTEM_EARTH:   //earth
+                    return 30761;
+                case SUMMON_TYPE_TOTEM_WATER:   //water
+                    return 30763;
+                case SUMMON_TYPE_TOTEM_AIR:     //air
+                    return 30760;
+            }
+            break;
+        }
+        case RACE_TAUREN:
+        {
+            switch(totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    //fire
+                    return 4589;
+                case SUMMON_TYPE_TOTEM_EARTH:   //earth
+                    return 4588;
+                case SUMMON_TYPE_TOTEM_WATER:   //water
+                    return 4587;
+                case SUMMON_TYPE_TOTEM_AIR:     //air
+                    return 4590;
+            }
+            break;
+        }
+        case RACE_DRAENEI:
+        {
+            switch(totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    //fire
+                    return 19074;
+                case SUMMON_TYPE_TOTEM_EARTH:   //earth
+                    return 19073;
+                case SUMMON_TYPE_TOTEM_WATER:   //water
+                    return 19075;
+                case SUMMON_TYPE_TOTEM_AIR:     //air
+                    return 19071;
+            }
+            break;
+        }
+    }
+    return 0;
+}
+
+void Unit::JumpTo(float speedXY, float speedZ, bool forward)
+{
+    float angle = forward ? 0 : M_PI;
+    if (GetTypeId() == TYPEID_UNIT)
+        GetMotionMaster()->MoveJumpTo(angle, speedXY, speedZ);
+    else
+    {
+        float vcos = cos(angle+GetOrientation());
+        float vsin = sin(angle+GetOrientation());
+
+        WorldPacket data(SMSG_MOVE_KNOCK_BACK, (8+4+4+4+4+4));
+        data.append(GetPackGUID());
+        data << uint32(0);                                      // Sequence
+        data << float(vcos);                                    // x direction
+        data << float(vsin);                                    // y direction
+        data << float(speedXY);                                 // Horizontal speed
+        data << float(-speedZ);                                 // Z Movement speed (vertical)
+
+        this->ToPlayer()->GetSession()->SendPacket(&data);
+    }
+}
+
+void Unit::JumpTo(WorldObject *obj, float speedZ)
+{
+    float x, y, z;
+    obj->GetContactPoint(this, x, y, z);
+    float speedXY = GetExactDist2d(x, y) * 10.0f / speedZ;
+    GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+}
+
+bool Unit::CheckPlayerCondition(Player* pPlayer)
+{
+    switch(GetEntry())
+    {
+            case 35644: //Argent Warhorse
+            case 36558: //Argent Battleworg
+                if (!pPlayer->HasItemOrGemWithIdEquipped(46106,1)) //Check item Argent Lance
+                    return false;
+            default:
+                return true;
+    }
+}
+
+void Unit::EnterVehicle(Vehicle *vehicle, int8 seatId)
+{
+    if (!isAlive() || GetVehicleKit() == vehicle)
+        return;
+
+    if (m_vehicle)
+    {
+        if (m_vehicle == vehicle)
+        {
+            if (seatId >= 0)
+            {
+                sLog.outDebug("EnterVehicle: %u leave vehicle %u seat %d and enter %d.", GetEntry(), m_vehicle->GetBase()->GetEntry(), GetTransSeat(), seatId);
+                ChangeSeat(seatId);
+            }
+            return;
+        }
+        else
+        {
+            sLog.outDebug("EnterVehicle: %u exit %u and enter %u.", GetEntry(), m_vehicle->GetBase()->GetEntry(), vehicle->GetBase()->GetEntry());
+            ExitVehicle();
+        }
+    }
+
+    if (Player* plr = ToPlayer())
+    {
+        if (vehicle->GetBase()->GetTypeId() == TYPEID_PLAYER && plr->isInCombat())
+            return;
+
+        InterruptNonMeleeSpells(false);
+        plr->StopCastingCharm();
+        plr->StopCastingBindSight();
+        Unmount();
+        RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+        // drop flag at invisible in bg
+        if (Battleground *bg = plr->GetBattleground())
+            bg->EventPlayerDroppedFlag(plr);
+    }
+
+    ASSERT(!m_vehicle);
+    m_vehicle = vehicle;
+    if (!m_vehicle->AddPassenger(this, seatId))
+    {
+        m_vehicle = NULL;
+        return;
+    }
+
+    SetControlled(true, UNIT_STAT_ROOT);
+    //movementInfo is set in AddPassenger
+    //packets are sent in AddPassenger
+
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        //this->ToPlayer()->SetClientControl(vehicle, 1);
+        WorldPacket data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
+        this->ToPlayer()->GetSession()->SendPacket(&data);
+    }
+}
+
+void Unit::ChangeSeat(int8 seatId, bool next)
+{
+    if (!m_vehicle)
+        return;
+
+    if (seatId < 0)
+    {
+        seatId = m_vehicle->GetNextEmptySeat(GetTransSeat(), next);
+        if (seatId < 0)
+            return;
+    }
+    else if (seatId == GetTransSeat() || !m_vehicle->HasEmptySeat(seatId))
+        return;
+
+    m_vehicle->RemovePassenger(this);
+    if (!m_vehicle->AddPassenger(this, seatId))
+        ASSERT(false);
+}
+
+void Unit::ExitVehicle()
+{
+    if (!m_vehicle)
+        return;
+
+    Unit *vehicleBase = m_vehicle->GetBase();
+    const AuraEffectList &modAuras = vehicleBase->GetAuraEffectsByType(SPELL_AURA_CONTROL_VEHICLE);
+    for (AuraEffectList::const_iterator itr = modAuras.begin(); itr != modAuras.end(); ++itr)
+    {
+        if ((*itr)->GetBase()->GetOwner() == this)
+        {
+            vehicleBase->RemoveAura((*itr)->GetBase());
+            break; // there should be no case that a vehicle has two auras for one owner
+        }
+    }
+
+    if (!m_vehicle)
+        return;
+
+    //sLog.outError("exit vehicle");
+
+    m_vehicle->RemovePassenger(this);
+
+    // This should be done before dismiss, because there may be some aura removal
+    Vehicle *vehicle = m_vehicle;
+    m_vehicle = NULL;
+
+    SetControlled(false, UNIT_STAT_ROOT);
+
+    RemoveUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT);
+    m_movementInfo.t_pos.Relocate(0, 0, 0, 0);
+    m_movementInfo.t_time = 0;
+    m_movementInfo.t_seat = 0;
+
+    Relocate(vehicle->GetBase());
+
+    //Send leave vehicle, not correct
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        //this->ToPlayer()->SetClientControl(this, 1);
+        this->ToPlayer()->SendTeleportAckPacket();
+        this->ToPlayer()->SetFallInformation(0, GetPositionZ());
+    }
+    WorldPacket data;
+    BuildHeartBeatMsg(&data);
+    SendMessageToSet(&data, false);
+
+    if (vehicle->GetBase()->HasUnitTypeMask(UNIT_MASK_MINION))
+        if (((Minion*)vehicle->GetBase())->GetOwner() == this)
+            vehicle->Dismiss();
+}
+
+void Unit::BuildMovementPacket(ByteBuffer *data) const
+{
+    switch (GetTypeId())
+    {
+        case TYPEID_UNIT:
+            if (canFly())
+                const_cast<Unit*>(this)->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
+            break;
+        case TYPEID_PLAYER:
+            // remove unknown, unused etc flags for now
+            const_cast<Unit*>(this)->RemoveUnitMovementFlag(MOVEMENTFLAG_SPLINE_ENABLED);
+            if (isInFlight())
+            {
+                WPAssert(const_cast<Unit*>(this)->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE);
+                const_cast<Unit*>(this)->AddUnitMovementFlag(MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_SPLINE_ENABLED);
+            }
+            break;
+        default:
+            break;
+    }
+
+    *data << uint32(GetUnitMovementFlags()); // movement flags
+    *data << uint16(m_movementInfo.flags2);    // 2.3.0
+    *data << uint32(getMSTime());            // time
+    *data << GetPositionX();
+    *data << GetPositionY();
+    *data << GetPositionZ();
+    *data << GetOrientation();
+
+    // 0x00000200
+    if (GetUnitMovementFlags() & MOVEMENTFLAG_ONTRANSPORT)
+    {
+        if (m_vehicle)
+            data->append(m_vehicle->GetBase()->GetPackGUID());
+        else if (GetTransport())
+            data->append(GetTransport()->GetPackGUID());
+        else
+        {
+            sLog.outError("Unit %u does not have transport!", GetEntry());
+            *data << (uint8)0;
+        }
+        *data << float (GetTransOffsetX());
+        *data << float (GetTransOffsetY());
+        *data << float (GetTransOffsetZ());
+        *data << float (GetTransOffsetO());
+        *data << uint32(GetTransTime());
+        *data << uint8 (GetTransSeat());
+    }
+
+    // 0x02200000
+    if ((GetUnitMovementFlags() & (MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_FLYING))
+        || (m_movementInfo.flags2 & MOVEMENTFLAG2_ALWAYS_ALLOW_PITCHING))
+        *data << (float)m_movementInfo.pitch;
+
+    *data << (uint32)m_movementInfo.fallTime;
+
+    // 0x00001000
+    if (GetUnitMovementFlags() & MOVEMENTFLAG_JUMPING)
+    {
+        *data << (float)m_movementInfo.j_zspeed;
+        *data << (float)m_movementInfo.j_sinAngle;
+        *data << (float)m_movementInfo.j_cosAngle;
+        *data << (float)m_movementInfo.j_xyspeed;
+    }
+
+    // 0x04000000
+    if (GetUnitMovementFlags() & MOVEMENTFLAG_SPLINE_ELEVATION)
+        *data << (float)m_movementInfo.splineElevation;
+}
+
+void Unit::SetFlying(bool apply)
+{
+    if (apply)
+    {
+        SetByteFlag(UNIT_FIELD_BYTES_1, 3, 0x02);
+        AddUnitMovementFlag(MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING);
+    }
+    else
+    {
+        RemoveByteFlag(UNIT_FIELD_BYTES_1, 3, 0x02);
+        RemoveUnitMovementFlag(MOVEMENTFLAG_CAN_FLY | MOVEMENTFLAG_FLYING);
+    }
+}
+
+void Unit::NearTeleportTo(float x, float y, float z, float orientation, bool casting /*= false*/)
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+        this->ToPlayer()->TeleportTo(GetMapId(), x, y, z, orientation, TELE_TO_NOT_LEAVE_TRANSPORT | TELE_TO_NOT_LEAVE_COMBAT | TELE_TO_NOT_UNSUMMON_PET | (casting ? TELE_TO_SPELL : 0));
+    else
+    {
+        // FIXME: this interrupts spell visual
+        DestroyForNearbyPlayers();
+        SetPosition(x, y, z, orientation, true);
+    }
+}
+
+bool Unit::SetPosition(float x, float y, float z, float orientation, bool teleport)
+{
+    // prevent crash when a bad coord is sent by the client
+    if (!Trinity::IsValidMapCoord(x,y,z,orientation))
+    {
+        sLog.outDebug("Unit::SetPosition(%f, %f, %f) .. bad coordinates!",x,y,z);
+        return false;
+    }
+
+    bool turn = (GetOrientation() != orientation);
+    bool relocated = (teleport || GetPositionX() != x || GetPositionY() != y || GetPositionZ() != z);
+
+    if (turn)
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
+
+    if (relocated)
+    {
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
+
+        // move and update visible state if need
+        if (GetTypeId() == TYPEID_PLAYER)
+            GetMap()->PlayerRelocation((Player*)this, x, y, z, orientation);
+        else
+            GetMap()->CreatureRelocation(this->ToCreature(), x, y, z, orientation);
+    }
+    else if (turn)
+        SetOrientation(orientation);
+
+    if ((relocated || turn) && IsVehicle())
+        GetVehicleKit()->RelocatePassengers(x,y,z,orientation);
+
+    return (relocated || turn);
+}
+
+void Unit::SendThreatListUpdate()
+{
+    if (uint32 count = getThreatManager().getThreatList().size())
+    {
+        //sLog.outDebug("WORLD: Send SMSG_THREAT_UPDATE Message");
+        WorldPacket data(SMSG_THREAT_UPDATE, 8 + count * 8);
+        data.append(GetPackGUID());
+        data << uint32(count);
+        std::list<HostileReference*>& tlist = getThreatManager().getThreatList();
+        for (std::list<HostileReference*>::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)
+        {
+            data.appendPackGUID((*itr)->getUnitGuid());
+            data << uint32((*itr)->getThreat());
+        }
+        SendMessageToSet(&data, false);
+    }
+}
+
+void Unit::SendChangeCurrentVictimOpcode(HostileReference* pHostileReference)
+{
+    if (uint32 count = getThreatManager().getThreatList().size())
+    {
+        sLog.outDebug("WORLD: Send SMSG_HIGHEST_THREAT_UPDATE Message");
+        WorldPacket data(SMSG_HIGHEST_THREAT_UPDATE, 8 + 8 + count * 8);
+        data.append(GetPackGUID());
+        data.appendPackGUID(pHostileReference->getUnitGuid());
+        data << uint32(count);
+        std::list<HostileReference*>& tlist = getThreatManager().getThreatList();
+        for (std::list<HostileReference*>::const_iterator itr = tlist.begin(); itr != tlist.end(); ++itr)
+        {
+            data.appendPackGUID((*itr)->getUnitGuid());
+            data << uint32((*itr)->getThreat());
+        }
+        SendMessageToSet(&data, false);
+    }
+}
+
+void Unit::SendClearThreatListOpcode()
+{
+    sLog.outDebug("WORLD: Send SMSG_THREAT_CLEAR Message");
+    WorldPacket data(SMSG_THREAT_CLEAR, 8);
+    data.append(GetPackGUID());
+    SendMessageToSet(&data, false);
+}
+
+void Unit::SendRemoveFromThreatListOpcode(HostileReference* pHostileReference)
+{
+    sLog.outDebug("WORLD: Send SMSG_THREAT_REMOVE Message");
+    WorldPacket data(SMSG_THREAT_REMOVE, 8 + 8);
+    data.append(GetPackGUID());
+    data.appendPackGUID(pHostileReference->getUnitGuid());
+    SendMessageToSet(&data, false);
+}
+
+void Unit::RewardRage(uint32 damage, uint32 weaponSpeedHitFactor, bool attacker)
+{
+    float addRage;
+
+    float rageconversion = ((0.0091107836f * getLevel()*getLevel())+3.225598133f*getLevel())+4.2652911f;
+
+    // Unknown if correct, but lineary adjust rage conversion above level 70
+    if (getLevel() > 70)
+        rageconversion += 13.27f*(getLevel()-70);
+
+    if (attacker)
+    {
+        addRage = ((damage/rageconversion*7.5f + weaponSpeedHitFactor)/2);
+
+        // talent who gave more rage on attack
+        addRage *= 1.0f + GetTotalAuraModifier(SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT) / 100.0f;
+    }
+    else
+    {
+        addRage = damage/rageconversion*2.5f;
+
+        // Berserker Rage effect
+        if (HasAura(18499))
+            addRage *= 2.0f;
+    }
+
+    addRage *= sWorld.getRate(RATE_POWER_RAGE_INCOME);
+
+    ModifyPower(POWER_RAGE, uint32(addRage*10));
+}
+
+void Unit::StopAttackFaction(uint32 faction_id)
+{
+    if (Unit* victim = getVictim())
+    {
+        if (victim->getFactionTemplateEntry()->faction == faction_id)
+        {
+            AttackStop();
+            if (IsNonMeleeSpellCasted(false))
+                InterruptNonMeleeSpells(false);
+
+            // melee and ranged forced attack cancel
+            if (GetTypeId() == TYPEID_PLAYER)
+                this->ToPlayer()->SendAttackSwingCancelAttack();
+        }
+    }
+
+    AttackerSet const& attackers = getAttackers();
+    for (AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
+    {
+        if ((*itr)->getFactionTemplateEntry()->faction == faction_id)
+        {
+            (*itr)->AttackStop();
+            itr = attackers.begin();
+        }
+        else
+            ++itr;
+    }
+
+    getHostileRefManager().deleteReferencesForFaction(faction_id);
+
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+            (*itr)->StopAttackFaction(faction_id);
+}
+
+void Unit::OutDebugInfo() const
+{
+    sLog.outError("Unit::OutDebugInfo");
+    sLog.outString("GUID "UI64FMTD", entry %u, type %u, name %s", GetGUID(), GetEntry(), (uint32)GetTypeId(), GetName());
+    sLog.outString("OwnerGUID "UI64FMTD", MinionGUID "UI64FMTD", CharmerGUID "UI64FMTD", CharmedGUID "UI64FMTD, GetOwnerGUID(), GetMinionGUID(), GetCharmerGUID(), GetCharmGUID());
+    sLog.outString("In world %u, unit type mask %u", (uint32)(IsInWorld() ? 1 : 0), m_unitTypeMask);
+    if (IsInWorld())
+        sLog.outString("Mapid %u", GetMapId());
+
+    sLog.outStringInLine("Summon Slot: ");
+    for (uint32 i = 0; i < MAX_SUMMON_SLOT; ++i)
+        sLog.outStringInLine(UI64FMTD", ", m_SummonSlot[i]);
+    sLog.outString();
+
+    sLog.outStringInLine("Controlled List: ");
+    for (ControlList::const_iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        sLog.outStringInLine(UI64FMTD", ", (*itr)->GetGUID());
+    sLog.outString();
+
+    sLog.outStringInLine("Aura List: ");
+    for (AuraApplicationMap::const_iterator itr = m_appliedAuras.begin(); itr != m_appliedAuras.end(); ++itr)
+        sLog.outStringInLine("%u, ", itr->first);
+    sLog.outString();
+
+    if (IsVehicle())
+    {
+        sLog.outStringInLine("Passenger List: ");
+        for (SeatMap::iterator itr = GetVehicleKit()->m_Seats.begin(); itr != GetVehicleKit()->m_Seats.end(); ++itr)
+            if (Unit *passenger = itr->second.passenger)
+                sLog.outStringInLine(UI64FMTD", ", passenger->GetGUID());
+        sLog.outString();
+    }
+
+    if (GetVehicle())
+        sLog.outString("On vehicle %u.", GetVehicleBase()->GetEntry());
+}
+
+uint32 Unit::GetRemainingDotDamage(uint64 caster, uint32 spellId, uint8 effectIndex) const
+{
+    uint32 amount = 0;
+    AuraEffectList const& DoTAuras = GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
+    for (AuraEffectList::const_iterator i = DoTAuras.begin(); i != DoTAuras.end(); ++i)
+    {
+        if ((*i)->GetCasterGUID() != caster || (*i)->GetId() != spellId || (*i)->GetEffIndex() != effectIndex)
+            continue;
+        amount += ((*i)->GetAmount() * ((*i)->GetTotalTicks() - ((*i)->GetTickNumber()))) / (*i)->GetTotalTicks();
+        break;
+    }
+
+    return amount;
+}
+
+void CharmInfo::SetIsCommandAttack(bool val)
+{
+    m_isCommandAttack = val;
+}
+
+bool CharmInfo::IsCommandAttack()
+{
+    return m_isCommandAttack;
+}
+
+void CharmInfo::SaveStayPosition()
+{
+    m_unit->GetPosition(m_stayX, m_stayY, m_stayZ);
+}
+
+void CharmInfo::GetStayPosition(float &x, float &y, float &z)
+{
+    x = m_stayX;
+    y = m_stayY;
+    z = m_stayZ;
+}
+
+void CharmInfo::SetIsAtStay(bool val)
+{
+    m_isAtStay = val;
+}
+
+bool CharmInfo::IsAtStay()
+{
+    return m_isAtStay;
+}
+
+void CharmInfo::SetIsFollowing(bool val)
+{
+    m_isFollowing = val;
+}
+
+bool CharmInfo::IsFollowing()
+{
+    return m_isFollowing;
+}
+
+void CharmInfo::SetIsReturning(bool val)
+{
+    m_isReturning = val;
+}
+
+bool CharmInfo::IsReturning()
+{
+    return m_isReturning;
+}
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -464,8 +464,8 @@
 void AddSC_boss_lord_marrowgar();
 void AddSC_boss_lady_deathwhisper();
 void AddSC_boss_festergut();
-void AddSC_boss_deathbringer_saurfang();
-void AddSC_boss_blood_queen_lanathel();
+void AddSC_boss_saurfang();
+void AddSC_boss_blood_queen_lana_thel();
 void AddSC_boss_gunship_battle();
 void AddSC_boss_baltharus();	//RubySanctum
 void AddSC_boss_halion();
@@ -1147,8 +1147,8 @@
     AddSC_boss_lord_marrowgar();
     AddSC_boss_lady_deathwhisper();
     AddSC_boss_festergut();
-    AddSC_boss_deathbringer_saurfang();
-    AddSC_boss_blood_queen_lanathel();
+    AddSC_boss_saurfang();
+    AddSC_boss_blood_queen_lana_thel();
 	AddSC_boss_gunship_battle();
 	AddSC_boss_baltharus();	//RubySanctum
     AddSC_boss_halion();
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -1839,6 +1839,8 @@
                 target->CastSpell((Unit*)NULL , GetAmount() , true);
             break;
         case SPELL_AURA_PERIODIC_DUMMY:
+			if(GetId() == 72178)
+                caster->CastSpell(caster, 72202, true);
             PeriodicDummyTick(target, caster);
             break;
         case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -1,2738 +1,2738 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "WorldPacket.h"
-#include "WorldSession.h"
-#include "GridNotifiers.h"
-#include "GridNotifiersImpl.h"
-#include "Opcodes.h"
-#include "Log.h"
-#include "UpdateMask.h"
-#include "World.h"
-#include "ObjectMgr.h"
-#include "SpellMgr.h"
-#include "Player.h"
-#include "Pet.h"
-#include "Unit.h"
-#include "Totem.h"
-#include "Spell.h"
-#include "DynamicObject.h"
-#include "Group.h"
-#include "UpdateData.h"
-#include "MapManager.h"
-#include "ObjectAccessor.h"
-#include "CellImpl.h"
-#include "SharedDefines.h"
-#include "LootMgr.h"
-#include "VMapFactory.h"
-#include "Battleground.h"
-#include "Util.h"
-#include "TemporarySummon.h"
-#include "Vehicle.h"
-#include "SpellAuraEffects.h"
-#include "ScriptMgr.h"
-#include "ConditionMgr.h"
-#include "DisableMgr.h"
-#include "SpellScript.h"
-#include "OutdoorPvPWG.h"
-#include "OutdoorPvPMgr.h"
-
-#define SPELL_CHANNEL_UPDATE_INTERVAL (1 * IN_MILLISECONDS)
-
-extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
-
-bool IsQuestTameSpell(uint32 spellId)
-{
-    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
-    if (!spellproto) return false;
-
-    return spellproto->Effect[0] == SPELL_EFFECT_THREAT
-        && spellproto->Effect[1] == SPELL_EFFECT_APPLY_AURA && spellproto->EffectApplyAuraName[1] == SPELL_AURA_DUMMY;
-}
-
-SpellCastTargets::SpellCastTargets() : m_elevation(0), m_speed(0)
-{
-    m_unitTarget = NULL;
-    m_itemTarget = NULL;
-    m_GOTarget   = NULL;
-
-    m_unitTargetGUID   = 0;
-    m_GOTargetGUID     = 0;
-    m_CorpseTargetGUID = 0;
-    m_itemTargetGUID   = 0;
-    m_itemTargetEntry  = 0;
-
-    m_srcTransGUID = 0;
-    m_srcTransOffset.Relocate(0, 0, 0, 0);
-    m_srcPos.Relocate(0, 0, 0, 0);
-    m_dstTransGUID = 0;
-    m_dstTransOffset.Relocate(0, 0, 0, 0);
-    m_dstPos.Relocate(0, 0, 0, 0);
-    m_strTarget = "";
-    m_targetMask = 0;
-}
-
-SpellCastTargets::~SpellCastTargets()
-{
-}
-
-void SpellCastTargets::setUnitTarget(Unit *target)
-{
-    if (!target)
-        return;
-
-    m_unitTarget = target;
-    m_unitTargetGUID = target->GetGUID();
-    m_targetMask |= TARGET_FLAG_UNIT;
-}
-
-void SpellCastTargets::setSrc(float x, float y, float z)
-{
-    m_srcPos.Relocate(x, y, z);
-    m_srcTransGUID = 0;
-    m_targetMask |= TARGET_FLAG_SOURCE_LOCATION;
-}
-
-void SpellCastTargets::setSrc(Position &pos)
-{
-    m_srcPos.Relocate(pos);
-    m_srcTransGUID = 0;
-    m_targetMask |= TARGET_FLAG_SOURCE_LOCATION;
-}
-
-void SpellCastTargets::setSrc(WorldObject &wObj)
-{
-    uint64 guid = wObj.GetTransGUID();
-    m_srcTransGUID = guid;
-    m_srcTransOffset.Relocate(wObj.GetTransOffsetX(), wObj.GetTransOffsetY(), wObj.GetTransOffsetZ(), wObj.GetTransOffsetO());
-    m_srcPos.Relocate(wObj);
-    m_targetMask |= TARGET_FLAG_SOURCE_LOCATION;
-}
-
-void SpellCastTargets::modSrc(Position &pos)
-{
-    ASSERT(m_targetMask & TARGET_FLAG_SOURCE_LOCATION);
-
-    if (m_srcTransGUID)
-    {
-        Position offset;
-        m_srcPos.GetPositionOffsetTo(pos, offset);
-        m_srcTransOffset.RelocateOffset(offset);
-    }
-    m_srcPos.Relocate(pos);
-}
-
-void SpellCastTargets::setDst(float x, float y, float z, float orientation, uint32 mapId)
-{
-    m_dstPos.Relocate(x, y, z, orientation);
-    m_dstTransGUID = 0;
-    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
-    if (mapId != MAPID_INVALID)
-        m_dstPos.m_mapId = mapId;
-}
-
-void SpellCastTargets::setDst(Position &pos)
-{
-    m_dstPos.Relocate(pos);
-    m_dstTransGUID = 0;
-    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
-}
-
-void SpellCastTargets::setDst(WorldObject &wObj)
-{
-    uint64 guid = wObj.GetTransGUID();
-    m_dstTransGUID = guid;
-    m_dstTransOffset.Relocate(wObj.GetTransOffsetX(), wObj.GetTransOffsetY(), wObj.GetTransOffsetZ(), wObj.GetTransOffsetO());
-    m_dstPos.Relocate(wObj);
-    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
-}
-
-void SpellCastTargets::setDst(SpellCastTargets &spellTargets)
-{
-    m_dstTransGUID = spellTargets.m_dstTransGUID;
-    m_dstTransOffset.Relocate(spellTargets.m_dstTransOffset);
-    m_dstPos.Relocate(spellTargets.m_dstPos);
-    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
-}
-
-void SpellCastTargets::modDst(Position &pos)
-{
-    ASSERT(m_targetMask & TARGET_FLAG_DEST_LOCATION);
-
-    if (m_dstTransGUID)
-    {
-        Position offset;
-        m_dstPos.GetPositionOffsetTo(pos, offset);
-        m_dstTransOffset.RelocateOffset(offset);
-    }
-    m_dstPos.Relocate(pos);
-}
-
-void SpellCastTargets::setGOTarget(GameObject *target)
-{
-    m_GOTarget = target;
-    m_GOTargetGUID = target->GetGUID();
-    m_targetMask |= TARGET_FLAG_OBJECT;
-}
-
-void SpellCastTargets::setItemTarget(Item* item)
-{
-    if (!item)
-        return;
-
-    m_itemTarget = item;
-    m_itemTargetGUID = item->GetGUID();
-    m_itemTargetEntry = item->GetEntry();
-    m_targetMask |= TARGET_FLAG_ITEM;
-}
-
-void SpellCastTargets::setTradeItemTarget(Player* caster)
-{
-    m_itemTargetGUID = uint64(TRADE_SLOT_NONTRADED);
-    m_itemTargetEntry = 0;
-    m_targetMask |= TARGET_FLAG_TRADE_ITEM;
-
-    Update(caster);
-}
-
-void SpellCastTargets::setCorpseTarget(Corpse* corpse)
-{
-    m_CorpseTargetGUID = corpse->GetGUID();
-}
-
-void SpellCastTargets::Update(Unit* caster)
-{
-    m_GOTarget   = m_GOTargetGUID ? caster->GetMap()->GetGameObject(m_GOTargetGUID) : NULL;
-    m_unitTarget = m_unitTargetGUID ?
-        (m_unitTargetGUID == caster->GetGUID() ? caster : ObjectAccessor::GetUnit(*caster, m_unitTargetGUID)) :
-    NULL;
-
-    m_itemTarget = NULL;
-    if (caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        Player *player = caster->ToPlayer();
-        if (m_targetMask & TARGET_FLAG_ITEM)
-            m_itemTarget = player->GetItemByGuid(m_itemTargetGUID);
-        else if (m_targetMask & TARGET_FLAG_TRADE_ITEM)
-            if (m_itemTargetGUID == TRADE_SLOT_NONTRADED) // here it is not guid but slot. Also prevents hacking slots
-                if (TradeData* pTrade = player->GetTradeData())
-                    m_itemTarget = pTrade->GetTraderData()->GetItem(TRADE_SLOT_NONTRADED);
-
-        if (m_itemTarget)
-            m_itemTargetEntry = m_itemTarget->GetEntry();
-    }
-    // update positions by transport move
-    if (HasSrc() && m_srcTransGUID)
-    {
-        if (WorldObject * transport = ObjectAccessor::GetWorldObject(*caster, m_srcTransGUID))
-        {
-            m_srcPos.Relocate(transport);
-            m_srcPos.RelocateOffset(m_srcTransOffset);
-        }
-    }
-    if (HasDst() && m_dstTransGUID)
-    {
-        if (WorldObject * transport = ObjectAccessor::GetWorldObject(*caster, m_dstTransGUID))
-        {
-            m_dstPos.Relocate(transport);
-            m_dstPos.RelocateOffset(m_dstTransOffset);
-        }
-    }
-}
-
-void SpellCastTargets::OutDebug()
-{
-    if (!m_targetMask)
-        sLog.outString("TARGET_FLAG_SELF");
-
-    if (m_targetMask & TARGET_FLAG_UNIT)
-    {
-        sLog.outString("TARGET_FLAG_UNIT: " UI64FMTD, m_unitTargetGUID);
-    }
-    if (m_targetMask & TARGET_FLAG_UNK17)
-    {
-        sLog.outString("TARGET_FLAG_UNK17: " UI64FMTD, m_unitTargetGUID);
-    }
-    if (m_targetMask & TARGET_FLAG_OBJECT)
-    {
-        sLog.outString("TARGET_FLAG_OBJECT: " UI64FMTD, m_GOTargetGUID);
-    }
-    if (m_targetMask & TARGET_FLAG_CORPSE)
-    {
-        sLog.outString("TARGET_FLAG_CORPSE: " UI64FMTD, m_CorpseTargetGUID);
-    }
-    if (m_targetMask & TARGET_FLAG_PVP_CORPSE)
-    {
-        sLog.outString("TARGET_FLAG_PVP_CORPSE: " UI64FMTD, m_CorpseTargetGUID);
-    }
-    if (m_targetMask & TARGET_FLAG_ITEM)
-    {
-        sLog.outString("TARGET_FLAG_ITEM: " UI64FMTD, m_itemTargetGUID);
-    }
-    if (m_targetMask & TARGET_FLAG_TRADE_ITEM)
-    {
-        sLog.outString("TARGET_FLAG_TRADE_ITEM: " UI64FMTD, m_itemTargetGUID);
-    }
-    if (m_targetMask & TARGET_FLAG_SOURCE_LOCATION)
-    {
-        sLog.outString("TARGET_FLAG_SOURCE_LOCATION: transport guid:" UI64FMTD " trans offset: %s position: %s", m_srcTransGUID, m_srcTransOffset.ToString().c_str(), m_srcPos.ToString().c_str());
-    }
-    if (m_targetMask & TARGET_FLAG_DEST_LOCATION)
-    {
-        sLog.outString("TARGET_FLAG_DEST_LOCATION: transport guid:" UI64FMTD " trans offset: %s position: %s", m_dstTransGUID, m_dstTransOffset.ToString().c_str(), m_dstPos.ToString().c_str());
-    }
-    if (m_targetMask & TARGET_FLAG_STRING)
-    {
-        sLog.outString("TARGET_FLAG_STRING: %s", m_strTarget.c_str());
-    }
-    sLog.outString("speed: %f", m_speed);
-    sLog.outString("elevation: %f", m_elevation);
-}
-
-void SpellCastTargets::read (ByteBuffer & data, Unit * caster)
-{
-    data >> m_targetMask;
-
-    if (m_targetMask == TARGET_FLAG_SELF)
-        return;
-
-    if (m_targetMask & (TARGET_FLAG_UNIT | TARGET_FLAG_UNK17))
-        data.readPackGUID(m_unitTargetGUID);
-
-    if (m_targetMask & (TARGET_FLAG_OBJECT))
-        data.readPackGUID(m_GOTargetGUID);
-
-    if(m_targetMask & (TARGET_FLAG_ITEM | TARGET_FLAG_TRADE_ITEM))
-        data.readPackGUID(m_itemTargetGUID);
-
-    if(m_targetMask & (TARGET_FLAG_CORPSE | TARGET_FLAG_PVP_CORPSE))
-        data.readPackGUID(m_CorpseTargetGUID);
-
-    if (m_targetMask & TARGET_FLAG_SOURCE_LOCATION)
-    {
-        data.readPackGUID(m_srcTransGUID);
-        if (m_srcTransGUID)
-            data >> m_srcTransOffset.PositionXYZStream();
-        else
-            data >> m_srcPos.PositionXYZStream();
-    }
-    else
-    {
-        m_srcTransGUID = caster->GetTransGUID();
-        if (m_srcTransGUID)
-            m_srcTransOffset.Relocate(caster->GetTransOffsetX(), caster->GetTransOffsetY(), caster->GetTransOffsetZ(), caster->GetTransOffsetO());
-        else
-            m_srcPos.Relocate(caster);
-    }
-
-    if (m_targetMask & TARGET_FLAG_DEST_LOCATION)
-    {
-        data.readPackGUID(m_dstTransGUID);
-        if (m_dstTransGUID)
-            data >> m_dstTransOffset.PositionXYZStream();
-        else
-            data >> m_dstPos.PositionXYZStream();
-    }
-    else
-    {
-        m_dstTransGUID = caster->GetTransGUID();
-        if (m_dstTransGUID)
-            m_dstTransOffset.Relocate(caster->GetTransOffsetX(), caster->GetTransOffsetY(), caster->GetTransOffsetZ(), caster->GetTransOffsetO());
-        else
-            m_dstPos.Relocate(caster);
-    }
-
-    if(m_targetMask & TARGET_FLAG_STRING)
-        data >> m_strTarget;
-
-    Update(caster);
-}
-
-void SpellCastTargets::write (ByteBuffer & data)
-{
-    data << uint32(m_targetMask);
-
-    if (m_targetMask & (TARGET_FLAG_UNIT | TARGET_FLAG_PVP_CORPSE | TARGET_FLAG_OBJECT | TARGET_FLAG_CORPSE | TARGET_FLAG_UNK17))
-    {
-        if (m_targetMask & TARGET_FLAG_UNIT)
-        {
-            if (m_unitTarget)
-                data.append(m_unitTarget->GetPackGUID());
-            else
-                data << uint8(0);
-        }
-        else if (m_targetMask & TARGET_FLAG_OBJECT)
-        {
-            if(m_GOTarget)
-                data.append(m_GOTarget->GetPackGUID());
-            else
-                data << uint8(0);
-        }
-        else if (m_targetMask & ( TARGET_FLAG_CORPSE | TARGET_FLAG_PVP_CORPSE))
-            data.appendPackGUID(m_CorpseTargetGUID);
-        else
-            data << uint8(0);
-    }
-
-    if (m_targetMask & ( TARGET_FLAG_ITEM | TARGET_FLAG_TRADE_ITEM))
-    {
-        if(m_itemTarget)
-            data.append(m_itemTarget->GetPackGUID());
-        else
-            data << uint8(0);
-    }
-
-    if (m_targetMask & TARGET_FLAG_SOURCE_LOCATION)
-    {
-        data.appendPackGUID(m_srcTransGUID); // relative position guid here - transport for example
-        if (m_srcTransGUID)
-            data << m_srcTransOffset.PositionXYZStream();
-        else
-            data << m_srcPos.PositionXYZStream();
-    }
-
-    if (m_targetMask & TARGET_FLAG_DEST_LOCATION)
-    {
-        data.appendPackGUID(m_dstTransGUID); // relative position guid here - transport for example
-        if (m_dstTransGUID)
-            data << m_dstTransOffset.PositionXYZStream();
-        else
-            data << m_dstPos.PositionXYZStream();
-    }
-
-    if (m_targetMask & TARGET_FLAG_STRING)
-        data << m_strTarget;
-}
-
-Spell::Spell(Unit* Caster, SpellEntry const *info, bool triggered, uint64 originalCasterGUID, bool skipCheck):
-m_spellInfo(sSpellMgr.GetSpellForDifficultyFromSpell(info, Caster)),
-m_caster(Caster), m_spellValue(new SpellValue(m_spellInfo))
-{
-    m_customAttr = sSpellMgr.GetSpellCustomAttr(m_spellInfo->Id);
-    m_skipCheck = skipCheck;
-    m_selfContainer = NULL;
-    m_referencedFromCurrentSpell = false;
-    m_executedCurrently = false;
-    m_needComboPoints = NeedsComboPoints(m_spellInfo);
-    m_comboPointGain = 0;
-    m_delayStart = 0;
-    m_delayAtDamageCount = 0;
-
-    m_effectMask = 0;
-    m_auraScaleMask = 0;
-
-    // Get data for type of attack
-    switch (m_spellInfo->DmgClass)
-    {
-        case SPELL_DAMAGE_CLASS_MELEE:
-            if (m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_REQ_OFFHAND)
-                m_attackType = OFF_ATTACK;
-            else
-                m_attackType = BASE_ATTACK;
-            break;
-        case SPELL_DAMAGE_CLASS_RANGED:
-            m_attackType = IsRangedWeaponSpell(m_spellInfo) ? RANGED_ATTACK : BASE_ATTACK;
-            break;
-        default:
-                                                            // Wands
-            if (m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG)
-                m_attackType = RANGED_ATTACK;
-            else
-                m_attackType = BASE_ATTACK;
-            break;
-    }
-
-    m_spellSchoolMask = GetSpellSchoolMask(info);           // Can be override for some spell (wand shoot for example)
-
-    if (m_attackType == RANGED_ATTACK)
-    {
-        // wand case
-        if ((m_caster->getClassMask() & CLASSMASK_WAND_USERS) != 0 && m_caster->GetTypeId() == TYPEID_PLAYER)
-        {
-            if (Item* pItem = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK))
-                m_spellSchoolMask = SpellSchoolMask(1 << pItem->GetProto()->Damage[0].DamageType);
-        }
-    }
-
-    if (originalCasterGUID)
-        m_originalCasterGUID = originalCasterGUID;
-    else
-        m_originalCasterGUID = m_caster->GetGUID();
-
-    if (m_originalCasterGUID == m_caster->GetGUID())
-        m_originalCaster = m_caster;
-    else
-    {
-        m_originalCaster = ObjectAccessor::GetUnit(*m_caster, m_originalCasterGUID);
-        if (m_originalCaster && !m_originalCaster->IsInWorld()) m_originalCaster = NULL;
-    }
-
-    m_spellState = SPELL_STATE_NULL;
-
-    m_IsTriggeredSpell = triggered;
-    m_CastItem = NULL;
-
-    unitTarget = NULL;
-    itemTarget = NULL;
-    gameObjTarget = NULL;
-    focusObject = NULL;
-    m_cast_count = 0;
-    m_glyphIndex = 0;
-    m_preCastSpell = 0;
-    m_triggeredByAuraSpell  = NULL;
-    m_spellAura = NULL;
-
-    //Auto Shot & Shoot (wand)
-    m_autoRepeat = IsAutoRepeatRangedSpell(m_spellInfo);
-
-    m_runesState = 0;
-    m_powerCost = 0;                                        // setup to correct value in Spell::prepare, don't must be used before.
-    m_casttime = 0;                                         // setup to correct value in Spell::prepare, don't must be used before.
-    m_timer = 0;                                            // will set to castime in prepare
-
-    m_channelTargetEffectMask = 0;
-
-    // determine reflection
-    m_canReflect = false;
-
-    if (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC && !IsAreaOfEffectSpell(m_spellInfo) && !(m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_CANT_REFLECTED))
-    {
-        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            if (m_spellInfo->Effect[j] == 0)
-                continue;
-
-            if (!IsPositiveTarget(m_spellInfo->EffectImplicitTargetA[j], m_spellInfo->EffectImplicitTargetB[j]))
-                m_canReflect = true;
-            else
-                m_canReflect = (m_spellInfo->AttributesEx & SPELL_ATTR_EX_NEGATIVE) ? true : false;
-
-            if (m_canReflect)
-                continue;
-            else
-                break;
-        }
-    }
-
-    CleanupTargetList();
-    CleanupEffectExecuteData();
-}
-
-Spell::~Spell()
-{
-    // unload scripts
-    while(!m_loadedScripts.empty())
-    {
-        std::list<SpellScript *>::iterator itr = m_loadedScripts.begin();
-        (*itr)->_Unload();
-        delete (*itr);
-        m_loadedScripts.erase(itr);
-    }
-
-    if (m_referencedFromCurrentSpell && m_selfContainer && *m_selfContainer == this)
-    {
-        // Clean the reference to avoid later crash.
-        // If this error is repeating, we may have to add an ASSERT to better track down how we get into this case.
-        sLog.outError("SPELL: deleting spell for spell ID %u. However, spell still referenced.", m_spellInfo->Id);
-        *m_selfContainer = NULL;
-    }
-
-    if (m_caster && m_caster->GetTypeId() == TYPEID_PLAYER)
-        ASSERT(m_caster->ToPlayer()->m_spellModTakingSpell != this);
-    delete m_spellValue;
-
-    CheckEffectExecuteData();
-}
-
-template<typename T>
-WorldObject* Spell::FindCorpseUsing()
-{
-    // non-standard target selection
-    float max_range = GetSpellMaxRange(m_spellInfo, false);
-
-    CellPair p(Trinity::ComputeCellPair(m_caster->GetPositionX(), m_caster->GetPositionY()));
-    Cell cell(p);
-    cell.data.Part.reserved = ALL_DISTRICT;
-    cell.SetNoCreate();
-
-    WorldObject* result = NULL;
-
-    T u_check(m_caster, max_range);
-    Trinity::WorldObjectSearcher<T> searcher(m_caster, result, u_check);
-
-    TypeContainerVisitor<Trinity::WorldObjectSearcher<T>, GridTypeMapContainer > grid_searcher(searcher);
-    cell.Visit(p, grid_searcher, *m_caster->GetMap(), *m_caster, max_range);
-
-    if (!result)
-    {
-        TypeContainerVisitor<Trinity::WorldObjectSearcher<T>, WorldTypeMapContainer > world_searcher(searcher);
-        cell.Visit(p, world_searcher, *m_caster->GetMap(), *m_caster, max_range);
-    }
-
-    return result;
-}
-
-void Spell::SelectSpellTargets()
-{
-    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        // not call for empty effect.
-        // Also some spells use not used effect targets for store targets for dummy effect in triggered spells
-        if (!m_spellInfo->Effect[i])
-            continue;
-
-        uint32 effectTargetType = EffectTargetType[m_spellInfo->Effect[i]];
-
-        // is it possible that areaaura is not applied to caster?
-        if (effectTargetType == SPELL_REQUIRE_NONE)
-            continue;
-
-        uint32 targetA = m_spellInfo->EffectImplicitTargetA[i];
-        uint32 targetB = m_spellInfo->EffectImplicitTargetB[i];
-
-        if (targetA)
-            SelectEffectTargets(i, targetA);
-        if (targetB) // In very rare case !A && B
-            SelectEffectTargets(i, targetB);
-
-        if (effectTargetType != SPELL_REQUIRE_UNIT)
-        {
-            if (effectTargetType == SPELL_REQUIRE_CASTER)
-                AddUnitTarget(m_caster, i);
-            else if (effectTargetType == SPELL_REQUIRE_ITEM)
-            {
-                if (m_targets.getItemTarget())
-                    AddItemTarget(m_targets.getItemTarget(), i);
-            }
-            continue;
-        }
-
-        if (!targetA && !targetB)
-        {
-            if (!GetSpellMaxRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex)))
-            {
-                AddUnitTarget(m_caster, i);
-                continue;
-            }
-
-            // add here custom effects that need default target.
-            // FOR EVERY TARGET TYPE THERE IS A DIFFERENT FILL!!
-            switch(m_spellInfo->Effect[i])
-            {
-                case SPELL_EFFECT_DUMMY:
-                {
-                    switch(m_spellInfo->Id)
-                    {
-                        case 20577:                         // Cannibalize
-                        case 54044:                         // Carrion Feeder
-                        {
-                            WorldObject* result = NULL;
-                            if (m_spellInfo->Id == 20577)
-                                result = FindCorpseUsing<Trinity::CannibalizeObjectCheck>();
-                            else
-                                result = FindCorpseUsing<Trinity::CarrionFeederObjectCheck>();
-
-                            if (result)
-                            {
-                                switch(result->GetTypeId())
-                                {
-                                    case TYPEID_UNIT:
-                                    case TYPEID_PLAYER:
-                                        AddUnitTarget((Unit*)result, i);
-                                        break;
-                                    case TYPEID_CORPSE:
-                                        m_targets.setCorpseTarget((Corpse*)result);
-                                        if (Player* owner = ObjectAccessor::FindPlayer(((Corpse*)result)->GetOwnerGUID()))
-                                            AddUnitTarget(owner, i);
-                                        break;
-                                    default:
-                                        break;
-                                }
-                            }
-                            else
-                            {
-                                // clear cooldown at fail
-                                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                                    m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id, true);
-                                SendCastResult(SPELL_FAILED_NO_EDIBLE_CORPSES);
-                                finish(false);
-                            }
-                            break;
-                        }
-                        default:
-                            if (m_targets.getUnitTarget())
-                                AddUnitTarget(m_targets.getUnitTarget(), i);
-                            else
-                                AddUnitTarget(m_caster, i);
-                            break;
-                    }
-                    break;
-                }
-                case SPELL_EFFECT_BIND:
-                case SPELL_EFFECT_RESURRECT:
-                case SPELL_EFFECT_CREATE_ITEM:
-                case SPELL_EFFECT_TRIGGER_SPELL:
-                case SPELL_EFFECT_SKILL_STEP:
-                case SPELL_EFFECT_PROFICIENCY:
-                case SPELL_EFFECT_SUMMON_OBJECT_WILD:
-                case SPELL_EFFECT_SELF_RESURRECT:
-                case SPELL_EFFECT_REPUTATION:
-                case SPELL_EFFECT_LEARN_SPELL:
-                case SPELL_EFFECT_SEND_TAXI:
-                    if (m_targets.getUnitTarget())
-                        AddUnitTarget(m_targets.getUnitTarget(), i);
-                    // Triggered spells have additional spell targets - cast them even if no explicit unit target is given (required for spell 50516 for example)
-                    else if (m_spellInfo->Effect[i] == SPELL_EFFECT_TRIGGER_SPELL)
-                        AddUnitTarget(m_caster, i);
-                    break;
-                case SPELL_EFFECT_SUMMON_PLAYER:
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->GetSelection())
-                    {
-                        Player* target = sObjectMgr.GetPlayer(m_caster->ToPlayer()->GetSelection());
-                        if (target)
-                            AddUnitTarget(target, i);
-                    }
-                    break;
-                case SPELL_EFFECT_RESURRECT_NEW:
-                    if (m_targets.getUnitTarget())
-                        AddUnitTarget(m_targets.getUnitTarget(), i);
-                    if (m_targets.getCorpseTargetGUID())
-                    {
-                        Corpse *corpse = ObjectAccessor::GetCorpse(*m_caster, m_targets.getCorpseTargetGUID());
-                        if (corpse)
-                        {
-                            Player* owner = ObjectAccessor::FindPlayer(corpse->GetOwnerGUID());
-                            if (owner)
-                                AddUnitTarget(owner, i);
-                        }
-                    }
-                    break;
-                case SPELL_EFFECT_SUMMON_CHANGE_ITEM:
-                case SPELL_EFFECT_ADD_FARSIGHT:
-                case SPELL_EFFECT_APPLY_GLYPH:
-                case SPELL_EFFECT_STUCK:
-                case SPELL_EFFECT_FEED_PET:
-                case SPELL_EFFECT_DESTROY_ALL_TOTEMS:
-                case SPELL_EFFECT_KILL_CREDIT2: // only one spell: 42793
-                    AddUnitTarget(m_caster, i);
-                    break;
-                case SPELL_EFFECT_LEARN_PET_SPELL:
-                    if (Guardian* pet = m_caster->GetGuardianPet())
-                        AddUnitTarget(pet, i);
-                    break;
-                /*case SPELL_EFFECT_ENCHANT_ITEM:
-                case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
-                case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
-                case SPELL_EFFECT_DISENCHANT:
-                case SPELL_EFFECT_PROSPECTING:
-                case SPELL_EFFECT_MILLING:
-                    if (m_targets.getItemTarget())
-                        AddItemTarget(m_targets.getItemTarget(), i);
-                    break;*/
-                case SPELL_EFFECT_APPLY_AURA:
-                    switch(m_spellInfo->EffectApplyAuraName[i])
-                    {
-                        case SPELL_AURA_ADD_FLAT_MODIFIER:  // some spell mods auras have 0 target modes instead expected TARGET_UNIT_CASTER(1) (and present for other ranks for same spell for example)
-                        case SPELL_AURA_ADD_PCT_MODIFIER:
-                            AddUnitTarget(m_caster, i);
-                            break;
-                        default:                            // apply to target in other case
-                            break;
-                    }
-                    break;
-                case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
-                                                            // AreaAura
-                    if (m_spellInfo->Attributes & (SPELL_ATTR_CASTABLE_WHILE_SITTING | SPELL_ATTR_CASTABLE_WHILE_MOUNTED | SPELL_ATTR_UNK18 | SPELL_ATTR_NOT_SHAPESHIFT) || m_spellInfo->Attributes == SPELL_ATTR_NOT_SHAPESHIFT)
-                        SelectEffectTargets(i, TARGET_UNIT_PARTY_TARGET);
-                    break;
-                case SPELL_EFFECT_SKIN_PLAYER_CORPSE:
-                    if (m_targets.getUnitTarget())
-                    {
-                        AddUnitTarget(m_targets.getUnitTarget(), i);
-                    }
-                    else if (m_targets.getCorpseTargetGUID())
-                    {
-                        Corpse *corpse = ObjectAccessor::GetCorpse(*m_caster,m_targets.getCorpseTargetGUID());
-                        if (corpse)
-                        {
-                            Player* owner = ObjectAccessor::FindPlayer(corpse->GetOwnerGUID());
-                            if (owner)
-                                AddUnitTarget(owner, i);
-                        }
-                    }
-                    break;
-                default:
-                    AddUnitTarget(m_caster, i);
-                    break;
-            }
-        }
-        if (IsChanneledSpell(m_spellInfo))
-        {
-            uint8 mask = (1<<i);
-            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-            {
-                if (ihit->effectMask & mask)
-                {
-                    m_channelTargetEffectMask |= mask;
-                    break;
-                }
-            }
-        }
-        else if (m_auraScaleMask)
-        {
-            bool checkLvl = !m_UniqueTargetInfo.empty();
-            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end();)
-            {
-                // remove targets which did not pass min level check
-                if (m_auraScaleMask && ihit->effectMask == m_auraScaleMask)
-                {
-                    // Do not check for selfcast
-                    if (!ihit->scaleAura && ihit->targetGUID != m_caster->GetGUID())
-                    {
-                         m_UniqueTargetInfo.erase(ihit++);
-                         continue;
-                    }
-                }
-                ++ihit;
-            }
-            if (checkLvl && m_UniqueTargetInfo.empty())
-            {
-                SendCastResult(SPELL_FAILED_LOWLEVEL);
-                finish(false);
-            }
-        }
-    }
-
-    if (m_targets.HasDst())
-    {
-        if (m_targets.HasTraj())
-        {
-            float speed = m_targets.GetSpeedXY();
-            if (speed > 0.0f)
-                m_delayMoment = (uint64)floor(m_targets.GetDist2d() / speed * 1000.0f);
-        }
-        else if (m_spellInfo->speed > 0.0f)
-        {
-            float dist = m_caster->GetDistance(m_targets.m_dstPos);
-            m_delayMoment = (uint64) floor(dist / m_spellInfo->speed * 1000.0f);
-        }
-    }
-}
-
-void Spell::prepareDataForTriggerSystem(AuraEffect const * /*triggeredByAura*/)
-{
-    //==========================================================================================
-    // Now fill data for trigger system, need know:
-    // can spell trigger another or not (m_canTrigger)
-    // Create base triggers flags for Attacker and Victim (m_procAttacker, m_procVictim and m_procEx)
-    //==========================================================================================
-
-    m_procVictim = m_procAttacker = 0;
-    // Get data for type of attack and fill base info for trigger
-    switch (m_spellInfo->DmgClass)
-    {
-        case SPELL_DAMAGE_CLASS_MELEE:
-            m_procAttacker = PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS;
-            if (m_attackType == OFF_ATTACK)
-                m_procAttacker |= PROC_FLAG_DONE_OFFHAND_ATTACK;
-            else
-                m_procAttacker |= PROC_FLAG_DONE_MAINHAND_ATTACK;
-            m_procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
-            break;
-        case SPELL_DAMAGE_CLASS_RANGED:
-            // Auto attack
-            if (m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG)
-            {
-                m_procAttacker = PROC_FLAG_DONE_RANGED_AUTO_ATTACK;
-                m_procVictim   = PROC_FLAG_TAKEN_RANGED_AUTO_ATTACK;
-            }
-            else // Ranged spell attack
-            {
-                m_procAttacker = PROC_FLAG_DONE_SPELL_RANGED_DMG_CLASS;
-                m_procVictim   = PROC_FLAG_TAKEN_SPELL_RANGED_DMG_CLASS;
-            }
-            break;
-        default:
-            if (m_spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON &&
-                m_spellInfo->EquippedItemSubClassMask & (1<<ITEM_SUBCLASS_WEAPON_WAND)
-                && m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG) // Wands auto attack
-            {
-                m_procAttacker = PROC_FLAG_DONE_RANGED_AUTO_ATTACK;
-                m_procVictim   = PROC_FLAG_TAKEN_RANGED_AUTO_ATTACK;
-            }
-            // For other spells trigger procflags are set in Spell::DoAllEffectOnTarget
-            // Because spell positivity is dependant on target
-    }
-    m_procEx= PROC_EX_NONE;
-
-    // Hunter trap spells - activation proc for Lock and Load, Entrapment and Misdirection
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER &&
-        (m_spellInfo->SpellFamilyFlags[0] & 0x18 ||     // Freezing and Frost Trap, Freezing Arrow
-        m_spellInfo->Id == 57879 ||                     // Snake Trap - done this way to avoid double proc
-        m_spellInfo->SpellFamilyFlags[2] & 0x00024000)) // Explosive and Immolation Trap
-
-        m_procAttacker |= PROC_FLAG_DONE_TRAP_ACTIVATION;
-
-    /*
-        Effects which are result of aura proc from triggered spell cannot proc
-        to prevent chain proc of these spells
-    */
-
-    // Hellfire Effect - trigger as DOT
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->SpellFamilyFlags[0] & 0x00000040)
-    {
-        m_procAttacker = PROC_FLAG_DONE_PERIODIC;
-        m_procVictim   = PROC_FLAG_TAKEN_PERIODIC;
-    }
-
-    // Ranged autorepeat attack is set as triggered spell - ignore it
-    if (!(m_procAttacker & PROC_FLAG_DONE_RANGED_AUTO_ATTACK))
-    {
-        if (m_IsTriggeredSpell &&
-            (m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_TRIGGERED_CAN_TRIGGER ||
-            m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_TRIGGERED_CAN_TRIGGER_2))
-            m_procEx |= PROC_EX_INTERNAL_CANT_PROC;
-        else if (m_IsTriggeredSpell)
-            m_procEx |= PROC_EX_INTERNAL_TRIGGERED;
-    }
-    // Totem casts require spellfamilymask defined in spell_proc_event to proc
-    if (m_originalCaster && m_caster != m_originalCaster && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isTotem() && m_caster->IsControlledByPlayer())
-    {
-        m_procEx |= PROC_EX_INTERNAL_REQ_FAMILY;
-    }
-}
-
-void Spell::CleanupTargetList()
-{
-    m_UniqueTargetInfo.clear();
-    m_UniqueGOTargetInfo.clear();
-    m_UniqueItemInfo.clear();
-    m_delayMoment = 0;
-}
-
-void Spell::AddUnitTarget(Unit* pVictim, uint32 effIndex)
-{
-    if (m_spellInfo->Effect[effIndex] == 0)
-        return;
-
-    if (!CheckTarget(pVictim, effIndex))
-        return;
-		
-	// Skip if has aura "Recently Reapaired"
- 	if (pVictim->HasAura(62705))
- 	    return;	
-
-    // Check for effect immune skip if immuned
-    bool immuned = pVictim->IsImmunedToSpellEffect(m_spellInfo, effIndex);
-
-    uint64 targetGUID = pVictim->GetGUID();
-
-    // Lookup target in already in list
-    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-    {
-        if (targetGUID == ihit->targetGUID)                 // Found in list
-        {
-            if (!immuned)
-                ihit->effectMask |= 1 << effIndex;          // Add only effect mask if not immuned
-            ihit->scaleAura = false;
-            if (m_auraScaleMask && ihit->effectMask == m_auraScaleMask && m_caster != pVictim)
-            {
-                SpellEntry const * auraSpell = sSpellStore.LookupEntry(sSpellMgr.GetFirstSpellInChain(m_spellInfo->Id));
-                if (uint32(pVictim->getLevel() + 10) >= auraSpell->spellLevel)
-                    ihit->scaleAura = true;
-            }
-            return;
-        }
-    }
-
-    // This is new target calculate data for him
-
-    // Get spell hit result on target
-    TargetInfo target;
-    target.targetGUID = targetGUID;                         // Store target GUID
-    target.effectMask = immuned ? 0 : 1 << effIndex;        // Store index of effect if not immuned
-    target.processed  = false;                              // Effects not apply on target
-    target.alive      = pVictim->isAlive();
-    target.damage     = 0;
-    target.crit       = false;
-    target.scaleAura  = false;
-    if (m_auraScaleMask && target.effectMask == m_auraScaleMask && m_caster != pVictim)
-    {
-        SpellEntry const * auraSpell = sSpellStore.LookupEntry(sSpellMgr.GetFirstSpellInChain(m_spellInfo->Id));
-        if (uint32(pVictim->getLevel() + 10) >= auraSpell->spellLevel)
-            target.scaleAura = true;
-    }
-
-    // Calculate hit result
-    if (m_originalCaster)
-    {
-        target.missCondition = m_originalCaster->SpellHitResult(pVictim, m_spellInfo, m_canReflect);
-        if (m_skipCheck && target.missCondition != SPELL_MISS_IMMUNE)
-            target.missCondition = SPELL_MISS_NONE;
-    }
-    else
-        target.missCondition = SPELL_MISS_EVADE; //SPELL_MISS_NONE;
-
-    // Spell have speed - need calculate incoming time
-    // Incoming time is zero for self casts. At least I think so.
-    if (m_spellInfo->speed > 0.0f && m_caster != pVictim)
-    {
-        // calculate spell incoming interval
-        // TODO: this is a hack
-        float dist = m_caster->GetDistance(pVictim->GetPositionX(), pVictim->GetPositionY(), pVictim->GetPositionZ());
-
-        if (dist < 5.0f) dist = 5.0f;
-        target.timeDelay = (uint64) floor(dist / m_spellInfo->speed * 1000.0f);
-
-        // Calculate minimum incoming time
-        if (m_delayMoment == 0 || m_delayMoment>target.timeDelay)
-            m_delayMoment = target.timeDelay;
-    }
-    else
-        target.timeDelay = 0LL;
-
-    // If target reflect spell back to caster
-    if (target.missCondition == SPELL_MISS_REFLECT)
-    {
-        // Calculate reflected spell result on caster
-        target.reflectResult =  m_caster->SpellHitResult(m_caster, m_spellInfo, m_canReflect);
-
-        if (target.reflectResult == SPELL_MISS_REFLECT)     // Impossible reflect again, so simply deflect spell
-            target.reflectResult = SPELL_MISS_PARRY;
-
-        // Increase time interval for reflected spells by 1.5
-        target.timeDelay += target.timeDelay >> 1;
-    }
-    else
-        target.reflectResult = SPELL_MISS_NONE;
-
-    // Add target to list
-    m_UniqueTargetInfo.push_back(target);
-}
-
-void Spell::AddUnitTarget(uint64 unitGUID, uint32 effIndex)
-{
-    if (Unit* unit = m_caster->GetGUID() == unitGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, unitGUID))
-        AddUnitTarget(unit, effIndex);
-}
-
-void Spell::AddGOTarget(GameObject* pVictim, uint32 effIndex)
-{
-    if (m_spellInfo->Effect[effIndex] == 0)
-        return;
-
-    uint64 targetGUID = pVictim->GetGUID();
-
-    // Lookup target in already in list
-    for (std::list<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
-    {
-        if (targetGUID == ihit->targetGUID)                 // Found in list
-        {
-            ihit->effectMask |= 1 << effIndex;              // Add only effect mask
-            return;
-        }
-    }
-
-    // This is new target calculate data for him
-
-    GOTargetInfo target;
-    target.targetGUID = targetGUID;
-    target.effectMask = 1 << effIndex;
-    target.processed  = false;                              // Effects not apply on target
-
-    // Spell have speed - need calculate incoming time
-    if (m_spellInfo->speed > 0.0f)
-    {
-        // calculate spell incoming interval
-        float dist = m_caster->GetDistance(pVictim->GetPositionX(), pVictim->GetPositionY(), pVictim->GetPositionZ());
-        if (dist < 5.0f) dist = 5.0f;
-        target.timeDelay = (uint64) floor(dist / m_spellInfo->speed * 1000.0f);
-        if (m_delayMoment == 0 || m_delayMoment>target.timeDelay)
-            m_delayMoment = target.timeDelay;
-    }
-    else
-        target.timeDelay = 0LL;
-
-    // Add target to list
-    m_UniqueGOTargetInfo.push_back(target);
-}
-
-void Spell::AddGOTarget(uint64 goGUID, uint32 effIndex)
-{
-    GameObject* go = m_caster->GetMap()->GetGameObject(goGUID);
-    if (go)
-        AddGOTarget(go, effIndex);
-}
-
-void Spell::AddItemTarget(Item* pitem, uint32 effIndex)
-{
-    if (m_spellInfo->Effect[effIndex] == 0)
-        return;
-
-    // Lookup target in already in list
-    for (std::list<ItemTargetInfo>::iterator ihit = m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
-    {
-        if (pitem == ihit->item)                            // Found in list
-        {
-            ihit->effectMask |= 1<<effIndex;                // Add only effect mask
-            return;
-        }
-    }
-
-    // This is new target add data
-
-    ItemTargetInfo target;
-    target.item       = pitem;
-    target.effectMask = 1 << effIndex;
-    m_UniqueItemInfo.push_back(target);
-}
-
-void Spell::DoAllEffectOnTarget(TargetInfo *target)
-{
-    if (!target || target->processed)
-        return;
-
-    target->processed = true;                               // Target checked in apply effects procedure
-
-    // Get mask of effects for target
-    uint8 mask = target->effectMask;
-
-    Unit* unit = m_caster->GetGUID() == target->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster,target->targetGUID);
-    if (!unit)
-    {
-        uint8 farMask = 0;
-        // create far target mask
-        for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (IsFarUnitTargetEffect(m_spellInfo->Effect[i]))
-                if ((1<<i) & mask)
-                    farMask |= (1<<i);
-        }
-        if (!farMask)
-            return;
-        // find unit in world
-        unit = ObjectAccessor::FindUnit(target->targetGUID);
-        if (!unit)
-            return;
-        // do far effects on the unit
-        // can't use default call because of threading, do stuff as fast as possible
-        for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (farMask & (1<<i))
-                HandleEffects(unit,NULL,NULL,i);
-        }
-        return;
-    }
-
-    if (unit->isAlive() != target->alive)
-        return;
-
-    // Get original caster (if exist) and calculate damage/healing from him data
-    Unit *caster = m_originalCaster ? m_originalCaster : m_caster;
-
-    // Skip if m_originalCaster not avaiable
-    if (!caster)
-        return;
-
-    SpellMissInfo missInfo = target->missCondition;
-
-    // Need init unitTarget by default unit (can changed in code on reflect)
-    // Or on missInfo != SPELL_MISS_NONE unitTarget undefined (but need in trigger subsystem)
-    unitTarget = unit;
-
-    // Reset damage/healing counter
-    m_damage = target->damage;
-    m_healing = -target->damage;
-
-    // Fill base trigger info
-    uint32 procAttacker = m_procAttacker;
-    uint32 procVictim   = m_procVictim;
-    uint32 procEx = m_procEx;
-
-    m_spellAura = NULL; // Set aura to null for every target-make sure that pointer is not used for unit without aura applied
-
-                            //Spells with this flag cannot trigger if effect is casted on self
-                            // Slice and Dice, relentless strikes, eviscerate
-    bool canEffectTrigger = unitTarget->CanProc() && (m_spellInfo->AttributesEx4 & (SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST) ? m_caster != unitTarget : true);
-    Unit * spellHitTarget = NULL;
-
-    if (missInfo == SPELL_MISS_NONE)                          // In case spell hit target, do all effect on that target
-        spellHitTarget = unit;
-    else if (missInfo == SPELL_MISS_REFLECT)                // In case spell reflect from target, do all effect on caster (if hit)
-    {
-        if (target->reflectResult == SPELL_MISS_NONE)       // If reflected spell hit caster -> do all effect on him
-        {
-            spellHitTarget = m_caster;
-            if (m_caster->GetTypeId() == TYPEID_UNIT)
-                m_caster->ToCreature()->LowerPlayerDamageReq(target->damage);
-        }
-    }
-
-    if (spellHitTarget)
-    {
-        SpellMissInfo missInfo = DoSpellHitOnUnit(spellHitTarget, mask, target->scaleAura);
-        if (missInfo != SPELL_MISS_NONE)
-        {
-            if (missInfo != SPELL_MISS_MISS)
-                m_caster->SendSpellMiss(unit, m_spellInfo->Id, missInfo);
-            m_damage = 0;
-            spellHitTarget = NULL;
-        }
-    }
-
-    // Do not take combo points on dodge and miss
-    if (m_needComboPoints && m_targets.getUnitTargetGUID() == target->targetGUID)
-        if (missInfo != SPELL_MISS_NONE)
-            m_needComboPoints = false;
-
-    // Trigger info was not filled in spell::preparedatafortriggersystem - we do it now
-    if (canEffectTrigger && !procAttacker && !procVictim)
-    {
-        bool positive = true;
-        if (m_damage > 0)
-            positive = false;
-        else if (!m_healing)
-        {
-            for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
-                // If at least one effect negative spell is negative hit
-                if (mask & (1<<i) && !IsPositiveEffect(m_spellInfo->Id, i))
-                {
-                    positive = false;
-                    break;
-                }
-        }
-        switch(m_spellInfo->DmgClass)
-        {
-            case SPELL_DAMAGE_CLASS_MAGIC:
-                if (positive)
-                {
-                    procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS;
-                    procVictim   |= PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS;
-                }
-                else
-                {
-                    procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG;
-                    procVictim   |= PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG;
-                }
-            break;
-            case SPELL_DAMAGE_CLASS_NONE:
-                if (positive)
-                {
-                    procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS;
-                    procVictim   |= PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_POS;
-                }
-                else
-                {
-                    procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_NEG;
-                    procVictim   |= PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_NEG;
-                }
-            break;
-        }
-    }
-    CallScriptOnHitHandlers();
-
-    // All calculated do it!
-    // Do healing and triggers
-    if (m_healing > 0)
-    {
-        bool crit = caster->isSpellCrit(unitTarget, m_spellInfo, m_spellSchoolMask);
-        uint32 addhealth = m_healing;
-        if (crit)
-        {
-            procEx |= PROC_EX_CRITICAL_HIT;
-            addhealth = caster->SpellCriticalHealingBonus(m_spellInfo, addhealth, NULL);
-        }
-        else
-            procEx |= PROC_EX_NORMAL_HIT;
-
-        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
-        if (canEffectTrigger && missInfo != SPELL_MISS_REFLECT)
-            caster->ProcDamageAndSpell(unitTarget, procAttacker, procVictim, procEx, addhealth, m_attackType, m_spellInfo, m_triggeredByAuraSpell);
-
-        int32 gain = caster->HealBySpell(unitTarget, m_spellInfo, addhealth, crit);
-        unitTarget->getHostileRefManager().threatAssist(caster, float(gain) * 0.5f, m_spellInfo);
-    }
-    // Do damage and triggers
-    else if (m_damage > 0)
-    {
-        // Fill base damage struct (unitTarget - is real spell target)
-        SpellNonMeleeDamage damageInfo(caster, unitTarget, m_spellInfo->Id, m_spellSchoolMask);
-
-        // Add bonuses and fill damageInfo struct
-        caster->CalculateSpellDamageTaken(&damageInfo, m_damage, m_spellInfo, m_attackType,  target->crit);
-        caster->DealDamageMods(damageInfo.target,damageInfo.damage,&damageInfo.absorb);
-
-        // Send log damage message to client
-        caster->SendSpellNonMeleeDamageLog(&damageInfo);
-
-        procEx |= createProcExtendMask(&damageInfo, missInfo);
-        procVictim |= PROC_FLAG_TAKEN_DAMAGE;
-
-        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
-        if (canEffectTrigger && missInfo != SPELL_MISS_REFLECT)
-        {
-            caster->ProcDamageAndSpell(unitTarget, procAttacker, procVictim, procEx, damageInfo.damage, m_attackType, m_spellInfo, m_triggeredByAuraSpell);
-            if (caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->Attributes & SPELL_ATTR_STOP_ATTACK_TARGET) == 0 &&
-               (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
-                caster->ToPlayer()->CastItemCombatSpell(unitTarget, m_attackType, procVictim, procEx);
-        }
-
-        caster->DealSpellDamage(&damageInfo, true);
-
-        // Haunt
-        if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->SpellFamilyFlags[1] & 0x40000 && m_spellAura && m_spellAura->GetEffect(1))
-        {
-            AuraEffect * aurEff = m_spellAura->GetEffect(1);
-            aurEff->SetAmount(aurEff->GetAmount() * damageInfo.damage / 100);
-        }
-    }
-    // Passive spell hits/misses or active spells only misses (only triggers)
-    else
-    {
-        // Fill base damage struct (unitTarget - is real spell target)
-        SpellNonMeleeDamage damageInfo(caster, unitTarget, m_spellInfo->Id, m_spellSchoolMask);
-        procEx |= createProcExtendMask(&damageInfo, missInfo);
-        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
-        if (canEffectTrigger && missInfo != SPELL_MISS_REFLECT)
-            caster->ProcDamageAndSpell(unit, procAttacker, procVictim, procEx, 0, m_attackType, m_spellInfo, m_triggeredByAuraSpell);
-
-        // Failed Pickpocket, reveal rogue
-        if (missInfo == SPELL_MISS_RESIST
-            && m_customAttr & SPELL_ATTR_CU_PICKPOCKET
-            && unitTarget->GetTypeId() == TYPEID_UNIT)
-        {
-            m_caster->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);
-            if (unitTarget->ToCreature()->IsAIEnabled)
-                unitTarget->ToCreature()->AI()->AttackStart(m_caster);
-        }
-    }
-
-    if (m_caster && !m_caster->IsFriendlyTo(unit) && !IsPositiveSpell(m_spellInfo->Id))
-    {
-        m_caster->CombatStart(unit, !(m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_NO_INITIAL_AGGRO));
-
-        if (m_customAttr & SPELL_ATTR_CU_AURA_CC)
-            if (!unit->IsStandState())
-                unit->SetStandState(UNIT_STAND_STATE_STAND);
-    }
-
-    if (spellHitTarget)
-    {
-        //AI functions
-        if (spellHitTarget->GetTypeId() == TYPEID_UNIT)
-        {
-            if (spellHitTarget->ToCreature()->IsAIEnabled)
-                spellHitTarget->ToCreature()->AI()->SpellHit(m_caster, m_spellInfo);
-
-            // cast at creature (or GO) quest objectives update at successful cast finished (+channel finished)
-            // ignore pets or autorepeat/melee casts for speed (not exist quest for spells (hm...)
-            if (m_originalCaster && m_originalCaster->IsControlledByPlayer() && !spellHitTarget->ToCreature()->isPet() && !IsAutoRepeat() && !IsNextMeleeSwingSpell() && !IsChannelActive())
-                if (Player* p = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself())
-                    p->CastedCreatureOrGO(spellHitTarget->GetEntry(),spellHitTarget->GetGUID(),m_spellInfo->Id);
-        }
-
-        if (m_caster && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsAIEnabled)
-            m_caster->ToCreature()->AI()->SpellHitTarget(spellHitTarget, m_spellInfo);
-
-        // Needs to be called after dealing damage/healing to not remove breaking on damage auras
-        DoTriggersOnSpellHit(spellHitTarget);
-
-        // if target is fallged for pvp also flag caster if a player
-        if (unit->IsPvP())
-        {
-            if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            m_caster->ToPlayer()->UpdatePvP(true);
-        }
-
-        CallScriptAfterHitHandlers();
-    }
-}
-
-SpellMissInfo Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask, bool scaleAura)
-{
-    if (!unit || !effectMask)
-        return SPELL_MISS_EVADE;
-
-    // Recheck immune (only for delayed spells)
-    if (m_spellInfo->speed && (unit->IsImmunedToDamage(m_spellInfo) || unit->IsImmunedToSpell(m_spellInfo)))
-        return SPELL_MISS_IMMUNE;
-
-    PrepareScriptHitHandlers();
-    CallScriptBeforeHitHandlers();
-
-    if (unit->GetTypeId() == TYPEID_PLAYER)
-    {
-        unit->ToPlayer()->GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_SPELL_TARGET, m_spellInfo->Id);
-        unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, m_spellInfo->Id, 0, m_caster);
-        unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET2, m_spellInfo->Id);
-    }
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        m_caster->ToPlayer()->GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_SPELL_CASTER, m_spellInfo->Id);
-        m_caster->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CAST_SPELL2, m_spellInfo->Id, 0, unit);
-    }
-
-    if (m_caster != unit)
-    {
-        // Recheck  UNIT_FLAG_NON_ATTACKABLE for delayed spells
-        if (m_spellInfo->speed > 0.0f &&
-            unit->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) &&
-            unit->GetCharmerOrOwnerGUID() != m_caster->GetGUID())
-        {
-            return SPELL_MISS_EVADE;
-        }
-
-        if (!m_caster->IsFriendlyTo(unit))
-        {
-            // reset damage to 0 if target has Invisibility and isn't visible for caster
-            // I do not think this is a correct way to fix it. Sanctuary effect should make all delayed spells invalid
-            // for delayed spells ignore not visible explicit target
-            if (m_spellInfo->speed > 0.0f && unit == m_targets.getUnitTarget()
-                && (unit->m_invisibilityMask || m_caster->m_invisibilityMask)
-                && !m_caster->canSeeOrDetect(unit, true))
-            {
-                // that was causing CombatLog errors
-                // return SPELL_MISS_EVADE;
-                return SPELL_MISS_MISS; // miss = do not send anything here
-            }
-
-            unit->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_HITBYSPELL);
-            //TODO: This is a hack. But we do not know what types of stealth should be interrupted by CC
-            if ((m_customAttr & SPELL_ATTR_CU_AURA_CC) && unit->IsControlledByPlayer())
-                unit->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
-        }
-        else
-        {
-            // for delayed spells ignore negative spells (after duel end) for friendly targets
-            // TODO: this cause soul transfer bugged
-            if (m_spellInfo->speed > 0.0f && unit->GetTypeId() == TYPEID_PLAYER && !IsPositiveSpell(m_spellInfo->Id))
-            {
-                return SPELL_MISS_EVADE;
-            }
-
-            // assisting case, healing and resurrection
-            if (unit->hasUnitState(UNIT_STAT_ATTACK_PLAYER))
-            {
-                m_caster->SetContestedPvP();
-                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    m_caster->ToPlayer()->UpdatePvP(true);
-            }
-            if (unit->isInCombat() && !(m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_NO_INITIAL_AGGRO))
-            {
-                m_caster->SetInCombatState(unit->GetCombatTimer() > 0, unit);
-                unit->getHostileRefManager().threatAssist(m_caster, 0.0f);
-            }
-        }
-    }
-
-    // Get Data Needed for Diminishing Returns, some effects may have multiple auras, so this must be done on spell hit, not aura add
-    m_diminishGroup = GetDiminishingReturnsGroupForSpell(m_spellInfo,m_triggeredByAuraSpell);
-    if (m_diminishGroup)
-    {
-        m_diminishLevel = unit->GetDiminishing(m_diminishGroup);
-        DiminishingReturnsType type = GetDiminishingReturnsGroupType(m_diminishGroup);
-        // Increase Diminishing on unit, current informations for actually casts will use values above
-        if ((type == DRTYPE_PLAYER && (unit->GetTypeId() == TYPEID_PLAYER || unit->ToCreature()->isPet() || unit->ToCreature()->isPossessedByPlayer())) || type == DRTYPE_ALL)
-            unit->IncrDiminishing(m_diminishGroup);
-    }
-
-    uint8 aura_effmask = 0;
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        if (effectMask & (1<<i) && IsUnitOwnedAuraEffect(m_spellInfo->Effect[i]))
-            aura_effmask |= 1<<i;
-
-    if (aura_effmask)
-    {
-        // Select rank for aura with level requirements only in specific cases
-        // Unit has to be target only of aura effect, both caster and target have to be players, target has to be other than unit target
-        SpellEntry const * aurSpellInfo = m_spellInfo;
-        int32 basePoints[3];
-        if (scaleAura)
-        {
-            aurSpellInfo = sSpellMgr.SelectAuraRankForPlayerLevel(m_spellInfo,unitTarget->getLevel());
-            ASSERT(aurSpellInfo);
-            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-            {
-                basePoints[i] = aurSpellInfo->EffectBasePoints[i];
-                if (m_spellInfo->Effect[i] != aurSpellInfo->Effect[i])
-                {
-                    aurSpellInfo = m_spellInfo;
-                    break;
-                }
-            }
-        }
-
-        if (m_originalCaster)
-        {
-            m_spellAura = Aura::TryCreate(aurSpellInfo, effectMask, unit,
-                m_originalCaster,(aurSpellInfo == m_spellInfo)? &m_spellValue->EffectBasePoints[0] : &basePoints[0], m_CastItem);
-            if (m_spellAura)
-            {
-                // Now Reduce spell duration using data received at spell hit
-                int32 duration = m_spellAura->GetMaxDuration();
-                int32 limitduration = GetDiminishingReturnsLimitDuration(m_diminishGroup,aurSpellInfo);
-                float diminishMod = unit->ApplyDiminishingToDuration(m_diminishGroup, duration, m_originalCaster, m_diminishLevel,limitduration);
-
-                // unit is immune to aura if it was diminished to 0 duration
-                if (diminishMod == 0.0f)
-                {
-                    m_spellAura->Remove();
-                    return SPELL_MISS_IMMUNE;
-                }
-
-                ((UnitAura*)m_spellAura)->SetDiminishGroup(m_diminishGroup);
-
-                bool positive = IsPositiveSpell(m_spellAura->GetId());
-                AuraApplication * aurApp = m_spellAura->GetApplicationOfTarget(m_originalCaster->GetGUID());
-                if (aurApp)
-                    positive = aurApp->IsPositive();
-
-                duration = m_originalCaster->ModSpellDuration(aurSpellInfo, unit, duration, positive);
-
-                // Haste modifies duration of channeled spells
-                if (IsChanneledSpell(m_spellInfo))
-                    m_originalCaster->ModSpellCastTime(aurSpellInfo, duration, this);
-
-                // and duration of auras affected by SPELL_AURA_PERIODIC_HASTE
-                if (m_originalCaster->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_HASTE, aurSpellInfo))
-                    duration = int32(duration * m_originalCaster->GetFloatValue(UNIT_MOD_CAST_SPEED));
-
-                if (duration != m_spellAura->GetMaxDuration())
-                {
-                    m_spellAura->SetMaxDuration(duration);
-                    m_spellAura->SetDuration(duration);
-                }
-                m_spellAura->_RegisterForTargets();
-            }
-        }
-    }
-
-    for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
-    {
-        if (effectMask & (1<<effectNumber))
-            HandleEffects(unit,NULL,NULL,effectNumber);
-    }
-
-    return SPELL_MISS_NONE;
-}
-
-void Spell::DoTriggersOnSpellHit(Unit *unit)
-{
-    // Apply additional spell effects to target
-    if (m_preCastSpell)
-    {
-        // Paladin immunity shields
-        if (m_preCastSpell == 61988)
-        {
-            // Cast Forbearance
-            m_caster->CastSpell(unit, 25771, true);
-            // Cast Avenging Wrath Marker
-            unit->CastSpell(unit, 61987, true);
-        }
-
-        // Avenging Wrath
-        if (m_preCastSpell == 61987)
-            // Cast the serverside immunity shield marker
-            m_caster->CastSpell(unit, 61988, true);
-
-        if (sSpellStore.LookupEntry(m_preCastSpell))
-            // Blizz seems to just apply aura without bothering to cast
-            m_caster->AddAura(m_preCastSpell, unit);
-    }
-
-    // spells with this flag can trigger only if not selfcast (eviscerate for example)
-    if (m_ChanceTriggerSpells.size() && (!((m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST) && unit == m_caster)))
-    {
-        int _duration=0;
-        for (ChanceTriggerSpells::const_iterator i = m_ChanceTriggerSpells.begin(); i != m_ChanceTriggerSpells.end(); ++i)
-        {
-            // SPELL_AURA_ADD_TARGET_TRIGGER auras shouldn't trigger auras without duration
-            // set duration equal to triggering spell
-            if (roll_chance_i(i->second))
-            {
-                m_caster->CastSpell(unit, i->first, true);
-                sLog.outDebug("Spell %d triggered spell %d by SPELL_AURA_ADD_TARGET_TRIGGER aura", m_spellInfo->Id, i->first->Id);
-            }
-            if (GetSpellDuration(i->first) == -1)
-            {
-                if (Aura * triggeredAur = unit->GetAura(i->first->Id, m_caster->GetGUID()))
-                {
-                    // get duration from aura-only once
-                    if (!_duration)
-                    {
-                        Aura * aur = unit->GetAura(m_spellInfo->Id, m_caster->GetGUID());
-                        _duration = aur ? aur->GetDuration() : -1;
-                    }
-                    triggeredAur->SetDuration(_duration);
-                }
-            }
-        }
-    }
-
-    if (m_customAttr & SPELL_ATTR_CU_LINK_HIT)
-    {
-        if (const std::vector<int32> *spell_triggered = sSpellMgr.GetSpellLinked(m_spellInfo->Id + SPELL_LINK_HIT))
-            for (std::vector<int32>::const_iterator i = spell_triggered->begin(); i != spell_triggered->end(); ++i)
-                if (*i < 0)
-                    unit->RemoveAurasDueToSpell(-(*i));
-                else
-                    unit->CastSpell(unit, *i, true, 0, 0, m_caster->GetGUID());
-    }
-}
-
-void Spell::DoAllEffectOnTarget(GOTargetInfo *target)
-{
-    if (target->processed)                                  // Check target
-        return;
-    target->processed = true;                               // Target checked in apply effects procedure
-
-    uint32 effectMask = target->effectMask;
-    if (!effectMask)
-        return;
-
-    GameObject* go = m_caster->GetMap()->GetGameObject(target->targetGUID);
-    if (!go)
-        return;
-
-    PrepareScriptHitHandlers();
-    CallScriptBeforeHitHandlers();
-
-    for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
-        if (effectMask & (1 << effectNumber))
-            HandleEffects(NULL, NULL, go, effectNumber);
-
-    CallScriptOnHitHandlers();
-
-    // cast at creature (or GO) quest objectives update at successful cast finished (+channel finished)
-    // ignore autorepeat/melee casts for speed (not exist quest for spells (hm...)
-    if (m_originalCaster && m_originalCaster->IsControlledByPlayer() && !IsAutoRepeat() && !IsNextMeleeSwingSpell() && !IsChannelActive())
-    {
-        if (Player* p = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself())
-            p->CastedCreatureOrGO(go->GetEntry(),go->GetGUID(),m_spellInfo->Id);
-    }
-    CallScriptAfterHitHandlers();
-}
-
-void Spell::DoAllEffectOnTarget(ItemTargetInfo *target)
-{
-    uint32 effectMask = target->effectMask;
-    if (!target->item || !effectMask)
-        return;
-
-    PrepareScriptHitHandlers();
-    CallScriptBeforeHitHandlers();
-
-    for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
-        if (effectMask & (1 << effectNumber))
-            HandleEffects(NULL, target->item, NULL, effectNumber);
-
-    CallScriptOnHitHandlers();
-
-    CallScriptAfterHitHandlers();
-}
-
-bool Spell::UpdateChanneledTargetList()
-{
-    // Not need check return true
-    if (m_channelTargetEffectMask == 0)
-        return true;
-
-    uint8 channelTargetEffectMask = m_channelTargetEffectMask;
-    uint8 channelAuraMask = 0;
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        if (m_spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
-            channelAuraMask |= 1<<i;
-
-    channelAuraMask &= channelTargetEffectMask;
-
-    float range = 0;
-    if (channelAuraMask)
-    {
-        range = GetSpellMaxRange(m_spellInfo, IsPositiveSpell(m_spellInfo->Id));
-        if (Player * modOwner = m_caster->GetSpellModOwner())
-            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
-    }
-
-    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-    {
-        if (ihit->missCondition == SPELL_MISS_NONE && (channelTargetEffectMask & ihit->effectMask))
-        {
-            Unit *unit = m_caster->GetGUID() == ihit->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID);
-
-            if (!unit)
-                continue;
-
-            if (IsValidDeadOrAliveTarget(unit))
-            {
-                if (channelAuraMask & ihit->effectMask)
-                {
-                    if (AuraApplication * aurApp = unit->GetAuraApplication(m_spellInfo->Id, m_originalCasterGUID))
-                    {
-                        if (m_caster != unit && !m_caster->IsWithinDistInMap(unit,range))
-                        {
-                            ihit->effectMask &= ~aurApp->GetEffectMask();
-                            unit->RemoveAura(aurApp);
-                            continue;
-                        }
-                    }
-                    else // aura is dispelled
-                        continue;
-                }
-
-                channelTargetEffectMask &= ~ihit->effectMask;   // remove from need alive mask effect that have alive target
-            }
-        }
-    }
-
-    // is all effects from m_needAliveTargetMask have alive targets
-    return channelTargetEffectMask == 0;
-}
-
-// Helper for Chain Healing
-// Spell target first
-// Raidmates then descending by injury suffered (MaxHealth - Health)
-// Other players/mobs then descending by injury suffered (MaxHealth - Health)
-struct ChainHealingOrder : public std::binary_function<const Unit*, const Unit*, bool>
-{
-    const Unit* MainTarget;
-    ChainHealingOrder(Unit const* Target) : MainTarget(Target) {};
-    // functor for operator ">"
-    bool operator()(Unit const* _Left, Unit const* _Right) const
-    {
-        return (ChainHealingHash(_Left) < ChainHealingHash(_Right));
-    }
-
-    int32 ChainHealingHash(Unit const* Target) const
-    {
-        /*if (Target == MainTarget)
-            return 0;
-        else*/ if (Target->GetTypeId() == TYPEID_PLAYER && MainTarget->GetTypeId() == TYPEID_PLAYER &&
-           Target->ToPlayer()->IsInSameRaidWith(MainTarget->ToPlayer()))
-        {
-            if (Target->IsFullHealth())
-                return 40000;
-            else
-                return 20000 - Target->GetMaxHealth() + Target->GetHealth();
-        }
-        else
-            return 40000 - Target->GetMaxHealth() + Target->GetHealth();
-    }
-};
-
-void Spell::SearchChainTarget(std::list<Unit*> &TagUnitMap, float max_range, uint32 num, SpellTargets TargetType)
-{
-    Unit *cur = m_targets.getUnitTarget();
-    if (!cur)
-        return;
-
-    // Get spell max affected targets
-    /*uint32 unMaxTargets = m_spellInfo->MaxAffectedTargets;
-    Unit::AuraList const& mod = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_MAX_AFFECTED_TARGETS);
-    for (Unit::AuraList::const_iterator m = mod.begin(); m != mod.end(); ++m)
-    {
-        if (!(*m)->IsAffectedOnSpell(m_spellInfo))
-            continue;
-        unMaxTargets+=(*m)->GetAmount();
-    }*/
-
-    //FIXME: This very like horrible hack and wrong for most spells
-    if (m_spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
-        max_range += num * CHAIN_SPELL_JUMP_RADIUS;
-
-    std::list<Unit*> tempUnitMap;
-    if (TargetType == SPELL_TARGETS_CHAINHEAL)
-    {
-        SearchAreaTarget(tempUnitMap, max_range, PUSH_CHAIN, SPELL_TARGETS_ALLY);
-        tempUnitMap.sort(ChainHealingOrder(m_caster));
-        //if (cur->IsFullHealth() && tempUnitMap.size())
-        //    cur = tempUnitMap.front();
-    }
-    else
-        SearchAreaTarget(tempUnitMap, max_range, PUSH_CHAIN, TargetType);
-    tempUnitMap.remove(cur);
-
-    while (num)
-    {
-        TagUnitMap.push_back(cur);
-        --num;
-
-        if (tempUnitMap.empty())
-            break;
-
-        std::list<Unit*>::iterator next;
-
-        if (TargetType == SPELL_TARGETS_CHAINHEAL)
-        {
-            next = tempUnitMap.begin();
-            while (cur->GetDistance(*next) > CHAIN_SPELL_JUMP_RADIUS
-                || !cur->IsWithinLOSInMap(*next))
-            {
-                ++next;
-                if (next == tempUnitMap.end())
-                    return;
-            }
-        }
-        else
-        {
-            tempUnitMap.sort(Trinity::ObjectDistanceOrderPred(cur));
-            next = tempUnitMap.begin();
-
-            if (cur->GetDistance(*next) > CHAIN_SPELL_JUMP_RADIUS)
-                break;
-            while ((m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE
-                && !m_caster->isInFrontInMap(*next, max_range))
-                || !m_caster->canSeeOrDetect(*next, false)
-                || !cur->IsWithinLOSInMap(*next))
-            {
-                ++next;
-                if (next == tempUnitMap.end() || cur->GetDistance(*next) > CHAIN_SPELL_JUMP_RADIUS)
-                    return;
-            }
-        }
-
-        cur = *next;
-        tempUnitMap.erase(next);
-    }
-}
-
-void Spell::SearchAreaTarget(std::list<Unit*> &TagUnitMap, float radius, SpellNotifyPushType type, SpellTargets TargetType, uint32 entry)
-{
-    if (TargetType == SPELL_TARGETS_GO)
-        return;
-
-    Position *pos;
-    switch(type)
-    {
-        case PUSH_DST_CENTER:
-            CheckDst();
-            pos = &m_targets.m_dstPos;
-            break;
-        case PUSH_SRC_CENTER:
-            CheckSrc();
-            pos = &m_targets.m_srcPos;
-            break;
-        case PUSH_CHAIN:
-        {
-            Unit *target = m_targets.getUnitTarget();
-            if (!target)
-            {
-                sLog.outError("SPELL: cannot find unit target for spell ID %u\n", m_spellInfo->Id);
-                return;
-            }
-            pos = target;
-            break;
-        }
-        default:
-            pos = m_caster;
-            break;
-    }
-
-    bool requireDeadTarget = bool(m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_REQUIRE_DEAD_TARGET);
-    Trinity::SpellNotifierCreatureAndPlayer notifier(m_caster, TagUnitMap, radius, type, TargetType, pos, entry, requireDeadTarget);
-    if ((m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_PLAYERS_ONLY)
-        || (TargetType == SPELL_TARGETS_ENTRY && !entry))
-        m_caster->GetMap()->VisitWorld(pos->m_positionX, pos->m_positionY, radius, notifier);
-    else
-        m_caster->GetMap()->VisitAll(pos->m_positionX, pos->m_positionY, radius, notifier);
-
-    if (m_customAttr & SPELL_ATTR_CU_EXCLUDE_SELF)
-        TagUnitMap.remove(m_caster);
-}
-
-void Spell::SearchGOAreaTarget(std::list<GameObject*> &TagGOMap, float radius, SpellNotifyPushType type, SpellTargets TargetType, uint32 entry)
-{
-    if (TargetType != SPELL_TARGETS_GO)
-        return;
-
-    Position *pos;
-    switch (type)
-    {
-        case PUSH_DST_CENTER:
-            CheckDst();
-            pos = &m_targets.m_dstPos;
-            break;
-        case PUSH_SRC_CENTER:
-            CheckSrc();
-            pos = &m_targets.m_srcPos;
-            break;
-        default:
-            pos = m_caster;
-            break;
-    }
-
-    Trinity::GameObjectInRangeCheck check(pos->m_positionX, pos->m_positionY, pos->m_positionZ, radius + 50, entry);
-    Trinity::GameObjectListSearcher<Trinity::GameObjectInRangeCheck> searcher(m_caster, TagGOMap, check);
-    m_caster->GetMap()->VisitGrid(pos->m_positionX, pos->m_positionY, radius, searcher);
-}
-
-WorldObject* Spell::SearchNearbyTarget(float range, SpellTargets TargetType)
-{
-    switch(TargetType)
-    {
-        case SPELL_TARGETS_ENTRY:
-        {
-            ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET, m_spellInfo->Id);
-            if (conditions.empty())
-            {
-                sLog.outDebug("Spell (ID: %u) (caster Entry: %u) does not have record in `conditions` for spell script target (ConditionSourceType 14)", m_spellInfo->Id, m_caster->GetEntry());
-                if (IsPositiveSpell(m_spellInfo->Id))
-                    return SearchNearbyTarget(range, SPELL_TARGETS_ALLY);
-                else
-                    return SearchNearbyTarget(range, SPELL_TARGETS_ENEMY);
-            }
-
-            Creature* creatureScriptTarget = NULL;
-            GameObject* goScriptTarget = NULL;
-
-            for (ConditionList::const_iterator i_spellST = conditions.begin(); i_spellST != conditions.end(); ++i_spellST)
-            {
-                if ((*i_spellST)->mConditionType != CONDITION_SPELL_SCRIPT_TARGET)
-                    continue;
-                switch((*i_spellST)->mConditionValue1)
-                {
-                    case SPELL_TARGET_TYPE_CONTROLLED:
-                        for (Unit::ControlList::iterator itr = m_caster->m_Controlled.begin(); itr != m_caster->m_Controlled.end(); ++itr)
-                            if ((*itr)->GetEntry() == (*i_spellST)->mConditionValue2 && (*itr)->IsWithinDistInMap(m_caster, range))
-                            {
-                                goScriptTarget = NULL;
-                                creatureScriptTarget = (*itr)->ToCreature();
-                                range = m_caster->GetDistance(creatureScriptTarget);
-                            }
-                        break;
-                    case SPELL_TARGET_TYPE_GAMEOBJECT:
-                        if ((*i_spellST)->mConditionValue2)
-                        {
-                            if (GameObject *go = m_caster->FindNearestGameObject((*i_spellST)->mConditionValue2, range))
-                            {
-                                // remember found target and range, next attempt will find more near target with another entry
-                                goScriptTarget = go;
-                                creatureScriptTarget = NULL;
-                                range = m_caster->GetDistance(goScriptTarget);
-                            }
-                        }
-                        else if (focusObject)          //Focus Object
-                        {
-                            float frange = m_caster->GetDistance(focusObject);
-                            if (range >= frange)
-                            {
-                                creatureScriptTarget = NULL;
-                                goScriptTarget = focusObject;
-                                range = frange;
-                            }
-                        }
-                        break;
-                    case SPELL_TARGET_TYPE_CREATURE:
-                        if (m_targets.getUnitTarget() && m_targets.getUnitTarget()->GetEntry() == (*i_spellST)->mConditionValue2)
-                            return m_targets.getUnitTarget();
-                    case SPELL_TARGET_TYPE_DEAD:
-                    default:
-                        if (Creature *cre = m_caster->FindNearestCreature((*i_spellST)->mConditionValue2, range, (*i_spellST)->mConditionValue1 != SPELL_TARGET_TYPE_DEAD))
-                        {
-                            creatureScriptTarget = cre;
-                            goScriptTarget = NULL;
-                            range = m_caster->GetDistance(creatureScriptTarget);
-                        }
-                        break;
-                }
-            }
-
-            if (creatureScriptTarget)
-                return creatureScriptTarget;
-            else
-                return goScriptTarget;
-        }
-        default:
-        case SPELL_TARGETS_ENEMY:
-        {
-            Unit *target = NULL;
-            Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(m_caster, m_caster, range);
-            Trinity::UnitLastSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(m_caster, target, u_check);
-            m_caster->VisitNearbyObject(range, searcher);
-            return target;
-        }
-        case SPELL_TARGETS_ALLY:
-        {
-            Unit *target = NULL;
-            Trinity::AnyFriendlyUnitInObjectRangeCheck u_check(m_caster, m_caster, range);
-            Trinity::UnitLastSearcher<Trinity::AnyFriendlyUnitInObjectRangeCheck> searcher(m_caster, target, u_check);
-            m_caster->VisitNearbyObject(range, searcher);
-            return target;
-        }
-    }
-}
-
-void Spell::SelectEffectTargets(uint32 i, uint32 cur)
-{
-    SpellNotifyPushType pushType = PUSH_NONE;
-    Player *modOwner = NULL;
-    if (m_originalCaster)
-        modOwner = m_originalCaster->GetSpellModOwner();
-
-    switch(SpellTargetType[cur])
-    {
-        case TARGET_TYPE_UNIT_CASTER:
-        {
-            switch(cur)
-            {
-                case TARGET_UNIT_CASTER:
-                    AddUnitTarget(m_caster, i);
-                    break;
-                case TARGET_UNIT_CASTER_FISHING:
-                {
-                    float min_dis = GetSpellMinRange(m_spellInfo, true);
-                    float max_dis = GetSpellMaxRange(m_spellInfo, true);
-                    float dis = (float)rand_norm() * (max_dis - min_dis) + min_dis;
-                    float x, y, z;
-                    m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE, dis);
-                    m_targets.setDst(x, y, z, m_caster->GetOrientation());
-                    break;
-                }
-                case TARGET_UNIT_MASTER:
-                    if (Unit* owner = m_caster->GetCharmerOrOwner())
-                        AddUnitTarget(owner, i);
-                    break;
-                case TARGET_UNIT_PET:
-                    if (Guardian* pet = m_caster->GetGuardianPet())
-                        AddUnitTarget(pet, i);
-                    break;
-                case TARGET_UNIT_SUMMONER:
-                    if (m_caster->isSummon())
-                        if (Unit* unit = m_caster->ToTempSummon()->GetSummoner())
-                            AddUnitTarget(unit, i);
-                    break;
-                case TARGET_UNIT_PARTY_CASTER:
-                case TARGET_UNIT_RAID_CASTER:
-                    pushType = PUSH_CASTER_CENTER;
-                    break;
-                case TARGET_UNIT_VEHICLE:
-                    if (Unit *vehicle = m_caster->GetVehicleBase())
-                        AddUnitTarget(vehicle, i);
-                    break;
-                case TARGET_UNIT_PASSENGER_0:
-                case TARGET_UNIT_PASSENGER_1:
-                case TARGET_UNIT_PASSENGER_2:
-                case TARGET_UNIT_PASSENGER_3:
-                case TARGET_UNIT_PASSENGER_4:
-                case TARGET_UNIT_PASSENGER_5:
-                case TARGET_UNIT_PASSENGER_6:
-                case TARGET_UNIT_PASSENGER_7:
-                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsVehicle())
-                        if (Unit *unit = m_caster->GetVehicleKit()->GetPassenger(cur - TARGET_UNIT_PASSENGER_0))
-                            AddUnitTarget(unit, i);
-                    break;
-            }
-            break;
-        }
-
-        case TARGET_TYPE_UNIT_TARGET:
-        {
-            Unit *target = m_targets.getUnitTarget();
-            if (!target)
-            {
-                sLog.outError("SPELL: no unit target for spell ID %u", m_spellInfo->Id);
-                break;
-            }
-
-            switch(cur)
-            {
-                case TARGET_UNIT_TARGET_ENEMY:
-                    if (Unit *magnet = m_caster->SelectMagnetTarget(target, m_spellInfo))
-                        if (magnet != target)
-                            m_targets.setUnitTarget(magnet);
-                    pushType = PUSH_CHAIN;
-                    break;
-                case TARGET_UNIT_TARGET_ANY:
-                    if (!IsPositiveSpell(m_spellInfo->Id))
-                        if (Unit *magnet = m_caster->SelectMagnetTarget(target, m_spellInfo))
-                            if (magnet != target)
-                                m_targets.setUnitTarget(magnet);
-                    pushType = PUSH_CHAIN;
-                    break;
-                case TARGET_UNIT_CHAINHEAL:
-                    pushType = PUSH_CHAIN;
-                    break;
-                case TARGET_UNIT_TARGET_ALLY:
-                case TARGET_UNIT_TARGET_RAID:
-                case TARGET_UNIT_TARGET_PARTY:
-                case TARGET_UNIT_TARGET_PUPPET:
-                    AddUnitTarget(target, i);
-                    break;
-                case TARGET_UNIT_PARTY_TARGET:
-                case TARGET_UNIT_CLASS_TARGET:
-                    pushType = PUSH_CASTER_CENTER; // not real
-                    break;
-            }
-            break;
-        }
-
-        case TARGET_TYPE_UNIT_NEARBY:
-        {
-            WorldObject *target = NULL;
-            float range;
-
-            switch(cur)
-            {
-                case TARGET_UNIT_NEARBY_ENEMY:
-                    range = GetSpellMaxRange(m_spellInfo, false);
-                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
-                    target = SearchNearbyTarget(range, SPELL_TARGETS_ENEMY);
-                    break;
-                case TARGET_UNIT_NEARBY_ALLY:
-                case TARGET_UNIT_NEARBY_ALLY_UNK:
-                case TARGET_UNIT_NEARBY_RAID:
-                    range = GetSpellMaxRange(m_spellInfo, true);
-                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
-                    target = SearchNearbyTarget(range, SPELL_TARGETS_ALLY);
-                    break;
-                case TARGET_UNIT_NEARBY_ENTRY:
-                case TARGET_GAMEOBJECT_NEARBY_ENTRY:
-                    range = GetSpellMaxRange(m_spellInfo, IsPositiveSpell(m_spellInfo->Id));
-                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
-                    target = SearchNearbyTarget(range, SPELL_TARGETS_ENTRY);
-                    break;
-            }
-
-            if (!target)
-                return;
-            else if (target->GetTypeId() == TYPEID_GAMEOBJECT)
-                AddGOTarget((GameObject*)target, i);
-            else
-            {
-                pushType = PUSH_CHAIN;
-
-                if (m_targets.getUnitTarget() != target)
-                    m_targets.setUnitTarget((Unit*)target);
-            }
-
-            break;
-        }
-
-        case TARGET_TYPE_AREA_SRC:
-            pushType = PUSH_SRC_CENTER;
-            break;
-
-        case TARGET_TYPE_AREA_DST:
-            pushType = PUSH_DST_CENTER;
-            break;
-
-        case TARGET_TYPE_AREA_CONE:
-            if (m_customAttr & SPELL_ATTR_CU_CONE_BACK)
-                pushType = PUSH_IN_BACK;
-            else if (m_customAttr & SPELL_ATTR_CU_CONE_LINE)
-                pushType = PUSH_IN_LINE;
-            else
-                pushType = PUSH_IN_FRONT;
-            break;
-
-        case TARGET_TYPE_DEST_CASTER: //4+8+2
-        {
-            if (cur == TARGET_SRC_CASTER)
-            {
-                m_targets.setSrc(*m_caster);
-                break;
-            }
-            else if (cur == TARGET_DST_CASTER)
-            {
-                m_targets.setDst(*m_caster);
-                break;
-            }
-
-            float angle, dist;
-
-            float objSize = m_caster->GetObjectSize();
-            dist = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-            if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, dist, this);
-            if (dist < objSize)
-                dist = objSize;
-            else if (cur == TARGET_DEST_CASTER_RANDOM)
-                dist = objSize + (dist - objSize) * (float)rand_norm();
-
-            switch(cur)
-            {
-                case TARGET_DEST_CASTER_FRONT_LEFT: angle = static_cast<float>(-M_PI/4);                   break;
-                case TARGET_DEST_CASTER_BACK_LEFT:  angle = static_cast<float>(-3*M_PI/4);                 break;
-                case TARGET_DEST_CASTER_BACK_RIGHT: angle = static_cast<float>(3*M_PI/4);                  break;
-                case TARGET_DEST_CASTER_FRONT_RIGHT:angle = static_cast<float>(M_PI/4);                    break;
-                case TARGET_MINION:
-                case TARGET_DEST_CASTER_FRONT_LEAP:
-                case TARGET_DEST_CASTER_FRONT:      angle = 0.0f;                                          break;
-                case TARGET_DEST_CASTER_BACK:       angle = static_cast<float>(M_PI);                      break;
-                case TARGET_DEST_CASTER_RIGHT:      angle = static_cast<float>(M_PI/2);                    break;
-                case TARGET_DEST_CASTER_LEFT:       angle = static_cast<float>(-M_PI/2);                   break;
-                default:                            angle = (float)rand_norm()*static_cast<float>(2*M_PI); break;
-            }
-
-            Position pos;
-            if (cur == TARGET_DEST_CASTER_FRONT_LEAP)
-                m_caster->GetFirstCollisionPosition(pos, dist, angle);
-            else
-                m_caster->GetNearPosition(pos, dist, angle);
-            m_targets.setDst(*m_caster);
-            m_targets.modDst(pos);
-            break;
-        }
-
-        case TARGET_TYPE_DEST_TARGET: //2+8+2
-        {
-            Unit *target = m_targets.getUnitTarget();
-            if (!target)
-            {
-                sLog.outError("SPELL: no unit target for spell ID %u", m_spellInfo->Id);
-                break;
-            }
-
-            if (cur == TARGET_DST_TARGET_ENEMY || cur == TARGET_DEST_TARGET_ANY)
-            {
-                m_targets.setDst(*target);
-                break;
-            }
-
-            float angle, dist;
-
-            float objSize = target->GetObjectSize();
-            dist = (float)target->GetSpellRadiusForTarget(target, sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-            if (dist < objSize)
-                dist = objSize;
-            else if (cur == TARGET_DEST_CASTER_RANDOM)
-                dist = objSize + (dist - objSize) * (float)rand_norm();
-
-            switch(cur)
-            {
-                case TARGET_DEST_TARGET_FRONT:      angle = 0.0f;                                          break;
-                case TARGET_DEST_TARGET_BACK:       angle = static_cast<float>(M_PI);                      break;
-                case TARGET_DEST_TARGET_RIGHT:      angle = static_cast<float>(M_PI/2);                    break;
-                case TARGET_DEST_TARGET_LEFT:       angle = static_cast<float>(-M_PI/2);                   break;
-                case TARGET_DEST_TARGET_FRONT_LEFT: angle = static_cast<float>(-M_PI/4);                   break;
-                case TARGET_DEST_TARGET_BACK_LEFT:  angle = static_cast<float>(-3*M_PI/4);                 break;
-                case TARGET_DEST_TARGET_BACK_RIGHT: angle = static_cast<float>(3*M_PI/4);                  break;
-                case TARGET_DEST_TARGET_FRONT_RIGHT:angle = static_cast<float>(M_PI/4);                    break;
-                default:                            angle = (float)rand_norm()*static_cast<float>(2*M_PI); break;
-            }
-
-            Position pos;
-            target->GetNearPosition(pos, dist, angle);
-            m_targets.setDst(*target);
-            m_targets.modDst(pos);
-            break;
-        }
-
-        case TARGET_TYPE_DEST_DEST: //5+8+1
-        {
-            if (!m_targets.HasDst())
-            {
-                sLog.outError("SPELL: no destination for spell ID %u", m_spellInfo->Id);
-                break;
-            }
-
-            float angle;
-            switch(cur)
-            {
-                case TARGET_DEST_DYNOBJ_ENEMY:
-                case TARGET_DEST_DYNOBJ_ALLY:
-                case TARGET_DEST_DYNOBJ_NONE:
-                case TARGET_DEST_DEST:
-                    return;
-                case TARGET_DEST_TRAJ:
-                    SelectTrajTargets();
-                    return;
-                case TARGET_DEST_DEST_FRONT:      angle = 0.0f;                                          break;
-                case TARGET_DEST_DEST_BACK:       angle = static_cast<float>(M_PI);                      break;
-                case TARGET_DEST_DEST_RIGHT:      angle = static_cast<float>(M_PI/2);                    break;
-                case TARGET_DEST_DEST_LEFT:       angle = static_cast<float>(-M_PI/2);                   break;
-                case TARGET_DEST_DEST_FRONT_LEFT: angle = static_cast<float>(-M_PI/4);                   break;
-                case TARGET_DEST_DEST_BACK_LEFT:  angle = static_cast<float>(-3*M_PI/4);                 break;
-                case TARGET_DEST_DEST_BACK_RIGHT: angle = static_cast<float>(3*M_PI/4);                  break;
-                case TARGET_DEST_DEST_FRONT_RIGHT:angle = static_cast<float>(M_PI/4);                    break;
-                default:                          angle = (float)rand_norm()*static_cast<float>(2*M_PI); break;
-            }
-
-            float dist;
-            dist = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-            if (cur == TARGET_DEST_DEST_RANDOM || cur == TARGET_DEST_DEST_RANDOM_DIR_DIST)
-                dist *= (float)rand_norm();
-
-            // must has dst, no need to set flag
-            Position pos = m_targets.m_dstPos;
-            m_caster->MovePosition(pos, dist, angle);
-            m_targets.modDst(pos);
-            break;
-        }
-
-        case TARGET_TYPE_DEST_SPECIAL:
-        {
-            switch(cur)
-            {
-                case TARGET_DST_DB:
-                    if (SpellTargetPosition const* st = sSpellMgr.GetSpellTargetPosition(m_spellInfo->Id))
-                    {
-                        //TODO: fix this check
-                        if (m_spellInfo->Effect[0] == SPELL_EFFECT_TELEPORT_UNITS
-                            || m_spellInfo->Effect[1] == SPELL_EFFECT_TELEPORT_UNITS
-                            || m_spellInfo->Effect[2] == SPELL_EFFECT_TELEPORT_UNITS)
-                            m_targets.setDst(st->target_X, st->target_Y, st->target_Z, st->target_Orientation, (int32)st->target_mapId);
-                        else if (st->target_mapId == m_caster->GetMapId())
-                            m_targets.setDst(st->target_X, st->target_Y, st->target_Z, st->target_Orientation);
-                    }
-                    else
-                    {
-                        sLog.outDebug("SPELL: unknown target coordinates for spell ID %u", m_spellInfo->Id);
-                        Unit *target = NULL;
-                        if (uint64 guid = m_caster->GetUInt64Value(UNIT_FIELD_TARGET))
-                            target = ObjectAccessor::GetUnit(*m_caster, guid);
-                        m_targets.setDst(target ? *target : *m_caster);
-                    }
-                    break;
-                case TARGET_DST_HOME:
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                        m_targets.setDst(m_caster->ToPlayer()->m_homebindX,m_caster->ToPlayer()->m_homebindY,m_caster->ToPlayer()->m_homebindZ, m_caster->ToPlayer()->GetOrientation(), m_caster->ToPlayer()->m_homebindMapId);
-                    break;
-                case TARGET_DST_NEARBY_ENTRY:
-                {
-                    float range = GetSpellMaxRange(m_spellInfo, IsPositiveSpell(m_spellInfo->Id));
-                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
-
-                    if (WorldObject *target = SearchNearbyTarget(range, SPELL_TARGETS_ENTRY))
-                        m_targets.setDst(*target);
-                    break;
-                }
-            }
-            break;
-        }
-
-        case TARGET_TYPE_CHANNEL:
-        {
-            if (!m_originalCaster || !m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
-            {
-                sLog.outError("SPELL: no current channeled spell for spell ID %u", m_spellInfo->Id);
-                break;
-            }
-
-            switch (cur)
-            {
-                case TARGET_UNIT_CHANNEL_TARGET:
-                    // unit target may be no longer avalible - teleported out of map for example
-                    if (Unit* target = Unit::GetUnit(*m_caster, m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets.getUnitTargetGUID()))
-                        AddUnitTarget(target, i);
-                    else
-                        sLog.outError("SPELL: cannot find channel spell target for spell ID %u", m_spellInfo->Id);
-                    break;
-                case TARGET_DEST_CHANNEL_TARGET:
-                    if (m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets.HasDst())
-                        m_targets.setDst(m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets);
-                    else if (Unit* target = Unit::GetUnit(*m_caster, m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets.getUnitTargetGUID()))
-                        m_targets.setDst(*target);
-                    else
-                        sLog.outError("SPELL: cannot find channel spell destination for spell ID %u", m_spellInfo->Id);
-                    break;
-                case TARGET_DEST_CHANNEL_CASTER:
-                    m_targets.setDst(*m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->GetCaster());
-                    break;
-            }
-            break;
-        }
-
-        default:
-        {
-            switch (cur)
-            {
-                case TARGET_GAMEOBJECT:
-                    if (m_targets.getGOTarget())
-                        AddGOTarget(m_targets.getGOTarget(), i);
-                    break;
-                case TARGET_GAMEOBJECT_ITEM:
-                    if (m_targets.getGOTargetGUID())
-                        AddGOTarget(m_targets.getGOTarget(), i);
-                    else if (m_targets.getItemTarget())
-                        AddItemTarget(m_targets.getItemTarget(), i);
-                    break;
-                case TARGET_UNIT_DRIVER:
-                    if (Unit * driver = m_targets.getUnitTarget())
-                        if (driver->IsOnVehicle(driver))
-                            AddUnitTarget(driver, i);
-                    break;
-                default:
-                    sLog.outError("Unhandled spell target %u", cur);
-                    break;
-            }
-            break;
-        }
-    }
-
-    if (pushType == PUSH_CHAIN) // Chain
-    {
-        Unit *target = m_targets.getUnitTarget();
-        if (!target)
-        {
-            sLog.outError("SPELL: no chain unit target for spell ID %u", m_spellInfo->Id);
-            return;
-        }
-
-        //Chain: 2, 6, 22, 25, 45, 77
-        uint32 maxTargets = m_spellInfo->EffectChainTarget[i];
-        if (modOwner)
-            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_JUMP_TARGETS, maxTargets, this);
-
-        if (maxTargets > 1)
-        {
-            float range;
-            std::list<Unit*> unitList;
-
-            switch (cur)
-            {
-                case TARGET_UNIT_NEARBY_ENEMY:
-                case TARGET_UNIT_TARGET_ENEMY:
-                case TARGET_UNIT_NEARBY_ENTRY: // fix me
-                    range = GetSpellMaxRange(m_spellInfo, false);
-                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
-                    SearchChainTarget(unitList, range, maxTargets, SPELL_TARGETS_ENEMY);
-                    break;
-                case TARGET_UNIT_CHAINHEAL:
-                case TARGET_UNIT_NEARBY_ALLY:  // fix me
-                case TARGET_UNIT_NEARBY_ALLY_UNK:
-                case TARGET_UNIT_NEARBY_RAID:
-                    range = GetSpellMaxRange(m_spellInfo, true);
-                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
-                    SearchChainTarget(unitList, range, maxTargets, SPELL_TARGETS_CHAINHEAL);
-                    break;
-            }
-
-            for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
-                AddUnitTarget(*itr, i);
-        }
-        else
-            AddUnitTarget(target, i);
-    }
-    else if (pushType)
-    {
-        // Dummy, just for client
-        if (EffectTargetType[m_spellInfo->Effect[i]] != SPELL_REQUIRE_UNIT)
-            return;
-
-        float radius;
-        SpellTargets targetType;
-        switch(cur)
-        {
-            case TARGET_UNIT_AREA_ENEMY_SRC:
-            case TARGET_UNIT_AREA_ENEMY_DST:
-            case TARGET_UNIT_CONE_ENEMY:
-            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
-            case TARGET_UNIT_AREA_PATH:
-                radius = GetSpellRadius(m_spellInfo, i, false);
-                targetType = SPELL_TARGETS_ENEMY;
-                break;
-            case TARGET_UNIT_AREA_ALLY_SRC:
-            case TARGET_UNIT_AREA_ALLY_DST:
-            case TARGET_UNIT_CONE_ALLY:
-                radius = GetSpellRadius(m_spellInfo, i, true);
-                targetType = SPELL_TARGETS_ALLY;
-                break;
-            case TARGET_UNIT_AREA_ENTRY_DST:
-            case TARGET_UNIT_AREA_ENTRY_SRC:
-            case TARGET_UNIT_CONE_ENTRY: // fix me
-                radius = GetSpellRadius(m_spellInfo, i, IsPositiveSpell(m_spellInfo->Id));
-                targetType = SPELL_TARGETS_ENTRY;
-                break;
-            case TARGET_GAMEOBJECT_AREA_SRC:
-            case TARGET_GAMEOBJECT_AREA_DST:
-            case TARGET_GAMEOBJECT_AREA_PATH:
-                radius = GetSpellRadius(m_spellInfo, i, true);
-                targetType = SPELL_TARGETS_GO;
-                break;
-            default:
-                radius = GetSpellRadius(m_spellInfo, i, true);
-                targetType = SPELL_TARGETS_NONE;
-                break;
-        }
-
-        if (modOwner)
-            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, radius, this);
-        radius *= m_spellValue->RadiusMod;
-
-        std::list<Unit*> unitList;
-        std::list<GameObject*> gobjectList;
-        switch (targetType)
-        {
-            case SPELL_TARGETS_ENTRY:
-            {
-                ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET, m_spellInfo->Id);
-                if (!conditions.empty())
-                {
-                    for (ConditionList::const_iterator i_spellST = conditions.begin(); i_spellST != conditions.end(); ++i_spellST)
-                    {
-                        if ((*i_spellST)->mConditionType != CONDITION_SPELL_SCRIPT_TARGET)
-                            continue;
-                        if ((*i_spellST)->mConditionValue1 == SPELL_TARGET_TYPE_CREATURE)
-                            SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ENTRY, (*i_spellST)->mConditionValue2);
-                        else if ((*i_spellST)->mConditionValue1 == SPELL_TARGET_TYPE_CONTROLLED)
-                        {
-                            for (Unit::ControlList::iterator itr = m_caster->m_Controlled.begin(); itr != m_caster->m_Controlled.end(); ++itr)
-                                if ((*itr)->GetEntry() == (*i_spellST)->mConditionValue2 &&
-                                    /*(*itr)->IsWithinDistInMap(m_caster, radius)*/ (*itr)->IsInMap(m_caster)) // For 60243 and 52173 need skip radius check or use range (no radius entry for effect)
-                                    unitList.push_back(*itr);
-                        }
-                    }
-                }
-                else
-                {
-                    // Custom entries
-                    // TODO: move these to sql
-                    switch (m_spellInfo->Id)
-                    {
-                        case 46584: // Raise Dead
-                        {
-                            if (WorldObject* result = FindCorpseUsing<Trinity::RaiseDeadObjectCheck> ())
-                            {
-                                switch(result->GetTypeId())
-                                {
-                                    case TYPEID_UNIT:
-                                        m_targets.setDst(*result);
-                                        break;
-                                    default:
-                                        break;
-                                }
-                            }
-                            break;
-                        }
-                        // Corpse Explosion
-                        case 49158:
-                        case 51325:
-                        case 51326:
-                        case 51327:
-                        case 51328:
-                            // Search for ghoul if our ghoul or dead body not valid unit target
-                            if (!(m_targets.getUnitTarget() && ((m_targets.getUnitTarget()->GetEntry() == 26125 && m_targets.getUnitTarget()->GetOwnerGUID() == m_caster->GetGUID())
-                                || (m_targets.getUnitTarget()->getDeathState() == CORPSE
-                                    && m_targets.getUnitTarget()->GetDisplayId() == m_targets.getUnitTarget()->GetNativeDisplayId()
-                                    && m_targets.getUnitTarget()->GetTypeId() == TYPEID_UNIT
-                                    && !m_targets.getUnitTarget()->ToCreature()->isDeadByDefault()
-                                    && !(m_targets.getUnitTarget()->GetCreatureTypeMask() & CREATURE_TYPEMASK_MECHANICAL_OR_ELEMENTAL)
-                                    && m_targets.getUnitTarget()->GetDisplayId() == m_targets.getUnitTarget()->GetNativeDisplayId()))))
-                            {
-                                CleanupTargetList();
-
-                                WorldObject* result = FindCorpseUsing <Trinity::ExplodeCorpseObjectCheck> ();
-
-                                if (result)
-                                {
-                                    switch (result->GetTypeId())
-                                    {
-                                        case TYPEID_UNIT:
-                                        case TYPEID_PLAYER:
-                                            m_targets.setUnitTarget((Unit*)result);
-                                            break;
-                                        default:
-                                            break;
-                                    }
-                                }
-                                else
-                                {
-                                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                                        m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id,true);
-                                    SendCastResult(SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW);
-                                    finish(false);
-                                }
-                            }
-                            break;
-
-                        default:
-                            sLog.outDebug("Spell (ID: %u) (caster Entry: %u) does not have type CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET record in `conditions` table.", m_spellInfo->Id, m_caster->GetEntry());
-
-                            if (m_spellInfo->Effect[i] == SPELL_EFFECT_TELEPORT_UNITS)
-                                SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ENTRY, 0);
-                            else if (IsPositiveEffect(m_spellInfo->Id, i))
-                                SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ALLY);
-                            else
-                                SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ENEMY);
-                    }
-                }
-                break;
-            }
-            case SPELL_TARGETS_GO:
-            {
-                ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET, m_spellInfo->Id);
-                if (!conditions.empty())
-                {
-                    for (ConditionList::const_iterator i_spellST = conditions.begin(); i_spellST != conditions.end(); ++i_spellST)
-                    {
-                        if ((*i_spellST)->mConditionType != CONDITION_SPELL_SCRIPT_TARGET)
-                            continue;
-                        if ((*i_spellST)->mConditionValue1 == SPELL_TARGET_TYPE_GAMEOBJECT)
-                            SearchGOAreaTarget(gobjectList, radius, pushType, SPELL_TARGETS_GO, (*i_spellST)->mConditionValue2);
-                    }
-                }
-                else
-                {
-                    if (m_spellInfo->Effect[i] == SPELL_EFFECT_ACTIVATE_OBJECT)
-                        sLog.outDebug("Spell (ID: %u) (caster Entry: %u) with SPELL_EFFECT_ACTIVATE_OBJECT does not have type CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET record in `conditions` table.", m_spellInfo->Id, m_caster->GetEntry());
-                    SearchGOAreaTarget(gobjectList, radius, pushType, SPELL_TARGETS_GO);
-                }
-                break;
-            }
-            case SPELL_TARGETS_ALLY:
-            case SPELL_TARGETS_ENEMY:
-            case SPELL_TARGETS_CHAINHEAL:
-            case SPELL_TARGETS_ANY:
-                SearchAreaTarget(unitList, radius, pushType, targetType);
-                break;
-            default:
-                switch (cur)
-                {
-                    case TARGET_UNIT_AREA_PARTY_SRC:
-                    case TARGET_UNIT_AREA_PARTY_DST:
-                        m_caster->GetPartyMemberInDist(unitList, radius); //fix me
-                        break;
-                    case TARGET_UNIT_PARTY_TARGET:
-                        m_targets.getUnitTarget()->GetPartyMemberInDist(unitList, radius);
-                        break;
-                    case TARGET_UNIT_PARTY_CASTER:
-                        m_caster->GetPartyMemberInDist(unitList, radius);
-                        break;
-                    case TARGET_UNIT_RAID_CASTER:
-                        m_caster->GetRaidMember(unitList, radius);
-                        break;
-                    case TARGET_UNIT_CLASS_TARGET:
-                    {
-                        Player* targetPlayer = m_targets.getUnitTarget() && m_targets.getUnitTarget()->GetTypeId() == TYPEID_PLAYER
-                            ? (Player*)m_targets.getUnitTarget() : NULL;
-
-                        Group* pGroup = targetPlayer ? targetPlayer->GetGroup() : NULL;
-                        if (pGroup)
-                        {
-                            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-                            {
-                                Player* Target = itr->getSource();
-
-                                // IsHostileTo check duel and controlled by enemy
-                                if (Target && targetPlayer->IsWithinDistInMap(Target, radius) &&
-                                    targetPlayer->getClass() == Target->getClass() &&
-                                    !m_caster->IsHostileTo(Target))
-                                {
-                                    AddUnitTarget(Target, i);
-                                }
-                            }
-                        }
-                        else if (m_targets.getUnitTarget())
-                            AddUnitTarget(m_targets.getUnitTarget(), i);
-                        break;
-                    }
-                }
-                break;
-            }
-
-        if (!unitList.empty())
-        {
-            // Special target selection for smart heals and energizes
-            uint32 maxSize = 0;
-            int32 power = -1;
-            switch (m_spellInfo->SpellFamilyName)
-            {
-                case SPELLFAMILY_GENERIC:
-                    switch (m_spellInfo->Id)
-                    {
-                        case 52759: // Ancestral Awakening
-                        case 71610: // Echoes of Light (Althor's Abacus normal version)
-                        case 71641: // Echoes of Light (Althor's Abacus heroic version)
-                            maxSize = 1;
-                            power = POWER_HEALTH;
-                            break;
-                        case 54968: // Glyph of Holy Light
-                            maxSize = m_spellInfo->MaxAffectedTargets;
-                            power = POWER_HEALTH;
-                            break;
-                        case 57669: // Replenishment
-                            // In arenas Replenishment may only affect the caster
-                            if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->InArena())
-                            {
-                                unitList.clear();
-                                unitList.push_back(m_caster);
-                                break;
-                            }
-                            maxSize = 10;
-                            power = POWER_MANA;
-                            break;
-                        default:
-                            break;
-                    }
-                    break;
-                case SPELLFAMILY_PRIEST:
-                    if (m_spellInfo->SpellFamilyFlags[0] == 0x10000000) // Circle of Healing
-                    {
-                        maxSize = m_caster->HasAura(55675) ? 6 : 5; // Glyph of Circle of Healing
-                        power = POWER_HEALTH;
-                    }
-                    else if (m_spellInfo->Id == 64844) // Divine Hymn
-                    {
-                        maxSize = 3;
-                        power = POWER_HEALTH;
-                    }
-                    else if (m_spellInfo->Id == 64904) // Hymn of Hope
-                    {
-                        maxSize = 3;
-                        power = POWER_MANA;
-                    }
-                    else
-                        break;
-
-                    // Remove targets outside caster's raid
-                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
-                    {
-                        if (!(*itr)->IsInRaidWith(m_caster))
-                            itr = unitList.erase(itr);
-                        else
-                            ++itr;
-                    }
-                    break;
-                case SPELLFAMILY_DRUID:
-                    if (m_spellInfo->SpellFamilyFlags[1] == 0x04000000) // Wild Growth
-                    {
-                        maxSize = m_caster->HasAura(62970) ? 6 : 5; // Glyph of Wild Growth
-                        power = POWER_HEALTH;
-                    }
-                    else
-                        break;
-
-                    // Remove targets outside caster's raid
-                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
-                    {
-                        if (!(*itr)->IsInRaidWith(m_caster))
-                            itr = unitList.erase(itr);
-                        else
-                            ++itr;
-                    }
-                    break;
-                default:
-                    break;
-            }
-
-            if (maxSize && power != -1)
-            {
-                if (Powers(power) == POWER_HEALTH)
-                {
-                    if (unitList.size() > maxSize)
-                    {
-                        unitList.sort(Trinity::HealthPctOrderPred());
-                        unitList.resize(maxSize);
-                    }
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "DatabaseEnv.h"
+#include "WorldPacket.h"
+#include "WorldSession.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Opcodes.h"
+#include "Log.h"
+#include "UpdateMask.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "Pet.h"
+#include "Unit.h"
+#include "Totem.h"
+#include "Spell.h"
+#include "DynamicObject.h"
+#include "Group.h"
+#include "UpdateData.h"
+#include "MapManager.h"
+#include "ObjectAccessor.h"
+#include "CellImpl.h"
+#include "SharedDefines.h"
+#include "LootMgr.h"
+#include "VMapFactory.h"
+#include "Battleground.h"
+#include "Util.h"
+#include "TemporarySummon.h"
+#include "Vehicle.h"
+#include "SpellAuraEffects.h"
+#include "ScriptMgr.h"
+#include "ConditionMgr.h"
+#include "DisableMgr.h"
+#include "SpellScript.h"
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+
+#define SPELL_CHANNEL_UPDATE_INTERVAL (1 * IN_MILLISECONDS)
+
+extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
+
+bool IsQuestTameSpell(uint32 spellId)
+{
+    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
+    if (!spellproto) return false;
+
+    return spellproto->Effect[0] == SPELL_EFFECT_THREAT
+        && spellproto->Effect[1] == SPELL_EFFECT_APPLY_AURA && spellproto->EffectApplyAuraName[1] == SPELL_AURA_DUMMY;
+}
+
+SpellCastTargets::SpellCastTargets() : m_elevation(0), m_speed(0)
+{
+    m_unitTarget = NULL;
+    m_itemTarget = NULL;
+    m_GOTarget   = NULL;
+
+    m_unitTargetGUID   = 0;
+    m_GOTargetGUID     = 0;
+    m_CorpseTargetGUID = 0;
+    m_itemTargetGUID   = 0;
+    m_itemTargetEntry  = 0;
+
+    m_srcTransGUID = 0;
+    m_srcTransOffset.Relocate(0, 0, 0, 0);
+    m_srcPos.Relocate(0, 0, 0, 0);
+    m_dstTransGUID = 0;
+    m_dstTransOffset.Relocate(0, 0, 0, 0);
+    m_dstPos.Relocate(0, 0, 0, 0);
+    m_strTarget = "";
+    m_targetMask = 0;
+}
+
+SpellCastTargets::~SpellCastTargets()
+{
+}
+
+void SpellCastTargets::setUnitTarget(Unit *target)
+{
+    if (!target)
+        return;
+
+    m_unitTarget = target;
+    m_unitTargetGUID = target->GetGUID();
+    m_targetMask |= TARGET_FLAG_UNIT;
+}
+
+void SpellCastTargets::setSrc(float x, float y, float z)
+{
+    m_srcPos.Relocate(x, y, z);
+    m_srcTransGUID = 0;
+    m_targetMask |= TARGET_FLAG_SOURCE_LOCATION;
+}
+
+void SpellCastTargets::setSrc(Position &pos)
+{
+    m_srcPos.Relocate(pos);
+    m_srcTransGUID = 0;
+    m_targetMask |= TARGET_FLAG_SOURCE_LOCATION;
+}
+
+void SpellCastTargets::setSrc(WorldObject &wObj)
+{
+    uint64 guid = wObj.GetTransGUID();
+    m_srcTransGUID = guid;
+    m_srcTransOffset.Relocate(wObj.GetTransOffsetX(), wObj.GetTransOffsetY(), wObj.GetTransOffsetZ(), wObj.GetTransOffsetO());
+    m_srcPos.Relocate(wObj);
+    m_targetMask |= TARGET_FLAG_SOURCE_LOCATION;
+}
+
+void SpellCastTargets::modSrc(Position &pos)
+{
+    ASSERT(m_targetMask & TARGET_FLAG_SOURCE_LOCATION);
+
+    if (m_srcTransGUID)
+    {
+        Position offset;
+        m_srcPos.GetPositionOffsetTo(pos, offset);
+        m_srcTransOffset.RelocateOffset(offset);
+    }
+    m_srcPos.Relocate(pos);
+}
+
+void SpellCastTargets::setDst(float x, float y, float z, float orientation, uint32 mapId)
+{
+    m_dstPos.Relocate(x, y, z, orientation);
+    m_dstTransGUID = 0;
+    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
+    if (mapId != MAPID_INVALID)
+        m_dstPos.m_mapId = mapId;
+}
+
+void SpellCastTargets::setDst(Position &pos)
+{
+    m_dstPos.Relocate(pos);
+    m_dstTransGUID = 0;
+    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
+}
+
+void SpellCastTargets::setDst(WorldObject &wObj)
+{
+    uint64 guid = wObj.GetTransGUID();
+    m_dstTransGUID = guid;
+    m_dstTransOffset.Relocate(wObj.GetTransOffsetX(), wObj.GetTransOffsetY(), wObj.GetTransOffsetZ(), wObj.GetTransOffsetO());
+    m_dstPos.Relocate(wObj);
+    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
+}
+
+void SpellCastTargets::setDst(SpellCastTargets &spellTargets)
+{
+    m_dstTransGUID = spellTargets.m_dstTransGUID;
+    m_dstTransOffset.Relocate(spellTargets.m_dstTransOffset);
+    m_dstPos.Relocate(spellTargets.m_dstPos);
+    m_targetMask |= TARGET_FLAG_DEST_LOCATION;
+}
+
+void SpellCastTargets::modDst(Position &pos)
+{
+    ASSERT(m_targetMask & TARGET_FLAG_DEST_LOCATION);
+
+    if (m_dstTransGUID)
+    {
+        Position offset;
+        m_dstPos.GetPositionOffsetTo(pos, offset);
+        m_dstTransOffset.RelocateOffset(offset);
+    }
+    m_dstPos.Relocate(pos);
+}
+
+void SpellCastTargets::setGOTarget(GameObject *target)
+{
+    m_GOTarget = target;
+    m_GOTargetGUID = target->GetGUID();
+    m_targetMask |= TARGET_FLAG_OBJECT;
+}
+
+void SpellCastTargets::setItemTarget(Item* item)
+{
+    if (!item)
+        return;
+
+    m_itemTarget = item;
+    m_itemTargetGUID = item->GetGUID();
+    m_itemTargetEntry = item->GetEntry();
+    m_targetMask |= TARGET_FLAG_ITEM;
+}
+
+void SpellCastTargets::setTradeItemTarget(Player* caster)
+{
+    m_itemTargetGUID = uint64(TRADE_SLOT_NONTRADED);
+    m_itemTargetEntry = 0;
+    m_targetMask |= TARGET_FLAG_TRADE_ITEM;
+
+    Update(caster);
+}
+
+void SpellCastTargets::setCorpseTarget(Corpse* corpse)
+{
+    m_CorpseTargetGUID = corpse->GetGUID();
+}
+
+void SpellCastTargets::Update(Unit* caster)
+{
+    m_GOTarget   = m_GOTargetGUID ? caster->GetMap()->GetGameObject(m_GOTargetGUID) : NULL;
+    m_unitTarget = m_unitTargetGUID ?
+        (m_unitTargetGUID == caster->GetGUID() ? caster : ObjectAccessor::GetUnit(*caster, m_unitTargetGUID)) :
+    NULL;
+
+    m_itemTarget = NULL;
+    if (caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        Player *player = caster->ToPlayer();
+        if (m_targetMask & TARGET_FLAG_ITEM)
+            m_itemTarget = player->GetItemByGuid(m_itemTargetGUID);
+        else if (m_targetMask & TARGET_FLAG_TRADE_ITEM)
+            if (m_itemTargetGUID == TRADE_SLOT_NONTRADED) // here it is not guid but slot. Also prevents hacking slots
+                if (TradeData* pTrade = player->GetTradeData())
+                    m_itemTarget = pTrade->GetTraderData()->GetItem(TRADE_SLOT_NONTRADED);
+
+        if (m_itemTarget)
+            m_itemTargetEntry = m_itemTarget->GetEntry();
+    }
+    // update positions by transport move
+    if (HasSrc() && m_srcTransGUID)
+    {
+        if (WorldObject * transport = ObjectAccessor::GetWorldObject(*caster, m_srcTransGUID))
+        {
+            m_srcPos.Relocate(transport);
+            m_srcPos.RelocateOffset(m_srcTransOffset);
+        }
+    }
+    if (HasDst() && m_dstTransGUID)
+    {
+        if (WorldObject * transport = ObjectAccessor::GetWorldObject(*caster, m_dstTransGUID))
+        {
+            m_dstPos.Relocate(transport);
+            m_dstPos.RelocateOffset(m_dstTransOffset);
+        }
+    }
+}
+
+void SpellCastTargets::OutDebug()
+{
+    if (!m_targetMask)
+        sLog.outString("TARGET_FLAG_SELF");
+
+    if (m_targetMask & TARGET_FLAG_UNIT)
+    {
+        sLog.outString("TARGET_FLAG_UNIT: " UI64FMTD, m_unitTargetGUID);
+    }
+    if (m_targetMask & TARGET_FLAG_UNK17)
+    {
+        sLog.outString("TARGET_FLAG_UNK17: " UI64FMTD, m_unitTargetGUID);
+    }
+    if (m_targetMask & TARGET_FLAG_OBJECT)
+    {
+        sLog.outString("TARGET_FLAG_OBJECT: " UI64FMTD, m_GOTargetGUID);
+    }
+    if (m_targetMask & TARGET_FLAG_CORPSE)
+    {
+        sLog.outString("TARGET_FLAG_CORPSE: " UI64FMTD, m_CorpseTargetGUID);
+    }
+    if (m_targetMask & TARGET_FLAG_PVP_CORPSE)
+    {
+        sLog.outString("TARGET_FLAG_PVP_CORPSE: " UI64FMTD, m_CorpseTargetGUID);
+    }
+    if (m_targetMask & TARGET_FLAG_ITEM)
+    {
+        sLog.outString("TARGET_FLAG_ITEM: " UI64FMTD, m_itemTargetGUID);
+    }
+    if (m_targetMask & TARGET_FLAG_TRADE_ITEM)
+    {
+        sLog.outString("TARGET_FLAG_TRADE_ITEM: " UI64FMTD, m_itemTargetGUID);
+    }
+    if (m_targetMask & TARGET_FLAG_SOURCE_LOCATION)
+    {
+        sLog.outString("TARGET_FLAG_SOURCE_LOCATION: transport guid:" UI64FMTD " trans offset: %s position: %s", m_srcTransGUID, m_srcTransOffset.ToString().c_str(), m_srcPos.ToString().c_str());
+    }
+    if (m_targetMask & TARGET_FLAG_DEST_LOCATION)
+    {
+        sLog.outString("TARGET_FLAG_DEST_LOCATION: transport guid:" UI64FMTD " trans offset: %s position: %s", m_dstTransGUID, m_dstTransOffset.ToString().c_str(), m_dstPos.ToString().c_str());
+    }
+    if (m_targetMask & TARGET_FLAG_STRING)
+    {
+        sLog.outString("TARGET_FLAG_STRING: %s", m_strTarget.c_str());
+    }
+    sLog.outString("speed: %f", m_speed);
+    sLog.outString("elevation: %f", m_elevation);
+}
+
+void SpellCastTargets::read (ByteBuffer & data, Unit * caster)
+{
+    data >> m_targetMask;
+
+    if (m_targetMask == TARGET_FLAG_SELF)
+        return;
+
+    if (m_targetMask & (TARGET_FLAG_UNIT | TARGET_FLAG_UNK17))
+        data.readPackGUID(m_unitTargetGUID);
+
+    if (m_targetMask & (TARGET_FLAG_OBJECT))
+        data.readPackGUID(m_GOTargetGUID);
+
+    if(m_targetMask & (TARGET_FLAG_ITEM | TARGET_FLAG_TRADE_ITEM))
+        data.readPackGUID(m_itemTargetGUID);
+
+    if(m_targetMask & (TARGET_FLAG_CORPSE | TARGET_FLAG_PVP_CORPSE))
+        data.readPackGUID(m_CorpseTargetGUID);
+
+    if (m_targetMask & TARGET_FLAG_SOURCE_LOCATION)
+    {
+        data.readPackGUID(m_srcTransGUID);
+        if (m_srcTransGUID)
+            data >> m_srcTransOffset.PositionXYZStream();
+        else
+            data >> m_srcPos.PositionXYZStream();
+    }
+    else
+    {
+        m_srcTransGUID = caster->GetTransGUID();
+        if (m_srcTransGUID)
+            m_srcTransOffset.Relocate(caster->GetTransOffsetX(), caster->GetTransOffsetY(), caster->GetTransOffsetZ(), caster->GetTransOffsetO());
+        else
+            m_srcPos.Relocate(caster);
+    }
+
+    if (m_targetMask & TARGET_FLAG_DEST_LOCATION)
+    {
+        data.readPackGUID(m_dstTransGUID);
+        if (m_dstTransGUID)
+            data >> m_dstTransOffset.PositionXYZStream();
+        else
+            data >> m_dstPos.PositionXYZStream();
+    }
+    else
+    {
+        m_dstTransGUID = caster->GetTransGUID();
+        if (m_dstTransGUID)
+            m_dstTransOffset.Relocate(caster->GetTransOffsetX(), caster->GetTransOffsetY(), caster->GetTransOffsetZ(), caster->GetTransOffsetO());
+        else
+            m_dstPos.Relocate(caster);
+    }
+
+    if(m_targetMask & TARGET_FLAG_STRING)
+        data >> m_strTarget;
+
+    Update(caster);
+}
+
+void SpellCastTargets::write (ByteBuffer & data)
+{
+    data << uint32(m_targetMask);
+
+    if (m_targetMask & (TARGET_FLAG_UNIT | TARGET_FLAG_PVP_CORPSE | TARGET_FLAG_OBJECT | TARGET_FLAG_CORPSE | TARGET_FLAG_UNK17))
+    {
+        if (m_targetMask & TARGET_FLAG_UNIT)
+        {
+            if (m_unitTarget)
+                data.append(m_unitTarget->GetPackGUID());
+            else
+                data << uint8(0);
+        }
+        else if (m_targetMask & TARGET_FLAG_OBJECT)
+        {
+            if(m_GOTarget)
+                data.append(m_GOTarget->GetPackGUID());
+            else
+                data << uint8(0);
+        }
+        else if (m_targetMask & ( TARGET_FLAG_CORPSE | TARGET_FLAG_PVP_CORPSE))
+            data.appendPackGUID(m_CorpseTargetGUID);
+        else
+            data << uint8(0);
+    }
+
+    if (m_targetMask & ( TARGET_FLAG_ITEM | TARGET_FLAG_TRADE_ITEM))
+    {
+        if(m_itemTarget)
+            data.append(m_itemTarget->GetPackGUID());
+        else
+            data << uint8(0);
+    }
+
+    if (m_targetMask & TARGET_FLAG_SOURCE_LOCATION)
+    {
+        data.appendPackGUID(m_srcTransGUID); // relative position guid here - transport for example
+        if (m_srcTransGUID)
+            data << m_srcTransOffset.PositionXYZStream();
+        else
+            data << m_srcPos.PositionXYZStream();
+    }
+
+    if (m_targetMask & TARGET_FLAG_DEST_LOCATION)
+    {
+        data.appendPackGUID(m_dstTransGUID); // relative position guid here - transport for example
+        if (m_dstTransGUID)
+            data << m_dstTransOffset.PositionXYZStream();
+        else
+            data << m_dstPos.PositionXYZStream();
+    }
+
+    if (m_targetMask & TARGET_FLAG_STRING)
+        data << m_strTarget;
+}
+
+Spell::Spell(Unit* Caster, SpellEntry const *info, bool triggered, uint64 originalCasterGUID, bool skipCheck):
+m_spellInfo(sSpellMgr.GetSpellForDifficultyFromSpell(info, Caster)),
+m_caster(Caster), m_spellValue(new SpellValue(m_spellInfo))
+{
+    m_customAttr = sSpellMgr.GetSpellCustomAttr(m_spellInfo->Id);
+    m_skipCheck = skipCheck;
+    m_selfContainer = NULL;
+    m_referencedFromCurrentSpell = false;
+    m_executedCurrently = false;
+    m_needComboPoints = NeedsComboPoints(m_spellInfo);
+    m_comboPointGain = 0;
+    m_delayStart = 0;
+    m_delayAtDamageCount = 0;
+
+    m_effectMask = 0;
+    m_auraScaleMask = 0;
+
+    // Get data for type of attack
+    switch (m_spellInfo->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_MELEE:
+            if (m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_REQ_OFFHAND)
+                m_attackType = OFF_ATTACK;
+            else
+                m_attackType = BASE_ATTACK;
+            break;
+        case SPELL_DAMAGE_CLASS_RANGED:
+            m_attackType = IsRangedWeaponSpell(m_spellInfo) ? RANGED_ATTACK : BASE_ATTACK;
+            break;
+        default:
+                                                            // Wands
+            if (m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG)
+                m_attackType = RANGED_ATTACK;
+            else
+                m_attackType = BASE_ATTACK;
+            break;
+    }
+
+    m_spellSchoolMask = GetSpellSchoolMask(info);           // Can be override for some spell (wand shoot for example)
+
+    if (m_attackType == RANGED_ATTACK)
+    {
+        // wand case
+        if ((m_caster->getClassMask() & CLASSMASK_WAND_USERS) != 0 && m_caster->GetTypeId() == TYPEID_PLAYER)
+        {
+            if (Item* pItem = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK))
+                m_spellSchoolMask = SpellSchoolMask(1 << pItem->GetProto()->Damage[0].DamageType);
+        }
+    }
+
+    if (originalCasterGUID)
+        m_originalCasterGUID = originalCasterGUID;
+    else
+        m_originalCasterGUID = m_caster->GetGUID();
+
+    if (m_originalCasterGUID == m_caster->GetGUID())
+        m_originalCaster = m_caster;
+    else
+    {
+        m_originalCaster = ObjectAccessor::GetUnit(*m_caster, m_originalCasterGUID);
+        if (m_originalCaster && !m_originalCaster->IsInWorld()) m_originalCaster = NULL;
+    }
+
+    m_spellState = SPELL_STATE_NULL;
+
+    m_IsTriggeredSpell = triggered;
+    m_CastItem = NULL;
+
+    unitTarget = NULL;
+    itemTarget = NULL;
+    gameObjTarget = NULL;
+    focusObject = NULL;
+    m_cast_count = 0;
+    m_glyphIndex = 0;
+    m_preCastSpell = 0;
+    m_triggeredByAuraSpell  = NULL;
+    m_spellAura = NULL;
+
+    //Auto Shot & Shoot (wand)
+    m_autoRepeat = IsAutoRepeatRangedSpell(m_spellInfo);
+
+    m_runesState = 0;
+    m_powerCost = 0;                                        // setup to correct value in Spell::prepare, don't must be used before.
+    m_casttime = 0;                                         // setup to correct value in Spell::prepare, don't must be used before.
+    m_timer = 0;                                            // will set to castime in prepare
+
+    m_channelTargetEffectMask = 0;
+
+    // determine reflection
+    m_canReflect = false;
+
+    if (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC && !IsAreaOfEffectSpell(m_spellInfo) && !(m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_CANT_REFLECTED))
+    {
+        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            if (m_spellInfo->Effect[j] == 0)
+                continue;
+
+            if (!IsPositiveTarget(m_spellInfo->EffectImplicitTargetA[j], m_spellInfo->EffectImplicitTargetB[j]))
+                m_canReflect = true;
+            else
+                m_canReflect = (m_spellInfo->AttributesEx & SPELL_ATTR_EX_NEGATIVE) ? true : false;
+
+            if (m_canReflect)
+                continue;
+            else
+                break;
+        }
+    }
+
+    CleanupTargetList();
+    CleanupEffectExecuteData();
+}
+
+Spell::~Spell()
+{
+    // unload scripts
+    while(!m_loadedScripts.empty())
+    {
+        std::list<SpellScript *>::iterator itr = m_loadedScripts.begin();
+        (*itr)->_Unload();
+        delete (*itr);
+        m_loadedScripts.erase(itr);
+    }
+
+    if (m_referencedFromCurrentSpell && m_selfContainer && *m_selfContainer == this)
+    {
+        // Clean the reference to avoid later crash.
+        // If this error is repeating, we may have to add an ASSERT to better track down how we get into this case.
+        sLog.outError("SPELL: deleting spell for spell ID %u. However, spell still referenced.", m_spellInfo->Id);
+        *m_selfContainer = NULL;
+    }
+
+    if (m_caster && m_caster->GetTypeId() == TYPEID_PLAYER)
+        ASSERT(m_caster->ToPlayer()->m_spellModTakingSpell != this);
+    delete m_spellValue;
+
+    CheckEffectExecuteData();
+}
+
+template<typename T>
+WorldObject* Spell::FindCorpseUsing()
+{
+    // non-standard target selection
+    float max_range = GetSpellMaxRange(m_spellInfo, false);
+
+    CellPair p(Trinity::ComputeCellPair(m_caster->GetPositionX(), m_caster->GetPositionY()));
+    Cell cell(p);
+    cell.data.Part.reserved = ALL_DISTRICT;
+    cell.SetNoCreate();
+
+    WorldObject* result = NULL;
+
+    T u_check(m_caster, max_range);
+    Trinity::WorldObjectSearcher<T> searcher(m_caster, result, u_check);
+
+    TypeContainerVisitor<Trinity::WorldObjectSearcher<T>, GridTypeMapContainer > grid_searcher(searcher);
+    cell.Visit(p, grid_searcher, *m_caster->GetMap(), *m_caster, max_range);
+
+    if (!result)
+    {
+        TypeContainerVisitor<Trinity::WorldObjectSearcher<T>, WorldTypeMapContainer > world_searcher(searcher);
+        cell.Visit(p, world_searcher, *m_caster->GetMap(), *m_caster, max_range);
+    }
+
+    return result;
+}
+
+void Spell::SelectSpellTargets()
+{
+    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        // not call for empty effect.
+        // Also some spells use not used effect targets for store targets for dummy effect in triggered spells
+        if (!m_spellInfo->Effect[i])
+            continue;
+
+        uint32 effectTargetType = EffectTargetType[m_spellInfo->Effect[i]];
+
+        // is it possible that areaaura is not applied to caster?
+        if (effectTargetType == SPELL_REQUIRE_NONE)
+            continue;
+
+        uint32 targetA = m_spellInfo->EffectImplicitTargetA[i];
+        uint32 targetB = m_spellInfo->EffectImplicitTargetB[i];
+
+        if (targetA)
+            SelectEffectTargets(i, targetA);
+        if (targetB) // In very rare case !A && B
+            SelectEffectTargets(i, targetB);
+
+        if (effectTargetType != SPELL_REQUIRE_UNIT)
+        {
+            if (effectTargetType == SPELL_REQUIRE_CASTER)
+                AddUnitTarget(m_caster, i);
+            else if (effectTargetType == SPELL_REQUIRE_ITEM)
+            {
+                if (m_targets.getItemTarget())
+                    AddItemTarget(m_targets.getItemTarget(), i);
+            }
+            continue;
+        }
+
+        if (!targetA && !targetB)
+        {
+            if (!GetSpellMaxRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex)))
+            {
+                AddUnitTarget(m_caster, i);
+                continue;
+            }
+
+            // add here custom effects that need default target.
+            // FOR EVERY TARGET TYPE THERE IS A DIFFERENT FILL!!
+            switch(m_spellInfo->Effect[i])
+            {
+                case SPELL_EFFECT_DUMMY:
+                {
+                    switch(m_spellInfo->Id)
+                    {
+                        case 20577:                         // Cannibalize
+                        case 54044:                         // Carrion Feeder
+                        {
+                            WorldObject* result = NULL;
+                            if (m_spellInfo->Id == 20577)
+                                result = FindCorpseUsing<Trinity::CannibalizeObjectCheck>();
+                            else
+                                result = FindCorpseUsing<Trinity::CarrionFeederObjectCheck>();
+
+                            if (result)
+                            {
+                                switch(result->GetTypeId())
+                                {
+                                    case TYPEID_UNIT:
+                                    case TYPEID_PLAYER:
+                                        AddUnitTarget((Unit*)result, i);
+                                        break;
+                                    case TYPEID_CORPSE:
+                                        m_targets.setCorpseTarget((Corpse*)result);
+                                        if (Player* owner = ObjectAccessor::FindPlayer(((Corpse*)result)->GetOwnerGUID()))
+                                            AddUnitTarget(owner, i);
+                                        break;
+                                    default:
+                                        break;
+                                }
+                            }
+                            else
+                            {
+                                // clear cooldown at fail
+                                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                                    m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id, true);
+                                SendCastResult(SPELL_FAILED_NO_EDIBLE_CORPSES);
+                                finish(false);
+                            }
+                            break;
+                        }
+                        default:
+                            if (m_targets.getUnitTarget())
+                                AddUnitTarget(m_targets.getUnitTarget(), i);
+                            else
+                                AddUnitTarget(m_caster, i);
+                            break;
+                    }
+                    break;
+                }
+                case SPELL_EFFECT_BIND:
+                case SPELL_EFFECT_RESURRECT:
+                case SPELL_EFFECT_CREATE_ITEM:
+                case SPELL_EFFECT_TRIGGER_SPELL:
+                case SPELL_EFFECT_SKILL_STEP:
+                case SPELL_EFFECT_PROFICIENCY:
+                case SPELL_EFFECT_SUMMON_OBJECT_WILD:
+                case SPELL_EFFECT_SELF_RESURRECT:
+                case SPELL_EFFECT_REPUTATION:
+                case SPELL_EFFECT_LEARN_SPELL:
+                case SPELL_EFFECT_SEND_TAXI:
+                    if (m_targets.getUnitTarget())
+                        AddUnitTarget(m_targets.getUnitTarget(), i);
+                    // Triggered spells have additional spell targets - cast them even if no explicit unit target is given (required for spell 50516 for example)
+                    else if (m_spellInfo->Effect[i] == SPELL_EFFECT_TRIGGER_SPELL)
+                        AddUnitTarget(m_caster, i);
+                    break;
+                case SPELL_EFFECT_SUMMON_PLAYER:
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->GetSelection())
+                    {
+                        Player* target = sObjectMgr.GetPlayer(m_caster->ToPlayer()->GetSelection());
+                        if (target)
+                            AddUnitTarget(target, i);
+                    }
+                    break;
+                case SPELL_EFFECT_RESURRECT_NEW:
+                    if (m_targets.getUnitTarget())
+                        AddUnitTarget(m_targets.getUnitTarget(), i);
+                    if (m_targets.getCorpseTargetGUID())
+                    {
+                        Corpse *corpse = ObjectAccessor::GetCorpse(*m_caster, m_targets.getCorpseTargetGUID());
+                        if (corpse)
+                        {
+                            Player* owner = ObjectAccessor::FindPlayer(corpse->GetOwnerGUID());
+                            if (owner)
+                                AddUnitTarget(owner, i);
+                        }
+                    }
+                    break;
+                case SPELL_EFFECT_SUMMON_CHANGE_ITEM:
+                case SPELL_EFFECT_ADD_FARSIGHT:
+                case SPELL_EFFECT_APPLY_GLYPH:
+                case SPELL_EFFECT_STUCK:
+                case SPELL_EFFECT_FEED_PET:
+                case SPELL_EFFECT_DESTROY_ALL_TOTEMS:
+                case SPELL_EFFECT_KILL_CREDIT2: // only one spell: 42793
+                    AddUnitTarget(m_caster, i);
+                    break;
+                case SPELL_EFFECT_LEARN_PET_SPELL:
+                    if (Guardian* pet = m_caster->GetGuardianPet())
+                        AddUnitTarget(pet, i);
+                    break;
+                /*case SPELL_EFFECT_ENCHANT_ITEM:
+                case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
+                case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
+                case SPELL_EFFECT_DISENCHANT:
+                case SPELL_EFFECT_PROSPECTING:
+                case SPELL_EFFECT_MILLING:
+                    if (m_targets.getItemTarget())
+                        AddItemTarget(m_targets.getItemTarget(), i);
+                    break;*/
+                case SPELL_EFFECT_APPLY_AURA:
+                    switch(m_spellInfo->EffectApplyAuraName[i])
+                    {
+                        case SPELL_AURA_ADD_FLAT_MODIFIER:  // some spell mods auras have 0 target modes instead expected TARGET_UNIT_CASTER(1) (and present for other ranks for same spell for example)
+                        case SPELL_AURA_ADD_PCT_MODIFIER:
+                            AddUnitTarget(m_caster, i);
+                            break;
+                        default:                            // apply to target in other case
+                            break;
+                    }
+                    break;
+                case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
+                                                            // AreaAura
+                    if (m_spellInfo->Attributes & (SPELL_ATTR_CASTABLE_WHILE_SITTING | SPELL_ATTR_CASTABLE_WHILE_MOUNTED | SPELL_ATTR_UNK18 | SPELL_ATTR_NOT_SHAPESHIFT) || m_spellInfo->Attributes == SPELL_ATTR_NOT_SHAPESHIFT)
+                        SelectEffectTargets(i, TARGET_UNIT_PARTY_TARGET);
+                    break;
+                case SPELL_EFFECT_SKIN_PLAYER_CORPSE:
+                    if (m_targets.getUnitTarget())
+                    {
+                        AddUnitTarget(m_targets.getUnitTarget(), i);
+                    }
+                    else if (m_targets.getCorpseTargetGUID())
+                    {
+                        Corpse *corpse = ObjectAccessor::GetCorpse(*m_caster,m_targets.getCorpseTargetGUID());
+                        if (corpse)
+                        {
+                            Player* owner = ObjectAccessor::FindPlayer(corpse->GetOwnerGUID());
+                            if (owner)
+                                AddUnitTarget(owner, i);
+                        }
+                    }
+                    break;
+                default:
+                    AddUnitTarget(m_caster, i);
+                    break;
+            }
+        }
+        if (IsChanneledSpell(m_spellInfo))
+        {
+            uint8 mask = (1<<i);
+            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+            {
+                if (ihit->effectMask & mask)
+                {
+                    m_channelTargetEffectMask |= mask;
+                    break;
+                }
+            }
+        }
+        else if (m_auraScaleMask)
+        {
+            bool checkLvl = !m_UniqueTargetInfo.empty();
+            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end();)
+            {
+                // remove targets which did not pass min level check
+                if (m_auraScaleMask && ihit->effectMask == m_auraScaleMask)
+                {
+                    // Do not check for selfcast
+                    if (!ihit->scaleAura && ihit->targetGUID != m_caster->GetGUID())
+                    {
+                         m_UniqueTargetInfo.erase(ihit++);
+                         continue;
+                    }
+                }
+                ++ihit;
+            }
+            if (checkLvl && m_UniqueTargetInfo.empty())
+            {
+                SendCastResult(SPELL_FAILED_LOWLEVEL);
+                finish(false);
+            }
+        }
+    }
+
+    if (m_targets.HasDst())
+    {
+        if (m_targets.HasTraj())
+        {
+            float speed = m_targets.GetSpeedXY();
+            if (speed > 0.0f)
+                m_delayMoment = (uint64)floor(m_targets.GetDist2d() / speed * 1000.0f);
+        }
+        else if (m_spellInfo->speed > 0.0f)
+        {
+            float dist = m_caster->GetDistance(m_targets.m_dstPos);
+            m_delayMoment = (uint64) floor(dist / m_spellInfo->speed * 1000.0f);
+        }
+    }
+}
+
+void Spell::prepareDataForTriggerSystem(AuraEffect const * /*triggeredByAura*/)
+{
+    //==========================================================================================
+    // Now fill data for trigger system, need know:
+    // can spell trigger another or not (m_canTrigger)
+    // Create base triggers flags for Attacker and Victim (m_procAttacker, m_procVictim and m_procEx)
+    //==========================================================================================
+
+    m_procVictim = m_procAttacker = 0;
+    // Get data for type of attack and fill base info for trigger
+    switch (m_spellInfo->DmgClass)
+    {
+        case SPELL_DAMAGE_CLASS_MELEE:
+            m_procAttacker = PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS;
+            if (m_attackType == OFF_ATTACK)
+                m_procAttacker |= PROC_FLAG_DONE_OFFHAND_ATTACK;
+            else
+                m_procAttacker |= PROC_FLAG_DONE_MAINHAND_ATTACK;
+            m_procVictim   = PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK;
+            break;
+        case SPELL_DAMAGE_CLASS_RANGED:
+            // Auto attack
+            if (m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG)
+            {
+                m_procAttacker = PROC_FLAG_DONE_RANGED_AUTO_ATTACK;
+                m_procVictim   = PROC_FLAG_TAKEN_RANGED_AUTO_ATTACK;
+            }
+            else // Ranged spell attack
+            {
+                m_procAttacker = PROC_FLAG_DONE_SPELL_RANGED_DMG_CLASS;
+                m_procVictim   = PROC_FLAG_TAKEN_SPELL_RANGED_DMG_CLASS;
+            }
+            break;
+        default:
+            if (m_spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON &&
+                m_spellInfo->EquippedItemSubClassMask & (1<<ITEM_SUBCLASS_WEAPON_WAND)
+                && m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_AUTOREPEAT_FLAG) // Wands auto attack
+            {
+                m_procAttacker = PROC_FLAG_DONE_RANGED_AUTO_ATTACK;
+                m_procVictim   = PROC_FLAG_TAKEN_RANGED_AUTO_ATTACK;
+            }
+            // For other spells trigger procflags are set in Spell::DoAllEffectOnTarget
+            // Because spell positivity is dependant on target
+    }
+    m_procEx= PROC_EX_NONE;
+
+    // Hunter trap spells - activation proc for Lock and Load, Entrapment and Misdirection
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_HUNTER &&
+        (m_spellInfo->SpellFamilyFlags[0] & 0x18 ||     // Freezing and Frost Trap, Freezing Arrow
+        m_spellInfo->Id == 57879 ||                     // Snake Trap - done this way to avoid double proc
+        m_spellInfo->SpellFamilyFlags[2] & 0x00024000)) // Explosive and Immolation Trap
+
+        m_procAttacker |= PROC_FLAG_DONE_TRAP_ACTIVATION;
+
+    /*
+        Effects which are result of aura proc from triggered spell cannot proc
+        to prevent chain proc of these spells
+    */
+
+    // Hellfire Effect - trigger as DOT
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->SpellFamilyFlags[0] & 0x00000040)
+    {
+        m_procAttacker = PROC_FLAG_DONE_PERIODIC;
+        m_procVictim   = PROC_FLAG_TAKEN_PERIODIC;
+    }
+
+    // Ranged autorepeat attack is set as triggered spell - ignore it
+    if (!(m_procAttacker & PROC_FLAG_DONE_RANGED_AUTO_ATTACK))
+    {
+        if (m_IsTriggeredSpell &&
+            (m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_TRIGGERED_CAN_TRIGGER ||
+            m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_TRIGGERED_CAN_TRIGGER_2))
+            m_procEx |= PROC_EX_INTERNAL_CANT_PROC;
+        else if (m_IsTriggeredSpell)
+            m_procEx |= PROC_EX_INTERNAL_TRIGGERED;
+    }
+    // Totem casts require spellfamilymask defined in spell_proc_event to proc
+    if (m_originalCaster && m_caster != m_originalCaster && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isTotem() && m_caster->IsControlledByPlayer())
+    {
+        m_procEx |= PROC_EX_INTERNAL_REQ_FAMILY;
+    }
+}
+
+void Spell::CleanupTargetList()
+{
+    m_UniqueTargetInfo.clear();
+    m_UniqueGOTargetInfo.clear();
+    m_UniqueItemInfo.clear();
+    m_delayMoment = 0;
+}
+
+void Spell::AddUnitTarget(Unit* pVictim, uint32 effIndex)
+{
+    if (m_spellInfo->Effect[effIndex] == 0)
+        return;
+
+    if (!CheckTarget(pVictim, effIndex))
+        return;
+		
+	// Skip if has aura "Recently Reapaired"
+ 	if (pVictim->HasAura(62705))
+ 	    return;	
+
+    // Check for effect immune skip if immuned
+    bool immuned = pVictim->IsImmunedToSpellEffect(m_spellInfo, effIndex);
+
+    uint64 targetGUID = pVictim->GetGUID();
+
+    // Lookup target in already in list
+    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        if (targetGUID == ihit->targetGUID)                 // Found in list
+        {
+            if (!immuned)
+                ihit->effectMask |= 1 << effIndex;          // Add only effect mask if not immuned
+            ihit->scaleAura = false;
+            if (m_auraScaleMask && ihit->effectMask == m_auraScaleMask && m_caster != pVictim)
+            {
+                SpellEntry const * auraSpell = sSpellStore.LookupEntry(sSpellMgr.GetFirstSpellInChain(m_spellInfo->Id));
+                if (uint32(pVictim->getLevel() + 10) >= auraSpell->spellLevel)
+                    ihit->scaleAura = true;
+            }
+            return;
+        }
+    }
+
+    // This is new target calculate data for him
+
+    // Get spell hit result on target
+    TargetInfo target;
+    target.targetGUID = targetGUID;                         // Store target GUID
+    target.effectMask = immuned ? 0 : 1 << effIndex;        // Store index of effect if not immuned
+    target.processed  = false;                              // Effects not apply on target
+    target.alive      = pVictim->isAlive();
+    target.damage     = 0;
+    target.crit       = false;
+    target.scaleAura  = false;
+    if (m_auraScaleMask && target.effectMask == m_auraScaleMask && m_caster != pVictim)
+    {
+        SpellEntry const * auraSpell = sSpellStore.LookupEntry(sSpellMgr.GetFirstSpellInChain(m_spellInfo->Id));
+        if (uint32(pVictim->getLevel() + 10) >= auraSpell->spellLevel)
+            target.scaleAura = true;
+    }
+
+    // Calculate hit result
+    if (m_originalCaster)
+    {
+        target.missCondition = m_originalCaster->SpellHitResult(pVictim, m_spellInfo, m_canReflect);
+        if (m_skipCheck && target.missCondition != SPELL_MISS_IMMUNE)
+            target.missCondition = SPELL_MISS_NONE;
+    }
+    else
+        target.missCondition = SPELL_MISS_EVADE; //SPELL_MISS_NONE;
+
+    // Spell have speed - need calculate incoming time
+    // Incoming time is zero for self casts. At least I think so.
+    if (m_spellInfo->speed > 0.0f && m_caster != pVictim)
+    {
+        // calculate spell incoming interval
+        // TODO: this is a hack
+        float dist = m_caster->GetDistance(pVictim->GetPositionX(), pVictim->GetPositionY(), pVictim->GetPositionZ());
+
+        if (dist < 5.0f) dist = 5.0f;
+        target.timeDelay = (uint64) floor(dist / m_spellInfo->speed * 1000.0f);
+
+        // Calculate minimum incoming time
+        if (m_delayMoment == 0 || m_delayMoment>target.timeDelay)
+            m_delayMoment = target.timeDelay;
+    }
+    else
+        target.timeDelay = 0LL;
+
+    // If target reflect spell back to caster
+    if (target.missCondition == SPELL_MISS_REFLECT)
+    {
+        // Calculate reflected spell result on caster
+        target.reflectResult =  m_caster->SpellHitResult(m_caster, m_spellInfo, m_canReflect);
+
+        if (target.reflectResult == SPELL_MISS_REFLECT)     // Impossible reflect again, so simply deflect spell
+            target.reflectResult = SPELL_MISS_PARRY;
+
+        // Increase time interval for reflected spells by 1.5
+        target.timeDelay += target.timeDelay >> 1;
+    }
+    else
+        target.reflectResult = SPELL_MISS_NONE;
+
+    // Add target to list
+    m_UniqueTargetInfo.push_back(target);
+}
+
+void Spell::AddUnitTarget(uint64 unitGUID, uint32 effIndex)
+{
+    if (Unit* unit = m_caster->GetGUID() == unitGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, unitGUID))
+        AddUnitTarget(unit, effIndex);
+}
+
+void Spell::AddGOTarget(GameObject* pVictim, uint32 effIndex)
+{
+    if (m_spellInfo->Effect[effIndex] == 0)
+        return;
+
+    uint64 targetGUID = pVictim->GetGUID();
+
+    // Lookup target in already in list
+    for (std::list<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
+    {
+        if (targetGUID == ihit->targetGUID)                 // Found in list
+        {
+            ihit->effectMask |= 1 << effIndex;              // Add only effect mask
+            return;
+        }
+    }
+
+    // This is new target calculate data for him
+
+    GOTargetInfo target;
+    target.targetGUID = targetGUID;
+    target.effectMask = 1 << effIndex;
+    target.processed  = false;                              // Effects not apply on target
+
+    // Spell have speed - need calculate incoming time
+    if (m_spellInfo->speed > 0.0f)
+    {
+        // calculate spell incoming interval
+        float dist = m_caster->GetDistance(pVictim->GetPositionX(), pVictim->GetPositionY(), pVictim->GetPositionZ());
+        if (dist < 5.0f) dist = 5.0f;
+        target.timeDelay = (uint64) floor(dist / m_spellInfo->speed * 1000.0f);
+        if (m_delayMoment == 0 || m_delayMoment>target.timeDelay)
+            m_delayMoment = target.timeDelay;
+    }
+    else
+        target.timeDelay = 0LL;
+
+    // Add target to list
+    m_UniqueGOTargetInfo.push_back(target);
+}
+
+void Spell::AddGOTarget(uint64 goGUID, uint32 effIndex)
+{
+    GameObject* go = m_caster->GetMap()->GetGameObject(goGUID);
+    if (go)
+        AddGOTarget(go, effIndex);
+}
+
+void Spell::AddItemTarget(Item* pitem, uint32 effIndex)
+{
+    if (m_spellInfo->Effect[effIndex] == 0)
+        return;
+
+    // Lookup target in already in list
+    for (std::list<ItemTargetInfo>::iterator ihit = m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
+    {
+        if (pitem == ihit->item)                            // Found in list
+        {
+            ihit->effectMask |= 1<<effIndex;                // Add only effect mask
+            return;
+        }
+    }
+
+    // This is new target add data
+
+    ItemTargetInfo target;
+    target.item       = pitem;
+    target.effectMask = 1 << effIndex;
+    m_UniqueItemInfo.push_back(target);
+}
+
+void Spell::DoAllEffectOnTarget(TargetInfo *target)
+{
+    if (!target || target->processed)
+        return;
+
+    target->processed = true;                               // Target checked in apply effects procedure
+
+    // Get mask of effects for target
+    uint8 mask = target->effectMask;
+
+    Unit* unit = m_caster->GetGUID() == target->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster,target->targetGUID);
+    if (!unit)
+    {
+        uint8 farMask = 0;
+        // create far target mask
+        for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (IsFarUnitTargetEffect(m_spellInfo->Effect[i]))
+                if ((1<<i) & mask)
+                    farMask |= (1<<i);
+        }
+        if (!farMask)
+            return;
+        // find unit in world
+        unit = ObjectAccessor::FindUnit(target->targetGUID);
+        if (!unit)
+            return;
+        // do far effects on the unit
+        // can't use default call because of threading, do stuff as fast as possible
+        for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (farMask & (1<<i))
+                HandleEffects(unit,NULL,NULL,i);
+        }
+        return;
+    }
+
+    if (unit->isAlive() != target->alive)
+        return;
+
+    // Get original caster (if exist) and calculate damage/healing from him data
+    Unit *caster = m_originalCaster ? m_originalCaster : m_caster;
+
+    // Skip if m_originalCaster not avaiable
+    if (!caster)
+        return;
+
+    SpellMissInfo missInfo = target->missCondition;
+
+    // Need init unitTarget by default unit (can changed in code on reflect)
+    // Or on missInfo != SPELL_MISS_NONE unitTarget undefined (but need in trigger subsystem)
+    unitTarget = unit;
+
+    // Reset damage/healing counter
+    m_damage = target->damage;
+    m_healing = -target->damage;
+
+    // Fill base trigger info
+    uint32 procAttacker = m_procAttacker;
+    uint32 procVictim   = m_procVictim;
+    uint32 procEx = m_procEx;
+
+    m_spellAura = NULL; // Set aura to null for every target-make sure that pointer is not used for unit without aura applied
+
+                            //Spells with this flag cannot trigger if effect is casted on self
+                            // Slice and Dice, relentless strikes, eviscerate
+    bool canEffectTrigger = unitTarget->CanProc() && (m_spellInfo->AttributesEx4 & (SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST) ? m_caster != unitTarget : true);
+    Unit * spellHitTarget = NULL;
+
+    if (missInfo == SPELL_MISS_NONE)                          // In case spell hit target, do all effect on that target
+        spellHitTarget = unit;
+    else if (missInfo == SPELL_MISS_REFLECT)                // In case spell reflect from target, do all effect on caster (if hit)
+    {
+        if (target->reflectResult == SPELL_MISS_NONE)       // If reflected spell hit caster -> do all effect on him
+        {
+            spellHitTarget = m_caster;
+            if (m_caster->GetTypeId() == TYPEID_UNIT)
+                m_caster->ToCreature()->LowerPlayerDamageReq(target->damage);
+        }
+    }
+
+    if (spellHitTarget)
+    {
+        SpellMissInfo missInfo = DoSpellHitOnUnit(spellHitTarget, mask, target->scaleAura);
+        if (missInfo != SPELL_MISS_NONE)
+        {
+            if (missInfo != SPELL_MISS_MISS)
+                m_caster->SendSpellMiss(unit, m_spellInfo->Id, missInfo);
+            m_damage = 0;
+            spellHitTarget = NULL;
+        }
+    }
+
+    // Do not take combo points on dodge and miss
+    if (m_needComboPoints && m_targets.getUnitTargetGUID() == target->targetGUID)
+        if (missInfo != SPELL_MISS_NONE)
+            m_needComboPoints = false;
+
+    // Trigger info was not filled in spell::preparedatafortriggersystem - we do it now
+    if (canEffectTrigger && !procAttacker && !procVictim)
+    {
+        bool positive = true;
+        if (m_damage > 0)
+            positive = false;
+        else if (!m_healing)
+        {
+            for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
+                // If at least one effect negative spell is negative hit
+                if (mask & (1<<i) && !IsPositiveEffect(m_spellInfo->Id, i))
+                {
+                    positive = false;
+                    break;
+                }
+        }
+        switch(m_spellInfo->DmgClass)
+        {
+            case SPELL_DAMAGE_CLASS_MAGIC:
+                if (positive)
+                {
+                    procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS;
+                    procVictim   |= PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS;
+                }
+                else
+                {
+                    procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG;
+                    procVictim   |= PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG;
+                }
+            break;
+            case SPELL_DAMAGE_CLASS_NONE:
+                if (positive)
+                {
+                    procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS;
+                    procVictim   |= PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_POS;
+                }
+                else
+                {
+                    procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_NEG;
+                    procVictim   |= PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_NEG;
+                }
+            break;
+        }
+    }
+    CallScriptOnHitHandlers();
+
+    // All calculated do it!
+    // Do healing and triggers
+    if (m_healing > 0)
+    {
+        bool crit = caster->isSpellCrit(unitTarget, m_spellInfo, m_spellSchoolMask);
+        uint32 addhealth = m_healing;
+        if (crit)
+        {
+            procEx |= PROC_EX_CRITICAL_HIT;
+            addhealth = caster->SpellCriticalHealingBonus(m_spellInfo, addhealth, NULL);
+        }
+        else
+            procEx |= PROC_EX_NORMAL_HIT;
+
+        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
+        if (canEffectTrigger && missInfo != SPELL_MISS_REFLECT)
+            caster->ProcDamageAndSpell(unitTarget, procAttacker, procVictim, procEx, addhealth, m_attackType, m_spellInfo, m_triggeredByAuraSpell);
+
+        int32 gain = caster->HealBySpell(unitTarget, m_spellInfo, addhealth, crit);
+        unitTarget->getHostileRefManager().threatAssist(caster, float(gain) * 0.5f, m_spellInfo);
+    }
+    // Do damage and triggers
+    else if (m_damage > 0)
+    {
+        // Fill base damage struct (unitTarget - is real spell target)
+        SpellNonMeleeDamage damageInfo(caster, unitTarget, m_spellInfo->Id, m_spellSchoolMask);
+
+        // Add bonuses and fill damageInfo struct
+        caster->CalculateSpellDamageTaken(&damageInfo, m_damage, m_spellInfo, m_attackType,  target->crit);
+        caster->DealDamageMods(damageInfo.target,damageInfo.damage,&damageInfo.absorb);
+
+        // Send log damage message to client
+        caster->SendSpellNonMeleeDamageLog(&damageInfo);
+
+        procEx |= createProcExtendMask(&damageInfo, missInfo);
+        procVictim |= PROC_FLAG_TAKEN_DAMAGE;
+
+        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
+        if (canEffectTrigger && missInfo != SPELL_MISS_REFLECT)
+        {
+            caster->ProcDamageAndSpell(unitTarget, procAttacker, procVictim, procEx, damageInfo.damage, m_attackType, m_spellInfo, m_triggeredByAuraSpell);
+            if (caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->Attributes & SPELL_ATTR_STOP_ATTACK_TARGET) == 0 &&
+               (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+                caster->ToPlayer()->CastItemCombatSpell(unitTarget, m_attackType, procVictim, procEx);
+        }
+
+        caster->DealSpellDamage(&damageInfo, true);
+
+        // Haunt
+        if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->SpellFamilyFlags[1] & 0x40000 && m_spellAura && m_spellAura->GetEffect(1))
+        {
+            AuraEffect * aurEff = m_spellAura->GetEffect(1);
+            aurEff->SetAmount(aurEff->GetAmount() * damageInfo.damage / 100);
+        }
+    }
+    // Passive spell hits/misses or active spells only misses (only triggers)
+    else
+    {
+        // Fill base damage struct (unitTarget - is real spell target)
+        SpellNonMeleeDamage damageInfo(caster, unitTarget, m_spellInfo->Id, m_spellSchoolMask);
+        procEx |= createProcExtendMask(&damageInfo, missInfo);
+        // Do triggers for unit (reflect triggers passed on hit phase for correct drop charge)
+        if (canEffectTrigger && missInfo != SPELL_MISS_REFLECT)
+            caster->ProcDamageAndSpell(unit, procAttacker, procVictim, procEx, 0, m_attackType, m_spellInfo, m_triggeredByAuraSpell);
+
+        // Failed Pickpocket, reveal rogue
+        if (missInfo == SPELL_MISS_RESIST
+            && m_customAttr & SPELL_ATTR_CU_PICKPOCKET
+            && unitTarget->GetTypeId() == TYPEID_UNIT)
+        {
+            m_caster->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);
+            if (unitTarget->ToCreature()->IsAIEnabled)
+                unitTarget->ToCreature()->AI()->AttackStart(m_caster);
+        }
+    }
+
+    if (m_caster && !m_caster->IsFriendlyTo(unit) && !IsPositiveSpell(m_spellInfo->Id))
+    {
+        m_caster->CombatStart(unit, !(m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_NO_INITIAL_AGGRO));
+
+        if (m_customAttr & SPELL_ATTR_CU_AURA_CC)
+            if (!unit->IsStandState())
+                unit->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+
+    if (spellHitTarget)
+    {
+        //AI functions
+        if (spellHitTarget->GetTypeId() == TYPEID_UNIT)
+        {
+            if (spellHitTarget->ToCreature()->IsAIEnabled)
+                spellHitTarget->ToCreature()->AI()->SpellHit(m_caster, m_spellInfo);
+
+            // cast at creature (or GO) quest objectives update at successful cast finished (+channel finished)
+            // ignore pets or autorepeat/melee casts for speed (not exist quest for spells (hm...)
+            if (m_originalCaster && m_originalCaster->IsControlledByPlayer() && !spellHitTarget->ToCreature()->isPet() && !IsAutoRepeat() && !IsNextMeleeSwingSpell() && !IsChannelActive())
+                if (Player* p = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself())
+                    p->CastedCreatureOrGO(spellHitTarget->GetEntry(),spellHitTarget->GetGUID(),m_spellInfo->Id);
+        }
+
+        if (m_caster && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsAIEnabled)
+            m_caster->ToCreature()->AI()->SpellHitTarget(spellHitTarget, m_spellInfo);
+
+        // Needs to be called after dealing damage/healing to not remove breaking on damage auras
+        DoTriggersOnSpellHit(spellHitTarget);
+
+        // if target is fallged for pvp also flag caster if a player
+        if (unit->IsPvP())
+        {
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            m_caster->ToPlayer()->UpdatePvP(true);
+        }
+
+        CallScriptAfterHitHandlers();
+    }
+}
+
+SpellMissInfo Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask, bool scaleAura)
+{
+    if (!unit || !effectMask)
+        return SPELL_MISS_EVADE;
+
+    // Recheck immune (only for delayed spells)
+    if (m_spellInfo->speed && (unit->IsImmunedToDamage(m_spellInfo) || unit->IsImmunedToSpell(m_spellInfo)))
+        return SPELL_MISS_IMMUNE;
+
+    PrepareScriptHitHandlers();
+    CallScriptBeforeHitHandlers();
+
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+    {
+        unit->ToPlayer()->GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_SPELL_TARGET, m_spellInfo->Id);
+        unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, m_spellInfo->Id, 0, m_caster);
+        unit->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET2, m_spellInfo->Id);
+    }
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        m_caster->ToPlayer()->GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_SPELL_CASTER, m_spellInfo->Id);
+        m_caster->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CAST_SPELL2, m_spellInfo->Id, 0, unit);
+    }
+
+    if (m_caster != unit)
+    {
+        // Recheck  UNIT_FLAG_NON_ATTACKABLE for delayed spells
+        if (m_spellInfo->speed > 0.0f &&
+            unit->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) &&
+            unit->GetCharmerOrOwnerGUID() != m_caster->GetGUID())
+        {
+            return SPELL_MISS_EVADE;
+        }
+
+        if (!m_caster->IsFriendlyTo(unit))
+        {
+            // reset damage to 0 if target has Invisibility and isn't visible for caster
+            // I do not think this is a correct way to fix it. Sanctuary effect should make all delayed spells invalid
+            // for delayed spells ignore not visible explicit target
+            if (m_spellInfo->speed > 0.0f && unit == m_targets.getUnitTarget()
+                && (unit->m_invisibilityMask || m_caster->m_invisibilityMask)
+                && !m_caster->canSeeOrDetect(unit, true))
+            {
+                // that was causing CombatLog errors
+                // return SPELL_MISS_EVADE;
+                return SPELL_MISS_MISS; // miss = do not send anything here
+            }
+
+            unit->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_HITBYSPELL);
+            //TODO: This is a hack. But we do not know what types of stealth should be interrupted by CC
+            if ((m_customAttr & SPELL_ATTR_CU_AURA_CC) && unit->IsControlledByPlayer())
+                unit->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+        }
+        else
+        {
+            // for delayed spells ignore negative spells (after duel end) for friendly targets
+            // TODO: this cause soul transfer bugged
+            if (m_spellInfo->speed > 0.0f && unit->GetTypeId() == TYPEID_PLAYER && !IsPositiveSpell(m_spellInfo->Id))
+            {
+                return SPELL_MISS_EVADE;
+            }
+
+            // assisting case, healing and resurrection
+            if (unit->hasUnitState(UNIT_STAT_ATTACK_PLAYER))
+            {
+                m_caster->SetContestedPvP();
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    m_caster->ToPlayer()->UpdatePvP(true);
+            }
+            if (unit->isInCombat() && !(m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_NO_INITIAL_AGGRO))
+            {
+                m_caster->SetInCombatState(unit->GetCombatTimer() > 0, unit);
+                unit->getHostileRefManager().threatAssist(m_caster, 0.0f);
+            }
+        }
+    }
+
+    // Get Data Needed for Diminishing Returns, some effects may have multiple auras, so this must be done on spell hit, not aura add
+    m_diminishGroup = GetDiminishingReturnsGroupForSpell(m_spellInfo,m_triggeredByAuraSpell);
+    if (m_diminishGroup)
+    {
+        m_diminishLevel = unit->GetDiminishing(m_diminishGroup);
+        DiminishingReturnsType type = GetDiminishingReturnsGroupType(m_diminishGroup);
+        // Increase Diminishing on unit, current informations for actually casts will use values above
+        if ((type == DRTYPE_PLAYER && (unit->GetTypeId() == TYPEID_PLAYER || unit->ToCreature()->isPet() || unit->ToCreature()->isPossessedByPlayer())) || type == DRTYPE_ALL)
+            unit->IncrDiminishing(m_diminishGroup);
+    }
+
+    uint8 aura_effmask = 0;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        if (effectMask & (1<<i) && IsUnitOwnedAuraEffect(m_spellInfo->Effect[i]))
+            aura_effmask |= 1<<i;
+
+    if (aura_effmask)
+    {
+        // Select rank for aura with level requirements only in specific cases
+        // Unit has to be target only of aura effect, both caster and target have to be players, target has to be other than unit target
+        SpellEntry const * aurSpellInfo = m_spellInfo;
+        int32 basePoints[3];
+        if (scaleAura)
+        {
+            aurSpellInfo = sSpellMgr.SelectAuraRankForPlayerLevel(m_spellInfo,unitTarget->getLevel());
+            ASSERT(aurSpellInfo);
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                basePoints[i] = aurSpellInfo->EffectBasePoints[i];
+                if (m_spellInfo->Effect[i] != aurSpellInfo->Effect[i])
+                {
+                    aurSpellInfo = m_spellInfo;
+                    break;
+                }
+            }
+        }
+
+        if (m_originalCaster)
+        {
+            m_spellAura = Aura::TryCreate(aurSpellInfo, effectMask, unit,
+                m_originalCaster,(aurSpellInfo == m_spellInfo)? &m_spellValue->EffectBasePoints[0] : &basePoints[0], m_CastItem);
+            if (m_spellAura)
+            {
+                // Now Reduce spell duration using data received at spell hit
+                int32 duration = m_spellAura->GetMaxDuration();
+                int32 limitduration = GetDiminishingReturnsLimitDuration(m_diminishGroup,aurSpellInfo);
+                float diminishMod = unit->ApplyDiminishingToDuration(m_diminishGroup, duration, m_originalCaster, m_diminishLevel,limitduration);
+
+                // unit is immune to aura if it was diminished to 0 duration
+                if (diminishMod == 0.0f)
+                {
+                    m_spellAura->Remove();
+                    return SPELL_MISS_IMMUNE;
+                }
+
+                ((UnitAura*)m_spellAura)->SetDiminishGroup(m_diminishGroup);
+
+                bool positive = IsPositiveSpell(m_spellAura->GetId());
+                AuraApplication * aurApp = m_spellAura->GetApplicationOfTarget(m_originalCaster->GetGUID());
+                if (aurApp)
+                    positive = aurApp->IsPositive();
+
+                duration = m_originalCaster->ModSpellDuration(aurSpellInfo, unit, duration, positive);
+
+                // Haste modifies duration of channeled spells
+                if (IsChanneledSpell(m_spellInfo))
+                    m_originalCaster->ModSpellCastTime(aurSpellInfo, duration, this);
+
+                // and duration of auras affected by SPELL_AURA_PERIODIC_HASTE
+                if (m_originalCaster->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_HASTE, aurSpellInfo))
+                    duration = int32(duration * m_originalCaster->GetFloatValue(UNIT_MOD_CAST_SPEED));
+
+                if (duration != m_spellAura->GetMaxDuration())
+                {
+                    m_spellAura->SetMaxDuration(duration);
+                    m_spellAura->SetDuration(duration);
+                }
+                m_spellAura->_RegisterForTargets();
+            }
+        }
+    }
+
+    for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
+    {
+        if (effectMask & (1<<effectNumber))
+            HandleEffects(unit,NULL,NULL,effectNumber);
+    }
+
+    return SPELL_MISS_NONE;
+}
+
+void Spell::DoTriggersOnSpellHit(Unit *unit)
+{
+    // Apply additional spell effects to target
+    if (m_preCastSpell)
+    {
+        // Paladin immunity shields
+        if (m_preCastSpell == 61988)
+        {
+            // Cast Forbearance
+            m_caster->CastSpell(unit, 25771, true);
+            // Cast Avenging Wrath Marker
+            unit->CastSpell(unit, 61987, true);
+        }
+
+        // Avenging Wrath
+        if (m_preCastSpell == 61987)
+            // Cast the serverside immunity shield marker
+            m_caster->CastSpell(unit, 61988, true);
+
+        if (sSpellStore.LookupEntry(m_preCastSpell))
+            // Blizz seems to just apply aura without bothering to cast
+            m_caster->AddAura(m_preCastSpell, unit);
+    }
+
+    // spells with this flag can trigger only if not selfcast (eviscerate for example)
+    if (m_ChanceTriggerSpells.size() && (!((m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST) && unit == m_caster)))
+    {
+        int _duration=0;
+        for (ChanceTriggerSpells::const_iterator i = m_ChanceTriggerSpells.begin(); i != m_ChanceTriggerSpells.end(); ++i)
+        {
+            // SPELL_AURA_ADD_TARGET_TRIGGER auras shouldn't trigger auras without duration
+            // set duration equal to triggering spell
+            if (roll_chance_i(i->second))
+            {
+                m_caster->CastSpell(unit, i->first, true);
+                sLog.outDebug("Spell %d triggered spell %d by SPELL_AURA_ADD_TARGET_TRIGGER aura", m_spellInfo->Id, i->first->Id);
+            }
+            if (GetSpellDuration(i->first) == -1)
+            {
+                if (Aura * triggeredAur = unit->GetAura(i->first->Id, m_caster->GetGUID()))
+                {
+                    // get duration from aura-only once
+                    if (!_duration)
+                    {
+                        Aura * aur = unit->GetAura(m_spellInfo->Id, m_caster->GetGUID());
+                        _duration = aur ? aur->GetDuration() : -1;
+                    }
+                    triggeredAur->SetDuration(_duration);
+                }
+            }
+        }
+    }
+
+    if (m_customAttr & SPELL_ATTR_CU_LINK_HIT)
+    {
+        if (const std::vector<int32> *spell_triggered = sSpellMgr.GetSpellLinked(m_spellInfo->Id + SPELL_LINK_HIT))
+            for (std::vector<int32>::const_iterator i = spell_triggered->begin(); i != spell_triggered->end(); ++i)
+                if (*i < 0)
+                    unit->RemoveAurasDueToSpell(-(*i));
+                else
+                    unit->CastSpell(unit, *i, true, 0, 0, m_caster->GetGUID());
+    }
+}
+
+void Spell::DoAllEffectOnTarget(GOTargetInfo *target)
+{
+    if (target->processed)                                  // Check target
+        return;
+    target->processed = true;                               // Target checked in apply effects procedure
+
+    uint32 effectMask = target->effectMask;
+    if (!effectMask)
+        return;
+
+    GameObject* go = m_caster->GetMap()->GetGameObject(target->targetGUID);
+    if (!go)
+        return;
+
+    PrepareScriptHitHandlers();
+    CallScriptBeforeHitHandlers();
+
+    for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
+        if (effectMask & (1 << effectNumber))
+            HandleEffects(NULL, NULL, go, effectNumber);
+
+    CallScriptOnHitHandlers();
+
+    // cast at creature (or GO) quest objectives update at successful cast finished (+channel finished)
+    // ignore autorepeat/melee casts for speed (not exist quest for spells (hm...)
+    if (m_originalCaster && m_originalCaster->IsControlledByPlayer() && !IsAutoRepeat() && !IsNextMeleeSwingSpell() && !IsChannelActive())
+    {
+        if (Player* p = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself())
+            p->CastedCreatureOrGO(go->GetEntry(),go->GetGUID(),m_spellInfo->Id);
+    }
+    CallScriptAfterHitHandlers();
+}
+
+void Spell::DoAllEffectOnTarget(ItemTargetInfo *target)
+{
+    uint32 effectMask = target->effectMask;
+    if (!target->item || !effectMask)
+        return;
+
+    PrepareScriptHitHandlers();
+    CallScriptBeforeHitHandlers();
+
+    for (uint32 effectNumber = 0; effectNumber < MAX_SPELL_EFFECTS; ++effectNumber)
+        if (effectMask & (1 << effectNumber))
+            HandleEffects(NULL, target->item, NULL, effectNumber);
+
+    CallScriptOnHitHandlers();
+
+    CallScriptAfterHitHandlers();
+}
+
+bool Spell::UpdateChanneledTargetList()
+{
+    // Not need check return true
+    if (m_channelTargetEffectMask == 0)
+        return true;
+
+    uint8 channelTargetEffectMask = m_channelTargetEffectMask;
+    uint8 channelAuraMask = 0;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        if (m_spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
+            channelAuraMask |= 1<<i;
+
+    channelAuraMask &= channelTargetEffectMask;
+
+    float range = 0;
+    if (channelAuraMask)
+    {
+        range = GetSpellMaxRange(m_spellInfo, IsPositiveSpell(m_spellInfo->Id));
+        if (Player * modOwner = m_caster->GetSpellModOwner())
+            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
+    }
+
+    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        if (ihit->missCondition == SPELL_MISS_NONE && (channelTargetEffectMask & ihit->effectMask))
+        {
+            Unit *unit = m_caster->GetGUID() == ihit->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID);
+
+            if (!unit)
+                continue;
+
+            if (IsValidDeadOrAliveTarget(unit))
+            {
+                if (channelAuraMask & ihit->effectMask)
+                {
+                    if (AuraApplication * aurApp = unit->GetAuraApplication(m_spellInfo->Id, m_originalCasterGUID))
+                    {
+                        if (m_caster != unit && !m_caster->IsWithinDistInMap(unit,range))
+                        {
+                            ihit->effectMask &= ~aurApp->GetEffectMask();
+                            unit->RemoveAura(aurApp);
+                            continue;
+                        }
+                    }
+                    else // aura is dispelled
+                        continue;
+                }
+
+                channelTargetEffectMask &= ~ihit->effectMask;   // remove from need alive mask effect that have alive target
+            }
+        }
+    }
+
+    // is all effects from m_needAliveTargetMask have alive targets
+    return channelTargetEffectMask == 0;
+}
+
+// Helper for Chain Healing
+// Spell target first
+// Raidmates then descending by injury suffered (MaxHealth - Health)
+// Other players/mobs then descending by injury suffered (MaxHealth - Health)
+struct ChainHealingOrder : public std::binary_function<const Unit*, const Unit*, bool>
+{
+    const Unit* MainTarget;
+    ChainHealingOrder(Unit const* Target) : MainTarget(Target) {};
+    // functor for operator ">"
+    bool operator()(Unit const* _Left, Unit const* _Right) const
+    {
+        return (ChainHealingHash(_Left) < ChainHealingHash(_Right));
+    }
+
+    int32 ChainHealingHash(Unit const* Target) const
+    {
+        /*if (Target == MainTarget)
+            return 0;
+        else*/ if (Target->GetTypeId() == TYPEID_PLAYER && MainTarget->GetTypeId() == TYPEID_PLAYER &&
+           Target->ToPlayer()->IsInSameRaidWith(MainTarget->ToPlayer()))
+        {
+            if (Target->IsFullHealth())
+                return 40000;
+            else
+                return 20000 - Target->GetMaxHealth() + Target->GetHealth();
+        }
+        else
+            return 40000 - Target->GetMaxHealth() + Target->GetHealth();
+    }
+};
+
+void Spell::SearchChainTarget(std::list<Unit*> &TagUnitMap, float max_range, uint32 num, SpellTargets TargetType)
+{
+    Unit *cur = m_targets.getUnitTarget();
+    if (!cur)
+        return;
+
+    // Get spell max affected targets
+    /*uint32 unMaxTargets = m_spellInfo->MaxAffectedTargets;
+    Unit::AuraList const& mod = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_MAX_AFFECTED_TARGETS);
+    for (Unit::AuraList::const_iterator m = mod.begin(); m != mod.end(); ++m)
+    {
+        if (!(*m)->IsAffectedOnSpell(m_spellInfo))
+            continue;
+        unMaxTargets+=(*m)->GetAmount();
+    }*/
+
+    //FIXME: This very like horrible hack and wrong for most spells
+    if (m_spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+        max_range += num * CHAIN_SPELL_JUMP_RADIUS;
+
+    std::list<Unit*> tempUnitMap;
+    if (TargetType == SPELL_TARGETS_CHAINHEAL)
+    {
+        SearchAreaTarget(tempUnitMap, max_range, PUSH_CHAIN, SPELL_TARGETS_ALLY);
+        tempUnitMap.sort(ChainHealingOrder(m_caster));
+        //if (cur->IsFullHealth() && tempUnitMap.size())
+        //    cur = tempUnitMap.front();
+    }
+    else
+        SearchAreaTarget(tempUnitMap, max_range, PUSH_CHAIN, TargetType);
+    tempUnitMap.remove(cur);
+
+    while (num)
+    {
+        TagUnitMap.push_back(cur);
+        --num;
+
+        if (tempUnitMap.empty())
+            break;
+
+        std::list<Unit*>::iterator next;
+
+        if (TargetType == SPELL_TARGETS_CHAINHEAL)
+        {
+            next = tempUnitMap.begin();
+            while (cur->GetDistance(*next) > CHAIN_SPELL_JUMP_RADIUS
+                || !cur->IsWithinLOSInMap(*next))
+            {
+                ++next;
+                if (next == tempUnitMap.end())
+                    return;
+            }
+        }
+        else
+        {
+            tempUnitMap.sort(Trinity::ObjectDistanceOrderPred(cur));
+            next = tempUnitMap.begin();
+
+            if (cur->GetDistance(*next) > CHAIN_SPELL_JUMP_RADIUS)
+                break;
+            while ((m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE
+                && !m_caster->isInFrontInMap(*next, max_range))
+                || !m_caster->canSeeOrDetect(*next, false)
+                || !cur->IsWithinLOSInMap(*next))
+            {
+                ++next;
+                if (next == tempUnitMap.end() || cur->GetDistance(*next) > CHAIN_SPELL_JUMP_RADIUS)
+                    return;
+            }
+        }
+
+        cur = *next;
+        tempUnitMap.erase(next);
+    }
+}
+
+void Spell::SearchAreaTarget(std::list<Unit*> &TagUnitMap, float radius, SpellNotifyPushType type, SpellTargets TargetType, uint32 entry)
+{
+    if (TargetType == SPELL_TARGETS_GO)
+        return;
+
+    Position *pos;
+    switch(type)
+    {
+        case PUSH_DST_CENTER:
+            CheckDst();
+            pos = &m_targets.m_dstPos;
+            break;
+        case PUSH_SRC_CENTER:
+            CheckSrc();
+            pos = &m_targets.m_srcPos;
+            break;
+        case PUSH_CHAIN:
+        {
+            Unit *target = m_targets.getUnitTarget();
+            if (!target)
+            {
+                sLog.outError("SPELL: cannot find unit target for spell ID %u\n", m_spellInfo->Id);
+                return;
+            }
+            pos = target;
+            break;
+        }
+        default:
+            pos = m_caster;
+            break;
+    }
+
+    bool requireDeadTarget = bool(m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_REQUIRE_DEAD_TARGET);
+    Trinity::SpellNotifierCreatureAndPlayer notifier(m_caster, TagUnitMap, radius, type, TargetType, pos, entry, requireDeadTarget);
+    if ((m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_PLAYERS_ONLY)
+        || (TargetType == SPELL_TARGETS_ENTRY && !entry))
+        m_caster->GetMap()->VisitWorld(pos->m_positionX, pos->m_positionY, radius, notifier);
+    else
+        m_caster->GetMap()->VisitAll(pos->m_positionX, pos->m_positionY, radius, notifier);
+
+    if (m_customAttr & SPELL_ATTR_CU_EXCLUDE_SELF)
+        TagUnitMap.remove(m_caster);
+}
+
+void Spell::SearchGOAreaTarget(std::list<GameObject*> &TagGOMap, float radius, SpellNotifyPushType type, SpellTargets TargetType, uint32 entry)
+{
+    if (TargetType != SPELL_TARGETS_GO)
+        return;
+
+    Position *pos;
+    switch (type)
+    {
+        case PUSH_DST_CENTER:
+            CheckDst();
+            pos = &m_targets.m_dstPos;
+            break;
+        case PUSH_SRC_CENTER:
+            CheckSrc();
+            pos = &m_targets.m_srcPos;
+            break;
+        default:
+            pos = m_caster;
+            break;
+    }
+
+    Trinity::GameObjectInRangeCheck check(pos->m_positionX, pos->m_positionY, pos->m_positionZ, radius + 50, entry);
+    Trinity::GameObjectListSearcher<Trinity::GameObjectInRangeCheck> searcher(m_caster, TagGOMap, check);
+    m_caster->GetMap()->VisitGrid(pos->m_positionX, pos->m_positionY, radius, searcher);
+}
+
+WorldObject* Spell::SearchNearbyTarget(float range, SpellTargets TargetType)
+{
+    switch(TargetType)
+    {
+        case SPELL_TARGETS_ENTRY:
+        {
+            ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET, m_spellInfo->Id);
+            if (conditions.empty())
+            {
+                sLog.outDebug("Spell (ID: %u) (caster Entry: %u) does not have record in `conditions` for spell script target (ConditionSourceType 14)", m_spellInfo->Id, m_caster->GetEntry());
+                if (IsPositiveSpell(m_spellInfo->Id))
+                    return SearchNearbyTarget(range, SPELL_TARGETS_ALLY);
+                else
+                    return SearchNearbyTarget(range, SPELL_TARGETS_ENEMY);
+            }
+
+            Creature* creatureScriptTarget = NULL;
+            GameObject* goScriptTarget = NULL;
+
+            for (ConditionList::const_iterator i_spellST = conditions.begin(); i_spellST != conditions.end(); ++i_spellST)
+            {
+                if ((*i_spellST)->mConditionType != CONDITION_SPELL_SCRIPT_TARGET)
+                    continue;
+                switch((*i_spellST)->mConditionValue1)
+                {
+                    case SPELL_TARGET_TYPE_CONTROLLED:
+                        for (Unit::ControlList::iterator itr = m_caster->m_Controlled.begin(); itr != m_caster->m_Controlled.end(); ++itr)
+                            if ((*itr)->GetEntry() == (*i_spellST)->mConditionValue2 && (*itr)->IsWithinDistInMap(m_caster, range))
+                            {
+                                goScriptTarget = NULL;
+                                creatureScriptTarget = (*itr)->ToCreature();
+                                range = m_caster->GetDistance(creatureScriptTarget);
+                            }
+                        break;
+                    case SPELL_TARGET_TYPE_GAMEOBJECT:
+                        if ((*i_spellST)->mConditionValue2)
+                        {
+                            if (GameObject *go = m_caster->FindNearestGameObject((*i_spellST)->mConditionValue2, range))
+                            {
+                                // remember found target and range, next attempt will find more near target with another entry
+                                goScriptTarget = go;
+                                creatureScriptTarget = NULL;
+                                range = m_caster->GetDistance(goScriptTarget);
+                            }
+                        }
+                        else if (focusObject)          //Focus Object
+                        {
+                            float frange = m_caster->GetDistance(focusObject);
+                            if (range >= frange)
+                            {
+                                creatureScriptTarget = NULL;
+                                goScriptTarget = focusObject;
+                                range = frange;
+                            }
+                        }
+                        break;
+                    case SPELL_TARGET_TYPE_CREATURE:
+                        if (m_targets.getUnitTarget() && m_targets.getUnitTarget()->GetEntry() == (*i_spellST)->mConditionValue2)
+                            return m_targets.getUnitTarget();
+                    case SPELL_TARGET_TYPE_DEAD:
+                    default:
+                        if (Creature *cre = m_caster->FindNearestCreature((*i_spellST)->mConditionValue2, range, (*i_spellST)->mConditionValue1 != SPELL_TARGET_TYPE_DEAD))
+                        {
+                            creatureScriptTarget = cre;
+                            goScriptTarget = NULL;
+                            range = m_caster->GetDistance(creatureScriptTarget);
+                        }
+                        break;
+                }
+            }
+
+            if (creatureScriptTarget)
+                return creatureScriptTarget;
+            else
+                return goScriptTarget;
+        }
+        default:
+        case SPELL_TARGETS_ENEMY:
+        {
+            Unit *target = NULL;
+            Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(m_caster, m_caster, range);
+            Trinity::UnitLastSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(m_caster, target, u_check);
+            m_caster->VisitNearbyObject(range, searcher);
+            return target;
+        }
+        case SPELL_TARGETS_ALLY:
+        {
+            Unit *target = NULL;
+            Trinity::AnyFriendlyUnitInObjectRangeCheck u_check(m_caster, m_caster, range);
+            Trinity::UnitLastSearcher<Trinity::AnyFriendlyUnitInObjectRangeCheck> searcher(m_caster, target, u_check);
+            m_caster->VisitNearbyObject(range, searcher);
+            return target;
+        }
+    }
+}
+
+void Spell::SelectEffectTargets(uint32 i, uint32 cur)
+{
+    SpellNotifyPushType pushType = PUSH_NONE;
+    Player *modOwner = NULL;
+    if (m_originalCaster)
+        modOwner = m_originalCaster->GetSpellModOwner();
+
+    switch(SpellTargetType[cur])
+    {
+        case TARGET_TYPE_UNIT_CASTER:
+        {
+            switch(cur)
+            {
+                case TARGET_UNIT_CASTER:
+                    AddUnitTarget(m_caster, i);
+                    break;
+                case TARGET_UNIT_CASTER_FISHING:
+                {
+                    float min_dis = GetSpellMinRange(m_spellInfo, true);
+                    float max_dis = GetSpellMaxRange(m_spellInfo, true);
+                    float dis = (float)rand_norm() * (max_dis - min_dis) + min_dis;
+                    float x, y, z;
+                    m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE, dis);
+                    m_targets.setDst(x, y, z, m_caster->GetOrientation());
+                    break;
+                }
+                case TARGET_UNIT_MASTER:
+                    if (Unit* owner = m_caster->GetCharmerOrOwner())
+                        AddUnitTarget(owner, i);
+                    break;
+                case TARGET_UNIT_PET:
+                    if (Guardian* pet = m_caster->GetGuardianPet())
+                        AddUnitTarget(pet, i);
+                    break;
+                case TARGET_UNIT_SUMMONER:
+                    if (m_caster->isSummon())
+                        if (Unit* unit = m_caster->ToTempSummon()->GetSummoner())
+                            AddUnitTarget(unit, i);
+                    break;
+                case TARGET_UNIT_PARTY_CASTER:
+                case TARGET_UNIT_RAID_CASTER:
+                    pushType = PUSH_CASTER_CENTER;
+                    break;
+                case TARGET_UNIT_VEHICLE:
+                    if (Unit *vehicle = m_caster->GetVehicleBase())
+                        AddUnitTarget(vehicle, i);
+                    break;
+                case TARGET_UNIT_PASSENGER_0:
+                case TARGET_UNIT_PASSENGER_1:
+                case TARGET_UNIT_PASSENGER_2:
+                case TARGET_UNIT_PASSENGER_3:
+                case TARGET_UNIT_PASSENGER_4:
+                case TARGET_UNIT_PASSENGER_5:
+                case TARGET_UNIT_PASSENGER_6:
+                case TARGET_UNIT_PASSENGER_7:
+                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsVehicle())
+                        if (Unit *unit = m_caster->GetVehicleKit()->GetPassenger(cur - TARGET_UNIT_PASSENGER_0))
+                            AddUnitTarget(unit, i);
+                    break;
+            }
+            break;
+        }
+
+        case TARGET_TYPE_UNIT_TARGET:
+        {
+            Unit *target = m_targets.getUnitTarget();
+            if (!target)
+            {
+                sLog.outError("SPELL: no unit target for spell ID %u", m_spellInfo->Id);
+                break;
+            }
+
+            switch(cur)
+            {
+                case TARGET_UNIT_TARGET_ENEMY:
+                    if (Unit *magnet = m_caster->SelectMagnetTarget(target, m_spellInfo))
+                        if (magnet != target)
+                            m_targets.setUnitTarget(magnet);
+                    pushType = PUSH_CHAIN;
+                    break;
+                case TARGET_UNIT_TARGET_ANY:
+                    if (!IsPositiveSpell(m_spellInfo->Id))
+                        if (Unit *magnet = m_caster->SelectMagnetTarget(target, m_spellInfo))
+                            if (magnet != target)
+                                m_targets.setUnitTarget(magnet);
+                    pushType = PUSH_CHAIN;
+                    break;
+                case TARGET_UNIT_CHAINHEAL:
+                    pushType = PUSH_CHAIN;
+                    break;
+                case TARGET_UNIT_TARGET_ALLY:
+                case TARGET_UNIT_TARGET_RAID:
+                case TARGET_UNIT_TARGET_PARTY:
+                case TARGET_UNIT_TARGET_PUPPET:
+                    AddUnitTarget(target, i);
+                    break;
+                case TARGET_UNIT_PARTY_TARGET:
+                case TARGET_UNIT_CLASS_TARGET:
+                    pushType = PUSH_CASTER_CENTER; // not real
+                    break;
+            }
+            break;
+        }
+
+        case TARGET_TYPE_UNIT_NEARBY:
+        {
+            WorldObject *target = NULL;
+            float range;
+
+            switch(cur)
+            {
+                case TARGET_UNIT_NEARBY_ENEMY:
+                    range = GetSpellMaxRange(m_spellInfo, false);
+                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
+                    target = SearchNearbyTarget(range, SPELL_TARGETS_ENEMY);
+                    break;
+                case TARGET_UNIT_NEARBY_ALLY:
+                case TARGET_UNIT_NEARBY_ALLY_UNK:
+                case TARGET_UNIT_NEARBY_RAID:
+                    range = GetSpellMaxRange(m_spellInfo, true);
+                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
+                    target = SearchNearbyTarget(range, SPELL_TARGETS_ALLY);
+                    break;
+                case TARGET_UNIT_NEARBY_ENTRY:
+                case TARGET_GAMEOBJECT_NEARBY_ENTRY:
+                    range = GetSpellMaxRange(m_spellInfo, IsPositiveSpell(m_spellInfo->Id));
+                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
+                    target = SearchNearbyTarget(range, SPELL_TARGETS_ENTRY);
+                    break;
+            }
+
+            if (!target)
+                return;
+            else if (target->GetTypeId() == TYPEID_GAMEOBJECT)
+                AddGOTarget((GameObject*)target, i);
+            else
+            {
+                pushType = PUSH_CHAIN;
+
+                if (m_targets.getUnitTarget() != target)
+                    m_targets.setUnitTarget((Unit*)target);
+            }
+
+            break;
+        }
+
+        case TARGET_TYPE_AREA_SRC:
+            pushType = PUSH_SRC_CENTER;
+            break;
+
+        case TARGET_TYPE_AREA_DST:
+            pushType = PUSH_DST_CENTER;
+            break;
+
+        case TARGET_TYPE_AREA_CONE:
+            if (m_customAttr & SPELL_ATTR_CU_CONE_BACK)
+                pushType = PUSH_IN_BACK;
+            else if (m_customAttr & SPELL_ATTR_CU_CONE_LINE)
+                pushType = PUSH_IN_LINE;
+            else
+                pushType = PUSH_IN_FRONT;
+            break;
+
+        case TARGET_TYPE_DEST_CASTER: //4+8+2
+        {
+            if (cur == TARGET_SRC_CASTER)
+            {
+                m_targets.setSrc(*m_caster);
+                break;
+            }
+            else if (cur == TARGET_DST_CASTER)
+            {
+                m_targets.setDst(*m_caster);
+                break;
+            }
+
+            float angle, dist;
+
+            float objSize = m_caster->GetObjectSize();
+            dist = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, dist, this);
+            if (dist < objSize)
+                dist = objSize;
+            else if (cur == TARGET_DEST_CASTER_RANDOM)
+                dist = objSize + (dist - objSize) * (float)rand_norm();
+
+            switch(cur)
+            {
+                case TARGET_DEST_CASTER_FRONT_LEFT: angle = static_cast<float>(-M_PI/4);                   break;
+                case TARGET_DEST_CASTER_BACK_LEFT:  angle = static_cast<float>(-3*M_PI/4);                 break;
+                case TARGET_DEST_CASTER_BACK_RIGHT: angle = static_cast<float>(3*M_PI/4);                  break;
+                case TARGET_DEST_CASTER_FRONT_RIGHT:angle = static_cast<float>(M_PI/4);                    break;
+                case TARGET_MINION:
+                case TARGET_DEST_CASTER_FRONT_LEAP:
+                case TARGET_DEST_CASTER_FRONT:      angle = 0.0f;                                          break;
+                case TARGET_DEST_CASTER_BACK:       angle = static_cast<float>(M_PI);                      break;
+                case TARGET_DEST_CASTER_RIGHT:      angle = static_cast<float>(M_PI/2);                    break;
+                case TARGET_DEST_CASTER_LEFT:       angle = static_cast<float>(-M_PI/2);                   break;
+                default:                            angle = (float)rand_norm()*static_cast<float>(2*M_PI); break;
+            }
+
+            Position pos;
+            if (cur == TARGET_DEST_CASTER_FRONT_LEAP)
+                m_caster->GetFirstCollisionPosition(pos, dist, angle);
+            else
+                m_caster->GetNearPosition(pos, dist, angle);
+            m_targets.setDst(*m_caster);
+            m_targets.modDst(pos);
+            break;
+        }
+
+        case TARGET_TYPE_DEST_TARGET: //2+8+2
+        {
+            Unit *target = m_targets.getUnitTarget();
+            if (!target)
+            {
+                sLog.outError("SPELL: no unit target for spell ID %u", m_spellInfo->Id);
+                break;
+            }
+
+            if (cur == TARGET_DST_TARGET_ENEMY || cur == TARGET_DEST_TARGET_ANY)
+            {
+                m_targets.setDst(*target);
+                break;
+            }
+
+            float angle, dist;
+
+            float objSize = target->GetObjectSize();
+            dist = (float)target->GetSpellRadiusForTarget(target, sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            if (dist < objSize)
+                dist = objSize;
+            else if (cur == TARGET_DEST_CASTER_RANDOM)
+                dist = objSize + (dist - objSize) * (float)rand_norm();
+
+            switch(cur)
+            {
+                case TARGET_DEST_TARGET_FRONT:      angle = 0.0f;                                          break;
+                case TARGET_DEST_TARGET_BACK:       angle = static_cast<float>(M_PI);                      break;
+                case TARGET_DEST_TARGET_RIGHT:      angle = static_cast<float>(M_PI/2);                    break;
+                case TARGET_DEST_TARGET_LEFT:       angle = static_cast<float>(-M_PI/2);                   break;
+                case TARGET_DEST_TARGET_FRONT_LEFT: angle = static_cast<float>(-M_PI/4);                   break;
+                case TARGET_DEST_TARGET_BACK_LEFT:  angle = static_cast<float>(-3*M_PI/4);                 break;
+                case TARGET_DEST_TARGET_BACK_RIGHT: angle = static_cast<float>(3*M_PI/4);                  break;
+                case TARGET_DEST_TARGET_FRONT_RIGHT:angle = static_cast<float>(M_PI/4);                    break;
+                default:                            angle = (float)rand_norm()*static_cast<float>(2*M_PI); break;
+            }
+
+            Position pos;
+            target->GetNearPosition(pos, dist, angle);
+            m_targets.setDst(*target);
+            m_targets.modDst(pos);
+            break;
+        }
+
+        case TARGET_TYPE_DEST_DEST: //5+8+1
+        {
+            if (!m_targets.HasDst())
+            {
+                sLog.outError("SPELL: no destination for spell ID %u", m_spellInfo->Id);
+                break;
+            }
+
+            float angle;
+            switch(cur)
+            {
+                case TARGET_DEST_DYNOBJ_ENEMY:
+                case TARGET_DEST_DYNOBJ_ALLY:
+                case TARGET_DEST_DYNOBJ_NONE:
+                case TARGET_DEST_DEST:
+                    return;
+                case TARGET_DEST_TRAJ:
+                    SelectTrajTargets();
+                    return;
+                case TARGET_DEST_DEST_FRONT:      angle = 0.0f;                                          break;
+                case TARGET_DEST_DEST_BACK:       angle = static_cast<float>(M_PI);                      break;
+                case TARGET_DEST_DEST_RIGHT:      angle = static_cast<float>(M_PI/2);                    break;
+                case TARGET_DEST_DEST_LEFT:       angle = static_cast<float>(-M_PI/2);                   break;
+                case TARGET_DEST_DEST_FRONT_LEFT: angle = static_cast<float>(-M_PI/4);                   break;
+                case TARGET_DEST_DEST_BACK_LEFT:  angle = static_cast<float>(-3*M_PI/4);                 break;
+                case TARGET_DEST_DEST_BACK_RIGHT: angle = static_cast<float>(3*M_PI/4);                  break;
+                case TARGET_DEST_DEST_FRONT_RIGHT:angle = static_cast<float>(M_PI/4);                    break;
+                default:                          angle = (float)rand_norm()*static_cast<float>(2*M_PI); break;
+            }
+
+            float dist;
+            dist = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+            if (cur == TARGET_DEST_DEST_RANDOM || cur == TARGET_DEST_DEST_RANDOM_DIR_DIST)
+                dist *= (float)rand_norm();
+
+            // must has dst, no need to set flag
+            Position pos = m_targets.m_dstPos;
+            m_caster->MovePosition(pos, dist, angle);
+            m_targets.modDst(pos);
+            break;
+        }
+
+        case TARGET_TYPE_DEST_SPECIAL:
+        {
+            switch(cur)
+            {
+                case TARGET_DST_DB:
+                    if (SpellTargetPosition const* st = sSpellMgr.GetSpellTargetPosition(m_spellInfo->Id))
+                    {
+                        //TODO: fix this check
+                        if (m_spellInfo->Effect[0] == SPELL_EFFECT_TELEPORT_UNITS
+                            || m_spellInfo->Effect[1] == SPELL_EFFECT_TELEPORT_UNITS
+                            || m_spellInfo->Effect[2] == SPELL_EFFECT_TELEPORT_UNITS)
+                            m_targets.setDst(st->target_X, st->target_Y, st->target_Z, st->target_Orientation, (int32)st->target_mapId);
+                        else if (st->target_mapId == m_caster->GetMapId())
+                            m_targets.setDst(st->target_X, st->target_Y, st->target_Z, st->target_Orientation);
+                    }
+                    else
+                    {
+                        sLog.outDebug("SPELL: unknown target coordinates for spell ID %u", m_spellInfo->Id);
+                        Unit *target = NULL;
+                        if (uint64 guid = m_caster->GetUInt64Value(UNIT_FIELD_TARGET))
+                            target = ObjectAccessor::GetUnit(*m_caster, guid);
+                        m_targets.setDst(target ? *target : *m_caster);
+                    }
+                    break;
+                case TARGET_DST_HOME:
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                        m_targets.setDst(m_caster->ToPlayer()->m_homebindX,m_caster->ToPlayer()->m_homebindY,m_caster->ToPlayer()->m_homebindZ, m_caster->ToPlayer()->GetOrientation(), m_caster->ToPlayer()->m_homebindMapId);
+                    break;
+                case TARGET_DST_NEARBY_ENTRY:
+                {
+                    float range = GetSpellMaxRange(m_spellInfo, IsPositiveSpell(m_spellInfo->Id));
+                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
+
+                    if (WorldObject *target = SearchNearbyTarget(range, SPELL_TARGETS_ENTRY))
+                        m_targets.setDst(*target);
+                    break;
+                }
+            }
+            break;
+        }
+
+        case TARGET_TYPE_CHANNEL:
+        {
+            if (!m_originalCaster || !m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+            {
+                sLog.outError("SPELL: no current channeled spell for spell ID %u", m_spellInfo->Id);
+                break;
+            }
+
+            switch (cur)
+            {
+                case TARGET_UNIT_CHANNEL_TARGET:
+                    // unit target may be no longer avalible - teleported out of map for example
+                    if (Unit* target = Unit::GetUnit(*m_caster, m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets.getUnitTargetGUID()))
+                        AddUnitTarget(target, i);
+                    else
+                        sLog.outError("SPELL: cannot find channel spell target for spell ID %u", m_spellInfo->Id);
+                    break;
+                case TARGET_DEST_CHANNEL_TARGET:
+                    if (m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets.HasDst())
+                        m_targets.setDst(m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets);
+                    else if (Unit* target = Unit::GetUnit(*m_caster, m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->m_targets.getUnitTargetGUID()))
+                        m_targets.setDst(*target);
+                    else
+                        sLog.outError("SPELL: cannot find channel spell destination for spell ID %u", m_spellInfo->Id);
+                    break;
+                case TARGET_DEST_CHANNEL_CASTER:
+                    m_targets.setDst(*m_originalCaster->GetCurrentSpell(CURRENT_CHANNELED_SPELL)->GetCaster());
+                    break;
+            }
+            break;
+        }
+
+        default:
+        {
+            switch (cur)
+            {
+                case TARGET_GAMEOBJECT:
+                    if (m_targets.getGOTarget())
+                        AddGOTarget(m_targets.getGOTarget(), i);
+                    break;
+                case TARGET_GAMEOBJECT_ITEM:
+                    if (m_targets.getGOTargetGUID())
+                        AddGOTarget(m_targets.getGOTarget(), i);
+                    else if (m_targets.getItemTarget())
+                        AddItemTarget(m_targets.getItemTarget(), i);
+                    break;
+                case TARGET_UNIT_DRIVER:
+                    if (Unit * driver = m_targets.getUnitTarget())
+                        if (driver->IsOnVehicle(driver))
+                            AddUnitTarget(driver, i);
+                    break;
+                default:
+                    sLog.outError("Unhandled spell target %u", cur);
+                    break;
+            }
+            break;
+        }
+    }
+
+    if (pushType == PUSH_CHAIN) // Chain
+    {
+        Unit *target = m_targets.getUnitTarget();
+        if (!target)
+        {
+            sLog.outError("SPELL: no chain unit target for spell ID %u", m_spellInfo->Id);
+            return;
+        }
+
+        //Chain: 2, 6, 22, 25, 45, 77
+        uint32 maxTargets = m_spellInfo->EffectChainTarget[i];
+        if (modOwner)
+            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_JUMP_TARGETS, maxTargets, this);
+
+        if (maxTargets > 1)
+        {
+            float range;
+            std::list<Unit*> unitList;
+
+            switch (cur)
+            {
+                case TARGET_UNIT_NEARBY_ENEMY:
+                case TARGET_UNIT_TARGET_ENEMY:
+                case TARGET_UNIT_NEARBY_ENTRY: // fix me
+                    range = GetSpellMaxRange(m_spellInfo, false);
+                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
+                    SearchChainTarget(unitList, range, maxTargets, SPELL_TARGETS_ENEMY);
+                    break;
+                case TARGET_UNIT_CHAINHEAL:
+                case TARGET_UNIT_NEARBY_ALLY:  // fix me
+                case TARGET_UNIT_NEARBY_ALLY_UNK:
+                case TARGET_UNIT_NEARBY_RAID:
+                    range = GetSpellMaxRange(m_spellInfo, true);
+                    if (modOwner) modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
+                    SearchChainTarget(unitList, range, maxTargets, SPELL_TARGETS_CHAINHEAL);
+                    break;
+            }
+
+            for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+                AddUnitTarget(*itr, i);
+        }
+        else
+            AddUnitTarget(target, i);
+    }
+    else if (pushType)
+    {
+        // Dummy, just for client
+        if (EffectTargetType[m_spellInfo->Effect[i]] != SPELL_REQUIRE_UNIT)
+            return;
+
+        float radius;
+        SpellTargets targetType;
+        switch(cur)
+        {
+            case TARGET_UNIT_AREA_ENEMY_SRC:
+            case TARGET_UNIT_AREA_ENEMY_DST:
+            case TARGET_UNIT_CONE_ENEMY:
+            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
+            case TARGET_UNIT_AREA_PATH:
+                radius = GetSpellRadius(m_spellInfo, i, false);
+                targetType = SPELL_TARGETS_ENEMY;
+                break;
+            case TARGET_UNIT_AREA_ALLY_SRC:
+            case TARGET_UNIT_AREA_ALLY_DST:
+            case TARGET_UNIT_CONE_ALLY:
+                radius = GetSpellRadius(m_spellInfo, i, true);
+                targetType = SPELL_TARGETS_ALLY;
+                break;
+            case TARGET_UNIT_AREA_ENTRY_DST:
+            case TARGET_UNIT_AREA_ENTRY_SRC:
+            case TARGET_UNIT_CONE_ENTRY: // fix me
+                radius = GetSpellRadius(m_spellInfo, i, IsPositiveSpell(m_spellInfo->Id));
+                targetType = SPELL_TARGETS_ENTRY;
+                break;
+            case TARGET_GAMEOBJECT_AREA_SRC:
+            case TARGET_GAMEOBJECT_AREA_DST:
+            case TARGET_GAMEOBJECT_AREA_PATH:
+                radius = GetSpellRadius(m_spellInfo, i, true);
+                targetType = SPELL_TARGETS_GO;
+                break;
+            default:
+                radius = GetSpellRadius(m_spellInfo, i, true);
+                targetType = SPELL_TARGETS_NONE;
+                break;
+        }
+
+        if (modOwner)
+            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, radius, this);
+        radius *= m_spellValue->RadiusMod;
+
+        std::list<Unit*> unitList;
+        std::list<GameObject*> gobjectList;
+        switch (targetType)
+        {
+            case SPELL_TARGETS_ENTRY:
+            {
+                ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET, m_spellInfo->Id);
+                if (!conditions.empty())
+                {
+                    for (ConditionList::const_iterator i_spellST = conditions.begin(); i_spellST != conditions.end(); ++i_spellST)
+                    {
+                        if ((*i_spellST)->mConditionType != CONDITION_SPELL_SCRIPT_TARGET)
+                            continue;
+                        if ((*i_spellST)->mConditionValue1 == SPELL_TARGET_TYPE_CREATURE)
+                            SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ENTRY, (*i_spellST)->mConditionValue2);
+                        else if ((*i_spellST)->mConditionValue1 == SPELL_TARGET_TYPE_CONTROLLED)
+                        {
+                            for (Unit::ControlList::iterator itr = m_caster->m_Controlled.begin(); itr != m_caster->m_Controlled.end(); ++itr)
+                                if ((*itr)->GetEntry() == (*i_spellST)->mConditionValue2 &&
+                                    /*(*itr)->IsWithinDistInMap(m_caster, radius)*/ (*itr)->IsInMap(m_caster)) // For 60243 and 52173 need skip radius check or use range (no radius entry for effect)
+                                    unitList.push_back(*itr);
+                        }
+                    }
+                }
+                else
+                {
+                    // Custom entries
+                    // TODO: move these to sql
+                    switch (m_spellInfo->Id)
+                    {
+                        case 46584: // Raise Dead
+                        {
+                            if (WorldObject* result = FindCorpseUsing<Trinity::RaiseDeadObjectCheck> ())
+                            {
+                                switch(result->GetTypeId())
+                                {
+                                    case TYPEID_UNIT:
+                                        m_targets.setDst(*result);
+                                        break;
+                                    default:
+                                        break;
+                                }
+                            }
+                            break;
+                        }
+                        // Corpse Explosion
+                        case 49158:
+                        case 51325:
+                        case 51326:
+                        case 51327:
+                        case 51328:
+                            // Search for ghoul if our ghoul or dead body not valid unit target
+                            if (!(m_targets.getUnitTarget() && ((m_targets.getUnitTarget()->GetEntry() == 26125 && m_targets.getUnitTarget()->GetOwnerGUID() == m_caster->GetGUID())
+                                || (m_targets.getUnitTarget()->getDeathState() == CORPSE
+                                    && m_targets.getUnitTarget()->GetDisplayId() == m_targets.getUnitTarget()->GetNativeDisplayId()
+                                    && m_targets.getUnitTarget()->GetTypeId() == TYPEID_UNIT
+                                    && !m_targets.getUnitTarget()->ToCreature()->isDeadByDefault()
+                                    && !(m_targets.getUnitTarget()->GetCreatureTypeMask() & CREATURE_TYPEMASK_MECHANICAL_OR_ELEMENTAL)
+                                    && m_targets.getUnitTarget()->GetDisplayId() == m_targets.getUnitTarget()->GetNativeDisplayId()))))
+                            {
+                                CleanupTargetList();
+
+                                WorldObject* result = FindCorpseUsing <Trinity::ExplodeCorpseObjectCheck> ();
+
+                                if (result)
+                                {
+                                    switch (result->GetTypeId())
+                                    {
+                                        case TYPEID_UNIT:
+                                        case TYPEID_PLAYER:
+                                            m_targets.setUnitTarget((Unit*)result);
+                                            break;
+                                        default:
+                                            break;
+                                    }
+                                }
+                                else
+                                {
+                                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                                        m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id,true);
+                                    SendCastResult(SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW);
+                                    finish(false);
+                                }
+                            }
+                            break;
+
+                        default:
+                            sLog.outDebug("Spell (ID: %u) (caster Entry: %u) does not have type CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET record in `conditions` table.", m_spellInfo->Id, m_caster->GetEntry());
+
+                            if (m_spellInfo->Effect[i] == SPELL_EFFECT_TELEPORT_UNITS)
+                                SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ENTRY, 0);
+                            else if (IsPositiveEffect(m_spellInfo->Id, i))
+                                SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ALLY);
+                            else
+                                SearchAreaTarget(unitList, radius, pushType, SPELL_TARGETS_ENEMY);
+                    }
+                }
+                break;
+            }
+            case SPELL_TARGETS_GO:
+            {
+                ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET, m_spellInfo->Id);
+                if (!conditions.empty())
+                {
+                    for (ConditionList::const_iterator i_spellST = conditions.begin(); i_spellST != conditions.end(); ++i_spellST)
+                    {
+                        if ((*i_spellST)->mConditionType != CONDITION_SPELL_SCRIPT_TARGET)
+                            continue;
+                        if ((*i_spellST)->mConditionValue1 == SPELL_TARGET_TYPE_GAMEOBJECT)
+                            SearchGOAreaTarget(gobjectList, radius, pushType, SPELL_TARGETS_GO, (*i_spellST)->mConditionValue2);
+                    }
+                }
+                else
+                {
+                    if (m_spellInfo->Effect[i] == SPELL_EFFECT_ACTIVATE_OBJECT)
+                        sLog.outDebug("Spell (ID: %u) (caster Entry: %u) with SPELL_EFFECT_ACTIVATE_OBJECT does not have type CONDITION_SOURCE_TYPE_SPELL_SCRIPT_TARGET record in `conditions` table.", m_spellInfo->Id, m_caster->GetEntry());
+                    SearchGOAreaTarget(gobjectList, radius, pushType, SPELL_TARGETS_GO);
+                }
+                break;
+            }
+            case SPELL_TARGETS_ALLY:
+            case SPELL_TARGETS_ENEMY:
+            case SPELL_TARGETS_CHAINHEAL:
+            case SPELL_TARGETS_ANY:
+                SearchAreaTarget(unitList, radius, pushType, targetType);
+                break;
+            default:
+                switch (cur)
+                {
+                    case TARGET_UNIT_AREA_PARTY_SRC:
+                    case TARGET_UNIT_AREA_PARTY_DST:
+                        m_caster->GetPartyMemberInDist(unitList, radius); //fix me
+                        break;
+                    case TARGET_UNIT_PARTY_TARGET:
+                        m_targets.getUnitTarget()->GetPartyMemberInDist(unitList, radius);
+                        break;
+                    case TARGET_UNIT_PARTY_CASTER:
+                        m_caster->GetPartyMemberInDist(unitList, radius);
+                        break;
+                    case TARGET_UNIT_RAID_CASTER:
+                        m_caster->GetRaidMember(unitList, radius);
+                        break;
+                    case TARGET_UNIT_CLASS_TARGET:
+                    {
+                        Player* targetPlayer = m_targets.getUnitTarget() && m_targets.getUnitTarget()->GetTypeId() == TYPEID_PLAYER
+                            ? (Player*)m_targets.getUnitTarget() : NULL;
+
+                        Group* pGroup = targetPlayer ? targetPlayer->GetGroup() : NULL;
+                        if (pGroup)
+                        {
+                            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                            {
+                                Player* Target = itr->getSource();
+
+                                // IsHostileTo check duel and controlled by enemy
+                                if (Target && targetPlayer->IsWithinDistInMap(Target, radius) &&
+                                    targetPlayer->getClass() == Target->getClass() &&
+                                    !m_caster->IsHostileTo(Target))
+                                {
+                                    AddUnitTarget(Target, i);
+                                }
+                            }
+                        }
+                        else if (m_targets.getUnitTarget())
+                            AddUnitTarget(m_targets.getUnitTarget(), i);
+                        break;
+                    }
+                }
+                break;
+            }
+
+        if (!unitList.empty())
+        {
+            // Special target selection for smart heals and energizes
+            uint32 maxSize = 0;
+            int32 power = -1;
+            switch (m_spellInfo->SpellFamilyName)
+            {
+                case SPELLFAMILY_GENERIC:
+                    switch (m_spellInfo->Id)
+                    {
+                        case 52759: // Ancestral Awakening
+                        case 71610: // Echoes of Light (Althor's Abacus normal version)
+                        case 71641: // Echoes of Light (Althor's Abacus heroic version)
+                            maxSize = 1;
+                            power = POWER_HEALTH;
+                            break;
+                        case 54968: // Glyph of Holy Light
+                            maxSize = m_spellInfo->MaxAffectedTargets;
+                            power = POWER_HEALTH;
+                            break;
+                        case 57669: // Replenishment
+                            // In arenas Replenishment may only affect the caster
+                            if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->InArena())
+                            {
+                                unitList.clear();
+                                unitList.push_back(m_caster);
+                                break;
+                            }
+                            maxSize = 10;
+                            power = POWER_MANA;
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                case SPELLFAMILY_PRIEST:
+                    if (m_spellInfo->SpellFamilyFlags[0] == 0x10000000) // Circle of Healing
+                    {
+                        maxSize = m_caster->HasAura(55675) ? 6 : 5; // Glyph of Circle of Healing
+                        power = POWER_HEALTH;
+                    }
+                    else if (m_spellInfo->Id == 64844) // Divine Hymn
+                    {
+                        maxSize = 3;
+                        power = POWER_HEALTH;
+                    }
+                    else if (m_spellInfo->Id == 64904) // Hymn of Hope
+                    {
+                        maxSize = 3;
+                        power = POWER_MANA;
+                    }
+                    else
+                        break;
+
+                    // Remove targets outside caster's raid
+                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
+                    {
+                        if (!(*itr)->IsInRaidWith(m_caster))
+                            itr = unitList.erase(itr);
+                        else
+                            ++itr;
+                    }
+                    break;
+                case SPELLFAMILY_DRUID:
+                    if (m_spellInfo->SpellFamilyFlags[1] == 0x04000000) // Wild Growth
+                    {
+                        maxSize = m_caster->HasAura(62970) ? 6 : 5; // Glyph of Wild Growth
+                        power = POWER_HEALTH;
+                    }
+                    else
+                        break;
+
+                    // Remove targets outside caster's raid
+                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
+                    {
+                        if (!(*itr)->IsInRaidWith(m_caster))
+                            itr = unitList.erase(itr);
+                        else
+                            ++itr;
+                    }
+                    break;
+                default:
+                    break;
+            }
+
+            if (maxSize && power != -1)
+            {
+                if (Powers(power) == POWER_HEALTH)
+                {
+                    if (unitList.size() > maxSize)
+                    {
+                        unitList.sort(Trinity::HealthPctOrderPred());
+                        unitList.resize(maxSize);
+                    }
 					 // Replenishment: refresh existing auras
                     if (m_spellInfo->Id == 57669)
                         for (std::list<Unit *>::iterator itr = unitList.begin(); itr != unitList.end();)
@@ -2745,22 +2745,22 @@
                             }
                             else
                                 ++itr;
-
-                }
-                else
-                {
-                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
-                    {
-                        if ((*itr)->getPowerType() != (Powers)power)
-                            itr = unitList.erase(itr);
-                        else
-                            ++itr;
-                    }
-                    if (unitList.size() > maxSize)
-                    {
-                        unitList.sort(Trinity::PowerPctOrderPred((Powers)power));
-                        unitList.resize(maxSize);
-                    }
+
+                }
+                else
+                {
+                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
+                    {
+                        if ((*itr)->getPowerType() != (Powers)power)
+                            itr = unitList.erase(itr);
+                        else
+                            ++itr;
+                    }
+                    if (unitList.size() > maxSize)
+                    {
+                        unitList.sort(Trinity::PowerPctOrderPred((Powers)power));
+                        unitList.resize(maxSize);
+                    }
 					  // Replenishment: refresh existing auras
                     if (m_spellInfo->Id == 57669)
                         for (std::list<Unit *>::iterator itr = unitList.begin(); itr != unitList.end();)
@@ -2773,4560 +2773,4566 @@
                             }
                             else
                                 ++itr;
-
-                }
-            }
-
-            // Other special target selection goes here
-            if (uint32 maxTargets = m_spellValue->MaxAffectedTargets)
-            {
-                Unit::AuraEffectList const& Auras = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_MAX_AFFECTED_TARGETS);
-                for (Unit::AuraEffectList::const_iterator j = Auras.begin(); j != Auras.end(); ++j)
-                    if ((*j)->IsAffectedOnSpell(m_spellInfo))
-                        maxTargets += (*j)->GetAmount();
-
-                if (m_spellInfo->Id == 5246) //Intimidating Shout
-                    unitList.remove(m_targets.getUnitTarget());
-                Trinity::RandomResizeList(unitList, maxTargets);
-            }
-            else
-            {
-                switch (m_spellInfo->Id)
-                {
-                    case 27285: // Seed of Corruption proc spell
-                        unitList.remove(m_targets.getUnitTarget());
-                        break;
-                    case 55789: // Improved Icy Talons
-                    case 59725: // Improved Spell Reflection - aoe aura
-                        unitList.remove(m_caster);
-                        break;
-                    case 72255: // Mark of the Fallen Champion (Deathbringer Saurfang)
-                    case 72444:
-                    case 72445:
-                    case 72446:
-                        for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
-                        {
-                            if (!(*itr)->HasAura(72293))
-                                itr = unitList.erase(itr);
-                            else
-                                ++itr;
-                        }
-                        break;
-                    case 69782: case 69796:                 // Ooze Flood
-                    case 69798: case 69801:                 // Ooze Flood
-                        // get 2 targets except 2 nearest
-                        unitList.sort(Trinity::ObjectDistanceOrderPred(m_caster));
-                        unitList.resize(4);
-                        while (unitList.size() > 2)
-                            unitList.pop_front();
-                        // crashfix
-                        if (unitList.empty())
-                            return;
-                        break;
-                }
-                // Death Pact
-                if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
-                {
-                    Unit * unit_to_add = NULL;
-                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end(); ++itr)
-                    {
-                        if ((*itr)->GetTypeId() == TYPEID_UNIT
-                            && (*itr)->GetOwnerGUID() == m_caster->GetGUID()
-                            && (*itr)->ToCreature()->GetCreatureInfo()->type == CREATURE_TYPE_UNDEAD)
-                        {
-                            unit_to_add = (*itr);
-                            break;
-                        }
-                    }
-                    if (unit_to_add)
-                    {
-                        unitList.clear();
-                        unitList.push_back(unit_to_add);
-                    }
-                    // Pet not found - remove cooldown
-                    else
-                    {
-                        if (modOwner->GetTypeId() == TYPEID_PLAYER)
-                            modOwner->RemoveSpellCooldown(m_spellInfo->Id,true);
-                        SendCastResult(SPELL_FAILED_NO_PET);
-                        finish(false);
-                    }
-                }
-            }
-            for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
-                AddUnitTarget(*itr, i);
-        }
-
-        if (!gobjectList.empty())
-        {
-            if (uint32 maxTargets = m_spellValue->MaxAffectedTargets)
-            {
-                Unit::AuraEffectList const& Auras = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_MAX_AFFECTED_TARGETS);
-                for (Unit::AuraEffectList::const_iterator j = Auras.begin(); j != Auras.end(); ++j)
-                    if ((*j)->IsAffectedOnSpell(m_spellInfo))
-                        maxTargets += (*j)->GetAmount();
-
-                Trinity::RandomResizeList(gobjectList, maxTargets);
-            }
-            for (std::list<GameObject*>::iterator itr = gobjectList.begin(); itr != gobjectList.end(); ++itr)
-                AddGOTarget(*itr, i);
-        }
-    }
-}
-
-void Spell::prepare(SpellCastTargets const* targets, AuraEffect const * triggeredByAura)
-{
-    if (m_CastItem)
-        m_castItemGUID = m_CastItem->GetGUID();
-    else
-        m_castItemGUID = 0;
-
-    m_targets = *targets;
-
-    if (!m_targets.getUnitTargetGUID() && m_spellInfo->Targets & TARGET_FLAG_UNIT)
-    {
-        Unit *target = NULL;
-        if (m_caster->GetTypeId() == TYPEID_UNIT)
-            target = m_caster->getVictim();
-        else
-            target = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
-
-        if (target && IsValidSingleTargetSpell(target))
-            m_targets.setUnitTarget(target);
-        else
-        {
-            SendCastResult(SPELL_FAILED_BAD_TARGETS);
-            finish(false);
-            return;
-        }
-    }
-    if (m_caster->ToPlayer())
-    {
-        //check for special spell conditions
-        ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL, m_spellInfo->Id);
-        if (!conditions.empty())
-        {
-            if (!sConditionMgr.IsPlayerMeetToConditions(m_caster->ToPlayer(), conditions))
-            {
-                SendCastResult(SPELL_FAILED_DONT_REPORT);
-                finish(false);
-                return;
-            }
-        }
-    }
-    if (!m_targets.HasSrc() && m_spellInfo->Targets & TARGET_FLAG_SOURCE_LOCATION)
-        m_targets.setSrc(*m_caster);
-
-    if (!m_targets.HasDst() && m_spellInfo->Targets & TARGET_FLAG_DEST_LOCATION)
-    {
-        Unit *target = m_targets.getUnitTarget();
-        if (!target)
-        {
-            if (m_caster->GetTypeId() == TYPEID_UNIT)
-                target = m_caster->getVictim();
-            else
-                target = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
-        }
-
-        if (target)
-            m_targets.setDst(*target);
-        else
-        {
-            SendCastResult(SPELL_FAILED_BAD_TARGETS);
-            finish(false);
-            return;
-        }
-    }
-
-    // Fill aura scaling information
-    if (m_caster->IsControlledByPlayer() && !IsPassiveSpell(m_spellInfo->Id) && m_spellInfo->spellLevel && !IsChanneledSpell(m_spellInfo) && !m_IsTriggeredSpell)
-    {
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (m_spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
-            {
-                // Change aura with ranks only if basepoints are taken from spellInfo and aura is positive
-                if (IsPositiveEffect(m_spellInfo->Id, i))
-                {
-                    m_auraScaleMask |= (1<<i);
-                    if (m_spellValue->EffectBasePoints[i] != m_spellInfo->EffectBasePoints[i])
-                    {
-                        m_auraScaleMask = 0;
-                        break;
-                    }
-                }
-            }
-        }
-    }
-
-    m_spellState = SPELL_STATE_PREPARING;
-
-    if (triggeredByAura)
-        m_triggeredByAuraSpell  = triggeredByAura->GetSpellProto();
-
-    // create and add update event for this spell
-    SpellEvent* Event = new SpellEvent(this);
-    m_caster->m_Events.AddEvent(Event, m_caster->m_Events.CalculateTime(1));
-
-    //Prevent casting at cast another spell (ServerSide check)
-    if (m_caster->IsNonMeleeSpellCasted(false, true, true) && m_cast_count)
-    {
-        SendCastResult(SPELL_FAILED_SPELL_IN_PROGRESS);
-        finish(false);
-        return;
-    }
-
-    if (sDisableMgr.IsDisabledFor(DISABLE_TYPE_SPELL, m_spellInfo->Id, m_caster))
-    {
-        SendCastResult(SPELL_FAILED_SPELL_UNAVAILABLE);
-        finish(false);
-        return;
-    }
-    LoadScripts();
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
-    // Fill cost data (not use power for item casts
-    m_powerCost = m_CastItem ? 0 : CalculatePowerCost(m_spellInfo, m_caster, m_spellSchoolMask);
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
-
-    // Set combo point requirement
-    if (m_IsTriggeredSpell || m_CastItem || !m_caster->m_movedPlayer)
-        m_needComboPoints = false;
-
-    SpellCastResult result = CheckCast(true);
-    if (result != SPELL_CAST_OK && !IsAutoRepeat())          //always cast autorepeat dummy for triggering
-    {
-        if (triggeredByAura && !triggeredByAura->GetBase()->IsPassive())
-        {
-            SendChannelUpdate(0);
-            triggeredByAura->GetBase()->SetDuration(0);
-        }
-        SendCastResult(result);
-
-        finish(false);
-        return;
-    }
-
-    // Prepare data for triggers
-    prepareDataForTriggerSystem(triggeredByAura);
-
-    // calculate cast time (calculated after first CheckCast check to prevent charge counting for first CheckCast fail)
-    m_casttime = GetSpellCastTime(m_spellInfo, this);
-    //m_caster->ModSpellCastTime(m_spellInfo, m_casttime, this);
-
-    // don't allow channeled spells / spells with cast time to be casted while moving
-    // (even if they are interrupted on moving, spells with almost immediate effect get to have their effect processed before movement interrupter kicks in)
-    if ((IsChanneledSpell(m_spellInfo) || m_casttime)
-        && m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->isMoving()
-        && m_spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_MOVEMENT)
-    {
-        SendCastResult(SPELL_FAILED_MOVING);
-        finish(false);
-        return;
-    }
-
-    // set timer base at cast time
-    ReSetTimer();
-
-    sLog.outDebug("Spell::prepare: spell id %u source %u caster %d triggered %u mask %u", m_spellInfo->Id, m_caster->GetEntry(), m_originalCaster ? m_originalCaster->GetEntry() : -1, m_IsTriggeredSpell ? 1 : 0, m_targets.getTargetMask());
-    //if (m_targets.getUnitTarget())
-    //    sLog.outError("Spell::prepare: unit target %u", m_targets.getUnitTarget()->GetEntry());
-    //if (m_targets.HasDst())
-    //    sLog.outError("Spell::prepare: pos target %f %f %f", m_targets.m_dstPos.m_positionX, m_targets.m_dstPos.m_positionY, m_targets.m_dstPos.m_positionZ);
-
-    //Containers for channeled spells have to be set
-    //TODO:Apply this to all casted spells if needed
-    // Why check duration? 29350: channelled triggers channelled
-    if (m_IsTriggeredSpell && (!IsChanneledSpell(m_spellInfo) || !GetSpellMaxDuration(m_spellInfo)))
-        cast(true);
-    else
-    {
-        // stealth must be removed at cast starting (at show channel bar)
-        // skip triggered spell (item equip spell casting and other not explicit character casts/item uses)
-        if (!m_IsTriggeredSpell && isSpellBreakStealth(m_spellInfo))
-        {
-            m_caster->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CAST);
-            for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-            {
-                if (EffectTargetType[m_spellInfo->Effect[i]] == SPELL_REQUIRE_UNIT)
-                {
-                    m_caster->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_SPELL_ATTACK);
-                    break;
-                }
-            }
-        }
-
-        m_caster->SetCurrentCastedSpell(this);
-        SendSpellStart();
-
-        if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            m_caster->ToPlayer()->AddGlobalCooldown(m_spellInfo,this);
-
-        if (!m_casttime && !m_spellInfo->StartRecoveryTime
-            && !m_castItemGUID     //item: first cast may destroy item and second cast causes crash
-            && GetCurrentContainer() == CURRENT_GENERIC_SPELL)
-            cast(true);
-    }
-}
-
-void Spell::cancel()
-{
-    if (m_spellState == SPELL_STATE_FINISHED)
-        return;
-
-    SetReferencedFromCurrent(false);
-    if (m_selfContainer && *m_selfContainer == this)
-        *m_selfContainer = NULL;
-
-    uint32 oldState = m_spellState;
-    m_spellState = SPELL_STATE_FINISHED;
-
-    m_autoRepeat = false;
-    switch (oldState)
-    {
-        case SPELL_STATE_PREPARING:
-        case SPELL_STATE_DELAYED:
-            SendInterrupted(0);
-            SendCastResult(SPELL_FAILED_INTERRUPTED);
-            break;
-
-        case SPELL_STATE_CASTING:
-            for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                if ((*ihit).missCondition == SPELL_MISS_NONE)
-                    if (Unit* unit = m_caster->GetGUID() == ihit->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID))
-                        unit->RemoveOwnedAura(m_spellInfo->Id, m_originalCasterGUID, 0, AURA_REMOVE_BY_CANCEL);
-
-            SendChannelUpdate(0);
-            SendInterrupted(0);
-            SendCastResult(SPELL_FAILED_INTERRUPTED);
-
-            // spell is canceled-take mods and clear list
-            if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                m_caster->ToPlayer()->RemoveSpellMods(this);
-
-            m_appliedMods.clear();
-            break;
-
-        default:
-            break;
-    }
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->RemoveGlobalCooldown(m_spellInfo);
-
-    m_caster->RemoveDynObject(m_spellInfo->Id);
-    m_caster->RemoveGameObject(m_spellInfo->Id,true);
-
-    //set state back so finish will be processed
-    m_spellState = oldState;
-
-    finish(false);
-}
-
-void Spell::cast(bool skipCheck)
-{
-    // update pointers base at GUIDs to prevent access to non-existed already object
-    UpdatePointers();
-
-    if (Unit *target = m_targets.getUnitTarget())
-    {
-        // three check: prepare, cast (m_casttime > 0), hit (delayed)
-        if (m_casttime && target->isAlive()
-            && (target->m_invisibilityMask || m_caster->m_invisibilityMask
-            || target->GetVisibility() == VISIBILITY_GROUP_STEALTH)
-            && !target->IsFriendlyTo(m_caster) && !m_caster->canSeeOrDetect(target, true))
-        {
-            SendCastResult(SPELL_FAILED_BAD_TARGETS);
-            SendInterrupted(0);
-            finish(false);
-            return;
-        }
-    }
-    else
-    {
-        // cancel at lost main target unit
-        if (m_targets.getUnitTargetGUID() && m_targets.getUnitTargetGUID() != m_caster->GetGUID())
-        {
-            cancel();
-            return;
-        }
-    }
-
-    // now that we've done the basic check, now run the scripts
-    // should be done before the spell is actually executed
-    if (Player *playerCaster = m_caster->ToPlayer())
-        sScriptMgr.OnPlayerSpellCast(playerCaster, this, skipCheck);
-
-    SetExecutedCurrently(true);
-
-    if (m_caster->GetTypeId() != TYPEID_PLAYER && m_targets.getUnitTarget() && m_targets.getUnitTarget() != m_caster)
-        m_caster->SetInFront(m_targets.getUnitTarget());
-
-    // Should this be done for original caster?
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        // Set spell which will drop charges for triggered cast spells
-        // if not successfully casted, will be remove in finish(false)
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
-    }
-
-    // triggered cast called from Spell::prepare where it was already checked
-    if (!m_IsTriggeredSpell || !skipCheck)
-    {
-        SpellCastResult castResult = CheckCast(false);
-        if (castResult != SPELL_CAST_OK)
-        {
-            SendCastResult(castResult);
-            SendInterrupted(0);
-            //restore spell mods
-            if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            {
-                m_caster->ToPlayer()->RestoreSpellMods(this);
-                // cleanup after mod system
-                // triggered spell pointer can be not removed in some cases
-                m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
-            }
-            finish(false);
-            SetExecutedCurrently(false);
-            return;
-        }
-
-        // additional check after cast bar completes (must not be in CheckCast)
-        // if trade not complete then remember it in trade data
-        if (m_targets.getTargetMask() & TARGET_FLAG_TRADE_ITEM)
-        {
-            if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            {
-                if (TradeData* my_trade = m_caster->ToPlayer()->GetTradeData())
-                {
-                    if (!my_trade->IsInAcceptProcess())
-                    {
-                        // Spell will be casted at completing the trade. Silently ignore at this place
-                        my_trade->SetSpell(m_spellInfo->Id, m_CastItem);
-                        SendCastResult(SPELL_FAILED_DONT_REPORT);
-                        SendInterrupted(0);
-                        m_caster->ToPlayer()->RestoreSpellMods(this);
-                        // cleanup after mod system
-                        // triggered spell pointer can be not removed in some cases
-                        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
-                        finish(false);
-                        SetExecutedCurrently(false);
-                        return;
-                    }
-                }
-            }
-        }
-    }
-
-    SelectSpellTargets();
-
-    // Spell may be finished after target map check
-    if (m_spellState == SPELL_STATE_FINISHED)
-    {
-        SendInterrupted(0);
-        //restore spell mods
-        if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        {
-            m_caster->ToPlayer()->RestoreSpellMods(this);
-            // cleanup after mod system
-            // triggered spell pointer can be not removed in some cases
-            m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
-        }
-        finish(false);
-        SetExecutedCurrently(false);
-        return;
-    }
-
-    if (m_spellInfo->SpellFamilyName)
-    {
-        if (m_spellInfo->excludeCasterAuraSpell && !IsPositiveSpell(m_spellInfo->excludeCasterAuraSpell))
-            m_preCastSpell = m_spellInfo->excludeCasterAuraSpell;
-        else if (m_spellInfo->excludeTargetAuraSpell && !IsPositiveSpell(m_spellInfo->excludeTargetAuraSpell))
-            m_preCastSpell = m_spellInfo->excludeTargetAuraSpell;
-    }
-
-    switch (m_spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            if (m_spellInfo->Mechanic == MECHANIC_BANDAGE) // Bandages
-                m_preCastSpell = 11196;                                // Recently Bandaged
-            break;
-        }
-        case SPELLFAMILY_MAGE:
-        {
-             // Permafrost
-             if (m_spellInfo->SpellFamilyFlags[1] & 0x00001000 ||  m_spellInfo->SpellFamilyFlags[0] & 0x00100220)
-              m_preCastSpell = 68391;
-             break;
-        }
-    }
-
-    // traded items have trade slot instead of guid in m_itemTargetGUID
-    // set to real guid to be sent later to the client
-    m_targets.updateTradeSlotItem();
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (!m_IsTriggeredSpell && m_CastItem)
-        {
-            m_caster->ToPlayer()->GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_ITEM, m_CastItem->GetEntry());
-            m_caster->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_USE_ITEM, m_CastItem->GetEntry());
-        }
-
-        m_caster->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CAST_SPELL, m_spellInfo->Id);
-    }
-
-    if (!m_IsTriggeredSpell)
-    {
-        // Powers have to be taken before SendSpellGo
-        TakePower();
-        TakeReagents();                                         // we must remove reagents before HandleEffects to allow place crafted item in same slot
-    }
-    else if (Item* targetItem = m_targets.getItemTarget())
-    {
-        /// Not own traded item (in trader trade slot) req. reagents including triggered spell case
-        if (targetItem->GetOwnerGUID() != m_caster->GetGUID())
-            TakeReagents();
-    }
-
-    // are there any spells need to be triggered after hit?
-    // handle SPELL_AURA_ADD_TARGET_TRIGGER auras
-    Unit::AuraEffectList const& targetTriggers = m_caster->GetAuraEffectsByType(SPELL_AURA_ADD_TARGET_TRIGGER);
-    for (Unit::AuraEffectList::const_iterator i = targetTriggers.begin(); i != targetTriggers.end(); ++i)
-    {
-        if (!(*i)->IsAffectedOnSpell(m_spellInfo))
-            continue;
-        SpellEntry const *auraSpellInfo = (*i)->GetSpellProto();
-        uint32 auraSpellIdx = (*i)->GetEffIndex();
-        if (SpellEntry const *spellInfo = sSpellStore.LookupEntry(auraSpellInfo->EffectTriggerSpell[auraSpellIdx]))
-        {
-            int32 auraBaseAmount = (*i)->GetBaseAmount();
-            int32 chance = m_caster->CalculateSpellDamage(NULL, auraSpellInfo, auraSpellIdx, &auraBaseAmount);
-            m_ChanceTriggerSpells.push_back(std::make_pair(spellInfo, chance * (*i)->GetBase()->GetStackAmount()));
-        }
-    }
-
-    if (m_customAttr & SPELL_ATTR_CU_DIRECT_DAMAGE)
-        CalculateDamageDoneForAllTargets();
-
-    // CAST SPELL
-    SendSpellCooldown();
-
-    PrepareScriptHitHandlers();
-
-    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch(m_spellInfo->Effect[i])
-        {
-            case SPELL_EFFECT_CHARGE:
-            case SPELL_EFFECT_CHARGE_DEST:
-            case SPELL_EFFECT_JUMP:
-            case SPELL_EFFECT_JUMP_DEST:
-            case SPELL_EFFECT_LEAP_BACK:
-            case SPELL_EFFECT_ACTIVATE_RUNE:
-                HandleEffects(NULL,NULL,NULL,i);
-                m_effectMask |= (1<<i);
-                break;
-        }
-    }
-
-    // we must send smsg_spell_go packet before m_castItem delete in TakeCastItem()...
-    SendSpellGo();
-
-    // Okay, everything is prepared. Now we need to distinguish between immediate and evented delayed spells
-    if ((m_spellInfo->speed > 0.0f && !IsChanneledSpell(m_spellInfo)) || m_spellInfo->Id == 14157)
-    {
-        // Remove used for cast item if need (it can be already NULL after TakeReagents call
-        // in case delayed spell remove item at cast delay start
-        TakeCastItem();
-
-        // Okay, maps created, now prepare flags
-        m_immediateHandled = false;
-        m_spellState = SPELL_STATE_DELAYED;
-        SetDelayStart(0);
-
-        if (m_caster->hasUnitState(UNIT_STAT_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
-            m_caster->clearUnitState(UNIT_STAT_CASTING);
-    }
-    else
-    {
-        // Immediate spell, no big deal
-        handle_immediate();
-    }
-
-    if (m_customAttr & SPELL_ATTR_CU_LINK_CAST)
-    {
-        if (const std::vector<int32> *spell_triggered = sSpellMgr.GetSpellLinked(m_spellInfo->Id))
-        {
-            for (std::vector<int32>::const_iterator i = spell_triggered->begin(); i != spell_triggered->end(); ++i)
-                if (*i < 0)
-                    m_caster->RemoveAurasDueToSpell(-(*i));
-                else
-                    m_caster->CastSpell(m_targets.getUnitTarget() ? m_targets.getUnitTarget() : m_caster, *i, true);
-        }
-    }
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
-
-    SetExecutedCurrently(false);
-}
-
-void Spell::handle_immediate()
-{
-    // start channeling if applicable
-    if (IsChanneledSpell(m_spellInfo))
-    {
-        int32 duration = GetSpellDuration(m_spellInfo);
-        if (duration)
-        {
-            // First mod_duration then haste - see Missile Barrage
-            // Apply duration mod
-            if (Player* modOwner = m_caster->GetSpellModOwner())
-                modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
-            // Apply haste mods
-            m_caster->ModSpellCastTime(m_spellInfo, duration, this);
-
-            m_spellState = SPELL_STATE_CASTING;
-            m_caster->AddInterruptMask(m_spellInfo->ChannelInterruptFlags);
-            SendChannelStart(duration);
-        }
-    }
-
-    PrepareTargetProcessing();
-
-    // process immediate effects (items, ground, etc.) also initialize some variables
-    _handle_immediate_phase();
-
-    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-        DoAllEffectOnTarget(&(*ihit));
-
-    for (std::list<GOTargetInfo>::iterator ihit= m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
-        DoAllEffectOnTarget(&(*ihit));
-
-    FinishTargetProcessing();
-
-    // spell is finished, perform some last features of the spell here
-    _handle_finish_phase();
-
-    // Remove used for cast item if need (it can be already NULL after TakeReagents call
-    TakeCastItem();
-
-    if (m_spellState != SPELL_STATE_CASTING)
-        finish(true);                                       // successfully finish spell cast (not last in case autorepeat or channel spell)
-}
-
-uint64 Spell::handle_delayed(uint64 t_offset)
-{
-    UpdatePointers();
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
-
-    uint64 next_time = 0;
-
-    PrepareTargetProcessing();
-
-    if (!m_immediateHandled)
-    {
-        _handle_immediate_phase();
-        m_immediateHandled = true;
-    }
-
-    bool single_missile = (m_targets.HasDst());
-
-    // now recheck units targeting correctness (need before any effects apply to prevent adding immunity at first effect not allow apply second spell effect and similar cases)
-    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-    {
-        if (ihit->processed == false)
-        {
-            if (single_missile || ihit->timeDelay <= t_offset)
-                DoAllEffectOnTarget(&(*ihit));
-            else if (next_time == 0 || ihit->timeDelay < next_time)
-                next_time = ihit->timeDelay;
-        }
-    }
-
-    // now recheck gameobject targeting correctness
-    for (std::list<GOTargetInfo>::iterator ighit= m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end(); ++ighit)
-    {
-        if (ighit->processed == false)
-        {
-            if (single_missile || ighit->timeDelay <= t_offset)
-                DoAllEffectOnTarget(&(*ighit));
-            else if (next_time == 0 || ighit->timeDelay < next_time)
-                next_time = ighit->timeDelay;
-        }
-    }
-
-    FinishTargetProcessing();
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
-
-    // All targets passed - need finish phase
-    if (next_time == 0)
-    {
-        // spell is finished, perform some last features of the spell here
-        _handle_finish_phase();
-
-        finish(true);                                       // successfully finish spell cast
-
-        // return zero, spell is finished now
-        return 0;
-    }
-    else
-    {
-        // spell is unfinished, return next execution time
-        return next_time;
-    }
-}
-
-void Spell::_handle_immediate_phase()
-{
-    m_spellAura = NULL;
-    // handle some immediate features of the spell here
-    HandleThreatSpells(m_spellInfo->Id);
-
-    PrepareScriptHitHandlers();
-
-    for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        if (m_spellInfo->Effect[j] == 0)
-            continue;
-
-        // apply Send Event effect to ground in case empty target lists
-        if (m_spellInfo->Effect[j] == SPELL_EFFECT_SEND_EVENT && !HaveTargetsForEffect(j))
-        {
-            HandleEffects(NULL, NULL, NULL, j);
-            continue;
-        }
-    }
-
-    // initialize Diminishing Returns Data
-    m_diminishLevel = DIMINISHING_LEVEL_1;
-    m_diminishGroup = DIMINISHING_NONE;
-
-    // process items
-    for (std::list<ItemTargetInfo>::iterator ihit= m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
-        DoAllEffectOnTarget(&(*ihit));
-
-    if (!m_originalCaster)
-        return;
-    uint8 oldEffMask = m_effectMask;
-    // process ground
-    for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        if (m_spellInfo->Effect[j] == 0)
-            continue;
-
-        if (EffectTargetType[m_spellInfo->Effect[j]] == SPELL_REQUIRE_DEST)
-        {
-            if (!m_targets.HasDst()) // FIXME: this will ignore dest set in effect
-                m_targets.setDst(*m_caster);
-            HandleEffects(m_originalCaster, NULL, NULL, j);
-            m_effectMask |= (1<<j);
-        }
-        else if (EffectTargetType[m_spellInfo->Effect[j]] == SPELL_REQUIRE_NONE)
-        {
-            HandleEffects(m_originalCaster, NULL, NULL, j);
-            m_effectMask |= (1<<j);
-        }
-    }
-    if (oldEffMask != m_effectMask && m_UniqueTargetInfo.empty())
-    {
-        uint32 procAttacker = m_procAttacker;
-        if (!procAttacker)
-        {
-            bool positive = true;
-            for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
-                // If at least one effect negative spell is negative hit
-                if (m_effectMask & (1<<i) && !IsPositiveEffect(m_spellInfo->Id, i))
-                {
-                    positive = false;
-                    break;
-                }
-            switch(m_spellInfo->DmgClass)
-            {
-                case SPELL_DAMAGE_CLASS_MAGIC:
-                    if (positive)
-                        procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS;
-                    else
-                        procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG;
-                break;
-                case SPELL_DAMAGE_CLASS_NONE:
-                    if (positive)
-                        procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS;
-                    else
-                        procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_NEG;
-                break;
-            }
-        }
-        // Proc damage for spells which have only dest targets (2484 should proc 51486 for example)
-        m_originalCaster->ProcDamageAndSpell(0, procAttacker, 0, m_procEx | PROC_EX_NORMAL_HIT, 0, BASE_ATTACK, m_spellInfo, m_triggeredByAuraSpell);
-    }
-}
-
-void Spell::_handle_finish_phase()
-{
-    if (m_caster->m_movedPlayer)
-    {
-        // Take for real after all targets are processed
-        if (m_needComboPoints)
-            m_caster->m_movedPlayer->ClearComboPoints();
-
-        // Real add combo points from effects
-        if (m_comboPointGain)
-            m_caster->m_movedPlayer->GainSpellComboPoints(m_comboPointGain);
-    }
-}
-
-void Spell::SendSpellCooldown()
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* _player = (Player*)m_caster;
-
-    // mana/health/etc potions, disabled by client (until combat out as declarate)
-    if (m_CastItem && m_CastItem->IsPotion())
-    {
-        // need in some way provided data for Spell::finish SendCooldownEvent
-        _player->SetLastPotionId(m_CastItem->GetEntry());
-        return;
-    }
-
-    // have infinity cooldown but set at aura apply                  // do not set cooldown for triggered spells (needed by reincarnation)
-    if (m_spellInfo->Attributes & (SPELL_ATTR_DISABLED_WHILE_ACTIVE | SPELL_ATTR_PASSIVE) || m_IsTriggeredSpell)
-        return;
-
-    _player->AddSpellAndCategoryCooldowns(m_spellInfo,m_CastItem ? m_CastItem->GetEntry() : 0, this);
-}
-
-void Spell::update(uint32 difftime)
-{
-    // update pointers based at it's GUIDs
-    UpdatePointers();
-
-    if (m_targets.getUnitTargetGUID() && !m_targets.getUnitTarget())
-    {
-        sLog.outDebug("Spell %u is cancelled due to removal of target.", m_spellInfo->Id);
-        cancel();
-        return;
-    }
-
-    // check if the player caster has moved before the spell finished
-    if ((m_caster->GetTypeId() == TYPEID_PLAYER && m_timer != 0) &&
-        m_caster->isMoving() && (m_spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_MOVEMENT) &&
-        (m_spellInfo->Effect[0] != SPELL_EFFECT_STUCK || !m_caster->HasUnitMovementFlag(MOVEMENTFLAG_FALLING)))
-    {
-        // don't cancel for melee, autorepeat, triggered and instant spells
-        if (!IsNextMeleeSwingSpell() && !IsAutoRepeat() && !m_IsTriggeredSpell)
-            cancel();
-    }
-
-    switch(m_spellState)
-    {
-        case SPELL_STATE_PREPARING:
-        {
-            if (m_timer)
-            {
-                if (difftime >= m_timer)
-                    m_timer = 0;
-                else
-                    m_timer -= difftime;
-            }
-
-            if (m_timer == 0 && !IsNextMeleeSwingSpell() && !IsAutoRepeat())
-                cast(m_spellInfo->CastingTimeIndex == 1);
-        } break;
-        case SPELL_STATE_CASTING:
-        {
-            if (m_timer > 0)
-            {
-                // check if there are alive targets left
-                if (!UpdateChanneledTargetList())
-                {
-                    sLog.outDebug("Channeled spell %d is removed due to lack of targets", m_spellInfo->Id);
-                    SendChannelUpdate(0);
-                    finish();
-                }
-
-                if (difftime >= m_timer)
-                    m_timer = 0;
-                else
-                    m_timer -= difftime;
-            }
-
-            if (m_timer == 0)
-            {
-                SendChannelUpdate(0);
-
-                // channeled spell processed independently for quest targeting
-                // cast at creature (or GO) quest objectives update at successful cast channel finished
-                // ignore autorepeat/melee casts for speed (not exist quest for spells (hm...)
-                if (!IsAutoRepeat() && !IsNextMeleeSwingSpell())
-                {
-                    if (Player* p = m_caster->GetCharmerOrOwnerPlayerOrPlayerItself())
-                    {
-                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        {
-                            TargetInfo* target = &*ihit;
-                            if (!IS_CRE_OR_VEH_GUID(target->targetGUID))
-                                continue;
-
-                            Unit* unit = m_caster->GetGUID() == target->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, target->targetGUID);
-                            if (unit == NULL)
-                                continue;
-
-                            p->CastedCreatureOrGO(unit->GetEntry(), unit->GetGUID(), m_spellInfo->Id);
-                        }
-
-                        for (std::list<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
-                        {
-                            GOTargetInfo* target = &*ihit;
-
-                            GameObject* go = m_caster->GetMap()->GetGameObject(target->targetGUID);
-                            if (!go)
-                                continue;
-
-                            p->CastedCreatureOrGO(go->GetEntry(), go->GetGUID(), m_spellInfo->Id);
-                        }
-                    }
-                }
-
-                finish();
-            }
-        } break;
-        default:
-        {
-        }break;
-    }
-}
-
-void Spell::finish(bool ok)
-{
-    if (!m_caster)
-        return;
-
-    if (m_spellState == SPELL_STATE_FINISHED)
-        return;
-    m_spellState = SPELL_STATE_FINISHED;
-
-    if (IsChanneledSpell(m_spellInfo))
-        m_caster->UpdateInterruptMask();
-
-    if (m_caster->hasUnitState(UNIT_STAT_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
-        m_caster->clearUnitState(UNIT_STAT_CASTING);
-
-    // Unsummon summon as possessed creatures on spell cancel
-    if (IsChanneledSpell(m_spellInfo) && m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (Unit *charm = m_caster->GetCharm())
-            if (charm->GetTypeId() == TYPEID_UNIT
-                && charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_PUPPET)
-                && charm->GetUInt32Value(UNIT_CREATED_BY_SPELL) == m_spellInfo->Id)
-                ((Puppet*)charm)->UnSummon();
-    }
-
-    if (!ok)
-        return;
-
-    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isSummon())
-    {
-        // Unsummon statue
-        uint32 spell = m_caster->GetUInt32Value(UNIT_CREATED_BY_SPELL);
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
-        if (spellInfo && spellInfo->SpellIconID == 2056)
-        {
-            sLog.outDebug("Statue %d is unsummoned in spell %d finish", m_caster->GetGUIDLow(), m_spellInfo->Id);
-            m_caster->setDeathState(JUST_DIED);
-            return;
-        }
-    }
-
-    if (IsAutoActionResetSpell())
-    {
-        bool found = false;
-        Unit::AuraEffectList const& vIgnoreReset = m_caster->GetAuraEffectsByType(SPELL_AURA_IGNORE_MELEE_RESET);
-        for (Unit::AuraEffectList::const_iterator i = vIgnoreReset.begin(); i != vIgnoreReset.end(); ++i)
-        {
-            if ((*i)->IsAffectedOnSpell(m_spellInfo))
-            {
-                found = true;
-                break;
-            }
-        }
-        if (!found && !(m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_RESET_AUTO_ACTIONS))
-        {
-            m_caster->resetAttackTimer(BASE_ATTACK);
-            if (m_caster->haveOffhandWeapon())
-                m_caster->resetAttackTimer(OFF_ATTACK);
-            m_caster->resetAttackTimer(RANGED_ATTACK);
-        }
-    }
-
-    // potions disabled by client, send event "not in combat" if need
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (!m_triggeredByAuraSpell)
-            m_caster->ToPlayer()->UpdatePotionCooldown(this);
-
-        // triggered spell pointer can be not set in some cases
-        // this is needed for proper apply of triggered spell mods
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
-    }
-
-    // Take mods after trigger spell (needed for 14177 to affect 48664)
-    // mods are taken only on succesfull cast and independantly from targets of the spell
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        m_caster->ToPlayer()->RemoveSpellMods(this);
-        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
-    }
-
-    // Stop Attack for some spells
-    if (m_spellInfo->Attributes & SPELL_ATTR_STOP_ATTACK_TARGET)
-        m_caster->AttackStop();
-}
-
-void Spell::SendCastResult(SpellCastResult result)
-{
-    if (result == SPELL_CAST_OK)
-        return;
-
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (m_caster->ToPlayer()->GetSession()->PlayerLoading())  // don't send cast results at loading time
-        return;
-
-    SendCastResult((Player*)m_caster,m_spellInfo,m_cast_count,result);
-}
-
-void Spell::SendCastResult(Player* caster, SpellEntry const* spellInfo, uint8 cast_count, SpellCastResult result)
-{
-    if (result == SPELL_CAST_OK)
-        return;
-
-    WorldPacket data(SMSG_CAST_FAILED, (4+1+1));
-    data << uint8(cast_count);                              // single cast or multi 2.3 (0/1)
-    data << uint32(spellInfo->Id);
-    data << uint8(result);                                  // problem
-    switch (result)
-    {
-        case SPELL_FAILED_REQUIRES_SPELL_FOCUS:
-            data << uint32(spellInfo->RequiresSpellFocus);
-            break;
-        case SPELL_FAILED_REQUIRES_AREA:
-            // hardcode areas limitation case
-            switch(spellInfo->Id)
-            {
-                case 41617:                                 // Cenarion Mana Salve
-                case 41619:                                 // Cenarion Healing Salve
-                    data << uint32(3905);
-                    break;
-                case 41618:                                 // Bottled Nethergon Energy
-                case 41620:                                 // Bottled Nethergon Vapor
-                    data << uint32(3842);
-                    break;
-                case 45373:                                 // Bloodberry Elixir
-                    data << uint32(4075);
-                    break;
-                default:                                    // default case (don't must be)
-                    data << uint32(0);
-                    break;
-            }
-            break;
-        case SPELL_FAILED_TOTEMS:
-            if (spellInfo->Totem[0])
-                data << uint32(spellInfo->Totem[0]);
-            if (spellInfo->Totem[1])
-                data << uint32(spellInfo->Totem[1]);
-            break;
-        case SPELL_FAILED_TOTEM_CATEGORY:
-            if (spellInfo->TotemCategory[0])
-                data << uint32(spellInfo->TotemCategory[0]);
-            if (spellInfo->TotemCategory[1])
-                data << uint32(spellInfo->TotemCategory[1]);
-            break;
-        case SPELL_FAILED_EQUIPPED_ITEM_CLASS:
-            data << uint32(spellInfo->EquippedItemClass);
-            data << uint32(spellInfo->EquippedItemSubClassMask);
-            //data << uint32(spellInfo->EquippedItemInventoryTypeMask);
-            break;
-        case SPELL_FAILED_TOO_MANY_OF_ITEM:
-        {
-             uint32 item = 0;
-             for (int8 x=0;x < 3;x++)
-                 if (spellInfo->EffectItemType[x])
-                     item = spellInfo->EffectItemType[x];
-             ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item);
-             if (pProto && pProto->ItemLimitCategory)
-                 data << uint32(pProto->ItemLimitCategory);
-             break;
-        }
-        default:
-            break;
-    }
-    caster->GetSession()->SendPacket(&data);
-}
-
-void Spell::SendSpellStart()
-{
-    if (!IsNeedSendToClient())
-        return;
-
-    //sLog.outDebug("Sending SMSG_SPELL_START id=%u", m_spellInfo->Id);
-
-    uint32 castFlags = CAST_FLAG_UNKNOWN_2;
-    if (m_spellInfo->Attributes & SPELL_ATTR_REQ_AMMO)
-        castFlags |= CAST_FLAG_AMMO;
-    if ((m_caster->GetTypeId() == TYPEID_PLAYER ||
-        (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet()))
-         && m_spellInfo->powerType != POWER_HEALTH)
-        castFlags |= CAST_FLAG_POWER_LEFT_SELF;
-
-    if (m_spellInfo->runeCostID && m_spellInfo->powerType == POWER_RUNE)
-        castFlags |= CAST_FLAG_UNKNOWN_19;
-
-    WorldPacket data(SMSG_SPELL_START, (8+8+4+4+2));
-    if (m_CastItem)
-        data.append(m_CastItem->GetPackGUID());
-    else
-        data.append(m_caster->GetPackGUID());
-
-    data.append(m_caster->GetPackGUID());
-    data << uint8(m_cast_count);                            // pending spell cast?
-    data << uint32(m_spellInfo->Id);                        // spellId
-    data << uint32(castFlags);                              // cast flags
-    data << uint32(m_timer);                                // delay?
-
-    m_targets.write(data);
-
-    if (castFlags & CAST_FLAG_POWER_LEFT_SELF)
-        data << uint32(m_caster->GetPower((Powers)m_spellInfo->powerType));
-
-    if (castFlags & CAST_FLAG_AMMO)
-        WriteAmmoToPacket(&data);
-
-    if (castFlags & CAST_FLAG_UNKNOWN_23)
-    {
-        data << uint32(0);
-        data << uint32(0);
-    }
-
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::SendSpellGo()
-{
-    // not send invisible spell casting
-    if (!IsNeedSendToClient())
-        return;
-
-    //sLog.outDebug("Sending SMSG_SPELL_GO id=%u", m_spellInfo->Id);
-
-    uint32 castFlags = CAST_FLAG_UNKNOWN_9;
-
-    // triggered spells with spell visual != 0
-    if ((m_IsTriggeredSpell && !IsAutoRepeatRangedSpell(m_spellInfo)) || m_triggeredByAuraSpell)
-        castFlags |= CAST_FLAG_PENDING;
-
-    if (m_spellInfo->Attributes & SPELL_ATTR_REQ_AMMO)
-        castFlags |= CAST_FLAG_AMMO;                        // arrows/bullets visual
-    if ((m_caster->GetTypeId() == TYPEID_PLAYER ||
-        (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet()))
-        && m_spellInfo->powerType != POWER_HEALTH)
-        castFlags |= CAST_FLAG_POWER_LEFT_SELF; // should only be sent to self, but the current messaging doesn't make that possible
-
-    if ((m_caster->GetTypeId() == TYPEID_PLAYER)
-        && (m_caster->getClass() == CLASS_DEATH_KNIGHT)
-        && m_spellInfo->runeCostID
-        && m_spellInfo->powerType == POWER_RUNE)
-    {
-        castFlags |= CAST_FLAG_UNKNOWN_19;                   // same as in SMSG_SPELL_START
-        castFlags |= CAST_FLAG_RUNE_LIST;                    // rune cooldowns list
-        castFlags |= CAST_FLAG_UNKNOWN_9;                    // ??
-    }
-
-    if (IsSpellHaveEffect(m_spellInfo, SPELL_EFFECT_ACTIVATE_RUNE))
-    {
-        castFlags |= CAST_FLAG_RUNE_LIST;                    // rune cooldowns list
-        castFlags |= CAST_FLAG_UNKNOWN_19;                   // same as in SMSG_SPELL_START
-    }
-
-    WorldPacket data(SMSG_SPELL_GO, 50);                    // guess size
-
-    if (m_CastItem)
-        data.append(m_CastItem->GetPackGUID());
-    else
-        data.append(m_caster->GetPackGUID());
-
-    data.append(m_caster->GetPackGUID());
-    data << uint8(m_cast_count);                            // pending spell cast?
-    data << uint32(m_spellInfo->Id);                        // spellId
-    data << uint32(castFlags);                              // cast flags
-    data << uint32(getMSTime());                            // timestamp
-
-    /*
-    // statement below seems to be wrong - i've seen spells with both unit and dest target
-    // Can't have TARGET_FLAG_UNIT when *_LOCATION is present - it breaks missile visuals
-    if (m_targets.getTargetMask() & (TARGET_FLAG_SOURCE_LOCATION | TARGET_FLAG_DEST_LOCATION))
-        m_targets.setTargetMask(m_targets.getTargetMask() & ~TARGET_FLAG_UNIT);
-    else if (m_targets.getIntTargetFlags() & FLAG_INT_UNIT)
-        m_targets.setTargetMask(m_targets.getTargetMask() | TARGET_FLAG_UNIT);
-    */
-
-    WriteSpellGoTargets(&data);
-
-    m_targets.write(data);
-
-    if (castFlags & CAST_FLAG_POWER_LEFT_SELF)
-        data << uint32(m_caster->GetPower((Powers)m_spellInfo->powerType));
-
-    if (castFlags & CAST_FLAG_RUNE_LIST)                   // rune cooldowns list
-    {
-        uint8 v1 = m_runesState;
-        uint8 v2 = m_caster->ToPlayer()->GetRunesState();
-        data << uint8(v1);                                  // runes state before
-        data << uint8(v2);                                  // runes state after
-        for (uint8 i = 0; i < MAX_RUNES; ++i)
-        {
-            uint8 m = (1 << i);
-            if (m & v1)                                      // usable before...
-                if (!(m & v2))                               // ...but on cooldown now...
-                    data << uint8(0);                       // some unknown byte (time?)
-        }
-    }
-
-    if (castFlags & CAST_FLAG_UNKNOWN_18)                   // unknown wotlk
-    {
-        data << float(0);
-        data << uint32(0);
-    }
-
-    if (castFlags & CAST_FLAG_AMMO)
-        WriteAmmoToPacket(&data);
-
-    if (castFlags & CAST_FLAG_UNKNOWN_20)                   // unknown wotlk
-    {
-        data << uint32(0);
-        data << uint32(0);
-    }
-
-    if (m_targets.getTargetMask() & TARGET_FLAG_DEST_LOCATION)
-    {
-        data << uint8(0);
-    }
-
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::WriteAmmoToPacket(WorldPacket * data)
-{
-    uint32 ammoInventoryType = 0;
-    uint32 ammoDisplayID = 0;
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        Item *pItem = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
-        if (pItem)
-        {
-            ammoInventoryType = pItem->GetProto()->InventoryType;
-            if (ammoInventoryType == INVTYPE_THROWN)
-                ammoDisplayID = pItem->GetProto()->DisplayInfoID;
-            else
-            {
-                uint32 ammoID = m_caster->ToPlayer()->GetUInt32Value(PLAYER_AMMO_ID);
-                if (ammoID)
-                {
-                    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(ammoID);
-                    if (pProto)
-                    {
-                        ammoDisplayID = pProto->DisplayInfoID;
-                        ammoInventoryType = pProto->InventoryType;
-                    }
-                }
-                else if (m_caster->HasAura(46699))      // Requires No Ammo
-                {
-                    ammoDisplayID = 5996;                   // normal arrow
-                    ammoInventoryType = INVTYPE_AMMO;
-                }
-            }
-        }
-    }
-    else
-    {
-        for (uint8 i = 0; i < 3; ++i)
-        {
-            if (uint32 item_id = m_caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i))
-            {
-                if (ItemEntry const * itemEntry = sItemStore.LookupEntry(item_id))
-                {
-                    if (itemEntry->Class == ITEM_CLASS_WEAPON)
-                    {
-                        switch(itemEntry->SubClass)
-                        {
-                            case ITEM_SUBCLASS_WEAPON_THROWN:
-                                ammoDisplayID = itemEntry->DisplayId;
-                                ammoInventoryType = itemEntry->InventoryType;
-                                break;
-                            case ITEM_SUBCLASS_WEAPON_BOW:
-                            case ITEM_SUBCLASS_WEAPON_CROSSBOW:
-                                ammoDisplayID = 5996;       // is this need fixing?
-                                ammoInventoryType = INVTYPE_AMMO;
-                                break;
-                            case ITEM_SUBCLASS_WEAPON_GUN:
-                                ammoDisplayID = 5998;       // is this need fixing?
-                                ammoInventoryType = INVTYPE_AMMO;
-                                break;
-                        }
-
-                        if (ammoDisplayID)
-                            break;
-                    }
-                }
-            }
-        }
-    }
-
-    *data << uint32(ammoDisplayID);
-    *data << uint32(ammoInventoryType);
-}
-
-void Spell::WriteSpellGoTargets(WorldPacket * data)
-{
-    // This function also fill data for channeled spells:
-    // m_needAliveTargetMask req for stop channelig if one target die
-    uint32 hit  = m_UniqueGOTargetInfo.size(); // Always hits on GO
-    uint32 miss = 0;
-    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-    {
-        if ((*ihit).effectMask == 0)                  // No effect apply - all immuned add state
-        {
-            // possibly SPELL_MISS_IMMUNE2 for this??
-            ihit->missCondition = SPELL_MISS_IMMUNE2;
-            ++miss;
-        }
-        else if ((*ihit).missCondition == SPELL_MISS_NONE)
-            ++hit;
-        else
-            ++miss;
-    }
-
-    *data << (uint8)hit;
-    for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-    {
-        if ((*ihit).missCondition == SPELL_MISS_NONE)       // Add only hits
-        {
-            *data << uint64(ihit->targetGUID);
-            m_channelTargetEffectMask |=ihit->effectMask;
-        }
-    }
-
-    for (std::list<GOTargetInfo>::const_iterator ighit = m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end(); ++ighit)
-        *data << uint64(ighit->targetGUID);                 // Always hits
-
-    *data << (uint8)miss;
-    for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-    {
-        if (ihit->missCondition != SPELL_MISS_NONE)        // Add only miss
-        {
-            *data << uint64(ihit->targetGUID);
-            *data << uint8(ihit->missCondition);
-            if (ihit->missCondition == SPELL_MISS_REFLECT)
-                *data << uint8(ihit->reflectResult);
-        }
-    }
-    // Reset m_needAliveTargetMask for non channeled spell
-    if (!IsChanneledSpell(m_spellInfo))
-        m_channelTargetEffectMask = 0;
-}
-
-void Spell::SendLogExecute()
-{
-    WorldPacket data(SMSG_SPELLLOGEXECUTE, (8+4+4+4+4+8));
-
-    data.append(m_caster->GetPackGUID());
-
-    data << uint32(m_spellInfo->Id);
-
-    uint8 effCount = 0;
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (m_effectExecuteData[i])
-            ++effCount;
-    }
-
-    if (!effCount)
-        return;
-
-    data << uint32(effCount);
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (!m_effectExecuteData[i])
-            continue;
-
-        data << uint32(m_spellInfo->Effect[i]);             // spell effect
-
-        data.append(*m_effectExecuteData[i]);
-
-        delete m_effectExecuteData[i];
-        m_effectExecuteData[i] = NULL;
-    }
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::ExecuteLogEffectTakeTargetPower(uint8 effIndex, Unit * target, uint32 powerType, uint32 powerTaken, float gainMultiplier)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(target->GetPackGUID());
-    *m_effectExecuteData[effIndex] << uint32(powerTaken);
-    *m_effectExecuteData[effIndex] << uint32(powerType);
-    *m_effectExecuteData[effIndex] << float(gainMultiplier);
-}
-
-void Spell::ExecuteLogEffectExtraAttacks(uint8 effIndex, Unit * victim, uint32 attCount)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(victim->GetPackGUID());
-    *m_effectExecuteData[effIndex] << uint32(attCount);
-}
-
-void Spell::ExecuteLogEffectInterruptCast(uint8 effIndex, Unit * victim, uint32 spellId)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(victim->GetPackGUID());
-    *m_effectExecuteData[effIndex] << uint32(spellId);
-}
-
-void Spell::ExecuteLogEffectDurabilityDamage(uint8 effIndex, Unit * victim, uint32 /*itemslot*/, uint32 damage)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(victim->GetPackGUID());
-    *m_effectExecuteData[effIndex] << uint32(m_spellInfo->Id);
-    *m_effectExecuteData[effIndex] << uint32(damage);
-}
-
-void Spell::ExecuteLogEffectOpenLock(uint8 effIndex, Object * obj)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(obj->GetPackGUID());
-}
-
-void Spell::ExecuteLogEffectCreateItem(uint8 effIndex, uint32 entry)
-{
-    InitEffectExecuteData(effIndex);
-    *m_effectExecuteData[effIndex] << uint32(entry);
-}
-
-void Spell::ExecuteLogEffectDestroyItem(uint8 effIndex, uint32 entry)
-{
-    InitEffectExecuteData(effIndex);
-    *m_effectExecuteData[effIndex] << uint32(entry);
-}
-
-void Spell::ExecuteLogEffectSummonObject(uint8 effIndex, WorldObject * obj)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(obj->GetPackGUID());
-}
-
-void Spell::ExecuteLogEffectUnsummonObject(uint8 effIndex, WorldObject * obj)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(obj->GetPackGUID());
-}
-
-void Spell::ExecuteLogEffectResurrect(uint8 effIndex, Unit * target)
-{
-    InitEffectExecuteData(effIndex);
-    m_effectExecuteData[effIndex]->append(target->GetPackGUID());
-}
-
-void Spell::SendInterrupted(uint8 result)
-{
-    WorldPacket data(SMSG_SPELL_FAILURE, (8+4+1));
-    data.append(m_caster->GetPackGUID());
-    data << uint8(m_cast_count);
-    data << uint32(m_spellInfo->Id);
-    data << uint8(result);
-    m_caster->SendMessageToSet(&data, true);
-
-    data.Initialize(SMSG_SPELL_FAILED_OTHER, (8+4));
-    data.append(m_caster->GetPackGUID());
-    data << uint8(m_cast_count);
-    data << uint32(m_spellInfo->Id);
-    data << uint8(result);
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::SendChannelUpdate(uint32 time)
-{
-    if (time == 0)
-    {
-        m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, 0);
-        m_caster->SetUInt32Value(UNIT_CHANNEL_SPELL, 0);
-    }
-
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    WorldPacket data(MSG_CHANNEL_UPDATE, 8+4);
-    data.append(m_caster->GetPackGUID());
-    data << uint32(time);
-
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::SendChannelStart(uint32 duration)
-{
-    WorldObject* target = NULL;
-
-    // select first not resisted target from target list for _0_ effect
-    if (!m_UniqueTargetInfo.empty())
-    {
-        for (std::list<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
-        {
-            if ((itr->effectMask & (1 << 0)) && itr->reflectResult == SPELL_MISS_NONE && itr->targetGUID != m_caster->GetGUID())
-            {
-                target = ObjectAccessor::GetUnit(*m_caster, itr->targetGUID);
-                break;
-            }
-        }
-    }
-    else if (!m_UniqueGOTargetInfo.empty())
-    {
-        for (std::list<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
-        {
-            if (itr->effectMask & (1 << 0))
-            {
-                target = m_caster->GetMap()->GetGameObject(itr->targetGUID);
-                break;
-            }
-        }
-    }
-
-    WorldPacket data(MSG_CHANNEL_START, (8+4+4));
-    data.append(m_caster->GetPackGUID());
-    data << uint32(m_spellInfo->Id);
-    data << uint32(duration);
-
-    m_caster->SendMessageToSet(&data, true);
-
-    m_timer = duration;
-    if (target)
-        m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, target->GetGUID());
-    m_caster->SetUInt32Value(UNIT_CHANNEL_SPELL, m_spellInfo->Id);
-}
-
-void Spell::SendResurrectRequest(Player* target)
-{
-    // Both players and NPCs can resurrect using spells - have a look at creature 28487 for example
-    // However, the packet structure differs slightly
-
-    const char* sentName = m_caster->GetTypeId() == TYPEID_PLAYER ? "" : m_caster->GetNameForLocaleIdx(target->GetSession()->GetSessionDbLocaleIndex());
-
-    WorldPacket data(SMSG_RESURRECT_REQUEST, (8+4+strlen(sentName)+1+1+1));
-    data << uint64(m_caster->GetGUID());
-    data << uint32(strlen(sentName) + 1);
-
-    data << sentName;
-    data << uint8(0);
-
-    data << uint8(m_caster->GetTypeId() == TYPEID_PLAYER ? 0 : 1);
-    target->GetSession()->SendPacket(&data);
-}
-
-void Spell::SendPlaySpellVisual(uint32 SpellID)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 8 + 4);
-    data << uint64(m_caster->GetGUID());
-    data << uint32(SpellID);                                // spell visual id?
-    m_caster->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-void Spell::TakeCastItem()
-{
-    if (!m_CastItem || m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // not remove cast item at triggered spell (equipping, weapon damage, etc)
-    if (m_IsTriggeredSpell)
-        return;
-
-    ItemPrototype const *proto = m_CastItem->GetProto();
-
-    if (!proto)
-    {
-        // This code is to avoid a crash
-        // I'm not sure, if this is really an error, but I guess every item needs a prototype
-        sLog.outError("Cast item has no item prototype highId=%d, lowId=%d",m_CastItem->GetGUIDHigh(), m_CastItem->GetGUIDLow());
-        return;
-    }
-
-    bool expendable = false;
-    bool withoutCharges = false;
-
-    for (int i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
-    {
-        if (proto->Spells[i].SpellId)
-        {
-            // item has limited charges
-            if (proto->Spells[i].SpellCharges)
-            {
-                if (proto->Spells[i].SpellCharges < 0)
-                    expendable = true;
-
-                int32 charges = m_CastItem->GetSpellCharges(i);
-
-                // item has charges left
-                if (charges)
-                {
-                    (charges > 0) ? --charges : ++charges;  // abs(charges) less at 1 after use
-                    if (proto->Stackable == 1)
-                        m_CastItem->SetSpellCharges(i, charges);
-                    m_CastItem->SetState(ITEM_CHANGED, (Player*)m_caster);
-                }
-
-                // all charges used
-                withoutCharges = (charges == 0);
-            }
-        }
-    }
-
-    if (expendable && withoutCharges)
-    {
-        uint32 count = 1;
-        m_caster->ToPlayer()->DestroyItemCount(m_CastItem, count, true);
-
-        // prevent crash at access to deleted m_targets.getItemTarget
-        if (m_CastItem == m_targets.getItemTarget())
-            m_targets.setItemTarget(NULL);
-
-        m_CastItem = NULL;
-    }
-}
-
-void Spell::TakePower()
-{
-    if (m_CastItem || m_triggeredByAuraSpell)
-        return;
-
-    bool hit = true;
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (m_spellInfo->powerType == POWER_RAGE || m_spellInfo->powerType == POWER_ENERGY)
-            if (uint64 targetGUID = m_targets.getUnitTargetGUID())
-                for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                    if (ihit->targetGUID == targetGUID)
-                    {
-                        if (ihit->missCondition != SPELL_MISS_NONE && ihit->missCondition != SPELL_MISS_MISS/* && ihit->targetGUID != m_caster->GetGUID()*/)
-                            hit = false;
-                        if (ihit->missCondition != SPELL_MISS_NONE)
-                        {
-                            //lower spell cost on fail (by talent aura)
-                            if (Player *modOwner = m_caster->ToPlayer()->GetSpellModOwner())
-                                modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_SPELL_COST_REFUND_ON_FAIL, m_powerCost);
-                        }
-                        break;
-                    }
-    }
-
-    Powers powerType = Powers(m_spellInfo->powerType);
-
-    if (hit && powerType == POWER_RUNE)
-    {
-        TakeRunePower();
-        return;
-    }
-
-    if (!m_powerCost)
-        return;
-
-    // health as power used
-    if (m_spellInfo->powerType == POWER_HEALTH)
-    {
-        m_caster->ModifyHealth(-(int32)m_powerCost);
-        return;
-    }
-
-    if (m_spellInfo->powerType >= MAX_POWERS)
-    {
-        sLog.outError("Spell::TakePower: Unknown power type '%d'", m_spellInfo->powerType);
-        return;
-    }
-
-    if (hit)
-        m_caster->ModifyPower(powerType, -m_powerCost);
-    else
-        m_caster->ModifyPower(powerType, -irand(0, m_powerCost/4));
-
-    // Set the five second timer
-    if (powerType == POWER_MANA && m_powerCost > 0)
-        m_caster->SetLastManaUse(getMSTime());
-}
-
-void Spell::TakeAmmo()
-{
-    if (m_attackType == RANGED_ATTACK && m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        Item *pItem = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
-
-        // wands don't have ammo
-        if (!pItem  || pItem->IsBroken() || pItem->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_WAND)
-            return;
-
-        if (pItem->GetProto()->InventoryType == INVTYPE_THROWN)
-        {
-            if (pItem->GetMaxStackCount() == 1)
-            {
-                // decrease durability for non-stackable throw weapon
-                m_caster->ToPlayer()->DurabilityPointLossForEquipSlot(EQUIPMENT_SLOT_RANGED);
-            }
-            else
-            {
-                // decrease items amount for stackable throw weapon
-                uint32 count = 1;
-                m_caster->ToPlayer()->DestroyItemCount(pItem, count, true);
-            }
-        }
-        else if (uint32 ammo = m_caster->ToPlayer()->GetUInt32Value(PLAYER_AMMO_ID))
-            m_caster->ToPlayer()->DestroyItemCount(ammo, 1, true);
-    }
-}
-
-SpellCastResult Spell::CheckRuneCost(uint32 runeCostID)
-{
-    if (m_spellInfo->powerType != POWER_RUNE || !runeCostID)
-        return SPELL_CAST_OK;
-
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return SPELL_CAST_OK;
-
-    Player *plr = (Player*)m_caster;
-
-    if (plr->getClass() != CLASS_DEATH_KNIGHT)
-        return SPELL_CAST_OK;
-
-    SpellRuneCostEntry const *src = sSpellRuneCostStore.LookupEntry(runeCostID);
-
-    if (!src)
-        return SPELL_CAST_OK;
-
-    if (src->NoRuneCost())
-        return SPELL_CAST_OK;
-
-    int32 runeCost[NUM_RUNE_TYPES];                         // blood, frost, unholy, death
-
-    for (uint32 i = 0; i < RUNE_DEATH; ++i)
-    {
-        runeCost[i] = src->RuneCost[i];
-        if (Player* modOwner = m_caster->GetSpellModOwner())
-            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_COST, runeCost[i], this);
-    }
-
-    runeCost[RUNE_DEATH] = MAX_RUNES;                       // calculated later
-
-    for (uint32 i = 0; i < MAX_RUNES; ++i)
-    {
-        RuneType rune = plr->GetCurrentRune(i);
-        if ((plr->GetRuneCooldown(i) == 0) && (runeCost[rune] > 0))
-            runeCost[rune]--;
-    }
-
-    for (uint32 i = 0; i < RUNE_DEATH; ++i)
-        if (runeCost[i] > 0)
-            runeCost[RUNE_DEATH] += runeCost[i];
-
-    if (runeCost[RUNE_DEATH] > MAX_RUNES)
-        return SPELL_FAILED_NO_POWER;                       // not sure if result code is correct
-
-    return SPELL_CAST_OK;
-}
-
-void Spell::TakeRunePower()
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *plr = (Player*)m_caster;
-
-    if (plr->getClass() != CLASS_DEATH_KNIGHT)
-        return;
-
-    SpellRuneCostEntry const *src = sSpellRuneCostStore.LookupEntry(m_spellInfo->runeCostID);
-
-    if (!src || (src->NoRuneCost() && src->NoRunicPowerGain()))
-        return;
-
-    m_runesState = plr->GetRunesState();                    // store previous state
-
-    int32 runeCost[NUM_RUNE_TYPES];                         // blood, frost, unholy, death
-
-    for (uint32 i = 0; i < RUNE_DEATH; ++i)
-    {
-        runeCost[i] = src->RuneCost[i];
-        if (Player* modOwner = m_caster->GetSpellModOwner())
-            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_COST, runeCost[i], this);
-    }
-
-    runeCost[RUNE_DEATH] = 0;                               // calculated later
-
-    for (uint32 i = 0; i < MAX_RUNES; ++i)
-    {
-        RuneType rune = plr->GetCurrentRune(i);
-        if ((plr->GetRuneCooldown(i) == 0) && (runeCost[rune] > 0))
-        {
-            plr->SetRuneCooldown(i, plr->GetRuneBaseCooldown(i));
-            plr->SetLastUsedRune(RuneType(rune));
-            runeCost[rune]--;
-        }
-    }
-
-    runeCost[RUNE_DEATH] = runeCost[RUNE_BLOOD] + runeCost[RUNE_UNHOLY] + runeCost[RUNE_FROST];
-
-    if (runeCost[RUNE_DEATH] > 0)
-    {
-        for (uint32 i = 0; i < MAX_RUNES; ++i)
-        {
-            RuneType rune = plr->GetCurrentRune(i);
-            if ((plr->GetRuneCooldown(i) == 0) && (rune == RUNE_DEATH))
-            {
-                plr->SetRuneCooldown(i, plr->GetRuneBaseCooldown(i));
-                plr->SetLastUsedRune(RuneType(rune));
-                runeCost[rune]--;
-
-                plr->RestoreBaseRune(i);
-
-                if (runeCost[RUNE_DEATH] == 0)
-                    break;
-            }
-        }
-    }
-
-    // you can gain some runic power when use runes
-    float rp = (float)src->runePowerGain;
-    rp *= sWorld.getRate(RATE_POWER_RUNICPOWER_INCOME);
-    plr->ModifyPower(POWER_RUNIC_POWER, (int32)rp);
-}
-
-void Spell::TakeReagents()
-{
-    if (m_IsTriggeredSpell)                                  // reagents used in triggered spell removed by original spell or don't must be removed.
-    {
-        Item* targetItem = m_targets.getItemTarget();
-        /// Not own traded item (in trader trade slot) req. reagents including triggered spell case
-        if (!(targetItem && targetItem->GetOwnerGUID() != m_caster->GetGUID()))
-            return;
-    }
-
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // do not take reagents for these item casts
-    if (m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-    if (p_caster->CanNoReagentCast(m_spellInfo))
-        return;
-
-    for (uint32 x = 0; x < MAX_SPELL_REAGENTS; ++x)
-    {
-        if (m_spellInfo->Reagent[x] <= 0)
-            continue;
-
-        uint32 itemid = m_spellInfo->Reagent[x];
-        uint32 itemcount = m_spellInfo->ReagentCount[x];
-
-        // if CastItem is also spell reagent
-        if (m_CastItem)
-        {
-            ItemPrototype const *proto = m_CastItem->GetProto();
-            if (proto && proto->ItemId == itemid)
-            {
-                for (int s = 0; s < MAX_ITEM_PROTO_SPELLS; ++s)
-                {
-                    // CastItem will be used up and does not count as reagent
-                    int32 charges = m_CastItem->GetSpellCharges(s);
-                    if (proto->Spells[s].SpellCharges < 0 && abs(charges) < 2)
-                    {
-                        ++itemcount;
-                        break;
-                    }
-                }
-
-                m_CastItem = NULL;
-            }
-        }
-
-        // if getItemTarget is also spell reagent
-        if (m_targets.getItemTargetEntry() == itemid)
-            m_targets.setItemTarget(NULL);
-
-        p_caster->DestroyItemCount(itemid, itemcount, true);
-    }
-}
-
-void Spell::HandleThreatSpells(uint32 spellId)
-{
-    if (!m_targets.getUnitTarget() || !spellId)
-        return;
-
-    if (!m_targets.getUnitTarget()->CanHaveThreatList())
-        return;
-
-    uint16 threat = sSpellMgr.GetSpellThreat(spellId);
-
-    if (!threat)
-        return;
-
-    m_targets.getUnitTarget()->AddThreat(m_caster, float(threat));
-
-    sLog.outStaticDebug("Spell %u, rank %u, added an additional %i threat", spellId, sSpellMgr.GetSpellRank(spellId), threat);
-}
-
-void Spell::HandleEffects(Unit *pUnitTarget,Item *pItemTarget,GameObject *pGOTarget,uint32 i)
-{
-    //effect has been handled, skip it
-    if (m_effectMask & (1<<i))
-        return;
-
-    unitTarget = pUnitTarget;
-    itemTarget = pItemTarget;
-    gameObjTarget = pGOTarget;
-
-    uint8 eff = m_spellInfo->Effect[i];
-
-    sLog.outDebug("Spell: %u Effect : %u", m_spellInfo->Id, eff);
-
-    //we do not need DamageMultiplier here.
-    damage = CalculateDamage(i, NULL);
-
-    bool preventDefault = CallScriptEffectHandlers((SpellEffIndex)i);
-
-    if (!preventDefault && eff < TOTAL_SPELL_EFFECTS)
-    {
-        (this->*SpellEffects[eff])((SpellEffIndex)i);
-    }
-}
-
-SpellCastResult Spell::CheckCast(bool strict)
-{
-	OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
-
-    // check death state
-    if (!m_IsTriggeredSpell && !m_caster->isAlive() && !(m_spellInfo->Attributes & SPELL_ATTR_PASSIVE) && !(m_spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD))
-        return SPELL_FAILED_CASTER_DEAD;
-
-    // check cooldowns to prevent cheating
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && !(m_spellInfo->Attributes & SPELL_ATTR_PASSIVE))
-    {
-        //can cast triggered (by aura only?) spells while have this flag
-        if (!m_IsTriggeredSpell && m_caster->ToPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_ALLOW_ONLY_ABILITY))
-            return SPELL_FAILED_SPELL_IN_PROGRESS;
-
-        if (m_caster->ToPlayer()->HasSpellCooldown(m_spellInfo->Id) ||
-            (strict && !m_IsTriggeredSpell && m_caster->ToPlayer()->HasGlobalCooldown(m_spellInfo)))
-        {
-            if (m_triggeredByAuraSpell)
-                return SPELL_FAILED_DONT_REPORT;
-            else
-                return SPELL_FAILED_NOT_READY;
-        }
-    }
-
-    // only allow triggered spells if at an ended battleground
-    if (!m_IsTriggeredSpell && m_caster->GetTypeId() == TYPEID_PLAYER)
-        if (Battleground * bg = m_caster->ToPlayer()->GetBattleground())
-            if (bg->GetStatus() == STATUS_WAIT_LEAVE)
-                return SPELL_FAILED_DONT_REPORT;
-
-    if(m_caster->GetTypeId() == TYPEID_PLAYER && VMAP::VMapFactory::createOrGetVMapManager()->isLineOfSightCalcEnabled())
-    {
-        if(m_spellInfo->Attributes & SPELL_ATTR_OUTDOORS_ONLY &&
-                !m_caster->GetMap()->IsOutdoors(m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ()))
-            return SPELL_FAILED_ONLY_OUTDOORS;
-
-        if(m_spellInfo->Attributes & SPELL_ATTR_INDOORS_ONLY &&
-                m_caster->GetMap()->IsOutdoors(m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ()))
-            return SPELL_FAILED_ONLY_INDOORS;
-    }
-
-    // only check at first call, Stealth auras are already removed at second call
-    // for now, ignore triggered spells
-    if (strict && !m_IsTriggeredSpell)
-    {
-        bool checkForm = true;
-        // Ignore form req aura
-        Unit::AuraEffectList const& ignore = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
-        for (Unit::AuraEffectList::const_iterator i = ignore.begin(); i != ignore.end(); ++i)
-        {
-            if (!(*i)->IsAffectedOnSpell(m_spellInfo))
-                continue;
-            checkForm = false;
-            break;
-        }
-        if (checkForm)
-        {
-            // Cannot be used in this stance/form
-            SpellCastResult shapeError = GetErrorAtShapeshiftedCast(m_spellInfo, m_caster->m_form);
-            if (shapeError != SPELL_CAST_OK)
-                return shapeError;
-
-            if ((m_spellInfo->Attributes & SPELL_ATTR_ONLY_STEALTHED) && !(m_caster->HasStealthAura()))
-                return SPELL_FAILED_ONLY_STEALTHED;
-        }
-    }
-
-    bool reqCombat=true;
-    Unit::AuraEffectList const& stateAuras = m_caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_IGNORE_AURASTATE);
-    for (Unit::AuraEffectList::const_iterator j = stateAuras.begin(); j != stateAuras.end(); ++j)
-    {
-        if ((*j)->IsAffectedOnSpell(m_spellInfo))
-        {
-            m_needComboPoints = false;
-            if ((*j)->GetMiscValue() == 1)
-            {
-                reqCombat=false;
-                break;
-            }
-        }
-    }
-
-    // caster state requirements
-    // not for triggered spells (needed by execute)
-    if (!m_IsTriggeredSpell)
-    {
-        if (m_spellInfo->CasterAuraState && !m_caster->HasAuraState(AuraState(m_spellInfo->CasterAuraState), m_spellInfo, m_caster))
-            return SPELL_FAILED_CASTER_AURASTATE;
-        if (m_spellInfo->CasterAuraStateNot && m_caster->HasAuraState(AuraState(m_spellInfo->CasterAuraStateNot), m_spellInfo, m_caster))
-            return SPELL_FAILED_CASTER_AURASTATE;
-
-        // Note: spell 62473 requres casterAuraSpell = triggering spell
-        if (m_spellInfo->casterAuraSpell && !m_caster->HasAura(m_spellInfo->casterAuraSpell))
-            return SPELL_FAILED_CASTER_AURASTATE;
-        if (m_spellInfo->excludeCasterAuraSpell && m_caster->HasAura(m_spellInfo->excludeCasterAuraSpell))
-            return SPELL_FAILED_CASTER_AURASTATE;
-
-        if (reqCombat && m_caster->isInCombat() && IsNonCombatSpell(m_spellInfo))
-            return SPELL_FAILED_AFFECTING_COMBAT;
-    }
-
-    // cancel autorepeat spells if cast start when moving
-    // (not wand currently autorepeat cast delayed to moving stop anyway in spell update code)
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->isMoving())
-    {
-        // skip stuck spell to allow use it in falling case and apply spell limitations at movement
-        if ((!m_caster->HasUnitMovementFlag(MOVEMENTFLAG_FALLING) || m_spellInfo->Effect[0] != SPELL_EFFECT_STUCK) &&
-            (IsAutoRepeat() || (m_spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) != 0))
-            return SPELL_FAILED_MOVING;
-    }
-
-    Unit *target = m_targets.getUnitTarget();
-
-    // In pure self-cast spells, the client won't send any unit target
-    if (!target && (m_targets.getTargetMask() == TARGET_FLAG_SELF || m_targets.getTargetMask() & TARGET_FLAG_UNIT_CASTER)) // TARGET_FLAG_SELF == 0, remember!
-        target = m_caster;
-
-    if (target)
-    {
-        // target state requirements (not allowed state), apply to self also
-        if (!m_IsTriggeredSpell && m_spellInfo->TargetAuraStateNot && target->HasAuraState(AuraState(m_spellInfo->TargetAuraStateNot), m_spellInfo, m_caster))
-            return SPELL_FAILED_TARGET_AURASTATE;
-
-        if (m_spellInfo->targetAuraSpell && !target->HasAura(m_spellInfo->targetAuraSpell))
-            return SPELL_FAILED_TARGET_AURASTATE;
-
-        if (m_spellInfo->excludeTargetAuraSpell && target->HasAura(m_spellInfo->excludeTargetAuraSpell))
-            return SPELL_FAILED_TARGET_AURASTATE;
-
-        if (!m_IsTriggeredSpell && target == m_caster && m_spellInfo->AttributesEx & SPELL_ATTR_EX_CANT_TARGET_SELF)
-            return SPELL_FAILED_BAD_TARGETS;
-
-        bool non_caster_target = target != m_caster && !sSpellMgr.IsSpellWithCasterSourceTargetsOnly(m_spellInfo);
-
-        if (non_caster_target)
-        {
-            // target state requirements (apply to non-self only), to allow cast affects to self like Dirty Deeds
-            if (!m_IsTriggeredSpell && m_spellInfo->TargetAuraState && !target->HasAuraState(AuraState(m_spellInfo->TargetAuraState), m_spellInfo, m_caster))
-                return SPELL_FAILED_TARGET_AURASTATE;
-
-            // Not allow casting on flying player
-            if (target->hasUnitState(UNIT_STAT_UNATTACKABLE))
-                return SPELL_FAILED_BAD_TARGETS;
-
-            if (!m_IsTriggeredSpell && (target->HasAuraType(SPELL_AURA_MOD_STEALTH)
-                || target->m_invisibilityMask) && !m_caster->canSeeOrDetect(target, true))
-                return SPELL_FAILED_BAD_TARGETS;
-
-            if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            {
-                // Do not allow to banish target tapped by someone not in caster's group
-                if (m_spellInfo->Mechanic == MECHANIC_BANISH)
-                    if (Creature *targetCreature = target->ToCreature())
-                        if (targetCreature->hasLootRecipient() && !targetCreature->isTappedBy(m_caster->ToPlayer()))
-                            return SPELL_FAILED_CANT_CAST_ON_TAPPED;
-
-                if (m_customAttr & SPELL_ATTR_CU_PICKPOCKET)
-                {
-                     if (target->GetTypeId() == TYPEID_PLAYER)
-                         return SPELL_FAILED_BAD_TARGETS;
-                     else if ((target->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) == 0)
-                         return SPELL_FAILED_TARGET_NO_POCKETS;
-                }
-
-                // Not allow disarm unarmed player
-                if (m_spellInfo->Mechanic == MECHANIC_DISARM)
-                {
-                    if (target->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        Player *player = target->ToPlayer();
-                        if (!player->GetWeaponForAttack(BASE_ATTACK) || !player->IsUseEquipedWeapon(true))
-                            return SPELL_FAILED_TARGET_NO_WEAPONS;
-                    }
-                    else if (!target->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID))
-                        return SPELL_FAILED_TARGET_NO_WEAPONS;
-                }
-            }
-
-            if (!m_IsTriggeredSpell && VMAP::VMapFactory::checkSpellForLoS(m_spellInfo->Id) && !m_caster->IsWithinLOSInMap(target))
-                return SPELL_FAILED_LINE_OF_SIGHT;
-
-        }
-        else if (m_caster == target)
-        {
-            if (m_caster->GetTypeId() == TYPEID_PLAYER) // Target - is player caster
-            {
-                // Additional check for some spells
-                // If 0 spell effect empty - client not send target data (need use selection)
-                // TODO: check it on next client version
-                if (m_targets.getTargetMask() == TARGET_FLAG_SELF &&
-                    m_spellInfo->EffectImplicitTargetA[1] == TARGET_UNIT_TARGET_ENEMY)
-                {
-                    target = m_caster->GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
-                    if (target)
-                        m_targets.setUnitTarget(target);
-                    else
-                        return SPELL_FAILED_BAD_TARGETS;
-                }
-                // Lay on Hands - cannot be self-cast on paladin with Forbearance or after using Avenging Wrath
-                if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN && m_spellInfo->SpellFamilyFlags[0] & 0x0008000)
-                    if (target->HasAura(61988)) // Immunity shield marker
-                        return SPELL_FAILED_TARGET_AURASTATE;
-            }
-        }
-
-        // check pet presents
-        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            if (m_spellInfo->EffectImplicitTargetA[j] == TARGET_UNIT_PET)
-            {
-                target = m_caster->GetGuardianPet();
-                if (!target)
-                {
-                    if (m_triggeredByAuraSpell)              // not report pet not existence for triggered spells
-                        return SPELL_FAILED_DONT_REPORT;
-                    else
-                        return SPELL_FAILED_NO_PET;
-                }
-                break;
-            }
-        }
-
-        //check creature type
-        //ignore self casts (including area casts when caster selected as target)
-        if (non_caster_target)
-        {
-            if (!CheckTargetCreatureType(target))
-            {
-                if (target->GetTypeId() == TYPEID_PLAYER)
-                    return SPELL_FAILED_TARGET_IS_PLAYER;
-                else
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-        }
-
-        // who can give me an example to show what is the use of this
-        // even if we need check, check by effect rather than whole spell, otherwise 57108,57143 are broken
-        /*
-        // TODO: this check can be applied and for player to prevent cheating when IsPositiveSpell will return always correct result.
-        // check target for pet/charmed casts (not self targeted), self targeted cast used for area effects and etc
-        if (non_caster_target && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->GetCharmerOrOwnerGUID())
-        {
-            // check correctness positive/negative cast target (pet cast real check and cheating check)
-            if (IsPositiveSpell(m_spellInfo->Id))
-            {
-                                                     //dispel positivity is dependant on target, don't check it
-                if (m_caster->IsHostileTo(target) && !IsDispel(m_spellInfo))
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-            else
-            {
-                if (m_caster->IsFriendlyTo(target))
-                    return SPELL_FAILED_BAD_TARGETS;
-            }
-        }
-        */
-
-        if (target)
-            if (IsPositiveSpell(m_spellInfo->Id))
-                if (target->IsImmunedToSpell(m_spellInfo))
-                    return SPELL_FAILED_TARGET_AURASTATE;
-
-        //Must be behind the target.
-        if (m_spellInfo->AttributesEx2 == SPELL_ATTR_EX2_UNK20 && m_spellInfo->AttributesEx & SPELL_ATTR_EX_UNK9 && target->HasInArc(static_cast<float>(M_PI), m_caster)
-            //Exclusion for Pounce: Facing Limitation was removed in 2.0.1, but it still uses the same, old Ex-Flags
-            && (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags.IsEqual(0x20000,0,0)))
-            //Mutilate no longer requires you be behind the target as of patch 3.0.3
-            && (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && m_spellInfo->SpellFamilyFlags[1] & 0x200000))
-            //Exclusion for Throw: Facing limitation was added in 3.2.x, but that shouldn't be
-            && (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && m_spellInfo->SpellFamilyFlags[0] & 0x00000001)))
-        {
-            SendInterrupted(2);
-            return SPELL_FAILED_NOT_BEHIND;
-        }
-
-        //Target must be facing you.
-        if ((m_spellInfo->Attributes == (SPELL_ATTR_UNK4 | SPELL_ATTR_NOT_SHAPESHIFT | SPELL_ATTR_UNK18 | SPELL_ATTR_STOP_ATTACK_TARGET)) && !target->HasInArc(static_cast<float>(M_PI), m_caster))
-        {
-            SendInterrupted(2);
-            return SPELL_FAILED_NOT_INFRONT;
-        }
-
-        // check if target is in combat
-        if (non_caster_target && (m_spellInfo->AttributesEx & SPELL_ATTR_EX_NOT_IN_COMBAT_TARGET) && target->isInCombat())
-            return SPELL_FAILED_TARGET_AFFECTING_COMBAT;
-    }
-
-    // Spell casted only on battleground
-    if ((m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_BATTLEGROUND) &&  m_caster->GetTypeId() == TYPEID_PLAYER)
-        if (!m_caster->ToPlayer()->InBattleground())
-            return SPELL_FAILED_ONLY_BATTLEGROUNDS;
-
-    // do not allow spells to be cast in arenas
-    // - with greater than 10 min CD without SPELL_ATTR_EX4_USABLE_IN_ARENA flag
-    // - with SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA flag
-    if ((m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA) ||
-        (GetSpellRecoveryTime(m_spellInfo) > 10 * MINUTE * IN_MILLISECONDS && !(m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_USABLE_IN_ARENA)))
-        if (MapEntry const* mapEntry = sMapStore.LookupEntry(m_caster->GetMapId()))
-            if (mapEntry->IsBattleArena())
-                return SPELL_FAILED_NOT_IN_ARENA;
-
-    // zone check
-    if (m_caster->GetTypeId() == TYPEID_UNIT || !m_caster->ToPlayer()->isGameMaster())
-    {
-        uint32 zone, area;
-        m_caster->GetZoneAndAreaId(zone,area);
-
-        SpellCastResult locRes= sSpellMgr.GetSpellAllowedInLocationError(m_spellInfo,m_caster->GetMapId(),zone,area,
-            m_caster->GetTypeId() == TYPEID_PLAYER ? m_caster->ToPlayer() : NULL);
-        if (locRes != SPELL_CAST_OK)
-            return locRes;
-    }
-
-    // not let players cast spells at mount (and let do it to creatures)
-    if (m_caster->IsMounted() && m_caster->GetTypeId() == TYPEID_PLAYER && !m_IsTriggeredSpell &&
-        !IsPassiveSpell(m_spellInfo->Id) && !(m_spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_MOUNTED))
-    {
-        if (m_caster->isInFlight())
-            return SPELL_FAILED_NOT_ON_TAXI;
-        else
-            return SPELL_FAILED_NOT_MOUNTED;
-    }
-
-    // always (except passive spells) check items (focus object can be required for any type casts)
-    if (!IsPassiveSpell(m_spellInfo->Id))
-    {
-        SpellCastResult castResult = CheckItems();
-        if (castResult != SPELL_CAST_OK)
-            return castResult;
-    }
-
-    if (!m_IsTriggeredSpell)
-    {
-        SpellCastResult castResult = CheckRange(strict);
-        if (castResult != SPELL_CAST_OK)
-            return castResult;
-
-        castResult = CheckPower();
-        if (castResult != SPELL_CAST_OK)
-            return castResult;
-
-        castResult = CheckCasterAuras();
-        if (castResult != SPELL_CAST_OK)
-            return castResult;
-    }
-
-    for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
-    {
-        // for effects of spells that have only one target
-        switch(m_spellInfo->Effect[i])
-        {
-            case SPELL_EFFECT_DUMMY:
-            {
-                if (m_spellInfo->Id == 51582)          // Rocket Boots Engaged
-                {
-                    if (m_caster->IsInWater())
-                        return SPELL_FAILED_ONLY_ABOVEWATER;
-                }
-                else if (m_spellInfo->SpellIconID == 156)    // Holy Shock
-                {
-                    // spell different for friends and enemies
-                    // hurt version required facing
-                    if (m_targets.getUnitTarget() && !m_caster->IsFriendlyTo(m_targets.getUnitTarget()) && !m_caster->HasInArc(static_cast<float>(M_PI), m_targets.getUnitTarget()))
-                        return SPELL_FAILED_UNIT_NOT_INFRONT;
-                }
-                else if (m_spellInfo->SpellIconID == 33 && m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_FIRE_NOVA)
-                {
-                    if (!m_caster->m_SummonSlot[1])
-                        return SPELL_FAILED_SUCCESS;
-                }
-                else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] == 0x2000) // Death Coil (DeathKnight)
-                {
-                    Unit* target = m_targets.getUnitTarget();
-                    if (!target || (target->IsFriendlyTo(m_caster) && target->GetCreatureType() != CREATURE_TYPE_UNDEAD))
-                        return SPELL_FAILED_BAD_TARGETS;
-                }
-                else if (m_spellInfo->Id == 19938)          // Awaken Peon
-                {
-                    Unit *unit = m_targets.getUnitTarget();
-                    if (!unit || !unit->HasAura(17743))
-                        return SPELL_FAILED_BAD_TARGETS;
-                }
-                else if (m_spellInfo->Id == 52264)          // Deliver Stolen Horse
-                {
-                    if (!m_caster->FindNearestCreature(28653,5))
-                        return SPELL_FAILED_OUT_OF_RANGE;
-                }
-                else if (m_spellInfo->Id == 31789)          // Righteous Defense
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return SPELL_FAILED_DONT_REPORT;
-
-                    Unit* target = m_targets.getUnitTarget();
-                    if (!target || !target->IsFriendlyTo(m_caster) || target->getAttackers().empty())
-                        return SPELL_FAILED_BAD_TARGETS;
-
-                }
-                break;
-            }
-            case SPELL_EFFECT_LEARN_SPELL:
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                if (m_spellInfo->EffectImplicitTargetA[i] != TARGET_UNIT_PET)
-                    break;
-
-                Pet* pet = m_caster->ToPlayer()->GetPet();
-
-                if (!pet)
-                    return SPELL_FAILED_NO_PET;
-
-                SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[i]);
-
-                if (!learn_spellproto)
-                    return SPELL_FAILED_NOT_KNOWN;
-
-                if (m_spellInfo->spellLevel > pet->getLevel())
-                    return SPELL_FAILED_LOWLEVEL;
-
-                break;
-            }
-            case SPELL_EFFECT_LEARN_PET_SPELL:
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                Pet* pet = m_caster->ToPlayer()->GetPet();
-                if (!pet)
-                    return SPELL_FAILED_NO_PET;
-
-                SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[i]);
-
-                if (!learn_spellproto)
-                    return SPELL_FAILED_NOT_KNOWN;
-
-                if (m_spellInfo->spellLevel > pet->getLevel())
-                    return SPELL_FAILED_LOWLEVEL;
-
-                break;
-            }
-            case SPELL_EFFECT_APPLY_GLYPH:
-            {
-                uint32 glyphId = m_spellInfo->EffectMiscValue[i];
-                if (GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(glyphId))
-                    if (m_caster->HasAura(gp->SpellId))
-                        return SPELL_FAILED_UNIQUE_GLYPH;
-                break;
-            }
-            case SPELL_EFFECT_FEED_PET:
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                Item* foodItem = m_targets.getItemTarget();
-                if (!foodItem)
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                Pet* pet = m_caster->ToPlayer()->GetPet();
-
-                if (!pet)
-                    return SPELL_FAILED_NO_PET;
-
-                if (!pet->HaveInDiet(foodItem->GetProto()))
-                    return SPELL_FAILED_WRONG_PET_FOOD;
-
-                if (!pet->GetCurrentFoodBenefitLevel(foodItem->GetProto()->ItemLevel))
-                    return SPELL_FAILED_FOOD_LOWLEVEL;
-
-                if (m_caster->isInCombat() || pet->isInCombat())
-                    return SPELL_FAILED_AFFECTING_COMBAT;
-
-                break;
-            }
-            case SPELL_EFFECT_POWER_BURN:
-            case SPELL_EFFECT_POWER_DRAIN:
-            {
-                // Can be area effect, Check only for players and not check if target - caster (spell can have multiply drain/burn effects)
-                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    if (Unit* target = m_targets.getUnitTarget())
-                        if (target != m_caster && target->getPowerType() != Powers(m_spellInfo->EffectMiscValue[i]))
-                            return SPELL_FAILED_BAD_TARGETS;
-                break;
-            }
-            case SPELL_EFFECT_CHARGE:
-            {
-                if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARRIOR)
-                {
-                    // Warbringer - can't be handled in proc system - should be done before checkcast root check and charge effect process
-                    if (strict && m_caster->IsScriptOverriden(m_spellInfo, 6953))
-                        m_caster->RemoveMovementImpairingAuras();
-                }
-                if (m_caster->hasUnitState(UNIT_STAT_ROOT))
-                    return SPELL_FAILED_ROOTED;
-                break;
-            }
-            case SPELL_EFFECT_SKINNING:
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER || !m_targets.getUnitTarget() || m_targets.getUnitTarget()->GetTypeId() != TYPEID_UNIT)
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                if (!(m_targets.getUnitTarget()->GetUInt32Value(UNIT_FIELD_FLAGS) & UNIT_FLAG_SKINNABLE))
-                    return SPELL_FAILED_TARGET_UNSKINNABLE;
-
-                Creature* creature = m_targets.getUnitTarget()->ToCreature();
-                if (creature->GetCreatureType() != CREATURE_TYPE_CRITTER && !creature->loot.isLooted())
-                    return SPELL_FAILED_TARGET_NOT_LOOTED;
-
-                uint32 skill = creature->GetCreatureInfo()->GetRequiredLootSkill();
-
-                int32 skillValue = m_caster->ToPlayer()->GetSkillValue(skill);
-                int32 TargetLevel = m_targets.getUnitTarget()->getLevel();
-                int32 ReqValue = (skillValue < 100 ? (TargetLevel-10) * 10 : TargetLevel * 5);
-                if (ReqValue > skillValue)
-                    return SPELL_FAILED_LOW_CASTLEVEL;
-
-                // chance for fail at orange skinning attempt
-                if ((m_selfContainer && (*m_selfContainer) == this) &&
-                    skillValue < sWorld.GetConfigMaxSkillValue() &&
-                    (ReqValue < 0 ? 0 : ReqValue) > irand(skillValue - 25, skillValue + 37))
-                    return SPELL_FAILED_TRY_AGAIN;
-
-                break;
-            }
-            case SPELL_EFFECT_OPEN_LOCK:
-            {
-                if (m_spellInfo->EffectImplicitTargetA[i] != TARGET_GAMEOBJECT &&
-                    m_spellInfo->EffectImplicitTargetA[i] != TARGET_GAMEOBJECT_ITEM)
-                    break;
-
-                if (m_caster->GetTypeId() != TYPEID_PLAYER  // only players can open locks, gather etc.
-                    // we need a go target in case of TARGET_GAMEOBJECT
-                    || (m_spellInfo->EffectImplicitTargetA[i] == TARGET_GAMEOBJECT && !m_targets.getGOTarget()))
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                Item *pTempItem = NULL;
-                if (m_targets.getTargetMask() & TARGET_FLAG_TRADE_ITEM)
-                {
-                    if (TradeData* pTrade = m_caster->ToPlayer()->GetTradeData())
-                        pTempItem = pTrade->GetTraderData()->GetItem(TradeSlots(m_targets.getItemTargetGUID()));
-                }
-                else if (m_targets.getTargetMask() & TARGET_FLAG_ITEM)
-                    pTempItem = m_caster->ToPlayer()->GetItemByGuid(m_targets.getItemTargetGUID());
-
-                // we need a go target, or an openable item target in case of TARGET_GAMEOBJECT_ITEM
-                if (m_spellInfo->EffectImplicitTargetA[i] == TARGET_GAMEOBJECT_ITEM &&
-                    !m_targets.getGOTarget() &&
-                    (!pTempItem || !pTempItem->GetProto()->LockID || !pTempItem->IsLocked()))
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                if (m_spellInfo->Id != 1842 || (m_targets.getGOTarget() &&
-                    m_targets.getGOTarget()->GetGOInfo()->type != GAMEOBJECT_TYPE_TRAP))
-                    if (m_caster->ToPlayer()->InBattleground() && // In Battleground players can use only flags and banners
-                        !m_caster->ToPlayer()->CanUseBattlegroundObject())
-                        return SPELL_FAILED_TRY_AGAIN;
-
-                // get the lock entry
-                uint32 lockId = 0;
-                if (GameObject* go = m_targets.getGOTarget())
-                {
-                    lockId = go->GetGOInfo()->GetLockId();
-                    if (!lockId)
-                        return SPELL_FAILED_BAD_TARGETS;
-                }
-                else if (Item* itm = m_targets.getItemTarget())
-                    lockId = itm->GetProto()->LockID;
-
-                SkillType skillId = SKILL_NONE;
-                int32 reqSkillValue = 0;
-                int32 skillValue = 0;
-
-                // check lock compatibility
-                SpellCastResult res = CanOpenLock(i, lockId, skillId, reqSkillValue, skillValue);
-                if (res != SPELL_CAST_OK)
-                    return res;
-
-                // chance for fail at orange mining/herb/LockPicking gathering attempt
-                // second check prevent fail at rechecks
-                if (skillId != SKILL_NONE && (!m_selfContainer || ((*m_selfContainer) != this)))
-                {
-                    bool canFailAtMax = skillId != SKILL_HERBALISM && skillId != SKILL_MINING;
-
-                    // chance for failure in orange gather / lockpick (gathering skill can't fail at maxskill)
-                    if ((canFailAtMax || skillValue < sWorld.GetConfigMaxSkillValue()) && reqSkillValue > irand(skillValue - 25, skillValue + 37))
-                        return SPELL_FAILED_TRY_AGAIN;
-                }
-                break;
-            }
-            case SPELL_EFFECT_SUMMON_DEAD_PET:
-            {
-                Creature *pet = m_caster->GetGuardianPet();
-                if (!pet)
-                    return SPELL_FAILED_NO_PET;
-
-                if (pet->isAlive())
-                    return SPELL_FAILED_ALREADY_HAVE_SUMMON;
-
-                break;
-            }
-            // This is generic summon effect
-            case SPELL_EFFECT_SUMMON:
-            {
-                SummonPropertiesEntry const *SummonProperties = sSummonPropertiesStore.LookupEntry(m_spellInfo->EffectMiscValueB[i]);
-                if (!SummonProperties)
-                    break;
-                switch(SummonProperties->Category)
-                {
-                    case SUMMON_CATEGORY_PET:
-                        if (m_caster->GetPetGUID())
-                            return SPELL_FAILED_ALREADY_HAVE_SUMMON;
-                    case SUMMON_CATEGORY_PUPPET:
-                        if (m_caster->GetCharmGUID())
-                            return SPELL_FAILED_ALREADY_HAVE_CHARM;
-                        break;
-                }
-                break;
-            }
-            case SPELL_EFFECT_CREATE_TAMED_PET:
-            {
-                if (m_targets.getUnitTarget())
-                {
-                    if (m_targets.getUnitTarget()->GetTypeId() != TYPEID_PLAYER)
-                        return SPELL_FAILED_BAD_TARGETS;
-                    if (m_targets.getUnitTarget()->GetPetGUID())
-                        return SPELL_FAILED_ALREADY_HAVE_SUMMON;
-                }
-                break;
-            }
-            case SPELL_EFFECT_SUMMON_PET:
-            {
-                if (m_caster->GetPetGUID())                  //let warlock do a replacement summon
-                {
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->getClass() == CLASS_WARLOCK)
-                    {
-                        if (strict)                         //starting cast, trigger pet stun (cast by pet so it doesn't attack player)
-                            if (Pet* pet = m_caster->ToPlayer()->GetPet())
-                                pet->CastSpell(pet, 32752, true, NULL, NULL, pet->GetGUID());
-                    }
-                    else
-                        return SPELL_FAILED_ALREADY_HAVE_SUMMON;
-                }
-
-                if (m_caster->GetCharmGUID())
-                    return SPELL_FAILED_ALREADY_HAVE_CHARM;
-
-                break;
-            }
-            case SPELL_EFFECT_SUMMON_PLAYER:
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return SPELL_FAILED_BAD_TARGETS;
-                if (!m_caster->ToPlayer()->GetSelection())
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                Player* target = sObjectMgr.GetPlayer(m_caster->ToPlayer()->GetSelection());
-                if (!target || m_caster->ToPlayer() == target || !target->IsInSameRaidWith(m_caster->ToPlayer()))
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                // check if our map is dungeon
-                if (sMapStore.LookupEntry(m_caster->GetMapId())->IsDungeon())
-                {
-                    Map const* pMap = m_caster->GetMap();
-                    InstanceTemplate const* instance = ObjectMgr::GetInstanceTemplate(pMap->GetId());
-                    if (!instance)
-                        return SPELL_FAILED_TARGET_NOT_IN_INSTANCE;
-                    if (!target->Satisfy(sObjectMgr.GetAccessRequirement(pMap->GetId(), pMap->GetDifficulty()), pMap->GetId()))
-                        return SPELL_FAILED_BAD_TARGETS;
-                }
-                break;
-            }
-            case SPELL_EFFECT_LEAP:
-            case SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER:
-            {
-              //Do not allow to cast it before BG starts.
-                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    if (Battleground const *bg = m_caster->ToPlayer()->GetBattleground())
-                        if (bg->GetStatus() != STATUS_IN_PROGRESS)
-                            return SPELL_FAILED_TRY_AGAIN;
-                break;
-            }
-            case SPELL_EFFECT_STEAL_BENEFICIAL_BUFF:
-            {
-                if (m_targets.getUnitTarget() == m_caster)
-                    return SPELL_FAILED_BAD_TARGETS;
-                break;
-            }
-            case SPELL_EFFECT_LEAP_BACK:
-            {
-                // Spell 781 (Disengage) requires player to be in combat
-                if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->Id == 781 && !m_caster->isInCombat())
-                    return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
-
-                Unit* target = m_targets.getUnitTarget();
-                if (m_caster == target && m_caster->hasUnitState(UNIT_STAT_ROOT))
-                {
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                        return SPELL_FAILED_ROOTED;
-                    else
-                        return SPELL_FAILED_DONT_REPORT;
-                }
-                break;
-            }
-            default:
-                break;
-        }
-    }
-
-    for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
-    {
-        switch(m_spellInfo->EffectApplyAuraName[i])
-        {
-            case SPELL_AURA_DUMMY:
-            {
-                //custom check
-                switch(m_spellInfo->Id)
-                {
-                    // Tag Murloc
-                    case 30877:
-                    {
-                        Unit* target = m_targets.getUnitTarget();
-                        if (!target || target->GetEntry() != 17326)
-                            return SPELL_FAILED_BAD_TARGETS;
-                        break;
-                    }
-                    case 61336:
-                        if (m_caster->GetTypeId() != TYPEID_PLAYER || !m_caster->ToPlayer()->IsInFeralForm())
-                            return SPELL_FAILED_ONLY_SHAPESHIFT;
-                        break;
-                    case 1515:
-                    {
-                        if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                            return SPELL_FAILED_BAD_TARGETS;
-
-                        if (!m_targets.getUnitTarget() || m_targets.getUnitTarget()->GetTypeId() == TYPEID_PLAYER)
-                            return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
-
-                        Creature* target = m_targets.getUnitTarget()->ToCreature();
-
-                        if (target->getLevel() > m_caster->getLevel())
-                            return SPELL_FAILED_HIGHLEVEL;
-
-                        // use SMSG_PET_TAME_FAILURE?
-                        if (!target->GetCreatureInfo()->isTameable (m_caster->ToPlayer()->CanTameExoticPets()))
-                            return SPELL_FAILED_BAD_TARGETS;
-
-                        if (m_caster->GetPetGUID())
-                            return SPELL_FAILED_ALREADY_HAVE_SUMMON;
-
-                        if (m_caster->GetCharmGUID())
-                            return SPELL_FAILED_ALREADY_HAVE_CHARM;
-
-                        break;
-                    }
-                    case 44795: // Parachute
-                    {
-                        float x, y, z;
-                        m_caster->GetPosition(x, y, z);
-                        float ground_Z = m_caster->GetMap()->GetHeight(x, y, z);
-                        if (fabs(ground_Z - z) < 0.1f)
-                            return SPELL_FAILED_DONT_REPORT;
-                        break;
-                    }
-                    default:
-                        break;
-                }
-                break;
-            }
-            case SPELL_AURA_MOD_POSSESS_PET:
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return SPELL_FAILED_NO_PET;
-
-                Pet *pet = m_caster->ToPlayer()->GetPet();
-                if (!pet)
-                    return SPELL_FAILED_NO_PET;
-
-                if (pet->GetCharmerGUID())
-                    return SPELL_FAILED_CHARMED;
-                break;
-            }
-            case SPELL_AURA_MOD_POSSESS:
-            case SPELL_AURA_MOD_CHARM:
-            case SPELL_AURA_AOE_CHARM:
-            {
-                if (m_caster->GetCharmerGUID())
-                    return SPELL_FAILED_CHARMED;
-
-                if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_CHARM
-                    || m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_POSSESS)
-                {
-                    if (m_caster->GetPetGUID())
-                        return SPELL_FAILED_ALREADY_HAVE_SUMMON;
-
-                    if (m_caster->GetCharmGUID())
-                        return SPELL_FAILED_ALREADY_HAVE_CHARM;
-                }
-
-                if (Unit *target = m_targets.getUnitTarget())
-                {
-                    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsVehicle())
-                        return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
-
-                    if (target->IsMounted())
-                        return SPELL_FAILED_CANT_BE_CHARMED;
-
-                    if (target->GetCharmerGUID())
-                        return SPELL_FAILED_CHARMED;
-
-                    int32 damage = CalculateDamage(i, target);
-                    if (damage && int32(target->getLevel()) > damage)
-                        return SPELL_FAILED_HIGHLEVEL;
-                }
-
-                break;
-            }
-            case SPELL_AURA_MOUNTED:
-            {
-                if (m_caster->IsInWater())
-                    return SPELL_FAILED_ONLY_ABOVEWATER;
-
-                // Ignore map check if spell have AreaId. AreaId already checked and this prevent special mount spells
-                bool AllowMount = !m_caster->GetMap()->IsDungeon() || m_caster->GetMap()->IsBattlegroundOrArena();
-                InstanceTemplate const *it = sObjectMgr.GetInstanceTemplate(m_caster->GetMapId());
-                if (it)
-                    AllowMount = it->allowMount;
-                if (m_caster->GetTypeId() == TYPEID_PLAYER && !AllowMount && !m_IsTriggeredSpell && !m_spellInfo->AreaGroupId)
-                    return SPELL_FAILED_NO_MOUNTS_ALLOWED;
-
-                ShapeshiftForm form = m_caster->m_form;
-                if (form == FORM_CAT          || form == FORM_TREE      || form == FORM_TRAVEL   ||
-                    form == FORM_AQUA         || form == FORM_BEAR      || form == FORM_DIREBEAR ||
-                    form == FORM_CREATUREBEAR || form == FORM_GHOSTWOLF || form == FORM_FLIGHT   ||
-                    form == FORM_FLIGHT_EPIC  || form == FORM_MOONKIN   || form == FORM_METAMORPHOSIS)
-                    return SPELL_FAILED_NOT_SHAPESHIFT;
-
-                break;
-            }
-            case SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS:
-            {
-                if (!m_targets.getUnitTarget())
-                    return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
-
-                // can be casted at non-friendly unit or own pet/charm
-                if (m_caster->IsFriendlyTo(m_targets.getUnitTarget()))
-                    return SPELL_FAILED_TARGET_FRIENDLY;
-
-                break;
-            }
-            case SPELL_AURA_FLY:
-            case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
-            {
-                // not allow cast fly spells if not have req. skills  (all spells is self target)
-                // allow always ghost flight spells
-                if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
-                {
-                    if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
-                    {
-                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                            return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
-                        // Wintergrasp Antifly check
-                        if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-                        {
-                          if (m_originalCaster->GetZoneId() == 4197 && pvpWG && pvpWG != 0  && pvpWG->isWarTime()==true)
-                          return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELL_AURA_PERIODIC_MANA_LEECH:
-            {
-                if (!m_targets.getUnitTarget())
-                    return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
-
-                if (m_caster->GetTypeId() != TYPEID_PLAYER || m_CastItem)
-                    break;
-
-                if (m_targets.getUnitTarget()->getPowerType() != POWER_MANA)
-                    return SPELL_FAILED_BAD_TARGETS;
-
-                break;
-            }
-            default:
-                break;
-        }
-    }
-
-    // check trade slot case (last, for allow catch any another cast problems)
-    if (m_targets.getTargetMask() & TARGET_FLAG_TRADE_ITEM)
-    {
-        if (m_caster->GetTypeId() != TYPEID_PLAYER)
-            return SPELL_FAILED_NOT_TRADING;
-
-        TradeData* my_trade = m_caster->ToPlayer()->GetTradeData();
-
-        if (!my_trade)
-            return SPELL_FAILED_NOT_TRADING;
-
-        TradeSlots slot = TradeSlots(m_targets.getItemTargetGUID());
-        if (slot != TRADE_SLOT_NONTRADED)
-            return SPELL_FAILED_BAD_TARGETS;
-
-        if (!m_IsTriggeredSpell)
-            if (my_trade->GetSpell())
-                return SPELL_FAILED_ITEM_ALREADY_ENCHANTED;
-    }
-
-    // check if caster has at least 1 combo point for spells that require combo points
-    if (m_needComboPoints)
-        if (Player* plrCaster = m_caster->ToPlayer())
-            if (!plrCaster->GetComboPoints())
-                return SPELL_FAILED_NO_COMBO_POINTS;
-
-    // all ok
-    return SPELL_CAST_OK;
-}
-
-SpellCastResult Spell::CheckPetCast(Unit* target)
-{
-    if (!m_caster->isAlive() && !(m_spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD))
-        return SPELL_FAILED_CASTER_DEAD;
-
-    if (m_caster->hasUnitState(UNIT_STAT_CASTING) && !m_IsTriggeredSpell)              //prevent spellcast interruption by another spellcast
-        return SPELL_FAILED_SPELL_IN_PROGRESS;
-    if (m_caster->isInCombat() && IsNonCombatSpell(m_spellInfo))
-        return SPELL_FAILED_AFFECTING_COMBAT;
-
-                                                            //dead owner (pets still alive when owners ressed?)
-        if (Unit *owner = m_caster->GetCharmerOrOwner())
-            if (!owner->isAlive())
-                return SPELL_FAILED_CASTER_DEAD;
-
-        if (!target && m_targets.getUnitTarget())
-            target = m_targets.getUnitTarget();
-
-        for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (SpellTargetType[m_spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET
-                || SpellTargetType[m_spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_DEST_TARGET)
-            {
-                if (!target)
-                    return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
-                m_targets.setUnitTarget(target);
-                break;
-            }
-        }
-
-        Unit* _target = m_targets.getUnitTarget();
-
-        if (_target)                                         //for target dead/target not valid
-        {
-            if (!_target->isAlive())
-                return SPELL_FAILED_BAD_TARGETS;
-
-            if (!IsValidSingleTargetSpell(_target))
-                return SPELL_FAILED_BAD_TARGETS;
-        }
-                                                            //cooldown
-        if (m_caster->ToCreature()->HasSpellCooldown(m_spellInfo->Id))
-            return SPELL_FAILED_NOT_READY;
-
-    return CheckCast(true);
-}
-
-SpellCastResult Spell::CheckCasterAuras() const
-{
-    // spells totally immuned to caster auras (wsg flag drop, give marks etc)
-    if (m_spellInfo->AttributesEx6& SPELL_ATTR_EX6_IGNORE_CASTER_AURAS)
-        return SPELL_CAST_OK;
-
-    uint8 school_immune = 0;
-    uint32 mechanic_immune = 0;
-    uint32 dispel_immune = 0;
-
-    // Check if the spell grants school or mechanic immunity.
-    // We use bitmasks so the loop is done only once and not on every aura check below.
-    if (m_spellInfo->AttributesEx & SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY)
-    {
-        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_SCHOOL_IMMUNITY)
-                school_immune |= uint32(m_spellInfo->EffectMiscValue[i]);
-            else if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MECHANIC_IMMUNITY)
-                mechanic_immune |= 1 << uint32(m_spellInfo->EffectMiscValue[i]);
-            else if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_DISPEL_IMMUNITY)
-                dispel_immune |= GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[i]));
-        }
-        // immune movement impairment and loss of control
-        if (m_spellInfo->Id == 42292 || m_spellInfo->Id == 59752)
-            mechanic_immune = IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK;
-    }
-
-    // Check whether the cast should be prevented by any state you might have.
-    SpellCastResult prevented_reason = SPELL_CAST_OK;
-    // Have to check if there is a stun aura. Otherwise will have problems with ghost aura apply while logging out
-    uint32 unitflag = m_caster->GetUInt32Value(UNIT_FIELD_FLAGS);     // Get unit state
-    if (unitflag & UNIT_FLAG_STUNNED && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_STUNNED))
-        prevented_reason = SPELL_FAILED_STUNNED;
-    else if (unitflag & UNIT_FLAG_CONFUSED && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_CONFUSED))
-        prevented_reason = SPELL_FAILED_CONFUSED;
-    else if (unitflag & UNIT_FLAG_FLEEING && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_FEARED))
-        prevented_reason = SPELL_FAILED_FLEEING;
-    else if (unitflag & UNIT_FLAG_SILENCED && m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
-        prevented_reason = SPELL_FAILED_SILENCED;
-    else if (unitflag & UNIT_FLAG_PACIFIED && m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_PACIFY)
-        prevented_reason = SPELL_FAILED_PACIFIED;
-
-    // Attr must make flag drop spell totally immune from all effects
-    if (prevented_reason != SPELL_CAST_OK)
-    {
-        if (school_immune || mechanic_immune || dispel_immune)
-        {
-            //Checking auras is needed now, because you are prevented by some state but the spell grants immunity.
-            Unit::AuraApplicationMap const& auras = m_caster->GetAppliedAuras();
-            for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-            {
-                Aura const * aura = itr->second->GetBase();
-                if (GetAllSpellMechanicMask(aura->GetSpellProto()) & mechanic_immune)
-                    continue;
-                if (GetSpellSchoolMask(aura->GetSpellProto()) & school_immune)
-                    continue;
-                if ((1<<(aura->GetSpellProto()->Dispel)) & dispel_immune)
-                    continue;
-
-                //Make a second check for spell failed so the right SPELL_FAILED message is returned.
-                //That is needed when your casting is prevented by multiple states and you are only immune to some of them.
-                for (uint8 i=0; i<MAX_SPELL_EFFECTS; ++i)
-                {
-                    if (AuraEffect * part = aura->GetEffect(i))
-                    {
-                        switch(part->GetAuraType())
-                        {
-                            case SPELL_AURA_MOD_STUN:
-                                if (!(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_STUNNED))
-                                    return SPELL_FAILED_STUNNED;
-                                break;
-                            case SPELL_AURA_MOD_CONFUSE:
-                                if (!(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_CONFUSED))
-                                    return SPELL_FAILED_CONFUSED;
-                                break;
-                            case SPELL_AURA_MOD_FEAR:
-                                if (!(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_FEARED))
-                                    return SPELL_FAILED_FLEEING;
-                                break;
-                            case SPELL_AURA_MOD_SILENCE:
-                            case SPELL_AURA_MOD_PACIFY:
-                            case SPELL_AURA_MOD_PACIFY_SILENCE:
-                                if (m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_PACIFY)
-                                    return SPELL_FAILED_PACIFIED;
-                                else if (m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
-                                    return SPELL_FAILED_SILENCED;
-                                break;
-                            default: break;
-                        }
-                    }
-                }
-            }
-        }
-        // You are prevented from casting and the spell casted does not grant immunity. Return a failed error.
-        else
-            return prevented_reason;
-    }
-    return SPELL_CAST_OK;
-}
-
-bool Spell::CanAutoCast(Unit* target)
-{
-    uint64 targetguid = target->GetGUID();
-
-    for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        if (m_spellInfo->Effect[j] == SPELL_EFFECT_APPLY_AURA)
-        {
-            if (m_spellInfo->StackAmount <= 1)
-            {
-                if (target->HasAuraEffect(m_spellInfo->Id, j))
-                    return false;
-            }
-            else
-            {
-                if (AuraEffect * aureff = target->GetAuraEffect(m_spellInfo->Id, j))
-                    if (aureff->GetBase()->GetStackAmount() >= m_spellInfo->StackAmount)
-                        return false;
-            }
-        }
-        else if (IsAreaAuraEffect(m_spellInfo->Effect[j]))
-        {
-            if (target->HasAuraEffect(m_spellInfo->Id, j))
-                return false;
-        }
-    }
-
-    SpellCastResult result = CheckPetCast(target);
-
-    if (result == SPELL_CAST_OK || result == SPELL_FAILED_UNIT_NOT_INFRONT)
-    {
-        SelectSpellTargets();
-        //check if among target units, our WANTED target is as well (->only self cast spells return false)
-        for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-            if (ihit->targetGUID == targetguid)
-                return true;
-    }
-    return false;                                           //target invalid
-}
-
-SpellCastResult Spell::CheckRange(bool strict)
-{
-    // self cast doesn't need range checking -- also for Starshards fix
-    if (m_spellInfo->rangeIndex == 1)
-        return SPELL_CAST_OK;
-
-    // Don't check for instant cast spells
-    if (!strict && m_casttime == 0)
-        return SPELL_CAST_OK;
-
-    SpellRangeEntry const* srange = sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex);
-
-    Unit *target = m_targets.getUnitTarget();
-    float max_range = (float)m_caster->GetSpellMaxRangeForTarget(target, srange);
-    float min_range = (float)m_caster->GetSpellMinRangeForTarget(target, srange);
-    uint32 range_type = GetSpellRangeType(srange);
-
-    if (Player* modOwner = m_caster->GetSpellModOwner())
-        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, max_range, this);
-
-    if (target && target != m_caster)
-    {
-        if (range_type == SPELL_RANGE_MELEE)
-        {
-            // Because of lag, we can not check too strictly here.
-            if (!m_caster->IsWithinMeleeRange(target, max_range))
-                return SPELL_FAILED_OUT_OF_RANGE;
-        }
-        else if (!m_caster->IsWithinCombatRange(target, max_range))
-            return SPELL_FAILED_OUT_OF_RANGE;               //0x5A;
-
-        if (range_type == SPELL_RANGE_RANGED)
-        {
-            if (m_caster->IsWithinMeleeRange(target))
-                return SPELL_FAILED_TOO_CLOSE;
-        }
-        else if (min_range && m_caster->IsWithinCombatRange(target, min_range)) // skip this check if min_range = 0
-            return SPELL_FAILED_TOO_CLOSE;
-
-        if (m_caster->GetTypeId() == TYPEID_PLAYER &&
-            (m_spellInfo->FacingCasterFlags & SPELL_FACING_FLAG_INFRONT) && !m_caster->HasInArc(static_cast<float>(M_PI), target))
-            return SPELL_FAILED_UNIT_NOT_INFRONT;
-    }
-
-    if (m_targets.HasDst() && !m_targets.HasTraj())
-    {
-        if (!m_caster->IsWithinDist3d(&m_targets.m_dstPos, max_range))
-            return SPELL_FAILED_OUT_OF_RANGE;
-        if (min_range && m_caster->IsWithinDist3d(&m_targets.m_dstPos, min_range))
-            return SPELL_FAILED_TOO_CLOSE;
-    }
-
-    return SPELL_CAST_OK;
-}
-
-SpellCastResult Spell::CheckPower()
-{
-    // item cast not used power
-    if (m_CastItem)
-        return SPELL_CAST_OK;
-
-    // health as power used - need check health amount
-    if (m_spellInfo->powerType == POWER_HEALTH)
-    {
-        if (int32(m_caster->GetHealth()) <= m_powerCost)
-            return SPELL_FAILED_CASTER_AURASTATE;
-        return SPELL_CAST_OK;
-    }
-    // Check valid power type
-    if (m_spellInfo->powerType >= MAX_POWERS)
-    {
-        sLog.outError("Spell::CheckPower: Unknown power type '%d'", m_spellInfo->powerType);
-        return SPELL_FAILED_UNKNOWN;
-    }
-
-    //check rune cost only if a spell has PowerType == POWER_RUNE
-    if (m_spellInfo->powerType == POWER_RUNE)
-    {
-        SpellCastResult failReason = CheckRuneCost(m_spellInfo->runeCostID);
-        if (failReason != SPELL_CAST_OK)
-            return failReason;
-    }
-
-    // Check power amount
-    Powers powerType = Powers(m_spellInfo->powerType);
-    if (int32(m_caster->GetPower(powerType)) < m_powerCost)
-        return SPELL_FAILED_NO_POWER;
-    else
-        return SPELL_CAST_OK;
-}
-
-SpellCastResult Spell::CheckItems()
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return SPELL_CAST_OK;
-
-    Player* p_caster = (Player*)m_caster;
-
-    if (!m_CastItem)
-    {
-        if (m_castItemGUID)
-            return SPELL_FAILED_ITEM_NOT_READY;
-    }
-    else
-    {
-        uint32 itemid = m_CastItem->GetEntry();
-        if (!p_caster->HasItemCount(itemid, 1))
-            return SPELL_FAILED_ITEM_NOT_READY;
-
-        ItemPrototype const *proto = m_CastItem->GetProto();
-        if (!proto)
-            return SPELL_FAILED_ITEM_NOT_READY;
-
-        for (int i = 0; i < MAX_ITEM_SPELLS; ++i)
-            if (proto->Spells[i].SpellCharges)
-                if (m_CastItem->GetSpellCharges(i) == 0)
-                    return SPELL_FAILED_NO_CHARGES_REMAIN;
-
-        // consumable cast item checks
-        if (proto->Class == ITEM_CLASS_CONSUMABLE && m_targets.getUnitTarget())
-        {
-            // such items should only fail if there is no suitable effect at all - see Rejuvenation Potions for example
-            SpellCastResult failReason = SPELL_CAST_OK;
-            for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
-            {
-                    // skip check, pet not required like checks, and for TARGET_UNIT_PET m_targets.getUnitTarget() is not the real target but the caster
-                    if (m_spellInfo->EffectImplicitTargetA[i] == TARGET_UNIT_PET)
-                    continue;
-
-                if (m_spellInfo->Effect[i] == SPELL_EFFECT_HEAL)
-                {
-                    if (m_targets.getUnitTarget()->IsFullHealth())
-                    {
-                        failReason = SPELL_FAILED_ALREADY_AT_FULL_HEALTH;
-                        continue;
-                    }
-                    else
-                    {
-                        failReason = SPELL_CAST_OK;
-                        break;
-                    }
-                }
-
-                // Mana Potion, Rage Potion, Thistle Tea(Rogue), ...
-                if (m_spellInfo->Effect[i] == SPELL_EFFECT_ENERGIZE)
-                {
-                    if (m_spellInfo->EffectMiscValue[i] < 0 || m_spellInfo->EffectMiscValue[i] >= int8(MAX_POWERS))
-                    {
-                        failReason = SPELL_FAILED_ALREADY_AT_FULL_POWER;
-                        continue;
-                    }
-
-                    Powers power = Powers(m_spellInfo->EffectMiscValue[i]);
-                    if (m_targets.getUnitTarget()->GetPower(power) == m_targets.getUnitTarget()->GetMaxPower(power))
-                    {
-                        failReason = SPELL_FAILED_ALREADY_AT_FULL_POWER;
-                        continue;
-                    }
-                    else
-                    {
-                        failReason = SPELL_CAST_OK;
-                        break;
-                    }
-                }
-            }
-            if (failReason != SPELL_CAST_OK)
-                return failReason;
-        }
-    }
-
-    // check target item
-    if (m_targets.getItemTargetGUID())
-    {
-        if (m_caster->GetTypeId() != TYPEID_PLAYER)
-            return SPELL_FAILED_BAD_TARGETS;
-
-        if (!m_targets.getItemTarget())
-            return SPELL_FAILED_ITEM_GONE;
-
-        if (!m_targets.getItemTarget()->IsFitToSpellRequirements(m_spellInfo))
-            return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
-    }
-    // if not item target then required item must be equipped
-    else
-    {
-        if (m_caster->GetTypeId() == TYPEID_PLAYER && !m_caster->ToPlayer()->HasItemFitToSpellReqirements(m_spellInfo))
-            return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
-    }
-
-    // check spell focus object
-    if (m_spellInfo->RequiresSpellFocus)
-    {
-        CellPair p(Trinity::ComputeCellPair(m_caster->GetPositionX(), m_caster->GetPositionY()));
-        Cell cell(p);
-        cell.data.Part.reserved = ALL_DISTRICT;
-
-        GameObject* ok = NULL;
-        Trinity::GameObjectFocusCheck go_check(m_caster,m_spellInfo->RequiresSpellFocus);
-        Trinity::GameObjectSearcher<Trinity::GameObjectFocusCheck> checker(m_caster, ok, go_check);
-
-        TypeContainerVisitor<Trinity::GameObjectSearcher<Trinity::GameObjectFocusCheck>, GridTypeMapContainer > object_checker(checker);
-        Map& map = *m_caster->GetMap();
-        cell.Visit(p, object_checker, map, *m_caster, map.GetVisibilityDistance());
-
-        if (!ok)
-            return SPELL_FAILED_REQUIRES_SPELL_FOCUS;
-
-        focusObject = ok;                                   // game object found in range
-    }
-
-    // do not take reagents for these item casts
-    if (!(m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST))
-    {
-        // check reagents (ignore triggered spells with reagents processed by original spell) and special reagent ignore case.
-        if (!m_IsTriggeredSpell && !p_caster->CanNoReagentCast(m_spellInfo))
-        {
-            for (uint32 i = 0; i < MAX_SPELL_REAGENTS; i++)
-            {
-                if (m_spellInfo->Reagent[i] <= 0)
-                    continue;
-
-                uint32 itemid    = m_spellInfo->Reagent[i];
-                uint32 itemcount = m_spellInfo->ReagentCount[i];
-
-                // if CastItem is also spell reagent
-                if (m_CastItem && m_CastItem->GetEntry() == itemid)
-                {
-                    ItemPrototype const *proto = m_CastItem->GetProto();
-                    if (!proto)
-                        return SPELL_FAILED_ITEM_NOT_READY;
-                    for (int s=0; s < MAX_ITEM_PROTO_SPELLS; ++s)
-                    {
-                        // CastItem will be used up and does not count as reagent
-                        int32 charges = m_CastItem->GetSpellCharges(s);
-                        if (proto->Spells[s].SpellCharges < 0 && abs(charges) < 2)
-                        {
-                            ++itemcount;
-                            break;
-                        }
-                    }
-                }
-                if (!p_caster->HasItemCount(itemid,itemcount))
-                    return SPELL_FAILED_ITEM_NOT_READY;         //0x54
-            }
-        }
-
-        // check totem-item requirements (items presence in inventory)
-        uint32 totems = 2;
-        for (int i = 0; i < 2 ; ++i)
-        {
-            if (m_spellInfo->Totem[i] != 0)
-            {
-                if (p_caster->HasItemCount(m_spellInfo->Totem[i],1))
-                {
-                    totems -= 1;
-                    continue;
-                }
-            }else
-            totems -= 1;
-        }
-        if (totems != 0)
-            return SPELL_FAILED_TOTEMS;                         //0x7C
-
-        // Check items for TotemCategory  (items presence in inventory)
-        uint32 TotemCategory = 2;
-        for (int i= 0; i < 2; ++i)
-        {
-            if (m_spellInfo->TotemCategory[i] != 0)
-            {
-                if (p_caster->HasItemTotemCategory(m_spellInfo->TotemCategory[i]))
-                {
-                    TotemCategory -= 1;
-                    continue;
-                }
-            }
-            else
-                TotemCategory -= 1;
-        }
-        if (TotemCategory != 0)
-            return SPELL_FAILED_TOTEM_CATEGORY;                 //0x7B
-    }
-
-    // special checks for spell effects
-    for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
-    {
-        switch (m_spellInfo->Effect[i])
-        {
-            case SPELL_EFFECT_CREATE_ITEM:
-            case SPELL_EFFECT_CREATE_ITEM_2:
-            {
-                if (!m_IsTriggeredSpell && m_spellInfo->EffectItemType[i])
-                {
-                    ItemPosCountVec dest;
-                    uint8 msg = p_caster->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, m_spellInfo->EffectItemType[i], 1);
-                    if (msg != EQUIP_ERR_OK)
-                    {
-                        ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(m_spellInfo->EffectItemType[i]);
-                        // TODO: Needs review
-                        if (pProto && !(pProto->ItemLimitCategory))
-                        {
-                            p_caster->SendEquipError(msg, NULL, NULL, m_spellInfo->EffectItemType[i]);
-                            return SPELL_FAILED_DONT_REPORT;
-                        }
-                        else
-                        {
-                            if (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE && (m_spellInfo->SpellFamilyFlags[0] & 0x40000000)))
-                                return SPELL_FAILED_TOO_MANY_OF_ITEM;
-                            else if (!(p_caster->HasItemCount(m_spellInfo->EffectItemType[i],1)))
-                                return SPELL_FAILED_TOO_MANY_OF_ITEM;
-                            else
-                                p_caster->CastSpell(m_caster,SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1),false);        // move this to anywhere
-                            return SPELL_FAILED_DONT_REPORT;
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELL_EFFECT_ENCHANT_ITEM:
-                if (m_spellInfo->EffectItemType[i] && m_targets.getItemTarget()
-                    && (m_targets.getItemTarget()->IsWeaponVellum() || m_targets.getItemTarget()->IsArmorVellum()))
-                {
-                    // cannot enchant vellum for other player
-                    if (m_targets.getItemTarget()->GetOwner() != m_caster)
-                        return SPELL_FAILED_NOT_TRADEABLE;
-                    // do not allow to enchant vellum from scroll made by vellum-prevent exploit
-                    if (m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST)
-                        return SPELL_FAILED_TOTEM_CATEGORY;
-                    ItemPosCountVec dest;
-                    uint8 msg = p_caster->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, m_spellInfo->EffectItemType[i], 1);
-                    if (msg != EQUIP_ERR_OK)
-                    {
-                        p_caster->SendEquipError(msg, NULL, NULL, m_spellInfo->EffectItemType[i]);
-                        return SPELL_FAILED_DONT_REPORT;
-                    }
-                }
-            case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
-            {
-                Item* targetItem = m_targets.getItemTarget();
-                if (!targetItem)
-                    return SPELL_FAILED_ITEM_NOT_FOUND;
-
-                if (targetItem->GetProto()->ItemLevel < m_spellInfo->baseLevel)
-                    return SPELL_FAILED_LOWLEVEL;
-
-                bool isItemUsable = false;
-                for (uint8 e = 0; e < MAX_ITEM_PROTO_SPELLS; ++e)
-                {
-                    ItemPrototype const *proto = targetItem->GetProto();
-                    if (proto->Spells[e].SpellId && (
-                        proto->Spells[e].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE ||
-                        proto->Spells[e].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE))
-                    {
-                        isItemUsable = true;
-                        break;
-                    }
-                }
-
-                SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(m_spellInfo->EffectMiscValue[i]);
-                // do not allow adding usable enchantments to items that have use effect already
-                if (pEnchant && isItemUsable)
-                    for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
-                        if (pEnchant->type[s] == ITEM_ENCHANTMENT_TYPE_USE_SPELL)
-                            return SPELL_FAILED_ON_USE_ENCHANT;
-
-                // Not allow enchant in trade slot for some enchant type
-                if (targetItem->GetOwner() != m_caster)
-                {
-                    if (!pEnchant)
-                        return SPELL_FAILED_ERROR;
-                    if (pEnchant->slot & ENCHANTMENT_CAN_SOULBOUND)
-                        return SPELL_FAILED_NOT_TRADEABLE;
-                }
-                break;
-            }
-            case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
-            {
-                Item *item = m_targets.getItemTarget();
-                if (!item)
-                    return SPELL_FAILED_ITEM_NOT_FOUND;
-                // Not allow enchant in trade slot for some enchant type
-                if (item->GetOwner() != m_caster)
-                {
-                    uint32 enchant_id = m_spellInfo->EffectMiscValue[i];
-                    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-                    if (!pEnchant)
-                        return SPELL_FAILED_ERROR;
-                    if (pEnchant->slot & ENCHANTMENT_CAN_SOULBOUND)
-                        return SPELL_FAILED_NOT_TRADEABLE;
-                }
-                break;
-            }
-            case SPELL_EFFECT_ENCHANT_HELD_ITEM:
-                // check item existence in effect code (not output errors at offhand hold item effect to main hand for example
-                break;
-            case SPELL_EFFECT_DISENCHANT:
-            {
-                if (!m_targets.getItemTarget())
-                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
-
-                // prevent disenchanting in trade slot
-                if (m_targets.getItemTarget()->GetOwnerGUID() != m_caster->GetGUID())
-                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
-
-                ItemPrototype const* itemProto = m_targets.getItemTarget()->GetProto();
-                if (!itemProto)
-                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
-
-                uint32 item_quality = itemProto->Quality;
-                // 2.0.x addon: Check player enchanting level against the item disenchanting requirements
-                uint32 item_disenchantskilllevel = itemProto->RequiredDisenchantSkill;
-                if (item_disenchantskilllevel == uint32(-1))
-                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
-                if (item_disenchantskilllevel > p_caster->GetSkillValue(SKILL_ENCHANTING))
-                    return SPELL_FAILED_LOW_CASTLEVEL;
-                if (item_quality > 4 || item_quality < 2)
-                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
-                if (itemProto->Class != ITEM_CLASS_WEAPON && itemProto->Class != ITEM_CLASS_ARMOR)
-                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
-                if (!itemProto->DisenchantID)
-                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
-                break;
-            }
-            case SPELL_EFFECT_PROSPECTING:
-            {
-                if (!m_targets.getItemTarget())
-                    return SPELL_FAILED_CANT_BE_PROSPECTED;
-                //ensure item is a prospectable ore
-                if (!(m_targets.getItemTarget()->GetProto()->Flags & ITEM_PROTO_FLAG_PROSPECTABLE))
-                    return SPELL_FAILED_CANT_BE_PROSPECTED;
-                //prevent prospecting in trade slot
-                if (m_targets.getItemTarget()->GetOwnerGUID() != m_caster->GetGUID())
-                    return SPELL_FAILED_CANT_BE_PROSPECTED;
-                //Check for enough skill in jewelcrafting
-                uint32 item_prospectingskilllevel = m_targets.getItemTarget()->GetProto()->RequiredSkillRank;
-                if (item_prospectingskilllevel >p_caster->GetSkillValue(SKILL_JEWELCRAFTING))
-                    return SPELL_FAILED_LOW_CASTLEVEL;
-                //make sure the player has the required ores in inventory
-                if (m_targets.getItemTarget()->GetCount() < 5)
-                    return SPELL_FAILED_NEED_MORE_ITEMS;
-
-                if (!LootTemplates_Prospecting.HaveLootFor(m_targets.getItemTargetEntry()))
-                    return SPELL_FAILED_CANT_BE_PROSPECTED;
-
-                break;
-            }
-            case SPELL_EFFECT_MILLING:
-            {
-                if (!m_targets.getItemTarget())
-                    return SPELL_FAILED_CANT_BE_MILLED;
-                //ensure item is a millable herb
-                if (!(m_targets.getItemTarget()->GetProto()->Flags & ITEM_PROTO_FLAG_MILLABLE))
-                    return SPELL_FAILED_CANT_BE_MILLED;
-                //prevent milling in trade slot
-                if (m_targets.getItemTarget()->GetOwnerGUID() != m_caster->GetGUID())
-                    return SPELL_FAILED_CANT_BE_MILLED;
-                //Check for enough skill in inscription
-                uint32 item_millingskilllevel = m_targets.getItemTarget()->GetProto()->RequiredSkillRank;
-                if (item_millingskilllevel >p_caster->GetSkillValue(SKILL_INSCRIPTION))
-                    return SPELL_FAILED_LOW_CASTLEVEL;
-                //make sure the player has the required herbs in inventory
-                if (m_targets.getItemTarget()->GetCount() < 5)
-                    return SPELL_FAILED_NEED_MORE_ITEMS;
-
-                if (!LootTemplates_Milling.HaveLootFor(m_targets.getItemTargetEntry()))
-                    return SPELL_FAILED_CANT_BE_MILLED;
-
-                break;
-            }
-            case SPELL_EFFECT_WEAPON_DAMAGE:
-            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER) return SPELL_FAILED_TARGET_NOT_PLAYER;
-                if (m_attackType != RANGED_ATTACK)
-                    break;
-                Item *pItem = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType);
-                if (!pItem || pItem->IsBroken())
-                    return SPELL_FAILED_EQUIPPED_ITEM;
-
-                switch(pItem->GetProto()->SubClass)
-                {
-                    case ITEM_SUBCLASS_WEAPON_THROWN:
-                    {
-                        uint32 ammo = pItem->GetEntry();
-                        if (!m_caster->ToPlayer()->HasItemCount(ammo, 1))
-                            return SPELL_FAILED_NO_AMMO;
-                    };  break;
-                    case ITEM_SUBCLASS_WEAPON_GUN:
-                    case ITEM_SUBCLASS_WEAPON_BOW:
-                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
-                    {
-                        uint32 ammo = m_caster->ToPlayer()->GetUInt32Value(PLAYER_AMMO_ID);
-                        if (!ammo)
-                        {
-                            // Requires No Ammo
-                            if (m_caster->HasAura(46699))
-                                break;                      // skip other checks
-
-                            return SPELL_FAILED_NO_AMMO;
-                        }
-
-                        ItemPrototype const *ammoProto = sObjectMgr.GetItemPrototype(ammo);
-                        if (!ammoProto)
-                            return SPELL_FAILED_NO_AMMO;
-
-                        if (ammoProto->Class != ITEM_CLASS_PROJECTILE)
-                            return SPELL_FAILED_NO_AMMO;
-
-                        // check ammo ws. weapon compatibility
-                        switch(pItem->GetProto()->SubClass)
-                        {
-                            case ITEM_SUBCLASS_WEAPON_BOW:
-                            case ITEM_SUBCLASS_WEAPON_CROSSBOW:
-                                if (ammoProto->SubClass != ITEM_SUBCLASS_ARROW)
-                                    return SPELL_FAILED_NO_AMMO;
-                                break;
-                            case ITEM_SUBCLASS_WEAPON_GUN:
-                                if (ammoProto->SubClass != ITEM_SUBCLASS_BULLET)
-                                    return SPELL_FAILED_NO_AMMO;
-                                break;
-                            default:
-                                return SPELL_FAILED_NO_AMMO;
-                        }
-
-                        if (!m_caster->ToPlayer()->HasItemCount(ammo, 1))
-                        {
-                            m_caster->ToPlayer()->SetUInt32Value(PLAYER_AMMO_ID, 0);
-                            return SPELL_FAILED_NO_AMMO;
-                        }
-                    };  break;
-                    case ITEM_SUBCLASS_WEAPON_WAND:
-                        break;
-                    default:
-                        break;
-                }
-                break;
-            }
-            case SPELL_EFFECT_CREATE_MANA_GEM:
-            {
-                 uint32 item_id = m_spellInfo->EffectItemType[i];
-                 ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item_id);
-
-                 if (!pProto)
-                     return SPELL_FAILED_ITEM_AT_MAX_CHARGES;
-
-                 if (Item* pitem = p_caster->GetItemByEntry(item_id))
-                 {
-                     for (int x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
-                         if (pProto->Spells[x].SpellCharges != 0 && pitem->GetSpellCharges(x) == pProto->Spells[x].SpellCharges)
-                             return SPELL_FAILED_ITEM_AT_MAX_CHARGES;
-                 }
-                 break;
-            }
-            default:
-                break;
-        }
-    }
-
-    // check weapon presence in slots for main/offhand weapons
-    if (m_spellInfo->EquippedItemClass >=0)
-    {
-        // main hand weapon required
-        if (m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_MAIN_HAND)
-        {
-            Item* item = m_caster->ToPlayer()->GetWeaponForAttack(BASE_ATTACK);
-
-            // skip spell if no weapon in slot or broken
-            if (!item || item->IsBroken())
-                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
-
-            // skip spell if weapon not fit to triggered spell
-            if (!item->IsFitToSpellRequirements(m_spellInfo))
-                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
-        }
-
-        // offhand hand weapon required
-        if (m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_REQ_OFFHAND)
-        {
-            Item* item = m_caster->ToPlayer()->GetWeaponForAttack(OFF_ATTACK);
-
-            // skip spell if no weapon in slot or broken
-            if (!item || item->IsBroken())
-                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
-
-            // skip spell if weapon not fit to triggered spell
-            if (!item->IsFitToSpellRequirements(m_spellInfo))
-                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
-        }
-    }
-
-    return SPELL_CAST_OK;
-}
-
-void Spell::Delayed() // only called in DealDamage()
-{
-    if (!m_caster)// || m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    //if (m_spellState == SPELL_STATE_DELAYED)
-    //    return;                                             // spell is active and can't be time-backed
-
-    if (isDelayableNoMore())                                 // Spells may only be delayed twice
-        return;
-
-    // spells not loosing casting time (slam, dynamites, bombs..)
-    //if (!(m_spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_DAMAGE))
-    //    return;
-
-    //check pushback reduce
-    int32 delaytime = 500;                                  // spellcasting delay is normally 500ms
-    int32 delayReduce = 100;                                // must be initialized to 100 for percent modifiers
-    m_caster->ToPlayer()->ApplySpellMod(m_spellInfo->Id, SPELLMOD_NOT_LOSE_CASTING_TIME, delayReduce, this);
-    delayReduce += m_caster->GetTotalAuraModifier(SPELL_AURA_REDUCE_PUSHBACK) - 100;
-    if (delayReduce >= 100)
-        return;
-
-    delaytime = delaytime * (100 - delayReduce) / 100;
-
-    if (int32(m_timer) + delaytime > m_casttime)
-    {
-        delaytime = m_casttime - m_timer;
-        m_timer = m_casttime;
-    }
-    else
-        m_timer += delaytime;
-
-    sLog.outDetail("Spell %u partially interrupted for (%d) ms at damage", m_spellInfo->Id, delaytime);
-
-    WorldPacket data(SMSG_SPELL_DELAYED, 8+4);
-    data.append(m_caster->GetPackGUID());
-    data << uint32(delaytime);
-
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::DelayedChannel()
-{
-    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER || getState() != SPELL_STATE_CASTING)
-        return;
-
-    if (isDelayableNoMore())                                    // Spells may only be delayed twice
-        return;
-
-    //check pushback reduce
-    int32 delaytime = GetSpellDuration(m_spellInfo) * 25 / 100; // channeling delay is normally 25% of its time per hit
-    int32 delayReduce = 100;                                    // must be initialized to 100 for percent modifiers
-    m_caster->ToPlayer()->ApplySpellMod(m_spellInfo->Id, SPELLMOD_NOT_LOSE_CASTING_TIME, delayReduce, this);
-    delayReduce += m_caster->GetTotalAuraModifier(SPELL_AURA_REDUCE_PUSHBACK) - 100;
-    if (delayReduce >= 100)
-        return;
-
-    delaytime = delaytime * (100 - delayReduce) / 100;
-
-    if (int32(m_timer) <= delaytime)
-    {
-        delaytime = m_timer;
-        m_timer = 0;
-    }
-    else
-        m_timer -= delaytime;
-
-    sLog.outDebug("Spell %u partially interrupted for %i ms, new duration: %u ms", m_spellInfo->Id, delaytime, m_timer);
-
-    for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-        if ((*ihit).missCondition == SPELL_MISS_NONE)
-            if (Unit* unit = (m_caster->GetGUID() == ihit->targetGUID) ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID))
-                unit->DelayOwnedAuras(m_spellInfo->Id, m_originalCasterGUID, delaytime);
-
-    // partially interrupt persistent area auras
-    if (DynamicObject* dynObj = m_caster->GetDynObject(m_spellInfo->Id))
-        dynObj->Delay(delaytime);
-
-    SendChannelUpdate(m_timer);
-}
-
-void Spell::UpdatePointers()
-{
-    if (m_originalCasterGUID == m_caster->GetGUID())
-        m_originalCaster = m_caster;
-    else
-    {
-        m_originalCaster = ObjectAccessor::GetUnit(*m_caster,m_originalCasterGUID);
-        if (m_originalCaster && !m_originalCaster->IsInWorld())
-            m_originalCaster = NULL;
-    }
-
-    if (m_castItemGUID && m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_CastItem = m_caster->ToPlayer()->GetItemByGuid(m_castItemGUID);
-
-    m_targets.Update(m_caster);
-}
-
-bool Spell::CheckTargetCreatureType(Unit* target) const
-{
-    uint32 spellCreatureTargetMask = m_spellInfo->TargetCreatureType;
-
-    // Curse of Doom & Exorcism: not find another way to fix spell target check :/
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->Category == 1179)
-    {
-        // not allow cast at player
-        if (target->GetTypeId() == TYPEID_PLAYER)
-            return false;
-
-        spellCreatureTargetMask = 0x7FF;
-    }
-
-    // Dismiss Pet and Taming Lesson skipped
-    if (m_spellInfo->Id == 2641 || m_spellInfo->Id == 23356)
-        spellCreatureTargetMask =  0;
-
-    // Polymorph and Grounding Totem
-    if (target->GetEntry() == 5925 && m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE && (m_spellInfo->SpellFamilyFlags[0] & 0x1000000) && m_spellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOD_CONFUSE)
-        return true;
-
-    if (spellCreatureTargetMask)
-    {
-        uint32 TargetCreatureType = target->GetCreatureTypeMask();
-
-        return !TargetCreatureType || (spellCreatureTargetMask & TargetCreatureType);
-    }
-    return true;
-}
-
-CurrentSpellTypes Spell::GetCurrentContainer()
-{
-    if (IsNextMeleeSwingSpell())
-        return(CURRENT_MELEE_SPELL);
-    else if (IsAutoRepeat())
-        return(CURRENT_AUTOREPEAT_SPELL);
-    else if (IsChanneledSpell(m_spellInfo))
-        return(CURRENT_CHANNELED_SPELL);
-    else
-        return(CURRENT_GENERIC_SPELL);
-}
-
-bool Spell::CheckTarget(Unit* target, uint32 eff)
-{
-    // Check targets for creature type mask and remove not appropriate (skip explicit self target case, maybe need other explicit targets)
-    if (m_spellInfo->EffectImplicitTargetA[eff] != TARGET_UNIT_CASTER)
-    {
-        if (!CheckTargetCreatureType(target))
-            return false;
-    }
-
-    // Check Aura spell req (need for AoE spells)
-    if (m_spellInfo->targetAuraSpell && !target->HasAura(m_spellInfo->targetAuraSpell))
-        return false;
-    if (m_spellInfo->excludeTargetAuraSpell && target->HasAura(m_spellInfo->excludeTargetAuraSpell))
-        return false;
-
-    // Check targets for not_selectable unit flag and remove
-    // A player can cast spells on his pet (or other controlled unit) though in any state
-    if (target != m_caster && target->GetCharmerOrOwnerGUID() != m_caster->GetGUID())
-    {
-        // any unattackable target skipped
-        if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
-            return false;
-
-        // unselectable targets skipped in all cases except TARGET_UNIT_NEARBY_ENTRY targeting
-        // in case TARGET_UNIT_NEARBY_ENTRY target selected by server always and can't be cheated
-        /*if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE) &&
-            m_spellInfo->EffectImplicitTargetA[eff] != TARGET_UNIT_NEARBY_ENTRY &&
-            m_spellInfo->EffectImplicitTargetB[eff] != TARGET_UNIT_NEARBY_ENTRY)
-            return false;*/
-    }
-
-    //Check player targets and remove if in GM mode or GM invisibility (for not self casting case)
-    if (target != m_caster && target->GetTypeId() == TYPEID_PLAYER)
-    {
-        if (target->ToPlayer()->GetVisibility() == VISIBILITY_OFF)
-            return false;
-
-        if (target->ToPlayer()->isGameMaster() && !IsPositiveSpell(m_spellInfo->Id))
-            return false;
-    }
-
-    switch(m_spellInfo->EffectApplyAuraName[eff])
-    {
-        case SPELL_AURA_NONE:
-        default:
-            break;
-        case SPELL_AURA_MOD_POSSESS:
-        case SPELL_AURA_MOD_CHARM:
-        case SPELL_AURA_MOD_POSSESS_PET:
-        case SPELL_AURA_AOE_CHARM:
-            if (target->GetTypeId() == TYPEID_UNIT && target->IsVehicle())
-                return false;
-            if (target->IsMounted())
-                return false;
-            if (target->GetCharmerGUID())
-                return false;
-            if (int32 damage = CalculateDamage(eff, target))
-                if ((int32)target->getLevel() > damage)
-                    return false;
-            break;
-    }
-
-    //Do not do further checks for triggered spells
-    if (m_IsTriggeredSpell)
-        return true;
-
-    //Check targets for LOS visibility (except spells without range limitations)
-    switch(m_spellInfo->Effect[eff])
-    {
-        case SPELL_EFFECT_SUMMON_PLAYER:                    // from anywhere
-            break;
-        case SPELL_EFFECT_DUMMY:
-            if (m_spellInfo->Id != 20577)                    // Cannibalize
-                break;
-            //fall through
-        case SPELL_EFFECT_RESURRECT_NEW:
-            // player far away, maybe his corpse near?
-            if (target != m_caster && !target->IsWithinLOSInMap(m_caster))
-            {
-                if (!m_targets.getCorpseTargetGUID())
-                    return false;
-
-                Corpse *corpse = ObjectAccessor::GetCorpse(*m_caster, m_targets.getCorpseTargetGUID());
-                if (!corpse)
-                    return false;
-
-                if (target->GetGUID() != corpse->GetOwnerGUID())
-                    return false;
-
-                if (!corpse->IsWithinLOSInMap(m_caster))
-                    return false;
-            }
-
-            // all ok by some way or another, skip normal check
-            break;
-        default:                                            // normal case
-            // Get GO cast coordinates if original caster -> GO
-            WorldObject *caster = NULL;
-            if (IS_GAMEOBJECT_GUID(m_originalCasterGUID))
-                caster = m_caster->GetMap()->GetGameObject(m_originalCasterGUID);
-            if (!caster)
-                caster = m_caster;
-            if (target->GetEntry() == 5925)
-                return true;
-            if (target != m_caster && !target->IsWithinLOSInMap(caster))
-                return false;
-            break;
-    }
-
-    return true;
-}
-
-bool Spell::IsNeedSendToClient() const
-{
-    return m_spellInfo->SpellVisual[0] || m_spellInfo->SpellVisual[1] || IsChanneledSpell(m_spellInfo) ||
-        m_spellInfo->speed > 0.0f || (!m_triggeredByAuraSpell && !m_IsTriggeredSpell);
-}
-
-bool Spell::HaveTargetsForEffect(uint8 effect) const
-{
-    for (std::list<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
-        if (itr->effectMask & (1 << effect))
-            return true;
-
-    for (std::list<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
-        if (itr->effectMask & (1 << effect))
-            return true;
-
-    for (std::list<ItemTargetInfo>::const_iterator itr = m_UniqueItemInfo.begin(); itr != m_UniqueItemInfo.end(); ++itr)
-        if (itr->effectMask & (1 << effect))
-            return true;
-
-    return false;
-}
-
-SpellEvent::SpellEvent(Spell* spell) : BasicEvent()
-{
-    m_Spell = spell;
-}
-
-SpellEvent::~SpellEvent()
-{
-    if (m_Spell->getState() != SPELL_STATE_FINISHED)
-        m_Spell->cancel();
-
-    if (m_Spell->IsDeletable())
-    {
-        delete m_Spell;
-    }
-    else
-    {
-        sLog.outError("~SpellEvent: %s %u tried to delete non-deletable spell %u. Was not deleted, causes memory leak.",
-            (m_Spell->GetCaster()->GetTypeId() == TYPEID_PLAYER ? "Player" : "Creature"), m_Spell->GetCaster()->GetGUIDLow(), m_Spell->m_spellInfo->Id);
-        ASSERT(false);
-    }
-}
-
-bool SpellEvent::Execute(uint64 e_time, uint32 p_time)
-{
-    // update spell if it is not finished
-    if (m_Spell->getState() != SPELL_STATE_FINISHED)
-        m_Spell->update(p_time);
-
-    // check spell state to process
-    switch (m_Spell->getState())
-    {
-        case SPELL_STATE_FINISHED:
-        {
-            // spell was finished, check deletable state
-            if (m_Spell->IsDeletable())
-            {
-                // check, if we do have unfinished triggered spells
-                return true;                                // spell is deletable, finish event
-            }
-            // event will be re-added automatically at the end of routine)
-        } break;
-
-        case SPELL_STATE_DELAYED:
-        {
-            // first, check, if we have just started
-            if (m_Spell->GetDelayStart() != 0)
-            {
-                // no, we aren't, do the typical update
-                // check, if we have channeled spell on our hands
-                /*
-                if (IsChanneledSpell(m_Spell->m_spellInfo))
-                {
-                    // evented channeled spell is processed separately, casted once after delay, and not destroyed till finish
-                    // check, if we have casting anything else except this channeled spell and autorepeat
-                    if (m_Spell->GetCaster()->IsNonMeleeSpellCasted(false, true, true))
-                    {
-                        // another non-melee non-delayed spell is casted now, abort
-                        m_Spell->cancel();
-                    }
-                    else
-                    {
-                        // Set last not triggered spell for apply spellmods
-                        ((Player*)m_Spell->GetCaster())->SetSpellModTakingSpell(m_Spell, true);
-                        // do the action (pass spell to channeling state)
-                        m_Spell->handle_immediate();
-
-                        // And remove after effect handling
-                        ((Player*)m_Spell->GetCaster())->SetSpellModTakingSpell(m_Spell, false);
-                    }
-                    // event will be re-added automatically at the end of routine)
-                }
-                else
-                */
-                {
-                    // run the spell handler and think about what we can do next
-                    uint64 t_offset = e_time - m_Spell->GetDelayStart();
-                    uint64 n_offset = m_Spell->handle_delayed(t_offset);
-                    if (n_offset)
-                    {
-                        // re-add us to the queue
-                        m_Spell->GetCaster()->m_Events.AddEvent(this, m_Spell->GetDelayStart() + n_offset, false);
-                        return false;                       // event not complete
-                    }
-                    // event complete
-                    // finish update event will be re-added automatically at the end of routine)
-                }
-            }
-            else
-            {
-                // delaying had just started, record the moment
-                m_Spell->SetDelayStart(e_time);
-                // re-plan the event for the delay moment
-                m_Spell->GetCaster()->m_Events.AddEvent(this, e_time + m_Spell->GetDelayMoment(), false);
-                return false;                               // event not complete
-            }
-        } break;
-
-        default:
-        {
-            // all other states
-            // event will be re-added automatically at the end of routine)
-        } break;
-    }
-
-    // spell processing not complete, plan event on the next update interval
-    m_Spell->GetCaster()->m_Events.AddEvent(this, e_time + 1, false);
-    return false;                                           // event not complete
-}
-
-void SpellEvent::Abort(uint64 /*e_time*/)
-{
-    // oops, the spell we try to do is aborted
-    if (m_Spell->getState() != SPELL_STATE_FINISHED)
-        m_Spell->cancel();
-}
-
-bool SpellEvent::IsDeletable() const
-{
-    return m_Spell->IsDeletable();
-}
-
-bool Spell::IsValidSingleTargetEffect(Unit const* target, Targets type) const
-{
-    switch (type)
-    {
-        case TARGET_UNIT_TARGET_ENEMY:
-            return !m_caster->IsFriendlyTo(target);
-        case TARGET_UNIT_TARGET_ALLY:
-        case TARGET_UNIT_PARTY_TARGET:
-            return m_caster->IsFriendlyTo(target);
-        case TARGET_UNIT_TARGET_PARTY:
-            return m_caster != target && m_caster->IsInPartyWith(target);
-        case TARGET_UNIT_TARGET_RAID:
-            return m_caster->IsInRaidWith(target);
-        case TARGET_UNIT_TARGET_PUPPET:
-            return target->HasUnitTypeMask(UNIT_MASK_PUPPET) && m_caster == target->GetOwner();
-        default:
-            break;
-    }
-    return true;
-}
-
-bool Spell::IsValidSingleTargetSpell(Unit const* target) const
-{
-    if (target->GetMapId() == MAPID_INVALID)
-    {
-        sLog.outDebug("Spell::IsValidSingleTargetSpell - a spell was cast on '%s' (GUIDLow: %u), but they have an invalid map id!", target->GetName(), target->GetGUIDLow());
-        return false;
-    }
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (!IsValidSingleTargetEffect(target, Targets(m_spellInfo->EffectImplicitTargetA[i])))
-            return false;
-        // Need to check B?
-        //if (!IsValidSingleTargetEffect(m_spellInfo->EffectImplicitTargetB[i], target)
-        //    return false;
-    }
-    return true;
-}
-
-bool Spell::IsValidDeadOrAliveTarget(Unit const* target) const
-{
-    if (target->isAlive())
-        return !IsRequiringDeadTargetSpell(m_spellInfo);
-    if (IsAllowingDeadTargetSpell(m_spellInfo))
-        return true;
-    return false;
-}
-
-void Spell::CalculateDamageDoneForAllTargets()
-{
-    float multiplier[MAX_SPELL_EFFECTS];
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        // Get multiplier
-        multiplier[i] = SpellMgr::CalculateSpellEffectDamageMultiplier(m_spellInfo, i, m_originalCaster, this);
-    }
-
-    bool usesAmmo = true;
-    Unit::AuraEffectList const& Auras = m_caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_CONSUME_NO_AMMO);
-    for (Unit::AuraEffectList::const_iterator j = Auras.begin(); j != Auras.end(); ++j)
-    {
-        if ((*j)->IsAffectedOnSpell(m_spellInfo))
-            usesAmmo=false;
-    }
-
-    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-    {
-        TargetInfo &target = *ihit;
-
-        uint32 mask = target.effectMask;
-        if (!mask)
-            continue;
-
-        Unit* unit = m_caster->GetGUID() == target.targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, target.targetGUID);
-        if (!unit) // || !unit->isAlive()) do we need to check alive here?
-            continue;
-
-        if (usesAmmo)
-        {
-            bool ammoTaken = false;
-            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)
-            {
-                if (!(mask & 1<<i))
-                    continue;
-                switch (m_spellInfo->Effect[i])
-                {
-                    case SPELL_EFFECT_SCHOOL_DAMAGE:
-                    case SPELL_EFFECT_WEAPON_DAMAGE:
-                    case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-                    case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                    case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                    ammoTaken=true;
-                    TakeAmmo();
-                }
-                if (ammoTaken)
-                    break;
-            }
-        }
-
-        if (target.missCondition == SPELL_MISS_NONE)                          // In case spell hit target, do all effect on that target
-        {
-            target.damage += CalculateDamageDone(unit, mask, multiplier);
-            target.crit = m_caster->isSpellCrit(unit, m_spellInfo, m_spellSchoolMask, m_attackType);
-        }
-        else if (target.missCondition == SPELL_MISS_REFLECT)                // In case spell reflect from target, do all effect on caster (if hit)
-        {
-            if (target.reflectResult == SPELL_MISS_NONE)       // If reflected spell hit caster -> do all effect on him
-            {
-                target.damage += CalculateDamageDone(m_caster, mask, multiplier);
-                target.crit = m_caster->isSpellCrit(m_caster, m_spellInfo, m_spellSchoolMask, m_attackType);
-            }
-        }
-    }
-}
-
-int32 Spell::CalculateDamageDone(Unit *unit, const uint32 effectMask, float * /*multiplier*/)
-{
-    int32 damageDone = 0;
-    unitTarget = unit;
-    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (effectMask & (1<<i))
-        {
-            m_damage = 0;
-            damage = CalculateDamage(i, NULL);
-
-            switch(m_spellInfo->Effect[i])
-            {
-                case SPELL_EFFECT_SCHOOL_DAMAGE:
-                    SpellDamageSchoolDmg((SpellEffIndex)i);
-                    break;
-                case SPELL_EFFECT_WEAPON_DAMAGE:
-                case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-                case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                    SpellDamageWeaponDmg((SpellEffIndex)i);
-                    break;
-                case SPELL_EFFECT_HEAL:
-                    SpellDamageHeal((SpellEffIndex)i);
-                    break;
-            }
-
-            if (m_damage > 0)
-            {
-                if (IsAreaEffectTarget[m_spellInfo->EffectImplicitTargetA[i]] || IsAreaEffectTarget[m_spellInfo->EffectImplicitTargetB[i]])
-                {
-                    m_damage = int32(float(m_damage) * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE, m_spellInfo->SchoolMask));
-                    if (m_caster->GetTypeId() == TYPEID_UNIT)
-                        m_damage = int32(float(m_damage) * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CREATURE_AOE_DAMAGE_AVOIDANCE, m_spellInfo->SchoolMask));
-
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        uint32 targetAmount = m_UniqueTargetInfo.size();
-                        if (targetAmount > 10)
-                            m_damage = m_damage * 10/targetAmount;
-                    }
-                }
-            }
-
-            damageDone += m_damage;
-        }
-    }
-
-    return damageDone;
-}
-
-SpellCastResult Spell::CanOpenLock(uint32 effIndex, uint32 lockId, SkillType& skillId, int32& reqSkillValue, int32& skillValue)
-{
-    if (!lockId)                                             // possible case for GO and maybe for items.
-        return SPELL_CAST_OK;
-
-    // Get LockInfo
-    LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
-
-    if (!lockInfo)
-        return SPELL_FAILED_BAD_TARGETS;
-
-    bool reqKey = false;                                    // some locks not have reqs
-
-    for (int j = 0; j < MAX_LOCK_CASE; ++j)
-    {
-        switch(lockInfo->Type[j])
-        {
-            // check key item (many fit cases can be)
-            case LOCK_KEY_ITEM:
-                if (lockInfo->Index[j] && m_CastItem && m_CastItem->GetEntry() == lockInfo->Index[j])
-                    return SPELL_CAST_OK;
-                reqKey = true;
-                break;
-                // check key skill (only single first fit case can be)
-            case LOCK_KEY_SKILL:
-            {
-                reqKey = true;
-
-                // wrong locktype, skip
-                if (uint32(m_spellInfo->EffectMiscValue[effIndex]) != lockInfo->Index[j])
-                    continue;
-
-                skillId = SkillByLockType(LockType(lockInfo->Index[j]));
-
-                if (skillId != SKILL_NONE)
-                {
-                    // skill bonus provided by casting spell (mostly item spells)
-                    // add the damage modifier from the spell casted (cheat lock / skeleton key etc.)
-                    uint32 spellSkillBonus = uint32(CalculateDamage(effIndex, NULL));
-                    reqSkillValue = lockInfo->Skill[j];
-
-                    // castitem check: rogue using skeleton keys. the skill values should not be added in this case.
-                    skillValue = m_CastItem || m_caster->GetTypeId()!= TYPEID_PLAYER ?
-                        0 : m_caster->ToPlayer()->GetSkillValue(skillId);
-
-                    skillValue += spellSkillBonus;
-
-                    if (skillValue < reqSkillValue)
-                        return SPELL_FAILED_LOW_CASTLEVEL;
-                }
-
-                return SPELL_CAST_OK;
-            }
-        }
-    }
-
-    if (reqKey)
-        return SPELL_FAILED_BAD_TARGETS;
-
-    return SPELL_CAST_OK;
-}
-
-void Spell::SetSpellValue(SpellValueMod mod, int32 value)
-{
-    switch(mod)
-    {
-        case SPELLVALUE_BASE_POINT0:
-            m_spellValue->EffectBasePoints[0] = SpellMgr::CalculateSpellEffectBaseAmount(value, m_spellInfo, 0);
-            break;
-        case SPELLVALUE_BASE_POINT1:
-            m_spellValue->EffectBasePoints[1] = SpellMgr::CalculateSpellEffectBaseAmount(value, m_spellInfo, 1);
-            break;
-        case SPELLVALUE_BASE_POINT2:
-            m_spellValue->EffectBasePoints[2] = SpellMgr::CalculateSpellEffectBaseAmount(value, m_spellInfo, 2);
-            break;
-        case SPELLVALUE_RADIUS_MOD:
-            m_spellValue->RadiusMod = (float)value / 10000;
-            break;
-        case SPELLVALUE_MAX_TARGETS:
-            m_spellValue->MaxAffectedTargets = (uint32)value;
-            break;
-    }
-}
-
-float tangent(float x)
-{
-    x = tan(x);
-    //if (x < std::numeric_limits<float>::max() && x > -std::numeric_limits<float>::max()) return x;
-    //if (x >= std::numeric_limits<float>::max()) return std::numeric_limits<float>::max();
-    //if (x <= -std::numeric_limits<float>::max()) return -std::numeric_limits<float>::max();
-    if (x < 100000.0f && x > -100000.0f) return x;
-    if (x >= 100000.0f) return 100000.0f;
-    if (x <= 100000.0f) return -100000.0f;
-    return 0.0f;
-}
-
-#define DEBUG_TRAJ(a) //a
-
-void Spell::SelectTrajTargets()
-{
-    if (!m_targets.HasTraj())
-        return;
-
-    float dist2d = m_targets.GetDist2d();
-    if (!dist2d)
-        return;
-
-    float dz = m_targets.m_dstPos.m_positionZ - m_targets.m_srcPos.m_positionZ;
-
-    UnitList unitList;
-    SearchAreaTarget(unitList, dist2d, PUSH_IN_THIN_LINE, SPELL_TARGETS_ANY);
-    if (unitList.empty())
-        return;
-
-    unitList.sort(Trinity::ObjectDistanceOrderPred(m_caster));
-
-    float b = tangent(m_targets.m_elevation);
-    float a = (dz - dist2d * b) / (dist2d * dist2d);
-    if (a > -0.0001f) a = 0;
-    DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: a %f b %f", a, b);)
-
-    float bestDist = GetSpellMaxRange(m_spellInfo, false);
-
-    UnitList::const_iterator itr = unitList.begin();
-    for (; itr != unitList.end(); ++itr)
-    {
-        if (m_caster == *itr || m_caster->IsOnVehicle(*itr) || (*itr)->GetVehicle())//(*itr)->IsOnVehicle(m_caster))
-            continue;
-
-        const float size = std::max((*itr)->GetObjectSize() * 0.7f, 1.0f); // 1/sqrt(3)
-        // TODO: all calculation should be based on src instead of m_caster
-        const float objDist2d = m_targets.m_srcPos.GetExactDist2d(*itr) * cos(m_targets.m_srcPos.GetRelativeAngle(*itr));
-        const float dz = (*itr)->GetPositionZ() - m_targets.m_srcPos.m_positionZ;
-
-        DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: check %u, dist between %f %f, height between %f %f.", (*itr)->GetEntry(), objDist2d - size, objDist2d + size, dz - size, dz + size);)
-
-        float dist = objDist2d - size;
-        float height = dist * (a * dist + b);
-        DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: dist %f, height %f.", dist, height);)
-        if (dist < bestDist && height < dz + size && height > dz - size)
-        {
-            bestDist = dist > 0 ? dist : 0;
-            break;
-        }
-
-#define CHECK_DIST {\
-    DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: dist %f, height %f.", dist, height);)\
-    if (dist > bestDist) continue;\
-    if (dist < objDist2d + size && dist > objDist2d - size) { bestDist = dist; break; }\
-        }
-
-        if (!a)
-        {
-            height = dz - size;
-            dist = height / b;
-            CHECK_DIST;
-
-            height = dz + size;
-            dist = height / b;
-            CHECK_DIST;
-
-            continue;
-        }
-
-        height = dz - size;
-        float sqrt1 = b * b + 4 * a * height;
-        if (sqrt1 > 0)
-        {
-            sqrt1 = sqrt(sqrt1);
-            dist = (sqrt1 - b) / (2 * a);
-            CHECK_DIST;
-        }
-
-        height = dz + size;
-        float sqrt2 = b * b + 4 * a * height;
-        if (sqrt2 > 0)
-        {
-            sqrt2 = sqrt(sqrt2);
-            dist = (sqrt2 - b) / (2 * a);
-            CHECK_DIST;
-
-            dist = (-sqrt2 - b) / (2 * a);
-            CHECK_DIST;
-        }
-
-        if (sqrt1 > 0)
-        {
-            dist = (-sqrt1 - b) / (2 * a);
-            CHECK_DIST;
-        }
-    }
-
-    if (m_targets.m_srcPos.GetExactDist2d(&m_targets.m_dstPos) > bestDist)
-    {
-        float x = m_targets.m_srcPos.m_positionX + cos(m_caster->GetOrientation()) * bestDist;
-        float y = m_targets.m_srcPos.m_positionY + sin(m_caster->GetOrientation()) * bestDist;
-        float z = m_targets.m_srcPos.m_positionZ + bestDist * (a * bestDist + b);
-
-        if (itr != unitList.end())
-        {
-            float distSq = (*itr)->GetExactDistSq(x, y, z);
-            float sizeSq = (*itr)->GetObjectSize();
-            sizeSq *= sizeSq;
-            DEBUG_TRAJ(sLog.outError("Initial %f %f %f %f %f", x, y, z, distSq, sizeSq);)
-            if (distSq > sizeSq)
-            {
-                float factor = 1 - sqrt(sizeSq / distSq);
-                x += factor * ((*itr)->GetPositionX() - x);
-                y += factor * ((*itr)->GetPositionY() - y);
-                z += factor * ((*itr)->GetPositionZ() - z);
-
-                distSq = (*itr)->GetExactDistSq(x, y, z);
-                DEBUG_TRAJ(sLog.outError("Initial %f %f %f %f %f", x, y, z, distSq, sizeSq);)
-            }
-        }
-
-        Position trajDst;
-        trajDst.Relocate(x, y, z, m_caster->GetOrientation());
-        m_targets.modDst(trajDst);
-    }
-}
-
-void Spell::PrepareTargetProcessing()
-{
-    CheckEffectExecuteData();
-}
-
-void Spell::FinishTargetProcessing()
-{
-    SendLogExecute();
-}
-
-void Spell::InitEffectExecuteData(uint8 effIndex)
-{
-    ASSERT(effIndex < MAX_SPELL_EFFECTS);
-    if (!m_effectExecuteData[effIndex])
-    {
-        m_effectExecuteData[effIndex] = new ByteBuffer(0x20);
-        // first dword - target counter
-        *m_effectExecuteData[effIndex] << uint32(1);
-    }
-    else
-    {
-        // increase target counter by one
-        uint32 count = (*m_effectExecuteData[effIndex]).read<uint32>(0);
-        (*m_effectExecuteData[effIndex]).put<uint32>(0, ++count);
-    }
-}
-
-void Spell::CleanupEffectExecuteData()
-{
-    for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        m_effectExecuteData[i] = NULL;
-}
-
-void Spell::CheckEffectExecuteData()
-{
-    for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        ASSERT(!m_effectExecuteData[i]);
-}
-
-void Spell::LoadScripts()
-{
-    sLog.outDebug("Spell::LoadScripts");
-    sScriptMgr.CreateSpellScripts(m_spellInfo->Id, m_loadedScripts);
-    for(std::list<SpellScript *>::iterator itr = m_loadedScripts.begin(); itr != m_loadedScripts.end() ;)
-    {
-        if (!(*itr)->_Load(this))
-        {
-            std::list<SpellScript *>::iterator bitr = itr;
-            ++itr;
-            m_loadedScripts.erase(bitr);
-            continue;
-        }
-        (*itr)->Register();
-        ++itr;
-    }
-}
-
-void Spell::PrepareScriptHitHandlers()
-{
-    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
-    {
-        (*scritr)->_InitHit();
-    }
-}
-
-bool Spell::CallScriptEffectHandlers(SpellEffIndex effIndex)
-{
-    // execute script effect handler hooks and check if effects was prevented
-    bool preventDefault = false;
-    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
-    {
-        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_EFFECT);
-        std::list<SpellScript::EffectHandler>::iterator effEndItr = (*scritr)->OnEffect.end(), effItr = (*scritr)->OnEffect.begin();
-        for(; effItr != effEndItr ; ++effItr)
-        {
-            // effect execution can be prevented
-            if (!(*scritr)->_IsEffectPrevented(effIndex) && (*effItr).IsEffectAffected(m_spellInfo, effIndex))
-                (*effItr).Call(*scritr, effIndex);
-        }
-        if (!preventDefault)
-            preventDefault = (*scritr)->_IsDefaultEffectPrevented(effIndex);
-        (*scritr)->_FinishScriptCall();
-    }
-    return preventDefault;
-}
-
-void Spell::CallScriptBeforeHitHandlers()
-{
-    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
-    {
-        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_BEFORE_HIT);
-        std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->BeforeHit.end(), hookItr = (*scritr)->BeforeHit.begin();
-        for(; hookItr != hookItrEnd ; ++hookItr)
-        {
-            (*hookItr).Call(*scritr);
-        }
-        (*scritr)->_FinishScriptCall();
-    }
-}
-
-void Spell::CallScriptOnHitHandlers()
-{
-    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
-    {
-        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_HIT);
-        std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->OnHit.end(), hookItr = (*scritr)->OnHit.begin();
-        for(; hookItr != hookItrEnd ; ++hookItr)
-        {
-           (*hookItr).Call(*scritr);
-        }
-        (*scritr)->_FinishScriptCall();
-    }
-}
-
-void Spell::CallScriptAfterHitHandlers()
-{
-    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
-    {
-        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_AFTER_HIT);
-        std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->AfterHit.end(), hookItr = (*scritr)->AfterHit.begin();
-        for(; hookItr != hookItrEnd ; ++hookItr)
-        {
-            (*hookItr).Call(*scritr);
-        }
-        (*scritr)->_FinishScriptCall();
-    }
-}
+
+                }
+            }
+
+            // Other special target selection goes here
+            if (uint32 maxTargets = m_spellValue->MaxAffectedTargets)
+            {
+                Unit::AuraEffectList const& Auras = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_MAX_AFFECTED_TARGETS);
+                for (Unit::AuraEffectList::const_iterator j = Auras.begin(); j != Auras.end(); ++j)
+                    if ((*j)->IsAffectedOnSpell(m_spellInfo))
+                        maxTargets += (*j)->GetAmount();
+
+                if (m_spellInfo->Id == 5246) //Intimidating Shout
+                    unitList.remove(m_targets.getUnitTarget());
+                Trinity::RandomResizeList(unitList, maxTargets);
+            }
+            else
+            {
+                switch (m_spellInfo->Id)
+                {
+                    case 27285: // Seed of Corruption proc spell
+                        unitList.remove(m_targets.getUnitTarget());
+                        break;
+                    case 55789: // Improved Icy Talons
+                    case 59725: // Improved Spell Reflection - aoe aura
+                        unitList.remove(m_caster);
+                        break;
+                    case 72255: // Mark of the Fallen Champion (Deathbringer Saurfang)
+                    case 72444:
+                    case 72445:
+                    case 72446:
+                        for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();)
+                        {
+                            if (!(*itr)->HasAura(72293))
+                                itr = unitList.erase(itr);
+                            else
+                                ++itr;
+                        }
+                        break;
+                    case 69782: case 69796:                 // Ooze Flood
+                    case 69798: case 69801:                 // Ooze Flood
+                        // get 2 targets except 2 nearest
+                        unitList.sort(Trinity::ObjectDistanceOrderPred(m_caster));
+                        unitList.resize(4);
+                        while (unitList.size() > 2)
+                            unitList.pop_front();
+                        // crashfix
+                        if (unitList.empty())
+                            return;
+                        break;
+                }
+                // Death Pact
+                if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
+                {
+                    Unit * unit_to_add = NULL;
+                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end(); ++itr)
+                    {
+                        if ((*itr)->GetTypeId() == TYPEID_UNIT
+                            && (*itr)->GetOwnerGUID() == m_caster->GetGUID()
+                            && (*itr)->ToCreature()->GetCreatureInfo()->type == CREATURE_TYPE_UNDEAD)
+                        {
+                            unit_to_add = (*itr);
+                            break;
+                        }
+                    }
+                    if (unit_to_add)
+                    {
+                        unitList.clear();
+                        unitList.push_back(unit_to_add);
+                    }
+                    // Pet not found - remove cooldown
+                    else
+                    {
+                        if (modOwner->GetTypeId() == TYPEID_PLAYER)
+                            modOwner->RemoveSpellCooldown(m_spellInfo->Id,true);
+                        SendCastResult(SPELL_FAILED_NO_PET);
+                        finish(false);
+                    }
+                }
+            }
+            for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+                AddUnitTarget(*itr, i);
+        }
+
+        if (!gobjectList.empty())
+        {
+            if (uint32 maxTargets = m_spellValue->MaxAffectedTargets)
+            {
+                Unit::AuraEffectList const& Auras = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_MAX_AFFECTED_TARGETS);
+                for (Unit::AuraEffectList::const_iterator j = Auras.begin(); j != Auras.end(); ++j)
+                    if ((*j)->IsAffectedOnSpell(m_spellInfo))
+                        maxTargets += (*j)->GetAmount();
+
+                Trinity::RandomResizeList(gobjectList, maxTargets);
+            }
+            for (std::list<GameObject*>::iterator itr = gobjectList.begin(); itr != gobjectList.end(); ++itr)
+                AddGOTarget(*itr, i);
+        }
+    }
+}
+
+void Spell::prepare(SpellCastTargets const* targets, AuraEffect const * triggeredByAura)
+{
+    if (m_CastItem)
+        m_castItemGUID = m_CastItem->GetGUID();
+    else
+        m_castItemGUID = 0;
+
+    m_targets = *targets;
+
+    if (!m_targets.getUnitTargetGUID() && m_spellInfo->Targets & TARGET_FLAG_UNIT)
+    {
+        Unit *target = NULL;
+        if (m_caster->GetTypeId() == TYPEID_UNIT)
+            target = m_caster->getVictim();
+        else
+            target = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
+
+        if (target && IsValidSingleTargetSpell(target))
+            m_targets.setUnitTarget(target);
+        else
+        {
+            SendCastResult(SPELL_FAILED_BAD_TARGETS);
+            finish(false);
+            return;
+        }
+    }
+    if (m_caster->ToPlayer())
+    {
+        //check for special spell conditions
+        ConditionList conditions = sConditionMgr.GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SPELL, m_spellInfo->Id);
+        if (!conditions.empty())
+        {
+            if (!sConditionMgr.IsPlayerMeetToConditions(m_caster->ToPlayer(), conditions))
+            {
+                SendCastResult(SPELL_FAILED_DONT_REPORT);
+                finish(false);
+                return;
+            }
+        }
+    }
+    if (!m_targets.HasSrc() && m_spellInfo->Targets & TARGET_FLAG_SOURCE_LOCATION)
+        m_targets.setSrc(*m_caster);
+
+    if (!m_targets.HasDst() && m_spellInfo->Targets & TARGET_FLAG_DEST_LOCATION)
+    {
+        Unit *target = m_targets.getUnitTarget();
+        if (!target)
+        {
+            if (m_caster->GetTypeId() == TYPEID_UNIT)
+                target = m_caster->getVictim();
+            else
+                target = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
+        }
+
+        if (target)
+            m_targets.setDst(*target);
+        else
+        {
+            SendCastResult(SPELL_FAILED_BAD_TARGETS);
+            finish(false);
+            return;
+        }
+    }
+
+    // Fill aura scaling information
+    if (m_caster->IsControlledByPlayer() && !IsPassiveSpell(m_spellInfo->Id) && m_spellInfo->spellLevel && !IsChanneledSpell(m_spellInfo) && !m_IsTriggeredSpell)
+    {
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (m_spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
+            {
+                // Change aura with ranks only if basepoints are taken from spellInfo and aura is positive
+                if (IsPositiveEffect(m_spellInfo->Id, i))
+                {
+                    m_auraScaleMask |= (1<<i);
+                    if (m_spellValue->EffectBasePoints[i] != m_spellInfo->EffectBasePoints[i])
+                    {
+                        m_auraScaleMask = 0;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    m_spellState = SPELL_STATE_PREPARING;
+
+    if (triggeredByAura)
+        m_triggeredByAuraSpell  = triggeredByAura->GetSpellProto();
+
+    // create and add update event for this spell
+    SpellEvent* Event = new SpellEvent(this);
+    m_caster->m_Events.AddEvent(Event, m_caster->m_Events.CalculateTime(1));
+
+    //Prevent casting at cast another spell (ServerSide check)
+    if (m_caster->IsNonMeleeSpellCasted(false, true, true) && m_cast_count)
+    {
+        SendCastResult(SPELL_FAILED_SPELL_IN_PROGRESS);
+        finish(false);
+        return;
+    }
+
+    if (sDisableMgr.IsDisabledFor(DISABLE_TYPE_SPELL, m_spellInfo->Id, m_caster))
+    {
+        SendCastResult(SPELL_FAILED_SPELL_UNAVAILABLE);
+        finish(false);
+        return;
+    }
+    LoadScripts();
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
+    // Fill cost data (not use power for item casts
+    m_powerCost = m_CastItem ? 0 : CalculatePowerCost(m_spellInfo, m_caster, m_spellSchoolMask);
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
+
+    // Set combo point requirement
+    if (m_IsTriggeredSpell || m_CastItem || !m_caster->m_movedPlayer)
+        m_needComboPoints = false;
+
+    SpellCastResult result = CheckCast(true);
+    if (result != SPELL_CAST_OK && !IsAutoRepeat())          //always cast autorepeat dummy for triggering
+    {
+        if (triggeredByAura && !triggeredByAura->GetBase()->IsPassive())
+        {
+            SendChannelUpdate(0);
+            triggeredByAura->GetBase()->SetDuration(0);
+        }
+        SendCastResult(result);
+
+        finish(false);
+        return;
+    }
+
+    // Prepare data for triggers
+    prepareDataForTriggerSystem(triggeredByAura);
+
+    // calculate cast time (calculated after first CheckCast check to prevent charge counting for first CheckCast fail)
+    m_casttime = GetSpellCastTime(m_spellInfo, this);
+    //m_caster->ModSpellCastTime(m_spellInfo, m_casttime, this);
+
+    // don't allow channeled spells / spells with cast time to be casted while moving
+    // (even if they are interrupted on moving, spells with almost immediate effect get to have their effect processed before movement interrupter kicks in)
+    if ((IsChanneledSpell(m_spellInfo) || m_casttime)
+        && m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->isMoving()
+        && m_spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_MOVEMENT)
+    {
+        SendCastResult(SPELL_FAILED_MOVING);
+        finish(false);
+        return;
+    }
+
+    // set timer base at cast time
+    ReSetTimer();
+
+    sLog.outDebug("Spell::prepare: spell id %u source %u caster %d triggered %u mask %u", m_spellInfo->Id, m_caster->GetEntry(), m_originalCaster ? m_originalCaster->GetEntry() : -1, m_IsTriggeredSpell ? 1 : 0, m_targets.getTargetMask());
+    //if (m_targets.getUnitTarget())
+    //    sLog.outError("Spell::prepare: unit target %u", m_targets.getUnitTarget()->GetEntry());
+    //if (m_targets.HasDst())
+    //    sLog.outError("Spell::prepare: pos target %f %f %f", m_targets.m_dstPos.m_positionX, m_targets.m_dstPos.m_positionY, m_targets.m_dstPos.m_positionZ);
+
+    //Containers for channeled spells have to be set
+    //TODO:Apply this to all casted spells if needed
+    // Why check duration? 29350: channelled triggers channelled
+    if (m_IsTriggeredSpell && (!IsChanneledSpell(m_spellInfo) || !GetSpellMaxDuration(m_spellInfo)))
+        cast(true);
+    else
+    {
+        // stealth must be removed at cast starting (at show channel bar)
+        // skip triggered spell (item equip spell casting and other not explicit character casts/item uses)
+        if (!m_IsTriggeredSpell && isSpellBreakStealth(m_spellInfo))
+        {
+            m_caster->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_CAST);
+            for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                if (EffectTargetType[m_spellInfo->Effect[i]] == SPELL_REQUIRE_UNIT)
+                {
+                    m_caster->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_SPELL_ATTACK);
+                    break;
+                }
+            }
+        }
+
+        m_caster->SetCurrentCastedSpell(this);
+        SendSpellStart();
+
+        if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            m_caster->ToPlayer()->AddGlobalCooldown(m_spellInfo,this);
+
+        if (!m_casttime && !m_spellInfo->StartRecoveryTime
+            && !m_castItemGUID     //item: first cast may destroy item and second cast causes crash
+            && GetCurrentContainer() == CURRENT_GENERIC_SPELL)
+            cast(true);
+    }
+}
+
+void Spell::cancel()
+{
+    if (m_spellState == SPELL_STATE_FINISHED)
+        return;
+
+    SetReferencedFromCurrent(false);
+    if (m_selfContainer && *m_selfContainer == this)
+        *m_selfContainer = NULL;
+
+    uint32 oldState = m_spellState;
+    m_spellState = SPELL_STATE_FINISHED;
+
+    m_autoRepeat = false;
+    switch (oldState)
+    {
+        case SPELL_STATE_PREPARING:
+        case SPELL_STATE_DELAYED:
+            SendInterrupted(0);
+            SendCastResult(SPELL_FAILED_INTERRUPTED);
+            break;
+
+        case SPELL_STATE_CASTING:
+            for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                if ((*ihit).missCondition == SPELL_MISS_NONE)
+                    if (Unit* unit = m_caster->GetGUID() == ihit->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID))
+                        unit->RemoveOwnedAura(m_spellInfo->Id, m_originalCasterGUID, 0, AURA_REMOVE_BY_CANCEL);
+
+            SendChannelUpdate(0);
+            SendInterrupted(0);
+            SendCastResult(SPELL_FAILED_INTERRUPTED);
+
+            // spell is canceled-take mods and clear list
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                m_caster->ToPlayer()->RemoveSpellMods(this);
+
+            m_appliedMods.clear();
+            break;
+
+        default:
+            break;
+    }
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->RemoveGlobalCooldown(m_spellInfo);
+
+    m_caster->RemoveDynObject(m_spellInfo->Id);
+    m_caster->RemoveGameObject(m_spellInfo->Id,true);
+
+    //set state back so finish will be processed
+    m_spellState = oldState;
+
+    finish(false);
+}
+
+void Spell::cast(bool skipCheck)
+{
+    // update pointers base at GUIDs to prevent access to non-existed already object
+    UpdatePointers();
+
+    if (Unit *target = m_targets.getUnitTarget())
+    {
+        // three check: prepare, cast (m_casttime > 0), hit (delayed)
+        if (m_casttime && target->isAlive()
+            && (target->m_invisibilityMask || m_caster->m_invisibilityMask
+            || target->GetVisibility() == VISIBILITY_GROUP_STEALTH)
+            && !target->IsFriendlyTo(m_caster) && !m_caster->canSeeOrDetect(target, true))
+        {
+            SendCastResult(SPELL_FAILED_BAD_TARGETS);
+            SendInterrupted(0);
+            finish(false);
+            return;
+        }
+    }
+    else
+    {
+        // cancel at lost main target unit
+        if (m_targets.getUnitTargetGUID() && m_targets.getUnitTargetGUID() != m_caster->GetGUID())
+        {
+            cancel();
+            return;
+        }
+    }
+
+    // now that we've done the basic check, now run the scripts
+    // should be done before the spell is actually executed
+    if (Player *playerCaster = m_caster->ToPlayer())
+        sScriptMgr.OnPlayerSpellCast(playerCaster, this, skipCheck);
+
+    SetExecutedCurrently(true);
+
+    if (m_caster->GetTypeId() != TYPEID_PLAYER && m_targets.getUnitTarget() && m_targets.getUnitTarget() != m_caster)
+        m_caster->SetInFront(m_targets.getUnitTarget());
+
+    // Should this be done for original caster?
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        // Set spell which will drop charges for triggered cast spells
+        // if not successfully casted, will be remove in finish(false)
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
+    }
+
+    // triggered cast called from Spell::prepare where it was already checked
+    if (!m_IsTriggeredSpell || !skipCheck)
+    {
+        SpellCastResult castResult = CheckCast(false);
+        if (castResult != SPELL_CAST_OK)
+        {
+            SendCastResult(castResult);
+            SendInterrupted(0);
+            //restore spell mods
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            {
+                m_caster->ToPlayer()->RestoreSpellMods(this);
+                // cleanup after mod system
+                // triggered spell pointer can be not removed in some cases
+                m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
+            }
+            finish(false);
+            SetExecutedCurrently(false);
+            return;
+        }
+
+        // additional check after cast bar completes (must not be in CheckCast)
+        // if trade not complete then remember it in trade data
+        if (m_targets.getTargetMask() & TARGET_FLAG_TRADE_ITEM)
+        {
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            {
+                if (TradeData* my_trade = m_caster->ToPlayer()->GetTradeData())
+                {
+                    if (!my_trade->IsInAcceptProcess())
+                    {
+                        // Spell will be casted at completing the trade. Silently ignore at this place
+                        my_trade->SetSpell(m_spellInfo->Id, m_CastItem);
+                        SendCastResult(SPELL_FAILED_DONT_REPORT);
+                        SendInterrupted(0);
+                        m_caster->ToPlayer()->RestoreSpellMods(this);
+                        // cleanup after mod system
+                        // triggered spell pointer can be not removed in some cases
+                        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
+                        finish(false);
+                        SetExecutedCurrently(false);
+                        return;
+                    }
+                }
+            }
+        }
+    }
+
+    SelectSpellTargets();
+
+    // Spell may be finished after target map check
+    if (m_spellState == SPELL_STATE_FINISHED)
+    {
+        SendInterrupted(0);
+        //restore spell mods
+        if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        {
+            m_caster->ToPlayer()->RestoreSpellMods(this);
+            // cleanup after mod system
+            // triggered spell pointer can be not removed in some cases
+            m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
+        }
+        finish(false);
+        SetExecutedCurrently(false);
+        return;
+    }
+
+    if (m_spellInfo->SpellFamilyName)
+    {
+        if (m_spellInfo->excludeCasterAuraSpell && !IsPositiveSpell(m_spellInfo->excludeCasterAuraSpell))
+            m_preCastSpell = m_spellInfo->excludeCasterAuraSpell;
+        else if (m_spellInfo->excludeTargetAuraSpell && !IsPositiveSpell(m_spellInfo->excludeTargetAuraSpell))
+            m_preCastSpell = m_spellInfo->excludeTargetAuraSpell;
+    }
+
+    switch (m_spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            if (m_spellInfo->Mechanic == MECHANIC_BANDAGE) // Bandages
+                m_preCastSpell = 11196;                                // Recently Bandaged
+            break;
+        }
+        case SPELLFAMILY_MAGE:
+        {
+             // Permafrost
+             if (m_spellInfo->SpellFamilyFlags[1] & 0x00001000 ||  m_spellInfo->SpellFamilyFlags[0] & 0x00100220)
+              m_preCastSpell = 68391;
+             break;
+        }
+    }
+
+    // traded items have trade slot instead of guid in m_itemTargetGUID
+    // set to real guid to be sent later to the client
+    m_targets.updateTradeSlotItem();
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (!m_IsTriggeredSpell && m_CastItem)
+        {
+            m_caster->ToPlayer()->GetAchievementMgr().StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_ITEM, m_CastItem->GetEntry());
+            m_caster->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_USE_ITEM, m_CastItem->GetEntry());
+        }
+
+        m_caster->ToPlayer()->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CAST_SPELL, m_spellInfo->Id);
+    }
+
+    if (!m_IsTriggeredSpell)
+    {
+        // Powers have to be taken before SendSpellGo
+        TakePower();
+        TakeReagents();                                         // we must remove reagents before HandleEffects to allow place crafted item in same slot
+    }
+    else if (Item* targetItem = m_targets.getItemTarget())
+    {
+        /// Not own traded item (in trader trade slot) req. reagents including triggered spell case
+        if (targetItem->GetOwnerGUID() != m_caster->GetGUID())
+            TakeReagents();
+    }
+
+    // are there any spells need to be triggered after hit?
+    // handle SPELL_AURA_ADD_TARGET_TRIGGER auras
+    Unit::AuraEffectList const& targetTriggers = m_caster->GetAuraEffectsByType(SPELL_AURA_ADD_TARGET_TRIGGER);
+    for (Unit::AuraEffectList::const_iterator i = targetTriggers.begin(); i != targetTriggers.end(); ++i)
+    {
+        if (!(*i)->IsAffectedOnSpell(m_spellInfo))
+            continue;
+        SpellEntry const *auraSpellInfo = (*i)->GetSpellProto();
+        uint32 auraSpellIdx = (*i)->GetEffIndex();
+        if (SpellEntry const *spellInfo = sSpellStore.LookupEntry(auraSpellInfo->EffectTriggerSpell[auraSpellIdx]))
+        {
+            int32 auraBaseAmount = (*i)->GetBaseAmount();
+            int32 chance = m_caster->CalculateSpellDamage(NULL, auraSpellInfo, auraSpellIdx, &auraBaseAmount);
+            m_ChanceTriggerSpells.push_back(std::make_pair(spellInfo, chance * (*i)->GetBase()->GetStackAmount()));
+        }
+    }
+
+    if (m_customAttr & SPELL_ATTR_CU_DIRECT_DAMAGE)
+        CalculateDamageDoneForAllTargets();
+
+    // CAST SPELL
+    SendSpellCooldown();
+
+    PrepareScriptHitHandlers();
+
+    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch(m_spellInfo->Effect[i])
+        {
+            case SPELL_EFFECT_CHARGE:
+            case SPELL_EFFECT_CHARGE_DEST:
+            case SPELL_EFFECT_JUMP:
+            case SPELL_EFFECT_JUMP_DEST:
+            case SPELL_EFFECT_LEAP_BACK:
+            case SPELL_EFFECT_ACTIVATE_RUNE:
+                HandleEffects(NULL,NULL,NULL,i);
+                m_effectMask |= (1<<i);
+                break;
+        }
+    }
+
+    // we must send smsg_spell_go packet before m_castItem delete in TakeCastItem()...
+    SendSpellGo();
+
+    // Okay, everything is prepared. Now we need to distinguish between immediate and evented delayed spells
+    if ((m_spellInfo->speed > 0.0f && !IsChanneledSpell(m_spellInfo)) || m_spellInfo->Id == 14157)
+    {
+        // Remove used for cast item if need (it can be already NULL after TakeReagents call
+        // in case delayed spell remove item at cast delay start
+        TakeCastItem();
+
+        // Okay, maps created, now prepare flags
+        m_immediateHandled = false;
+        m_spellState = SPELL_STATE_DELAYED;
+        SetDelayStart(0);
+
+        if (m_caster->hasUnitState(UNIT_STAT_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
+            m_caster->clearUnitState(UNIT_STAT_CASTING);
+    }
+    else
+    {
+        // Immediate spell, no big deal
+        handle_immediate();
+    }
+
+    if (m_customAttr & SPELL_ATTR_CU_LINK_CAST)
+    {
+        if (const std::vector<int32> *spell_triggered = sSpellMgr.GetSpellLinked(m_spellInfo->Id))
+        {
+            for (std::vector<int32>::const_iterator i = spell_triggered->begin(); i != spell_triggered->end(); ++i)
+                if (*i < 0)
+                    m_caster->RemoveAurasDueToSpell(-(*i));
+                else
+                    m_caster->CastSpell(m_targets.getUnitTarget() ? m_targets.getUnitTarget() : m_caster, *i, true);
+        }
+    }
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
+
+    SetExecutedCurrently(false);
+}
+
+void Spell::handle_immediate()
+{
+    // start channeling if applicable
+    if (IsChanneledSpell(m_spellInfo))
+    {
+        int32 duration = GetSpellDuration(m_spellInfo);
+        if (duration)
+        {
+            // First mod_duration then haste - see Missile Barrage
+            // Apply duration mod
+            if (Player* modOwner = m_caster->GetSpellModOwner())
+                modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
+            // Apply haste mods
+            m_caster->ModSpellCastTime(m_spellInfo, duration, this);
+
+            m_spellState = SPELL_STATE_CASTING;
+            m_caster->AddInterruptMask(m_spellInfo->ChannelInterruptFlags);
+            SendChannelStart(duration);
+        }
+    }
+
+    PrepareTargetProcessing();
+
+    // process immediate effects (items, ground, etc.) also initialize some variables
+    _handle_immediate_phase();
+
+    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+        DoAllEffectOnTarget(&(*ihit));
+
+    for (std::list<GOTargetInfo>::iterator ihit= m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
+        DoAllEffectOnTarget(&(*ihit));
+
+    FinishTargetProcessing();
+
+    // spell is finished, perform some last features of the spell here
+    _handle_finish_phase();
+
+    // Remove used for cast item if need (it can be already NULL after TakeReagents call
+    TakeCastItem();
+
+    if (m_spellState != SPELL_STATE_CASTING)
+        finish(true);                                       // successfully finish spell cast (not last in case autorepeat or channel spell)
+}
+
+uint64 Spell::handle_delayed(uint64 t_offset)
+{
+    UpdatePointers();
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
+
+    uint64 next_time = 0;
+
+    PrepareTargetProcessing();
+
+    if (!m_immediateHandled)
+    {
+        _handle_immediate_phase();
+        m_immediateHandled = true;
+    }
+
+    bool single_missile = (m_targets.HasDst());
+
+    // now recheck units targeting correctness (need before any effects apply to prevent adding immunity at first effect not allow apply second spell effect and similar cases)
+    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        if (ihit->processed == false)
+        {
+            if (single_missile || ihit->timeDelay <= t_offset)
+                DoAllEffectOnTarget(&(*ihit));
+            else if (next_time == 0 || ihit->timeDelay < next_time)
+                next_time = ihit->timeDelay;
+        }
+    }
+
+    // now recheck gameobject targeting correctness
+    for (std::list<GOTargetInfo>::iterator ighit= m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end(); ++ighit)
+    {
+        if (ighit->processed == false)
+        {
+            if (single_missile || ighit->timeDelay <= t_offset)
+                DoAllEffectOnTarget(&(*ighit));
+            else if (next_time == 0 || ighit->timeDelay < next_time)
+                next_time = ighit->timeDelay;
+        }
+    }
+
+    FinishTargetProcessing();
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
+
+    // All targets passed - need finish phase
+    if (next_time == 0)
+    {
+        // spell is finished, perform some last features of the spell here
+        _handle_finish_phase();
+
+        finish(true);                                       // successfully finish spell cast
+
+        // return zero, spell is finished now
+        return 0;
+    }
+    else
+    {
+        // spell is unfinished, return next execution time
+        return next_time;
+    }
+}
+
+void Spell::_handle_immediate_phase()
+{
+    m_spellAura = NULL;
+    // handle some immediate features of the spell here
+    HandleThreatSpells(m_spellInfo->Id);
+
+    PrepareScriptHitHandlers();
+
+    for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        if (m_spellInfo->Effect[j] == 0)
+            continue;
+
+        // apply Send Event effect to ground in case empty target lists
+        if (m_spellInfo->Effect[j] == SPELL_EFFECT_SEND_EVENT && !HaveTargetsForEffect(j))
+        {
+            HandleEffects(NULL, NULL, NULL, j);
+            continue;
+        }
+    }
+
+    // initialize Diminishing Returns Data
+    m_diminishLevel = DIMINISHING_LEVEL_1;
+    m_diminishGroup = DIMINISHING_NONE;
+
+    // process items
+    for (std::list<ItemTargetInfo>::iterator ihit= m_UniqueItemInfo.begin(); ihit != m_UniqueItemInfo.end(); ++ihit)
+        DoAllEffectOnTarget(&(*ihit));
+
+    if (!m_originalCaster)
+        return;
+    uint8 oldEffMask = m_effectMask;
+    // process ground
+    for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        if (m_spellInfo->Effect[j] == 0)
+            continue;
+
+        if (EffectTargetType[m_spellInfo->Effect[j]] == SPELL_REQUIRE_DEST)
+        {
+            if (!m_targets.HasDst()) // FIXME: this will ignore dest set in effect
+                m_targets.setDst(*m_caster);
+            HandleEffects(m_originalCaster, NULL, NULL, j);
+            m_effectMask |= (1<<j);
+        }
+        else if (EffectTargetType[m_spellInfo->Effect[j]] == SPELL_REQUIRE_NONE)
+        {
+            HandleEffects(m_originalCaster, NULL, NULL, j);
+            m_effectMask |= (1<<j);
+        }
+    }
+    if (oldEffMask != m_effectMask && m_UniqueTargetInfo.empty())
+    {
+        uint32 procAttacker = m_procAttacker;
+        if (!procAttacker)
+        {
+            bool positive = true;
+            for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
+                // If at least one effect negative spell is negative hit
+                if (m_effectMask & (1<<i) && !IsPositiveEffect(m_spellInfo->Id, i))
+                {
+                    positive = false;
+                    break;
+                }
+            switch(m_spellInfo->DmgClass)
+            {
+                case SPELL_DAMAGE_CLASS_MAGIC:
+                    if (positive)
+                        procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS;
+                    else
+                        procAttacker |= PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG;
+                break;
+                case SPELL_DAMAGE_CLASS_NONE:
+                    if (positive)
+                        procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS;
+                    else
+                        procAttacker |= PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_NEG;
+                break;
+            }
+        }
+        // Proc damage for spells which have only dest targets (2484 should proc 51486 for example)
+        m_originalCaster->ProcDamageAndSpell(0, procAttacker, 0, m_procEx | PROC_EX_NORMAL_HIT, 0, BASE_ATTACK, m_spellInfo, m_triggeredByAuraSpell);
+    }
+}
+
+void Spell::_handle_finish_phase()
+{
+    if (m_caster->m_movedPlayer)
+    {
+        // Take for real after all targets are processed
+        if (m_needComboPoints)
+            m_caster->m_movedPlayer->ClearComboPoints();
+
+        // Real add combo points from effects
+        if (m_comboPointGain)
+            m_caster->m_movedPlayer->GainSpellComboPoints(m_comboPointGain);
+    }
+}
+
+void Spell::SendSpellCooldown()
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* _player = (Player*)m_caster;
+
+    // mana/health/etc potions, disabled by client (until combat out as declarate)
+    if (m_CastItem && m_CastItem->IsPotion())
+    {
+        // need in some way provided data for Spell::finish SendCooldownEvent
+        _player->SetLastPotionId(m_CastItem->GetEntry());
+        return;
+    }
+
+    // have infinity cooldown but set at aura apply                  // do not set cooldown for triggered spells (needed by reincarnation)
+    if (m_spellInfo->Attributes & (SPELL_ATTR_DISABLED_WHILE_ACTIVE | SPELL_ATTR_PASSIVE) || m_IsTriggeredSpell)
+        return;
+
+    _player->AddSpellAndCategoryCooldowns(m_spellInfo,m_CastItem ? m_CastItem->GetEntry() : 0, this);
+}
+
+void Spell::update(uint32 difftime)
+{
+    // update pointers based at it's GUIDs
+    UpdatePointers();
+
+    if (m_targets.getUnitTargetGUID() && !m_targets.getUnitTarget())
+    {
+        sLog.outDebug("Spell %u is cancelled due to removal of target.", m_spellInfo->Id);
+        cancel();
+        return;
+    }
+
+    // check if the player caster has moved before the spell finished
+    if ((m_caster->GetTypeId() == TYPEID_PLAYER && m_timer != 0) &&
+        m_caster->isMoving() && (m_spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_MOVEMENT) &&
+        (m_spellInfo->Effect[0] != SPELL_EFFECT_STUCK || !m_caster->HasUnitMovementFlag(MOVEMENTFLAG_FALLING)))
+    {
+        // don't cancel for melee, autorepeat, triggered and instant spells
+        if (!IsNextMeleeSwingSpell() && !IsAutoRepeat() && !m_IsTriggeredSpell)
+            cancel();
+    }
+
+    switch(m_spellState)
+    {
+        case SPELL_STATE_PREPARING:
+        {
+            if (m_timer)
+            {
+                if (difftime >= m_timer)
+                    m_timer = 0;
+                else
+                    m_timer -= difftime;
+            }
+
+            if (m_timer == 0 && !IsNextMeleeSwingSpell() && !IsAutoRepeat())
+                cast(m_spellInfo->CastingTimeIndex == 1);
+        } break;
+        case SPELL_STATE_CASTING:
+        {
+            if (m_timer > 0)
+            {
+                // check if there are alive targets left
+                if (!UpdateChanneledTargetList())
+                {
+                    sLog.outDebug("Channeled spell %d is removed due to lack of targets", m_spellInfo->Id);
+                    SendChannelUpdate(0);
+                    finish();
+                }
+
+                if (difftime >= m_timer)
+                    m_timer = 0;
+                else
+                    m_timer -= difftime;
+            }
+
+            if (m_timer == 0)
+            {
+                SendChannelUpdate(0);
+
+                // channeled spell processed independently for quest targeting
+                // cast at creature (or GO) quest objectives update at successful cast channel finished
+                // ignore autorepeat/melee casts for speed (not exist quest for spells (hm...)
+                if (!IsAutoRepeat() && !IsNextMeleeSwingSpell())
+                {
+                    if (Player* p = m_caster->GetCharmerOrOwnerPlayerOrPlayerItself())
+                    {
+                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        {
+                            TargetInfo* target = &*ihit;
+                            if (!IS_CRE_OR_VEH_GUID(target->targetGUID))
+                                continue;
+
+                            Unit* unit = m_caster->GetGUID() == target->targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, target->targetGUID);
+                            if (unit == NULL)
+                                continue;
+
+                            p->CastedCreatureOrGO(unit->GetEntry(), unit->GetGUID(), m_spellInfo->Id);
+                        }
+
+                        for (std::list<GOTargetInfo>::iterator ihit = m_UniqueGOTargetInfo.begin(); ihit != m_UniqueGOTargetInfo.end(); ++ihit)
+                        {
+                            GOTargetInfo* target = &*ihit;
+
+                            GameObject* go = m_caster->GetMap()->GetGameObject(target->targetGUID);
+                            if (!go)
+                                continue;
+
+                            p->CastedCreatureOrGO(go->GetEntry(), go->GetGUID(), m_spellInfo->Id);
+                        }
+                    }
+                }
+
+                finish();
+            }
+        } break;
+        default:
+        {
+        }break;
+    }
+}
+
+void Spell::finish(bool ok)
+{
+    if (!m_caster)
+        return;
+
+    if (m_spellState == SPELL_STATE_FINISHED)
+        return;
+    m_spellState = SPELL_STATE_FINISHED;
+
+    if (IsChanneledSpell(m_spellInfo))
+        m_caster->UpdateInterruptMask();
+
+    if (m_caster->hasUnitState(UNIT_STAT_CASTING) && !m_caster->IsNonMeleeSpellCasted(false, false, true))
+        m_caster->clearUnitState(UNIT_STAT_CASTING);
+
+    // Unsummon summon as possessed creatures on spell cancel
+    if (IsChanneledSpell(m_spellInfo) && m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (Unit *charm = m_caster->GetCharm())
+            if (charm->GetTypeId() == TYPEID_UNIT
+                && charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_PUPPET)
+                && charm->GetUInt32Value(UNIT_CREATED_BY_SPELL) == m_spellInfo->Id)
+                ((Puppet*)charm)->UnSummon();
+    }
+
+    if (!ok)
+        return;
+
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isSummon())
+    {
+        // Unsummon statue
+        uint32 spell = m_caster->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
+        if (spellInfo && spellInfo->SpellIconID == 2056)
+        {
+            sLog.outDebug("Statue %d is unsummoned in spell %d finish", m_caster->GetGUIDLow(), m_spellInfo->Id);
+            m_caster->setDeathState(JUST_DIED);
+            return;
+        }
+    }
+
+    if (IsAutoActionResetSpell())
+    {
+        bool found = false;
+        Unit::AuraEffectList const& vIgnoreReset = m_caster->GetAuraEffectsByType(SPELL_AURA_IGNORE_MELEE_RESET);
+        for (Unit::AuraEffectList::const_iterator i = vIgnoreReset.begin(); i != vIgnoreReset.end(); ++i)
+        {
+            if ((*i)->IsAffectedOnSpell(m_spellInfo))
+            {
+                found = true;
+                break;
+            }
+        }
+        if (!found && !(m_spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_RESET_AUTO_ACTIONS))
+        {
+            m_caster->resetAttackTimer(BASE_ATTACK);
+            if (m_caster->haveOffhandWeapon())
+                m_caster->resetAttackTimer(OFF_ATTACK);
+            m_caster->resetAttackTimer(RANGED_ATTACK);
+        }
+    }
+
+    // potions disabled by client, send event "not in combat" if need
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (!m_triggeredByAuraSpell)
+            m_caster->ToPlayer()->UpdatePotionCooldown(this);
+
+        // triggered spell pointer can be not set in some cases
+        // this is needed for proper apply of triggered spell mods
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, true);
+    }
+
+    // Take mods after trigger spell (needed for 14177 to affect 48664)
+    // mods are taken only on succesfull cast and independantly from targets of the spell
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        m_caster->ToPlayer()->RemoveSpellMods(this);
+        m_caster->ToPlayer()->SetSpellModTakingSpell(this, false);
+    }
+
+    // Stop Attack for some spells
+    if (m_spellInfo->Attributes & SPELL_ATTR_STOP_ATTACK_TARGET)
+        m_caster->AttackStop();
+}
+
+void Spell::SendCastResult(SpellCastResult result)
+{
+    if (result == SPELL_CAST_OK)
+        return;
+
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (m_caster->ToPlayer()->GetSession()->PlayerLoading())  // don't send cast results at loading time
+        return;
+
+    SendCastResult((Player*)m_caster,m_spellInfo,m_cast_count,result);
+}
+
+void Spell::SendCastResult(Player* caster, SpellEntry const* spellInfo, uint8 cast_count, SpellCastResult result)
+{
+    if (result == SPELL_CAST_OK)
+        return;
+
+    WorldPacket data(SMSG_CAST_FAILED, (4+1+1));
+    data << uint8(cast_count);                              // single cast or multi 2.3 (0/1)
+    data << uint32(spellInfo->Id);
+    data << uint8(result);                                  // problem
+    switch (result)
+    {
+        case SPELL_FAILED_REQUIRES_SPELL_FOCUS:
+            data << uint32(spellInfo->RequiresSpellFocus);
+            break;
+        case SPELL_FAILED_REQUIRES_AREA:
+            // hardcode areas limitation case
+            switch(spellInfo->Id)
+            {
+                case 41617:                                 // Cenarion Mana Salve
+                case 41619:                                 // Cenarion Healing Salve
+                    data << uint32(3905);
+                    break;
+                case 41618:                                 // Bottled Nethergon Energy
+                case 41620:                                 // Bottled Nethergon Vapor
+                    data << uint32(3842);
+                    break;
+                case 45373:                                 // Bloodberry Elixir
+                    data << uint32(4075);
+                    break;
+                default:                                    // default case (don't must be)
+                    data << uint32(0);
+                    break;
+            }
+            break;
+        case SPELL_FAILED_TOTEMS:
+            if (spellInfo->Totem[0])
+                data << uint32(spellInfo->Totem[0]);
+            if (spellInfo->Totem[1])
+                data << uint32(spellInfo->Totem[1]);
+            break;
+        case SPELL_FAILED_TOTEM_CATEGORY:
+            if (spellInfo->TotemCategory[0])
+                data << uint32(spellInfo->TotemCategory[0]);
+            if (spellInfo->TotemCategory[1])
+                data << uint32(spellInfo->TotemCategory[1]);
+            break;
+        case SPELL_FAILED_EQUIPPED_ITEM_CLASS:
+            data << uint32(spellInfo->EquippedItemClass);
+            data << uint32(spellInfo->EquippedItemSubClassMask);
+            //data << uint32(spellInfo->EquippedItemInventoryTypeMask);
+            break;
+        case SPELL_FAILED_TOO_MANY_OF_ITEM:
+        {
+             uint32 item = 0;
+             for (int8 x=0;x < 3;x++)
+                 if (spellInfo->EffectItemType[x])
+                     item = spellInfo->EffectItemType[x];
+             ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item);
+             if (pProto && pProto->ItemLimitCategory)
+                 data << uint32(pProto->ItemLimitCategory);
+             break;
+        }
+        default:
+            break;
+    }
+    caster->GetSession()->SendPacket(&data);
+}
+
+void Spell::SendSpellStart()
+{
+    if (!IsNeedSendToClient())
+        return;
+
+    //sLog.outDebug("Sending SMSG_SPELL_START id=%u", m_spellInfo->Id);
+
+    uint32 castFlags = CAST_FLAG_UNKNOWN_2;
+    if (m_spellInfo->Attributes & SPELL_ATTR_REQ_AMMO)
+        castFlags |= CAST_FLAG_AMMO;
+    if ((m_caster->GetTypeId() == TYPEID_PLAYER ||
+        (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet()))
+         && m_spellInfo->powerType != POWER_HEALTH)
+        castFlags |= CAST_FLAG_POWER_LEFT_SELF;
+
+    if (m_spellInfo->runeCostID && m_spellInfo->powerType == POWER_RUNE)
+        castFlags |= CAST_FLAG_UNKNOWN_19;
+
+    WorldPacket data(SMSG_SPELL_START, (8+8+4+4+2));
+    if (m_CastItem)
+        data.append(m_CastItem->GetPackGUID());
+    else
+        data.append(m_caster->GetPackGUID());
+
+    data.append(m_caster->GetPackGUID());
+    data << uint8(m_cast_count);                            // pending spell cast?
+    data << uint32(m_spellInfo->Id);                        // spellId
+    data << uint32(castFlags);                              // cast flags
+    data << uint32(m_timer);                                // delay?
+
+    m_targets.write(data);
+
+    if (castFlags & CAST_FLAG_POWER_LEFT_SELF)
+        data << uint32(m_caster->GetPower((Powers)m_spellInfo->powerType));
+
+    if (castFlags & CAST_FLAG_AMMO)
+        WriteAmmoToPacket(&data);
+
+    if (castFlags & CAST_FLAG_UNKNOWN_23)
+    {
+        data << uint32(0);
+        data << uint32(0);
+    }
+
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::SendSpellGo()
+{
+    // not send invisible spell casting
+    if (!IsNeedSendToClient())
+        return;
+
+    //sLog.outDebug("Sending SMSG_SPELL_GO id=%u", m_spellInfo->Id);
+
+    uint32 castFlags = CAST_FLAG_UNKNOWN_9;
+
+    // triggered spells with spell visual != 0
+    if ((m_IsTriggeredSpell && !IsAutoRepeatRangedSpell(m_spellInfo)) || m_triggeredByAuraSpell)
+        castFlags |= CAST_FLAG_PENDING;
+
+    if (m_spellInfo->Attributes & SPELL_ATTR_REQ_AMMO)
+        castFlags |= CAST_FLAG_AMMO;                        // arrows/bullets visual
+    if ((m_caster->GetTypeId() == TYPEID_PLAYER ||
+        (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet()))
+        && m_spellInfo->powerType != POWER_HEALTH)
+        castFlags |= CAST_FLAG_POWER_LEFT_SELF; // should only be sent to self, but the current messaging doesn't make that possible
+
+    if ((m_caster->GetTypeId() == TYPEID_PLAYER)
+        && (m_caster->getClass() == CLASS_DEATH_KNIGHT)
+        && m_spellInfo->runeCostID
+        && m_spellInfo->powerType == POWER_RUNE)
+    {
+        castFlags |= CAST_FLAG_UNKNOWN_19;                   // same as in SMSG_SPELL_START
+        castFlags |= CAST_FLAG_RUNE_LIST;                    // rune cooldowns list
+        castFlags |= CAST_FLAG_UNKNOWN_9;                    // ??
+    }
+
+    if (IsSpellHaveEffect(m_spellInfo, SPELL_EFFECT_ACTIVATE_RUNE))
+    {
+        castFlags |= CAST_FLAG_RUNE_LIST;                    // rune cooldowns list
+        castFlags |= CAST_FLAG_UNKNOWN_19;                   // same as in SMSG_SPELL_START
+    }
+
+    WorldPacket data(SMSG_SPELL_GO, 50);                    // guess size
+
+    if (m_CastItem)
+        data.append(m_CastItem->GetPackGUID());
+    else
+        data.append(m_caster->GetPackGUID());
+
+    data.append(m_caster->GetPackGUID());
+    data << uint8(m_cast_count);                            // pending spell cast?
+    data << uint32(m_spellInfo->Id);                        // spellId
+    data << uint32(castFlags);                              // cast flags
+    data << uint32(getMSTime());                            // timestamp
+
+    /*
+    // statement below seems to be wrong - i've seen spells with both unit and dest target
+    // Can't have TARGET_FLAG_UNIT when *_LOCATION is present - it breaks missile visuals
+    if (m_targets.getTargetMask() & (TARGET_FLAG_SOURCE_LOCATION | TARGET_FLAG_DEST_LOCATION))
+        m_targets.setTargetMask(m_targets.getTargetMask() & ~TARGET_FLAG_UNIT);
+    else if (m_targets.getIntTargetFlags() & FLAG_INT_UNIT)
+        m_targets.setTargetMask(m_targets.getTargetMask() | TARGET_FLAG_UNIT);
+    */
+
+    WriteSpellGoTargets(&data);
+
+    m_targets.write(data);
+
+    if (castFlags & CAST_FLAG_POWER_LEFT_SELF)
+        data << uint32(m_caster->GetPower((Powers)m_spellInfo->powerType));
+
+    if (castFlags & CAST_FLAG_RUNE_LIST)                   // rune cooldowns list
+    {
+        uint8 v1 = m_runesState;
+        uint8 v2 = m_caster->ToPlayer()->GetRunesState();
+        data << uint8(v1);                                  // runes state before
+        data << uint8(v2);                                  // runes state after
+        for (uint8 i = 0; i < MAX_RUNES; ++i)
+        {
+            uint8 m = (1 << i);
+            if (m & v1)                                      // usable before...
+                if (!(m & v2))                               // ...but on cooldown now...
+                    data << uint8(0);                       // some unknown byte (time?)
+        }
+    }
+
+    if (castFlags & CAST_FLAG_UNKNOWN_18)                   // unknown wotlk
+    {
+        data << float(0);
+        data << uint32(0);
+    }
+
+    if (castFlags & CAST_FLAG_AMMO)
+        WriteAmmoToPacket(&data);
+
+    if (castFlags & CAST_FLAG_UNKNOWN_20)                   // unknown wotlk
+    {
+        data << uint32(0);
+        data << uint32(0);
+    }
+
+    if (m_targets.getTargetMask() & TARGET_FLAG_DEST_LOCATION)
+    {
+        data << uint8(0);
+    }
+
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::WriteAmmoToPacket(WorldPacket * data)
+{
+    uint32 ammoInventoryType = 0;
+    uint32 ammoDisplayID = 0;
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        Item *pItem = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
+        if (pItem)
+        {
+            ammoInventoryType = pItem->GetProto()->InventoryType;
+            if (ammoInventoryType == INVTYPE_THROWN)
+                ammoDisplayID = pItem->GetProto()->DisplayInfoID;
+            else
+            {
+                uint32 ammoID = m_caster->ToPlayer()->GetUInt32Value(PLAYER_AMMO_ID);
+                if (ammoID)
+                {
+                    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(ammoID);
+                    if (pProto)
+                    {
+                        ammoDisplayID = pProto->DisplayInfoID;
+                        ammoInventoryType = pProto->InventoryType;
+                    }
+                }
+                else if (m_caster->HasAura(46699))      // Requires No Ammo
+                {
+                    ammoDisplayID = 5996;                   // normal arrow
+                    ammoInventoryType = INVTYPE_AMMO;
+                }
+            }
+        }
+    }
+    else
+    {
+        for (uint8 i = 0; i < 3; ++i)
+        {
+            if (uint32 item_id = m_caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i))
+            {
+                if (ItemEntry const * itemEntry = sItemStore.LookupEntry(item_id))
+                {
+                    if (itemEntry->Class == ITEM_CLASS_WEAPON)
+                    {
+                        switch(itemEntry->SubClass)
+                        {
+                            case ITEM_SUBCLASS_WEAPON_THROWN:
+                                ammoDisplayID = itemEntry->DisplayId;
+                                ammoInventoryType = itemEntry->InventoryType;
+                                break;
+                            case ITEM_SUBCLASS_WEAPON_BOW:
+                            case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                                ammoDisplayID = 5996;       // is this need fixing?
+                                ammoInventoryType = INVTYPE_AMMO;
+                                break;
+                            case ITEM_SUBCLASS_WEAPON_GUN:
+                                ammoDisplayID = 5998;       // is this need fixing?
+                                ammoInventoryType = INVTYPE_AMMO;
+                                break;
+                        }
+
+                        if (ammoDisplayID)
+                            break;
+                    }
+                }
+            }
+        }
+    }
+
+    *data << uint32(ammoDisplayID);
+    *data << uint32(ammoInventoryType);
+}
+
+void Spell::WriteSpellGoTargets(WorldPacket * data)
+{
+    // This function also fill data for channeled spells:
+    // m_needAliveTargetMask req for stop channelig if one target die
+    uint32 hit  = m_UniqueGOTargetInfo.size(); // Always hits on GO
+    uint32 miss = 0;
+    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        if ((*ihit).effectMask == 0)                  // No effect apply - all immuned add state
+        {
+            // possibly SPELL_MISS_IMMUNE2 for this??
+            ihit->missCondition = SPELL_MISS_IMMUNE2;
+            ++miss;
+        }
+        else if ((*ihit).missCondition == SPELL_MISS_NONE)
+            ++hit;
+        else
+            ++miss;
+    }
+
+    *data << (uint8)hit;
+    for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        if ((*ihit).missCondition == SPELL_MISS_NONE)       // Add only hits
+        {
+            *data << uint64(ihit->targetGUID);
+            m_channelTargetEffectMask |=ihit->effectMask;
+        }
+    }
+
+    for (std::list<GOTargetInfo>::const_iterator ighit = m_UniqueGOTargetInfo.begin(); ighit != m_UniqueGOTargetInfo.end(); ++ighit)
+        *data << uint64(ighit->targetGUID);                 // Always hits
+
+    *data << (uint8)miss;
+    for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        if (ihit->missCondition != SPELL_MISS_NONE)        // Add only miss
+        {
+            *data << uint64(ihit->targetGUID);
+            *data << uint8(ihit->missCondition);
+            if (ihit->missCondition == SPELL_MISS_REFLECT)
+                *data << uint8(ihit->reflectResult);
+        }
+    }
+    // Reset m_needAliveTargetMask for non channeled spell
+    if (!IsChanneledSpell(m_spellInfo))
+        m_channelTargetEffectMask = 0;
+}
+
+void Spell::SendLogExecute()
+{
+    WorldPacket data(SMSG_SPELLLOGEXECUTE, (8+4+4+4+4+8));
+
+    data.append(m_caster->GetPackGUID());
+
+    data << uint32(m_spellInfo->Id);
+
+    uint8 effCount = 0;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (m_effectExecuteData[i])
+            ++effCount;
+    }
+
+    if (!effCount)
+        return;
+
+    data << uint32(effCount);
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (!m_effectExecuteData[i])
+            continue;
+
+        data << uint32(m_spellInfo->Effect[i]);             // spell effect
+
+        data.append(*m_effectExecuteData[i]);
+
+        delete m_effectExecuteData[i];
+        m_effectExecuteData[i] = NULL;
+    }
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::ExecuteLogEffectTakeTargetPower(uint8 effIndex, Unit * target, uint32 powerType, uint32 powerTaken, float gainMultiplier)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(target->GetPackGUID());
+    *m_effectExecuteData[effIndex] << uint32(powerTaken);
+    *m_effectExecuteData[effIndex] << uint32(powerType);
+    *m_effectExecuteData[effIndex] << float(gainMultiplier);
+}
+
+void Spell::ExecuteLogEffectExtraAttacks(uint8 effIndex, Unit * victim, uint32 attCount)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(victim->GetPackGUID());
+    *m_effectExecuteData[effIndex] << uint32(attCount);
+}
+
+void Spell::ExecuteLogEffectInterruptCast(uint8 effIndex, Unit * victim, uint32 spellId)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(victim->GetPackGUID());
+    *m_effectExecuteData[effIndex] << uint32(spellId);
+}
+
+void Spell::ExecuteLogEffectDurabilityDamage(uint8 effIndex, Unit * victim, uint32 /*itemslot*/, uint32 damage)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(victim->GetPackGUID());
+    *m_effectExecuteData[effIndex] << uint32(m_spellInfo->Id);
+    *m_effectExecuteData[effIndex] << uint32(damage);
+}
+
+void Spell::ExecuteLogEffectOpenLock(uint8 effIndex, Object * obj)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(obj->GetPackGUID());
+}
+
+void Spell::ExecuteLogEffectCreateItem(uint8 effIndex, uint32 entry)
+{
+    InitEffectExecuteData(effIndex);
+    *m_effectExecuteData[effIndex] << uint32(entry);
+}
+
+void Spell::ExecuteLogEffectDestroyItem(uint8 effIndex, uint32 entry)
+{
+    InitEffectExecuteData(effIndex);
+    *m_effectExecuteData[effIndex] << uint32(entry);
+}
+
+void Spell::ExecuteLogEffectSummonObject(uint8 effIndex, WorldObject * obj)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(obj->GetPackGUID());
+}
+
+void Spell::ExecuteLogEffectUnsummonObject(uint8 effIndex, WorldObject * obj)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(obj->GetPackGUID());
+}
+
+void Spell::ExecuteLogEffectResurrect(uint8 effIndex, Unit * target)
+{
+    InitEffectExecuteData(effIndex);
+    m_effectExecuteData[effIndex]->append(target->GetPackGUID());
+}
+
+void Spell::SendInterrupted(uint8 result)
+{
+    WorldPacket data(SMSG_SPELL_FAILURE, (8+4+1));
+    data.append(m_caster->GetPackGUID());
+    data << uint8(m_cast_count);
+    data << uint32(m_spellInfo->Id);
+    data << uint8(result);
+    m_caster->SendMessageToSet(&data, true);
+
+    data.Initialize(SMSG_SPELL_FAILED_OTHER, (8+4));
+    data.append(m_caster->GetPackGUID());
+    data << uint8(m_cast_count);
+    data << uint32(m_spellInfo->Id);
+    data << uint8(result);
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::SendChannelUpdate(uint32 time)
+{
+    if (time == 0)
+    {
+        m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, 0);
+        m_caster->SetUInt32Value(UNIT_CHANNEL_SPELL, 0);
+    }
+
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(MSG_CHANNEL_UPDATE, 8+4);
+    data.append(m_caster->GetPackGUID());
+    data << uint32(time);
+
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::SendChannelStart(uint32 duration)
+{
+    WorldObject* target = NULL;
+
+    // select first not resisted target from target list for _0_ effect
+    if (!m_UniqueTargetInfo.empty())
+    {
+        for (std::list<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
+        {
+            if ((itr->effectMask & (1 << 0)) && itr->reflectResult == SPELL_MISS_NONE && itr->targetGUID != m_caster->GetGUID())
+            {
+                target = ObjectAccessor::GetUnit(*m_caster, itr->targetGUID);
+                break;
+            }
+        }
+    }
+    else if (!m_UniqueGOTargetInfo.empty())
+    {
+        for (std::list<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
+        {
+            if (itr->effectMask & (1 << 0))
+            {
+                target = m_caster->GetMap()->GetGameObject(itr->targetGUID);
+                break;
+            }
+        }
+    }
+
+    WorldPacket data(MSG_CHANNEL_START, (8+4+4));
+    data.append(m_caster->GetPackGUID());
+    data << uint32(m_spellInfo->Id);
+    data << uint32(duration);
+
+    m_caster->SendMessageToSet(&data, true);
+
+    m_timer = duration;
+    if (target)
+        m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, target->GetGUID());
+    m_caster->SetUInt32Value(UNIT_CHANNEL_SPELL, m_spellInfo->Id);
+}
+
+void Spell::SendResurrectRequest(Player* target)
+{
+    // Both players and NPCs can resurrect using spells - have a look at creature 28487 for example
+    // However, the packet structure differs slightly
+
+    const char* sentName = m_caster->GetTypeId() == TYPEID_PLAYER ? "" : m_caster->GetNameForLocaleIdx(target->GetSession()->GetSessionDbLocaleIndex());
+
+    WorldPacket data(SMSG_RESURRECT_REQUEST, (8+4+strlen(sentName)+1+1+1));
+    data << uint64(m_caster->GetGUID());
+    data << uint32(strlen(sentName) + 1);
+
+    data << sentName;
+    data << uint8(0);
+
+    data << uint8(m_caster->GetTypeId() == TYPEID_PLAYER ? 0 : 1);
+    target->GetSession()->SendPacket(&data);
+}
+
+void Spell::SendPlaySpellVisual(uint32 SpellID)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 8 + 4);
+    data << uint64(m_caster->GetGUID());
+    data << uint32(SpellID);                                // spell visual id?
+    m_caster->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Spell::TakeCastItem()
+{
+    if (!m_CastItem || m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // not remove cast item at triggered spell (equipping, weapon damage, etc)
+    if (m_IsTriggeredSpell)
+        return;
+
+    ItemPrototype const *proto = m_CastItem->GetProto();
+
+    if (!proto)
+    {
+        // This code is to avoid a crash
+        // I'm not sure, if this is really an error, but I guess every item needs a prototype
+        sLog.outError("Cast item has no item prototype highId=%d, lowId=%d",m_CastItem->GetGUIDHigh(), m_CastItem->GetGUIDLow());
+        return;
+    }
+
+    bool expendable = false;
+    bool withoutCharges = false;
+
+    for (int i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        if (proto->Spells[i].SpellId)
+        {
+            // item has limited charges
+            if (proto->Spells[i].SpellCharges)
+            {
+                if (proto->Spells[i].SpellCharges < 0)
+                    expendable = true;
+
+                int32 charges = m_CastItem->GetSpellCharges(i);
+
+                // item has charges left
+                if (charges)
+                {
+                    (charges > 0) ? --charges : ++charges;  // abs(charges) less at 1 after use
+                    if (proto->Stackable == 1)
+                        m_CastItem->SetSpellCharges(i, charges);
+                    m_CastItem->SetState(ITEM_CHANGED, (Player*)m_caster);
+                }
+
+                // all charges used
+                withoutCharges = (charges == 0);
+            }
+        }
+    }
+
+    if (expendable && withoutCharges)
+    {
+        uint32 count = 1;
+        m_caster->ToPlayer()->DestroyItemCount(m_CastItem, count, true);
+
+        // prevent crash at access to deleted m_targets.getItemTarget
+        if (m_CastItem == m_targets.getItemTarget())
+            m_targets.setItemTarget(NULL);
+
+        m_CastItem = NULL;
+    }
+}
+
+void Spell::TakePower()
+{
+    if (m_CastItem || m_triggeredByAuraSpell)
+        return;
+
+    bool hit = true;
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (m_spellInfo->powerType == POWER_RAGE || m_spellInfo->powerType == POWER_ENERGY)
+            if (uint64 targetGUID = m_targets.getUnitTargetGUID())
+                for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                    if (ihit->targetGUID == targetGUID)
+                    {
+                        if (ihit->missCondition != SPELL_MISS_NONE && ihit->missCondition != SPELL_MISS_MISS/* && ihit->targetGUID != m_caster->GetGUID()*/)
+                            hit = false;
+                        if (ihit->missCondition != SPELL_MISS_NONE)
+                        {
+                            //lower spell cost on fail (by talent aura)
+                            if (Player *modOwner = m_caster->ToPlayer()->GetSpellModOwner())
+                                modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_SPELL_COST_REFUND_ON_FAIL, m_powerCost);
+                        }
+                        break;
+                    }
+    }
+
+    Powers powerType = Powers(m_spellInfo->powerType);
+
+    if (hit && powerType == POWER_RUNE)
+    {
+        TakeRunePower();
+        return;
+    }
+
+    if (!m_powerCost)
+        return;
+
+    // health as power used
+    if (m_spellInfo->powerType == POWER_HEALTH)
+    {
+        m_caster->ModifyHealth(-(int32)m_powerCost);
+        return;
+    }
+
+    if (m_spellInfo->powerType >= MAX_POWERS)
+    {
+        sLog.outError("Spell::TakePower: Unknown power type '%d'", m_spellInfo->powerType);
+        return;
+    }
+
+    if (hit)
+        m_caster->ModifyPower(powerType, -m_powerCost);
+    else
+        m_caster->ModifyPower(powerType, -irand(0, m_powerCost/4));
+
+    // Set the five second timer
+    if (powerType == POWER_MANA && m_powerCost > 0)
+        m_caster->SetLastManaUse(getMSTime());
+}
+
+void Spell::TakeAmmo()
+{
+    if (m_attackType == RANGED_ATTACK && m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        Item *pItem = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
+
+        // wands don't have ammo
+        if (!pItem  || pItem->IsBroken() || pItem->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_WAND)
+            return;
+
+        if (pItem->GetProto()->InventoryType == INVTYPE_THROWN)
+        {
+            if (pItem->GetMaxStackCount() == 1)
+            {
+                // decrease durability for non-stackable throw weapon
+                m_caster->ToPlayer()->DurabilityPointLossForEquipSlot(EQUIPMENT_SLOT_RANGED);
+            }
+            else
+            {
+                // decrease items amount for stackable throw weapon
+                uint32 count = 1;
+                m_caster->ToPlayer()->DestroyItemCount(pItem, count, true);
+            }
+        }
+        else if (uint32 ammo = m_caster->ToPlayer()->GetUInt32Value(PLAYER_AMMO_ID))
+            m_caster->ToPlayer()->DestroyItemCount(ammo, 1, true);
+    }
+}
+
+SpellCastResult Spell::CheckRuneCost(uint32 runeCostID)
+{
+    if (m_spellInfo->powerType != POWER_RUNE || !runeCostID)
+        return SPELL_CAST_OK;
+
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return SPELL_CAST_OK;
+
+    Player *plr = (Player*)m_caster;
+
+    if (plr->getClass() != CLASS_DEATH_KNIGHT)
+        return SPELL_CAST_OK;
+
+    SpellRuneCostEntry const *src = sSpellRuneCostStore.LookupEntry(runeCostID);
+
+    if (!src)
+        return SPELL_CAST_OK;
+
+    if (src->NoRuneCost())
+        return SPELL_CAST_OK;
+
+    int32 runeCost[NUM_RUNE_TYPES];                         // blood, frost, unholy, death
+
+    for (uint32 i = 0; i < RUNE_DEATH; ++i)
+    {
+        runeCost[i] = src->RuneCost[i];
+        if (Player* modOwner = m_caster->GetSpellModOwner())
+            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_COST, runeCost[i], this);
+    }
+
+    runeCost[RUNE_DEATH] = MAX_RUNES;                       // calculated later
+
+    for (uint32 i = 0; i < MAX_RUNES; ++i)
+    {
+        RuneType rune = plr->GetCurrentRune(i);
+        if ((plr->GetRuneCooldown(i) == 0) && (runeCost[rune] > 0))
+            runeCost[rune]--;
+    }
+
+    for (uint32 i = 0; i < RUNE_DEATH; ++i)
+        if (runeCost[i] > 0)
+            runeCost[RUNE_DEATH] += runeCost[i];
+
+    if (runeCost[RUNE_DEATH] > MAX_RUNES)
+        return SPELL_FAILED_NO_POWER;                       // not sure if result code is correct
+
+    return SPELL_CAST_OK;
+}
+
+void Spell::TakeRunePower()
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *plr = (Player*)m_caster;
+
+    if (plr->getClass() != CLASS_DEATH_KNIGHT)
+        return;
+
+    SpellRuneCostEntry const *src = sSpellRuneCostStore.LookupEntry(m_spellInfo->runeCostID);
+
+    if (!src || (src->NoRuneCost() && src->NoRunicPowerGain()))
+        return;
+
+    m_runesState = plr->GetRunesState();                    // store previous state
+
+    int32 runeCost[NUM_RUNE_TYPES];                         // blood, frost, unholy, death
+
+    for (uint32 i = 0; i < RUNE_DEATH; ++i)
+    {
+        runeCost[i] = src->RuneCost[i];
+        if (Player* modOwner = m_caster->GetSpellModOwner())
+            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_COST, runeCost[i], this);
+    }
+
+    runeCost[RUNE_DEATH] = 0;                               // calculated later
+
+    for (uint32 i = 0; i < MAX_RUNES; ++i)
+    {
+        RuneType rune = plr->GetCurrentRune(i);
+        if ((plr->GetRuneCooldown(i) == 0) && (runeCost[rune] > 0))
+        {
+            plr->SetRuneCooldown(i, plr->GetRuneBaseCooldown(i));
+            plr->SetLastUsedRune(RuneType(rune));
+            runeCost[rune]--;
+        }
+    }
+
+    runeCost[RUNE_DEATH] = runeCost[RUNE_BLOOD] + runeCost[RUNE_UNHOLY] + runeCost[RUNE_FROST];
+
+    if (runeCost[RUNE_DEATH] > 0)
+    {
+        for (uint32 i = 0; i < MAX_RUNES; ++i)
+        {
+            RuneType rune = plr->GetCurrentRune(i);
+            if ((plr->GetRuneCooldown(i) == 0) && (rune == RUNE_DEATH))
+            {
+                plr->SetRuneCooldown(i, plr->GetRuneBaseCooldown(i));
+                plr->SetLastUsedRune(RuneType(rune));
+                runeCost[rune]--;
+
+                plr->RestoreBaseRune(i);
+
+                if (runeCost[RUNE_DEATH] == 0)
+                    break;
+            }
+        }
+    }
+
+    // you can gain some runic power when use runes
+    float rp = (float)src->runePowerGain;
+    rp *= sWorld.getRate(RATE_POWER_RUNICPOWER_INCOME);
+    plr->ModifyPower(POWER_RUNIC_POWER, (int32)rp);
+}
+
+void Spell::TakeReagents()
+{
+    if (m_IsTriggeredSpell)                                  // reagents used in triggered spell removed by original spell or don't must be removed.
+    {
+        Item* targetItem = m_targets.getItemTarget();
+        /// Not own traded item (in trader trade slot) req. reagents including triggered spell case
+        if (!(targetItem && targetItem->GetOwnerGUID() != m_caster->GetGUID()))
+            return;
+    }
+
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // do not take reagents for these item casts
+    if (m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+    if (p_caster->CanNoReagentCast(m_spellInfo))
+        return;
+
+    for (uint32 x = 0; x < MAX_SPELL_REAGENTS; ++x)
+    {
+        if (m_spellInfo->Reagent[x] <= 0)
+            continue;
+
+        uint32 itemid = m_spellInfo->Reagent[x];
+        uint32 itemcount = m_spellInfo->ReagentCount[x];
+
+        // if CastItem is also spell reagent
+        if (m_CastItem)
+        {
+            ItemPrototype const *proto = m_CastItem->GetProto();
+            if (proto && proto->ItemId == itemid)
+            {
+                for (int s = 0; s < MAX_ITEM_PROTO_SPELLS; ++s)
+                {
+                    // CastItem will be used up and does not count as reagent
+                    int32 charges = m_CastItem->GetSpellCharges(s);
+                    if (proto->Spells[s].SpellCharges < 0 && abs(charges) < 2)
+                    {
+                        ++itemcount;
+                        break;
+                    }
+                }
+
+                m_CastItem = NULL;
+            }
+        }
+
+        // if getItemTarget is also spell reagent
+        if (m_targets.getItemTargetEntry() == itemid)
+            m_targets.setItemTarget(NULL);
+
+        p_caster->DestroyItemCount(itemid, itemcount, true);
+    }
+}
+
+void Spell::HandleThreatSpells(uint32 spellId)
+{
+    if (!m_targets.getUnitTarget() || !spellId)
+        return;
+
+    if (!m_targets.getUnitTarget()->CanHaveThreatList())
+        return;
+
+    uint16 threat = sSpellMgr.GetSpellThreat(spellId);
+
+    if (!threat)
+        return;
+
+    m_targets.getUnitTarget()->AddThreat(m_caster, float(threat));
+
+    sLog.outStaticDebug("Spell %u, rank %u, added an additional %i threat", spellId, sSpellMgr.GetSpellRank(spellId), threat);
+}
+
+void Spell::HandleEffects(Unit *pUnitTarget,Item *pItemTarget,GameObject *pGOTarget,uint32 i)
+{
+    //effect has been handled, skip it
+    if (m_effectMask & (1<<i))
+        return;
+
+    unitTarget = pUnitTarget;
+    itemTarget = pItemTarget;
+    gameObjTarget = pGOTarget;
+
+    uint8 eff = m_spellInfo->Effect[i];
+
+    sLog.outDebug("Spell: %u Effect : %u", m_spellInfo->Id, eff);
+
+    //we do not need DamageMultiplier here.
+    damage = CalculateDamage(i, NULL);
+
+    bool preventDefault = CallScriptEffectHandlers((SpellEffIndex)i);
+
+    if (!preventDefault && eff < TOTAL_SPELL_EFFECTS)
+    {
+        (this->*SpellEffects[eff])((SpellEffIndex)i);
+    }
+}
+
+SpellCastResult Spell::CheckCast(bool strict)
+{
+	OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
+
+    // check death state
+    if (!m_IsTriggeredSpell && !m_caster->isAlive() && !(m_spellInfo->Attributes & SPELL_ATTR_PASSIVE) && !(m_spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD))
+        return SPELL_FAILED_CASTER_DEAD;
+
+    // check cooldowns to prevent cheating
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && !(m_spellInfo->Attributes & SPELL_ATTR_PASSIVE))
+    {
+        //can cast triggered (by aura only?) spells while have this flag
+        if (!m_IsTriggeredSpell && m_caster->ToPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_ALLOW_ONLY_ABILITY))
+            return SPELL_FAILED_SPELL_IN_PROGRESS;
+
+        if (m_caster->ToPlayer()->HasSpellCooldown(m_spellInfo->Id) ||
+            (strict && !m_IsTriggeredSpell && m_caster->ToPlayer()->HasGlobalCooldown(m_spellInfo)))
+        {
+            if (m_triggeredByAuraSpell)
+                return SPELL_FAILED_DONT_REPORT;
+            else
+                return SPELL_FAILED_NOT_READY;
+        }
+    }
+
+    // only allow triggered spells if at an ended battleground
+    if (!m_IsTriggeredSpell && m_caster->GetTypeId() == TYPEID_PLAYER)
+        if (Battleground * bg = m_caster->ToPlayer()->GetBattleground())
+            if (bg->GetStatus() == STATUS_WAIT_LEAVE)
+                return SPELL_FAILED_DONT_REPORT;
+
+    if(m_caster->GetTypeId() == TYPEID_PLAYER && VMAP::VMapFactory::createOrGetVMapManager()->isLineOfSightCalcEnabled())
+    {
+        if(m_spellInfo->Attributes & SPELL_ATTR_OUTDOORS_ONLY &&
+                !m_caster->GetMap()->IsOutdoors(m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ()))
+            return SPELL_FAILED_ONLY_OUTDOORS;
+
+        if(m_spellInfo->Attributes & SPELL_ATTR_INDOORS_ONLY &&
+                m_caster->GetMap()->IsOutdoors(m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ()))
+            return SPELL_FAILED_ONLY_INDOORS;
+    }
+
+    // only check at first call, Stealth auras are already removed at second call
+    // for now, ignore triggered spells
+    if (strict && !m_IsTriggeredSpell)
+    {
+        bool checkForm = true;
+        // Ignore form req aura
+        Unit::AuraEffectList const& ignore = m_caster->GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
+        for (Unit::AuraEffectList::const_iterator i = ignore.begin(); i != ignore.end(); ++i)
+        {
+            if (!(*i)->IsAffectedOnSpell(m_spellInfo))
+                continue;
+            checkForm = false;
+            break;
+        }
+        if (checkForm)
+        {
+            // Cannot be used in this stance/form
+            SpellCastResult shapeError = GetErrorAtShapeshiftedCast(m_spellInfo, m_caster->m_form);
+            if (shapeError != SPELL_CAST_OK)
+                return shapeError;
+
+            if ((m_spellInfo->Attributes & SPELL_ATTR_ONLY_STEALTHED) && !(m_caster->HasStealthAura()))
+                return SPELL_FAILED_ONLY_STEALTHED;
+        }
+    }
+
+    bool reqCombat=true;
+    Unit::AuraEffectList const& stateAuras = m_caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_IGNORE_AURASTATE);
+    for (Unit::AuraEffectList::const_iterator j = stateAuras.begin(); j != stateAuras.end(); ++j)
+    {
+        if ((*j)->IsAffectedOnSpell(m_spellInfo))
+        {
+            m_needComboPoints = false;
+            if ((*j)->GetMiscValue() == 1)
+            {
+                reqCombat=false;
+                break;
+            }
+        }
+    }
+
+    // caster state requirements
+    // not for triggered spells (needed by execute)
+    if (!m_IsTriggeredSpell)
+    {
+        if (m_spellInfo->CasterAuraState && !m_caster->HasAuraState(AuraState(m_spellInfo->CasterAuraState), m_spellInfo, m_caster))
+            return SPELL_FAILED_CASTER_AURASTATE;
+        if (m_spellInfo->CasterAuraStateNot && m_caster->HasAuraState(AuraState(m_spellInfo->CasterAuraStateNot), m_spellInfo, m_caster))
+            return SPELL_FAILED_CASTER_AURASTATE;
+
+        // Note: spell 62473 requres casterAuraSpell = triggering spell
+        if (m_spellInfo->casterAuraSpell && !m_caster->HasAura(m_spellInfo->casterAuraSpell))
+            return SPELL_FAILED_CASTER_AURASTATE;
+        if (m_spellInfo->excludeCasterAuraSpell && m_caster->HasAura(m_spellInfo->excludeCasterAuraSpell))
+            return SPELL_FAILED_CASTER_AURASTATE;
+
+        if (reqCombat && m_caster->isInCombat() && IsNonCombatSpell(m_spellInfo))
+            return SPELL_FAILED_AFFECTING_COMBAT;
+    }
+
+    // cancel autorepeat spells if cast start when moving
+    // (not wand currently autorepeat cast delayed to moving stop anyway in spell update code)
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->isMoving())
+    {
+        // skip stuck spell to allow use it in falling case and apply spell limitations at movement
+        if ((!m_caster->HasUnitMovementFlag(MOVEMENTFLAG_FALLING) || m_spellInfo->Effect[0] != SPELL_EFFECT_STUCK) &&
+            (IsAutoRepeat() || (m_spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED) != 0))
+            return SPELL_FAILED_MOVING;
+    }
+
+    Unit *target = m_targets.getUnitTarget();
+
+    // In pure self-cast spells, the client won't send any unit target
+    if (!target && (m_targets.getTargetMask() == TARGET_FLAG_SELF || m_targets.getTargetMask() & TARGET_FLAG_UNIT_CASTER)) // TARGET_FLAG_SELF == 0, remember!
+        target = m_caster;
+
+    if (target)
+    {
+        // target state requirements (not allowed state), apply to self also
+        if (!m_IsTriggeredSpell && m_spellInfo->TargetAuraStateNot && target->HasAuraState(AuraState(m_spellInfo->TargetAuraStateNot), m_spellInfo, m_caster))
+            return SPELL_FAILED_TARGET_AURASTATE;
+
+        if (m_spellInfo->targetAuraSpell && !target->HasAura(m_spellInfo->targetAuraSpell))
+            return SPELL_FAILED_TARGET_AURASTATE;
+
+        if (m_spellInfo->excludeTargetAuraSpell && target->HasAura(m_spellInfo->excludeTargetAuraSpell))
+            return SPELL_FAILED_TARGET_AURASTATE;
+
+        if (!m_IsTriggeredSpell && target == m_caster && m_spellInfo->AttributesEx & SPELL_ATTR_EX_CANT_TARGET_SELF)
+            return SPELL_FAILED_BAD_TARGETS;
+
+        bool non_caster_target = target != m_caster && !sSpellMgr.IsSpellWithCasterSourceTargetsOnly(m_spellInfo);
+
+        if (non_caster_target)
+        {
+            // target state requirements (apply to non-self only), to allow cast affects to self like Dirty Deeds
+            if (!m_IsTriggeredSpell && m_spellInfo->TargetAuraState && !target->HasAuraState(AuraState(m_spellInfo->TargetAuraState), m_spellInfo, m_caster))
+                return SPELL_FAILED_TARGET_AURASTATE;
+
+            // Not allow casting on flying player
+            if (target->hasUnitState(UNIT_STAT_UNATTACKABLE))
+                return SPELL_FAILED_BAD_TARGETS;
+
+            if (!m_IsTriggeredSpell && (target->HasAuraType(SPELL_AURA_MOD_STEALTH)
+                || target->m_invisibilityMask) && !m_caster->canSeeOrDetect(target, true))
+                return SPELL_FAILED_BAD_TARGETS;
+
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            {
+                // Do not allow to banish target tapped by someone not in caster's group
+                if (m_spellInfo->Mechanic == MECHANIC_BANISH)
+                    if (Creature *targetCreature = target->ToCreature())
+                        if (targetCreature->hasLootRecipient() && !targetCreature->isTappedBy(m_caster->ToPlayer()))
+                            return SPELL_FAILED_CANT_CAST_ON_TAPPED;
+
+                if (m_customAttr & SPELL_ATTR_CU_PICKPOCKET)
+                {
+                     if (target->GetTypeId() == TYPEID_PLAYER)
+                         return SPELL_FAILED_BAD_TARGETS;
+                     else if ((target->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) == 0)
+                         return SPELL_FAILED_TARGET_NO_POCKETS;
+                }
+
+                // Not allow disarm unarmed player
+                if (m_spellInfo->Mechanic == MECHANIC_DISARM)
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        Player *player = target->ToPlayer();
+                        if (!player->GetWeaponForAttack(BASE_ATTACK) || !player->IsUseEquipedWeapon(true))
+                            return SPELL_FAILED_TARGET_NO_WEAPONS;
+                    }
+                    else if (!target->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID))
+                        return SPELL_FAILED_TARGET_NO_WEAPONS;
+                }
+            }
+
+            if (!m_IsTriggeredSpell && VMAP::VMapFactory::checkSpellForLoS(m_spellInfo->Id) && !m_caster->IsWithinLOSInMap(target))
+                return SPELL_FAILED_LINE_OF_SIGHT;
+
+        }
+        else if (m_caster == target)
+        {
+            if (m_caster->GetTypeId() == TYPEID_PLAYER) // Target - is player caster
+            {
+                // Additional check for some spells
+                // If 0 spell effect empty - client not send target data (need use selection)
+                // TODO: check it on next client version
+                if (m_targets.getTargetMask() == TARGET_FLAG_SELF &&
+                    m_spellInfo->EffectImplicitTargetA[1] == TARGET_UNIT_TARGET_ENEMY)
+                {
+                    target = m_caster->GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
+                    if (target)
+                        m_targets.setUnitTarget(target);
+                    else
+                        return SPELL_FAILED_BAD_TARGETS;
+                }
+                // Lay on Hands - cannot be self-cast on paladin with Forbearance or after using Avenging Wrath
+                if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN && m_spellInfo->SpellFamilyFlags[0] & 0x0008000)
+                    if (target->HasAura(61988)) // Immunity shield marker
+                        return SPELL_FAILED_TARGET_AURASTATE;
+            }
+        }
+
+        // check pet presents
+        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            if (m_spellInfo->EffectImplicitTargetA[j] == TARGET_UNIT_PET)
+            {
+                target = m_caster->GetGuardianPet();
+                if (!target)
+                {
+                    if (m_triggeredByAuraSpell)              // not report pet not existence for triggered spells
+                        return SPELL_FAILED_DONT_REPORT;
+                    else
+                        return SPELL_FAILED_NO_PET;
+                }
+                break;
+            }
+        }
+
+        //check creature type
+        //ignore self casts (including area casts when caster selected as target)
+        if (non_caster_target)
+        {
+            if (!CheckTargetCreatureType(target))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                    return SPELL_FAILED_TARGET_IS_PLAYER;
+                else
+                    return SPELL_FAILED_BAD_TARGETS;
+            }
+        }
+
+        // who can give me an example to show what is the use of this
+        // even if we need check, check by effect rather than whole spell, otherwise 57108,57143 are broken
+        /*
+        // TODO: this check can be applied and for player to prevent cheating when IsPositiveSpell will return always correct result.
+        // check target for pet/charmed casts (not self targeted), self targeted cast used for area effects and etc
+        if (non_caster_target && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->GetCharmerOrOwnerGUID())
+        {
+            // check correctness positive/negative cast target (pet cast real check and cheating check)
+            if (IsPositiveSpell(m_spellInfo->Id))
+            {
+                                                     //dispel positivity is dependant on target, don't check it
+                if (m_caster->IsHostileTo(target) && !IsDispel(m_spellInfo))
+                    return SPELL_FAILED_BAD_TARGETS;
+            }
+            else
+            {
+                if (m_caster->IsFriendlyTo(target))
+                    return SPELL_FAILED_BAD_TARGETS;
+            }
+        }
+        */
+
+        if (target)
+            if (IsPositiveSpell(m_spellInfo->Id))
+                if (target->IsImmunedToSpell(m_spellInfo))
+                    return SPELL_FAILED_TARGET_AURASTATE;
+
+        //Must be behind the target.
+        if (m_spellInfo->AttributesEx2 == SPELL_ATTR_EX2_UNK20 && m_spellInfo->AttributesEx & SPELL_ATTR_EX_UNK9 && target->HasInArc(static_cast<float>(M_PI), m_caster)
+            //Exclusion for Pounce: Facing Limitation was removed in 2.0.1, but it still uses the same, old Ex-Flags
+            && (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags.IsEqual(0x20000,0,0)))
+            //Mutilate no longer requires you be behind the target as of patch 3.0.3
+            && (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && m_spellInfo->SpellFamilyFlags[1] & 0x200000))
+            //Exclusion for Throw: Facing limitation was added in 3.2.x, but that shouldn't be
+            && (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && m_spellInfo->SpellFamilyFlags[0] & 0x00000001)))
+        {
+            SendInterrupted(2);
+            return SPELL_FAILED_NOT_BEHIND;
+        }
+
+        //Target must be facing you.
+        if ((m_spellInfo->Attributes == (SPELL_ATTR_UNK4 | SPELL_ATTR_NOT_SHAPESHIFT | SPELL_ATTR_UNK18 | SPELL_ATTR_STOP_ATTACK_TARGET)) && !target->HasInArc(static_cast<float>(M_PI), m_caster))
+        {
+            SendInterrupted(2);
+            return SPELL_FAILED_NOT_INFRONT;
+        }
+
+        // check if target is in combat
+        if (non_caster_target && (m_spellInfo->AttributesEx & SPELL_ATTR_EX_NOT_IN_COMBAT_TARGET) && target->isInCombat())
+            return SPELL_FAILED_TARGET_AFFECTING_COMBAT;
+    }
+
+    // Spell casted only on battleground
+    if ((m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_BATTLEGROUND) &&  m_caster->GetTypeId() == TYPEID_PLAYER)
+        if (!m_caster->ToPlayer()->InBattleground())
+            return SPELL_FAILED_ONLY_BATTLEGROUNDS;
+
+    // do not allow spells to be cast in arenas
+    // - with greater than 10 min CD without SPELL_ATTR_EX4_USABLE_IN_ARENA flag
+    // - with SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA flag
+    if ((m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA) ||
+        (GetSpellRecoveryTime(m_spellInfo) > 10 * MINUTE * IN_MILLISECONDS && !(m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_USABLE_IN_ARENA)))
+        if (MapEntry const* mapEntry = sMapStore.LookupEntry(m_caster->GetMapId()))
+            if (mapEntry->IsBattleArena())
+                return SPELL_FAILED_NOT_IN_ARENA;
+
+    // zone check
+    if (m_caster->GetTypeId() == TYPEID_UNIT || !m_caster->ToPlayer()->isGameMaster())
+    {
+        uint32 zone, area;
+        m_caster->GetZoneAndAreaId(zone,area);
+
+        SpellCastResult locRes= sSpellMgr.GetSpellAllowedInLocationError(m_spellInfo,m_caster->GetMapId(),zone,area,
+            m_caster->GetTypeId() == TYPEID_PLAYER ? m_caster->ToPlayer() : NULL);
+        if (locRes != SPELL_CAST_OK)
+            return locRes;
+    }
+
+    // not let players cast spells at mount (and let do it to creatures)
+    if (m_caster->IsMounted() && m_caster->GetTypeId() == TYPEID_PLAYER && !m_IsTriggeredSpell &&
+        !IsPassiveSpell(m_spellInfo->Id) && !(m_spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_MOUNTED))
+    {
+        if (m_caster->isInFlight())
+            return SPELL_FAILED_NOT_ON_TAXI;
+        else
+            return SPELL_FAILED_NOT_MOUNTED;
+    }
+
+    // always (except passive spells) check items (focus object can be required for any type casts)
+    if (!IsPassiveSpell(m_spellInfo->Id))
+    {
+        SpellCastResult castResult = CheckItems();
+        if (castResult != SPELL_CAST_OK)
+            return castResult;
+    }
+
+    if (!m_IsTriggeredSpell)
+    {
+        SpellCastResult castResult = CheckRange(strict);
+        if (castResult != SPELL_CAST_OK)
+            return castResult;
+
+        castResult = CheckPower();
+        if (castResult != SPELL_CAST_OK)
+            return castResult;
+
+        castResult = CheckCasterAuras();
+        if (castResult != SPELL_CAST_OK)
+            return castResult;
+    }
+
+    for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
+    {
+        // for effects of spells that have only one target
+        switch(m_spellInfo->Effect[i])
+        {
+            case SPELL_EFFECT_DUMMY:
+            {
+                if (m_spellInfo->Id == 51582)          // Rocket Boots Engaged
+                {
+                    if (m_caster->IsInWater())
+                        return SPELL_FAILED_ONLY_ABOVEWATER;
+                }
+				else if (m_spellInfo->Id == 72202) //Blood Link
+				{
+				    Creature* saurfang = m_caster->FindNearestCreature(37813, 500.0f, true);
+					if(saurfang && saurfang->isAlive())
+					    saurfang->CastSpell(saurfang, 72195, true);
+				}
+                else if (m_spellInfo->SpellIconID == 156)    // Holy Shock
+                {
+                    // spell different for friends and enemies
+                    // hurt version required facing
+                    if (m_targets.getUnitTarget() && !m_caster->IsFriendlyTo(m_targets.getUnitTarget()) && !m_caster->HasInArc(static_cast<float>(M_PI), m_targets.getUnitTarget()))
+                        return SPELL_FAILED_UNIT_NOT_INFRONT;
+                }
+                else if (m_spellInfo->SpellIconID == 33 && m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_FIRE_NOVA)
+                {
+                    if (!m_caster->m_SummonSlot[1])
+                        return SPELL_FAILED_SUCCESS;
+                }
+                else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] == 0x2000) // Death Coil (DeathKnight)
+                {
+                    Unit* target = m_targets.getUnitTarget();
+                    if (!target || (target->IsFriendlyTo(m_caster) && target->GetCreatureType() != CREATURE_TYPE_UNDEAD))
+                        return SPELL_FAILED_BAD_TARGETS;
+                }
+                else if (m_spellInfo->Id == 19938)          // Awaken Peon
+                {
+                    Unit *unit = m_targets.getUnitTarget();
+                    if (!unit || !unit->HasAura(17743))
+                        return SPELL_FAILED_BAD_TARGETS;
+                }
+                else if (m_spellInfo->Id == 52264)          // Deliver Stolen Horse
+                {
+                    if (!m_caster->FindNearestCreature(28653,5))
+                        return SPELL_FAILED_OUT_OF_RANGE;
+                }
+                else if (m_spellInfo->Id == 31789)          // Righteous Defense
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return SPELL_FAILED_DONT_REPORT;
+
+                    Unit* target = m_targets.getUnitTarget();
+                    if (!target || !target->IsFriendlyTo(m_caster) || target->getAttackers().empty())
+                        return SPELL_FAILED_BAD_TARGETS;
+
+                }
+                break;
+            }
+            case SPELL_EFFECT_LEARN_SPELL:
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                if (m_spellInfo->EffectImplicitTargetA[i] != TARGET_UNIT_PET)
+                    break;
+
+                Pet* pet = m_caster->ToPlayer()->GetPet();
+
+                if (!pet)
+                    return SPELL_FAILED_NO_PET;
+
+                SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[i]);
+
+                if (!learn_spellproto)
+                    return SPELL_FAILED_NOT_KNOWN;
+
+                if (m_spellInfo->spellLevel > pet->getLevel())
+                    return SPELL_FAILED_LOWLEVEL;
+
+                break;
+            }
+            case SPELL_EFFECT_LEARN_PET_SPELL:
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                Pet* pet = m_caster->ToPlayer()->GetPet();
+                if (!pet)
+                    return SPELL_FAILED_NO_PET;
+
+                SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[i]);
+
+                if (!learn_spellproto)
+                    return SPELL_FAILED_NOT_KNOWN;
+
+                if (m_spellInfo->spellLevel > pet->getLevel())
+                    return SPELL_FAILED_LOWLEVEL;
+
+                break;
+            }
+            case SPELL_EFFECT_APPLY_GLYPH:
+            {
+                uint32 glyphId = m_spellInfo->EffectMiscValue[i];
+                if (GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(glyphId))
+                    if (m_caster->HasAura(gp->SpellId))
+                        return SPELL_FAILED_UNIQUE_GLYPH;
+                break;
+            }
+            case SPELL_EFFECT_FEED_PET:
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                Item* foodItem = m_targets.getItemTarget();
+                if (!foodItem)
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                Pet* pet = m_caster->ToPlayer()->GetPet();
+
+                if (!pet)
+                    return SPELL_FAILED_NO_PET;
+
+                if (!pet->HaveInDiet(foodItem->GetProto()))
+                    return SPELL_FAILED_WRONG_PET_FOOD;
+
+                if (!pet->GetCurrentFoodBenefitLevel(foodItem->GetProto()->ItemLevel))
+                    return SPELL_FAILED_FOOD_LOWLEVEL;
+
+                if (m_caster->isInCombat() || pet->isInCombat())
+                    return SPELL_FAILED_AFFECTING_COMBAT;
+
+                break;
+            }
+            case SPELL_EFFECT_POWER_BURN:
+            case SPELL_EFFECT_POWER_DRAIN:
+            {
+                // Can be area effect, Check only for players and not check if target - caster (spell can have multiply drain/burn effects)
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    if (Unit* target = m_targets.getUnitTarget())
+                        if (target != m_caster && target->getPowerType() != Powers(m_spellInfo->EffectMiscValue[i]))
+                            return SPELL_FAILED_BAD_TARGETS;
+                break;
+            }
+            case SPELL_EFFECT_CHARGE:
+            {
+                if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARRIOR)
+                {
+                    // Warbringer - can't be handled in proc system - should be done before checkcast root check and charge effect process
+                    if (strict && m_caster->IsScriptOverriden(m_spellInfo, 6953))
+                        m_caster->RemoveMovementImpairingAuras();
+                }
+                if (m_caster->hasUnitState(UNIT_STAT_ROOT))
+                    return SPELL_FAILED_ROOTED;
+                break;
+            }
+            case SPELL_EFFECT_SKINNING:
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER || !m_targets.getUnitTarget() || m_targets.getUnitTarget()->GetTypeId() != TYPEID_UNIT)
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                if (!(m_targets.getUnitTarget()->GetUInt32Value(UNIT_FIELD_FLAGS) & UNIT_FLAG_SKINNABLE))
+                    return SPELL_FAILED_TARGET_UNSKINNABLE;
+
+                Creature* creature = m_targets.getUnitTarget()->ToCreature();
+                if (creature->GetCreatureType() != CREATURE_TYPE_CRITTER && !creature->loot.isLooted())
+                    return SPELL_FAILED_TARGET_NOT_LOOTED;
+
+                uint32 skill = creature->GetCreatureInfo()->GetRequiredLootSkill();
+
+                int32 skillValue = m_caster->ToPlayer()->GetSkillValue(skill);
+                int32 TargetLevel = m_targets.getUnitTarget()->getLevel();
+                int32 ReqValue = (skillValue < 100 ? (TargetLevel-10) * 10 : TargetLevel * 5);
+                if (ReqValue > skillValue)
+                    return SPELL_FAILED_LOW_CASTLEVEL;
+
+                // chance for fail at orange skinning attempt
+                if ((m_selfContainer && (*m_selfContainer) == this) &&
+                    skillValue < sWorld.GetConfigMaxSkillValue() &&
+                    (ReqValue < 0 ? 0 : ReqValue) > irand(skillValue - 25, skillValue + 37))
+                    return SPELL_FAILED_TRY_AGAIN;
+
+                break;
+            }
+            case SPELL_EFFECT_OPEN_LOCK:
+            {
+                if (m_spellInfo->EffectImplicitTargetA[i] != TARGET_GAMEOBJECT &&
+                    m_spellInfo->EffectImplicitTargetA[i] != TARGET_GAMEOBJECT_ITEM)
+                    break;
+
+                if (m_caster->GetTypeId() != TYPEID_PLAYER  // only players can open locks, gather etc.
+                    // we need a go target in case of TARGET_GAMEOBJECT
+                    || (m_spellInfo->EffectImplicitTargetA[i] == TARGET_GAMEOBJECT && !m_targets.getGOTarget()))
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                Item *pTempItem = NULL;
+                if (m_targets.getTargetMask() & TARGET_FLAG_TRADE_ITEM)
+                {
+                    if (TradeData* pTrade = m_caster->ToPlayer()->GetTradeData())
+                        pTempItem = pTrade->GetTraderData()->GetItem(TradeSlots(m_targets.getItemTargetGUID()));
+                }
+                else if (m_targets.getTargetMask() & TARGET_FLAG_ITEM)
+                    pTempItem = m_caster->ToPlayer()->GetItemByGuid(m_targets.getItemTargetGUID());
+
+                // we need a go target, or an openable item target in case of TARGET_GAMEOBJECT_ITEM
+                if (m_spellInfo->EffectImplicitTargetA[i] == TARGET_GAMEOBJECT_ITEM &&
+                    !m_targets.getGOTarget() &&
+                    (!pTempItem || !pTempItem->GetProto()->LockID || !pTempItem->IsLocked()))
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                if (m_spellInfo->Id != 1842 || (m_targets.getGOTarget() &&
+                    m_targets.getGOTarget()->GetGOInfo()->type != GAMEOBJECT_TYPE_TRAP))
+                    if (m_caster->ToPlayer()->InBattleground() && // In Battleground players can use only flags and banners
+                        !m_caster->ToPlayer()->CanUseBattlegroundObject())
+                        return SPELL_FAILED_TRY_AGAIN;
+
+                // get the lock entry
+                uint32 lockId = 0;
+                if (GameObject* go = m_targets.getGOTarget())
+                {
+                    lockId = go->GetGOInfo()->GetLockId();
+                    if (!lockId)
+                        return SPELL_FAILED_BAD_TARGETS;
+                }
+                else if (Item* itm = m_targets.getItemTarget())
+                    lockId = itm->GetProto()->LockID;
+
+                SkillType skillId = SKILL_NONE;
+                int32 reqSkillValue = 0;
+                int32 skillValue = 0;
+
+                // check lock compatibility
+                SpellCastResult res = CanOpenLock(i, lockId, skillId, reqSkillValue, skillValue);
+                if (res != SPELL_CAST_OK)
+                    return res;
+
+                // chance for fail at orange mining/herb/LockPicking gathering attempt
+                // second check prevent fail at rechecks
+                if (skillId != SKILL_NONE && (!m_selfContainer || ((*m_selfContainer) != this)))
+                {
+                    bool canFailAtMax = skillId != SKILL_HERBALISM && skillId != SKILL_MINING;
+
+                    // chance for failure in orange gather / lockpick (gathering skill can't fail at maxskill)
+                    if ((canFailAtMax || skillValue < sWorld.GetConfigMaxSkillValue()) && reqSkillValue > irand(skillValue - 25, skillValue + 37))
+                        return SPELL_FAILED_TRY_AGAIN;
+                }
+                break;
+            }
+            case SPELL_EFFECT_SUMMON_DEAD_PET:
+            {
+                Creature *pet = m_caster->GetGuardianPet();
+                if (!pet)
+                    return SPELL_FAILED_NO_PET;
+
+                if (pet->isAlive())
+                    return SPELL_FAILED_ALREADY_HAVE_SUMMON;
+
+                break;
+            }
+            // This is generic summon effect
+            case SPELL_EFFECT_SUMMON:
+            {
+                SummonPropertiesEntry const *SummonProperties = sSummonPropertiesStore.LookupEntry(m_spellInfo->EffectMiscValueB[i]);
+                if (!SummonProperties)
+                    break;
+                switch(SummonProperties->Category)
+                {
+                    case SUMMON_CATEGORY_PET:
+                        if (m_caster->GetPetGUID())
+                            return SPELL_FAILED_ALREADY_HAVE_SUMMON;
+                    case SUMMON_CATEGORY_PUPPET:
+                        if (m_caster->GetCharmGUID())
+                            return SPELL_FAILED_ALREADY_HAVE_CHARM;
+                        break;
+                }
+                break;
+            }
+            case SPELL_EFFECT_CREATE_TAMED_PET:
+            {
+                if (m_targets.getUnitTarget())
+                {
+                    if (m_targets.getUnitTarget()->GetTypeId() != TYPEID_PLAYER)
+                        return SPELL_FAILED_BAD_TARGETS;
+                    if (m_targets.getUnitTarget()->GetPetGUID())
+                        return SPELL_FAILED_ALREADY_HAVE_SUMMON;
+                }
+                break;
+            }
+            case SPELL_EFFECT_SUMMON_PET:
+            {
+                if (m_caster->GetPetGUID())                  //let warlock do a replacement summon
+                {
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->getClass() == CLASS_WARLOCK)
+                    {
+                        if (strict)                         //starting cast, trigger pet stun (cast by pet so it doesn't attack player)
+                            if (Pet* pet = m_caster->ToPlayer()->GetPet())
+                                pet->CastSpell(pet, 32752, true, NULL, NULL, pet->GetGUID());
+                    }
+                    else
+                        return SPELL_FAILED_ALREADY_HAVE_SUMMON;
+                }
+
+                if (m_caster->GetCharmGUID())
+                    return SPELL_FAILED_ALREADY_HAVE_CHARM;
+
+                break;
+            }
+            case SPELL_EFFECT_SUMMON_PLAYER:
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return SPELL_FAILED_BAD_TARGETS;
+                if (!m_caster->ToPlayer()->GetSelection())
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                Player* target = sObjectMgr.GetPlayer(m_caster->ToPlayer()->GetSelection());
+                if (!target || m_caster->ToPlayer() == target || !target->IsInSameRaidWith(m_caster->ToPlayer()))
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                // check if our map is dungeon
+                if (sMapStore.LookupEntry(m_caster->GetMapId())->IsDungeon())
+                {
+                    Map const* pMap = m_caster->GetMap();
+                    InstanceTemplate const* instance = ObjectMgr::GetInstanceTemplate(pMap->GetId());
+                    if (!instance)
+                        return SPELL_FAILED_TARGET_NOT_IN_INSTANCE;
+                    if (!target->Satisfy(sObjectMgr.GetAccessRequirement(pMap->GetId(), pMap->GetDifficulty()), pMap->GetId()))
+                        return SPELL_FAILED_BAD_TARGETS;
+                }
+                break;
+            }
+            case SPELL_EFFECT_LEAP:
+            case SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER:
+            {
+              //Do not allow to cast it before BG starts.
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    if (Battleground const *bg = m_caster->ToPlayer()->GetBattleground())
+                        if (bg->GetStatus() != STATUS_IN_PROGRESS)
+                            return SPELL_FAILED_TRY_AGAIN;
+                break;
+            }
+            case SPELL_EFFECT_STEAL_BENEFICIAL_BUFF:
+            {
+                if (m_targets.getUnitTarget() == m_caster)
+                    return SPELL_FAILED_BAD_TARGETS;
+                break;
+            }
+            case SPELL_EFFECT_LEAP_BACK:
+            {
+                // Spell 781 (Disengage) requires player to be in combat
+                if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->Id == 781 && !m_caster->isInCombat())
+                    return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+
+                Unit* target = m_targets.getUnitTarget();
+                if (m_caster == target && m_caster->hasUnitState(UNIT_STAT_ROOT))
+                {
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                        return SPELL_FAILED_ROOTED;
+                    else
+                        return SPELL_FAILED_DONT_REPORT;
+                }
+                break;
+            }
+            default:
+                break;
+        }
+    }
+
+    for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
+    {
+        switch(m_spellInfo->EffectApplyAuraName[i])
+        {
+            case SPELL_AURA_DUMMY:
+            {
+                //custom check
+                switch(m_spellInfo->Id)
+                {
+                    // Tag Murloc
+                    case 30877:
+                    {
+                        Unit* target = m_targets.getUnitTarget();
+                        if (!target || target->GetEntry() != 17326)
+                            return SPELL_FAILED_BAD_TARGETS;
+                        break;
+                    }
+                    case 61336:
+                        if (m_caster->GetTypeId() != TYPEID_PLAYER || !m_caster->ToPlayer()->IsInFeralForm())
+                            return SPELL_FAILED_ONLY_SHAPESHIFT;
+                        break;
+                    case 1515:
+                    {
+                        if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                            return SPELL_FAILED_BAD_TARGETS;
+
+                        if (!m_targets.getUnitTarget() || m_targets.getUnitTarget()->GetTypeId() == TYPEID_PLAYER)
+                            return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
+
+                        Creature* target = m_targets.getUnitTarget()->ToCreature();
+
+                        if (target->getLevel() > m_caster->getLevel())
+                            return SPELL_FAILED_HIGHLEVEL;
+
+                        // use SMSG_PET_TAME_FAILURE?
+                        if (!target->GetCreatureInfo()->isTameable (m_caster->ToPlayer()->CanTameExoticPets()))
+                            return SPELL_FAILED_BAD_TARGETS;
+
+                        if (m_caster->GetPetGUID())
+                            return SPELL_FAILED_ALREADY_HAVE_SUMMON;
+
+                        if (m_caster->GetCharmGUID())
+                            return SPELL_FAILED_ALREADY_HAVE_CHARM;
+
+                        break;
+                    }
+                    case 44795: // Parachute
+                    {
+                        float x, y, z;
+                        m_caster->GetPosition(x, y, z);
+                        float ground_Z = m_caster->GetMap()->GetHeight(x, y, z);
+                        if (fabs(ground_Z - z) < 0.1f)
+                            return SPELL_FAILED_DONT_REPORT;
+                        break;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            case SPELL_AURA_MOD_POSSESS_PET:
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return SPELL_FAILED_NO_PET;
+
+                Pet *pet = m_caster->ToPlayer()->GetPet();
+                if (!pet)
+                    return SPELL_FAILED_NO_PET;
+
+                if (pet->GetCharmerGUID())
+                    return SPELL_FAILED_CHARMED;
+                break;
+            }
+            case SPELL_AURA_MOD_POSSESS:
+            case SPELL_AURA_MOD_CHARM:
+            case SPELL_AURA_AOE_CHARM:
+            {
+                if (m_caster->GetCharmerGUID())
+                    return SPELL_FAILED_CHARMED;
+
+                if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_CHARM
+                    || m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_POSSESS)
+                {
+                    if (m_caster->GetPetGUID())
+                        return SPELL_FAILED_ALREADY_HAVE_SUMMON;
+
+                    if (m_caster->GetCharmGUID())
+                        return SPELL_FAILED_ALREADY_HAVE_CHARM;
+                }
+
+                if (Unit *target = m_targets.getUnitTarget())
+                {
+                    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsVehicle())
+                        return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
+
+                    if (target->IsMounted())
+                        return SPELL_FAILED_CANT_BE_CHARMED;
+
+                    if (target->GetCharmerGUID())
+                        return SPELL_FAILED_CHARMED;
+
+                    int32 damage = CalculateDamage(i, target);
+                    if (damage && int32(target->getLevel()) > damage)
+                        return SPELL_FAILED_HIGHLEVEL;
+                }
+
+                break;
+            }
+            case SPELL_AURA_MOUNTED:
+            {
+                if (m_caster->IsInWater())
+                    return SPELL_FAILED_ONLY_ABOVEWATER;
+
+                // Ignore map check if spell have AreaId. AreaId already checked and this prevent special mount spells
+                bool AllowMount = !m_caster->GetMap()->IsDungeon() || m_caster->GetMap()->IsBattlegroundOrArena();
+                InstanceTemplate const *it = sObjectMgr.GetInstanceTemplate(m_caster->GetMapId());
+                if (it)
+                    AllowMount = it->allowMount;
+                if (m_caster->GetTypeId() == TYPEID_PLAYER && !AllowMount && !m_IsTriggeredSpell && !m_spellInfo->AreaGroupId)
+                    return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+
+                ShapeshiftForm form = m_caster->m_form;
+                if (form == FORM_CAT          || form == FORM_TREE      || form == FORM_TRAVEL   ||
+                    form == FORM_AQUA         || form == FORM_BEAR      || form == FORM_DIREBEAR ||
+                    form == FORM_CREATUREBEAR || form == FORM_GHOSTWOLF || form == FORM_FLIGHT   ||
+                    form == FORM_FLIGHT_EPIC  || form == FORM_MOONKIN   || form == FORM_METAMORPHOSIS)
+                    return SPELL_FAILED_NOT_SHAPESHIFT;
+
+                break;
+            }
+            case SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS:
+            {
+                if (!m_targets.getUnitTarget())
+                    return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
+
+                // can be casted at non-friendly unit or own pet/charm
+                if (m_caster->IsFriendlyTo(m_targets.getUnitTarget()))
+                    return SPELL_FAILED_TARGET_FRIENDLY;
+
+                break;
+            }
+            case SPELL_AURA_FLY:
+            case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
+            {
+                // not allow cast fly spells if not have req. skills  (all spells is self target)
+                // allow always ghost flight spells
+                if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
+                {
+                    if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
+                    {
+                        if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                            return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        // Wintergrasp Antifly check
+                        if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                        {
+                          if (m_originalCaster->GetZoneId() == 4197 && pvpWG && pvpWG != 0  && pvpWG->isWarTime()==true)
+                          return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELL_AURA_PERIODIC_MANA_LEECH:
+            {
+                if (!m_targets.getUnitTarget())
+                    return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
+
+                if (m_caster->GetTypeId() != TYPEID_PLAYER || m_CastItem)
+                    break;
+
+                if (m_targets.getUnitTarget()->getPowerType() != POWER_MANA)
+                    return SPELL_FAILED_BAD_TARGETS;
+
+                break;
+            }
+            default:
+                break;
+        }
+    }
+
+    // check trade slot case (last, for allow catch any another cast problems)
+    if (m_targets.getTargetMask() & TARGET_FLAG_TRADE_ITEM)
+    {
+        if (m_caster->GetTypeId() != TYPEID_PLAYER)
+            return SPELL_FAILED_NOT_TRADING;
+
+        TradeData* my_trade = m_caster->ToPlayer()->GetTradeData();
+
+        if (!my_trade)
+            return SPELL_FAILED_NOT_TRADING;
+
+        TradeSlots slot = TradeSlots(m_targets.getItemTargetGUID());
+        if (slot != TRADE_SLOT_NONTRADED)
+            return SPELL_FAILED_BAD_TARGETS;
+
+        if (!m_IsTriggeredSpell)
+            if (my_trade->GetSpell())
+                return SPELL_FAILED_ITEM_ALREADY_ENCHANTED;
+    }
+
+    // check if caster has at least 1 combo point for spells that require combo points
+    if (m_needComboPoints)
+        if (Player* plrCaster = m_caster->ToPlayer())
+            if (!plrCaster->GetComboPoints())
+                return SPELL_FAILED_NO_COMBO_POINTS;
+
+    // all ok
+    return SPELL_CAST_OK;
+}
+
+SpellCastResult Spell::CheckPetCast(Unit* target)
+{
+    if (!m_caster->isAlive() && !(m_spellInfo->Attributes & SPELL_ATTR_CASTABLE_WHILE_DEAD))
+        return SPELL_FAILED_CASTER_DEAD;
+
+    if (m_caster->hasUnitState(UNIT_STAT_CASTING) && !m_IsTriggeredSpell)              //prevent spellcast interruption by another spellcast
+        return SPELL_FAILED_SPELL_IN_PROGRESS;
+    if (m_caster->isInCombat() && IsNonCombatSpell(m_spellInfo))
+        return SPELL_FAILED_AFFECTING_COMBAT;
+
+                                                            //dead owner (pets still alive when owners ressed?)
+        if (Unit *owner = m_caster->GetCharmerOrOwner())
+            if (!owner->isAlive())
+                return SPELL_FAILED_CASTER_DEAD;
+
+        if (!target && m_targets.getUnitTarget())
+            target = m_targets.getUnitTarget();
+
+        for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (SpellTargetType[m_spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET
+                || SpellTargetType[m_spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_DEST_TARGET)
+            {
+                if (!target)
+                    return SPELL_FAILED_BAD_IMPLICIT_TARGETS;
+                m_targets.setUnitTarget(target);
+                break;
+            }
+        }
+
+        Unit* _target = m_targets.getUnitTarget();
+
+        if (_target)                                         //for target dead/target not valid
+        {
+            if (!_target->isAlive())
+                return SPELL_FAILED_BAD_TARGETS;
+
+            if (!IsValidSingleTargetSpell(_target))
+                return SPELL_FAILED_BAD_TARGETS;
+        }
+                                                            //cooldown
+        if (m_caster->ToCreature()->HasSpellCooldown(m_spellInfo->Id))
+            return SPELL_FAILED_NOT_READY;
+
+    return CheckCast(true);
+}
+
+SpellCastResult Spell::CheckCasterAuras() const
+{
+    // spells totally immuned to caster auras (wsg flag drop, give marks etc)
+    if (m_spellInfo->AttributesEx6& SPELL_ATTR_EX6_IGNORE_CASTER_AURAS)
+        return SPELL_CAST_OK;
+
+    uint8 school_immune = 0;
+    uint32 mechanic_immune = 0;
+    uint32 dispel_immune = 0;
+
+    // Check if the spell grants school or mechanic immunity.
+    // We use bitmasks so the loop is done only once and not on every aura check below.
+    if (m_spellInfo->AttributesEx & SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY)
+    {
+        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_SCHOOL_IMMUNITY)
+                school_immune |= uint32(m_spellInfo->EffectMiscValue[i]);
+            else if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MECHANIC_IMMUNITY)
+                mechanic_immune |= 1 << uint32(m_spellInfo->EffectMiscValue[i]);
+            else if (m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_DISPEL_IMMUNITY)
+                dispel_immune |= GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[i]));
+        }
+        // immune movement impairment and loss of control
+        if (m_spellInfo->Id == 42292 || m_spellInfo->Id == 59752)
+            mechanic_immune = IMMUNE_TO_MOVEMENT_IMPAIRMENT_AND_LOSS_CONTROL_MASK;
+    }
+
+    // Check whether the cast should be prevented by any state you might have.
+    SpellCastResult prevented_reason = SPELL_CAST_OK;
+    // Have to check if there is a stun aura. Otherwise will have problems with ghost aura apply while logging out
+    uint32 unitflag = m_caster->GetUInt32Value(UNIT_FIELD_FLAGS);     // Get unit state
+    if (unitflag & UNIT_FLAG_STUNNED && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_STUNNED))
+        prevented_reason = SPELL_FAILED_STUNNED;
+    else if (unitflag & UNIT_FLAG_CONFUSED && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_CONFUSED))
+        prevented_reason = SPELL_FAILED_CONFUSED;
+    else if (unitflag & UNIT_FLAG_FLEEING && !(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_FEARED))
+        prevented_reason = SPELL_FAILED_FLEEING;
+    else if (unitflag & UNIT_FLAG_SILENCED && m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+        prevented_reason = SPELL_FAILED_SILENCED;
+    else if (unitflag & UNIT_FLAG_PACIFIED && m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_PACIFY)
+        prevented_reason = SPELL_FAILED_PACIFIED;
+
+    // Attr must make flag drop spell totally immune from all effects
+    if (prevented_reason != SPELL_CAST_OK)
+    {
+        if (school_immune || mechanic_immune || dispel_immune)
+        {
+            //Checking auras is needed now, because you are prevented by some state but the spell grants immunity.
+            Unit::AuraApplicationMap const& auras = m_caster->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+            {
+                Aura const * aura = itr->second->GetBase();
+                if (GetAllSpellMechanicMask(aura->GetSpellProto()) & mechanic_immune)
+                    continue;
+                if (GetSpellSchoolMask(aura->GetSpellProto()) & school_immune)
+                    continue;
+                if ((1<<(aura->GetSpellProto()->Dispel)) & dispel_immune)
+                    continue;
+
+                //Make a second check for spell failed so the right SPELL_FAILED message is returned.
+                //That is needed when your casting is prevented by multiple states and you are only immune to some of them.
+                for (uint8 i=0; i<MAX_SPELL_EFFECTS; ++i)
+                {
+                    if (AuraEffect * part = aura->GetEffect(i))
+                    {
+                        switch(part->GetAuraType())
+                        {
+                            case SPELL_AURA_MOD_STUN:
+                                if (!(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_STUNNED))
+                                    return SPELL_FAILED_STUNNED;
+                                break;
+                            case SPELL_AURA_MOD_CONFUSE:
+                                if (!(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_CONFUSED))
+                                    return SPELL_FAILED_CONFUSED;
+                                break;
+                            case SPELL_AURA_MOD_FEAR:
+                                if (!(m_spellInfo->AttributesEx5 & SPELL_ATTR_EX5_USABLE_WHILE_FEARED))
+                                    return SPELL_FAILED_FLEEING;
+                                break;
+                            case SPELL_AURA_MOD_SILENCE:
+                            case SPELL_AURA_MOD_PACIFY:
+                            case SPELL_AURA_MOD_PACIFY_SILENCE:
+                                if (m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_PACIFY)
+                                    return SPELL_FAILED_PACIFIED;
+                                else if (m_spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+                                    return SPELL_FAILED_SILENCED;
+                                break;
+                            default: break;
+                        }
+                    }
+                }
+            }
+        }
+        // You are prevented from casting and the spell casted does not grant immunity. Return a failed error.
+        else
+            return prevented_reason;
+    }
+    return SPELL_CAST_OK;
+}
+
+bool Spell::CanAutoCast(Unit* target)
+{
+    uint64 targetguid = target->GetGUID();
+
+    for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        if (m_spellInfo->Effect[j] == SPELL_EFFECT_APPLY_AURA)
+        {
+            if (m_spellInfo->StackAmount <= 1)
+            {
+                if (target->HasAuraEffect(m_spellInfo->Id, j))
+                    return false;
+            }
+            else
+            {
+                if (AuraEffect * aureff = target->GetAuraEffect(m_spellInfo->Id, j))
+                    if (aureff->GetBase()->GetStackAmount() >= m_spellInfo->StackAmount)
+                        return false;
+            }
+        }
+        else if (IsAreaAuraEffect(m_spellInfo->Effect[j]))
+        {
+            if (target->HasAuraEffect(m_spellInfo->Id, j))
+                return false;
+        }
+    }
+
+    SpellCastResult result = CheckPetCast(target);
+
+    if (result == SPELL_CAST_OK || result == SPELL_FAILED_UNIT_NOT_INFRONT)
+    {
+        SelectSpellTargets();
+        //check if among target units, our WANTED target is as well (->only self cast spells return false)
+        for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+            if (ihit->targetGUID == targetguid)
+                return true;
+    }
+    return false;                                           //target invalid
+}
+
+SpellCastResult Spell::CheckRange(bool strict)
+{
+    // self cast doesn't need range checking -- also for Starshards fix
+    if (m_spellInfo->rangeIndex == 1)
+        return SPELL_CAST_OK;
+
+    // Don't check for instant cast spells
+    if (!strict && m_casttime == 0)
+        return SPELL_CAST_OK;
+
+    SpellRangeEntry const* srange = sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex);
+
+    Unit *target = m_targets.getUnitTarget();
+    float max_range = (float)m_caster->GetSpellMaxRangeForTarget(target, srange);
+    float min_range = (float)m_caster->GetSpellMinRangeForTarget(target, srange);
+    uint32 range_type = GetSpellRangeType(srange);
+
+    if (Player* modOwner = m_caster->GetSpellModOwner())
+        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, max_range, this);
+
+    if (target && target != m_caster)
+    {
+        if (range_type == SPELL_RANGE_MELEE)
+        {
+            // Because of lag, we can not check too strictly here.
+            if (!m_caster->IsWithinMeleeRange(target, max_range))
+                return SPELL_FAILED_OUT_OF_RANGE;
+        }
+        else if (!m_caster->IsWithinCombatRange(target, max_range))
+            return SPELL_FAILED_OUT_OF_RANGE;               //0x5A;
+
+        if (range_type == SPELL_RANGE_RANGED)
+        {
+            if (m_caster->IsWithinMeleeRange(target))
+                return SPELL_FAILED_TOO_CLOSE;
+        }
+        else if (min_range && m_caster->IsWithinCombatRange(target, min_range)) // skip this check if min_range = 0
+            return SPELL_FAILED_TOO_CLOSE;
+
+        if (m_caster->GetTypeId() == TYPEID_PLAYER &&
+            (m_spellInfo->FacingCasterFlags & SPELL_FACING_FLAG_INFRONT) && !m_caster->HasInArc(static_cast<float>(M_PI), target))
+            return SPELL_FAILED_UNIT_NOT_INFRONT;
+    }
+
+    if (m_targets.HasDst() && !m_targets.HasTraj())
+    {
+        if (!m_caster->IsWithinDist3d(&m_targets.m_dstPos, max_range))
+            return SPELL_FAILED_OUT_OF_RANGE;
+        if (min_range && m_caster->IsWithinDist3d(&m_targets.m_dstPos, min_range))
+            return SPELL_FAILED_TOO_CLOSE;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+SpellCastResult Spell::CheckPower()
+{
+    // item cast not used power
+    if (m_CastItem)
+        return SPELL_CAST_OK;
+
+    // health as power used - need check health amount
+    if (m_spellInfo->powerType == POWER_HEALTH)
+    {
+        if (int32(m_caster->GetHealth()) <= m_powerCost)
+            return SPELL_FAILED_CASTER_AURASTATE;
+        return SPELL_CAST_OK;
+    }
+    // Check valid power type
+    if (m_spellInfo->powerType >= MAX_POWERS)
+    {
+        sLog.outError("Spell::CheckPower: Unknown power type '%d'", m_spellInfo->powerType);
+        return SPELL_FAILED_UNKNOWN;
+    }
+
+    //check rune cost only if a spell has PowerType == POWER_RUNE
+    if (m_spellInfo->powerType == POWER_RUNE)
+    {
+        SpellCastResult failReason = CheckRuneCost(m_spellInfo->runeCostID);
+        if (failReason != SPELL_CAST_OK)
+            return failReason;
+    }
+
+    // Check power amount
+    Powers powerType = Powers(m_spellInfo->powerType);
+    if (int32(m_caster->GetPower(powerType)) < m_powerCost)
+        return SPELL_FAILED_NO_POWER;
+    else
+        return SPELL_CAST_OK;
+}
+
+SpellCastResult Spell::CheckItems()
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return SPELL_CAST_OK;
+
+    Player* p_caster = (Player*)m_caster;
+
+    if (!m_CastItem)
+    {
+        if (m_castItemGUID)
+            return SPELL_FAILED_ITEM_NOT_READY;
+    }
+    else
+    {
+        uint32 itemid = m_CastItem->GetEntry();
+        if (!p_caster->HasItemCount(itemid, 1))
+            return SPELL_FAILED_ITEM_NOT_READY;
+
+        ItemPrototype const *proto = m_CastItem->GetProto();
+        if (!proto)
+            return SPELL_FAILED_ITEM_NOT_READY;
+
+        for (int i = 0; i < MAX_ITEM_SPELLS; ++i)
+            if (proto->Spells[i].SpellCharges)
+                if (m_CastItem->GetSpellCharges(i) == 0)
+                    return SPELL_FAILED_NO_CHARGES_REMAIN;
+
+        // consumable cast item checks
+        if (proto->Class == ITEM_CLASS_CONSUMABLE && m_targets.getUnitTarget())
+        {
+            // such items should only fail if there is no suitable effect at all - see Rejuvenation Potions for example
+            SpellCastResult failReason = SPELL_CAST_OK;
+            for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
+            {
+                    // skip check, pet not required like checks, and for TARGET_UNIT_PET m_targets.getUnitTarget() is not the real target but the caster
+                    if (m_spellInfo->EffectImplicitTargetA[i] == TARGET_UNIT_PET)
+                    continue;
+
+                if (m_spellInfo->Effect[i] == SPELL_EFFECT_HEAL)
+                {
+                    if (m_targets.getUnitTarget()->IsFullHealth())
+                    {
+                        failReason = SPELL_FAILED_ALREADY_AT_FULL_HEALTH;
+                        continue;
+                    }
+                    else
+                    {
+                        failReason = SPELL_CAST_OK;
+                        break;
+                    }
+                }
+
+                // Mana Potion, Rage Potion, Thistle Tea(Rogue), ...
+                if (m_spellInfo->Effect[i] == SPELL_EFFECT_ENERGIZE)
+                {
+                    if (m_spellInfo->EffectMiscValue[i] < 0 || m_spellInfo->EffectMiscValue[i] >= int8(MAX_POWERS))
+                    {
+                        failReason = SPELL_FAILED_ALREADY_AT_FULL_POWER;
+                        continue;
+                    }
+
+                    Powers power = Powers(m_spellInfo->EffectMiscValue[i]);
+                    if (m_targets.getUnitTarget()->GetPower(power) == m_targets.getUnitTarget()->GetMaxPower(power))
+                    {
+                        failReason = SPELL_FAILED_ALREADY_AT_FULL_POWER;
+                        continue;
+                    }
+                    else
+                    {
+                        failReason = SPELL_CAST_OK;
+                        break;
+                    }
+                }
+            }
+            if (failReason != SPELL_CAST_OK)
+                return failReason;
+        }
+    }
+
+    // check target item
+    if (m_targets.getItemTargetGUID())
+    {
+        if (m_caster->GetTypeId() != TYPEID_PLAYER)
+            return SPELL_FAILED_BAD_TARGETS;
+
+        if (!m_targets.getItemTarget())
+            return SPELL_FAILED_ITEM_GONE;
+
+        if (!m_targets.getItemTarget()->IsFitToSpellRequirements(m_spellInfo))
+            return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+    }
+    // if not item target then required item must be equipped
+    else
+    {
+        if (m_caster->GetTypeId() == TYPEID_PLAYER && !m_caster->ToPlayer()->HasItemFitToSpellReqirements(m_spellInfo))
+            return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+    }
+
+    // check spell focus object
+    if (m_spellInfo->RequiresSpellFocus)
+    {
+        CellPair p(Trinity::ComputeCellPair(m_caster->GetPositionX(), m_caster->GetPositionY()));
+        Cell cell(p);
+        cell.data.Part.reserved = ALL_DISTRICT;
+
+        GameObject* ok = NULL;
+        Trinity::GameObjectFocusCheck go_check(m_caster,m_spellInfo->RequiresSpellFocus);
+        Trinity::GameObjectSearcher<Trinity::GameObjectFocusCheck> checker(m_caster, ok, go_check);
+
+        TypeContainerVisitor<Trinity::GameObjectSearcher<Trinity::GameObjectFocusCheck>, GridTypeMapContainer > object_checker(checker);
+        Map& map = *m_caster->GetMap();
+        cell.Visit(p, object_checker, map, *m_caster, map.GetVisibilityDistance());
+
+        if (!ok)
+            return SPELL_FAILED_REQUIRES_SPELL_FOCUS;
+
+        focusObject = ok;                                   // game object found in range
+    }
+
+    // do not take reagents for these item casts
+    if (!(m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST))
+    {
+        // check reagents (ignore triggered spells with reagents processed by original spell) and special reagent ignore case.
+        if (!m_IsTriggeredSpell && !p_caster->CanNoReagentCast(m_spellInfo))
+        {
+            for (uint32 i = 0; i < MAX_SPELL_REAGENTS; i++)
+            {
+                if (m_spellInfo->Reagent[i] <= 0)
+                    continue;
+
+                uint32 itemid    = m_spellInfo->Reagent[i];
+                uint32 itemcount = m_spellInfo->ReagentCount[i];
+
+                // if CastItem is also spell reagent
+                if (m_CastItem && m_CastItem->GetEntry() == itemid)
+                {
+                    ItemPrototype const *proto = m_CastItem->GetProto();
+                    if (!proto)
+                        return SPELL_FAILED_ITEM_NOT_READY;
+                    for (int s=0; s < MAX_ITEM_PROTO_SPELLS; ++s)
+                    {
+                        // CastItem will be used up and does not count as reagent
+                        int32 charges = m_CastItem->GetSpellCharges(s);
+                        if (proto->Spells[s].SpellCharges < 0 && abs(charges) < 2)
+                        {
+                            ++itemcount;
+                            break;
+                        }
+                    }
+                }
+                if (!p_caster->HasItemCount(itemid,itemcount))
+                    return SPELL_FAILED_ITEM_NOT_READY;         //0x54
+            }
+        }
+
+        // check totem-item requirements (items presence in inventory)
+        uint32 totems = 2;
+        for (int i = 0; i < 2 ; ++i)
+        {
+            if (m_spellInfo->Totem[i] != 0)
+            {
+                if (p_caster->HasItemCount(m_spellInfo->Totem[i],1))
+                {
+                    totems -= 1;
+                    continue;
+                }
+            }else
+            totems -= 1;
+        }
+        if (totems != 0)
+            return SPELL_FAILED_TOTEMS;                         //0x7C
+
+        // Check items for TotemCategory  (items presence in inventory)
+        uint32 TotemCategory = 2;
+        for (int i= 0; i < 2; ++i)
+        {
+            if (m_spellInfo->TotemCategory[i] != 0)
+            {
+                if (p_caster->HasItemTotemCategory(m_spellInfo->TotemCategory[i]))
+                {
+                    TotemCategory -= 1;
+                    continue;
+                }
+            }
+            else
+                TotemCategory -= 1;
+        }
+        if (TotemCategory != 0)
+            return SPELL_FAILED_TOTEM_CATEGORY;                 //0x7B
+    }
+
+    // special checks for spell effects
+    for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
+    {
+        switch (m_spellInfo->Effect[i])
+        {
+            case SPELL_EFFECT_CREATE_ITEM:
+            case SPELL_EFFECT_CREATE_ITEM_2:
+            {
+                if (!m_IsTriggeredSpell && m_spellInfo->EffectItemType[i])
+                {
+                    ItemPosCountVec dest;
+                    uint8 msg = p_caster->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, m_spellInfo->EffectItemType[i], 1);
+                    if (msg != EQUIP_ERR_OK)
+                    {
+                        ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(m_spellInfo->EffectItemType[i]);
+                        // TODO: Needs review
+                        if (pProto && !(pProto->ItemLimitCategory))
+                        {
+                            p_caster->SendEquipError(msg, NULL, NULL, m_spellInfo->EffectItemType[i]);
+                            return SPELL_FAILED_DONT_REPORT;
+                        }
+                        else
+                        {
+                            if (!(m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE && (m_spellInfo->SpellFamilyFlags[0] & 0x40000000)))
+                                return SPELL_FAILED_TOO_MANY_OF_ITEM;
+                            else if (!(p_caster->HasItemCount(m_spellInfo->EffectItemType[i],1)))
+                                return SPELL_FAILED_TOO_MANY_OF_ITEM;
+                            else
+                                p_caster->CastSpell(m_caster,SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1),false);        // move this to anywhere
+                            return SPELL_FAILED_DONT_REPORT;
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELL_EFFECT_ENCHANT_ITEM:
+                if (m_spellInfo->EffectItemType[i] && m_targets.getItemTarget()
+                    && (m_targets.getItemTarget()->IsWeaponVellum() || m_targets.getItemTarget()->IsArmorVellum()))
+                {
+                    // cannot enchant vellum for other player
+                    if (m_targets.getItemTarget()->GetOwner() != m_caster)
+                        return SPELL_FAILED_NOT_TRADEABLE;
+                    // do not allow to enchant vellum from scroll made by vellum-prevent exploit
+                    if (m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST)
+                        return SPELL_FAILED_TOTEM_CATEGORY;
+                    ItemPosCountVec dest;
+                    uint8 msg = p_caster->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, m_spellInfo->EffectItemType[i], 1);
+                    if (msg != EQUIP_ERR_OK)
+                    {
+                        p_caster->SendEquipError(msg, NULL, NULL, m_spellInfo->EffectItemType[i]);
+                        return SPELL_FAILED_DONT_REPORT;
+                    }
+                }
+            case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
+            {
+                Item* targetItem = m_targets.getItemTarget();
+                if (!targetItem)
+                    return SPELL_FAILED_ITEM_NOT_FOUND;
+
+                if (targetItem->GetProto()->ItemLevel < m_spellInfo->baseLevel)
+                    return SPELL_FAILED_LOWLEVEL;
+
+                bool isItemUsable = false;
+                for (uint8 e = 0; e < MAX_ITEM_PROTO_SPELLS; ++e)
+                {
+                    ItemPrototype const *proto = targetItem->GetProto();
+                    if (proto->Spells[e].SpellId && (
+                        proto->Spells[e].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE ||
+                        proto->Spells[e].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE))
+                    {
+                        isItemUsable = true;
+                        break;
+                    }
+                }
+
+                SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(m_spellInfo->EffectMiscValue[i]);
+                // do not allow adding usable enchantments to items that have use effect already
+                if (pEnchant && isItemUsable)
+                    for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+                        if (pEnchant->type[s] == ITEM_ENCHANTMENT_TYPE_USE_SPELL)
+                            return SPELL_FAILED_ON_USE_ENCHANT;
+
+                // Not allow enchant in trade slot for some enchant type
+                if (targetItem->GetOwner() != m_caster)
+                {
+                    if (!pEnchant)
+                        return SPELL_FAILED_ERROR;
+                    if (pEnchant->slot & ENCHANTMENT_CAN_SOULBOUND)
+                        return SPELL_FAILED_NOT_TRADEABLE;
+                }
+                break;
+            }
+            case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
+            {
+                Item *item = m_targets.getItemTarget();
+                if (!item)
+                    return SPELL_FAILED_ITEM_NOT_FOUND;
+                // Not allow enchant in trade slot for some enchant type
+                if (item->GetOwner() != m_caster)
+                {
+                    uint32 enchant_id = m_spellInfo->EffectMiscValue[i];
+                    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                    if (!pEnchant)
+                        return SPELL_FAILED_ERROR;
+                    if (pEnchant->slot & ENCHANTMENT_CAN_SOULBOUND)
+                        return SPELL_FAILED_NOT_TRADEABLE;
+                }
+                break;
+            }
+            case SPELL_EFFECT_ENCHANT_HELD_ITEM:
+                // check item existence in effect code (not output errors at offhand hold item effect to main hand for example
+                break;
+            case SPELL_EFFECT_DISENCHANT:
+            {
+                if (!m_targets.getItemTarget())
+                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
+
+                // prevent disenchanting in trade slot
+                if (m_targets.getItemTarget()->GetOwnerGUID() != m_caster->GetGUID())
+                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
+
+                ItemPrototype const* itemProto = m_targets.getItemTarget()->GetProto();
+                if (!itemProto)
+                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
+
+                uint32 item_quality = itemProto->Quality;
+                // 2.0.x addon: Check player enchanting level against the item disenchanting requirements
+                uint32 item_disenchantskilllevel = itemProto->RequiredDisenchantSkill;
+                if (item_disenchantskilllevel == uint32(-1))
+                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
+                if (item_disenchantskilllevel > p_caster->GetSkillValue(SKILL_ENCHANTING))
+                    return SPELL_FAILED_LOW_CASTLEVEL;
+                if (item_quality > 4 || item_quality < 2)
+                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
+                if (itemProto->Class != ITEM_CLASS_WEAPON && itemProto->Class != ITEM_CLASS_ARMOR)
+                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
+                if (!itemProto->DisenchantID)
+                    return SPELL_FAILED_CANT_BE_DISENCHANTED;
+                break;
+            }
+            case SPELL_EFFECT_PROSPECTING:
+            {
+                if (!m_targets.getItemTarget())
+                    return SPELL_FAILED_CANT_BE_PROSPECTED;
+                //ensure item is a prospectable ore
+                if (!(m_targets.getItemTarget()->GetProto()->Flags & ITEM_PROTO_FLAG_PROSPECTABLE))
+                    return SPELL_FAILED_CANT_BE_PROSPECTED;
+                //prevent prospecting in trade slot
+                if (m_targets.getItemTarget()->GetOwnerGUID() != m_caster->GetGUID())
+                    return SPELL_FAILED_CANT_BE_PROSPECTED;
+                //Check for enough skill in jewelcrafting
+                uint32 item_prospectingskilllevel = m_targets.getItemTarget()->GetProto()->RequiredSkillRank;
+                if (item_prospectingskilllevel >p_caster->GetSkillValue(SKILL_JEWELCRAFTING))
+                    return SPELL_FAILED_LOW_CASTLEVEL;
+                //make sure the player has the required ores in inventory
+                if (m_targets.getItemTarget()->GetCount() < 5)
+                    return SPELL_FAILED_NEED_MORE_ITEMS;
+
+                if (!LootTemplates_Prospecting.HaveLootFor(m_targets.getItemTargetEntry()))
+                    return SPELL_FAILED_CANT_BE_PROSPECTED;
+
+                break;
+            }
+            case SPELL_EFFECT_MILLING:
+            {
+                if (!m_targets.getItemTarget())
+                    return SPELL_FAILED_CANT_BE_MILLED;
+                //ensure item is a millable herb
+                if (!(m_targets.getItemTarget()->GetProto()->Flags & ITEM_PROTO_FLAG_MILLABLE))
+                    return SPELL_FAILED_CANT_BE_MILLED;
+                //prevent milling in trade slot
+                if (m_targets.getItemTarget()->GetOwnerGUID() != m_caster->GetGUID())
+                    return SPELL_FAILED_CANT_BE_MILLED;
+                //Check for enough skill in inscription
+                uint32 item_millingskilllevel = m_targets.getItemTarget()->GetProto()->RequiredSkillRank;
+                if (item_millingskilllevel >p_caster->GetSkillValue(SKILL_INSCRIPTION))
+                    return SPELL_FAILED_LOW_CASTLEVEL;
+                //make sure the player has the required herbs in inventory
+                if (m_targets.getItemTarget()->GetCount() < 5)
+                    return SPELL_FAILED_NEED_MORE_ITEMS;
+
+                if (!LootTemplates_Milling.HaveLootFor(m_targets.getItemTargetEntry()))
+                    return SPELL_FAILED_CANT_BE_MILLED;
+
+                break;
+            }
+            case SPELL_EFFECT_WEAPON_DAMAGE:
+            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER) return SPELL_FAILED_TARGET_NOT_PLAYER;
+                if (m_attackType != RANGED_ATTACK)
+                    break;
+                Item *pItem = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType);
+                if (!pItem || pItem->IsBroken())
+                    return SPELL_FAILED_EQUIPPED_ITEM;
+
+                switch(pItem->GetProto()->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_THROWN:
+                    {
+                        uint32 ammo = pItem->GetEntry();
+                        if (!m_caster->ToPlayer()->HasItemCount(ammo, 1))
+                            return SPELL_FAILED_NO_AMMO;
+                    };  break;
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    {
+                        uint32 ammo = m_caster->ToPlayer()->GetUInt32Value(PLAYER_AMMO_ID);
+                        if (!ammo)
+                        {
+                            // Requires No Ammo
+                            if (m_caster->HasAura(46699))
+                                break;                      // skip other checks
+
+                            return SPELL_FAILED_NO_AMMO;
+                        }
+
+                        ItemPrototype const *ammoProto = sObjectMgr.GetItemPrototype(ammo);
+                        if (!ammoProto)
+                            return SPELL_FAILED_NO_AMMO;
+
+                        if (ammoProto->Class != ITEM_CLASS_PROJECTILE)
+                            return SPELL_FAILED_NO_AMMO;
+
+                        // check ammo ws. weapon compatibility
+                        switch(pItem->GetProto()->SubClass)
+                        {
+                            case ITEM_SUBCLASS_WEAPON_BOW:
+                            case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                                if (ammoProto->SubClass != ITEM_SUBCLASS_ARROW)
+                                    return SPELL_FAILED_NO_AMMO;
+                                break;
+                            case ITEM_SUBCLASS_WEAPON_GUN:
+                                if (ammoProto->SubClass != ITEM_SUBCLASS_BULLET)
+                                    return SPELL_FAILED_NO_AMMO;
+                                break;
+                            default:
+                                return SPELL_FAILED_NO_AMMO;
+                        }
+
+                        if (!m_caster->ToPlayer()->HasItemCount(ammo, 1))
+                        {
+                            m_caster->ToPlayer()->SetUInt32Value(PLAYER_AMMO_ID, 0);
+                            return SPELL_FAILED_NO_AMMO;
+                        }
+                    };  break;
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            }
+            case SPELL_EFFECT_CREATE_MANA_GEM:
+            {
+                 uint32 item_id = m_spellInfo->EffectItemType[i];
+                 ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item_id);
+
+                 if (!pProto)
+                     return SPELL_FAILED_ITEM_AT_MAX_CHARGES;
+
+                 if (Item* pitem = p_caster->GetItemByEntry(item_id))
+                 {
+                     for (int x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
+                         if (pProto->Spells[x].SpellCharges != 0 && pitem->GetSpellCharges(x) == pProto->Spells[x].SpellCharges)
+                             return SPELL_FAILED_ITEM_AT_MAX_CHARGES;
+                 }
+                 break;
+            }
+            default:
+                break;
+        }
+    }
+
+    // check weapon presence in slots for main/offhand weapons
+    if (m_spellInfo->EquippedItemClass >=0)
+    {
+        // main hand weapon required
+        if (m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_MAIN_HAND)
+        {
+            Item* item = m_caster->ToPlayer()->GetWeaponForAttack(BASE_ATTACK);
+
+            // skip spell if no weapon in slot or broken
+            if (!item || item->IsBroken())
+                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+
+            // skip spell if weapon not fit to triggered spell
+            if (!item->IsFitToSpellRequirements(m_spellInfo))
+                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+        }
+
+        // offhand hand weapon required
+        if (m_spellInfo->AttributesEx3 & SPELL_ATTR_EX3_REQ_OFFHAND)
+        {
+            Item* item = m_caster->ToPlayer()->GetWeaponForAttack(OFF_ATTACK);
+
+            // skip spell if no weapon in slot or broken
+            if (!item || item->IsBroken())
+                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+
+            // skip spell if weapon not fit to triggered spell
+            if (!item->IsFitToSpellRequirements(m_spellInfo))
+                return m_IsTriggeredSpell? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+        }
+    }
+
+    return SPELL_CAST_OK;
+}
+
+void Spell::Delayed() // only called in DealDamage()
+{
+    if (!m_caster)// || m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    //if (m_spellState == SPELL_STATE_DELAYED)
+    //    return;                                             // spell is active and can't be time-backed
+
+    if (isDelayableNoMore())                                 // Spells may only be delayed twice
+        return;
+
+    // spells not loosing casting time (slam, dynamites, bombs..)
+    //if (!(m_spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_DAMAGE))
+    //    return;
+
+    //check pushback reduce
+    int32 delaytime = 500;                                  // spellcasting delay is normally 500ms
+    int32 delayReduce = 100;                                // must be initialized to 100 for percent modifiers
+    m_caster->ToPlayer()->ApplySpellMod(m_spellInfo->Id, SPELLMOD_NOT_LOSE_CASTING_TIME, delayReduce, this);
+    delayReduce += m_caster->GetTotalAuraModifier(SPELL_AURA_REDUCE_PUSHBACK) - 100;
+    if (delayReduce >= 100)
+        return;
+
+    delaytime = delaytime * (100 - delayReduce) / 100;
+
+    if (int32(m_timer) + delaytime > m_casttime)
+    {
+        delaytime = m_casttime - m_timer;
+        m_timer = m_casttime;
+    }
+    else
+        m_timer += delaytime;
+
+    sLog.outDetail("Spell %u partially interrupted for (%d) ms at damage", m_spellInfo->Id, delaytime);
+
+    WorldPacket data(SMSG_SPELL_DELAYED, 8+4);
+    data.append(m_caster->GetPackGUID());
+    data << uint32(delaytime);
+
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::DelayedChannel()
+{
+    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER || getState() != SPELL_STATE_CASTING)
+        return;
+
+    if (isDelayableNoMore())                                    // Spells may only be delayed twice
+        return;
+
+    //check pushback reduce
+    int32 delaytime = GetSpellDuration(m_spellInfo) * 25 / 100; // channeling delay is normally 25% of its time per hit
+    int32 delayReduce = 100;                                    // must be initialized to 100 for percent modifiers
+    m_caster->ToPlayer()->ApplySpellMod(m_spellInfo->Id, SPELLMOD_NOT_LOSE_CASTING_TIME, delayReduce, this);
+    delayReduce += m_caster->GetTotalAuraModifier(SPELL_AURA_REDUCE_PUSHBACK) - 100;
+    if (delayReduce >= 100)
+        return;
+
+    delaytime = delaytime * (100 - delayReduce) / 100;
+
+    if (int32(m_timer) <= delaytime)
+    {
+        delaytime = m_timer;
+        m_timer = 0;
+    }
+    else
+        m_timer -= delaytime;
+
+    sLog.outDebug("Spell %u partially interrupted for %i ms, new duration: %u ms", m_spellInfo->Id, delaytime, m_timer);
+
+    for (std::list<TargetInfo>::const_iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+        if ((*ihit).missCondition == SPELL_MISS_NONE)
+            if (Unit* unit = (m_caster->GetGUID() == ihit->targetGUID) ? m_caster : ObjectAccessor::GetUnit(*m_caster, ihit->targetGUID))
+                unit->DelayOwnedAuras(m_spellInfo->Id, m_originalCasterGUID, delaytime);
+
+    // partially interrupt persistent area auras
+    if (DynamicObject* dynObj = m_caster->GetDynObject(m_spellInfo->Id))
+        dynObj->Delay(delaytime);
+
+    SendChannelUpdate(m_timer);
+}
+
+void Spell::UpdatePointers()
+{
+    if (m_originalCasterGUID == m_caster->GetGUID())
+        m_originalCaster = m_caster;
+    else
+    {
+        m_originalCaster = ObjectAccessor::GetUnit(*m_caster,m_originalCasterGUID);
+        if (m_originalCaster && !m_originalCaster->IsInWorld())
+            m_originalCaster = NULL;
+    }
+
+    if (m_castItemGUID && m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_CastItem = m_caster->ToPlayer()->GetItemByGuid(m_castItemGUID);
+
+    m_targets.Update(m_caster);
+}
+
+bool Spell::CheckTargetCreatureType(Unit* target) const
+{
+    uint32 spellCreatureTargetMask = m_spellInfo->TargetCreatureType;
+
+    // Curse of Doom & Exorcism: not find another way to fix spell target check :/
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->Category == 1179)
+    {
+        // not allow cast at player
+        if (target->GetTypeId() == TYPEID_PLAYER)
+            return false;
+
+        spellCreatureTargetMask = 0x7FF;
+    }
+
+    // Dismiss Pet and Taming Lesson skipped
+    if (m_spellInfo->Id == 2641 || m_spellInfo->Id == 23356)
+        spellCreatureTargetMask =  0;
+
+    // Polymorph and Grounding Totem
+    if (target->GetEntry() == 5925 && m_spellInfo->SpellFamilyName == SPELLFAMILY_MAGE && (m_spellInfo->SpellFamilyFlags[0] & 0x1000000) && m_spellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOD_CONFUSE)
+        return true;
+
+    if (spellCreatureTargetMask)
+    {
+        uint32 TargetCreatureType = target->GetCreatureTypeMask();
+
+        return !TargetCreatureType || (spellCreatureTargetMask & TargetCreatureType);
+    }
+    return true;
+}
+
+CurrentSpellTypes Spell::GetCurrentContainer()
+{
+    if (IsNextMeleeSwingSpell())
+        return(CURRENT_MELEE_SPELL);
+    else if (IsAutoRepeat())
+        return(CURRENT_AUTOREPEAT_SPELL);
+    else if (IsChanneledSpell(m_spellInfo))
+        return(CURRENT_CHANNELED_SPELL);
+    else
+        return(CURRENT_GENERIC_SPELL);
+}
+
+bool Spell::CheckTarget(Unit* target, uint32 eff)
+{
+    // Check targets for creature type mask and remove not appropriate (skip explicit self target case, maybe need other explicit targets)
+    if (m_spellInfo->EffectImplicitTargetA[eff] != TARGET_UNIT_CASTER)
+    {
+        if (!CheckTargetCreatureType(target))
+            return false;
+    }
+
+    // Check Aura spell req (need for AoE spells)
+    if (m_spellInfo->targetAuraSpell && !target->HasAura(m_spellInfo->targetAuraSpell))
+        return false;
+    if (m_spellInfo->excludeTargetAuraSpell && target->HasAura(m_spellInfo->excludeTargetAuraSpell))
+        return false;
+
+    // Check targets for not_selectable unit flag and remove
+    // A player can cast spells on his pet (or other controlled unit) though in any state
+    if (target != m_caster && target->GetCharmerOrOwnerGUID() != m_caster->GetGUID())
+    {
+        // any unattackable target skipped
+        if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+            return false;
+
+        // unselectable targets skipped in all cases except TARGET_UNIT_NEARBY_ENTRY targeting
+        // in case TARGET_UNIT_NEARBY_ENTRY target selected by server always and can't be cheated
+        /*if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE) &&
+            m_spellInfo->EffectImplicitTargetA[eff] != TARGET_UNIT_NEARBY_ENTRY &&
+            m_spellInfo->EffectImplicitTargetB[eff] != TARGET_UNIT_NEARBY_ENTRY)
+            return false;*/
+    }
+
+    //Check player targets and remove if in GM mode or GM invisibility (for not self casting case)
+    if (target != m_caster && target->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (target->ToPlayer()->GetVisibility() == VISIBILITY_OFF)
+            return false;
+
+        if (target->ToPlayer()->isGameMaster() && !IsPositiveSpell(m_spellInfo->Id))
+            return false;
+    }
+
+    switch(m_spellInfo->EffectApplyAuraName[eff])
+    {
+        case SPELL_AURA_NONE:
+        default:
+            break;
+        case SPELL_AURA_MOD_POSSESS:
+        case SPELL_AURA_MOD_CHARM:
+        case SPELL_AURA_MOD_POSSESS_PET:
+        case SPELL_AURA_AOE_CHARM:
+            if (target->GetTypeId() == TYPEID_UNIT && target->IsVehicle())
+                return false;
+            if (target->IsMounted())
+                return false;
+            if (target->GetCharmerGUID())
+                return false;
+            if (int32 damage = CalculateDamage(eff, target))
+                if ((int32)target->getLevel() > damage)
+                    return false;
+            break;
+    }
+
+    //Do not do further checks for triggered spells
+    if (m_IsTriggeredSpell)
+        return true;
+
+    //Check targets for LOS visibility (except spells without range limitations)
+    switch(m_spellInfo->Effect[eff])
+    {
+        case SPELL_EFFECT_SUMMON_PLAYER:                    // from anywhere
+            break;
+        case SPELL_EFFECT_DUMMY:
+            if (m_spellInfo->Id != 20577)                    // Cannibalize
+                break;
+            //fall through
+        case SPELL_EFFECT_RESURRECT_NEW:
+            // player far away, maybe his corpse near?
+            if (target != m_caster && !target->IsWithinLOSInMap(m_caster))
+            {
+                if (!m_targets.getCorpseTargetGUID())
+                    return false;
+
+                Corpse *corpse = ObjectAccessor::GetCorpse(*m_caster, m_targets.getCorpseTargetGUID());
+                if (!corpse)
+                    return false;
+
+                if (target->GetGUID() != corpse->GetOwnerGUID())
+                    return false;
+
+                if (!corpse->IsWithinLOSInMap(m_caster))
+                    return false;
+            }
+
+            // all ok by some way or another, skip normal check
+            break;
+        default:                                            // normal case
+            // Get GO cast coordinates if original caster -> GO
+            WorldObject *caster = NULL;
+            if (IS_GAMEOBJECT_GUID(m_originalCasterGUID))
+                caster = m_caster->GetMap()->GetGameObject(m_originalCasterGUID);
+            if (!caster)
+                caster = m_caster;
+            if (target->GetEntry() == 5925)
+                return true;
+            if (target != m_caster && !target->IsWithinLOSInMap(caster))
+                return false;
+            break;
+    }
+
+    return true;
+}
+
+bool Spell::IsNeedSendToClient() const
+{
+    return m_spellInfo->SpellVisual[0] || m_spellInfo->SpellVisual[1] || IsChanneledSpell(m_spellInfo) ||
+        m_spellInfo->speed > 0.0f || (!m_triggeredByAuraSpell && !m_IsTriggeredSpell);
+}
+
+bool Spell::HaveTargetsForEffect(uint8 effect) const
+{
+    for (std::list<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
+        if (itr->effectMask & (1 << effect))
+            return true;
+
+    for (std::list<GOTargetInfo>::const_iterator itr = m_UniqueGOTargetInfo.begin(); itr != m_UniqueGOTargetInfo.end(); ++itr)
+        if (itr->effectMask & (1 << effect))
+            return true;
+
+    for (std::list<ItemTargetInfo>::const_iterator itr = m_UniqueItemInfo.begin(); itr != m_UniqueItemInfo.end(); ++itr)
+        if (itr->effectMask & (1 << effect))
+            return true;
+
+    return false;
+}
+
+SpellEvent::SpellEvent(Spell* spell) : BasicEvent()
+{
+    m_Spell = spell;
+}
+
+SpellEvent::~SpellEvent()
+{
+    if (m_Spell->getState() != SPELL_STATE_FINISHED)
+        m_Spell->cancel();
+
+    if (m_Spell->IsDeletable())
+    {
+        delete m_Spell;
+    }
+    else
+    {
+        sLog.outError("~SpellEvent: %s %u tried to delete non-deletable spell %u. Was not deleted, causes memory leak.",
+            (m_Spell->GetCaster()->GetTypeId() == TYPEID_PLAYER ? "Player" : "Creature"), m_Spell->GetCaster()->GetGUIDLow(), m_Spell->m_spellInfo->Id);
+        ASSERT(false);
+    }
+}
+
+bool SpellEvent::Execute(uint64 e_time, uint32 p_time)
+{
+    // update spell if it is not finished
+    if (m_Spell->getState() != SPELL_STATE_FINISHED)
+        m_Spell->update(p_time);
+
+    // check spell state to process
+    switch (m_Spell->getState())
+    {
+        case SPELL_STATE_FINISHED:
+        {
+            // spell was finished, check deletable state
+            if (m_Spell->IsDeletable())
+            {
+                // check, if we do have unfinished triggered spells
+                return true;                                // spell is deletable, finish event
+            }
+            // event will be re-added automatically at the end of routine)
+        } break;
+
+        case SPELL_STATE_DELAYED:
+        {
+            // first, check, if we have just started
+            if (m_Spell->GetDelayStart() != 0)
+            {
+                // no, we aren't, do the typical update
+                // check, if we have channeled spell on our hands
+                /*
+                if (IsChanneledSpell(m_Spell->m_spellInfo))
+                {
+                    // evented channeled spell is processed separately, casted once after delay, and not destroyed till finish
+                    // check, if we have casting anything else except this channeled spell and autorepeat
+                    if (m_Spell->GetCaster()->IsNonMeleeSpellCasted(false, true, true))
+                    {
+                        // another non-melee non-delayed spell is casted now, abort
+                        m_Spell->cancel();
+                    }
+                    else
+                    {
+                        // Set last not triggered spell for apply spellmods
+                        ((Player*)m_Spell->GetCaster())->SetSpellModTakingSpell(m_Spell, true);
+                        // do the action (pass spell to channeling state)
+                        m_Spell->handle_immediate();
+
+                        // And remove after effect handling
+                        ((Player*)m_Spell->GetCaster())->SetSpellModTakingSpell(m_Spell, false);
+                    }
+                    // event will be re-added automatically at the end of routine)
+                }
+                else
+                */
+                {
+                    // run the spell handler and think about what we can do next
+                    uint64 t_offset = e_time - m_Spell->GetDelayStart();
+                    uint64 n_offset = m_Spell->handle_delayed(t_offset);
+                    if (n_offset)
+                    {
+                        // re-add us to the queue
+                        m_Spell->GetCaster()->m_Events.AddEvent(this, m_Spell->GetDelayStart() + n_offset, false);
+                        return false;                       // event not complete
+                    }
+                    // event complete
+                    // finish update event will be re-added automatically at the end of routine)
+                }
+            }
+            else
+            {
+                // delaying had just started, record the moment
+                m_Spell->SetDelayStart(e_time);
+                // re-plan the event for the delay moment
+                m_Spell->GetCaster()->m_Events.AddEvent(this, e_time + m_Spell->GetDelayMoment(), false);
+                return false;                               // event not complete
+            }
+        } break;
+
+        default:
+        {
+            // all other states
+            // event will be re-added automatically at the end of routine)
+        } break;
+    }
+
+    // spell processing not complete, plan event on the next update interval
+    m_Spell->GetCaster()->m_Events.AddEvent(this, e_time + 1, false);
+    return false;                                           // event not complete
+}
+
+void SpellEvent::Abort(uint64 /*e_time*/)
+{
+    // oops, the spell we try to do is aborted
+    if (m_Spell->getState() != SPELL_STATE_FINISHED)
+        m_Spell->cancel();
+}
+
+bool SpellEvent::IsDeletable() const
+{
+    return m_Spell->IsDeletable();
+}
+
+bool Spell::IsValidSingleTargetEffect(Unit const* target, Targets type) const
+{
+    switch (type)
+    {
+        case TARGET_UNIT_TARGET_ENEMY:
+            return !m_caster->IsFriendlyTo(target);
+        case TARGET_UNIT_TARGET_ALLY:
+        case TARGET_UNIT_PARTY_TARGET:
+            return m_caster->IsFriendlyTo(target);
+        case TARGET_UNIT_TARGET_PARTY:
+            return m_caster != target && m_caster->IsInPartyWith(target);
+        case TARGET_UNIT_TARGET_RAID:
+            return m_caster->IsInRaidWith(target);
+        case TARGET_UNIT_TARGET_PUPPET:
+            return target->HasUnitTypeMask(UNIT_MASK_PUPPET) && m_caster == target->GetOwner();
+        default:
+            break;
+    }
+    return true;
+}
+
+bool Spell::IsValidSingleTargetSpell(Unit const* target) const
+{
+    if (target->GetMapId() == MAPID_INVALID)
+    {
+        sLog.outDebug("Spell::IsValidSingleTargetSpell - a spell was cast on '%s' (GUIDLow: %u), but they have an invalid map id!", target->GetName(), target->GetGUIDLow());
+        return false;
+    }
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (!IsValidSingleTargetEffect(target, Targets(m_spellInfo->EffectImplicitTargetA[i])))
+            return false;
+        // Need to check B?
+        //if (!IsValidSingleTargetEffect(m_spellInfo->EffectImplicitTargetB[i], target)
+        //    return false;
+    }
+    return true;
+}
+
+bool Spell::IsValidDeadOrAliveTarget(Unit const* target) const
+{
+    if (target->isAlive())
+        return !IsRequiringDeadTargetSpell(m_spellInfo);
+    if (IsAllowingDeadTargetSpell(m_spellInfo))
+        return true;
+    return false;
+}
+
+void Spell::CalculateDamageDoneForAllTargets()
+{
+    float multiplier[MAX_SPELL_EFFECTS];
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        // Get multiplier
+        multiplier[i] = SpellMgr::CalculateSpellEffectDamageMultiplier(m_spellInfo, i, m_originalCaster, this);
+    }
+
+    bool usesAmmo = true;
+    Unit::AuraEffectList const& Auras = m_caster->GetAuraEffectsByType(SPELL_AURA_ABILITY_CONSUME_NO_AMMO);
+    for (Unit::AuraEffectList::const_iterator j = Auras.begin(); j != Auras.end(); ++j)
+    {
+        if ((*j)->IsAffectedOnSpell(m_spellInfo))
+            usesAmmo=false;
+    }
+
+    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+    {
+        TargetInfo &target = *ihit;
+
+        uint32 mask = target.effectMask;
+        if (!mask)
+            continue;
+
+        Unit* unit = m_caster->GetGUID() == target.targetGUID ? m_caster : ObjectAccessor::GetUnit(*m_caster, target.targetGUID);
+        if (!unit) // || !unit->isAlive()) do we need to check alive here?
+            continue;
+
+        if (usesAmmo)
+        {
+            bool ammoTaken = false;
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; i++)
+            {
+                if (!(mask & 1<<i))
+                    continue;
+                switch (m_spellInfo->Effect[i])
+                {
+                    case SPELL_EFFECT_SCHOOL_DAMAGE:
+                    case SPELL_EFFECT_WEAPON_DAMAGE:
+                    case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+                    case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                    case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                    ammoTaken=true;
+                    TakeAmmo();
+                }
+                if (ammoTaken)
+                    break;
+            }
+        }
+
+        if (target.missCondition == SPELL_MISS_NONE)                          // In case spell hit target, do all effect on that target
+        {
+            target.damage += CalculateDamageDone(unit, mask, multiplier);
+            target.crit = m_caster->isSpellCrit(unit, m_spellInfo, m_spellSchoolMask, m_attackType);
+        }
+        else if (target.missCondition == SPELL_MISS_REFLECT)                // In case spell reflect from target, do all effect on caster (if hit)
+        {
+            if (target.reflectResult == SPELL_MISS_NONE)       // If reflected spell hit caster -> do all effect on him
+            {
+                target.damage += CalculateDamageDone(m_caster, mask, multiplier);
+                target.crit = m_caster->isSpellCrit(m_caster, m_spellInfo, m_spellSchoolMask, m_attackType);
+            }
+        }
+    }
+}
+
+int32 Spell::CalculateDamageDone(Unit *unit, const uint32 effectMask, float * /*multiplier*/)
+{
+    int32 damageDone = 0;
+    unitTarget = unit;
+    for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (effectMask & (1<<i))
+        {
+            m_damage = 0;
+            damage = CalculateDamage(i, NULL);
+
+            switch(m_spellInfo->Effect[i])
+            {
+                case SPELL_EFFECT_SCHOOL_DAMAGE:
+                    SpellDamageSchoolDmg((SpellEffIndex)i);
+                    break;
+                case SPELL_EFFECT_WEAPON_DAMAGE:
+                case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+                case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                    SpellDamageWeaponDmg((SpellEffIndex)i);
+                    break;
+                case SPELL_EFFECT_HEAL:
+                    SpellDamageHeal((SpellEffIndex)i);
+                    break;
+            }
+
+            if (m_damage > 0)
+            {
+                if (IsAreaEffectTarget[m_spellInfo->EffectImplicitTargetA[i]] || IsAreaEffectTarget[m_spellInfo->EffectImplicitTargetB[i]])
+                {
+                    m_damage = int32(float(m_damage) * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_AOE_DAMAGE_AVOIDANCE, m_spellInfo->SchoolMask));
+                    if (m_caster->GetTypeId() == TYPEID_UNIT)
+                        m_damage = int32(float(m_damage) * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_CREATURE_AOE_DAMAGE_AVOIDANCE, m_spellInfo->SchoolMask));
+
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        uint32 targetAmount = m_UniqueTargetInfo.size();
+                        if (targetAmount > 10)
+                            m_damage = m_damage * 10/targetAmount;
+                    }
+                }
+            }
+
+            damageDone += m_damage;
+        }
+    }
+
+    return damageDone;
+}
+
+SpellCastResult Spell::CanOpenLock(uint32 effIndex, uint32 lockId, SkillType& skillId, int32& reqSkillValue, int32& skillValue)
+{
+    if (!lockId)                                             // possible case for GO and maybe for items.
+        return SPELL_CAST_OK;
+
+    // Get LockInfo
+    LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+
+    if (!lockInfo)
+        return SPELL_FAILED_BAD_TARGETS;
+
+    bool reqKey = false;                                    // some locks not have reqs
+
+    for (int j = 0; j < MAX_LOCK_CASE; ++j)
+    {
+        switch(lockInfo->Type[j])
+        {
+            // check key item (many fit cases can be)
+            case LOCK_KEY_ITEM:
+                if (lockInfo->Index[j] && m_CastItem && m_CastItem->GetEntry() == lockInfo->Index[j])
+                    return SPELL_CAST_OK;
+                reqKey = true;
+                break;
+                // check key skill (only single first fit case can be)
+            case LOCK_KEY_SKILL:
+            {
+                reqKey = true;
+
+                // wrong locktype, skip
+                if (uint32(m_spellInfo->EffectMiscValue[effIndex]) != lockInfo->Index[j])
+                    continue;
+
+                skillId = SkillByLockType(LockType(lockInfo->Index[j]));
+
+                if (skillId != SKILL_NONE)
+                {
+                    // skill bonus provided by casting spell (mostly item spells)
+                    // add the damage modifier from the spell casted (cheat lock / skeleton key etc.)
+                    uint32 spellSkillBonus = uint32(CalculateDamage(effIndex, NULL));
+                    reqSkillValue = lockInfo->Skill[j];
+
+                    // castitem check: rogue using skeleton keys. the skill values should not be added in this case.
+                    skillValue = m_CastItem || m_caster->GetTypeId()!= TYPEID_PLAYER ?
+                        0 : m_caster->ToPlayer()->GetSkillValue(skillId);
+
+                    skillValue += spellSkillBonus;
+
+                    if (skillValue < reqSkillValue)
+                        return SPELL_FAILED_LOW_CASTLEVEL;
+                }
+
+                return SPELL_CAST_OK;
+            }
+        }
+    }
+
+    if (reqKey)
+        return SPELL_FAILED_BAD_TARGETS;
+
+    return SPELL_CAST_OK;
+}
+
+void Spell::SetSpellValue(SpellValueMod mod, int32 value)
+{
+    switch(mod)
+    {
+        case SPELLVALUE_BASE_POINT0:
+            m_spellValue->EffectBasePoints[0] = SpellMgr::CalculateSpellEffectBaseAmount(value, m_spellInfo, 0);
+            break;
+        case SPELLVALUE_BASE_POINT1:
+            m_spellValue->EffectBasePoints[1] = SpellMgr::CalculateSpellEffectBaseAmount(value, m_spellInfo, 1);
+            break;
+        case SPELLVALUE_BASE_POINT2:
+            m_spellValue->EffectBasePoints[2] = SpellMgr::CalculateSpellEffectBaseAmount(value, m_spellInfo, 2);
+            break;
+        case SPELLVALUE_RADIUS_MOD:
+            m_spellValue->RadiusMod = (float)value / 10000;
+            break;
+        case SPELLVALUE_MAX_TARGETS:
+            m_spellValue->MaxAffectedTargets = (uint32)value;
+            break;
+    }
+}
+
+float tangent(float x)
+{
+    x = tan(x);
+    //if (x < std::numeric_limits<float>::max() && x > -std::numeric_limits<float>::max()) return x;
+    //if (x >= std::numeric_limits<float>::max()) return std::numeric_limits<float>::max();
+    //if (x <= -std::numeric_limits<float>::max()) return -std::numeric_limits<float>::max();
+    if (x < 100000.0f && x > -100000.0f) return x;
+    if (x >= 100000.0f) return 100000.0f;
+    if (x <= 100000.0f) return -100000.0f;
+    return 0.0f;
+}
+
+#define DEBUG_TRAJ(a) //a
+
+void Spell::SelectTrajTargets()
+{
+    if (!m_targets.HasTraj())
+        return;
+
+    float dist2d = m_targets.GetDist2d();
+    if (!dist2d)
+        return;
+
+    float dz = m_targets.m_dstPos.m_positionZ - m_targets.m_srcPos.m_positionZ;
+
+    UnitList unitList;
+    SearchAreaTarget(unitList, dist2d, PUSH_IN_THIN_LINE, SPELL_TARGETS_ANY);
+    if (unitList.empty())
+        return;
+
+    unitList.sort(Trinity::ObjectDistanceOrderPred(m_caster));
+
+    float b = tangent(m_targets.m_elevation);
+    float a = (dz - dist2d * b) / (dist2d * dist2d);
+    if (a > -0.0001f) a = 0;
+    DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: a %f b %f", a, b);)
+
+    float bestDist = GetSpellMaxRange(m_spellInfo, false);
+
+    UnitList::const_iterator itr = unitList.begin();
+    for (; itr != unitList.end(); ++itr)
+    {
+        if (m_caster == *itr || m_caster->IsOnVehicle(*itr) || (*itr)->GetVehicle())//(*itr)->IsOnVehicle(m_caster))
+            continue;
+
+        const float size = std::max((*itr)->GetObjectSize() * 0.7f, 1.0f); // 1/sqrt(3)
+        // TODO: all calculation should be based on src instead of m_caster
+        const float objDist2d = m_targets.m_srcPos.GetExactDist2d(*itr) * cos(m_targets.m_srcPos.GetRelativeAngle(*itr));
+        const float dz = (*itr)->GetPositionZ() - m_targets.m_srcPos.m_positionZ;
+
+        DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: check %u, dist between %f %f, height between %f %f.", (*itr)->GetEntry(), objDist2d - size, objDist2d + size, dz - size, dz + size);)
+
+        float dist = objDist2d - size;
+        float height = dist * (a * dist + b);
+        DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: dist %f, height %f.", dist, height);)
+        if (dist < bestDist && height < dz + size && height > dz - size)
+        {
+            bestDist = dist > 0 ? dist : 0;
+            break;
+        }
+
+#define CHECK_DIST {\
+    DEBUG_TRAJ(sLog.outError("Spell::SelectTrajTargets: dist %f, height %f.", dist, height);)\
+    if (dist > bestDist) continue;\
+    if (dist < objDist2d + size && dist > objDist2d - size) { bestDist = dist; break; }\
+        }
+
+        if (!a)
+        {
+            height = dz - size;
+            dist = height / b;
+            CHECK_DIST;
+
+            height = dz + size;
+            dist = height / b;
+            CHECK_DIST;
+
+            continue;
+        }
+
+        height = dz - size;
+        float sqrt1 = b * b + 4 * a * height;
+        if (sqrt1 > 0)
+        {
+            sqrt1 = sqrt(sqrt1);
+            dist = (sqrt1 - b) / (2 * a);
+            CHECK_DIST;
+        }
+
+        height = dz + size;
+        float sqrt2 = b * b + 4 * a * height;
+        if (sqrt2 > 0)
+        {
+            sqrt2 = sqrt(sqrt2);
+            dist = (sqrt2 - b) / (2 * a);
+            CHECK_DIST;
+
+            dist = (-sqrt2 - b) / (2 * a);
+            CHECK_DIST;
+        }
+
+        if (sqrt1 > 0)
+        {
+            dist = (-sqrt1 - b) / (2 * a);
+            CHECK_DIST;
+        }
+    }
+
+    if (m_targets.m_srcPos.GetExactDist2d(&m_targets.m_dstPos) > bestDist)
+    {
+        float x = m_targets.m_srcPos.m_positionX + cos(m_caster->GetOrientation()) * bestDist;
+        float y = m_targets.m_srcPos.m_positionY + sin(m_caster->GetOrientation()) * bestDist;
+        float z = m_targets.m_srcPos.m_positionZ + bestDist * (a * bestDist + b);
+
+        if (itr != unitList.end())
+        {
+            float distSq = (*itr)->GetExactDistSq(x, y, z);
+            float sizeSq = (*itr)->GetObjectSize();
+            sizeSq *= sizeSq;
+            DEBUG_TRAJ(sLog.outError("Initial %f %f %f %f %f", x, y, z, distSq, sizeSq);)
+            if (distSq > sizeSq)
+            {
+                float factor = 1 - sqrt(sizeSq / distSq);
+                x += factor * ((*itr)->GetPositionX() - x);
+                y += factor * ((*itr)->GetPositionY() - y);
+                z += factor * ((*itr)->GetPositionZ() - z);
+
+                distSq = (*itr)->GetExactDistSq(x, y, z);
+                DEBUG_TRAJ(sLog.outError("Initial %f %f %f %f %f", x, y, z, distSq, sizeSq);)
+            }
+        }
+
+        Position trajDst;
+        trajDst.Relocate(x, y, z, m_caster->GetOrientation());
+        m_targets.modDst(trajDst);
+    }
+}
+
+void Spell::PrepareTargetProcessing()
+{
+    CheckEffectExecuteData();
+}
+
+void Spell::FinishTargetProcessing()
+{
+    SendLogExecute();
+}
+
+void Spell::InitEffectExecuteData(uint8 effIndex)
+{
+    ASSERT(effIndex < MAX_SPELL_EFFECTS);
+    if (!m_effectExecuteData[effIndex])
+    {
+        m_effectExecuteData[effIndex] = new ByteBuffer(0x20);
+        // first dword - target counter
+        *m_effectExecuteData[effIndex] << uint32(1);
+    }
+    else
+    {
+        // increase target counter by one
+        uint32 count = (*m_effectExecuteData[effIndex]).read<uint32>(0);
+        (*m_effectExecuteData[effIndex]).put<uint32>(0, ++count);
+    }
+}
+
+void Spell::CleanupEffectExecuteData()
+{
+    for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        m_effectExecuteData[i] = NULL;
+}
+
+void Spell::CheckEffectExecuteData()
+{
+    for(uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        ASSERT(!m_effectExecuteData[i]);
+}
+
+void Spell::LoadScripts()
+{
+    sLog.outDebug("Spell::LoadScripts");
+    sScriptMgr.CreateSpellScripts(m_spellInfo->Id, m_loadedScripts);
+    for(std::list<SpellScript *>::iterator itr = m_loadedScripts.begin(); itr != m_loadedScripts.end() ;)
+    {
+        if (!(*itr)->_Load(this))
+        {
+            std::list<SpellScript *>::iterator bitr = itr;
+            ++itr;
+            m_loadedScripts.erase(bitr);
+            continue;
+        }
+        (*itr)->Register();
+        ++itr;
+    }
+}
+
+void Spell::PrepareScriptHitHandlers()
+{
+    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    {
+        (*scritr)->_InitHit();
+    }
+}
+
+bool Spell::CallScriptEffectHandlers(SpellEffIndex effIndex)
+{
+    // execute script effect handler hooks and check if effects was prevented
+    bool preventDefault = false;
+    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    {
+        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_EFFECT);
+        std::list<SpellScript::EffectHandler>::iterator effEndItr = (*scritr)->OnEffect.end(), effItr = (*scritr)->OnEffect.begin();
+        for(; effItr != effEndItr ; ++effItr)
+        {
+            // effect execution can be prevented
+            if (!(*scritr)->_IsEffectPrevented(effIndex) && (*effItr).IsEffectAffected(m_spellInfo, effIndex))
+                (*effItr).Call(*scritr, effIndex);
+        }
+        if (!preventDefault)
+            preventDefault = (*scritr)->_IsDefaultEffectPrevented(effIndex);
+        (*scritr)->_FinishScriptCall();
+    }
+    return preventDefault;
+}
+
+void Spell::CallScriptBeforeHitHandlers()
+{
+    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    {
+        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_BEFORE_HIT);
+        std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->BeforeHit.end(), hookItr = (*scritr)->BeforeHit.begin();
+        for(; hookItr != hookItrEnd ; ++hookItr)
+        {
+            (*hookItr).Call(*scritr);
+        }
+        (*scritr)->_FinishScriptCall();
+    }
+}
+
+void Spell::CallScriptOnHitHandlers()
+{
+    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    {
+        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_HIT);
+        std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->OnHit.end(), hookItr = (*scritr)->OnHit.begin();
+        for(; hookItr != hookItrEnd ; ++hookItr)
+        {
+           (*hookItr).Call(*scritr);
+        }
+        (*scritr)->_FinishScriptCall();
+    }
+}
+
+void Spell::CallScriptAfterHitHandlers()
+{
+    for(std::list<SpellScript *>::iterator scritr = m_loadedScripts.begin(); scritr != m_loadedScripts.end() ; ++scritr)
+    {
+        (*scritr)->_PrepareScriptCall(SPELL_SCRIPT_HOOK_AFTER_HIT);
+        std::list<SpellScript::HitHandler>::iterator hookItrEnd = (*scritr)->AfterHit.end(), hookItr = (*scritr)->AfterHit.begin();
+        for(; hookItr != hookItrEnd ; ++hookItr)
+        {
+            (*hookItr).Call(*scritr);
+        }
+        (*scritr)->_FinishScriptCall();
+    }
+}
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -1,7207 +1,7316 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "WorldPacket.h"
-#include "Opcodes.h"
-#include "Log.h"
-#include "UpdateMask.h"
-#include "World.h"
-#include "ObjectMgr.h"
-#include "SpellMgr.h"
-#include "Player.h"
-#include "SkillExtraItems.h"
-#include "Unit.h"
-#include "Spell.h"
-#include "DynamicObject.h"
-#include "SpellAuras.h"
-#include "SpellAuraEffects.h"
-#include "Group.h"
-#include "UpdateData.h"
-#include "MapManager.h"
-#include "ObjectAccessor.h"
-#include "SharedDefines.h"
-#include "Pet.h"
-#include "GameObject.h"
-#include "GossipDef.h"
-#include "Creature.h"
-#include "Totem.h"
-#include "CreatureAI.h"
-#include "BattlegroundMgr.h"
-#include "Battleground.h"
-#include "BattlegroundEY.h"
-#include "BattlegroundWS.h"
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPWG.h"
-#include "Language.h"
-#include "SocialMgr.h"
-#include "Util.h"
-#include "VMapFactory.h"
-#include "TemporarySummon.h"
-#include "CellImpl.h"
-#include "GridNotifiers.h"
-#include "GridNotifiersImpl.h"
-#include "SkillDiscovery.h"
-#include "Formulas.h"
-#include "Vehicle.h"
-#include "ScriptMgr.h"
-
-pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
-{
-    &Spell::EffectNULL,                                     //  0
-    &Spell::EffectInstaKill,                                //  1 SPELL_EFFECT_INSTAKILL
-    &Spell::EffectSchoolDMG,                                //  2 SPELL_EFFECT_SCHOOL_DAMAGE
-    &Spell::EffectDummy,                                    //  3 SPELL_EFFECT_DUMMY
-    &Spell::EffectUnused,                                   //  4 SPELL_EFFECT_PORTAL_TELEPORT          unused
-    &Spell::EffectTeleportUnits,                            //  5 SPELL_EFFECT_TELEPORT_UNITS
-    &Spell::EffectApplyAura,                                //  6 SPELL_EFFECT_APPLY_AURA
-    &Spell::EffectEnvirinmentalDMG,                         //  7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
-    &Spell::EffectPowerDrain,                               //  8 SPELL_EFFECT_POWER_DRAIN
-    &Spell::EffectHealthLeech,                              //  9 SPELL_EFFECT_HEALTH_LEECH
-    &Spell::EffectHeal,                                     // 10 SPELL_EFFECT_HEAL
-    &Spell::EffectBind,                                     // 11 SPELL_EFFECT_BIND
-    &Spell::EffectNULL,                                     // 12 SPELL_EFFECT_PORTAL
-    &Spell::EffectUnused,                                   // 13 SPELL_EFFECT_RITUAL_BASE              unused
-    &Spell::EffectUnused,                                   // 14 SPELL_EFFECT_RITUAL_SPECIALIZE        unused
-    &Spell::EffectUnused,                                   // 15 SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL   unused
-    &Spell::EffectQuestComplete,                            // 16 SPELL_EFFECT_QUEST_COMPLETE
-    &Spell::EffectWeaponDmg,                                // 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
-    &Spell::EffectResurrect,                                // 18 SPELL_EFFECT_RESURRECT
-    &Spell::EffectAddExtraAttacks,                          // 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
-    &Spell::EffectUnused,                                   // 20 SPELL_EFFECT_DODGE                    one spell: Dodge
-    &Spell::EffectUnused,                                   // 21 SPELL_EFFECT_EVADE                    one spell: Evade (DND)
-    &Spell::EffectParry,                                    // 22 SPELL_EFFECT_PARRY
-    &Spell::EffectBlock,                                    // 23 SPELL_EFFECT_BLOCK                    one spell: Block
-    &Spell::EffectCreateItem,                               // 24 SPELL_EFFECT_CREATE_ITEM
-    &Spell::EffectUnused,                                   // 25 SPELL_EFFECT_WEAPON
-    &Spell::EffectUnused,                                   // 26 SPELL_EFFECT_DEFENSE                  one spell: Defense
-    &Spell::EffectPersistentAA,                             // 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
-    &Spell::EffectSummonType,                               // 28 SPELL_EFFECT_SUMMON
-    &Spell::EffectLeap,                                     // 29 SPELL_EFFECT_LEAP
-    &Spell::EffectEnergize,                                 // 30 SPELL_EFFECT_ENERGIZE
-    &Spell::EffectWeaponDmg,                                // 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
-    &Spell::EffectTriggerMissileSpell,                      // 32 SPELL_EFFECT_TRIGGER_MISSILE
-    &Spell::EffectOpenLock,                                 // 33 SPELL_EFFECT_OPEN_LOCK
-    &Spell::EffectSummonChangeItem,                         // 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
-    &Spell::EffectApplyAreaAura,                            // 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
-    &Spell::EffectLearnSpell,                               // 36 SPELL_EFFECT_LEARN_SPELL
-    &Spell::EffectUnused,                                   // 37 SPELL_EFFECT_SPELL_DEFENSE            one spell: SPELLDEFENSE (DND)
-    &Spell::EffectDispel,                                   // 38 SPELL_EFFECT_DISPEL
-    &Spell::EffectUnused,                                   // 39 SPELL_EFFECT_LANGUAGE
-    &Spell::EffectDualWield,                                // 40 SPELL_EFFECT_DUAL_WIELD
-    &Spell::EffectJump,                                     // 41 SPELL_EFFECT_JUMP
-    &Spell::EffectJumpDest,                                 // 42 SPELL_EFFECT_JUMP_DEST
-    &Spell::EffectTeleUnitsFaceCaster,                      // 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
-    &Spell::EffectLearnSkill,                               // 44 SPELL_EFFECT_SKILL_STEP
-    &Spell::EffectAddHonor,                                 // 45 SPELL_EFFECT_ADD_HONOR                honor/pvp related
-    &Spell::EffectUnused,                                   // 46 SPELL_EFFECT_SPAWN clientside, unit appears as if it was just spawned
-    &Spell::EffectTradeSkill,                               // 47 SPELL_EFFECT_TRADE_SKILL
-    &Spell::EffectUnused,                                   // 48 SPELL_EFFECT_STEALTH                  one spell: Base Stealth
-    &Spell::EffectUnused,                                   // 49 SPELL_EFFECT_DETECT                   one spell: Detect
-    &Spell::EffectTransmitted,                              // 50 SPELL_EFFECT_TRANS_DOOR
-    &Spell::EffectUnused,                                   // 51 SPELL_EFFECT_FORCE_CRITICAL_HIT       unused
-    &Spell::EffectUnused,                                   // 52 SPELL_EFFECT_GUARANTEE_HIT            one spell: zzOLDCritical Shot
-    &Spell::EffectEnchantItemPerm,                          // 53 SPELL_EFFECT_ENCHANT_ITEM
-    &Spell::EffectEnchantItemTmp,                           // 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
-    &Spell::EffectTameCreature,                             // 55 SPELL_EFFECT_TAMECREATURE
-    &Spell::EffectSummonPet,                                // 56 SPELL_EFFECT_SUMMON_PET
-    &Spell::EffectLearnPetSpell,                            // 57 SPELL_EFFECT_LEARN_PET_SPELL
-    &Spell::EffectWeaponDmg,                                // 58 SPELL_EFFECT_WEAPON_DAMAGE
-    &Spell::EffectCreateRandomItem,                         // 59 SPELL_EFFECT_CREATE_RANDOM_ITEM       create item base at spell specific loot
-    &Spell::EffectProficiency,                              // 60 SPELL_EFFECT_PROFICIENCY
-    &Spell::EffectSendEvent,                                // 61 SPELL_EFFECT_SEND_EVENT
-    &Spell::EffectPowerBurn,                                // 62 SPELL_EFFECT_POWER_BURN
-    &Spell::EffectThreat,                                   // 63 SPELL_EFFECT_THREAT
-    &Spell::EffectTriggerSpell,                             // 64 SPELL_EFFECT_TRIGGER_SPELL
-    &Spell::EffectApplyAreaAura,                            // 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
-    &Spell::EffectRechargeManaGem,                          // 66 SPELL_EFFECT_CREATE_MANA_GEM          (possibly recharge it, misc - is item ID)
-    &Spell::EffectHealMaxHealth,                            // 67 SPELL_EFFECT_HEAL_MAX_HEALTH
-    &Spell::EffectInterruptCast,                            // 68 SPELL_EFFECT_INTERRUPT_CAST
-    &Spell::EffectDistract,                                 // 69 SPELL_EFFECT_DISTRACT
-    &Spell::EffectPull,                                     // 70 SPELL_EFFECT_PULL                     one spell: Distract Move
-    &Spell::EffectPickPocket,                               // 71 SPELL_EFFECT_PICKPOCKET
-    &Spell::EffectAddFarsight,                              // 72 SPELL_EFFECT_ADD_FARSIGHT
-    &Spell::EffectUnused,                                   // 73 SPELL_EFFECT_UNTRAIN_TALENTS
-    &Spell::EffectApplyGlyph,                               // 74 SPELL_EFFECT_APPLY_GLYPH
-    &Spell::EffectHealMechanical,                           // 75 SPELL_EFFECT_HEAL_MECHANICAL          one spell: Mechanical Patch Kit
-    &Spell::EffectSummonObjectWild,                         // 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
-    &Spell::EffectScriptEffect,                             // 77 SPELL_EFFECT_SCRIPT_EFFECT
-    &Spell::EffectUnused,                                   // 78 SPELL_EFFECT_ATTACK
-    &Spell::EffectSanctuary,                                // 79 SPELL_EFFECT_SANCTUARY
-    &Spell::EffectAddComboPoints,                           // 80 SPELL_EFFECT_ADD_COMBO_POINTS
-    &Spell::EffectUnused,                                   // 81 SPELL_EFFECT_CREATE_HOUSE             one spell: Create House (TEST)
-    &Spell::EffectNULL,                                     // 82 SPELL_EFFECT_BIND_SIGHT
-    &Spell::EffectDuel,                                     // 83 SPELL_EFFECT_DUEL
-    &Spell::EffectStuck,                                    // 84 SPELL_EFFECT_STUCK
-    &Spell::EffectSummonPlayer,                             // 85 SPELL_EFFECT_SUMMON_PLAYER
-    &Spell::EffectActivateObject,                           // 86 SPELL_EFFECT_ACTIVATE_OBJECT
-    &Spell::EffectWMODamage,                                // 87 SPELL_EFFECT_WMO_DAMAGE
-    &Spell::EffectWMORepair,                                // 88 SPELL_EFFECT_WMO_REPAIR
-    &Spell::EffectUnused,                                   // 89 SPELL_EFFECT_WMO_CHANGE // 0 intact // 1 damaged // 2 destroyed // 3 rebuilding
-    &Spell::EffectKillCreditPersonal,                       // 90 SPELL_EFFECT_KILL_CREDIT              Kill credit but only for single person
-    &Spell::EffectUnused,                                   // 91 SPELL_EFFECT_THREAT_ALL               one spell: zzOLDBrainwash
-    &Spell::EffectEnchantHeldItem,                          // 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
-    &Spell::EffectForceDeselect,                            // 93 SPELL_EFFECT_FORCE_DESELECT
-    &Spell::EffectSelfResurrect,                            // 94 SPELL_EFFECT_SELF_RESURRECT
-    &Spell::EffectSkinning,                                 // 95 SPELL_EFFECT_SKINNING
-    &Spell::EffectCharge,                                   // 96 SPELL_EFFECT_CHARGE
-    &Spell::EffectCastButtons,                              // 97 SPELL_EFFECT_CAST_BUTTON (totem bar since 3.2.2a)
-    &Spell::EffectKnockBack,                                // 98 SPELL_EFFECT_KNOCK_BACK
-    &Spell::EffectDisEnchant,                               // 99 SPELL_EFFECT_DISENCHANT
-    &Spell::EffectInebriate,                                //100 SPELL_EFFECT_INEBRIATE
-    &Spell::EffectFeedPet,                                  //101 SPELL_EFFECT_FEED_PET
-    &Spell::EffectDismissPet,                               //102 SPELL_EFFECT_DISMISS_PET
-    &Spell::EffectReputation,                               //103 SPELL_EFFECT_REPUTATION
-    &Spell::EffectSummonObject,                             //104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
-    &Spell::EffectSummonObject,                             //105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
-    &Spell::EffectSummonObject,                             //106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
-    &Spell::EffectSummonObject,                             //107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
-    &Spell::EffectDispelMechanic,                           //108 SPELL_EFFECT_DISPEL_MECHANIC
-    &Spell::EffectSummonDeadPet,                            //109 SPELL_EFFECT_SUMMON_DEAD_PET
-    &Spell::EffectDestroyAllTotems,                         //110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
-    &Spell::EffectDurabilityDamage,                         //111 SPELL_EFFECT_DURABILITY_DAMAGE
-    &Spell::EffectUnused,                                   //112 SPELL_EFFECT_112
-    &Spell::EffectResurrectNew,                             //113 SPELL_EFFECT_RESURRECT_NEW
-    &Spell::EffectTaunt,                                    //114 SPELL_EFFECT_ATTACK_ME
-    &Spell::EffectDurabilityDamagePCT,                      //115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
-    &Spell::EffectSkinPlayerCorpse,                         //116 SPELL_EFFECT_SKIN_PLAYER_CORPSE       one spell: Remove Insignia, bg usage, required special corpse flags...
-    &Spell::EffectSpiritHeal,                               //117 SPELL_EFFECT_SPIRIT_HEAL              one spell: Spirit Heal
-    &Spell::EffectSkill,                                    //118 SPELL_EFFECT_SKILL                    professions and more
-    &Spell::EffectApplyAreaAura,                            //119 SPELL_EFFECT_APPLY_AREA_AURA_PET
-    &Spell::EffectUnused,                                   //120 SPELL_EFFECT_TELEPORT_GRAVEYARD       one spell: Graveyard Teleport Test
-    &Spell::EffectWeaponDmg,                                //121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
-    &Spell::EffectUnused,                                   //122 SPELL_EFFECT_122                      unused
-    &Spell::EffectSendTaxi,                                 //123 SPELL_EFFECT_SEND_TAXI                taxi/flight related (misc value is taxi path id)
-    &Spell::EffectPullTowards,                              //124 SPELL_EFFECT_PULL_TOWARDS
-    &Spell::EffectModifyThreatPercent,                      //125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
-    &Spell::EffectStealBeneficialBuff,                      //126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF    spell steal effect?
-    &Spell::EffectProspecting,                              //127 SPELL_EFFECT_PROSPECTING              Prospecting spell
-    &Spell::EffectApplyAreaAura,                            //128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
-    &Spell::EffectApplyAreaAura,                            //129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
-    &Spell::EffectRedirectThreat,                           //130 SPELL_EFFECT_REDIRECT_THREAT
-    &Spell::EffectPlayerNotification,                       //131 SPELL_EFFECT_PLAYER_NOTIFICATION
-    &Spell::EffectPlayMusic,                                //132 SPELL_EFFECT_PLAY_MUSIC               sound id in misc value (SoundEntries.dbc)
-    &Spell::EffectUnlearnSpecialization,                    //133 SPELL_EFFECT_UNLEARN_SPECIALIZATION   unlearn profession specialization
-    &Spell::EffectKillCredit,                               //134 SPELL_EFFECT_KILL_CREDIT              misc value is creature entry
-    &Spell::EffectNULL,                                     //135 SPELL_EFFECT_CALL_PET
-    &Spell::EffectHealPct,                                  //136 SPELL_EFFECT_HEAL_PCT
-    &Spell::EffectEnergizePct,                              //137 SPELL_EFFECT_ENERGIZE_PCT
-    &Spell::EffectLeapBack,                                 //138 SPELL_EFFECT_LEAP_BACK                Leap back
-    &Spell::EffectQuestClear,                               //139 SPELL_EFFECT_CLEAR_QUEST              Reset quest status (miscValue - quest ID)
-    &Spell::EffectForceCast,                                //140 SPELL_EFFECT_FORCE_CAST
-    &Spell::EffectForceCastWithValue,                       //141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
-    &Spell::EffectTriggerSpellWithValue,                    //142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
-    &Spell::EffectApplyAreaAura,                            //143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
-    &Spell::EffectKnockBack,                                //144 SPELL_EFFECT_KNOCK_BACK_DEST
-    &Spell::EffectPullTowards,                              //145 SPELL_EFFECT_PULL_TOWARDS_DEST                      Black Hole Effect
-    &Spell::EffectActivateRune,                             //146 SPELL_EFFECT_ACTIVATE_RUNE
-    &Spell::EffectQuestFail,                                //147 SPELL_EFFECT_QUEST_FAIL               quest fail
-    &Spell::EffectUnused,                                   //148 SPELL_EFFECT_148   1 spell - 43509
-    &Spell::EffectChargeDest,                               //149 SPELL_EFFECT_CHARGE_DEST
-    &Spell::EffectQuestStart,                               //150 SPELL_EFFECT_QUEST_START
-    &Spell::EffectTriggerRitualOfSummoning,                 //151 SPELL_EFFECT_TRIGGER_SPELL_2
-    &Spell::EffectNULL,                                     //152 SPELL_EFFECT_152                      summon Refer-a-Friend
-    &Spell::EffectCreateTamedPet,                           //153 SPELL_EFFECT_CREATE_TAMED_PET         misc value is creature entry
-    &Spell::EffectDiscoverTaxi,                             //154 SPELL_EFFECT_DISCOVER_TAXI
-    &Spell::EffectTitanGrip,                                //155 SPELL_EFFECT_TITAN_GRIP Allows you to equip two-handed axes, maces and swords in one hand, but you attack $49152s1% slower than normal.
-    &Spell::EffectEnchantItemPrismatic,                     //156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
-    &Spell::EffectCreateItem2,                              //157 SPELL_EFFECT_CREATE_ITEM_2            create item or create item template and replace by some randon spell loot item
-    &Spell::EffectMilling,                                  //158 SPELL_EFFECT_MILLING                  milling
-    &Spell::EffectRenamePet,                                //159 SPELL_EFFECT_ALLOW_RENAME_PET         allow rename pet once again
-    &Spell::EffectNULL,                                     //160 SPELL_EFFECT_160                      1 spell - 45534
-    &Spell::EffectSpecCount,                                //161 SPELL_EFFECT_TALENT_SPEC_COUNT        second talent spec (learn/revert)
-    &Spell::EffectActivateSpec,                             //162 SPELL_EFFECT_TALENT_SPEC_SELECT       activate primary/secondary spec
-    &Spell::EffectNULL,                                     //163 unused
-    &Spell::EffectRemoveAura,                               //164 SPELL_EFFECT_REMOVE_AURA
-};
-
-void Spell::EffectNULL(SpellEffIndex /*effIndex*/)
-{
-    sLog.outDebug("WORLD: Spell Effect DUMMY");
-}
-
-void Spell::EffectUnused(SpellEffIndex /*effIndex*/)
-{
-    // NOT USED BY ANY SPELL OR USELESS OR IMPLEMENTED IN DIFFERENT WAY IN TRINITY
-}
-
-void Spell::EffectResurrectNew(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->isAlive())
-        return;
-
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (!unitTarget->IsInWorld())
-        return;
-
-    Player* pTarget = unitTarget->ToPlayer();
-
-    if (pTarget->isRessurectRequested())       // already have one active request
-        return;
-
-    uint32 health = damage;
-    uint32 mana = m_spellInfo->EffectMiscValue[effIndex];
-    ExecuteLogEffectResurrect(effIndex, pTarget);
-    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
-    SendResurrectRequest(pTarget);
-}
-
-void Spell::EffectInstaKill(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive())
-        return;
-
-    // Demonic Sacrifice
-    if (m_spellInfo->Id == 18788 && unitTarget->GetTypeId() == TYPEID_UNIT)
-    {
-        uint32 entry = unitTarget->GetEntry();
-        uint32 spellID;
-        switch (entry)
-        {
-            case   416: spellID = 18789; break;               //imp
-            case   417: spellID = 18792; break;               //fellhunter
-            case  1860: spellID = 18790; break;               //void
-            case  1863: spellID = 18791; break;               //succubus
-            case 17252: spellID = 35701; break;               //fellguard
-            default:
-                sLog.outError("EffectInstaKill: Unhandled creature entry (%u) case.", entry);
-                return;
-        }
-
-        m_caster->CastSpell(m_caster, spellID, true);
-    }
-
-    if (m_caster == unitTarget)                              // prevent interrupt message
-        finish();
-
-    WorldPacket data(SMSG_SPELLINSTAKILLLOG, 8+8+4);
-    data << uint64(m_caster->GetGUID());
-    data << uint64(unitTarget->GetGUID());
-    data << uint32(m_spellInfo->Id);
-    m_caster->SendMessageToSet(&data, true);
-
-    m_caster->DealDamage(unitTarget, unitTarget->GetHealth(), NULL, NODAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-}
-
-void Spell::EffectEnvirinmentalDMG(SpellEffIndex effIndex)
-{
-    uint32 absorb = 0;
-    uint32 resist = 0;
-
-    // Note: this hack with damage replace required until GO casting not implemented
-    // environment damage spells already have around enemies targeting but this not help in case not existed GO casting support
-    // currently each enemy selected explicitly and self cast damage, we prevent apply self casted spell bonuses/etc
-    damage = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex, m_caster);
-
-    m_caster->CalcAbsorbResist(m_caster, GetSpellSchoolMask(m_spellInfo), SPELL_DIRECT_DAMAGE, damage, &absorb, &resist, m_spellInfo);
-
-    m_caster->SendSpellNonMeleeDamageLog(m_caster, m_spellInfo->Id, damage, GetSpellSchoolMask(m_spellInfo), absorb, resist, false, 0, false);
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->ToPlayer()->EnvironmentalDamage(DAMAGE_FIRE, damage);
-}
-
-void Spell::EffectSchoolDMG(SpellEffIndex /*effIndex*/)
-{
-}
-
-void Spell::SpellDamageSchoolDmg(SpellEffIndex effIndex)
-{
-    bool apply_direct_bonus = true;
-
-    if (unitTarget && unitTarget->isAlive())
-    {
-        switch (m_spellInfo->SpellFamilyName)
-        {
-            case SPELLFAMILY_GENERIC:
-            {
-                // Meteor like spells (divided damage to targets)
-                if (m_customAttr & SPELL_ATTR_CU_SHARE_DAMAGE)
-                {
-                    uint32 count = 0;
-                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1<<effIndex))
-                            ++count;
-
-                    damage /= count;                    // divide to all targets
-                }
-
-                switch(m_spellInfo->Id)                     // better way to check unknown
-                {
-                    // Positive/Negative Charge
-                    case 28062:
-                    case 28085:
-                    case 39090:
-                    case 39093:
-                        if (!m_triggeredByAuraSpell)
-                            break;
-                        if (unitTarget == m_caster)
-                        {
-                            uint8 count = 0;
-                            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                                if (ihit->targetGUID != m_caster->GetGUID())
-                                    if (Player *target = ObjectAccessor::GetPlayer(*m_caster, ihit->targetGUID))
-                                        if (target->HasAura(m_triggeredByAuraSpell->Id))
-                                            ++count;
-                            if (count)
-                            {
-                                uint32 spellId = 0;
-                                switch (m_spellInfo->Id)
-                                {
-                                    case 28062: spellId = 29659; break;
-                                    case 28085: spellId = 29660; break;
-                                    case 39090: spellId = 39089; break;
-                                    case 39093: spellId = 39092; break;
-                                }
-                                m_caster->SetAuraStack(spellId, m_caster, count);
-                            }
-                        }
-
-                        if (unitTarget->HasAura(m_triggeredByAuraSpell->Id))
-                            damage = 0;
-                        break;
-                    // Consumption
-                    case 28865:
-                        damage = (((InstanceMap*)m_caster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY ? 2750 : 4250);
-                        break;
-                    // percent from health with min
-                    case 25599:                             // Thundercrash
-                    {
-                        damage = unitTarget->GetHealth() / 2;
-                        if (damage < 200)
-                            damage = 200;
-                        break;
-                    }
-                    // arcane charge. must only affect demons (also undead?)
-                    case 45072:
-                    {
-                        if (unitTarget->GetCreatureType() != CREATURE_TYPE_DEMON
-                            && unitTarget->GetCreatureType() != CREATURE_TYPE_UNDEAD)
-                            return;
-                        break;
-                    }
-                    case 33671: // gruul's shatter
-                    case 50811: // krystallus shatter ( Normal )
-                    case 61547: // krystallus shatter ( Heroic )
-                    {
-                        // don't damage self and only players
-                        if (unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                            return;
-
-                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
-                        if (!radius) return;
-                        float distance = m_caster->GetDistance2d(unitTarget);
-                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * ((radius - distance)/radius));
-                        break;
-                    }
-                    // TODO: add spell specific target requirement hook for spells
-                    // Shadowbolts only affects targets with Shadow Mark (Gothik)
-                    case 27831:
-                    case 55638:
-                        if (!unitTarget->HasAura(27825))
-                            return;
-                        break;
-                    // Cataclysmic Bolt
-                    case 38441:
-                    {
-                        damage = unitTarget->CountPctFromMaxHealth(50);
-                        break;
-                    }
-                    // Tympanic Tantrum
-                    case 62775:
-                    {
-                        damage = unitTarget->CountPctFromMaxHealth(10);
-                        break;
-                    }
-                    // Gargoyle Strike
-                    case 51963:
-                    {
-                        // about +4 base spell dmg per level
-                        damage = (m_caster->getLevel() - 60) * 4 + 60;
-                        break;
-                    }
-
-                    // Loken Pulsing Shockwave
-                    case 59837:
-                    case 52942:
-                    {
-                        // don't damage self and only players
-                        if(unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                            return;
-
-                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
-                        if (!radius)
-                            return;
-                        float distance = m_caster->GetDistance2d(unitTarget);
-                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * distance);
-                        break;
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_WARRIOR:
-            {
-                // Bloodthirst
-                if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
-                    damage = uint32(damage * (m_caster->GetTotalAttackPowerValue(BASE_ATTACK)) / 100);
-                // Shield Slam
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x200 && m_spellInfo->Category == 1209)
-                    damage += m_caster->ApplyEffectModifiers(m_spellInfo,effIndex,int32(m_caster->GetShieldBlockValue()));
-                // Victory Rush
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x100)
-                {
-                    damage = uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
-                    m_caster->ModifyAuraState(AURA_STATE_WARRIOR_VICTORY_RUSH, false);
-                }
-                // Shockwave
-                else if (m_spellInfo->Id == 46968)
-                {
-                    int32 pct = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, 2);
-                    if (pct > 0)
-                        damage+= int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * pct / 100);
-                    break;
-                }
-                break;
-            }
-            case SPELLFAMILY_WARLOCK:
-            {
-                // Incinerate Rank 1 & 2
-                if ((m_spellInfo->SpellFamilyFlags[1] & 0x000040) && m_spellInfo->SpellIconID == 2128)
-                {
-                    // Incinerate does more dmg (dmg*0.25) if the target have Immolate debuff.
-                    // Check aura state for speed but aura state set not only for Immolate spell
-                    if (unitTarget->HasAuraState(AURA_STATE_CONFLAGRATE))
-                    {
-                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0, 0))
-                            damage += damage/4;
-                    }
-                }
-                // Conflagrate - consumes Immolate or Shadowflame
-                else if (m_spellInfo->TargetAuraState == AURA_STATE_CONFLAGRATE)
-                {
-                    AuraEffect const* aura = NULL;                // found req. aura for damage calculation
-
-                    Unit::AuraEffectList const &mPeriodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
-                    for (Unit::AuraEffectList::const_iterator i = mPeriodic.begin(); i != mPeriodic.end(); ++i)
-                    {
-                        // for caster applied auras only
-                        if ((*i)->GetSpellProto()->SpellFamilyName != SPELLFAMILY_WARLOCK ||
-                            (*i)->GetCasterGUID() != m_caster->GetGUID())
-                            continue;
-
-                        // Immolate
-                        if ((*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x4)
-                        {
-                            aura = *i;                      // it selected always if exist
-                            break;
-                        }
-
-                        // Shadowflame
-                        if ((*i)->GetSpellProto()->SpellFamilyFlags[2] & 0x00000002)
-                            aura = *i;                      // remember but wait possible Immolate as primary priority
-                    }
-
-                    // found Immolate or Shadowflame
-                    if (aura)
-                    {
-                        uint32 pdamage = aura->GetAmount() > 0 ? aura->GetAmount() : 0;
-                        pdamage = m_caster->SpellDamageBonus(unitTarget, aura->GetSpellProto(), pdamage, DOT, aura->GetBase()->GetStackAmount());
-                        uint32 pct_dir = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 1));
-                        uint8 baseTotalTicks = uint8(m_caster->CalcSpellDuration(aura->GetSpellProto()) / aura->GetSpellProto()->EffectAmplitude[0]);
-                        damage += pdamage * baseTotalTicks * pct_dir / 100;
-
-                        uint32 pct_dot = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 2)) / 3;
-                        m_spellValue->EffectBasePoints[1] = SpellMgr::CalculateSpellEffectBaseAmount(pdamage * baseTotalTicks * pct_dot / 100, m_spellInfo, 1);
-
-                        apply_direct_bonus = false;
-                        // Glyph of Conflagrate
-                        if (!m_caster->HasAura(56235))
-                            unitTarget->RemoveAurasDueToSpell(aura->GetId(), m_caster->GetGUID());
-
-                        break;
-                    }
-                }
-                // Shadow Bite
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x400000)
-                {
-                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet())
-                    {
-                        // Get DoTs on target by owner (5% increase by dot)
-                        damage += 5 * unitTarget->GetDoTsByCaster(m_caster->GetOwnerGUID()) / 100;
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_PRIEST:
-            {
-                // Shadow Word: Death - deals damage equal to damage done to caster
-                if ((m_spellInfo->SpellFamilyFlags[1] & 0x2))
-                {
-                    int32 back_damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
-                    // Pain and Suffering reduces damage
-                    if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST, 2874, 0))
-                        back_damage -= aurEff->GetAmount() * back_damage / 100;
-
-                    if (back_damage < int32(unitTarget->GetHealth()))
-                        m_caster->CastCustomSpell(m_caster, 32409, &back_damage, 0, 0, true);
-                }
-                // Mind Blast - applies Mind Trauma if:
-                else if (m_spellInfo->SpellFamilyFlags[2] & 0x00002000)
-                {
-                    // We are in Shadow Form
-                    if (m_caster->m_form == FORM_SHADOW)
-                        // We have Improved Mind Blast
-                        if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST,95,0))
-                            // Chance has been successfully rolled
-                            if (roll_chance_i(aurEff->GetAmount()))
-                                m_caster->CastSpell(unitTarget, 48301, true);
-                }
-                // Smite
-                else if (m_spellInfo->SpellFamilyFlags[0] & 0x80)
-                {
-                    // Glyph of Smite
-                    if (AuraEffect * aurEff = m_caster->GetAuraEffect(55692, 0))
-                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x100000, 0, 0, m_caster->GetGUID()))
-                            damage += damage * aurEff->GetAmount() / 100;
-                }
-                // Improved Mind Blast (Mind Blast in shadow form bonus)
-                else if (m_caster->m_form == FORM_SHADOW && (m_spellInfo->SpellFamilyFlags[0] & 0x00002000))
-                {
-                    Unit::AuraEffectList const& ImprMindBlast = m_caster->GetAuraEffectsByType(SPELL_AURA_ADD_FLAT_MODIFIER);
-                    for (Unit::AuraEffectList::const_iterator i = ImprMindBlast.begin(); i != ImprMindBlast.end(); ++i)
-                    {
-                        if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_PRIEST &&
-                            ((*i)->GetSpellProto()->SpellIconID == 95))
-                        {
-                            int chance = SpellMgr::CalculateSpellEffectAmount((*i)->GetSpellProto(), 1, m_caster);
-                            if (roll_chance_i(chance))
-                                // Mind Trauma
-                                m_caster->CastSpell(unitTarget, 48301, true, 0);
-                            break;
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_DRUID:
-            {
-                // Ferocious Bite
-                if (m_caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->SpellFamilyFlags[0] & 0x000800000) && m_spellInfo->SpellVisual[0] == 6587)
-                {
-                    // converts each extra point of energy into ($f1+$AP/410) additional damage
-                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
-                    float multiple = ap / 410 + m_spellInfo->EffectDamageMultiplier[effIndex];
-                    int32 energy = -(m_caster->ModifyPower(POWER_ENERGY, -30));
-                    damage += int32(energy * multiple);
-                    damage += int32(m_caster->ToPlayer()->GetComboPoints() * ap * 7 / 100);
-                }
-                // Wrath
-                else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
-                {
-                    // Improved Insect Swarm
-                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))
-                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00200000, 0, 0))
-                            damage = int32(damage*(100.0f+aurEff->GetAmount())/100.0f);
-                }
-                break;
-            }
-            case SPELLFAMILY_ROGUE:
-            {
-                // Envenom
-                if (m_caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->SpellFamilyFlags[1] & 0x8))
-                {
-                    // consume from stack dozes not more that have combo-points
-                    if (uint32 combo = m_caster->ToPlayer()->GetComboPoints())
-                    {
-                        // Lookup for Deadly poison (only attacker applied)
-                        if (AuraEffect const * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x10000, 0, 0, m_caster->GetGUID()))
-                        {
-                            // count consumed deadly poison doses at target
-                            bool needConsume = true;
-                            uint32 spellId = aurEff->GetId();
-                            uint32 doses = aurEff->GetBase()->GetStackAmount();
-                            if (doses > combo)
-                                doses = combo;
-                            // Master Poisoner
-                            Unit::AuraEffectList const& auraList = m_caster->ToPlayer()->GetAuraEffectsByType(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK);
-                            for (Unit::AuraEffectList::const_iterator iter = auraList.begin(); iter != auraList.end(); ++iter)
-                            {
-                                if ((*iter)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_ROGUE && (*iter)->GetSpellProto()->SpellIconID == 1960)
-                                {
-                                    uint32 chance = SpellMgr::CalculateSpellEffectAmount((*iter)->GetSpellProto(), 2, m_caster);
-
-                                    if (chance && roll_chance_i(chance))
-                                        needConsume = false;
-
-                                    break;
-                                }
-                            }
-
-                            if (needConsume)
-                                for (uint32 i = 0; i < doses; ++i)
-                                    unitTarget->RemoveAuraFromStack(spellId);
-                            damage *= doses;
-                            damage += int32(((Player*)m_caster)->GetTotalAttackPowerValue(BASE_ATTACK) * 0.09f * doses);
-                        }
-                        // Eviscerate and Envenom Bonus Damage (item set effect)
-                        if (m_caster->HasAura(37169))
-                            damage += ((Player*)m_caster)->GetComboPoints()*40;
-                    }
-                }
-                // Eviscerate
-                else if ((m_spellInfo->SpellFamilyFlags[0] & 0x00020000) && m_caster->GetTypeId() == TYPEID_PLAYER)
-                {
-                    if (uint32 combo = ((Player*)m_caster)->GetComboPoints())
-                    {
-                        float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
-                        damage += irand(int32(ap * combo * 0.03f), int32(ap * combo * 0.07f));
-
-                        // Eviscerate and Envenom Bonus Damage (item set effect)
-                        if (m_caster->HasAura(37169))
-                            damage += combo*40;
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_HUNTER:
-            {
-                //Gore
-                if (m_spellInfo->SpellIconID == 1578)
-                {
-                    if (m_caster->HasAura(57627))           // Charge 6 sec post-affect
-                        damage *= 2;
-                }
-                // Steady Shot
-                else if (m_spellInfo->SpellFamilyFlags[1] & 0x1)
-                {
-                    bool found = false;
-                    // check dazed affect
-                    Unit::AuraEffectList const& decSpeedList = unitTarget->GetAuraEffectsByType(SPELL_AURA_MOD_DECREASE_SPEED);
-                    for (Unit::AuraEffectList::const_iterator iter = decSpeedList.begin(); iter != decSpeedList.end(); ++iter)
-                    {
-                        if ((*iter)->GetSpellProto()->SpellIconID == 15 && (*iter)->GetSpellProto()->Dispel == 0)
-                        {
-                            found = true;
-                            break;
-                        }
-                    }
-
-                    // TODO: should this be put on taken but not done?
-                    if (found)
-                        damage += SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
-
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        // Add Ammo and Weapon damage plus RAP * 0.1
-                        Item *item = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
-                        if (item)
-                        {
-                            float dmg_min = item->GetProto()->Damage->DamageMin;
-                            float dmg_max = item->GetProto()->Damage->DamageMax;
-                            if (dmg_max == 0.0f && dmg_min > dmg_max)
-                                damage += int32(dmg_min);
-                            else
-                                damage += irand(int32(dmg_min), int32(dmg_max));
-                            damage += int32(m_caster->ToPlayer()->GetAmmoDPS()*item->GetProto()->Delay*0.001f);
-                        }
-                    }
-                }
-                break;
-            }
-            case SPELLFAMILY_PALADIN:
-            {
-                // Hammer of the Righteous
-                if (m_spellInfo->SpellFamilyFlags[1]&0x00040000)
-                {
-                    // Add main hand dps * effect[2] amount
-                    float average = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2;
-                    int32 count = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, 2);
-                    damage += count * int32(average * IN_MILLISECONDS) / m_caster->GetAttackTime(BASE_ATTACK);
-                }
-                // Shield of Righteousness
-                else if (m_spellInfo->SpellFamilyFlags[1]&0x00100000)
-                {
-                    damage += int32(m_caster->GetShieldBlockValue() * 1.3f);
-                }
-                break;
-            }
-            case SPELLFAMILY_DEATHKNIGHT:
-            {
-                // Blood Boil - bonus for diseased targets
-                if (m_spellInfo->SpellFamilyFlags[0] & 0x00040000 && unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0, 0, 0x00000002, m_caster->GetGUID()))
-                {
-                    damage += m_damage / 2;
-                    damage += int32(m_caster->GetTotalAttackPowerValue(RANGED_ATTACK)* 0.035f);
-                }
-                break;
-            }
-        }
-
-        if (m_originalCaster && damage > 0 && apply_direct_bonus)
-            damage = m_originalCaster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
-
-        m_damage += damage;
-    }
-}
-
-void Spell::EffectDummy(SpellEffIndex effIndex)
-{
-    if (!unitTarget && !gameObjTarget && !itemTarget)
-        return;
-
-    uint32 spell_id = 0;
-    int32 bp = 0;
-    bool triggered = true;
-    SpellCastTargets targets;
-
-    // selection by spell family
-    switch (m_spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            switch (m_spellInfo->Id)
-            {
-                case 8593:                                  // Symbol of life (restore creature to life)
-                case 31225:                                 // Shimmering Vessel (restore creature to life)
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-                    unitTarget->ToCreature()->setDeathState(JUST_ALIVED);
-                    return;
-                }
-                case 12162:                                 // Deep wounds
-                case 12850:                                 // (now good common check for this spells)
-                case 12868:
-                {
-                    if (!unitTarget)
-                        return;
-
-                    float damage;
-                    // DW should benefit of attack power, damage percent mods etc.
-                    // TODO: check if using offhand damage is correct and if it should be divided by 2
-                    if (m_caster->haveOffhandWeapon() && m_caster->getAttackTimer(BASE_ATTACK) > m_caster->getAttackTimer(OFF_ATTACK))
-                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE))/2;
-                    else
-                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE))/2;
-
-                    switch (m_spellInfo->Id)
-                    {
-                        case 12162: damage *= 0.16f; break; // Rank 1
-                        case 12850: damage *= 0.32f; break; // Rank 2
-                        case 12868: damage *= 0.48f; break; // Rank 3
-                        default:
-                            sLog.outError("Spell::EffectDummy: Spell %u not handled in DW",m_spellInfo->Id);
-                            return;
-                    };
-
-                    // get remaining damage of old Deep Wound aura
-                    AuraEffect* deepWound = unitTarget->GetAuraEffect(12721, 0);
-                    if (deepWound)
-                    {
-                        int32 remainingTicks = deepWound->GetBase()->GetDuration() / deepWound->GetAmplitude();
-                        damage += remainingTicks * deepWound->GetAmount();
-                    }
-
-                    // 1 tick/sec * 6 sec = 6 ticks
-                    int32 deepWoundsDotBasePoints0 = int32(damage / 6);
-                    m_caster->CastCustomSpell(unitTarget, 12721, &deepWoundsDotBasePoints0, NULL, NULL, true, NULL);
-                    return;
-                }
-                case 13567:                                 // Dummy Trigger
-                {
-                    // can be used for different aura triggering, so select by aura
-                    if (!m_triggeredByAuraSpell || !unitTarget)
-                        return;
-
-                    switch (m_triggeredByAuraSpell->Id)
-                    {
-                        case 26467:                         // Persistent Shield
-                            m_caster->CastCustomSpell(unitTarget, 26470, &damage, NULL, NULL, true);
-                            break;
-                        default:
-                            sLog.outError("EffectDummy: Non-handled case for spell 13567 for triggered aura %u",m_triggeredByAuraSpell->Id);
-                            break;
-                    }
-                    return;
-                }
-                case 17251:                                 // Spirit Healer Res
-                {
-                    if (!unitTarget || !m_originalCaster)
-                        return;
-
-                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
-                    {
-                        WorldPacket data(SMSG_SPIRIT_HEALER_CONFIRM, 8);
-                        data << uint64(unitTarget->GetGUID());
-                        m_originalCaster->ToPlayer()->GetSession()->SendPacket(&data);
-                    }
-                    return;
-                }
-                case 20577:                                 // Cannibalize
-                    if (unitTarget)
-                        m_caster->CastSpell(m_caster, 20578, false, NULL);
-                    return;
-                case 23019:                                 // Crystal Prison Dummy DND
-                {
-                    if (!unitTarget || !unitTarget->isAlive() || unitTarget->GetTypeId() != TYPEID_UNIT || unitTarget->ToCreature()->isPet())
-                        return;
-
-                    Creature* creatureTarget = unitTarget->ToCreature();
-
-                    m_caster->SummonGameObject(179644, creatureTarget->GetPositionX(), creatureTarget->GetPositionY(), creatureTarget->GetPositionZ(), creatureTarget->GetOrientation(), 0, 0, 0, 0, uint32(creatureTarget->GetRespawnTime()-time(NULL)));
-                    sLog.outDebug("SummonGameObject at SpellEfects.cpp EffectDummy for Spell 23019");
-
-                    creatureTarget->ForcedDespawn();
-
-                    return;
-                }
-                case 23448:                                 // Transporter Arrival - Ultrasafe Transporter: Gadgetzan - backfires
-                {
-                    int32 r = irand(0, 119);
-                    if (r < 20)                           // Transporter Malfunction - 1/6 polymorph
-                        m_caster->CastSpell(m_caster, 23444, true);
-                    else if (r < 100)                     // Evil Twin               - 4/6 evil twin
-                        m_caster->CastSpell(m_caster, 23445, true);
-                    else                                    // Transporter Malfunction - 1/6 miss the target
-                        m_caster->CastSpell(m_caster, 36902, true);
-                    return;
-                }
-                case 23453:                                 // Gnomish Transporter - Ultrasafe Transporter: Gadgetzan
-                    if (roll_chance_i(50))                // Gadgetzan Transporter         - success
-                        m_caster->CastSpell(m_caster, 23441, true);
-                    else                                    // Gadgetzan Transporter Failure - failure
-                        m_caster->CastSpell(m_caster, 23446, true);
-                    return;
-                case 25860:                                 // Reindeer Transformation
-                {
-                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
-                        return;
-
-                    float flyspeed = m_caster->GetSpeedRate(MOVE_FLIGHT);
-                    float speed = m_caster->GetSpeedRate(MOVE_RUN);
-
-                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    //5 different spells used depending on mounted speed and if mount can fly or not
-                    if (flyspeed >= 4.1f)
-                        // Flying Reindeer
-                        m_caster->CastSpell(m_caster, 44827, true); //310% flying Reindeer
-                    else if (flyspeed >= 3.8f)
-                        // Flying Reindeer
-                        m_caster->CastSpell(m_caster, 44825, true); //280% flying Reindeer
-                    else if (flyspeed >= 1.6f)
-                        // Flying Reindeer
-                        m_caster->CastSpell(m_caster, 44824, true); //60% flying Reindeer
-                    else if (speed >= 2.0f)
-                        // Reindeer
-                        m_caster->CastSpell(m_caster, 25859, true); //100% ground Reindeer
-                    else
-                        // Reindeer
-                        m_caster->CastSpell(m_caster, 25858, true); //60% ground Reindeer
-
-                    return;
-                }
-                case 26074:                                 // Holiday Cheer
-                    // implemented at client side
-                    return;
-                // Polarity Shift
-                case 28089:
-                    if (unitTarget)
-                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 28059 : 28084, true, NULL, NULL, m_caster->GetGUID());
-                    break;
-                // Polarity Shift
-                case 39096:
-                    if (unitTarget)
-                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 39088 : 39091, true, NULL, NULL, m_caster->GetGUID());
-                    break;
-                case 29200:                                 // Purify Helboar Meat
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    uint32 spell_id = roll_chance_i(50)
-                        ? 29277                             // Summon Purified Helboar Meat
-                        : 29278;                            // Summon Toxic Helboar Meat
-
-                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
-                    return;
-                }
-                case 29858:                                 // Soulshatter
-                    if (unitTarget && unitTarget->CanHaveThreatList()
-                        && unitTarget->getThreatManager().getThreat(m_caster) > 0.0f)
-                        m_caster->CastSpell(unitTarget,32835,true);
-                    return;
-                case 30458:                                 // Nigh Invulnerability
-                    if (!m_CastItem) return;
-                    if (roll_chance_i(86))                   // Nigh-Invulnerability   - success
-                        m_caster->CastSpell(m_caster, 30456, true, m_CastItem);
-                    else                                    // Complete Vulnerability - backfire in 14% casts
-                        m_caster->CastSpell(m_caster, 30457, true, m_CastItem);
-                    return;
-                case 30507:                                 // Poultryizer
-                    if (!m_CastItem) return;
-                    if (roll_chance_i(80))                   // Poultryized! - success
-                        m_caster->CastSpell(unitTarget, 30501, true, m_CastItem);
-                    else                                    // Poultryized! - backfire 20%
-                        m_caster->CastSpell(unitTarget, 30504, true, m_CastItem);
-                    return;
-                case 35745:                                 // Socrethar's Stone
-                {
-                    uint32 spell_id;
-                    switch(m_caster->GetAreaId())
-                    {
-                        case 3900: spell_id = 35743; break; // Socrethar Portal
-                        case 3742: spell_id = 35744; break; // Socrethar Portal
-                        default: return;
-                    }
-
-                    m_caster->CastSpell(m_caster, spell_id, true);
-                    return;
-                }
-                case 37674:                                 // Chaos Blast
-                {
-                    if (!unitTarget)
-                        return;
-
-                    int32 basepoints0 = 100;
-                    m_caster->CastCustomSpell(unitTarget, 37675, &basepoints0, NULL, NULL, true);
-                    return;
-                }
-                // Wrath of the Astromancer
-                case 42784:
-                {
-                    uint32 count = 0;
-                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1<<effIndex))
-                            ++count;
-
-                    damage = 12000; // maybe wrong value
-                    damage /= count;
-
-                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(42784);
-
-                     // now deal the damage
-                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1<<effIndex))
-                        {
-                            if (Unit* casttarget = Unit::GetUnit((*unitTarget), ihit->targetGUID))
-                                m_caster->DealDamage(casttarget, damage, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_ARCANE, spellInfo, false);
-                        }
-
-                    return;
-                }
-                // Demon Broiled Surprise
-                case 43723:
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    Player *player = (Player*)m_caster;
-
-                    if (player && player->GetQuestStatus(11379) == QUEST_STATUS_INCOMPLETE)
-                    {
-                        Creature *creature = player->FindNearestCreature(19973, 10, false);
-                        if (!creature)
-                        {
-                            SendCastResult(SPELL_FAILED_NOT_HERE);
-                            return;
-                        }
-
-                        player->CastSpell(player, 43753, false);
-                    }
-                    return;
-                }
-                case 44875:                                 // Complete Raptor Capture
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    unitTarget->ToCreature()->ForcedDespawn();
-
-                    //cast spell Raptor Capture Credit
-                    m_caster->CastSpell(m_caster, 42337, true, NULL);
-                    return;
-                }
-                case 47170:                                 // Impale Leviroth
-                {
-                    if (!unitTarget && unitTarget->GetEntry() != 26452 && unitTarget->HealthAbovePct(95))
-                        return;
-
-                        m_caster->DealDamage(unitTarget, unitTarget->CountPctFromMaxHealth(93));
-                        return;
-                }
-                case 49357:                                 // Brewfest Mount Transformation
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
-                        return;
-                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
-                    // Ram for Alliance, Kodo for Horde
-                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                    {
-                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Ram
-                            m_caster->CastSpell(m_caster, 43900, true);
-                        else
-                            // 60% Ram
-                            m_caster->CastSpell(m_caster, 43899, true);
-                    }
-                    else
-                    {
-                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Kodo
-                            m_caster->CastSpell(m_caster, 49379, true);
-                        else
-                            // 60% Kodo
-                            m_caster->CastSpell(m_caster, 49378, true);
-                    }
-                    return;
-                case 52845:                                 // Brewfest Mount Transformation (Faction Swap)
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
-                        return;
-                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
-                    // Ram for Horde, Kodo for Alliance
-                    if (m_caster->ToPlayer()->GetTeam() == HORDE)
-                    {
-                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Ram
-                            m_caster->CastSpell(m_caster, 43900, true);
-                        else
-                            // 60% Ram
-                            m_caster->CastSpell(m_caster, 43899, true);
-                    }
-                    else
-                    {
-                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
-                            // 100% Kodo
-                            m_caster->CastSpell(m_caster, 49379, true);
-                        else
-                            // 60% Kodo
-                            m_caster->CastSpell(m_caster, 49378, true);
-                    }
-                    return;
-                case 55004:                                 // Nitro Boosts
-                    if (!m_CastItem)
-                        return;
-                    if (roll_chance_i(95))                  // Nitro Boosts - success
-                        m_caster->CastSpell(m_caster, 54861, true, m_CastItem);
-                    else                                    // Knocked Up   - backfire 5%
-                        m_caster->CastSpell(m_caster, 46014, true, m_CastItem);
-                    return;
-                case 50243:                                 // Teach Language
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // spell has a 1/3 chance to trigger one of the below
-                    if (roll_chance_i(66))
-                        return;
-                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                    {
-                        // 1000001 - gnomish binary
-                        m_caster->CastSpell(m_caster, 50242, true);
-                    }
-                    else
-                    {
-                        // 01001000 - goblin binary
-                        m_caster->CastSpell(m_caster, 50246, true);
-                    }
-
-                    return;
-                }
-                case 51582:                                 //Rocket Boots Engaged (Rocket Boots Xtreme and Rocket Boots Xtreme Lite)
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    if (Battleground* bg = m_caster->ToPlayer()->GetBattleground())
-                        bg->EventPlayerDroppedFlag(m_caster->ToPlayer());
-
-                    m_caster->CastSpell(m_caster, 30452, true, NULL);
-                    return;
-                }
-                case 52759:                                 // Ancestral Awakening
-                    if (!unitTarget)
-                        return;
-                    m_caster->CastCustomSpell(unitTarget, 52752, &damage, NULL, NULL, true);
-                    return;
-                case 54171:                                   //Divine Storm
-                {
-                    m_caster->CastCustomSpell(unitTarget, 54172, &damage, 0, 0, true);
-                    return;
-                }
-                case 58418:                                 // Portal to Orgrimmar
-                case 58420:                                 // Portal to Stormwind
-                    return;                                 // implemented in EffectScript[0]
-                case 62324: // Throw Passenger
-                {
-                    if (m_targets.HasTraj())
-                    {
-                        if (Vehicle *vehicle = m_caster->GetVehicleKit())
-                            if (Unit *passenger = vehicle->GetPassenger(damage - 1))
-                            {
-                                std::list<Unit*> unitList;
-                                // use 99 because it is 3d search
-                                SearchAreaTarget(unitList, 99, PUSH_DST_CENTER, SPELL_TARGETS_ENTRY, 33114);
-                                float minDist = 99 * 99;
-                                Vehicle *target = NULL;
-                                for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
-                                {
-                                    if (Vehicle *seat = (*itr)->GetVehicleKit())
-                                        if (!seat->GetPassenger(0))
-                                            if (Unit *device = seat->GetPassenger(2))
-                                                if (!device->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
-                                                {
-                                                    float dist = (*itr)->GetExactDistSq(&m_targets.m_dstPos);
-                                                    if (dist < minDist)
-                                                    {
-                                                        minDist = dist;
-                                                        target = seat;
-                                                    }
-                                                }
-                                }
-                                if (target && target->GetBase()->IsWithinDist2d(&m_targets.m_dstPos, GetSpellRadius(m_spellInfo, effIndex, false) * 2)) // now we use *2 because the location of the seat is not correct
-                                    passenger->EnterVehicle(target, 0);
-                                else
-                                {
-                                    passenger->ExitVehicle();
-                                    float x, y, z;
-                                    m_targets.m_dstPos.GetPosition(x, y, z);
-                                    passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
-                                }
-                            }
-                    }
-                    return;
-                }
-                case 64385:                                 // Unusual Compass
-                {
-                    m_caster->SetOrientation(float(urand(0,62832)) / 10000.0f);
-                    WorldPacket data;
-                    m_caster->BuildHeartBeatMsg(&data);
-                    m_caster->SendMessageToSet(&data,true);
-                    return;
-                }
-            }
-
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-            // Charge
-            if (m_spellInfo->SpellFamilyFlags & SPELLFAMILYFLAG_WARRIOR_CHARGE && m_spellInfo->SpellVisual[0] == 867)
-            {
-                int32 chargeBasePoints0 = damage;
-                m_caster->CastCustomSpell(m_caster, 34846, &chargeBasePoints0, NULL, NULL, true);
-
-                //Juggernaut crit bonus
-                if (m_caster->HasAura(64976))
-                    m_caster->CastSpell(m_caster, 65156, true);
-                return;
-            }
-            //Slam
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_SLAM && m_spellInfo->SpellIconID == 559)
-            {
-                int32 bp0 = damage;
-                m_caster->CastCustomSpell(unitTarget, 50783, &bp0, NULL, NULL, true, 0);
-                return;
-            }
-            // Execute
-            if (m_spellInfo->SpellFamilyFlags[EFFECT_0] & SPELLFAMILYFLAG_WARRIOR_EXECUTE)
-            {
-                if (!unitTarget)
-                    return;
-
-                spell_id = 20647;
-
-                int32 rageUsed = std::min<int32>(300 - m_powerCost, m_caster->GetPower(POWER_RAGE));
-                int32 newRage = std::max<int32>(0, m_caster->GetPower(POWER_RAGE) - rageUsed);
-
-                // Sudden Death rage save
-                if (AuraEffect * aurEff = m_caster->GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_GENERIC, 1989, EFFECT_0))
-                {
-                    int32 ragesave = SpellMgr::CalculateSpellEffectAmount(aurEff->GetSpellProto(), EFFECT_1) * 10;
-                    newRage = std::max(newRage, ragesave);
-                }
-
-                m_caster->SetPower(POWER_RAGE, uint32(newRage));
-
-                // Glyph of Execution bonus
-                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58367, EFFECT_0))
-                    rageUsed += aurEff->GetAmount() * 10;
-
-                bp = damage + int32(rageUsed * m_spellInfo->EffectDamageMultiplier[effIndex] + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.2f);
-                break;
-            }
-            // Concussion Blow
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_CONCUSSION_BLOW)
-            {
-                m_damage+= uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
-                return;
-            }
-            switch(m_spellInfo->Id)
-            {
-                // Bloodthirst
-                case 23881:
-                {
-                    m_caster->CastCustomSpell(unitTarget, 23885, &damage, NULL, NULL, true, NULL);
-                    return;
-                }
-            }
-            break;
-        case SPELLFAMILY_WARLOCK:
-            // Life Tap
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARLOCK_LIFETAP)
-            {
-                float spFactor = 0.0f;
-                switch (m_spellInfo->Id)
-                {
-                    case 11689: spFactor = 0.2f; break;
-                    case 27222:
-                    case 57946: spFactor = 0.5f; break;
-                }
-                int32 damage = int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) + (6.3875 * m_spellInfo->baseLevel));
-                int32 mana = int32(damage + (m_caster->ToPlayer()->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+SPELL_SCHOOL_SHADOW) * spFactor));
-
-                if (unitTarget && (int32(unitTarget->GetHealth()) > damage))
-                {
-                    // Shouldn't Appear in Combat Log
-                    unitTarget->ModifyHealth(-damage);
-
-                    // Improved Life Tap mod
-                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 208, 0))
-                        mana = (aurEff->GetAmount() + 100)* mana / 100;
-
-                    m_caster->CastCustomSpell(unitTarget, 31818, &mana, NULL, NULL, true);
-
-                    // Mana Feed
-                    int32 manaFeedVal = 0;
-                    if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_WARLOCK, 1982, 0))
-                        manaFeedVal = aurEff->GetAmount();
-
-                    if (manaFeedVal > 0)
-                    {
-                        manaFeedVal = manaFeedVal * mana / 100;
-                        m_caster->CastCustomSpell(m_caster, 32553, &manaFeedVal, NULL, NULL, true, NULL);
-                    }
-                }
-                else
-                    SendCastResult(SPELL_FAILED_FIZZLE);
-                return;
-            }
-            break;
-        case SPELLFAMILY_DRUID:
-            // Starfall
-            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_DRUID_STARFALL)
-            {
-                //Shapeshifting into an animal form or mounting cancels the effect.
-                if (m_caster->GetCreatureType() == CREATURE_TYPE_BEAST || m_caster->IsMounted())
-                {
-                    if (m_triggeredByAuraSpell)
-                        m_caster->RemoveAurasDueToSpell(m_triggeredByAuraSpell->Id);
-                    return;
-                }
-
-                //Any effect which causes you to lose control of your character will supress the starfall effect.
-                if (m_caster->hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_FLEEING | UNIT_STAT_ROOT | UNIT_STAT_CONFUSED))
-                    return;
-
-                m_caster->CastSpell(unitTarget, damage, true);
-                return;
-            }
-            break;
-        case SPELLFAMILY_PALADIN:
-            // Divine Storm
-            if (m_spellInfo->SpellFamilyFlags[1] & SPELLFAMILYFLAG1_PALADIN_DIVINESTORM && effIndex == 1)
-            {
-                int32 dmg = m_damage * damage / 100;
-                if (!unitTarget)
-                    unitTarget = m_caster;
-                m_caster->CastCustomSpell(unitTarget, 54171, &dmg, 0, 0, true);
-                return;
-            }
-
-            switch(m_spellInfo->Id)
-            {
-                case 31789:                                 // Righteous Defense (step 1)
-                {
-                    // Clear targets for eff 1
-                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        ihit->effectMask &= ~(1<<1);
-
-                    // not empty (checked), copy
-                    Unit::AttackerSet attackers = unitTarget->getAttackers();
-
-                    // selected from list 3
-                    for (uint32 i = 0; i < std::min(size_t(3), attackers.size()); ++i)
-                    {
-                        Unit::AttackerSet::iterator aItr = attackers.begin();
-                        std::advance(aItr, rand() % attackers.size());
-                        AddUnitTarget((*aItr), 1);
-                        attackers.erase(aItr);
-                    }
-
-                    // now let next effect cast spell at each target.
-                    return;
-                }
-            }
-            break;
-        case SPELLFAMILY_SHAMAN:
-            // Cleansing Totem Pulse
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_TOTEM_EFFECTS && m_spellInfo->SpellIconID == 1673)
-            {
-                int32 bp1 = 1;
-                // Cleansing Totem Effect
-                if (unitTarget)
-                    m_caster->CastCustomSpell(unitTarget, 52025, NULL, &bp1, NULL, true, NULL, NULL, m_originalCasterGUID);
-                return;
-            }
-            // Healing Stream Totem
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_HEALING_STREAM)
-            {
-                if (!unitTarget)
-                    return;
-                // Restorative Totems
-                if (Unit *owner = m_caster->GetOwner())
-                    if (AuraEffect *dummy = owner->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 338, 1))
-                        damage += damage * dummy->GetAmount() / 100;
-
-                    m_caster->CastCustomSpell(unitTarget, 52042, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
-                return;
-            }
-            // Mana Spring Totem
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_MANA_SPRING)
-            {
-                if (!unitTarget || unitTarget->getPowerType() != POWER_MANA)
-                    return;
-                m_caster->CastCustomSpell(unitTarget, 52032, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
-                return;
-            }
-            // Lava Lash
-            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_SHAMAN_LAVA_LASH)
-            {
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return;
-
-                if (m_caster->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
-                {
-                    // Damage is increased by 25% if your off-hand weapon is enchanted with Flametongue.
-                    if (m_caster->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 0x200000, 0, 0))
-                        m_damage += m_damage * damage / 100;
-                }
-                return;
-            }
-            break;
-        case SPELLFAMILY_DEATHKNIGHT:
-            // Death strike
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_STRIKE)
-            {
-                uint32 count = unitTarget->GetDiseasesByCaster(m_caster->GetGUID());
-                int32 bp = int32(count * m_caster->CountPctFromMaxHealth(int32(m_spellInfo->EffectDamageMultiplier[0])));
-                // Improved Death Strike
-                if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DEATHKNIGHT, 2751, 0))
-                    bp = int32(bp * (m_caster->CalculateSpellDamage(m_caster, aurEff->GetSpellProto(), 2) + 100.0f) / 100.0f);
-                m_caster->CastCustomSpell(m_caster, 45470, &bp, NULL, NULL, false);
-                return;
-            }
-            // Death Coil
-            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_COIL)
-            {
-                if (m_caster->IsFriendlyTo(unitTarget))
-                {
-                    int32 bp = int32(damage * 1.5f);
-                    m_caster->CastCustomSpell(unitTarget, 47633, &bp, NULL, NULL, true);
-                }
-                else
-                {
-                    int32 bp = damage;
-                    m_caster->CastCustomSpell(unitTarget, 47632, &bp, NULL, NULL, true);
-                }
-                return;
-            }
-            switch (m_spellInfo->Id)
-            {
-            case 49560: // Death Grip
-                Position pos;
-                GetSummonPosition(effIndex, pos);
-                if (Unit *unit = unitTarget->GetVehicleBase()) // what is this for?
-                    unit->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
-                else
-                    unitTarget->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
-                return;
-            case 46584: // Raise Dead
-                if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                    return;
-
-                // Do we have talent Master of Ghouls?
-                if (m_caster->HasAura(52143))
-                    // summon as pet
-                    bp = 52150;
-                else
-                    // or guardian
-                    bp = 46585;
-
-                if (m_targets.HasDst())
-                    targets.setDst(m_targets.m_dstPos);
-                else
-                {
-                    targets.setDst(*m_caster);
-                    // Corpse not found - take reagents (only not triggered cast can take them)
-                    triggered = false;
-                }
-                // Remove cooldown - summon spellls have category
-                m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id, true);
-                spell_id = 48289;
-                break;
-            // Raise dead - take reagents and trigger summon spells
-            case 48289:
-                if (m_targets.HasDst())
-                    targets.setDst(m_targets.m_dstPos);
-
-                spell_id = CalculateDamage(0, NULL);
-                break;
-            }
-            break;
-    }
-
-    //spells triggered by dummy effect should not miss
-    if (spell_id)
-    {
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
-
-        if (!spellInfo)
-        {
-            sLog.outError("EffectDummy of spell %u: triggering unknown spell id %i\n", m_spellInfo->Id, spell_id);
-            return;
-        }
-
-        targets.setUnitTarget(unitTarget);
-        Spell* spell = new Spell(m_caster, spellInfo, triggered, m_originalCasterGUID, true);
-        if (bp) spell->SetSpellValue(SPELLVALUE_BASE_POINT0, bp);
-        spell->prepare(&targets);
-    }
-
-    // pet auras
-    if (PetAura const* petSpell = sSpellMgr.GetPetAura(m_spellInfo->Id,effIndex))
-    {
-        m_caster->AddPetAura(petSpell);
-        return;
-    }
-
-    // normal DB scripted effect
-    sLog.outDebug("Spell ScriptStart spellid %u in EffectDummy(%u)", m_spellInfo->Id, effIndex);
-    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
-
-    // Script based implementation. Must be used only for not good for implementation in core spell effects
-    // So called only for not proccessed cases
-    if (gameObjTarget)
-        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, gameObjTarget);
-    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_UNIT)
-        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, unitTarget->ToCreature());
-    else if (itemTarget)
-        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, itemTarget);
-}
-
-void Spell::EffectTriggerSpellWithValue(SpellEffIndex effIndex)
-{
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerSpellWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    int32 bp = damage;
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastCustomSpell(unitTarget,triggered_spell_id,&bp,&bp,&bp,true);
-}
-
-void Spell::EffectTriggerRitualOfSummoning(SpellEffIndex effIndex)
-{
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerRitualOfSummoning of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    finish();
-
-    m_caster->CastSpell(unitTarget,spellInfo,false);
-}
-
-void Spell::EffectForceCast(SpellEffIndex effIndex)
-{
-      switch(m_spellInfo->Id)
-      {
-               case 66548://Teleport (IC battleground)
-               {
-                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(23472,60.0f,true))
-                       {
-                               float x,y,z,o;
-                               TargetTeleport->GetPosition(x,y,z,o);
-                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
-                                       return;
-                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
-                       }
-                       return;        
-               }
-               case 66549:
-               {
-                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(22515,60.0f,true))
-                       {
-                               float x,y,z,o;
-                               TargetTeleport->GetPosition(x,y,z,o);
-                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
-                                       return;
-                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
-                       }
-                       return;
-               }
-       }
-
-    if (!unitTarget)
-        return;
-
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectForceCast of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    if (damage)
-    {
-        switch(m_spellInfo->Id)
-        {
-                case 66218: //Catapulte
-                if (Vehicle *vehicle = m_caster->GetVehicleKit())
-                    if (Unit *passenger = vehicle->GetPassenger(0))
-                    {
-                        passenger->ExitVehicle();
-                    passenger->AddAura(66251,passenger);
-                        float x, y, z;
-                        m_targets.m_dstPos.GetPosition(x, y, z);
-                        passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
-                    }                    
-                return;    
-            case 66629:
-            case 66638:
-            {
-                if(!(m_caster->GetTypeId()==TYPEID_PLAYER))
-                    return;
-                Player *plr = m_caster->ToPlayer();
-                if (Battleground *bg = plr->GetBattleground())
-                    {
-                        if (bg->GetTypeID(true) == BATTLEGROUND_IC)
-                            bg->EventPlayerCapturedFlag(plr);
-                        return;
-                    }
-                
-                return;
-            }
-            case 52588: // Skeletal Gryphon Escape
-            case 48598: // Ride Flamebringer Cue
-                unitTarget->RemoveAura(damage);
-                break;
-            case 52463: // Hide In Mine Car
-            case 52349: // Overtake
-                unitTarget->CastCustomSpell(unitTarget, spellInfo->Id, &damage, NULL, NULL, true, NULL, NULL, m_originalCasterGUID);
-                return;
-            case 72378: // Blood Nova
-            case 73058: // Blood Nova
-                spellInfo = sSpellMgr.GetSpellForDifficultyFromSpell(spellInfo, m_caster);
-                break;
-        }
-    }
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastSpell(unitTarget, spellInfo, true, NULL, NULL, m_originalCasterGUID);
-}
-
-void Spell::EffectForceCastWithValue(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectForceCastWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-    int32 bp = damage;
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastCustomSpell(unitTarget, spellInfo->Id, &bp, &bp, &bp, true, NULL, NULL, m_originalCasterGUID);
-}
-
-
-void Spell::EffectTriggerSpell(SpellEffIndex effIndex)
-{
-    // only unit case known
-    if (!unitTarget)
-    {
-        if (gameObjTarget || itemTarget)
-            sLog.outError("Spell::EffectTriggerSpell (Spell: %u): Unsupported non-unit case!",m_spellInfo->Id);
-        return;
-    }
-
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-    Unit* originalCaster = NULL;
-
-    // special cases
-    switch(triggered_spell_id)
-    {
-        // Mirror Image
-        case 58832:
-        {
-            // Glyph of Mirror Image
-            if (m_caster->HasAura(63093))
-               m_caster->CastSpell(m_caster, 65047, true); // Mirror Image
-
-            break;
-        }
-        // Vanish (not exist)
-        case 18461:
-        {
-            unitTarget->RemoveMovementImpairingAuras();
-            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
-
-            // if this spell is given to NPC it must handle rest by it's own AI
-            if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-                return;
-
-          // Stealth spell
-			uint32 spellId = 1784;
-			SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-
-			if (!spellInfo)
-                return;
-
-            // reset cooldown on it if needed
-            if (unitTarget->ToPlayer()->HasSpellCooldown(spellId))
-                unitTarget->ToPlayer()->RemoveSpellCooldown(spellId);
-
-            triggered_spell_id =  spellId;
-            return;
-        }
-        // Demonic Empowerment -- succubus
-        case 54437:
-        {
-            unitTarget->RemoveMovementImpairingAuras();
-            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
-            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STUN);
-
-            // Cast Lesser Invisibility
-            triggered_spell_id = 7870;
-            break;
-        }
-        // just skip
-        case 23770:                                         // Sayge's Dark Fortune of *
-            // not exist, common cooldown can be implemented in scripts if need.
-            return;
-        // Brittle Armor - (need add max stack of 24575 Brittle Armor)
-        case 29284:
-        {
-            // Brittle Armor
-            SpellEntry const* spell = sSpellStore.LookupEntry(24575);
-            if (!spell)
-                return;
-
-            for (uint32 j = 0; j < spell->StackAmount; ++j)
-                m_caster->CastSpell(unitTarget, spell->Id, true);
-            return;
-        }
-        // Mercurial Shield - (need add max stack of 26464 Mercurial Shield)
-        case 29286:
-        {
-            // Mercurial Shield
-            SpellEntry const* spell = sSpellStore.LookupEntry(26464);
-            if (!spell)
-                return;
-
-            for (uint32 j = 0; j < spell->StackAmount; ++j)
-                m_caster->CastSpell(unitTarget, spell->Id, true);
-            return;
-        }
-        // Righteous Defense
-        case 31980:
-        {
-            m_caster->CastSpell(unitTarget, 31790, true);
-            return;
-        }
-        // Cloak of Shadows
-        case 35729:
-        {
-            uint32 dispelMask = GetDispellMask(DISPEL_ALL);
-            Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
-            for (Unit::AuraApplicationMap::iterator iter = Auras.begin(); iter != Auras.end();)
-            {
-                // remove all harmful spells on you...
-                SpellEntry const* spell = iter->second->GetBase()->GetSpellProto();
-                if ((spell->DmgClass == SPELL_DAMAGE_CLASS_MAGIC // only affect magic spells
-                    || ((1<<spell->Dispel) & dispelMask))
-                    // ignore positive and passive auras
-                    && !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive())
-                {
-                    m_caster->RemoveAura(iter);
-                }
-                else
-                    iter++;
-            }
-            return;
-        }
-        // Priest Shadowfiend (34433) need apply mana gain trigger aura on pet
-        case 41967:
-        {
-            if (Unit *pet = unitTarget->GetGuardianPet())
-                pet->CastSpell(pet, 28305, true);
-            return;
-        }
-        // Empower Rune Weapon
-        case 53258:
-            return; // skip, hack-added in spell effect
-        // Snake Trap
-        case 57879:
-            originalCaster = m_originalCaster;
-            break;
-        // Coldflame
-        case 33801:
-            return; // just make the core stfu
-    }
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerSpell of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
-        return;
-    }
-
-    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
-    // Needed by freezing arrow and few other spells
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
-        && m_spellInfo->Category == spellInfo->Category)
-        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
-
-    // Note: not exist spells with weapon req. and IsSpellHaveCasterSourceTargets == true
-    // so this just for speedup places in else
-    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
-
-    caster->CastSpell(unitTarget,spellInfo,true, 0, 0, (originalCaster ? originalCaster->GetGUID() : 0));
-}
-
-void Spell::EffectTriggerMissileSpell(SpellEffIndex effIndex)
-{
-    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    // normal case
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
-
-    if (!spellInfo)
-    {
-        sLog.outError("EffectTriggerMissileSpell of spell %u (eff: %u): triggering unknown spell id %u",
-            m_spellInfo->Id,effIndex,triggered_spell_id);
-        return;
-    }
-
-    if (m_CastItem)
-        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
-
-    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
-    // Needed by freezing arrow and few other spells
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
-        && m_spellInfo->Category == spellInfo->Category)
-        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
-
-    float x, y, z;
-    m_targets.m_dstPos.GetPosition(x, y, z);
-    m_caster->CastSpell(x, y, z, spellInfo->Id, true, m_CastItem, 0, m_originalCasterGUID);
-}
-
-void Spell::EffectJump(SpellEffIndex effIndex)
-{
-    if (m_caster->isInFlight())
-        return;
-
-    float x,y,z,o;
-    if (m_targets.getUnitTarget())
-    {
-        m_targets.getUnitTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
-        o = m_caster->GetOrientation();
-    }
-    else if (m_targets.getGOTarget())
-    {
-        m_targets.getGOTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
-        o = m_caster->GetOrientation();
-    }
-    else
-    {
-        sLog.outError("Spell::EffectJump - unsupported target mode for spell ID %u", m_spellInfo->Id);
-        return;
-    }
-
-    float speedXY, speedZ;
-    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
-    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
-}
-
-void Spell::EffectJumpDest(SpellEffIndex effIndex)
-{
-    if (m_caster->isInFlight())
-        return;
-
-    // Init dest coordinates
-    float x,y,z,o;
-    if (m_targets.HasDst())
-    {
-        m_targets.m_dstPos.GetPosition(x, y, z);
-
-        if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DEST_TARGET_BACK)
-        {
-            // explicit cast data from client or server-side cast
-            // some spell at client send caster
-            Unit* pTarget = NULL;
-            if (m_targets.getUnitTarget() && m_targets.getUnitTarget() != m_caster)
-                pTarget = m_targets.getUnitTarget();
-            else if (m_caster->getVictim())
-                pTarget = m_caster->getVictim();
-            else if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                pTarget = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
-
-            o = pTarget ? pTarget->GetOrientation() : m_caster->GetOrientation();
-        }
-        else
-            o = m_caster->GetOrientation();
-    }
-    else
-    {
-        sLog.outError("Spell::EffectJumpDest - unsupported target mode for spell ID %u", m_spellInfo->Id);
-        return;
-    }
-
-    float speedXY, speedZ;
-    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
-    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
-}
-
-void Spell::CalculateJumpSpeeds(uint8 i, float dist, float & speedXY, float & speedZ)
-{
-    if (m_spellInfo->EffectMiscValue[i])
-        speedZ = float(m_spellInfo->EffectMiscValue[i])/10;
-    else if (m_spellInfo->EffectMiscValueB[i])
-        speedZ = float(m_spellInfo->EffectMiscValueB[i])/10;
-    else
-        speedZ = 10.0f;
-    speedXY = dist * 10.0f / speedZ;
-}
-
-void Spell::EffectTeleportUnits(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->isInFlight())
-        return;
-
-    // Pre effects
-    uint8 uiMaxSafeLevel = 0;
-    switch (m_spellInfo->Id)
-    {
-        case 66550:
-            return;
-        case 48129:  // Scroll of Recall
-            uiMaxSafeLevel = 40;
-        case 60320:  // Scroll of Recall II
-            if (!uiMaxSafeLevel)
-                uiMaxSafeLevel = 70;
-        case 60321:  // Scroll of Recal III
-            if (!uiMaxSafeLevel)
-                uiMaxSafeLevel = 80;
-
-            if (unitTarget->getLevel() > uiMaxSafeLevel)
-            {
-                unitTarget->AddAura(60444,unitTarget); //Apply Lost! Aura
-                return;
-            }
-            break;
-    }
-
-    // If not exist data for dest location - return
-    if (!m_targets.HasDst())
-    {
-        sLog.outError("Spell::EffectTeleportUnits - does not have destination for spell ID %u\n", m_spellInfo->Id);
-        return;
-    }
-
-    // Init dest coordinates
-    uint32 mapid = m_targets.m_dstPos.GetMapId();
-    if (mapid == MAPID_INVALID)
-        mapid = unitTarget->GetMapId();
-    float x, y, z, orientation;
-    m_targets.m_dstPos.GetPosition(x, y, z, orientation);
-    if (!orientation && m_targets.getUnitTarget())
-        orientation = m_targets.getUnitTarget()->GetOrientation();
-    sLog.outDebug("Spell::EffectTeleportUnits - teleport unit to %u %f %f %f %f\n", mapid, x, y, z, orientation);
-
-    if (mapid == unitTarget->GetMapId())
-        unitTarget->NearTeleportTo(x, y, z, orientation, unitTarget == m_caster);
-    else if (unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->TeleportTo(mapid, x, y, z, orientation, unitTarget == m_caster ? TELE_TO_SPELL : 0);
-
-    // post effects for TARGET_DST_DB
-    switch (m_spellInfo->Id)
-    {
-        // Dimensional Ripper - Everlook
-        case 23442:
-        {
-            int32 r = irand(0, 119);
-            if (r >= 70)                                  // 7/12 success
-            {
-                if (r < 100)                              // 4/12 evil twin
-                    m_caster->CastSpell(m_caster, 23445, true);
-                else                                        // 1/12 fire
-                    m_caster->CastSpell(m_caster, 23449, true);
-            }
-            return;
-        }
-        // Ultrasafe Transporter: Toshley's Station
-        case 36941:
-        {
-            if (roll_chance_i(50))                        // 50% success
-            {
-                int32 rand_eff = urand(1, 7);
-                switch (rand_eff)
-                {
-                    case 1:
-                        // soul split - evil
-                        m_caster->CastSpell(m_caster, 36900, true);
-                        break;
-                    case 2:
-                        // soul split - good
-                        m_caster->CastSpell(m_caster, 36901, true);
-                        break;
-                    case 3:
-                        // Increase the size
-                        m_caster->CastSpell(m_caster, 36895, true);
-                        break;
-                    case 4:
-                        // Decrease the size
-                        m_caster->CastSpell(m_caster, 36893, true);
-                        break;
-                    case 5:
-                    // Transform
-                    {
-                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                            m_caster->CastSpell(m_caster, 36897, true);
-                        else
-                            m_caster->CastSpell(m_caster, 36899, true);
-                        break;
-                    }
-                    case 6:
-                        // chicken
-                        m_caster->CastSpell(m_caster, 36940, true);
-                        break;
-                    case 7:
-                        // evil twin
-                        m_caster->CastSpell(m_caster, 23445, true);
-                        break;
-                }
-            }
-            return;
-        }
-        // Dimensional Ripper - Area 52
-        case 36890:
-        {
-            if (roll_chance_i(50))                        // 50% success
-            {
-                int32 rand_eff = urand(1, 4);
-                switch (rand_eff)
-                {
-                    case 1:
-                        // soul split - evil
-                        m_caster->CastSpell(m_caster, 36900, true);
-                        break;
-                    case 2:
-                        // soul split - good
-                        m_caster->CastSpell(m_caster, 36901, true);
-                        break;
-                    case 3:
-                        // Increase the size
-                        m_caster->CastSpell(m_caster, 36895, true);
-                        break;
-                    case 4:
-                        // Transform
-                    {
-                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-                            m_caster->CastSpell(m_caster, 36897, true);
-                        else
-                            m_caster->CastSpell(m_caster, 36899, true);
-                        break;
-                    }
-                }
-            }
-            return;
-        }
-    }
-}
-
-void Spell::EffectApplyAura(SpellEffIndex effIndex)
-{
-    if (!m_spellAura || !unitTarget)
-        return;
-    ASSERT(unitTarget == m_spellAura->GetOwner());
-    m_spellAura->_ApplyEffectForTargets(effIndex);
-}
-
-void Spell::EffectApplyAreaAura(SpellEffIndex effIndex)
-{
-    if (!m_spellAura || !unitTarget)
-        return;
-    ASSERT (unitTarget == m_spellAura->GetOwner());
-    m_spellAura->_ApplyEffectForTargets(effIndex);
-}
-
-void Spell::EffectUnlearnSpecialization(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)unitTarget;
-    uint32 spellToUnlearn = m_spellInfo->EffectTriggerSpell[effIndex];
-
-    _player->removeSpell(spellToUnlearn);
-
-    sLog.outDebug("Spell: Player %u has unlearned spell %u from NpcGUID: %u", _player->GetGUIDLow(), spellToUnlearn, m_caster->GetGUIDLow());
-}
-
-void Spell::EffectPowerDrain(SpellEffIndex effIndex)
-{
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
-        return;
-
-    // add spell damage bonus
-    damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, uint32(damage), SPELL_DIRECT_DAMAGE);
-
-    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
-    int32 power = damage;
-    if (powerType == POWER_MANA)
-        power -= unitTarget->GetSpellCritDamageReduction(power);
-
-    int32 newDamage = -(unitTarget->ModifyPower(powerType, -int32(power)));
-
-    float gainMultiplier = 0.0f;
-
-    // Don`t restore from self drain
-    if (m_caster != unitTarget)
-    {
-        gainMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
-
-        int32 gain = int32(newDamage * gainMultiplier);
-
-        m_caster->EnergizeBySpell(m_caster, m_spellInfo->Id, gain, powerType);
-    }
-    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, gainMultiplier);
-}
-
-void Spell::EffectSendEvent(SpellEffIndex effIndex)
-{
-    /*
-    we do not handle a flag dropping or clicking on flag in battleground by sendevent system
-    */
-    sLog.outDebug("Spell ScriptStart %u for spellid %u in EffectSendEvent ", m_spellInfo->EffectMiscValue[effIndex], m_spellInfo->Id);
-
-    Object *pTarget;
-    if (focusObject)
-        pTarget = focusObject;
-    else if (unitTarget)
-        pTarget = unitTarget;
-    else if (gameObjTarget)
-        pTarget = gameObjTarget;
-    else
-        pTarget = NULL;
-
-    m_caster->GetMap()->ScriptsStart(sEventScripts, m_spellInfo->EffectMiscValue[effIndex], m_caster, pTarget);
-}
-
-void Spell::EffectPowerBurn(SpellEffIndex effIndex)
-{
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
-        return;
-
-    // burn x% of target's mana, up to maximum of 2x% of caster's mana (Mana Burn)
-    if (m_spellInfo->ManaCostPercentage)
-    {
-        int32 maxDamage = m_caster->GetMaxPower(powerType) * damage * 2 / 100;
-        damage = unitTarget->GetMaxPower(powerType) * damage / 100;
-        damage = std::min(damage, maxDamage);
-    }
-
-    int32 power = damage;
-    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
-    if (powerType == POWER_MANA)
-        power -= unitTarget->GetSpellCritDamageReduction(power);
-
-    int32 newDamage = -(unitTarget->ModifyPower(powerType, -power));
-
-    // NO - Not a typo - EffectPowerBurn uses effect value multiplier - not effect damage multiplier
-    float dmgMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
-
-    // add log data before multiplication (need power amount, not damage)
-    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, 0.0f);
-
-    newDamage = int32(newDamage * dmgMultiplier);
-
-    m_damage += newDamage;
-}
-
-void Spell::EffectHeal(SpellEffIndex /*effIndex*/)
-{
-}
-
-void Spell::SpellDamageHeal(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->isAlive() && damage >= 0)
-    {
-        // Try to get original caster
-        Unit *caster = m_originalCasterGUID ? m_originalCaster : m_caster;
-
-        // Skip if m_originalCaster not available
-        if (!caster)
-            return;
-
-        int32 addhealth = damage;
-
-        // Vessel of the Naaru (Vial of the Sunwell trinket)
-        if (m_spellInfo->Id == 45064)
-        {
-            // Amount of heal - depends from stacked Holy Energy
-            int damageAmount = 0;
-            if (AuraEffect const * aurEff = m_caster->GetAuraEffect(45062, 0))
-            {
-                damageAmount+= aurEff->GetAmount();
-                m_caster->RemoveAurasDueToSpell(45062);
-            }
-
-            addhealth += damageAmount;
-        }
-        // Swiftmend - consumes Regrowth or Rejuvenation
-        else if (m_spellInfo->TargetAuraState == AURA_STATE_SWIFTMEND && unitTarget->HasAuraState(AURA_STATE_SWIFTMEND, m_spellInfo, m_caster))
-        {
-            Unit::AuraEffectList const& RejorRegr = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
-            // find most short by duration
-            AuraEffect *targetAura = NULL;
-            for (Unit::AuraEffectList::const_iterator i = RejorRegr.begin(); i != RejorRegr.end(); ++i)
-            {
-                if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID
-                    && (*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x50)
-                {
-                    if (!targetAura || (*i)->GetBase()->GetDuration() < targetAura->GetBase()->GetDuration())
-                        targetAura = *i;
-                }
-            }
-
-            if (!targetAura)
-            {
-                sLog.outError("Target(GUID:" UI64FMTD ") has aurastate AURA_STATE_SWIFTMEND but no matching aura.", unitTarget->GetGUID());
-                return;
-            }
-
-            int32 tickheal = targetAura->GetAmount();
-            if (Unit* auraCaster = targetAura->GetCaster())
-                tickheal = auraCaster->SpellHealingBonus(unitTarget, targetAura->GetSpellProto(), tickheal, DOT);
-            //int32 tickheal = targetAura->GetSpellProto()->EffectBasePoints[idx] + 1;
-            //It is said that talent bonus should not be included
-
-            int32 tickcount = 0;
-            // Rejuvenation
-            if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x10)
-                tickcount = 4;
-            // Regrowth
-            else // if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x40)
-                tickcount = 6;
-
-            addhealth += tickheal * tickcount;
-
-            // Glyph of Swiftmend
-            if (!caster->HasAura(54824))
-                unitTarget->RemoveAura(targetAura->GetId(), targetAura->GetCasterGUID());
-
-            //addhealth += tickheal * tickcount;
-            //addhealth = caster->SpellHealingBonus(m_spellInfo, addhealth,HEAL, unitTarget);
-        }
-        // Glyph of Nourish
-        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x2000000)
-        {
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
-
-            if (AuraEffect const* aurEff = m_caster->GetAuraEffect(62971, 0))
-            {
-                Unit::AuraEffectList const& Periodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
-                for (Unit::AuraEffectList::const_iterator i = Periodic.begin(); i != Periodic.end(); ++i)
-                {
-                    if (m_caster->GetGUID() == (*i)->GetCasterGUID())
-                        addhealth += addhealth * aurEff->GetAmount() / 100;
-                }
-            }
-        }
-        // Lifebloom - final heal coef multiplied by original DoT stack
-        else if (m_spellInfo->Id == 33778)
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL, m_spellValue->EffectBasePoints[1]);
-        // Riptide - increase healing done by Chain Heal
-        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x100)
-        {
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
-            if (AuraEffect * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0, 0, 0x10, m_originalCasterGUID))
-            {
-                addhealth = int32(addhealth * 1.25f);
-                // consume aura
-                unitTarget->RemoveAura(aurEff->GetBase());
-            }
-        }
-        // Death Pact - return pct of max health to caster
-        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, int32(caster->CountPctFromMaxHealth(damage)), HEAL);
-        else
-            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
-
-        // Remove Grievious bite if fully healed
-        if (unitTarget->HasAura(48920) && (unitTarget->GetHealth() + addhealth >= unitTarget->GetMaxHealth()))
-            unitTarget->RemoveAura(48920);
-
-        m_damage -= addhealth;
-    }
-}
-
-void Spell::EffectHealPct(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
-        return;
-
-    // Skip if m_originalCaster not available
-    if (!m_originalCaster)
-        return;
-
-    // Rune Tap - Party
-    if (m_spellInfo->Id == 59754 && unitTarget == m_caster)
-        return;
-
-    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, unitTarget->CountPctFromMaxHealth(damage), HEAL);
-}
-
-void Spell::EffectHealMechanical(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
-        return;
-
-    // Skip if m_originalCaster not available
-    if (!m_originalCaster)
-        return;
-
-    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, uint32(damage), HEAL);
-}
-
-void Spell::EffectHealthLeech(SpellEffIndex effIndex)
-{
-    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
-        return;
-
-    sLog.outDebug("HealthLeech :%i", damage);
-
-    float healMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
-
-    m_damage += damage;
-    // get max possible damage, don't count overkill for heal
-    uint32 healthGain = uint32(-unitTarget->GetHealthGain(-damage) * healMultiplier);
-
-    if (m_caster->isAlive())
-    {
-        healthGain = m_caster->SpellHealingBonus(m_caster, m_spellInfo, healthGain, HEAL);
-        m_caster->HealBySpell(m_caster, m_spellInfo, uint32(healthGain));
-    }
-}
-
-void Spell::DoCreateItem(uint32 /*i*/, uint32 itemtype)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* player = (Player*)unitTarget;
-
-    uint32 newitemid = itemtype;
-    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(newitemid);
-    if (!pProto)
-    {
-        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-        return;
-    }
-
-    // bg reward have some special in code work
-    uint32 bgType = 0;
-    switch(m_spellInfo->Id)
-    {
-        case SPELL_AV_MARK_WINNER:
-        case SPELL_AV_MARK_LOSER:
-            bgType = BATTLEGROUND_AV;
-            break;
-        case SPELL_WS_MARK_WINNER:
-        case SPELL_WS_MARK_LOSER:
-            bgType = BATTLEGROUND_WS;
-            break;
-        case SPELL_AB_MARK_WINNER:
-        case SPELL_AB_MARK_LOSER:
-            bgType = BATTLEGROUND_AB;
-            break;
-        default:
-            break;
-    }
-
-    uint32 num_to_add = damage;
-
-    if (num_to_add < 1)
-        num_to_add = 1;
-    if (num_to_add > pProto->GetMaxStackSize())
-        num_to_add = pProto->GetMaxStackSize();
-
-    // init items_count to 1, since 1 item will be created regardless of specialization
-    int items_count=1;
-    // the chance to create additional items
-    float additionalCreateChance=0.0f;
-    // the maximum number of created additional items
-    uint8 additionalMaxNum=0;
-    // get the chance and maximum number for creating extra items
-    if (canCreateExtraItems(player, m_spellInfo->Id, additionalCreateChance, additionalMaxNum))
-    {
-        // roll with this chance till we roll not to create or we create the max num
-        while (roll_chance_f(additionalCreateChance) && items_count <= additionalMaxNum)
-            ++items_count;
-    }
-
-    // really will be created more items
-    num_to_add *= items_count;
-
-    // can the player store the new item?
-    ItemPosCountVec dest;
-    uint32 no_space = 0;
-    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, num_to_add, &no_space);
-    if (msg != EQUIP_ERR_OK)
-    {
-        // convert to possible store amount
-        if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
-            num_to_add -= no_space;
-        else
-        {
-            // if not created by another reason from full inventory or unique items amount limitation
-            player->SendEquipError(msg, NULL, NULL, newitemid);
-            return;
-        }
-    }
-
-    if (num_to_add)
-    {
-        // create the new item and store it
-        Item* pItem = player->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
-
-        // was it successful? return error if not
-        if (!pItem)
-        {
-            player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-            return;
-        }
-
-        // set the "Crafted by ..." property of the item
-        if (pItem->GetProto()->Class != ITEM_CLASS_CONSUMABLE && pItem->GetProto()->Class != ITEM_CLASS_QUEST && newitemid != 6265 && newitemid != 6948)
-            pItem->SetUInt32Value(ITEM_FIELD_CREATOR, player->GetGUIDLow());
-
-        // send info to the client
-        if (pItem)
-            player->SendNewItem(pItem, num_to_add, true, bgType == 0);
-
-        // we succeeded in creating at least one item, so a levelup is possible
-        if (bgType == 0)
-            player->UpdateCraftSkill(m_spellInfo->Id);
-    }
-
-/*
-    // for battleground marks send by mail if not add all expected
-    if (no_space > 0 && bgType)
-    {
-        if (Battleground* bg = sBattlegroundMgr.GetBattlegroundTemplate(BattlegroundTypeId(bgType)))
-            bg->SendRewardMarkByMail(player, newitemid, no_space);
-    }
-*/
-}
-
-void Spell::EffectCreateItem(SpellEffIndex effIndex)
-{
-    DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
-    ExecuteLogEffectCreateItem(effIndex, m_spellInfo->EffectItemType[effIndex]);
-}
-
-void Spell::EffectCreateItem2(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player* player = (Player*)m_caster;
-
-    uint32 item_id = m_spellInfo->EffectItemType[effIndex];
-
-    if (item_id)
-        DoCreateItem(effIndex, item_id);
-
-    // special case: fake item replaced by generate using spell_loot_template
-    if (IsLootCraftingSpell(m_spellInfo))
-    {
-        if (item_id)
-        {
-            if (!player->HasItemCount(item_id, 1))
-                return;
-
-            // remove reagent
-            uint32 count = 1;
-            player->DestroyItemCount(item_id, count, true);
-
-            // create some random items
-            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
-        }
-        else
-            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);    // create some random items
-    }
-    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
-}
-
-void Spell::EffectCreateRandomItem(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player* player = (Player*)m_caster;
-
-    // create some random items
-    player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
-    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
-}
-
-void Spell::EffectPersistentAA(SpellEffIndex effIndex)
-{
-    if (!m_spellAura)
-    {
-        float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-        if (Player* modOwner = m_originalCaster->GetSpellModOwner())
-            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, radius);
-
-        Unit *caster = m_caster->GetEntry() == WORLD_TRIGGER ? m_originalCaster : m_caster;
-        // Caster not in world, might be spell triggered from aura removal
-        if (!caster->IsInWorld())
-            return;
-        DynamicObject* dynObj = new DynamicObject;
-        if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), caster, m_spellInfo->Id, m_targets.m_dstPos, radius, false))
-        {
-            delete dynObj;
-            return;
-        }
-        caster->AddDynObject(dynObj);
-        dynObj->GetMap()->Add(dynObj);
-
-        if (Aura * aura = Aura::TryCreate(m_spellInfo, dynObj, caster, &m_spellValue->EffectBasePoints[0]))
-            m_spellAura = aura;
-        else
-        {
-            ASSERT(false);
-            return;
-        }
-        m_spellAura->_RegisterForTargets();
-    }
-    ASSERT(m_spellAura->GetDynobjOwner());
-    m_spellAura->_ApplyEffectForTargets(effIndex);
-}
-
-void Spell::EffectEnergize(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (!unitTarget->isAlive())
-        return;
-
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    // Some level depends spells
-    int level_multiplier = 0;
-    int level_diff = 0;
-    switch (m_spellInfo->Id)
-    {
-        case 9512:                                          // Restore Energy
-            level_diff = m_caster->getLevel() - 40;
-            level_multiplier = 2;
-            break;
-        case 24571:                                         // Blood Fury
-            level_diff = m_caster->getLevel() - 60;
-            level_multiplier = 10;
-            break;
-        case 24532:                                         // Burst of Energy
-            level_diff = m_caster->getLevel() - 60;
-            level_multiplier = 4;
-            break;
-        case 31930:                                         // Judgements of the Wise
-        case 63375:                                         // Improved Stormstrike
-        case 68082:                                         // Glyph of Seal of Command
-            damage = damage * unitTarget->GetCreateMana() / 100;
-            break;
-        case 48542:                                         // Revitalize
-            damage = damage * unitTarget->GetMaxPower(power) / 100;
-            break;
-        default:
-            break;
-    }
-
-    if (level_diff > 0)
-        damage -= level_multiplier * level_diff;
-
-    if (damage < 0)
-        return;
-
-    if (unitTarget->GetMaxPower(power) == 0)
-        return;
-
-    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, damage, power);
-
-    // Mad Alchemist's Potion
-    if (m_spellInfo->Id == 45051)
-    {
-        // find elixirs on target
-        bool guardianFound = false;
-        bool battleFound = false;
-        Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
-        for (Unit::AuraApplicationMap::iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
-        {
-            uint32 spell_id = itr->second->GetBase()->GetId();
-            if (!guardianFound)
-                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_GUARDIAN))
-                    guardianFound = true;
-            if (!battleFound)
-                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_BATTLE))
-                    battleFound = true;
-            if (battleFound && guardianFound)
-                break;
-        }
-
-        // get all available elixirs by mask and spell level
-        std::set<uint32> avalibleElixirs;
-        if (!guardianFound)
-            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_GUARDIAN, avalibleElixirs);
-        if (!battleFound)
-            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_BATTLE, avalibleElixirs);
-        for (std::set<uint32>::iterator itr = avalibleElixirs.begin(); itr != avalibleElixirs.end() ;)
-        {
-            SpellEntry const *spellInfo = sSpellStore.LookupEntry(*itr);
-            if (spellInfo->spellLevel < m_spellInfo->spellLevel || spellInfo->spellLevel > unitTarget->getLevel())
-                avalibleElixirs.erase(itr++);
-            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_SHATTRATH))
-                avalibleElixirs.erase(itr++);
-            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_UNSTABLE))
-                avalibleElixirs.erase(itr++);
-            else
-                ++itr;
-        }
-
-        if (!avalibleElixirs.empty())
-        {
-            // cast random elixir on target
-            uint32 rand_spell = urand(0,avalibleElixirs.size()-1);
-            std::set<uint32>::iterator itr = avalibleElixirs.begin();
-            std::advance(itr, rand_spell);
-            m_caster->CastSpell(unitTarget,*itr,true,m_CastItem);
-        }
-    }
-}
-
-void Spell::EffectEnergizePct(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (!unitTarget->isAlive())
-        return;
-
-    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
-        return;
-
-    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
-
-    uint32 maxPower = unitTarget->GetMaxPower(power);
-    if (maxPower == 0)
-        return;
-
-    uint32 gain = damage * maxPower / 100;
-    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, gain, power);
-}
-
-void Spell::SendLoot(uint64 guid, LootType loottype)
-{
-    Player* player = (Player*)m_caster;
-    if (!player)
-        return;
-
-    if (gameObjTarget)
-    {
-        if (sScriptMgr.OnGossipHello(player, gameObjTarget))
-            return;
-
-        switch (gameObjTarget->GetGoType())
-        {
-            case GAMEOBJECT_TYPE_DOOR:
-            case GAMEOBJECT_TYPE_BUTTON:
-                gameObjTarget->UseDoorOrButton();
-                player->GetMap()->ScriptsStart(sGameObjectScripts, gameObjTarget->GetDBTableGUIDLow(), player, gameObjTarget);
-                return;
-
-            case GAMEOBJECT_TYPE_QUESTGIVER:
-                // start or end quest
-                player->PrepareQuestMenu(guid);
-                player->SendPreparedQuest(guid);
-                return;
-
-            case GAMEOBJECT_TYPE_SPELL_FOCUS:
-                // triggering linked GO
-                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->spellFocus.linkedTrapId)
-                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
-                return;
-
-            case GAMEOBJECT_TYPE_GOOBER:
-                gameObjTarget->Use(m_caster);
-                return;
-
-            case GAMEOBJECT_TYPE_CHEST:
-                // TODO: possible must be moved to loot release (in different from linked triggering)
-                if (gameObjTarget->GetGOInfo()->chest.eventId)
-                {
-                    sLog.outDebug("Chest ScriptStart id %u for GO %u", gameObjTarget->GetGOInfo()->chest.eventId,gameObjTarget->GetDBTableGUIDLow());
-                    player->GetMap()->ScriptsStart(sEventScripts, gameObjTarget->GetGOInfo()->chest.eventId, player, gameObjTarget);
-                }
-
-                // triggering linked GO
-                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->chest.linkedTrapId)
-                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
-
-                // Don't return, let loots been taken
-            default:
-                break;
-        }
-    }
-
-    // Send loot
-    player->SendLoot(guid, loottype);
-}
-
-void Spell::EffectOpenLock(SpellEffIndex effIndex)
-{
-    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
-    {
-        sLog.outDebug("WORLD: Open Lock - No Player Caster!");
-        return;
-    }
-
-    Player* player = (Player*)m_caster;
-
-    uint32 lockId = 0;
-    uint64 guid = 0;
-
-    // Get lockId
-    if (gameObjTarget)
-    {
-        GameObjectInfo const* goInfo = gameObjTarget->GetGOInfo();
-        // Arathi Basin banner opening !
-        if ((goInfo->type == GAMEOBJECT_TYPE_BUTTON && goInfo->button.noDamageImmune) ||
-            (goInfo->type == GAMEOBJECT_TYPE_GOOBER && goInfo->goober.losOK))
-        {
-            //CanUseBattlegroundObject() already called in CheckCast()
-            // in battleground check
-            if (Battleground *bg = player->GetBattleground())
-          {
-        bg->EventPlayerClickedOnFlag(player, gameObjTarget);
-        return;
-          }
-        }
-        else if (goInfo->type == GAMEOBJECT_TYPE_FLAGSTAND)
-        {
-            //CanUseBattlegroundObject() already called in CheckCast()
-            // in battleground check
-            if (Battleground *bg = player->GetBattleground())
-            {
-                if (bg->GetTypeID(true) == BATTLEGROUND_EY)
-                    bg->EventPlayerClickedOnFlag(player, gameObjTarget);
-                return;
-            }
-        }else if (m_spellInfo->Id == 1842 && gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_TRAP && gameObjTarget->GetOwner())
-        {
-            gameObjTarget->SetLootState(GO_JUST_DEACTIVATED);
-            return;
-        }
-        // TODO: Add script for spell 41920 - Filling, becouse server it freze when use this spell
-        // handle outdoor pvp object opening, return true if go was registered for handling
-        // these objects must have been spawned by outdoorpvp!
-        else if (gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
-            return;
-        lockId = goInfo->GetLockId();
-        guid = gameObjTarget->GetGUID();
-    }
-    else if (itemTarget)
-    {
-        lockId = itemTarget->GetProto()->LockID;
-        guid = itemTarget->GetGUID();
-    }
-    else
-    {
-        sLog.outDebug("WORLD: Open Lock - No GameObject/Item Target!");
-        return;
-    }
-
-    SkillType skillId = SKILL_NONE;
-    int32 reqSkillValue = 0;
-    int32 skillValue;
-
-    SpellCastResult res = CanOpenLock(effIndex, lockId, skillId, reqSkillValue, skillValue);
-    if (res != SPELL_CAST_OK)
-    {
-        SendCastResult(res);
-        return;
-    }
-
-    if (gameObjTarget)
-        SendLoot(guid, LOOT_SKINNING);
-    else
-        itemTarget->SetFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_UNLOCKED);
-
-    // not allow use skill grow at item base open
-    if (!m_CastItem && skillId != SKILL_NONE)
-    {
-        // update skill if really known
-        if (uint32 pureSkillValue = player->GetPureSkillValue(skillId))
-        {
-            if (gameObjTarget)
-            {
-                // Allow one skill-up until respawned
-                if (!gameObjTarget->IsInSkillupList(player->GetGUIDLow()) &&
-                    player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue))
-                    gameObjTarget->AddToSkillupList(player->GetGUIDLow());
-            }
-            else if (itemTarget)
-            {
-                // Do one skill-up
-                player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue);
-            }
-        }
-    }
-    ExecuteLogEffectOpenLock(effIndex, gameObjTarget ? (Object*)gameObjTarget : (Object*)itemTarget);
-}
-
-void Spell::EffectSummonChangeItem(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *player = (Player*)m_caster;
-
-    // applied only to using item
-    if (!m_CastItem)
-        return;
-
-    // ... only to item in own inventory/bank/equip_slot
-    if (m_CastItem->GetOwnerGUID() != player->GetGUID())
-        return;
-
-    uint32 newitemid = m_spellInfo->EffectItemType[effIndex];
-    if (!newitemid)
-        return;
-
-    uint16 pos = m_CastItem->GetPos();
-
-    Item *pNewItem = Item::CreateItem(newitemid, 1, player);
-    if (!pNewItem)
-        return;
-
-    for (uint8 j = PERM_ENCHANTMENT_SLOT; j <= TEMP_ENCHANTMENT_SLOT; ++j)
-        if (m_CastItem->GetEnchantmentId(EnchantmentSlot(j)))
-            pNewItem->SetEnchantment(EnchantmentSlot(j), m_CastItem->GetEnchantmentId(EnchantmentSlot(j)), m_CastItem->GetEnchantmentDuration(EnchantmentSlot(j)), m_CastItem->GetEnchantmentCharges(EnchantmentSlot(j)));
-
-    if (m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) < m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY))
-    {
-        double loosePercent = 1 - m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) / double(m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY));
-        player->DurabilityLoss(pNewItem, loosePercent);
-    }
-
-    if (player->IsInventoryPos(pos))
-    {
-        ItemPosCountVec dest;
-        uint8 msg = player->CanStoreItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
-        if (msg == EQUIP_ERR_OK)
-        {
-            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
-
-            // prevent crash at access and unexpected charges counting with item update queue corrupt
-            if (m_CastItem == m_targets.getItemTarget())
-                m_targets.setItemTarget(NULL);
-
-            m_CastItem = NULL;
-
-            player->StoreItem(dest, pNewItem, true);
-            return;
-        }
-    }
-    else if (player->IsBankPos(pos))
-    {
-        ItemPosCountVec dest;
-        uint8 msg = player->CanBankItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
-        if (msg == EQUIP_ERR_OK)
-        {
-            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
-
-            // prevent crash at access and unexpected charges counting with item update queue corrupt
-            if (m_CastItem == m_targets.getItemTarget())
-                m_targets.setItemTarget(NULL);
-
-            m_CastItem = NULL;
-
-            player->BankItem(dest, pNewItem, true);
-            return;
-        }
-    }
-    else if (player->IsEquipmentPos(pos))
-    {
-        uint16 dest;
-
-        player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
-
-        uint8 msg = player->CanEquipItem(m_CastItem->GetSlot(), dest, pNewItem, true);
-
-        if (msg == EQUIP_ERR_OK || msg == EQUIP_ERR_CANT_DO_RIGHT_NOW)
-        {
-            if (msg == EQUIP_ERR_CANT_DO_RIGHT_NOW) dest = EQUIPMENT_SLOT_MAINHAND;
-
-            // prevent crash at access and unexpected charges counting with item update queue corrupt
-            if (m_CastItem == m_targets.getItemTarget())
-                m_targets.setItemTarget(NULL);
-
-            m_CastItem = NULL;
-
-            player->EquipItem(dest, pNewItem, true);
-            player->AutoUnequipOffhandIfNeed();
-            return;
-        }
-    }
-
-    // fail
-    delete pNewItem;
-}
-
-void Spell::EffectProficiency(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player *p_target = (Player*)unitTarget;
-
-    uint32 subClassMask = m_spellInfo->EquippedItemSubClassMask;
-    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON && !(p_target->GetWeaponProficiency() & subClassMask))
-    {
-        p_target->AddWeaponProficiency(subClassMask);
-        p_target->SendProficiency(ITEM_CLASS_WEAPON, p_target->GetWeaponProficiency());
-    }
-    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_ARMOR && !(p_target->GetArmorProficiency() & subClassMask))
-    {
-        p_target->AddArmorProficiency(subClassMask);
-        p_target->SendProficiency(ITEM_CLASS_ARMOR, p_target->GetArmorProficiency());
-    }
-}
-
-void Spell::EffectSummonType(SpellEffIndex effIndex)
-{
-    uint32 entry = m_spellInfo->EffectMiscValue[effIndex];
-    if (!entry)
-        return;
-
-    SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(m_spellInfo->EffectMiscValueB[effIndex]);
-    if (!properties)
-    {
-        sLog.outError("EffectSummonType: Unhandled summon type %u", m_spellInfo->EffectMiscValueB[effIndex]);
-        return;
-    }
-
-    if (!m_originalCaster)
-        return;
-
-    int32 duration = GetSpellDuration(m_spellInfo);
-    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
-        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
-
-    Position pos;
-    GetSummonPosition(effIndex, pos);
-
-    /*//totem must be at same Z in case swimming caster and etc.
-        if (fabs(z - m_caster->GetPositionZ()) > 5)
-            z = m_caster->GetPositionZ();
-
-    uint8 level = m_caster->getLevel();
-
-    // level of creature summoned using engineering item based at engineering skill level
-    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_CastItem)
-    {
-        ItemPrototype const *proto = m_CastItem->GetProto();
-        if (proto && proto->RequiredSkill == SKILL_ENGINERING)
-        {
-            uint16 skill202 = m_caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING);
-            if (skill202)
-                level = skill202/5;
-        }
-    }*/
-
-    TempSummon *summon = NULL;
-
-    switch (properties->Category)
-    {
-        default:
-            if (properties->Flags & 512)
-            {
-                SummonGuardian(effIndex, entry, properties);
-                break;
-            }
-            switch (properties->Type)
-            {
-                case SUMMON_TYPE_PET:
-                case SUMMON_TYPE_GUARDIAN:
-                case SUMMON_TYPE_GUARDIAN2:
-                case SUMMON_TYPE_MINION:
-                    SummonGuardian(effIndex, entry, properties);
-                    break;
-                case SUMMON_TYPE_VEHICLE:
-                case SUMMON_TYPE_VEHICLE2:
-                    if (m_originalCaster)
-                        summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-                    break;
-                case SUMMON_TYPE_TOTEM:
-                {
-                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-                    if (!summon || !summon->isTotem())
-                        return;
-
-                    if (damage)                                            // if not spell info, DB values used
-                    {
-                        summon->SetMaxHealth(damage);
-                        summon->SetHealth(damage);
-                    }
-
-                    //summon->SetUInt32Value(UNIT_CREATED_BY_SPELL,m_spellInfo->Id);
-
-                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER
-                        && properties->Slot >= SUMMON_SLOT_TOTEM
-                        && properties->Slot < MAX_TOTEM_SLOT)
-                    {
-                        // set display id depending on race
-                        uint32 displayId = m_originalCaster->GetModelForTotem(PlayerTotemType(properties->Id));
-                        summon->SetNativeDisplayId(displayId);
-                        summon->SetDisplayId(displayId);
-
-                        //summon->SendUpdateToPlayerm_originalCaster->ToPlayer();
-                        WorldPacket data(SMSG_TOTEM_CREATED, 1+8+4+4);
-                        data << uint8(properties->Slot-1);
-                        data << uint64(m_originalCaster->GetGUID());
-                        data << uint32(duration);
-                        data << uint32(m_spellInfo->Id);
-                        m_originalCaster->ToPlayer()->SendDirectMessage(&data);
-                    }
-                    break;
-                }
-                case SUMMON_TYPE_MINIPET:
-                {
-                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-                    if (!summon || !summon->HasUnitTypeMask(UNIT_MASK_MINION))
-                        return;
-
-                    //summon->InitPetCreateSpells();                         // e.g. disgusting oozeling has a create spell as summon...
-                    summon->SelectLevel(summon->GetCreatureInfo());       // some summoned creaters have different from 1 DB data for level/hp
-                    summon->SetUInt32Value(UNIT_NPC_FLAGS, summon->GetCreatureInfo()->npcflag);
-
-                    summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-
-                    summon->AI()->EnterEvadeMode();
-
-                    std::string name = m_originalCaster->GetName();
-                    name.append(petTypeSuffix[3]);
-                    summon->SetName(name);
-                    break;
-                }
-                default:
-                {
-                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-
-                    uint32 amount = damage > 0 ? damage : 1;
-                    if (m_spellInfo->Id == 18662) // Curse of Doom
-                        amount = 1;
-
-                    for (uint32 count = 0; count < amount; ++count)
-                    {
-                        GetSummonPosition(effIndex, pos, radius, count);
-
-                        TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
-
-                        summon = m_originalCaster->SummonCreature(entry, pos, summonType, duration);
-                        if (!summon)
-                            continue;
-                        if (properties->Category == SUMMON_CATEGORY_ALLY)
-                        {
-                            summon->SetUInt64Value(UNIT_FIELD_SUMMONEDBY, m_originalCaster->GetGUID());
-                            summon->setFaction(m_originalCaster->getFaction());
-                            summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-                        }
-                        ExecuteLogEffectSummonObject(effIndex, summon);
-                    }
-                    return;
-                }
-            }//switch
-            break;
-        case SUMMON_CATEGORY_PET:
-            SummonGuardian(effIndex, entry, properties);
-            break;
-        case SUMMON_CATEGORY_PUPPET:
-            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
-            break;
-        case SUMMON_CATEGORY_VEHICLE:
-        {
-            float x, y, z;
-            m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
-            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_caster);
-            if (!summon || !summon->IsVehicle())
-                return;
-
-            if (m_spellInfo->EffectBasePoints[effIndex])
-            {
-                SpellEntry const *spellProto = sSpellStore.LookupEntry(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
-                if (spellProto)
-                    m_caster->CastSpell(summon, spellProto, true);
-            }
-
-            m_caster->EnterVehicle(summon->GetVehicleKit());
-            break;
-        }
-    }
-
-    if (summon)
-    {
-        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-        summon->SetCreatorGUID(m_originalCaster->GetGUID());
-        ExecuteLogEffectSummonObject(effIndex, summon);
-    }
-}
-
-void Spell::EffectLearnSpell(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-    {
-        if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            EffectLearnPetSpell(effIndex);
-
-        return;
-    }
-
-    Player *player = (Player*)unitTarget;
-
-    uint32 spellToLearn = (m_spellInfo->Id == 483 || m_spellInfo->Id == 55884) ? damage : m_spellInfo->EffectTriggerSpell[effIndex];
-    player->learnSpell(spellToLearn, false);
-
-    sLog.outDebug("Spell: Player %u has learned spell %u from NpcGUID=%u", player->GetGUIDLow(), spellToLearn, m_caster->GetGUIDLow());
-}
-
-typedef std::list< std::pair<uint32, uint64> > DispelList;
-typedef std::list< std::pair<Aura *, uint8> > DispelChargesList;
-void Spell::EffectDispel(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    DispelChargesList dispel_list;
-
-    // Create dispel mask by dispel type
-    uint32 dispel_type = m_spellInfo->EffectMiscValue[effIndex];
-    uint32 dispelMask  = GetDispellMask(DispelType(dispel_type));
-
-    // we should not be able to dispel diseases if the target is affected by unholy blight
-    if (dispelMask & (1 << DISPEL_DISEASE) && unitTarget->HasAura(50536))
-        dispelMask &= ~(1 << DISPEL_DISEASE);
-
-    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
-    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        Aura * aura = itr->second;
-        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
-        if (!aurApp)
-            continue;
-
-        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
-        {
-            if (aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
-            {
-                bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR_EX_NEGATIVE)) : false;
-
-                // do not remove positive auras if friendly target
-                //               negative auras if non-friendly target
-                if (positive == unitTarget->IsFriendlyTo(m_caster))
-                    continue;
-            }
-
-            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
-            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
-            // Polymorph instead of 1 / (5 + 1) -> 16%.
-            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
-            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
-            if (charges > 0)
-                dispel_list.push_back(std::make_pair(aura, charges));
-        }
-    }
-
-    if (dispel_list.empty())
-        return;
-
-    // Ok if exist some buffs for dispel try dispel it
-    uint32 failCount = 0;
-    DispelList success_list;
-    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
-    // dispel N = damage buffs (or while exist buffs for dispel)
-    for (int32 count = 0; count < damage && !dispel_list.empty();)
-    {
-        // Random select buff for dispel
-        DispelChargesList::iterator itr = dispel_list.begin();
-        std::advance(itr, urand(0, dispel_list.size() - 1));
-
-        bool success = false;
-        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
-        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
-        {
-            dispel_list.erase(itr);
-            continue;
-        }
-        else
-        {
-            if (success)
-            {
-                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
-                --itr->second;
-                if (itr->second <= 0)
-                    dispel_list.erase(itr);
-            }
-            else
-            {
-                if (!failCount)
-                {
-                    // Failed to dispell
-                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
-                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
-                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
-                }
-                ++failCount;
-                dataFail << uint32(itr->first->GetId());                         // Spell Id
-            }
-            ++count;
-        }
-    }
-
-    if (failCount)
-        m_caster->SendMessageToSet(&dataFail, true);
-
-    if (success_list.empty())
-        return;
-
-    WorldPacket dataSuccess(SMSG_SPELLDISPELLOG, 8+8+4+1+4+damage*5);
-    // Send packet header
-    dataSuccess.append(unitTarget->GetPackGUID());         // Victim GUID
-    dataSuccess.append(m_caster->GetPackGUID());           // Caster GUID
-    dataSuccess << uint32(m_spellInfo->Id);                // dispel spell id
-    dataSuccess << uint8(0);                               // not used
-    dataSuccess << uint32(success_list.size());            // count
-    for (DispelList::iterator itr = success_list.begin(); itr != success_list.end(); ++itr)
-    {
-        // Send dispelled spell info
-        dataSuccess << uint32(itr->first);              // Spell Id
-        dataSuccess << uint8(0);                        // 0 - dispelled !=0 cleansed
-        unitTarget->RemoveAurasDueToSpellByDispel(itr->first, itr->second, m_caster);
-    }
-    m_caster->SendMessageToSet(&dataSuccess, true);
-
-    // On success dispel
-    // Devour Magic
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->Category == SPELLCATEGORY_DEVOUR_MAGIC)
-    {
-        int32 heal_amount = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
-        m_caster->CastCustomSpell(m_caster, 19658, &heal_amount, NULL, NULL, true);
-    }
-}
-
-void Spell::EffectDualWield(SpellEffIndex /*effIndex*/)
-{
-    unitTarget->SetCanDualWield(true);
-    if (unitTarget->GetTypeId() == TYPEID_UNIT)
-        unitTarget->ToCreature()->UpdateDamagePhysical(OFF_ATTACK);
-}
-
-void Spell::EffectPull(SpellEffIndex /*effIndex*/)
-{
-    // TODO: create a proper pull towards distract spell center for distract
-    sLog.outDebug("WORLD: Spell Effect DUMMY");
-}
-
-void Spell::EffectDistract(SpellEffIndex /*effIndex*/)
-{
-    // Check for possible target
-    if (!unitTarget || unitTarget->isInCombat())
-        return;
-
-    // target must be OK to do this
-    if (unitTarget->hasUnitState(UNIT_STAT_CONFUSED | UNIT_STAT_STUNNED | UNIT_STAT_FLEEING))
-        return;
-
-    float angle = unitTarget->GetAngle(&m_targets.m_dstPos);
-
-    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
-    {
-        // For players just turn them
-        unitTarget->ToPlayer()->SetPosition(unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), angle, false);
-        unitTarget->ToPlayer()->SendTeleportAckPacket();
-    }
-    else
-    {
-        // Set creature Distracted, Stop it, And turn it
-        unitTarget->SetOrientation(angle);
-        unitTarget->StopMoving();
-        unitTarget->GetMotionMaster()->MoveDistract(damage * IN_MILLISECONDS);
-    }
-}
-
-void Spell::EffectPickPocket(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // victim must be creature and attackable
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT || m_caster->IsFriendlyTo(unitTarget))
-        return;
-
-    // victim have to be alive and humanoid or undead
-    if (unitTarget->isAlive() && (unitTarget->GetCreatureTypeMask() &CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0)
-        m_caster->ToPlayer()->SendLoot(unitTarget->GetGUID(),LOOT_PICKPOCKETING);
-}
-
-void Spell::EffectAddFarsight(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-    int32 duration = GetSpellDuration(m_spellInfo);
-    // Caster not in world, might be spell triggered from aura removal
-    if (!m_caster->IsInWorld())
-        return;
-    DynamicObject* dynObj = new DynamicObject;
-    if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), m_caster, m_spellInfo->Id, m_targets.m_dstPos, radius, true))
-    {
-        delete dynObj;
-        return;
-    }
-    dynObj->SetDuration(duration);
-    dynObj->SetUInt32Value(DYNAMICOBJECT_BYTES, 0x80000002);
-    m_caster->AddDynObject(dynObj);
-
-    dynObj->setActive(true);    //must before add to map to be put in world container
-    dynObj->GetMap()->Add(dynObj); //grid will also be loaded
-
-    // Need to update visibility of object for client to accept farsight guid
-    m_caster->ToPlayer()->SetViewpoint(dynObj, true);
-    //m_caster->ToPlayer()->UpdateVisibilityOf(dynObj);
-}
-
-void Spell::EffectTeleUnitsFaceCaster(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    if (unitTarget->isInFlight())
-        return;
-
-    float dis = (float)m_caster->GetSpellRadiusForTarget(unitTarget, sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-
-    float fx,fy,fz;
-    m_caster->GetClosePoint(fx,fy,fz,unitTarget->GetObjectSize(),dis);
-
-    unitTarget->NearTeleportTo(fx,fy,fz,-m_caster->GetOrientation(),unitTarget == m_caster);
-}
-
-void Spell::EffectLearnSkill(SpellEffIndex effIndex)
-{
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (damage < 0)
-        return;
-
-    uint32 skillid =  m_spellInfo->EffectMiscValue[effIndex];
-    uint16 skillval = unitTarget->ToPlayer()->GetPureSkillValue(skillid);
-    unitTarget->ToPlayer()->SetSkill(skillid, SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex), skillval?skillval:1, damage*75);
-}
-
-void Spell::EffectAddHonor(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // not scale value for item based reward (/10 value expected)
-    if (m_CastItem)
-    {
-        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage/10);
-        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %d honor points (item %u) for player: %u", m_spellInfo->Id, damage/10, m_CastItem->GetEntry(),unitTarget->ToPlayer()->GetGUIDLow());
-        return;
-    }
-
-    // do not allow to add too many honor for player (50 * 21) = 1040 at level 70, or (50 * 31) = 1550 at level 80
-    if (damage <= 50)
-    {
-        uint32 honor_reward = Trinity::Honor::hk_honor_at_level(unitTarget->getLevel(), damage);
-        unitTarget->ToPlayer()->RewardHonor(NULL, 1, honor_reward);
-        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (scale) to player: %u", m_spellInfo->Id, honor_reward, unitTarget->ToPlayer()->GetGUIDLow());
-    }
-    else
-    {
-        //maybe we have correct honor_gain in damage already
-        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage);
-        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (non scale) for player: %u", m_spellInfo->Id, damage, unitTarget->ToPlayer()->GetGUIDLow());
-    }
-}
-
-void Spell::EffectTradeSkill(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    // uint32 skillid =  m_spellInfo->EffectMiscValue[i];
-    // uint16 skillmax = unitTarget->ToPlayer()->(skillid);
-    // unitTarget->ToPlayer()->SetSkill(skillid,skillval?skillval:1,skillmax+75);
-}
-
-void Spell::EffectEnchantItemPerm(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!itemTarget)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-
-    // Handle vellums
-    if (itemTarget->IsWeaponVellum() || itemTarget->IsArmorVellum())
-    {
-        // destroy one vellum from stack
-        uint32 count = 1;
-        p_caster->DestroyItemCount(itemTarget,count,true);
-        unitTarget=p_caster;
-        // and add a scroll
-        DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
-        itemTarget=NULL;
-        m_targets.setItemTarget(NULL);
-    }
-    else
-    {
-        // do not increase skill if vellum used
-        if (!(m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST))
-            p_caster->UpdateCraftSkill(m_spellInfo->Id);
-
-        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-        if (!enchant_id)
-            return;
-
-        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-        if (!pEnchant)
-            return;
-        
-        // item can be in trade slot and have owner diff. from caster
-        Player* item_owner = itemTarget->GetOwner();
-        if (!item_owner)
-            return;
-        
-        // Prevent applying enchanements with Use: spell on items that already have a Use: effect, this is usually blocked from client side and 
-        // can only be bypassed with memory manipulation.
-        for (int s = 0; s < 3; ++s) {
-            if (pEnchant->type[s] == ITEM_ENCHANTMENT_TYPE_USE_SPELL) {
-                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i) {
-                    ItemPrototype const *proto = itemTarget->GetProto();
-                    if (proto->Spells[i].SpellId && proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE) {
-                        sLog.outError("Exploiting attempt: Player %s(GUID: %u) tried to apply an enchanement with Use: spell on an item that already has a Use: effect,"
-                                      " this should be blocked from client side.", p_caster->GetName(), p_caster->GetGUIDLow());
-                        return;
-                    }
-                }
-            }
-        }
-
-        if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
-        {
-            sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
-                p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
-                itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
-                item_owner->GetName(),item_owner->GetSession()->GetAccountId());
-        }
-
-        // remove old enchanting before applying new if equipped
-        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,false);
-
-        itemTarget->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchant_id, 0, 0);
-
-        // add new enchanting if equipped
-        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,true);
-
-        itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
-    }
-}
-
-void Spell::EffectEnchantItemPrismatic(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!itemTarget)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-
-    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-    if (!enchant_id)
-        return;
-
-    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-    if (!pEnchant)
-        return;
-
-    // support only enchantings with add socket in this slot
-    {
-        bool add_socket = false;
-        for (uint8 i = 0; i < MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
-        {
-            if (pEnchant->type[i] == ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET)
-            {
-                add_socket = true;
-                break;
-            }
-        }
-        if (!add_socket)
-        {
-            sLog.outError("Spell::EffectEnchantItemPrismatic: attempt apply enchant spell %u with SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC (%u) but without ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET (%u), not suppoted yet.",
-                m_spellInfo->Id,SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC,ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET);
-            return;
-        }
-    }
-
-    // item can be in trade slot and have owner diff. from caster
-    Player* item_owner = itemTarget->GetOwner();
-    if (!item_owner)
-        return;
-
-    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
-    {
-        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
-            p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
-            itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
-            item_owner->GetName(),item_owner->GetSession()->GetAccountId());
-    }
-
-    // remove old enchanting before applying new if equipped
-    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,false);
-
-    itemTarget->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, enchant_id, 0, 0);
-
-    // add new enchanting if equipped
-    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,true);
-
-    itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
-}
-
-void Spell::EffectEnchantItemTmp(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-
-    // Rockbiter Weapon apply to both weapon
-    if (!itemTarget)
-    return;
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x400000)
-    {
-        uint32 spell_id = 0;
-
-        // enchanting spell selected by calculated damage-per-sec stored in Effect[1] base value
-        // Note: damage calculated (correctly) with rounding int32(float(v)) but
-        // RW enchantments applied damage int32(float(v)+0.5), this create  0..1 difference sometime
-        switch(damage)
-        {
-            // Rank 1
-            case  2: spell_id = 36744; break;               //  0% [ 7% == 2, 14% == 2, 20% == 2]
-            // Rank 2
-            case  4: spell_id = 36753; break;               //  0% [ 7% == 4, 14% == 4]
-            case  5: spell_id = 36751; break;               // 20%
-            // Rank 3
-            case  6: spell_id = 36754; break;               //  0% [ 7% == 6, 14% == 6]
-            case  7: spell_id = 36755; break;               // 20%
-            // Rank 4
-            case  9: spell_id = 36761; break;               //  0% [ 7% == 6]
-            case 10: spell_id = 36758; break;               // 14%
-            case 11: spell_id = 36760; break;               // 20%
-            default:
-                sLog.outError("Spell::EffectEnchantItemTmp: Damage %u not handled in S'RW",damage);
-                return;
-        }
-
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
-        if (!spellInfo)
-        {
-            sLog.outError("Spell::EffectEnchantItemTmp: unknown spell id %i", spell_id);
-            return;
-
-        }
-
-        for (int j = BASE_ATTACK; j <= OFF_ATTACK; ++j)
-        {
-            if (Item* item = p_caster->GetWeaponForAttack(WeaponAttackType(j)))
-            {
-                if (item->IsFitToSpellRequirements(m_spellInfo))
-                {
-                    Spell *spell = new Spell(m_caster, spellInfo, true);
-                    SpellCastTargets targets;
-                    targets.setItemTarget(item);
-                    spell->prepare(&targets);
-                }
-            }
-        }
-        return;
-    }
-    if (!itemTarget)
-        return;
-
-    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    if (!enchant_id)
-    {
-        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have 0 as enchanting id",m_spellInfo->Id,effIndex);
-        return;
-    }
-
-    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-    if (!pEnchant)
-    {
-        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have not existed enchanting id %u ",m_spellInfo->Id,effIndex,enchant_id);
-        return;
-    }
-
-    // select enchantment duration
-    uint32 duration;
-
-    // rogue family enchantments exception by duration
-    if (m_spellInfo->Id == 38615)
-        duration = 1800;                                    // 30 mins
-    // other rogue family enchantments always 1 hour (some have spell damage=0, but some have wrong data in EffBasePoints)
-    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE)
-        duration = 3600;                                    // 1 hour
-    // shaman family enchantments
-    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN)
-        duration = 1800;                                    // 30 mins
-    // other cases with this SpellVisual already selected
-    else if (m_spellInfo->SpellVisual[0] == 215)
-        duration = 1800;                                    // 30 mins
-    // some fishing pole bonuses except Glow Worm which lasts full hour
-    else if (m_spellInfo->SpellVisual[0] == 563 && m_spellInfo->Id != 64401)
-        duration = 600;                                     // 10 mins
-    // shaman rockbiter enchantments
-    else if (m_spellInfo->SpellVisual[0] == 0)
-        duration = 1800;                                    // 30 mins
-    else if (m_spellInfo->Id == 29702)
-        duration = 300;                                     // 5 mins
-    else if (m_spellInfo->Id == 37360)
-        duration = 300;                                     // 5 mins
-    // default case
-    else
-        duration = 3600;                                    // 1 hour
-
-    // item can be in trade slot and have owner diff. from caster
-    Player* item_owner = itemTarget->GetOwner();
-    if (!item_owner)
-        return;
-
-    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
-    {
-        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(temp): %s (Entry: %d) for player: %s (Account: %u)",
-            p_caster->GetName(), p_caster->GetSession()->GetAccountId(),
-            itemTarget->GetProto()->Name1, itemTarget->GetEntry(),
-            item_owner->GetName(), item_owner->GetSession()->GetAccountId());
-    }
-
-    // remove old enchanting before applying new if equipped
-    item_owner->ApplyEnchantment(itemTarget,TEMP_ENCHANTMENT_SLOT, false);
-
-    itemTarget->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, duration * 1000, 0);
-
-    // add new enchanting if equipped
-    item_owner->ApplyEnchantment(itemTarget, TEMP_ENCHANTMENT_SLOT, true);
-}
-
-void Spell::EffectTameCreature(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetPetGUID())
-        return;
-
-    if (!unitTarget)
-        return;
-
-    if (unitTarget->GetTypeId() != TYPEID_UNIT)
-        return;
-
-    Creature* creatureTarget = unitTarget->ToCreature();
-
-    if (creatureTarget->isPet())
-        return;
-
-    if (m_caster->getClass() != CLASS_HUNTER)
-        return;
-
-    // cast finish successfully
-    //SendChannelUpdate(0);
-    finish();
-
-    Pet* pet = m_caster->CreateTamedPetFrom(creatureTarget,m_spellInfo->Id);
-    if (!pet)                                               // in very specific state like near world end/etc.
-        return;
-
-    // "kill" original creature
-    creatureTarget->ForcedDespawn();
-
-    uint8 level = (creatureTarget->getLevel() < (m_caster->getLevel() - 5)) ? (m_caster->getLevel() - 5) : creatureTarget->getLevel();
-
-    // prepare visual effect for levelup
-    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level - 1);
-
-    // add to world
-    pet->GetMap()->Add(pet->ToCreature());
-
-    // visual effect for levelup
-    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level);
-
-    // caster have pet now
-    m_caster->SetMinion(pet, true);
-
-    pet->InitTalentForLevel();
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-        m_caster->ToPlayer()->PetSpellInitialize();
-    }
-}
-
-void Spell::EffectSummonPet(SpellEffIndex effIndex)
-{
-    Player *owner = NULL;
-    if (m_originalCaster)
-    {
-        if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
-            owner = (Player*)m_originalCaster;
-        else if (m_originalCaster->ToCreature()->isTotem())
-            owner = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself();
-    }
-
-    uint32 petentry = m_spellInfo->EffectMiscValue[effIndex];
-
-    if (!owner)
-    {
-        SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(67);
-        if (properties)
-            SummonGuardian(effIndex, petentry, properties);
-        return;
-    }
-
-    Pet *OldSummon = owner->GetPet();
-
-    // if pet requested type already exist
-    if (OldSummon)
-    {
-        if (petentry == 0 || OldSummon->GetEntry() == petentry)
-        {
-            // pet in corpse state can't be summoned
-            if (OldSummon->isDead())
-                return;
-
-            ASSERT(OldSummon->GetMap() == owner->GetMap());
-
-            //OldSummon->GetMap()->Remove(OldSummon->ToCreature(),false);
-
-            float px, py, pz;
-            owner->GetClosePoint(px, py, pz, OldSummon->GetObjectSize());
-
-            OldSummon->NearTeleportTo(px, py, pz, OldSummon->GetOrientation());
-            //OldSummon->Relocate(px, py, pz, OldSummon->GetOrientation());
-            //OldSummon->SetMap(owner->GetMap());
-            //owner->GetMap()->Add(OldSummon->ToCreature());
-
-            if (owner->GetTypeId() == TYPEID_PLAYER && OldSummon->isControlled())
-                owner->ToPlayer()->PetSpellInitialize();
-
-            return;
-        }
-
-        if (owner->GetTypeId() == TYPEID_PLAYER)
-            owner->ToPlayer()->RemovePet(OldSummon,(OldSummon->getPetType() == HUNTER_PET ? PET_SAVE_AS_DELETED : PET_SAVE_NOT_IN_SLOT),false);
-        else
-            return;
-    }
-
-    float x, y, z;
-    owner->GetClosePoint(x, y, z, owner->GetObjectSize());
-    Pet* pet = owner->SummonPet(petentry, x, y, z, owner->GetOrientation(), SUMMON_PET, 0);
-    if (!pet)
-        return;
-
-    if (m_caster->GetTypeId() == TYPEID_UNIT)
-    {
-        if (m_caster->ToCreature()->isTotem())
-            pet->SetReactState(REACT_AGGRESSIVE);
-        else
-            pet->SetReactState(REACT_DEFENSIVE);
-    }
-
-    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-
-    // generate new name for summon pet
-    std::string new_name=sObjectMgr.GeneratePetName(petentry);
-    if (!new_name.empty())
-        pet->SetName(new_name);
-
-    ExecuteLogEffectSummonObject(effIndex, pet);
-}
-
-void Spell::EffectLearnPetSpell(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)m_caster;
-
-    Pet *pet = _player->GetPet();
-    if (!pet)
-        return;
-    if (!pet->isAlive())
-        return;
-
-    SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[effIndex]);
-    if (!learn_spellproto)
-        return;
-
-    pet->learnSpell(learn_spellproto->Id);
-
-    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-    _player->PetSpellInitialize();
-}
-
-void Spell::EffectTaunt(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    // this effect use before aura Taunt apply for prevent taunt already attacking target
-    // for spell as marked "non effective at already attacking target"
-    if (!unitTarget || !unitTarget->CanHaveThreatList()
-        || unitTarget->getVictim() == m_caster)
-    {
-        SendCastResult(SPELL_FAILED_DONT_REPORT);
-        return;
-    }
-
-    if (m_spellInfo->Id == 62124)
-    {
-        int32 damageDone = int32(1 + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.5f);
-        bool is_crit = m_caster->isSpellCrit(unitTarget, m_spellInfo, m_spellSchoolMask, m_attackType);
-        if (is_crit)
-            damageDone *= 2;
-        m_caster->DealDamage(unitTarget, damageDone, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_HOLY, m_spellInfo, false);
-        m_caster->SendSpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, damageDone, SPELL_SCHOOL_MASK_HOLY, 0, 0, false, false, is_crit);
-    }
-
-    // Also use this effect to set the taunter's threat to the taunted creature's highest value
-    if (unitTarget->getThreatManager().getCurrentVictim())
-    {
-        float myThreat = unitTarget->getThreatManager().getThreat(m_caster);
-        float itsThreat = unitTarget->getThreatManager().getCurrentVictim()->getThreat();
-        if (itsThreat > myThreat)
-            unitTarget->getThreatManager().addThreat(m_caster, itsThreat - myThreat);
-    }
-
-    //Set aggro victim to caster
-    if (!unitTarget->getThreatManager().getOnlineContainer().empty())
-        if (HostileReference* forcedVictim = unitTarget->getThreatManager().getOnlineContainer().getReferenceByTarget(m_caster))
-            unitTarget->getThreatManager().setCurrentVictim(forcedVictim);
-
-    if (unitTarget->ToCreature()->IsAIEnabled && !unitTarget->ToCreature()->HasReactState(REACT_PASSIVE))
-        unitTarget->ToCreature()->AI()->AttackStart(m_caster);
-}
-
-void Spell::EffectWeaponDmg(SpellEffIndex /*effIndex*/)
-{
-}
-
-void Spell::SpellDamageWeaponDmg(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (!unitTarget->isAlive())
-        return;
-
-    // multiple weapon dmg effect workaround
-    // execute only the last weapon damage
-    // and handle all effects at once
-    for (uint32 j = effIndex + 1; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        switch (m_spellInfo->Effect[j])
-        {
-            case SPELL_EFFECT_WEAPON_DAMAGE:
-            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                return;     // we must calculate only at last weapon effect
-            break;
-        }
-    }
-
-    // some spell specific modifiers
-    float totalDamagePercentMod  = 1.0f;                    // applied to final bonus+weapon damage
-    int32 fixed_bonus = 0;
-    int32 spell_bonus = 0;                                  // bonus specific for spell
-
-    switch (m_spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            switch (m_spellInfo->Id)
-            {
-                case 69055:     // Saber Lash
-                case 70814:     // Saber Lash
-                {
-                    uint32 count = 0;
-                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
-                        if (ihit->effectMask & (1 << effIndex))
-                            ++count;
-
-                    totalDamagePercentMod /= count;
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            // Devastate (player ones)
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x40)
-            {
-                // Player can apply only 58567 Sunder Armor effect.
-                bool needCast = !unitTarget->HasAura(58567, m_caster->GetGUID());
-                if (needCast)
-                    m_caster->CastSpell(unitTarget, 58567, true);
-
-                if (Aura * aur = unitTarget->GetAura(58567, m_caster->GetGUID()))
-                {
-                    // 58388 - Glyph of Devastate dummy aura.
-                    if (int32 num = (needCast ? 0 : 1) + (m_caster->HasAura(58388) ? 1 : 0))
-                        aur->ModStackAmount(num);
-                    fixed_bonus += (aur->GetStackAmount() - 1) * CalculateDamage(2, unitTarget);
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_ROGUE:
-        {
-            // Fan of Knives, Hemorrhage, Ghostly Strike
-            if ((m_spellInfo->SpellFamilyFlags[1] & 0x40000)
-                || (m_spellInfo->SpellFamilyFlags[0] & 0x6000000))
-            {
-                // Hemorrhage
-                if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
-                {
-                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                        m_caster->ToPlayer()->AddComboPoints(unitTarget, 1, this);
-                }
-                // 50% more damage with daggers
-                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    if (Item* item = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType, true))
-                        if (item->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
-                            totalDamagePercentMod *= 1.5f;
-            }
-            // Mutilate (for each hand)
-            else if (m_spellInfo->SpellFamilyFlags[1] & 0x6)
-            {
-                bool found = false;
-                // fast check
-                if (unitTarget->HasAuraState(AURA_STATE_DEADLY_POISON, m_spellInfo, m_caster))
-                    found = true;
-                // full aura scan
-                else
-                {
-                    Unit::AuraApplicationMap const& auras = unitTarget->GetAppliedAuras();
-                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-                    {
-                        if (itr->second->GetBase()->GetSpellProto()->Dispel == DISPEL_POISON)
-                        {
-                            found = true;
-                            break;
-                        }
-                    }
-                }
-
-                if (found)
-                    totalDamagePercentMod *= 1.2f;          // 120% if poisoned
-            }
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Seal of Command - Increase damage by 36% on every swing
-            if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
-            {
-                totalDamagePercentMod *= 1.36f;            //136% damage
-            }
-
-            // Seal of Command Unleashed
-            else if (m_spellInfo->Id == 20467)
-            {
-                spell_bonus += int32(0.08f*m_caster->GetTotalAttackPowerValue(BASE_ATTACK));
-                spell_bonus += int32(0.13f*m_caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellInfo)));
-            }
-            break;
-        }
-        case SPELLFAMILY_SHAMAN:
-        {
-            // Skyshatter Harness item set bonus
-            // Stormstrike
-            if (AuraEffect * aurEff = m_caster->IsScriptOverriden(m_spellInfo, 5634))
-                m_caster->CastSpell(m_caster, 38430, true, NULL, aurEff);
-            break;
-        }
-        case SPELLFAMILY_DRUID:
-        {
-            // Mangle (Cat): CP
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
-            {
-                if (m_caster->GetTypeId() == TYPEID_PLAYER)
-                    m_caster->ToPlayer()->AddComboPoints(unitTarget,1, this);
-            }
-            // Shred, Maul - Rend and Tear
-            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00008800 && unitTarget->HasAuraState(AURA_STATE_BLEEDING))
-            {
-                if (AuraEffect const* rendAndTear = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 0))
-                {
-                    totalDamagePercentMod *= float((rendAndTear->GetAmount() + 100.0f) / 100.0f);
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_HUNTER:
-        {
-            // Kill Shot - bonus damage from Ranged Attack Power
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x800000)
-                spell_bonus += int32(0.4f*m_caster->GetTotalAttackPowerValue(RANGED_ATTACK));
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Plague Strike
-            if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
-            {
-                // Glyph of Plague Strike
-                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58657,0))
-                    totalDamagePercentMod *= float((aurEff->GetAmount() + 100.0f) / 100.0f);
-            }
-            // Blood Strike
-            else if (m_spellInfo->SpellFamilyFlags[0] & 0x400000)
-            {
-                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
-
-                // Glyph of Blood Strike
-                if (m_caster->GetAuraEffect(59332,0))
-                {
-                    if (unitTarget->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED))
-                       totalDamagePercentMod *= float((20 + 100.0f) / 100.0f);
-                }
-            }
-            // Death Strike
-            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000010)
-            {
-                // Glyph of Death Strike
-                if (m_caster->GetAuraEffect(59336,0))
-                {
-                    if (uint32 runic = m_caster->GetPower(POWER_RUNIC_POWER))
-                    {
-                        if (runic > 25)
-                            runic = 25;
-
-                        totalDamagePercentMod *= float((runic + 100.0f) / 100.0f);
-                    }
-                }
-            }
-            // Obliterate (12.5% more damage per disease)
-            else if (m_spellInfo->SpellFamilyFlags[1] & 0x20000)
-            {
-                bool consumeDiseases = true;
-                // Annihilation
-                if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2710, 0))
-                {
-                    // Do not consume diseases if roll sucesses
-                    if (roll_chance_i(aurEff->GetAmount()))
-                        consumeDiseases = false;
-                }
-                totalDamagePercentMod *= (float(CalculateDamage(2, unitTarget) * unitTarget->GetDiseasesByCaster(m_caster->GetGUID(), consumeDiseases) / 2) + 100.0f) / 100.0f;
-            }
-            // Blood-Caked Strike - Blood-Caked Blade
-            else if (m_spellInfo->SpellIconID == 1736)
-                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
-            break;
-        }
-    }
-
-    bool normalized = false;
-    float weaponDamagePercentMod = 1.0;
-    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        switch(m_spellInfo->Effect[j])
-        {
-            case SPELL_EFFECT_WEAPON_DAMAGE:
-            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-                fixed_bonus += CalculateDamage(j, unitTarget);
-                break;
-            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                fixed_bonus += CalculateDamage(j, unitTarget);
-                normalized = true;
-                break;
-            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                weaponDamagePercentMod *= float(CalculateDamage(j,unitTarget)) / 100.0f;
-                break;
-            default:
-                break;                                      // not weapon damage effect, just skip
-        }
-    }
-
-    // apply to non-weapon bonus weapon total pct effect, weapon total flat effect included in weapon damage
-    if (fixed_bonus || spell_bonus)
-    {
-        UnitMods unitMod;
-        switch(m_attackType)
-        {
-            default:
-            case BASE_ATTACK:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
-            case OFF_ATTACK:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
-            case RANGED_ATTACK: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
-        }
-
-        float weapon_total_pct = 1.0f;
-        if (m_spellInfo->SchoolMask & SPELL_SCHOOL_MASK_NORMAL)
-             weapon_total_pct = m_caster->GetModifierValue(unitMod, TOTAL_PCT);
-
-        if (fixed_bonus)
-            fixed_bonus = int32(fixed_bonus * weapon_total_pct);
-        if (spell_bonus)
-            spell_bonus = int32(spell_bonus * weapon_total_pct);
-    }
-
-    int32 weaponDamage = m_caster->CalculateDamage(m_attackType, normalized, true);
-
-    // Sequence is important
-    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-    {
-        // We assume that a spell have at most one fixed_bonus
-        // and at most one weaponDamagePercentMod
-        switch(m_spellInfo->Effect[j])
-        {
-            case SPELL_EFFECT_WEAPON_DAMAGE:
-            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                weaponDamage += fixed_bonus;
-                break;
-            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                weaponDamage = int32(weaponDamage * weaponDamagePercentMod);
-            default:
-                break;                                      // not weapon damage effect, just skip
-        }
-    }
-
-    if (spell_bonus)
-        weaponDamage += spell_bonus;
-
-    if (totalDamagePercentMod != 1.0f)
-        weaponDamage = int32(weaponDamage * totalDamagePercentMod);
-
-    // prevent negative damage
-    uint32 eff_damage = uint32(weaponDamage > 0 ? weaponDamage : 0);
-
-    // Add melee damage bonuses (also check for negative)
-    m_caster->MeleeDamageBonus(unitTarget, &eff_damage, m_attackType, m_spellInfo);
-    m_damage+= eff_damage;
-}
-
-void Spell::EffectThreat(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive() || !m_caster->isAlive())
-        return;
-
-    if (!unitTarget->CanHaveThreatList())
-        return;
-
-    unitTarget->AddThreat(m_caster, float(damage));
-}
-
-void Spell::EffectHealMaxHealth(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || !unitTarget->isAlive())
-        return;
-
-    int32 addhealth;
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN) // Lay on Hands
-    {
-        if (m_caster->GetGUID() == unitTarget->GetGUID())
-        {
-            m_caster->CastSpell(m_caster, 25771, true); // Forbearance
-            m_caster->CastSpell(m_caster, 61988, true); // Immune shield marker (serverside)
-            m_caster->CastSpell(m_caster, 61987, true); // Avenging Wrath marker
-        }
-    }
-
-    // damage == 0 - heal for caster max health
-    if (damage == 0)
-        addhealth = m_caster->GetMaxHealth();
-    else
-        addhealth = unitTarget->GetMaxHealth() - unitTarget->GetHealth();
-
-    if (m_originalCaster)
-         m_healing += m_originalCaster->SpellHealingBonus(unitTarget,m_spellInfo, addhealth, HEAL);
-}
-
-void Spell::EffectInterruptCast(SpellEffIndex effIndex)
-{
-    if (!unitTarget || !unitTarget->isAlive())
-        return;
-
-    // TODO: not all spells that used this effect apply cooldown at school spells
-    // also exist case: apply cooldown to interrupted cast only and to all spells
-    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; ++i)
-    {
-        if (Spell* spell = unitTarget->GetCurrentSpell(CurrentSpellTypes(i)))
-        {
-            SpellEntry const* curSpellInfo = spell->m_spellInfo;
-            // check if we can interrupt spell
-            if ((spell->getState() == SPELL_STATE_CASTING
-                || (spell->getState() == SPELL_STATE_PREPARING && spell->GetCastTime() > 0.0f))
-                && curSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT && curSpellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
-            {
-                if (m_originalCaster)
-                {
-                    int32 duration = m_originalCaster->ModSpellDuration(m_spellInfo, unitTarget, m_originalCaster->CalcSpellDuration(m_spellInfo), false);
-                    unitTarget->ProhibitSpellScholl(GetSpellSchoolMask(curSpellInfo), duration/*GetSpellDuration(m_spellInfo)*/);
-                }
-                ExecuteLogEffectInterruptCast(effIndex, unitTarget, curSpellInfo->Id);
-                unitTarget->InterruptSpell(CurrentSpellTypes(i), false);
-            }
-        }
-    }
-}
-
-void Spell::EffectSummonObjectWild(SpellEffIndex effIndex)
-{
-    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    GameObject* pGameObj = new GameObject;
-
-    WorldObject* target = focusObject;
-    if (!target)
-        target = m_caster;
-
-    float x, y, z;
-    if (m_targets.HasDst())
-        m_targets.m_dstPos.GetPosition(x, y, z);
-    else
-        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
-
-    Map *map = target->GetMap();
-
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id, map,
-        m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    int32 duration = GetSpellDuration(m_spellInfo);
-
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-    pGameObj->SetSpellId(m_spellInfo->Id);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    // Wild object not have owner and check clickable by players
-    map->Add(pGameObj);
-
-    if (pGameObj->GetGoType() == GAMEOBJECT_TYPE_FLAGDROP && m_caster->GetTypeId() == TYPEID_PLAYER)
-    {
-        Player *pl = m_caster->ToPlayer();
-        Battleground* bg = pl->GetBattleground();
-
-        switch(pGameObj->GetMapId())
-        {
-            case 489:                                       //WS
-            {
-                if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS && bg->GetStatus() == STATUS_IN_PROGRESS)
-                {
-                    uint32 team = ALLIANCE;
-
-                    if (pl->GetTeam() == team)
-                        team = HORDE;
-
-                    ((BattlegroundWS*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID(),team);
-                }
-                break;
-            }
-            case 566:                                       //EY
-            {
-                if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY && bg->GetStatus() == STATUS_IN_PROGRESS)
-                {
-                    ((BattlegroundEY*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID());
-                }
-                break;
-            }
-        }
-    }
-
-    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
-    {
-        GameObject* linkedGO = new GameObject;
-        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, map,
-            m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-        {
-            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-            linkedGO->SetSpellId(m_spellInfo->Id);
-
-            ExecuteLogEffectSummonObject(effIndex, linkedGO);
-
-            // Wild object not have owner and check clickable by players
-            map->Add(linkedGO);
-        }
-        else
-        {
-            delete linkedGO;
-            linkedGO = NULL;
-            return;
-        }
-    }
-}
-
-void Spell::EffectScriptEffect(SpellEffIndex effIndex)
-{
-    // TODO: we must implement hunter pet summon at login there (spell 6962)
-
-    switch(m_spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            switch(m_spellInfo->Id)
-            {
-                //Teleport to Lake Wintergrasp
-                case 58622:
-                   {
-                  if(OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197))
-                        if(pvpWG->isWarTime() || pvpWG->m_timer<300000)
-                        {
-                        if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
-                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
-                        else if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
-                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_HORDE_CAMP, true);
-                    
-                        if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
-                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
-                        else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
-                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_ALLIENCE_CAMP, true);
-                        }
-                return;
-                   }
-                
-                // Glyph of Backstab
-                case 63975:
-                {
-                    if (AuraEffect const * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE,SPELLFAMILY_ROGUE,0x00100000,0,0,m_caster->GetGUID()))
-                    {
-                        uint32 countMin = aurEff->GetBase()->GetMaxDuration();
-                        uint32 countMax = 12000;
-                        countMax += m_caster->HasAura(56801) ? 4000 : 0;
-
-                        if (countMin < countMax)
-                        {
-                            aurEff->GetBase()->SetDuration(uint32(aurEff->GetBase()->GetDuration()+3000));
-                            aurEff->GetBase()->SetMaxDuration(countMin+2000);
-                        }
-
-                    }
-                    return;
-                }
-                case 45204: // Clone Me!
-                case 41055: // Copy Weapon
-                case 45206: // Copy Off-hand Weapon
-                    unitTarget->CastSpell(m_caster, damage, false);
-                    break;
-                case 45205: // Copy Offhand Weapon
-                case 41054: // Copy Weapon
-                    m_caster->CastSpell(unitTarget, damage, false);
-                    break;
-                case 55693:                                 // Remove Collapsing Cave Aura
-                    if (!unitTarget)
-                        return;
-                    unitTarget->RemoveAurasDueToSpell(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
-                    break;
-                // PX-238 Winter Wondervolt TRAP
-                case 26275:
-                {
-                    uint32 spells[4] = { 26272, 26157, 26273, 26274 };
-
-                    // check presence
-                    for (uint8 j = 0; j < 4; ++j)
-                        if (unitTarget->HasAuraEffect(spells[j],0))
-                            return;
-
-                    // select spell
-                    uint32 iTmpSpellId = spells[urand(0,3)];
-
-                    // cast
-                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
-                    return;
-                }
-                // Bending Shinbone
-                case 8856:
-                {
-                    if (!itemTarget && m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    uint32 spell_id = 0;
-                    switch(urand(1, 5))
-                    {
-                    case 1:  spell_id = 8854; break;
-                    default: spell_id = 8855; break;
-                    }
-
-                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
-                    return;
-                }
-                // Brittle Armor - need remove one 24575 Brittle Armor aura
-                case 24590:
-                    unitTarget->RemoveAuraFromStack(24575);
-                    return;
-                // Mercurial Shield - need remove one 26464 Mercurial Shield aura
-                case 26465:
-                    unitTarget->RemoveAuraFromStack(26464);
-                    return;
-				case 62575:
-				{
-					if(m_caster->GetOwner())
-						m_caster->GetOwner()->CastSpell(unitTarget,62626,true );
-						return;
-				}
-				case 62960:
-				{
-					if (!unitTarget)
-						return;
-					m_caster->CastSpell(unitTarget,62563,true );
-					m_caster->CastSpell(unitTarget,68321,true );
-					return;
-				}
-				case 62626:
-				case 68321:
-				{
-					if(!unitTarget)
-						return;
-					if (unitTarget->GetAura(62719))
-						unitTarget->RemoveAuraFromStack(62719);
-
-					if(unitTarget->GetAura(64100))
-						unitTarget->RemoveAuraFromStack(64100);
-					return;
-				}
-					// Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
-                case 22539:
-                case 22972:
-                case 22975:
-                case 22976:
-                case 22977:
-                case 22978:
-                case 22979:
-                case 22980:
-                case 22981:
-                case 22982:
-                case 22983:
-                case 22984:
-                case 22985:
-                {
-                    if (!unitTarget || !unitTarget->isAlive())
-                        return;
-
-                    // Onyxia Scale Cloak
-                    if (unitTarget->HasAura(22683))
-                        return;
-
-                    // Shadow Flame
-                    m_caster->CastSpell(unitTarget, 22682, true);
-                    return;
-                }
-                // Piccolo of the Flaming Fire
-                case 17512:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    unitTarget->HandleEmoteCommand(EMOTE_STATE_DANCE);
-                    return;
-                }
-                // Escape artist
-                case 20589:
-                    m_caster->RemoveMovementImpairingAuras();
-                    return;
-                // Decimate
-                case 28374:
-                case 54426:
-                    if (unitTarget)
-                    {
-                        int32 damage = int32(unitTarget->GetHealth()) - int32(unitTarget->CountPctFromMaxHealth(5));
-                        if (damage > 0)
-                            m_caster->CastCustomSpell(28375, SPELLVALUE_BASE_POINT0, damage, unitTarget);
-                    }
-                    return;
-                // Mirren's Drinking Hat
-                case 29830:
-                {
-                    uint32 item = 0;
-                    switch (urand(1, 6))
-                    {
-                        case 1:
-                        case 2:
-                        case 3:
-                            item = 23584; break;            // Loch Modan Lager
-                        case 4:
-                        case 5:
-                            item = 23585; break;            // Stouthammer Lite
-                        case 6:
-                            item = 23586; break;            // Aerie Peak Pale Ale
-                    }
-                    if (item)
-                        DoCreateItem(effIndex,item);
-                    break;
-                }
-                // Improved Sprint
-                case 30918:
-                {
-                    // Removes snares and roots.
-                    unitTarget->RemoveMovementImpairingAuras();
-                    break;
-                }
-                // Spirit Walk
-                case 58876:
-                {
-                    // Removes snares and roots.
-                    unitTarget->RemoveMovementImpairingAuras();
-                    break;
-                }
-                // Plant Warmaul Ogre Banner
-                case 32307:
-                {
-                    Player *p_caster = dynamic_cast<Player*>(m_caster);
-                    if (!p_caster)
-                        break;
-                    p_caster->RewardPlayerAndGroupAtEvent(18388, unitTarget);
-                    Creature *cTarget = dynamic_cast<Creature*>(unitTarget);
-                    if (!cTarget)
-                        break;
-                    cTarget->setDeathState(CORPSE);
-                    cTarget->RemoveCorpse();
-                    break;
-                }
-                case 48025:                                     // Headless Horseman's Mount
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 51621, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 48024, true); break;
-                    case 225:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 51617, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 48024, true);
-                        }break;
-                    case 300:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 48023, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 48024, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 47977:                                     // Magic Broom
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 42680, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 42683, true); break;
-                    case 225:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 42667, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 42683, true);
-                        }break;
-                    case 300:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 42668, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 42683, true);
-                        }break;
-                    }
-                    return;
-                }
-                // Mug Transformation
-                case 41931:
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    uint8 bag = 19;
-                    uint8 slot = 0;
-                    Item *item = NULL;
-
-                    while (bag) // 256 = 0 due to var type
-                    {
-                        item = m_caster->ToPlayer()->GetItemByPos(bag, slot);
-                        if (item && item->GetEntry() == 38587) break;
-                        ++slot;
-                        if (slot == 39)
-                        {
-                            slot = 0;
-                            ++bag;
-                        }
-                    }
-                    if (bag)
-                    {
-                        if (m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount() == 1) m_caster->ToPlayer()->RemoveItem(bag,slot,true);
-                        else m_caster->ToPlayer()->GetItemByPos(bag,slot)->SetCount(m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount()-1);
-                        // Spell 42518 (Braufest - Gratisprobe des Braufest herstellen)
-                        m_caster->CastSpell(m_caster, 42518, true);
-                        return;
-                    }
-                    break;
-                }
-                // Brutallus - Burn
-                case 45141:
-                case 45151:
-                {
-                    //Workaround for Range ... should be global for every ScriptEffect
-                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-                    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER && unitTarget->GetDistance(m_caster) >= radius && !unitTarget->HasAura(46394) && unitTarget != m_caster)
-                        unitTarget->CastSpell(unitTarget, 46394, true);
-
-                    break;
-                }
-                // Goblin Weather Machine
-                case 46203:
-                {
-                    if (!unitTarget)
-                        return;
-
-                    uint32 spellId = 0;
-                    switch(rand() % 4)
-                    {
-                        case 0: spellId = 46740; break;
-                        case 1: spellId = 46739; break;
-                        case 2: spellId = 46738; break;
-                        case 3: spellId = 46736; break;
-                    }
-                    unitTarget->CastSpell(unitTarget, spellId, true);
-                    break;
-                }
-                // 5,000 Gold
-                case 46642:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    unitTarget->ToPlayer()->ModifyMoney(5000 * GOLD);
-
-                    break;
-                }
-                // Roll Dice - Decahedral Dwarven Dice
-                case 47770:
-                {
-                    char buf[128];
-                    const char *gender = "his";
-                    if (m_caster->getGender() > 0)
-                        gender = "her";
-                    sprintf(buf, "%s rubs %s [Decahedral Dwarven Dice] between %s hands and rolls. One %u and one %u.", m_caster->GetName(), gender, gender, urand(1,10), urand(1,10));
-                    m_caster->MonsterTextEmote(buf, 0);
-                    break;
-                }
-                // Roll 'dem Bones - Worn Troll Dice
-                case 47776:
-                {
-                    char buf[128];
-                    const char *gender = "his";
-                    if (m_caster->getGender() > 0)
-                        gender = "her";
-                    sprintf(buf, "%s causually tosses %s [Worn Troll Dice]. One %u and one %u.", m_caster->GetName(), gender, urand(1,6), urand(1,6));
-                    m_caster->MonsterTextEmote(buf, 0);
-                    break;
-                }
-                // Vigilance
-                case 50725:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Remove Taunt cooldown
-                    unitTarget->ToPlayer()->RemoveSpellCooldown(355, true);
-
-                    return;
-                }
-                // Death Knight Initiate Visual
-                case 51519:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    uint32 iTmpSpellId = 0;
-                    switch (unitTarget->GetDisplayId())
-                    {
-                        case 25369: iTmpSpellId = 51552; break; // bloodelf female
-                        case 25373: iTmpSpellId = 51551; break; // bloodelf male
-                        case 25363: iTmpSpellId = 51542; break; // draenei female
-                        case 25357: iTmpSpellId = 51541; break; // draenei male
-                        case 25361: iTmpSpellId = 51537; break; // dwarf female
-                        case 25356: iTmpSpellId = 51538; break; // dwarf male
-                        case 25372: iTmpSpellId = 51550; break; // forsaken female
-                        case 25367: iTmpSpellId = 51549; break; // forsaken male
-                        case 25362: iTmpSpellId = 51540; break; // gnome female
-                        case 25359: iTmpSpellId = 51539; break; // gnome male
-                        case 25355: iTmpSpellId = 51534; break; // human female
-                        case 25354: iTmpSpellId = 51520; break; // human male
-                        case 25360: iTmpSpellId = 51536; break; // nightelf female
-                        case 25358: iTmpSpellId = 51535; break; // nightelf male
-                        case 25368: iTmpSpellId = 51544; break; // orc female
-                        case 25364: iTmpSpellId = 51543; break; // orc male
-                        case 25371: iTmpSpellId = 51548; break; // tauren female
-                        case 25366: iTmpSpellId = 51547; break; // tauren male
-                        case 25370: iTmpSpellId = 51545; break; // troll female
-                        case 25365: iTmpSpellId = 51546; break; // troll male
-                        default: return;
-                    }
-
-                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
-                    Creature* npc = unitTarget->ToCreature();
-                    npc->LoadEquipment(npc->GetEquipmentId());
-                    return;
-                }
-                // Emblazon Runeblade
-                case 51770:
-                {
-                    if (!m_originalCaster)
-                        return;
-
-                    m_originalCaster->CastSpell(m_originalCaster, damage, false);
-                    break;
-                }
-                // Deathbolt from Thalgran Blightbringer
-                // reflected by Freya's Ward
-                // Retribution by Sevenfold Retribution
-                case 51854:
-                {
-                    if (!m_caster || !unitTarget)
-                        return;
-                    if (unitTarget->HasAura(51845))
-                        unitTarget->CastSpell(m_caster, 51856, true);
-                    else
-                        m_caster->CastSpell(unitTarget, 51855, true);
-                    break;
-                }
-                // Summon Ghouls On Scarlet Crusade
-                case 51904:
-                {
-                    if (!m_targets.HasDst())
-                        return;
-
-                    float x, y, z;
-                    float radius = GetSpellRadius(m_spellInfo, effIndex, true);
-                    for (uint8 i = 0; i < 15; ++i)
-                    {
-                        m_caster->GetRandomPoint(m_targets.m_dstPos, radius, x, y, z);
-                        m_caster->CastSpell(x, y, z, 54522, true);
-                    }
-                    break;
-                }
-                case 52173: // Coyote Spirit Despawn
-                case 60243: // Blood Parrot Despawn
-                    if (unitTarget->GetTypeId() == TYPEID_UNIT && unitTarget->ToCreature()->isSummon())
-                        unitTarget->ToTempSummon()->UnSummon();
-                    return;
-                case 52479: // Gift of the Harvester
-                    if (unitTarget && m_originalCaster)
-                        m_originalCaster->CastSpell(unitTarget, urand(0, 1) ? damage : 52505, true);
-                    return;
-                // Death Gate
-                case 52751:
-                {
-                    if (!unitTarget || unitTarget->getClass() != CLASS_DEATH_KNIGHT)
-                        return;
-                    // triggered spell is stored in m_spellInfo->EffectBasePoints[0]
-                    unitTarget->CastSpell(unitTarget, damage, false);
-                    break;
-                }
-                case 53110: // Devour Humanoid
-                    if (unitTarget)
-                        unitTarget->CastSpell(m_caster, damage, true);
-                    return;
-                // Winged Steed of the Ebon Blade
-                case 54729:
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 300)
-                            unitTarget->CastSpell(unitTarget, 54727, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 54726, true);
-                    }
-                    return;
-                }
-                case 58418:                                 // Portal to Orgrimmar
-                case 58420:                                 // Portal to Stormwind
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || effIndex != 0)
-                        return;
-
-                    uint32 spellID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0);
-                    uint32 questID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
-
-                    if (unitTarget->ToPlayer()->GetQuestStatus(questID) == QUEST_STATUS_COMPLETE && !unitTarget->ToPlayer()->GetQuestRewardStatus (questID))
-                        unitTarget->CastSpell(unitTarget, spellID, true);
-
-                    return;
-                }
-                case 58941:                                 // Rock Shards
-                    if (unitTarget && m_originalCaster)
-                    {
-                        for (uint32 i = 0; i < 3; ++i)
-                        {
-                            m_originalCaster->CastSpell(unitTarget, 58689, true);
-                            m_originalCaster->CastSpell(unitTarget, 58692, true);
-                        }
-                        if (((InstanceMap*)m_originalCaster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY)
-                        {
-                            m_originalCaster->CastSpell(unitTarget, 58695, true);
-                            m_originalCaster->CastSpell(unitTarget, 58696, true);
-                        }
-                        else
-                        {
-                            m_originalCaster->CastSpell(unitTarget, 60883, true);
-                            m_originalCaster->CastSpell(unitTarget, 60884, true);
-                        }
-                    }
-                    return;
-                case 58983: // Big Blizzard Bear
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 150)
-                            unitTarget->CastSpell(unitTarget, 58999, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 58997, true);
-                    }
-                    return;
-                }
-                case 63845: // Create Lance
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
-			{
-                        m_caster->CastSpell(m_caster, 63914, true);
-			DoCreateItem(0,46069);
-			}
-                    else
-			{
-                        DoCreateItem(0,46070);
-			m_caster->CastSpell(m_caster, 63919, true);
-			}
-                    return;
-                }
-                case 62705:
-                {
- 	                if (!unitTarget->isInCombat())
- 	                    unitTarget->SetHealth(unitTarget->GetMaxHealth());
-                }
-                case 71342:                                     // Big Love Rocket
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 0: unitTarget->CastSpell(unitTarget, 71343, true); break;
-                    case 75: unitTarget->CastSpell(unitTarget, 71344, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 71345, true); break;
-                    case 225:
-                        {
-                        if (canFly)
-                                unitTarget->CastSpell(unitTarget, 71346, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 71345, true);
-                        }break;
-                    case 300:
-                        {
-                        if (canFly)
-                            unitTarget->CastSpell(unitTarget, 71347, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 71345, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 72286:                                     // Invincible
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 72281, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 72282, true); break;
-                    case 225:
-                        {
-                        if (canFly)
-                                unitTarget->CastSpell(unitTarget, 72283, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 72282, true);
-                        }break;
-                    case 300:
-                        {
-                        if (canFly)
-                            unitTarget->CastSpell(unitTarget, 72284, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 72282, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 74856:                                     // Blazing Hippogryph
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 300)
-                            unitTarget->CastSpell(unitTarget, 74855, true);
-                        else
-                            unitTarget->CastSpell(unitTarget, 74854, true);
-                    }
-                    return;
-                }
-                case 75614:                                     // Celestial Steed
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts and client crashes upon dismounting
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill and zone
-                    bool canFly = true;
-                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
-                    if (v_map != 530 && v_map != 571)
-                        canFly = false;
-
-                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
-                        canFly = false;
-
-                    float x, y, z;
-                    unitTarget->GetPosition(x, y, z);
-                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
-                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
-                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                        canFly = false;
-
-                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
-                    {
-                    case 75: unitTarget->CastSpell(unitTarget, 75619, true); break;
-                    case 150: unitTarget->CastSpell(unitTarget, 75620, true); break;
-                    case 225:
-                        {
-                            if (canFly)
-                                unitTarget->CastSpell(unitTarget, 75617, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 75620, true);
-                        }break;
-                    case 300:
-                        {
-                            if (canFly)
-                            {
-                                if (unitTarget->ToPlayer()->Has310Flyer(false))
-                                    unitTarget->CastSpell(unitTarget, 76153, true);
-                                else
-                                    unitTarget->CastSpell(unitTarget, 75618, true);
-                            }
-                            else
-                                unitTarget->CastSpell(unitTarget, 75620, true);
-                        }break;
-                    }
-                    return;
-                }
-                case 75973:                                     // X-53 Touring Rocket
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // Prevent stacking of mounts
-                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
-
-                    // Triggered spell id dependent on riding skill
-                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
-                    {
-                        if (skillval >= 300)
-                        {
-                            if (unitTarget->ToPlayer()->Has310Flyer(false))
-                                unitTarget->CastSpell(unitTarget, 76154, true);
-                            else
-                                unitTarget->CastSpell(unitTarget, 75972, true);
-                        }
-                        else
-                            unitTarget->CastSpell(unitTarget, 75957, true);
-                    }
-                    return;
-                }
-                case 59317:                                 // Teleporting
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // return from top
-                    if (unitTarget->ToPlayer()->GetAreaId() == 4637)
-                        unitTarget->CastSpell(unitTarget, 59316, true);
-                    // teleport atop
-                    else
-                        unitTarget->CastSpell(unitTarget, 59314, true);
-
-                    return;
-                // random spell learn instead placeholder
-                case 60893:                                 // Northrend Alchemy Research
-                case 61177:                                 // Northrend Inscription Research
-                case 61288:                                 // Minor Inscription Research
-                case 61756:                                 // Northrend Inscription Research (FAST QA VERSION)
-                case 64323:                                 // Book of Glyph Mastery
-                {
-                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-                        return;
-
-                    // learn random explicit discovery recipe (if any)
-                    if (uint32 discoveredSpell = GetExplicitDiscoverySpell(m_spellInfo->Id, (Player*)m_caster))
-                        m_caster->ToPlayer()->learnSpell(discoveredSpell, false);
-                    return;
-                }
-                case 62428: // Load into Catapult
-                {
-                    if (Vehicle *seat = m_caster->GetVehicleKit())
-                        if (Unit *passenger = seat->GetPassenger(0))
-                            if (Unit *demolisher = m_caster->GetVehicleBase())
-                                passenger->CastSpell(demolisher, damage, true);
-                    return;
-                }
-                case 62482: // Grab Crate
-                {
-                    if (unitTarget)
-                    {
-                        if (Vehicle *seat = m_caster->GetVehicleKit())
-                        {
-                            if (Creature *oldContainer = dynamic_cast<Creature*>(seat->GetPassenger(1)))
-                                oldContainer->DisappearAndDie();
-                            // TODO: a hack, range = 11, should after some time cast, otherwise too far
-                            unitTarget->CastSpell(seat->GetBase(), 62496, true);
-                            unitTarget->EnterVehicle(seat, 1);
-                        }
-                    }
-                    return;
-                }
-                case 60123: // Lightwell
-                {
-                    if (m_caster->GetTypeId() != TYPEID_UNIT || !m_caster->ToCreature()->isSummon())
-                        return;
-
-                    uint32 spell_heal;
-
-                    switch(m_caster->GetEntry())
-                    {
-                        case 31897: spell_heal = 7001; break;
-                        case 31896: spell_heal = 27873; break;
-                        case 31895: spell_heal = 27874; break;
-                        case 31894: spell_heal = 28276; break;
-                        case 31893: spell_heal = 48084; break;
-                        case 31883: spell_heal = 48085; break;
-                        default:
-                            sLog.outError("Unknown Lightwell spell caster %u", m_caster->GetEntry());
-                            return;
-                    }
-                    Aura * chargesaura = m_caster->GetAura(59907);
-
-                    if (chargesaura && chargesaura->GetCharges() > 1)
-                    {
-                        chargesaura->SetCharges(chargesaura->GetCharges() - 1);
-                        m_caster->CastSpell(unitTarget, spell_heal, true, NULL, NULL, m_caster->ToTempSummon()->GetSummonerGUID());
-                    }
-                    else
-                        m_caster->ToTempSummon()->UnSummon();
-                    return;
-                }
-                // Stoneclaw Totem
-                case 55328: // Rank 1
-                case 55329: // Rank 2
-                case 55330: // Rank 3
-                case 55332: // Rank 4
-                case 55333: // Rank 5
-                case 55335: // Rank 6
-                case 55278: // Rank 7
-                case 58589: // Rank 8
-                case 58590: // Rank 9
-                case 58591: // Rank 10
-                {
-                    int32 basepoints0 = damage;
-                    // Cast Absorb on totems
-                    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
-                    {
-                        if (!unitTarget->m_SummonSlot[slot])
-                            continue;
-
-                        Creature* totem = unitTarget->GetMap()->GetCreature(unitTarget->m_SummonSlot[slot]);
-                        if (totem && totem->isTotem())
-                        {
-                            m_caster->CastCustomSpell(totem, 55277, &basepoints0, NULL, NULL, true);
-                        }
-                    }
-                    // Glyph of Stoneclaw Totem
-                    if (AuraEffect *aur=unitTarget->GetAuraEffect(63298, 0))
-                    {
-                        basepoints0 *= aur->GetAmount();
-                        m_caster->CastCustomSpell(unitTarget, 55277, &basepoints0, NULL, NULL, true);
-                    }
-                    break;
-                }
-                case 66545: //Summon Memory
-                {
-                    uint8 uiRandom = urand(0,25);
-                    uint32 uiSpells[26] = {66704,66705,66706,66707,66709,66710,66711,66712,66713,66714,66715,66708,66708,66691,66692,66694,66695,66696,66697,66698,66699,66700,66701,66702,66703,66543};
-
-                    m_caster->CastSpell(m_caster,uiSpells[uiRandom],true);
-                    break;
-                }
-                case 45668:                                 // Ultra-Advanced Proto-Typical Shortening Blaster
-                {
-                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
-                        return;
-
-                    if (roll_chance_i(50))                  // chance unknown, using 50
-                        return;
-
-                    static uint32 const spellPlayer[5] =
-                    {
-                        45674,                            // Bigger!
-                        45675,                            // Shrunk
-                        45678,                            // Yellow
-                        45682,                            // Ghost
-                        45684                             // Polymorph
-                    };
-
-                    static uint32 const spellTarget[5] = {
-                        45673,                            // Bigger!
-                        45672,                            // Shrunk
-                        45677,                            // Yellow
-                        45681,                            // Ghost
-                        45683                             // Polymorph
-                    };
-
-                    m_caster->CastSpell(m_caster, spellPlayer[urand(0,4)], true);
-                    unitTarget->CastSpell(unitTarget, spellTarget[urand(0,4)], true);
-                    break;
-                }
-                case 64142:                                 // Upper Deck - Create Foam Sword
-		{
-                    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-                        return;
-                    Player *plr = unitTarget->ToPlayer();
-                    static uint32 const itemId[] = {45061, 45176, 45177, 45178, 45179, 0};
-                    // player can only have one of these items
-                    for (uint32 const *itr = &itemId[0]; *itr; ++itr)
-                        if (plr->HasItemCount(*itr, 1, true))
-                            return;
-                    DoCreateItem(effIndex, itemId[urand(0,4)]);
-                    return;
-		}
-            }
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Judgement (seal trigger)
-            if (m_spellInfo->Category == SPELLCATEGORY_JUDGEMENT)
-            {
-                if (!unitTarget || !unitTarget->isAlive())
-                    return;
-                uint32 spellId1 = 0;
-                uint32 spellId2 = 0;
-                uint32 spellId3 = 0;
-
-                // Judgement self add switch
-                switch (m_spellInfo->Id)
-                {
-                    case 53407: spellId1 = 20184; break;    // Judgement of Justice
-                    case 20271:                             // Judgement of Light
-                    case 57774: spellId1 = 20185; break;    // Judgement of Light
-                    case 53408: spellId1 = 20186; break;    // Judgement of Wisdom
-                    default:
-                        sLog.outError("Unsupported Judgement (seal trigger) spell (Id: %u) in Spell::EffectScriptEffect",m_spellInfo->Id);
-                        return;
-                }
-                // all seals have aura dummy in 2 effect
-                Unit::AuraApplicationMap & sealAuras = m_caster->GetAppliedAuras();
-                for (Unit::AuraApplicationMap::iterator iter = sealAuras.begin(); iter != sealAuras.end();)
-                {
-                    switch (iter->first)
-                    {
-                        // Heart of the Crusader
-                        case 20335: // Rank 1
-                            spellId3 = 21183;
-                            break;
-                        case 20336: // Rank 2
-                            spellId3 = 54498;
-                            break;
-                        case 20337: // Rank 3
-                            spellId3 = 54499;
-                            break;
-                    }
-                    Aura * aura = iter->second->GetBase();
-                    if (IsSealSpell(aura->GetSpellProto()))
-                    {
-                        if (AuraEffect * aureff = aura->GetEffect(2))
-                            if (aureff->GetAuraType() == SPELL_AURA_DUMMY)
-                            {
-                                if (sSpellStore.LookupEntry(aureff->GetAmount()))
-                                    spellId2 = aureff->GetAmount();
-                                break;
-                            }
-                        if (!spellId2)
-                        {
-                            switch (iter->first)
-                            {
-                                // Seal of light, Seal of wisdom, Seal of justice
-                                case 20165:
-                                case 20166:
-                                case 20164:
-                                    spellId2 = 54158;
-                            }
-                        }
-                        break;
-                    }
-                    else
-                        ++iter;
-                }
-                if (spellId1)
-                    m_caster->CastSpell(unitTarget, spellId1, true);
-                if (spellId2)
-                    m_caster->CastSpell(unitTarget, spellId2, true);
-                if (spellId3)
-                    m_caster->CastSpell(unitTarget, spellId3, true);
-                return;
-            }
-        }
-        case SPELLFAMILY_POTION:
-        {
-            switch(m_spellInfo->Id)
-            {
-                // Netherbloom
-                case 28702:
-                {
-                    if (!unitTarget)
-                        return;
-                    // 25% chance of casting a random buff
-                    if (roll_chance_i(75))
-                        return;
-
-                    // triggered spells are 28703 to 28707
-                    // Note: some sources say, that there was the possibility of
-                    //       receiving a debuff. However, this seems to be removed by a patch.
-                    const uint32 spellid = 28703;
-
-                    // don't overwrite an existing aura
-                    for (uint8 i = 0; i < 5; ++i)
-                        if (unitTarget->HasAura(spellid + i))
-                            return;
-                    unitTarget->CastSpell(unitTarget, spellid+urand(0, 4), true);
-                    break;
-                }
-
-                // Nightmare Vine
-                case 28720:
-                {
-                    if (!unitTarget)
-                        return;
-                    // 25% chance of casting Nightmare Pollen
-                    if (roll_chance_i(75))
-                        return;
-                    unitTarget->CastSpell(unitTarget, 28721, true);
-                    break;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Pestilence
-            if (m_spellInfo->SpellFamilyFlags[1]&0x10000)
-            {
-                // Get diseases on target of spell
-                if (m_targets.getUnitTarget() &&  // Glyph of Disease - cast on unit target too to refresh aura
-                    (m_targets.getUnitTarget() != unitTarget || m_caster->GetAura(63334)))
-                {
-                    // And spread them on target
-                    // Blood Plague
-                    if (m_targets.getUnitTarget()->GetAura(55078))
-                        m_caster->CastSpell(unitTarget, 55078, true);
-                    // Frost Fever
-                    if (m_targets.getUnitTarget()->GetAura(55095))
-                        m_caster->CastSpell(unitTarget, 55095, true);
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            // Shattering Throw
-            if (m_spellInfo->SpellFamilyFlags[1] & 0x00400000)
-            {
-                if (!unitTarget)
-                    return;
-                // remove shields, will still display immune to damage part
-                unitTarget->RemoveAurasWithMechanic(1<<MECHANIC_IMMUNE_SHIELD, AURA_REMOVE_BY_ENEMY_SPELL);
-                return;
-            }
-            break;
-        }
-    }
-
-    // normal DB scripted effect
-    sLog.outDebug("Spell ScriptStart spellid %u in EffectScriptEffect(%u)", m_spellInfo->Id, effIndex);
-    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
-}
-
-void Spell::EffectSanctuary(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    std::list<Unit*> targets;
-    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(unitTarget, unitTarget, m_caster->GetMap()->GetVisibilityDistance());
-    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(unitTarget, targets, u_check);
-    unitTarget->VisitNearbyObject(m_caster->GetMap()->GetVisibilityDistance(), searcher);
-    for (std::list<Unit*>::iterator iter = targets.begin(); iter != targets.end(); ++iter)
-    {
-        if (!(*iter)->hasUnitState(UNIT_STAT_CASTING))
-            continue;
-
-        for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
-        {
-            if ((*iter)->GetCurrentSpell(i)
-            && (*iter)->GetCurrentSpell(i)->m_targets.getUnitTargetGUID() == unitTarget->GetGUID())
-            {
-                (*iter)->InterruptSpell(CurrentSpellTypes(i), false);
-            }
-        }
-    }
-
-    unitTarget->CombatStop();
-    unitTarget->getHostileRefManager().deleteReferences();   // stop all fighting
-    // Vanish allows to remove all threat and cast regular stealth so other spells can be used
-    if (m_caster->GetTypeId() == TYPEID_PLAYER
-        && m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE
-        && (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_ROGUE_VANISH))
-    {
-        
-        // Overkill
-        if (m_caster->ToPlayer()->HasSpell(58426))
-           m_caster->CastSpell(m_caster, 58427, true);
-    }
-}
-
-void Spell::EffectAddComboPoints(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    if (!m_caster->m_movedPlayer)
-        return;
-
-    if (damage <= 0)
-        return;
-
-    m_caster->m_movedPlayer->AddComboPoints(unitTarget, damage, this);
-}
-
-void Spell::EffectDuel(SpellEffIndex effIndex)
-{
-    if (!m_caster || !unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *caster = (Player*)m_caster;
-    Player *target = (Player*)unitTarget;
-
-    // caster or target already have requested duel
-    if (caster->duel || target->duel || !target->GetSocial() || target->GetSocial()->HasIgnore(caster->GetGUIDLow()))
-        return;
-
-    // Players can only fight a duel with each other outside (=not inside dungeons and not in capital cities)
-    // Don't have to check the target's map since you cannot challenge someone across maps
-    if (caster->GetMap()->Instanceable())
-    //if (mapid != 0 && mapid != 1 && mapid != 530 && mapid != 571 && mapid != 609)
-    {
-        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
-        return;
-    }
-
-    AreaTableEntry const* casterAreaEntry = GetAreaEntryByAreaID(caster->GetZoneId());
-    if (casterAreaEntry && (casterAreaEntry->flags & AREA_FLAG_CAPITAL))
-    {
-        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
-        return;
-    }
-
-    AreaTableEntry const* targetAreaEntry = GetAreaEntryByAreaID(target->GetZoneId());
-    if (targetAreaEntry && (targetAreaEntry->flags & AREA_FLAG_CAPITAL))
-    {
-        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
-        return;
-    }
-
-    //CREATE DUEL FLAG OBJECT
-    GameObject* pGameObj = new GameObject;
-
-    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    Map *map = m_caster->GetMap();
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id,
-        map, m_caster->GetPhaseMask(),
-        m_caster->GetPositionX()+(unitTarget->GetPositionX()-m_caster->GetPositionX())/2 ,
-        m_caster->GetPositionY()+(unitTarget->GetPositionY()-m_caster->GetPositionY())/2 ,
-        m_caster->GetPositionZ(),
-        m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    pGameObj->SetUInt32Value(GAMEOBJECT_FACTION, m_caster->getFaction());
-    pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel()+1);
-    int32 duration = GetSpellDuration(m_spellInfo);
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-    pGameObj->SetSpellId(m_spellInfo->Id);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    m_caster->AddGameObject(pGameObj);
-    map->Add(pGameObj);
-    //END
-
-    // Send request
-    WorldPacket data(SMSG_DUEL_REQUESTED, 8 + 8);
-    data << uint64(pGameObj->GetGUID());
-    data << uint64(caster->GetGUID());
-    caster->GetSession()->SendPacket(&data);
-    target->GetSession()->SendPacket(&data);
-
-    // create duel-info
-    DuelInfo *duel   = new DuelInfo;
-    duel->initiator  = caster;
-    duel->opponent   = target;
-    duel->startTime  = 0;
-    duel->startTimer = 0;
-    caster->duel     = duel;
-
-    DuelInfo *duel2   = new DuelInfo;
-    duel2->initiator  = caster;
-    duel2->opponent   = caster;
-    duel2->startTime  = 0;
-    duel2->startTimer = 0;
-    target->duel      = duel2;
-
-    caster->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
-    target->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
-
-    sScriptMgr.OnPlayerDuelRequest(target, caster);
-}
-
-void Spell::EffectStuck(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (!sWorld.getBoolConfig(CONFIG_CAST_UNSTUCK))
-        return;
-
-    Player* pTarget = (Player*)unitTarget;
-
-    sLog.outDebug("Spell Effect: Stuck");
-    sLog.outDetail("Player %s (guid %u) used auto-unstuck future at map %u (%f, %f, %f)", pTarget->GetName(), pTarget->GetGUIDLow(), m_caster->GetMapId(), m_caster->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ());
-
-    if (pTarget->isInFlight())
-        return;
-
-    pTarget->TeleportTo(pTarget->GetStartPosition(), unitTarget == m_caster ? TELE_TO_SPELL : 0);
-    // homebind location is loaded always
-    // pTarget->TeleportTo(pTarget->m_homebindMapId,pTarget->m_homebindX,pTarget->m_homebindY,pTarget->m_homebindZ,pTarget->GetOrientation(), (unitTarget == m_caster ? TELE_TO_SPELL : 0));
-
-    // Stuck spell trigger Hearthstone cooldown
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(8690);
-    if (!spellInfo)
-        return;
-    Spell spell(pTarget, spellInfo, true, 0);
-    spell.SendSpellCooldown();
-}
-
-void Spell::EffectSummonPlayer(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    // Evil Twin (ignore player summon, but hide this for summoner)
-    if (unitTarget->HasAura(23445))
-        return;
-
-    float x, y, z;
-    m_caster->GetClosePoint(x, y, z, unitTarget->GetObjectSize());
-
-    unitTarget->ToPlayer()->SetSummonPoint(m_caster->GetMapId(),x,y,z);
-
-    WorldPacket data(SMSG_SUMMON_REQUEST, 8+4+4);
-    data << uint64(m_caster->GetGUID());                    // summoner guid
-    data << uint32(m_caster->GetZoneId());                  // summoner zone
-    data << uint32(MAX_PLAYER_SUMMON_DELAY*IN_MILLISECONDS); // auto decline after msecs
-    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-static ScriptInfo generateActivateCommand()
-{
-    ScriptInfo si;
-    si.command = SCRIPT_COMMAND_ACTIVATE_OBJECT;
-    return si;
-}
-
-void Spell::EffectActivateObject(SpellEffIndex effIndex)
-{
-    if (!gameObjTarget)
-        return;
-
-    static ScriptInfo activateCommand = generateActivateCommand();
-
-    int32 delay_secs = m_spellInfo->EffectMiscValue[effIndex];
-
-    gameObjTarget->GetMap()->ScriptCommandStart(activateCommand, delay_secs, m_caster, gameObjTarget);
-}
-
-void Spell::EffectApplyGlyph(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER || m_glyphIndex >= MAX_GLYPH_SLOT_INDEX)
-        return;
-
-    Player *player = (Player*)m_caster;
-
-    // glyph sockets level requirement
-    uint8 minLevel = 0;
-    switch (m_glyphIndex)
-    {
-        case 0:
-        case 1: minLevel = 15; break;
-        case 2: minLevel = 50; break;
-        case 3: minLevel = 30; break;
-        case 4: minLevel = 70; break;
-        case 5: minLevel = 80; break;
-    }
-    if (minLevel && m_caster->getLevel() < minLevel)
-    {
-        SendCastResult(SPELL_FAILED_GLYPH_SOCKET_LOCKED);
-        return;
-    }
-
-    // apply new one
-    if (uint32 glyph = m_spellInfo->EffectMiscValue[effIndex])
-    {
-        if (GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(glyph))
-        {
-            if (GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(player->GetGlyphSlot(m_glyphIndex)))
-            {
-                if (gp->TypeFlags != gs->TypeFlags)
-                {
-                    SendCastResult(SPELL_FAILED_INVALID_GLYPH);
-                    return;                                 // glyph slot mismatch
-                }
-            }
-
-            // remove old glyph
-            if (uint32 oldglyph = player->GetGlyph(m_glyphIndex))
-            {
-                if (GlyphPropertiesEntry const *old_gp = sGlyphPropertiesStore.LookupEntry(oldglyph))
-                {
-                    player->RemoveAurasDueToSpell(old_gp->SpellId);
-                    player->SetGlyph(m_glyphIndex, 0);
-                }
-            }
-
-            player->CastSpell(m_caster, gp->SpellId, true);
-            player->SetGlyph(m_glyphIndex, glyph);
-            player->SendTalentsInfoData(false);
-        }
-    }
-}
-
-void Spell::EffectEnchantHeldItem(SpellEffIndex effIndex)
-{
-    // this is only item spell effect applied to main-hand weapon of target player (players in area)
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* item_owner = (Player*)unitTarget;
-    Item* item = item_owner->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
-
-    if (!item)
-        return;
-
-    // must be equipped
-    if (!item ->IsEquipped())
-        return;
-
-    if (m_spellInfo->EffectMiscValue[effIndex])
-    {
-        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
-        int32 duration = GetSpellDuration(m_spellInfo);          //Try duration index first ..
-        if (!duration)
-            duration = damage;//+1;            //Base points after ..
-        if (!duration)
-            duration = 10;                                  //10 seconds for enchants which don't have listed duration
-
-        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-        if (!pEnchant)
-            return;
-
-        // Always go to temp enchantment slot
-        EnchantmentSlot slot = TEMP_ENCHANTMENT_SLOT;
-
-        // Enchantment will not be applied if a different one already exists
-        if (item->GetEnchantmentId(slot) && item->GetEnchantmentId(slot) != enchant_id)
-            return;
-
-        // Apply the temporary enchantment
-        item->SetEnchantment(slot, enchant_id, duration*IN_MILLISECONDS, 0);
-        item_owner->ApplyEnchantment(item, slot, true);
-    }
-}
-
-void Spell::EffectDisEnchant(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-    if (!itemTarget || !itemTarget->GetProto()->DisenchantID)
-        return;
-
-    p_caster->UpdateCraftSkill(m_spellInfo->Id);
-
-    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(),LOOT_DISENCHANTING);
-
-    // item will be removed at disenchanting end
-}
-
-void Spell::EffectInebriate(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *player = (Player*)unitTarget;
-    uint16 currentDrunk = player->GetDrunkValue();
-    uint16 drunkMod = damage * 256;
-    if (currentDrunk + drunkMod > 0xFFFF)
-        currentDrunk = 0xFFFF;
-    else
-        currentDrunk += drunkMod;
-    player->SetDrunkValue(currentDrunk, m_CastItem ? m_CastItem->GetEntry() : 0);
-}
-
-void Spell::EffectFeedPet(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)m_caster;
-
-    Item* foodItem = m_targets.getItemTarget();
-    if (!foodItem)
-        return;
-
-    Pet *pet = _player->GetPet();
-    if (!pet)
-        return;
-
-    if (!pet->isAlive())
-        return;
-
-    int32 benefit = pet->GetCurrentFoodBenefitLevel(foodItem->GetProto()->ItemLevel);
-    if (benefit <= 0)
-        return;
-
-    ExecuteLogEffectDestroyItem(effIndex, foodItem->GetEntry());
-
-    uint32 count = 1;
-    _player->DestroyItemCount(foodItem, count, true);
-    // TODO: fix crash when a spell has two effects, both pointed at the same item target
-
-    m_caster->CastCustomSpell(pet, m_spellInfo->EffectTriggerSpell[effIndex], &benefit, NULL, NULL, true);
-}
-
-void Spell::EffectDismissPet(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Pet* pet = m_caster->ToPlayer()->GetPet();
-
-    // not let dismiss dead pet
-    if (!pet||!pet->isAlive())
-        return;
-
-    ExecuteLogEffectUnsummonObject(effIndex, pet);
-    m_caster->ToPlayer()->RemovePet(pet, PET_SAVE_NOT_IN_SLOT);
-}
-
-void Spell::EffectSummonObject(SpellEffIndex effIndex)
-{
-    uint32 go_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    uint8 slot = 0;
-    switch(m_spellInfo->Effect[effIndex])
-    {
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT1: slot = 0; break;
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT2: slot = 1; break;
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT3: slot = 2; break;
-        case SPELL_EFFECT_SUMMON_OBJECT_SLOT4: slot = 3; break;
-        default: return;
-    }
-
-    uint64 guid = m_caster->m_ObjectSlot[slot];
-    if (guid != 0)
-    {
-        GameObject* obj = NULL;
-        if (m_caster)
-            obj = m_caster->GetMap()->GetGameObject(guid);
-
-        if (obj)
-        {
-            // Recast case - null spell id to make auras not be removed on object remove from world
-            if (m_spellInfo->Id == obj->GetSpellId())
-                obj->SetSpellId(0);
-            m_caster->RemoveGameObject(obj, true);
-        }
-        m_caster->m_ObjectSlot[slot] = 0;
-    }
-
-    GameObject* pGameObj = new GameObject;
-
-    float x, y, z;
-    // If dest location if present
-    if (m_targets.HasDst())
-        m_targets.m_dstPos.GetPosition(x, y, z);
-    // Summon in random point all other units if location present
-    else
-        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
-
-    Map *map = m_caster->GetMap();
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), go_id, map,
-        m_caster->GetPhaseMask(), x, y, z, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL,m_caster->getLevel());
-    int32 duration = GetSpellDuration(m_spellInfo);
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-    pGameObj->SetSpellId(m_spellInfo->Id);
-    m_caster->AddGameObject(pGameObj);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    map->Add(pGameObj);
-
-    m_caster->m_ObjectSlot[slot] = pGameObj->GetGUID();
-}
-
-void Spell::EffectResurrect(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    if (unitTarget->isAlive())
-        return;
-    if (!unitTarget->IsInWorld())
-        return;
-
-    switch (m_spellInfo->Id)
-    {
-        // Defibrillate (Goblin Jumper Cables) have 33% chance on success
-        case 8342:
-            if (roll_chance_i(67))
-            {
-                m_caster->CastSpell(m_caster, 8338, true, m_CastItem);
-                return;
-            }
-            break;
-        // Defibrillate (Goblin Jumper Cables XL) have 50% chance on success
-        case 22999:
-            if (roll_chance_i(50))
-            {
-                m_caster->CastSpell(m_caster, 23055, true, m_CastItem);
-                return;
-            }
-            break;
-        // Defibrillate ( Gnomish Army Knife) have 67% chance on success_list
-        case 54732:
-            if (roll_chance_i(33))
-            {
-                return;
-            }
-            break;
-        default:
-            break;
-    }
-
-    Player* pTarget = unitTarget->ToPlayer();
-
-    if (pTarget->isRessurectRequested())       // already have one active request
-        return;
-
-    uint32 health = pTarget->CountPctFromMaxHealth(damage);
-    uint32 mana   = pTarget->GetMaxPower(POWER_MANA) * damage / 100;
-
-    ExecuteLogEffectResurrect(effIndex, pTarget);
-
-    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
-    SendResurrectRequest(pTarget);
-}
-
-void Spell::EffectAddExtraAttacks(SpellEffIndex effIndex)
-{
-    if (!unitTarget || !unitTarget->isAlive() || !unitTarget->getVictim())
-        return;
-
-    if (unitTarget->m_extraAttacks)
-        return;
-
-    unitTarget->m_extraAttacks = damage;
-
-    ExecuteLogEffectExtraAttacks(effIndex, unitTarget->getVictim(), damage);
-}
-
-void Spell::EffectParry(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->SetCanParry(true);
-}
-
-void Spell::EffectBlock(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->SetCanBlock(true);
-}
-
-void Spell::EffectLeap(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->isInFlight())
-        return;
-
-    if (!m_targets.HasDst())
-        return;
-
-    unitTarget->NearTeleportTo(m_targets.m_dstPos.GetPositionX(), m_targets.m_dstPos.GetPositionY(), m_targets.m_dstPos.GetPositionZ(), m_targets.m_dstPos.GetOrientation(), unitTarget == m_caster);
-}
-
-void Spell::EffectReputation(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *_player = (Player*)unitTarget;
-
-    int32  rep_change = damage;//+1;           // field store reputation change -1
-
-    uint32 faction_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id);
-
-    if (!factionEntry)
-        return;
-
-    if (RepRewardRate const * repData = sObjectMgr.GetRepRewardRate(faction_id))
-    {
-        rep_change = int32((float)rep_change * repData->spell_rate);
-    }
-
-    _player->GetReputationMgr().ModifyReputation(factionEntry, rep_change);
-}
-
-void Spell::EffectQuestComplete(SpellEffIndex effIndex)
-{
-    Player *pPlayer;
-
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = (Player*)m_caster;
-    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = (Player*)unitTarget;
-    else
-        return;
-
-    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
-    if (quest_id)
-    {
-        uint16 log_slot = pPlayer->FindQuestSlot(quest_id);
-        if (log_slot < MAX_QUEST_LOG_SIZE)
-            pPlayer->AreaExploredOrEventHappens(quest_id);
-        else if (!pPlayer->GetQuestRewardStatus(quest_id))   // never rewarded before
-            pPlayer->CompleteQuest(quest_id);   // quest not in log - for internal use
-    }
-}
-
-void Spell::EffectForceDeselect(SpellEffIndex /*effIndex*/)
-{
-    WorldPacket data(SMSG_CLEAR_TARGET, 8);
-    data << uint64(m_caster->GetGUID());
-    m_caster->SendMessageToSet(&data, true);
-}
-
-void Spell::EffectSelfResurrect(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->isAlive())
-        return;
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!unitTarget->IsInWorld())
-        return;
-
-    uint32 health = 0;
-    uint32 mana = 0;
-
-    // flat case
-    if (damage < 0)
-    {
-        health = uint32(-damage);
-        mana = m_spellInfo->EffectMiscValue[effIndex];
-    }
-    // percent case
-    else
-    {
-        health = unitTarget->CountPctFromMaxHealth(damage);
-        if (unitTarget->GetMaxPower(POWER_MANA) > 0)
-            mana = uint32(damage/100.0f*unitTarget->GetMaxPower(POWER_MANA));
-    }
-
-    Player *plr = unitTarget->ToPlayer();
-    plr->ResurrectPlayer(0.0f);
-
-    plr->SetHealth(health);
-    plr->SetPower(POWER_MANA, mana);
-    plr->SetPower(POWER_RAGE, 0);
-    plr->SetPower(POWER_ENERGY, plr->GetMaxPower(POWER_ENERGY));
-
-    plr->SpawnCorpseBones();
-}
-
-void Spell::EffectSkinning(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget->GetTypeId() != TYPEID_UNIT)
-        return;
-    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Creature* creature = unitTarget->ToCreature();
-    int32 targetLevel = creature->getLevel();
-
-    uint32 skill = creature->GetCreatureInfo()->GetRequiredLootSkill();
-
-    m_caster->ToPlayer()->SendLoot(creature->GetGUID(),LOOT_SKINNING);
-    creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
-
-    int32 reqValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel-10)*10 : targetLevel*5;
-
-    int32 skillValue = m_caster->ToPlayer()->GetPureSkillValue(skill);
-
-    // Double chances for elites
-    m_caster->ToPlayer()->UpdateGatherSkill(skill, skillValue, reqValue, creature->isElite() ? 2 : 1);
-}
-
-void Spell::EffectCharge(SpellEffIndex /*effIndex*/)
-{
-    Unit *target = m_targets.getUnitTarget();
-    if (!target)
-        return;
-
-    float x, y, z;
-    target->GetContactPoint(m_caster, x, y, z);
-    m_caster->GetMotionMaster()->MoveCharge(x, y, z);
-
-    // not all charge effects used in negative spells
-    if (!IsPositiveSpell(m_spellInfo->Id) && m_caster->GetTypeId() == TYPEID_PLAYER)
-        m_caster->Attack(target, true);
-}
-
-void Spell::EffectChargeDest(SpellEffIndex /*effIndex*/)
-{
-    if (m_targets.HasDst())
-    {
-        float x, y, z;
-        m_targets.m_dstPos.GetPosition(x, y, z);
-        m_caster->GetMotionMaster()->MoveCharge(x, y, z);
-    }
-}
-
-void Spell::EffectKnockBack(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    // Instantly interrupt non melee spells being casted
-    if (unitTarget->IsNonMeleeSpellCasted(true))
-        unitTarget->InterruptNonMeleeSpells(true);
-
-    // Typhoon
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x01000000)
-    {
-        // Glyph of Typhoon
-        if (m_caster->HasAura(62135))
-            return;
-    }
-
-    // Thunderstorm
-    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[1] & 0x00002000)
-    {
-        // Glyph of Thunderstorm
-        if (m_caster->HasAura(62132))
-            return;
-    }
-
-    float ratio = m_caster->GetCombatReach() / std::max(unitTarget->GetCombatReach(), 1.0f);
-    if (ratio < 1.0f)
-        ratio = ratio * ratio * ratio * 0.1f; // volume = length^3
-    else
-        ratio = 0.1f; // dbc value ratio
-    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex]) * ratio;
-    float speedz = float(damage) * ratio;
-    if (speedxy < 0.1f && speedz < 0.1f)
-        return;
-
-    float x, y;
-    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_KNOCK_BACK_DEST)
-    {
-        if (m_targets.HasDst())
-            m_targets.m_dstPos.GetPosition(x, y);
-        else
-            return;
-    }
-    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_KNOCK_BACK)
-    {
-        m_caster->GetPosition(x, y);
-    }
-
-    unitTarget->KnockbackFrom(x, y, speedxy, speedz);
-}
-
-void Spell::EffectLeapBack(SpellEffIndex effIndex)
-{
-    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex])/10;
-    float speedz = float(damage/10);
-    if (!speedxy)
-    {
-        if (m_targets.getUnitTarget())
-            m_caster->JumpTo(m_targets.getUnitTarget(), speedz);
-    }
-    else
-    {
-        //1891: Disengage
-        m_caster->JumpTo(speedxy, speedz, m_spellInfo->SpellIconID != 1891);
-    }
-}
-
-void Spell::EffectQuestClear(SpellEffIndex effIndex)
-{
-    Player *pPlayer = NULL;
-    if (m_caster->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = m_caster->ToPlayer();
-    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        pPlayer = unitTarget->ToPlayer();
-
-    if (!pPlayer)
-        return;
-
-    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest_id);
-
-    if (!pQuest)
-        return;
-
-    QuestStatusMap::iterator qs_itr = pPlayer->getQuestStatusMap().find(quest_id);
-    // Player has never done this quest
-    if (qs_itr == pPlayer->getQuestStatusMap().end())
-        return;
-
-    // remove all quest entries for 'entry' from quest log
-    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
-    {
-        uint32 quest = pPlayer->GetQuestSlotQuestId(slot);
-        if (quest == quest_id)
-        {
-            pPlayer->SetQuestSlot(slot, 0);
-
-            // we ignore unequippable quest items in this case, its' still be equipped
-            pPlayer->TakeQuestSourceItem(quest, false);
-        }
-    }
-
-    // set quest status to not started (will be updated in DB at next save)
-    pPlayer->SetQuestStatus(quest_id, QUEST_STATUS_NONE);
-
-    // reset rewarded for restart repeatable quest
-    QuestStatusData &data = qs_itr->second;
-    data.m_rewarded = false;
-}
-
-void Spell::EffectSendTaxi(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->ActivateTaxiPathTo(m_spellInfo->EffectMiscValue[effIndex],m_spellInfo->Id);
-}
-
-void Spell::EffectPullTowards(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    float speedZ = (float)(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex) / 10);
-    float speedXY = (float)(m_spellInfo->EffectMiscValue[effIndex]/10);
-    Position pos;
-    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_PULL_TOWARDS_DEST)
-    {
-        if (m_targets.HasDst())
-            pos.Relocate(m_targets.m_dstPos);
-        else
-            return;
-    }
-    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_PULL_TOWARDS)
-    {
-        pos.Relocate(m_caster);
-    }
-
-    unitTarget->GetMotionMaster()->MoveJump(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), speedXY, speedZ);
-}
-
-void Spell::EffectDispelMechanic(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-
-    uint32 mechanic = m_spellInfo->EffectMiscValue[effIndex];
-
-    std::queue < std::pair < uint32, uint64 > > dispel_list;
-
-    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
-    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        Aura * aura = itr->second;
-        if (!aura->GetApplicationOfTarget(unitTarget->GetGUID()))
-            continue;
-        bool success = false;
-        GetDispelChance(aura->GetCaster(), unitTarget, aura->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success);
-        if ((GetAllSpellMechanicMask(aura->GetSpellProto()) & (1 << mechanic)) && success)
-            dispel_list.push(std::make_pair(aura->GetId(), aura->GetCasterGUID()));
-    }
-
-    for (; dispel_list.size(); dispel_list.pop())
-    {
-        unitTarget->RemoveAura(dispel_list.front().first, dispel_list.front().second, 0, AURA_REMOVE_BY_ENEMY_SPELL);
-    }
-}
-
-void Spell::EffectSummonDeadPet(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-    Player *_player = (Player*)m_caster;
-    Pet *pet = _player->GetPet();
-    if (!pet)
-        return;
-    if (pet->isAlive())
-        return;
-    if (damage < 0)
-        return;
-
-    float x,y,z;
-    _player->GetPosition(x, y, z);
-    _player->GetMap()->CreatureRelocation(pet, x, y, z, _player->GetOrientation());
-
-    pet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
-    pet->RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
-    pet->setDeathState(ALIVE);
-    pet->clearUnitState(UNIT_STAT_ALL_STATE);
-    pet->SetHealth(pet->CountPctFromMaxHealth(damage));
-
-    //pet->AIM_Initialize();
-    //_player->PetSpellInitialize();
-    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-}
-
-void Spell::EffectDestroyAllTotems(SpellEffIndex /*effIndex*/)
-{
-    int32 mana = 0;
-    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
-    {
-        if (!m_caster->m_SummonSlot[slot])
-            continue;
-
-        Creature* totem = m_caster->GetMap()->GetCreature(m_caster->m_SummonSlot[slot]);
-        if (totem && totem->isTotem())
-        {
-            uint32 spell_id = totem->GetUInt32Value(UNIT_CREATED_BY_SPELL);
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell_id);
-            if (spellInfo)
-            {
-                mana += spellInfo->manaCost;
-                mana += spellInfo->ManaCostPercentage * m_caster->GetCreateMana() / 100;
-            }
-            totem->ToTotem()->UnSummon();
-        }
-    }
-    mana = mana * damage / 100;
-
-    if (mana)
-        m_caster->CastCustomSpell(m_caster, 39104, &mana, NULL, NULL, true);
-}
-
-void Spell::EffectDurabilityDamage(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
-
-    // FIXME: some spells effects have value -1/-2
-    // Possibly its mean -1 all player equipped items and -2 all items
-    if (slot < 0)
-    {
-        unitTarget->ToPlayer()->DurabilityPointsLossAll(damage, (slot < -1));
-        return;
-    }
-
-    // invalid slot value
-    if (slot >= INVENTORY_SLOT_BAG_END)
-        return;
-
-    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
-        unitTarget->ToPlayer()->DurabilityPointsLoss(item, damage);
-
-    ExecuteLogEffectDurabilityDamage(effIndex, unitTarget, slot, damage);
-}
-
-void Spell::EffectDurabilityDamagePCT(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
-
-    // FIXME: some spells effects have value -1/-2
-    // Possibly its mean -1 all player equipped items and -2 all items
-    if (slot < 0)
-    {
-        unitTarget->ToPlayer()->DurabilityLossAll(double(damage)/100.0f, (slot < -1));
-        return;
-    }
-
-    // invalid slot value
-    if (slot >= INVENTORY_SLOT_BAG_END)
-        return;
-
-    if (damage <= 0)
-        return;
-
-    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
-        unitTarget->ToPlayer()->DurabilityLoss(item, double(damage)/100.0f);
-}
-
-void Spell::EffectModifyThreatPercent(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget)
-        return;
-
-    unitTarget->getThreatManager().modifyThreatPercent(m_caster, damage);
-}
-
-void Spell::EffectTransmitted(SpellEffIndex effIndex)
-{
-    uint32 name_id = m_spellInfo->EffectMiscValue[effIndex];
-
-    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(name_id);
-
-    if (!goinfo)
-    {
-        sLog.outErrorDb("Gameobject (Entry: %u) not exist and not created at spell (ID: %u) cast",name_id, m_spellInfo->Id);
-        return;
-    }
-
-    float fx, fy, fz;
-
-    if (m_targets.HasDst())
-        m_targets.m_dstPos.GetPosition(fx, fy, fz);
-    //FIXME: this can be better check for most objects but still hack
-    else if (m_spellInfo->EffectRadiusIndex[effIndex] && m_spellInfo->speed == 0)
-    {
-        float dis = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
-        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
-    }
-    else
-    {
-        //GO is always friendly to it's creator, get range for friends
-        float min_dis = GetSpellMinRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
-        float max_dis = GetSpellMaxRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
-        float dis = (float)rand_norm() * (max_dis - min_dis) + min_dis;
-
-        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
-    }
-
-    Map *cMap = m_caster->GetMap();
-    if (goinfo->type == GAMEOBJECT_TYPE_FISHINGNODE)
-    {
-        LiquidData liqData;
-        if ( !cMap->IsInWater(fx, fy, fz + 1.f/* -0.5f */, &liqData))             // Hack to prevent fishing bobber from failing to land on fishing hole
-        { // but this is not proper, we really need to ignore not materialized objects
-            SendCastResult(SPELL_FAILED_NOT_HERE);
-            SendChannelUpdate(0);
-            return;
-        }
-
-        // replace by water level in this case
-        //fz = cMap->GetWaterLevel(fx, fy);
-        fz = liqData.level;
-    }
-    // if gameobject is summoning object, it should be spawned right on caster's position
-    else if (goinfo->type == GAMEOBJECT_TYPE_SUMMONING_RITUAL)
-    {
-        m_caster->GetPosition(fx, fy, fz);
-    }
-
-    GameObject* pGameObj = new GameObject;
-
-    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), name_id, cMap,
-        m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-    {
-        delete pGameObj;
-        return;
-    }
-
-    int32 duration = GetSpellDuration(m_spellInfo);
-
-    switch(goinfo->type)
-    {
-        case GAMEOBJECT_TYPE_FISHINGNODE:
-        {
-            m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT,pGameObj->GetGUID());
-            m_caster->AddGameObject(pGameObj);              // will removed at spell cancel
-
-            // end time of range when possible catch fish (FISHING_BOBBER_READY_TIME..GetDuration(m_spellInfo))
-            // start time == fish-FISHING_BOBBER_READY_TIME (0..GetDuration(m_spellInfo)-FISHING_BOBBER_READY_TIME)
-            int32 lastSec = 0;
-            switch(urand(0, 3))
-            {
-                case 0: lastSec =  3; break;
-                case 1: lastSec =  7; break;
-                case 2: lastSec = 13; break;
-                case 3: lastSec = 17; break;
-            }
-
-            duration = duration - lastSec*IN_MILLISECONDS + FISHING_BOBBER_READY_TIME*IN_MILLISECONDS;
-            break;
-        }
-        case GAMEOBJECT_TYPE_SUMMONING_RITUAL:
-        {
-            if (m_caster->GetTypeId() == TYPEID_PLAYER)
-            {
-          pGameObj->AddUniqueUse(m_caster->ToPlayer());
-          m_caster->AddGameObject(pGameObj);          // will removed at spell cancel
-            }
-            break;
-        }
-        case GAMEOBJECT_TYPE_DUEL_ARBITER: // 52991
-            m_caster->AddGameObject(pGameObj);
-            break;
-        case GAMEOBJECT_TYPE_FISHINGHOLE:
-        case GAMEOBJECT_TYPE_CHEST:
-        default:
-            break;
-    }
-
-    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-
-    pGameObj->SetOwnerGUID(m_caster->GetGUID());
-
-    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
-    pGameObj->SetSpellId(m_spellInfo->Id);
-
-    ExecuteLogEffectSummonObject(effIndex, pGameObj);
-
-    sLog.outStaticDebug("AddObject at SpellEfects.cpp EffectTransmitted");
-    //m_caster->AddGameObject(pGameObj);
-    //m_ObjToDel.push_back(pGameObj);
-
-    cMap->Add(pGameObj);
-
-    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
-    {
-        GameObject* linkedGO = new GameObject;
-        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, cMap,
-            m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
-        {
-            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
-            //linkedGO->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
-            linkedGO->SetSpellId(m_spellInfo->Id);
-            linkedGO->SetOwnerGUID(m_caster->GetGUID());
-
-            ExecuteLogEffectSummonObject(effIndex, linkedGO);
-
-            linkedGO->GetMap()->Add(linkedGO);
-        }
-        else
-        {
-            delete linkedGO;
-            linkedGO = NULL;
-            return;
-        }
-    }
-}
-
-void Spell::EffectProspecting(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_PROSPECTABLE))
-        return;
-
-    if (itemTarget->GetCount() < 5)
-        return;
-
-    if (sWorld.getBoolConfig(CONFIG_SKILL_PROSPECTING))
-    {
-        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_JEWELCRAFTING);
-        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
-        p_caster->UpdateGatherSkill(SKILL_JEWELCRAFTING, SkillValue, reqSkillValue);
-    }
-
-    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_PROSPECTING);
-}
-
-void Spell::EffectMilling(SpellEffIndex /*effIndex*/)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* p_caster = (Player*)m_caster;
-    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_MILLABLE))
-        return;
-
-    if (itemTarget->GetCount() < 5)
-        return;
-
-    if (sWorld.getBoolConfig(CONFIG_SKILL_MILLING))
-    {
-        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_INSCRIPTION);
-        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
-        p_caster->UpdateGatherSkill(SKILL_INSCRIPTION, SkillValue, reqSkillValue);
-    }
-
-    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_MILLING);
-}
-
-void Spell::EffectSkill(SpellEffIndex /*effIndex*/)
-{
-    sLog.outDebug("WORLD: SkillEFFECT");
-}
-
-/* There is currently no need for this effect. We handle it in Battleground.cpp
-   If we would handle the resurrection here, the spiritguide would instantly disappear as the
-   player revives, and so we wouldn't see the spirit heal visual effect on the npc.
-   This is why we use a half sec delay between the visual effect and the resurrection itself */
-void Spell::EffectSpiritHeal(SpellEffIndex /*effIndex*/)
-{
-    /*
-    if (!unitTarget || unitTarget->isAlive())
-        return;
-    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    if (!unitTarget->IsInWorld())
-        return;
-
-    //m_spellInfo->EffectBasePoints[i]; == 99 (percent?)
-    //unitTarget->ToPlayer()->setResurrect(m_caster->GetGUID(), unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), unitTarget->GetMaxHealth(), unitTarget->GetMaxPower(POWER_MANA));
-    unitTarget->ToPlayer()->ResurrectPlayer(1.0f);
-    unitTarget->ToPlayer()->SpawnCorpseBones();
-    */
-}
-
-// remove insignia spell effect
-void Spell::EffectSkinPlayerCorpse(SpellEffIndex /*effIndex*/)
-{
-    sLog.outDebug("Effect: SkinPlayerCorpse");
-    if ((m_caster->GetTypeId() != TYPEID_PLAYER) || (unitTarget->GetTypeId() != TYPEID_PLAYER) || (unitTarget->isAlive()))
-        return;
-
-    unitTarget->ToPlayer()->RemovedInsignia((Player*)m_caster);
-}
-
-void Spell::EffectStealBeneficialBuff(SpellEffIndex effIndex)
-{
-    sLog.outDebug("Effect: StealBeneficialBuff");
-
-    if (!unitTarget || unitTarget == m_caster)                 // can't steal from self
-        return;
-
-    DispelChargesList steal_list;
-
-    // Create dispel mask by dispel type
-    uint32 dispelMask  = GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[effIndex]));
-    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
-    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
-    {
-        Aura * aura = itr->second;
-        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
-        if (!aurApp)
-            continue;
-
-        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
-        {
-            // Need check for passive? this
-            if (!aurApp->IsPositive() || aura->IsPassive() || aura->GetSpellProto()->AttributesEx4 & SPELL_ATTR_EX4_NOT_STEALABLE)
-                continue;
-
-            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
-            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
-            // Polymorph instead of 1 / (5 + 1) -> 16%.
-            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
-            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
-            if (charges > 0)
-                steal_list.push_back(std::make_pair(aura, charges));
-        }
-    }
-
-    if (steal_list.empty())
-        return;
-
-    // Ok if exist some buffs for dispel try dispel it
-    uint32 failCount = 0;
-    DispelList success_list;
-    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
-    // dispel N = damage buffs (or while exist buffs for dispel)
-    for (int32 count = 0; count < damage && !steal_list.empty();)
-    {
-        // Random select buff for dispel
-        DispelChargesList::iterator itr = steal_list.begin();
-        std::advance(itr, urand(0, steal_list.size() - 1));
-
-        bool success = false;
-        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
-        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
-        {
-            steal_list.erase(itr);
-            continue;
-        }
-        else
-        {
-            if (success)
-            {
-                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
-                --itr->second;
-                if (itr->second <= 0)
-                    steal_list.erase(itr);
-            }
-            else
-            {
-                if (!failCount)
-                {
-                    // Failed to dispell
-                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
-                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
-                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
-                }
-                ++failCount;
-                dataFail << uint32(itr->first->GetId());                         // Spell Id
-            }
-            ++count;
-        }
-    }
-
-    if (failCount)
-        m_caster->SendMessageToSet(&dataFail, true);
-
-    if (success_list.empty())
-        return;
-
-    WorldPacket dataSuccess(SMSG_SPELLSTEALLOG, 8+8+4+1+4+damage*5);
-    dataSuccess.append(unitTarget->GetPackGUID());  // Victim GUID
-    dataSuccess.append(m_caster->GetPackGUID());    // Caster GUID
-    dataSuccess << uint32(m_spellInfo->Id);         // dispel spell id
-    dataSuccess << uint8(0);                        // not used
-    dataSuccess << uint32(success_list.size());     // count
-    for (DispelList::iterator itr = success_list.begin(); itr!=success_list.end(); ++itr)
-    {
-        dataSuccess << uint32(itr->first);          // Spell Id
-        dataSuccess << uint8(0);                    // 0 - steals !=0 transfers
-        unitTarget->RemoveAurasDueToSpellBySteal(itr->first, itr->second, m_caster);
-    }
-    m_caster->SendMessageToSet(&dataSuccess, true);
-}
-
-void Spell::EffectKillCreditPersonal(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->KilledMonsterCredit(m_spellInfo->EffectMiscValue[effIndex], 0);
-}
-
-void Spell::EffectKillCredit(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    int32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
-    if (!creatureEntry)
-    {
-        if (m_spellInfo->Id == 42793) // Burn Body
-            creatureEntry = 24008; // Fallen Combatant
-    }
-
-    if (creatureEntry)
-        unitTarget->ToPlayer()->RewardPlayerAndGroupAtEvent(creatureEntry, unitTarget);
-}
-
-void Spell::EffectQuestFail(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->FailQuest(m_spellInfo->EffectMiscValue[effIndex]);
-}
-
-void Spell::EffectQuestStart(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player * player = unitTarget->ToPlayer();
-    if (Quest const* qInfo = sObjectMgr.GetQuestTemplate(m_spellInfo->EffectMiscValue[effIndex]))
-    {
-        if (player->CanTakeQuest(qInfo, false) && player->CanAddQuest(qInfo, false))
-        {
-            player->AddQuest(qInfo, NULL);
-        }
-    }
-}
-
-void Spell::EffectActivateRune(SpellEffIndex effIndex)
-{
-    if (m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *plr = (Player*)m_caster;
-
-    if (plr->getClass() != CLASS_DEATH_KNIGHT)
-        return;
-
-    // needed later
-    m_runesState = m_caster->ToPlayer()->GetRunesState();
-
-    uint32 count = damage;
-    if (count == 0) count = 1;
-    for (uint32 j = 0; j < MAX_RUNES && count > 0; ++j)
-    {
-        if (plr->GetRuneCooldown(j) && plr->GetCurrentRune(j) == RuneType(m_spellInfo->EffectMiscValue[effIndex]))
-        {
-            plr->SetRuneCooldown(j, 0);
-            --count;
-        }
-    }
-    // Empower rune weapon
-    if (m_spellInfo->Id == 47568)
-    {
-        // Need to do this just once
-        if (effIndex != 0)
-            return;
-
-        for (uint32 i = 0; i < MAX_RUNES; ++i)
-        {
-            if (plr->GetRuneCooldown(i) && (plr->GetCurrentRune(i) == RUNE_FROST ||  plr->GetCurrentRune(i) == RUNE_DEATH))
-                plr->SetRuneCooldown(i, 0);
-        }
-    }
-}
-
-void Spell::EffectCreateTamedPet(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || unitTarget->GetPetGUID() || unitTarget->getClass() != CLASS_HUNTER)
-        return;
-
-    uint32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
-    Pet * pet = unitTarget->CreateTamedPetFrom(creatureEntry, m_spellInfo->Id);
-    if (!pet)
-        return;
-
-    // add to world
-    pet->GetMap()->Add(pet->ToCreature());
-
-    // unitTarget has pet now
-    unitTarget->SetMinion(pet, true);
-
-    pet->InitTalentForLevel();
-
-    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
-    {
-        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
-        unitTarget->ToPlayer()->PetSpellInitialize();
-    }
-}
-
-void Spell::EffectDiscoverTaxi(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-    uint32 nodeid = m_spellInfo->EffectMiscValue[effIndex];
-    if (sTaxiNodesStore.LookupEntry(nodeid))
-        unitTarget->ToPlayer()->GetSession()->SendDiscoverNewTaxiNode(nodeid);
-}
-
-void Spell::EffectTitanGrip(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
-        unitTarget->ToPlayer()->SetCanTitanGrip(true);
-}
-
-void Spell::EffectRedirectThreat(SpellEffIndex /*effIndex*/)
-{
-    if (unitTarget)
-        m_caster->SetReducedThreatPercent((uint32)damage, unitTarget->GetGUID());
-}
-
-void Spell::EffectWMODamage(SpellEffIndex /*effIndex*/)
-{
-    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-    {
-        Unit *caster = m_originalCaster;
-        if (!caster)
-            return;
-
-        FactionTemplateEntry const *casterft, *goft;
-        casterft = caster->getFactionTemplateEntry();
-        goft = sFactionTemplateStore.LookupEntry(gameObjTarget->GetUInt32Value(GAMEOBJECT_FACTION));
-        // Do not allow to damage GO's of friendly factions (ie: Wintergrasp Walls)
-        if (casterft && goft && !casterft->IsFriendlyTo(*goft))
-        {
-            gameObjTarget->TakenDamage(uint32(damage), caster);
-            WorldPacket data(SMSG_DESTRUCTIBLE_BUILDING_DAMAGE, 8+8+8+4+4);
-            data.append(gameObjTarget->GetPackGUID());
-            data.append(caster->GetPackGUID());
-            if (Unit *who = caster->GetCharmerOrOwner())
-                data.append(who->GetPackGUID());
-            else
-                data << uint8(0);
-            data << uint32(damage);
-            data << uint32(m_spellInfo->Id);
-            gameObjTarget->SendMessageToSet(&data, false);
-        }
-    }
-}
-
-void Spell::EffectWMORepair(SpellEffIndex /*effIndex*/)
-{
-    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
-        gameObjTarget->Rebuild();
-}
-
-void Spell::SummonGuardian(uint32 i, uint32 entry, SummonPropertiesEntry const *properties)
-{
-    Unit *caster = m_originalCaster;
-    if (!caster)
-        return;
-
-    if (caster->isTotem())
-      caster = caster->ToTotem()->GetOwner();
-
-    // in another case summon new
-    uint8 level = caster->getLevel();
-
-    // level of pet summoned using engineering item based at engineering skill level
-    if (m_CastItem && caster->GetTypeId() == TYPEID_PLAYER)
-        if (ItemPrototype const *proto = m_CastItem->GetProto())
-            if (proto->RequiredSkill == SKILL_ENGINERING)
-                if (uint16 skill202 = caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING))
-                    level = skill202/5;
-
-    //float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
-    float radius = 5.0f;
-    uint32 amount = damage > 0 ? damage : 1;
-    int32 duration = GetSpellDuration(m_spellInfo);
-    switch (m_spellInfo->Id)
-    {
-        case 1122: // Inferno
-            amount = 1;
-            break;
-        case 49028: // Dancing Rune Weapon
-            if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(63330, 0)) // glyph of Dancing Rune Weapon
-                duration += aurEff->GetAmount();
-            break;
-    }
-    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
-        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
-
-    //TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
-    Map *map = caster->GetMap();
-
-    for (uint32 count = 0; count < amount; ++count)
-    {
-        Position pos;
-        GetSummonPosition(i, pos, radius, count);
-
-        TempSummon *summon = map->SummonCreature(entry, pos, properties, duration, caster);
-        if (!summon)
-            return;
-        if (summon->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
-            ((Guardian*)summon)->InitStatsForLevel(level);
-
-        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
-        if (summon->HasUnitTypeMask(UNIT_MASK_MINION) && m_targets.HasDst())
-            ((Minion*)summon)->SetFollowAngle(m_caster->GetAngle(summon));
-
-        if (summon->GetEntry() == 27893)
-        {
-            if (uint32 weapon = m_caster->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID))
-            {
-                summon->SetDisplayId(11686);
-                summon->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, weapon);
-            }
-            else
-                summon->SetDisplayId(1126);
-        }
-
-        summon->AI()->EnterEvadeMode();
-
-        ExecuteLogEffectSummonObject(i, summon);
-    }
-}
-
-void Spell::GetSummonPosition(uint32 i, Position &pos, float radius, uint32 count)
-{
-    pos.SetOrientation(m_caster->GetOrientation());
-
-    if (m_targets.HasDst())
-    {
-        // Summon 1 unit in dest location
-        if (count == 0)
-            pos.Relocate(m_targets.m_dstPos);
-        // Summon in random point all other units if location present
-        else
-        {
-            //This is a workaround. Do not have time to write much about it
-            switch (m_spellInfo->EffectImplicitTargetA[i])
-            {
-                case TARGET_MINION:
-                case TARGET_DEST_CASTER_RANDOM:
-                    m_caster->GetNearPosition(pos, radius * (float)rand_norm(), (float)rand_norm()*static_cast<float>(2*M_PI));
-                    break;
-                case TARGET_DEST_DEST_RANDOM:
-                case TARGET_DEST_TARGET_RANDOM:
-                    m_caster->GetRandomPoint(m_targets.m_dstPos, radius, pos);
-                    break;
-                default:
-                    pos.Relocate(m_targets.m_dstPos);
-                    break;
-            }
-        }
-    }
-    // Summon if dest location not present near caster
-    else
-    {
-        float x, y, z;
-        m_caster->GetClosePoint(x,y,z,3.0f);
-        pos.Relocate(x, y, z);
-    }
-}
-
-void Spell::EffectRenamePet(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT ||
-        !unitTarget->ToCreature()->isPet() || ((Pet*)unitTarget)->getPetType() != HUNTER_PET)
-        return;
-
-    unitTarget->RemoveByteFlag(UNIT_FIELD_BYTES_2, 2, UNIT_CAN_BE_RENAMED);
-}
-
-void Spell::EffectPlayMusic(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    uint32 soundid = m_spellInfo->EffectMiscValue[effIndex];
-
-    if (!sSoundEntriesStore.LookupEntry(soundid))
-    {
-        sLog.outError("EffectPlayMusic: Sound (Id: %u) not exist in spell %u.",soundid,m_spellInfo->Id);
-        return;
-    }
-
-    WorldPacket data(SMSG_PLAY_MUSIC, 4);
-    data << uint32(soundid);
-    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
-}
-
-void Spell::EffectSpecCount(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->UpdateSpecCount(damage);
-}
-
-void Spell::EffectActivateSpec(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    unitTarget->ToPlayer()->ActivateSpec(damage-1);  // damage is 1 or 2, spec is 0 or 1
-}
-
-void Spell::EffectPlayerNotification(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
-
-    switch(m_spellInfo->Id)
-    {
-        case 58730: // Restricted Flight Area
-           {
-             if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-              {
-              if (pvpWG->isWarTime()==true)
-               {
-                unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
-                unitTarget->PlayDirectSound(9417); // Fel Reaver sound
-                unitTarget->MonsterTextEmote("The air is too thin in Wintergrasp for normal flight. You will be ejected in 9 sec.",unitTarget->GetGUID(),true);
-               break;
-               } else unitTarget->RemoveAura(58730);
-              }
-            break;
-            }
-        case 58600: // Restricted Flight Area
-            unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
-            break;
-    }
-}
-
-void Spell::EffectRemoveAura(SpellEffIndex effIndex)
-{
-    if (!unitTarget)
-        return;
-    // there may be need of specifying casterguid of removed auras
-    unitTarget->RemoveAurasDueToSpell(m_spellInfo->EffectTriggerSpell[effIndex]);
-}
-
-void Spell::EffectCastButtons(SpellEffIndex effIndex)
-{
-    if (!unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *p_caster = (Player*)m_caster;
-    uint32 button_id = m_spellInfo->EffectMiscValue[effIndex] + 132;
-    uint32 n_buttons = m_spellInfo->EffectMiscValueB[effIndex];
-
-    for (; n_buttons; n_buttons--, button_id++)
-    {
-        ActionButton const* ab = p_caster->GetActionButton(button_id);
-        if (!ab || ab->GetType() != ACTION_BUTTON_SPELL)
-            continue;
-
-        uint32 spell_id = ab->GetAction();
-        if (!spell_id)
-            continue;
-
-        if (p_caster->HasSpellCooldown(spell_id))
-            continue;
-
-        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
-        uint32 cost = CalculatePowerCost(spellInfo, m_caster, GetSpellSchoolMask(spellInfo));
-
-        if (m_caster->GetPower(POWER_MANA) < cost)
-            break;
-
-        m_caster->CastSpell(unitTarget, spell_id, true);
-        m_caster->ModifyPower(POWER_MANA, -(int32)cost);
-        p_caster->AddSpellAndCategoryCooldowns(spellInfo, 0);
-    }
-}
-
-void Spell::EffectRechargeManaGem(SpellEffIndex /*effIndex*/)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player *player = m_caster->ToPlayer();
-
-    if (!player)
-        return;
-
-    uint32 item_id = m_spellInfo->EffectItemType[0];
-
-    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item_id);
-    if (!pProto)
-    {
-        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
-        return;
-    }
-
-    if (Item* pItem = player->GetItemByEntry(item_id))
-    {
-        for (int x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
-            pItem->SetSpellCharges(x,pProto->Spells[x].SpellCharges);
-        pItem->SetState(ITEM_CHANGED,player);
-    }
-}
-
-void Spell::EffectBind(SpellEffIndex effIndex)
-{
-    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
-        return;
-
-    Player* player = (Player*)unitTarget;
-
-    uint32 area_id;
-    WorldLocation loc;
-    if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DST_DB || m_spellInfo->EffectImplicitTargetB[effIndex] == TARGET_DST_DB)
-    {
-        SpellTargetPosition const* st = sSpellMgr.GetSpellTargetPosition(m_spellInfo->Id);
-        if (!st)
-        {
-            sLog.outError( "Spell::EffectBind - unknown teleport coordinates for spell ID %u", m_spellInfo->Id );
-            return;
-        }
-
-        loc.m_mapId         = st->target_mapId;
-        loc.m_positionX   = st->target_X;
-        loc.m_positionY   = st->target_Y;
-        loc.m_positionZ   = st->target_Y;
-        loc.m_orientation = st->target_Orientation;
-        area_id = player->GetAreaId();
-    }
-    else
-    {
-        player->GetPosition(&loc);
-        area_id = player->GetAreaId();
-    }
-
-    player->SetHomebind(loc, area_id);
-
-    // binding
-    WorldPacket data( SMSG_BINDPOINTUPDATE, (4+4+4+4+4) );
-    data << float(loc.m_positionX);
-    data << float(loc.m_positionY);
-    data << float(loc.m_positionZ);
-    data << uint32(loc.m_mapId);
-    data << uint32(area_id);
-    player->SendDirectMessage( &data );
-
-    sLog.outStaticDebug("New homebind X      : %f", loc.m_positionX);
-    sLog.outStaticDebug("New homebind Y      : %f", loc.m_positionY);
-    sLog.outStaticDebug("New homebind Z      : %f", loc.m_positionZ);
-    sLog.outStaticDebug("New homebind MapId  : %u", loc.m_mapId);
-    sLog.outStaticDebug("New homebind AreaId : %u", area_id);
-
-    // zone update
-    data.Initialize(SMSG_PLAYERBOUND, 8+4);
-    data << uint64(player->GetGUID());
-    data << uint32(area_id);
-    player->SendDirectMessage( &data );
-}
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "DatabaseEnv.h"
+#include "WorldPacket.h"
+#include "Opcodes.h"
+#include "Log.h"
+#include "UpdateMask.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "SkillExtraItems.h"
+#include "Unit.h"
+#include "Spell.h"
+#include "DynamicObject.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "Group.h"
+#include "UpdateData.h"
+#include "MapManager.h"
+#include "ObjectAccessor.h"
+#include "SharedDefines.h"
+#include "Pet.h"
+#include "GameObject.h"
+#include "GossipDef.h"
+#include "Creature.h"
+#include "Totem.h"
+#include "CreatureAI.h"
+#include "BattlegroundMgr.h"
+#include "Battleground.h"
+#include "BattlegroundEY.h"
+#include "BattlegroundWS.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
+#include "Language.h"
+#include "SocialMgr.h"
+#include "Util.h"
+#include "VMapFactory.h"
+#include "TemporarySummon.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "SkillDiscovery.h"
+#include "Formulas.h"
+#include "Vehicle.h"
+#include "ScriptMgr.h"
+
+pEffect SpellEffects[TOTAL_SPELL_EFFECTS]=
+{
+    &Spell::EffectNULL,                                     //  0
+    &Spell::EffectInstaKill,                                //  1 SPELL_EFFECT_INSTAKILL
+    &Spell::EffectSchoolDMG,                                //  2 SPELL_EFFECT_SCHOOL_DAMAGE
+    &Spell::EffectDummy,                                    //  3 SPELL_EFFECT_DUMMY
+    &Spell::EffectUnused,                                   //  4 SPELL_EFFECT_PORTAL_TELEPORT          unused
+    &Spell::EffectTeleportUnits,                            //  5 SPELL_EFFECT_TELEPORT_UNITS
+    &Spell::EffectApplyAura,                                //  6 SPELL_EFFECT_APPLY_AURA
+    &Spell::EffectEnvirinmentalDMG,                         //  7 SPELL_EFFECT_ENVIRONMENTAL_DAMAGE
+    &Spell::EffectPowerDrain,                               //  8 SPELL_EFFECT_POWER_DRAIN
+    &Spell::EffectHealthLeech,                              //  9 SPELL_EFFECT_HEALTH_LEECH
+    &Spell::EffectHeal,                                     // 10 SPELL_EFFECT_HEAL
+    &Spell::EffectBind,                                     // 11 SPELL_EFFECT_BIND
+    &Spell::EffectNULL,                                     // 12 SPELL_EFFECT_PORTAL
+    &Spell::EffectUnused,                                   // 13 SPELL_EFFECT_RITUAL_BASE              unused
+    &Spell::EffectUnused,                                   // 14 SPELL_EFFECT_RITUAL_SPECIALIZE        unused
+    &Spell::EffectUnused,                                   // 15 SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL   unused
+    &Spell::EffectQuestComplete,                            // 16 SPELL_EFFECT_QUEST_COMPLETE
+    &Spell::EffectWeaponDmg,                                // 17 SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL
+    &Spell::EffectResurrect,                                // 18 SPELL_EFFECT_RESURRECT
+    &Spell::EffectAddExtraAttacks,                          // 19 SPELL_EFFECT_ADD_EXTRA_ATTACKS
+    &Spell::EffectUnused,                                   // 20 SPELL_EFFECT_DODGE                    one spell: Dodge
+    &Spell::EffectUnused,                                   // 21 SPELL_EFFECT_EVADE                    one spell: Evade (DND)
+    &Spell::EffectParry,                                    // 22 SPELL_EFFECT_PARRY
+    &Spell::EffectBlock,                                    // 23 SPELL_EFFECT_BLOCK                    one spell: Block
+    &Spell::EffectCreateItem,                               // 24 SPELL_EFFECT_CREATE_ITEM
+    &Spell::EffectUnused,                                   // 25 SPELL_EFFECT_WEAPON
+    &Spell::EffectUnused,                                   // 26 SPELL_EFFECT_DEFENSE                  one spell: Defense
+    &Spell::EffectPersistentAA,                             // 27 SPELL_EFFECT_PERSISTENT_AREA_AURA
+    &Spell::EffectSummonType,                               // 28 SPELL_EFFECT_SUMMON
+    &Spell::EffectLeap,                                     // 29 SPELL_EFFECT_LEAP
+    &Spell::EffectEnergize,                                 // 30 SPELL_EFFECT_ENERGIZE
+    &Spell::EffectWeaponDmg,                                // 31 SPELL_EFFECT_WEAPON_PERCENT_DAMAGE
+    &Spell::EffectTriggerMissileSpell,                      // 32 SPELL_EFFECT_TRIGGER_MISSILE
+    &Spell::EffectOpenLock,                                 // 33 SPELL_EFFECT_OPEN_LOCK
+    &Spell::EffectSummonChangeItem,                         // 34 SPELL_EFFECT_SUMMON_CHANGE_ITEM
+    &Spell::EffectApplyAreaAura,                            // 35 SPELL_EFFECT_APPLY_AREA_AURA_PARTY
+    &Spell::EffectLearnSpell,                               // 36 SPELL_EFFECT_LEARN_SPELL
+    &Spell::EffectUnused,                                   // 37 SPELL_EFFECT_SPELL_DEFENSE            one spell: SPELLDEFENSE (DND)
+    &Spell::EffectDispel,                                   // 38 SPELL_EFFECT_DISPEL
+    &Spell::EffectUnused,                                   // 39 SPELL_EFFECT_LANGUAGE
+    &Spell::EffectDualWield,                                // 40 SPELL_EFFECT_DUAL_WIELD
+    &Spell::EffectJump,                                     // 41 SPELL_EFFECT_JUMP
+    &Spell::EffectJumpDest,                                 // 42 SPELL_EFFECT_JUMP_DEST
+    &Spell::EffectTeleUnitsFaceCaster,                      // 43 SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER
+    &Spell::EffectLearnSkill,                               // 44 SPELL_EFFECT_SKILL_STEP
+    &Spell::EffectAddHonor,                                 // 45 SPELL_EFFECT_ADD_HONOR                honor/pvp related
+    &Spell::EffectUnused,                                   // 46 SPELL_EFFECT_SPAWN clientside, unit appears as if it was just spawned
+    &Spell::EffectTradeSkill,                               // 47 SPELL_EFFECT_TRADE_SKILL
+    &Spell::EffectUnused,                                   // 48 SPELL_EFFECT_STEALTH                  one spell: Base Stealth
+    &Spell::EffectUnused,                                   // 49 SPELL_EFFECT_DETECT                   one spell: Detect
+    &Spell::EffectTransmitted,                              // 50 SPELL_EFFECT_TRANS_DOOR
+    &Spell::EffectUnused,                                   // 51 SPELL_EFFECT_FORCE_CRITICAL_HIT       unused
+    &Spell::EffectUnused,                                   // 52 SPELL_EFFECT_GUARANTEE_HIT            one spell: zzOLDCritical Shot
+    &Spell::EffectEnchantItemPerm,                          // 53 SPELL_EFFECT_ENCHANT_ITEM
+    &Spell::EffectEnchantItemTmp,                           // 54 SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
+    &Spell::EffectTameCreature,                             // 55 SPELL_EFFECT_TAMECREATURE
+    &Spell::EffectSummonPet,                                // 56 SPELL_EFFECT_SUMMON_PET
+    &Spell::EffectLearnPetSpell,                            // 57 SPELL_EFFECT_LEARN_PET_SPELL
+    &Spell::EffectWeaponDmg,                                // 58 SPELL_EFFECT_WEAPON_DAMAGE
+    &Spell::EffectCreateRandomItem,                         // 59 SPELL_EFFECT_CREATE_RANDOM_ITEM       create item base at spell specific loot
+    &Spell::EffectProficiency,                              // 60 SPELL_EFFECT_PROFICIENCY
+    &Spell::EffectSendEvent,                                // 61 SPELL_EFFECT_SEND_EVENT
+    &Spell::EffectPowerBurn,                                // 62 SPELL_EFFECT_POWER_BURN
+    &Spell::EffectThreat,                                   // 63 SPELL_EFFECT_THREAT
+    &Spell::EffectTriggerSpell,                             // 64 SPELL_EFFECT_TRIGGER_SPELL
+    &Spell::EffectApplyAreaAura,                            // 65 SPELL_EFFECT_APPLY_AREA_AURA_RAID
+    &Spell::EffectRechargeManaGem,                          // 66 SPELL_EFFECT_CREATE_MANA_GEM          (possibly recharge it, misc - is item ID)
+    &Spell::EffectHealMaxHealth,                            // 67 SPELL_EFFECT_HEAL_MAX_HEALTH
+    &Spell::EffectInterruptCast,                            // 68 SPELL_EFFECT_INTERRUPT_CAST
+    &Spell::EffectDistract,                                 // 69 SPELL_EFFECT_DISTRACT
+    &Spell::EffectPull,                                     // 70 SPELL_EFFECT_PULL                     one spell: Distract Move
+    &Spell::EffectPickPocket,                               // 71 SPELL_EFFECT_PICKPOCKET
+    &Spell::EffectAddFarsight,                              // 72 SPELL_EFFECT_ADD_FARSIGHT
+    &Spell::EffectUnused,                                   // 73 SPELL_EFFECT_UNTRAIN_TALENTS
+    &Spell::EffectApplyGlyph,                               // 74 SPELL_EFFECT_APPLY_GLYPH
+    &Spell::EffectHealMechanical,                           // 75 SPELL_EFFECT_HEAL_MECHANICAL          one spell: Mechanical Patch Kit
+    &Spell::EffectSummonObjectWild,                         // 76 SPELL_EFFECT_SUMMON_OBJECT_WILD
+    &Spell::EffectScriptEffect,                             // 77 SPELL_EFFECT_SCRIPT_EFFECT
+    &Spell::EffectUnused,                                   // 78 SPELL_EFFECT_ATTACK
+    &Spell::EffectSanctuary,                                // 79 SPELL_EFFECT_SANCTUARY
+    &Spell::EffectAddComboPoints,                           // 80 SPELL_EFFECT_ADD_COMBO_POINTS
+    &Spell::EffectUnused,                                   // 81 SPELL_EFFECT_CREATE_HOUSE             one spell: Create House (TEST)
+    &Spell::EffectNULL,                                     // 82 SPELL_EFFECT_BIND_SIGHT
+    &Spell::EffectDuel,                                     // 83 SPELL_EFFECT_DUEL
+    &Spell::EffectStuck,                                    // 84 SPELL_EFFECT_STUCK
+    &Spell::EffectSummonPlayer,                             // 85 SPELL_EFFECT_SUMMON_PLAYER
+    &Spell::EffectActivateObject,                           // 86 SPELL_EFFECT_ACTIVATE_OBJECT
+    &Spell::EffectWMODamage,                                // 87 SPELL_EFFECT_WMO_DAMAGE
+    &Spell::EffectWMORepair,                                // 88 SPELL_EFFECT_WMO_REPAIR
+    &Spell::EffectUnused,                                   // 89 SPELL_EFFECT_WMO_CHANGE // 0 intact // 1 damaged // 2 destroyed // 3 rebuilding
+    &Spell::EffectKillCreditPersonal,                       // 90 SPELL_EFFECT_KILL_CREDIT              Kill credit but only for single person
+    &Spell::EffectUnused,                                   // 91 SPELL_EFFECT_THREAT_ALL               one spell: zzOLDBrainwash
+    &Spell::EffectEnchantHeldItem,                          // 92 SPELL_EFFECT_ENCHANT_HELD_ITEM
+    &Spell::EffectForceDeselect,                            // 93 SPELL_EFFECT_FORCE_DESELECT
+    &Spell::EffectSelfResurrect,                            // 94 SPELL_EFFECT_SELF_RESURRECT
+    &Spell::EffectSkinning,                                 // 95 SPELL_EFFECT_SKINNING
+    &Spell::EffectCharge,                                   // 96 SPELL_EFFECT_CHARGE
+    &Spell::EffectCastButtons,                              // 97 SPELL_EFFECT_CAST_BUTTON (totem bar since 3.2.2a)
+    &Spell::EffectKnockBack,                                // 98 SPELL_EFFECT_KNOCK_BACK
+    &Spell::EffectDisEnchant,                               // 99 SPELL_EFFECT_DISENCHANT
+    &Spell::EffectInebriate,                                //100 SPELL_EFFECT_INEBRIATE
+    &Spell::EffectFeedPet,                                  //101 SPELL_EFFECT_FEED_PET
+    &Spell::EffectDismissPet,                               //102 SPELL_EFFECT_DISMISS_PET
+    &Spell::EffectReputation,                               //103 SPELL_EFFECT_REPUTATION
+    &Spell::EffectSummonObject,                             //104 SPELL_EFFECT_SUMMON_OBJECT_SLOT1
+    &Spell::EffectSummonObject,                             //105 SPELL_EFFECT_SUMMON_OBJECT_SLOT2
+    &Spell::EffectSummonObject,                             //106 SPELL_EFFECT_SUMMON_OBJECT_SLOT3
+    &Spell::EffectSummonObject,                             //107 SPELL_EFFECT_SUMMON_OBJECT_SLOT4
+    &Spell::EffectDispelMechanic,                           //108 SPELL_EFFECT_DISPEL_MECHANIC
+    &Spell::EffectSummonDeadPet,                            //109 SPELL_EFFECT_SUMMON_DEAD_PET
+    &Spell::EffectDestroyAllTotems,                         //110 SPELL_EFFECT_DESTROY_ALL_TOTEMS
+    &Spell::EffectDurabilityDamage,                         //111 SPELL_EFFECT_DURABILITY_DAMAGE
+    &Spell::EffectUnused,                                   //112 SPELL_EFFECT_112
+    &Spell::EffectResurrectNew,                             //113 SPELL_EFFECT_RESURRECT_NEW
+    &Spell::EffectTaunt,                                    //114 SPELL_EFFECT_ATTACK_ME
+    &Spell::EffectDurabilityDamagePCT,                      //115 SPELL_EFFECT_DURABILITY_DAMAGE_PCT
+    &Spell::EffectSkinPlayerCorpse,                         //116 SPELL_EFFECT_SKIN_PLAYER_CORPSE       one spell: Remove Insignia, bg usage, required special corpse flags...
+    &Spell::EffectSpiritHeal,                               //117 SPELL_EFFECT_SPIRIT_HEAL              one spell: Spirit Heal
+    &Spell::EffectSkill,                                    //118 SPELL_EFFECT_SKILL                    professions and more
+    &Spell::EffectApplyAreaAura,                            //119 SPELL_EFFECT_APPLY_AREA_AURA_PET
+    &Spell::EffectUnused,                                   //120 SPELL_EFFECT_TELEPORT_GRAVEYARD       one spell: Graveyard Teleport Test
+    &Spell::EffectWeaponDmg,                                //121 SPELL_EFFECT_NORMALIZED_WEAPON_DMG
+    &Spell::EffectUnused,                                   //122 SPELL_EFFECT_122                      unused
+    &Spell::EffectSendTaxi,                                 //123 SPELL_EFFECT_SEND_TAXI                taxi/flight related (misc value is taxi path id)
+    &Spell::EffectPullTowards,                              //124 SPELL_EFFECT_PULL_TOWARDS
+    &Spell::EffectModifyThreatPercent,                      //125 SPELL_EFFECT_MODIFY_THREAT_PERCENT
+    &Spell::EffectStealBeneficialBuff,                      //126 SPELL_EFFECT_STEAL_BENEFICIAL_BUFF    spell steal effect?
+    &Spell::EffectProspecting,                              //127 SPELL_EFFECT_PROSPECTING              Prospecting spell
+    &Spell::EffectApplyAreaAura,                            //128 SPELL_EFFECT_APPLY_AREA_AURA_FRIEND
+    &Spell::EffectApplyAreaAura,                            //129 SPELL_EFFECT_APPLY_AREA_AURA_ENEMY
+    &Spell::EffectRedirectThreat,                           //130 SPELL_EFFECT_REDIRECT_THREAT
+    &Spell::EffectPlayerNotification,                       //131 SPELL_EFFECT_PLAYER_NOTIFICATION
+    &Spell::EffectPlayMusic,                                //132 SPELL_EFFECT_PLAY_MUSIC               sound id in misc value (SoundEntries.dbc)
+    &Spell::EffectUnlearnSpecialization,                    //133 SPELL_EFFECT_UNLEARN_SPECIALIZATION   unlearn profession specialization
+    &Spell::EffectKillCredit,                               //134 SPELL_EFFECT_KILL_CREDIT              misc value is creature entry
+    &Spell::EffectNULL,                                     //135 SPELL_EFFECT_CALL_PET
+    &Spell::EffectHealPct,                                  //136 SPELL_EFFECT_HEAL_PCT
+    &Spell::EffectEnergizePct,                              //137 SPELL_EFFECT_ENERGIZE_PCT
+    &Spell::EffectLeapBack,                                 //138 SPELL_EFFECT_LEAP_BACK                Leap back
+    &Spell::EffectQuestClear,                               //139 SPELL_EFFECT_CLEAR_QUEST              Reset quest status (miscValue - quest ID)
+    &Spell::EffectForceCast,                                //140 SPELL_EFFECT_FORCE_CAST
+    &Spell::EffectForceCastWithValue,                       //141 SPELL_EFFECT_FORCE_CAST_WITH_VALUE
+    &Spell::EffectTriggerSpellWithValue,                    //142 SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE
+    &Spell::EffectApplyAreaAura,                            //143 SPELL_EFFECT_APPLY_AREA_AURA_OWNER
+    &Spell::EffectKnockBack,                                //144 SPELL_EFFECT_KNOCK_BACK_DEST
+    &Spell::EffectPullTowards,                              //145 SPELL_EFFECT_PULL_TOWARDS_DEST                      Black Hole Effect
+    &Spell::EffectActivateRune,                             //146 SPELL_EFFECT_ACTIVATE_RUNE
+    &Spell::EffectQuestFail,                                //147 SPELL_EFFECT_QUEST_FAIL               quest fail
+    &Spell::EffectUnused,                                   //148 SPELL_EFFECT_148   1 spell - 43509
+    &Spell::EffectChargeDest,                               //149 SPELL_EFFECT_CHARGE_DEST
+    &Spell::EffectQuestStart,                               //150 SPELL_EFFECT_QUEST_START
+    &Spell::EffectTriggerRitualOfSummoning,                 //151 SPELL_EFFECT_TRIGGER_SPELL_2
+    &Spell::EffectNULL,                                     //152 SPELL_EFFECT_152                      summon Refer-a-Friend
+    &Spell::EffectCreateTamedPet,                           //153 SPELL_EFFECT_CREATE_TAMED_PET         misc value is creature entry
+    &Spell::EffectDiscoverTaxi,                             //154 SPELL_EFFECT_DISCOVER_TAXI
+    &Spell::EffectTitanGrip,                                //155 SPELL_EFFECT_TITAN_GRIP Allows you to equip two-handed axes, maces and swords in one hand, but you attack $49152s1% slower than normal.
+    &Spell::EffectEnchantItemPrismatic,                     //156 SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC
+    &Spell::EffectCreateItem2,                              //157 SPELL_EFFECT_CREATE_ITEM_2            create item or create item template and replace by some randon spell loot item
+    &Spell::EffectMilling,                                  //158 SPELL_EFFECT_MILLING                  milling
+    &Spell::EffectRenamePet,                                //159 SPELL_EFFECT_ALLOW_RENAME_PET         allow rename pet once again
+    &Spell::EffectNULL,                                     //160 SPELL_EFFECT_160                      1 spell - 45534
+    &Spell::EffectSpecCount,                                //161 SPELL_EFFECT_TALENT_SPEC_COUNT        second talent spec (learn/revert)
+    &Spell::EffectActivateSpec,                             //162 SPELL_EFFECT_TALENT_SPEC_SELECT       activate primary/secondary spec
+    &Spell::EffectNULL,                                     //163 unused
+    &Spell::EffectRemoveAura,                               //164 SPELL_EFFECT_REMOVE_AURA
+};
+
+void Spell::EffectNULL(SpellEffIndex /*effIndex*/)
+{
+    sLog.outDebug("WORLD: Spell Effect DUMMY");
+}
+
+void Spell::EffectUnused(SpellEffIndex /*effIndex*/)
+{
+    // NOT USED BY ANY SPELL OR USELESS OR IMPLEMENTED IN DIFFERENT WAY IN TRINITY
+}
+
+void Spell::EffectResurrectNew(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->isAlive())
+        return;
+
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (!unitTarget->IsInWorld())
+        return;
+
+    Player* pTarget = unitTarget->ToPlayer();
+
+    if (pTarget->isRessurectRequested())       // already have one active request
+        return;
+
+    uint32 health = damage;
+    uint32 mana = m_spellInfo->EffectMiscValue[effIndex];
+    ExecuteLogEffectResurrect(effIndex, pTarget);
+    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
+    SendResurrectRequest(pTarget);
+}
+
+void Spell::EffectInstaKill(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive())
+        return;
+
+    // Demonic Sacrifice
+    if (m_spellInfo->Id == 18788 && unitTarget->GetTypeId() == TYPEID_UNIT)
+    {
+        uint32 entry = unitTarget->GetEntry();
+        uint32 spellID;
+        switch (entry)
+        {
+            case   416: spellID = 18789; break;               //imp
+            case   417: spellID = 18792; break;               //fellhunter
+            case  1860: spellID = 18790; break;               //void
+            case  1863: spellID = 18791; break;               //succubus
+            case 17252: spellID = 35701; break;               //fellguard
+            default:
+                sLog.outError("EffectInstaKill: Unhandled creature entry (%u) case.", entry);
+                return;
+        }
+
+        m_caster->CastSpell(m_caster, spellID, true);
+    }
+
+    if (m_caster == unitTarget)                              // prevent interrupt message
+        finish();
+
+    WorldPacket data(SMSG_SPELLINSTAKILLLOG, 8+8+4);
+    data << uint64(m_caster->GetGUID());
+    data << uint64(unitTarget->GetGUID());
+    data << uint32(m_spellInfo->Id);
+    m_caster->SendMessageToSet(&data, true);
+
+    m_caster->DealDamage(unitTarget, unitTarget->GetHealth(), NULL, NODAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+}
+
+void Spell::EffectEnvirinmentalDMG(SpellEffIndex effIndex)
+{
+    uint32 absorb = 0;
+    uint32 resist = 0;
+
+    // Note: this hack with damage replace required until GO casting not implemented
+    // environment damage spells already have around enemies targeting but this not help in case not existed GO casting support
+    // currently each enemy selected explicitly and self cast damage, we prevent apply self casted spell bonuses/etc
+    damage = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex, m_caster);
+
+    m_caster->CalcAbsorbResist(m_caster, GetSpellSchoolMask(m_spellInfo), SPELL_DIRECT_DAMAGE, damage, &absorb, &resist, m_spellInfo);
+
+    m_caster->SendSpellNonMeleeDamageLog(m_caster, m_spellInfo->Id, damage, GetSpellSchoolMask(m_spellInfo), absorb, resist, false, 0, false);
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->ToPlayer()->EnvironmentalDamage(DAMAGE_FIRE, damage);
+}
+
+void Spell::EffectSchoolDMG(SpellEffIndex /*effIndex*/)
+{
+}
+
+void Spell::SpellDamageSchoolDmg(SpellEffIndex effIndex)
+{
+    bool apply_direct_bonus = true;
+
+    if (unitTarget && unitTarget->isAlive())
+    {
+        switch (m_spellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_GENERIC:
+            {
+                // Meteor like spells (divided damage to targets)
+                if (m_customAttr & SPELL_ATTR_CU_SHARE_DAMAGE)
+                {
+                    uint32 count = 0;
+                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1<<effIndex))
+                            ++count;
+
+                    damage /= count;                    // divide to all targets
+                }
+
+                switch(m_spellInfo->Id)                     // better way to check unknown
+                {
+                    // Positive/Negative Charge
+                    case 28062:
+                    case 28085:
+                    case 39090:
+                    case 39093:
+                        if (!m_triggeredByAuraSpell)
+                            break;
+                        if (unitTarget == m_caster)
+                        {
+                            uint8 count = 0;
+                            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                                if (ihit->targetGUID != m_caster->GetGUID())
+                                    if (Player *target = ObjectAccessor::GetPlayer(*m_caster, ihit->targetGUID))
+                                        if (target->HasAura(m_triggeredByAuraSpell->Id))
+                                            ++count;
+                            if (count)
+                            {
+                                uint32 spellId = 0;
+                                switch (m_spellInfo->Id)
+                                {
+                                    case 28062: spellId = 29659; break;
+                                    case 28085: spellId = 29660; break;
+                                    case 39090: spellId = 39089; break;
+                                    case 39093: spellId = 39092; break;
+                                }
+                                m_caster->SetAuraStack(spellId, m_caster, count);
+                            }
+                        }
+
+                        if (unitTarget->HasAura(m_triggeredByAuraSpell->Id))
+                            damage = 0;
+                        break;
+                    // Consumption
+                    case 28865:
+                        damage = (((InstanceMap*)m_caster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY ? 2750 : 4250);
+                        break;
+                    // percent from health with min
+                    case 25599:                             // Thundercrash
+                    {
+                        damage = unitTarget->GetHealth() / 2;
+                        if (damage < 200)
+                            damage = 200;
+                        break;
+                    }
+                    // arcane charge. must only affect demons (also undead?)
+                    case 45072:
+                    {
+                        if (unitTarget->GetCreatureType() != CREATURE_TYPE_DEMON
+                            && unitTarget->GetCreatureType() != CREATURE_TYPE_UNDEAD)
+                            return;
+                        break;
+                    }
+                    case 33671: // gruul's shatter
+                    case 50811: // krystallus shatter ( Normal )
+                    case 61547: // krystallus shatter ( Heroic )
+                    {
+                        // don't damage self and only players
+                        if (unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                            return;
+
+                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
+                        if (!radius) return;
+                        float distance = m_caster->GetDistance2d(unitTarget);
+                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * ((radius - distance)/radius));
+                        break;
+                    }
+                    // TODO: add spell specific target requirement hook for spells
+                    // Shadowbolts only affects targets with Shadow Mark (Gothik)
+                    case 27831:
+                    case 55638:
+                        if (!unitTarget->HasAura(27825))
+                            return;
+                        break;
+                    // Cataclysmic Bolt
+                    case 38441:
+                    {
+                        damage = unitTarget->CountPctFromMaxHealth(50);
+                        break;
+                    }
+					case 69075:
+                    case 70834:
+                    case 70835:
+                    case 70836:
+                    {
+                        float distance = m_caster->GetDistance(unitTarget);
+                        float radius = 12.0f;
+                        if(distance > radius)
+                            return;
+
+                        if(distance < 1)
+                           distance = 1;
+
+                        int32 bp0 = m_spellInfo->EffectBasePoints[0];
+                        int32 damage = int32(bp0 / (distance / radius));
+                        break;
+                    }
+                    // Tympanic Tantrum
+                    case 62775:
+                    {
+                        damage = unitTarget->CountPctFromMaxHealth(10);
+                        break;
+                    }
+                    // Gargoyle Strike
+                    case 51963:
+                    {
+                        // about +4 base spell dmg per level
+                        damage = (m_caster->getLevel() - 60) * 4 + 60;
+                        break;
+                    }
+
+                    // Loken Pulsing Shockwave
+                    case 59837:
+                    case 52942:
+                    {
+                        // don't damage self and only players
+                        if(unitTarget->GetGUID() == m_caster->GetGUID() || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                            return;
+
+                        float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[0]));
+                        if (!radius)
+                            return;
+                        float distance = m_caster->GetDistance2d(unitTarget);
+                        damage = (distance > radius) ? 0 : int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) * distance);
+                        break;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_WARRIOR:
+            {
+                // Bloodthirst
+                if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
+                    damage = uint32(damage * (m_caster->GetTotalAttackPowerValue(BASE_ATTACK)) / 100);
+                // Shield Slam
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x200 && m_spellInfo->Category == 1209)
+                    damage += m_caster->ApplyEffectModifiers(m_spellInfo,effIndex,int32(m_caster->GetShieldBlockValue()));
+                // Victory Rush
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x100)
+                {
+                    damage = uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
+                    m_caster->ModifyAuraState(AURA_STATE_WARRIOR_VICTORY_RUSH, false);
+                }
+                // Shockwave
+                else if (m_spellInfo->Id == 46968)
+                {
+                    int32 pct = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, 2);
+                    if (pct > 0)
+                        damage+= int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * pct / 100);
+                    break;
+                }
+                break;
+            }
+            case SPELLFAMILY_WARLOCK:
+            {
+                // Incinerate Rank 1 & 2
+                if ((m_spellInfo->SpellFamilyFlags[1] & 0x000040) && m_spellInfo->SpellIconID == 2128)
+                {
+                    // Incinerate does more dmg (dmg*0.25) if the target have Immolate debuff.
+                    // Check aura state for speed but aura state set not only for Immolate spell
+                    if (unitTarget->HasAuraState(AURA_STATE_CONFLAGRATE))
+                    {
+                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0, 0))
+                            damage += damage/4;
+                    }
+                }
+                // Conflagrate - consumes Immolate or Shadowflame
+                else if (m_spellInfo->TargetAuraState == AURA_STATE_CONFLAGRATE)
+                {
+                    AuraEffect const* aura = NULL;                // found req. aura for damage calculation
+
+                    Unit::AuraEffectList const &mPeriodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_DAMAGE);
+                    for (Unit::AuraEffectList::const_iterator i = mPeriodic.begin(); i != mPeriodic.end(); ++i)
+                    {
+                        // for caster applied auras only
+                        if ((*i)->GetSpellProto()->SpellFamilyName != SPELLFAMILY_WARLOCK ||
+                            (*i)->GetCasterGUID() != m_caster->GetGUID())
+                            continue;
+
+                        // Immolate
+                        if ((*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x4)
+                        {
+                            aura = *i;                      // it selected always if exist
+                            break;
+                        }
+
+                        // Shadowflame
+                        if ((*i)->GetSpellProto()->SpellFamilyFlags[2] & 0x00000002)
+                            aura = *i;                      // remember but wait possible Immolate as primary priority
+                    }
+
+                    // found Immolate or Shadowflame
+                    if (aura)
+                    {
+                        uint32 pdamage = aura->GetAmount() > 0 ? aura->GetAmount() : 0;
+                        pdamage = m_caster->SpellDamageBonus(unitTarget, aura->GetSpellProto(), pdamage, DOT, aura->GetBase()->GetStackAmount());
+                        uint32 pct_dir = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 1));
+                        uint8 baseTotalTicks = uint8(m_caster->CalcSpellDuration(aura->GetSpellProto()) / aura->GetSpellProto()->EffectAmplitude[0]);
+                        damage += pdamage * baseTotalTicks * pct_dir / 100;
+
+                        uint32 pct_dot = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, (effIndex + 2)) / 3;
+                        m_spellValue->EffectBasePoints[1] = SpellMgr::CalculateSpellEffectBaseAmount(pdamage * baseTotalTicks * pct_dot / 100, m_spellInfo, 1);
+
+                        apply_direct_bonus = false;
+                        // Glyph of Conflagrate
+                        if (!m_caster->HasAura(56235))
+                            unitTarget->RemoveAurasDueToSpell(aura->GetId(), m_caster->GetGUID());
+
+                        break;
+                    }
+                }
+                // Shadow Bite
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x400000)
+                {
+                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->isPet())
+                    {
+                        // Get DoTs on target by owner (5% increase by dot)
+                        damage += 5 * unitTarget->GetDoTsByCaster(m_caster->GetOwnerGUID()) / 100;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_PRIEST:
+            {
+                // Shadow Word: Death - deals damage equal to damage done to caster
+                if ((m_spellInfo->SpellFamilyFlags[1] & 0x2))
+                {
+                    int32 back_damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
+                    // Pain and Suffering reduces damage
+                    if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST, 2874, 0))
+                        back_damage -= aurEff->GetAmount() * back_damage / 100;
+
+                    if (back_damage < int32(unitTarget->GetHealth()))
+                        m_caster->CastCustomSpell(m_caster, 32409, &back_damage, 0, 0, true);
+                }
+                // Mind Blast - applies Mind Trauma if:
+                else if (m_spellInfo->SpellFamilyFlags[2] & 0x00002000)
+                {
+                    // We are in Shadow Form
+                    if (m_caster->m_form == FORM_SHADOW)
+                        // We have Improved Mind Blast
+                        if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_PRIEST,95,0))
+                            // Chance has been successfully rolled
+                            if (roll_chance_i(aurEff->GetAmount()))
+                                m_caster->CastSpell(unitTarget, 48301, true);
+                }
+                // Smite
+                else if (m_spellInfo->SpellFamilyFlags[0] & 0x80)
+                {
+                    // Glyph of Smite
+                    if (AuraEffect * aurEff = m_caster->GetAuraEffect(55692, 0))
+                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x100000, 0, 0, m_caster->GetGUID()))
+                            damage += damage * aurEff->GetAmount() / 100;
+                }
+                // Improved Mind Blast (Mind Blast in shadow form bonus)
+                else if (m_caster->m_form == FORM_SHADOW && (m_spellInfo->SpellFamilyFlags[0] & 0x00002000))
+                {
+                    Unit::AuraEffectList const& ImprMindBlast = m_caster->GetAuraEffectsByType(SPELL_AURA_ADD_FLAT_MODIFIER);
+                    for (Unit::AuraEffectList::const_iterator i = ImprMindBlast.begin(); i != ImprMindBlast.end(); ++i)
+                    {
+                        if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_PRIEST &&
+                            ((*i)->GetSpellProto()->SpellIconID == 95))
+                        {
+                            int chance = SpellMgr::CalculateSpellEffectAmount((*i)->GetSpellProto(), 1, m_caster);
+                            if (roll_chance_i(chance))
+                                // Mind Trauma
+                                m_caster->CastSpell(unitTarget, 48301, true, 0);
+                            break;
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_DRUID:
+            {
+                // Ferocious Bite
+                if (m_caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->SpellFamilyFlags[0] & 0x000800000) && m_spellInfo->SpellVisual[0] == 6587)
+                {
+                    // converts each extra point of energy into ($f1+$AP/410) additional damage
+                    float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
+                    float multiple = ap / 410 + m_spellInfo->EffectDamageMultiplier[effIndex];
+                    int32 energy = -(m_caster->ModifyPower(POWER_ENERGY, -30));
+                    damage += int32(energy * multiple);
+                    damage += int32(m_caster->ToPlayer()->GetComboPoints() * ap * 7 / 100);
+                }
+                // Wrath
+                else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
+                {
+                    // Improved Insect Swarm
+                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 1771, 0))
+                        if (unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x00200000, 0, 0))
+                            damage = int32(damage*(100.0f+aurEff->GetAmount())/100.0f);
+                }
+                break;
+            }
+            case SPELLFAMILY_ROGUE:
+            {
+                // Envenom
+                if (m_caster->GetTypeId() == TYPEID_PLAYER && (m_spellInfo->SpellFamilyFlags[1] & 0x8))
+                {
+                    // consume from stack dozes not more that have combo-points
+                    if (uint32 combo = m_caster->ToPlayer()->GetComboPoints())
+                    {
+                        // Lookup for Deadly poison (only attacker applied)
+                        if (AuraEffect const * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x10000, 0, 0, m_caster->GetGUID()))
+                        {
+                            // count consumed deadly poison doses at target
+                            bool needConsume = true;
+                            uint32 spellId = aurEff->GetId();
+                            uint32 doses = aurEff->GetBase()->GetStackAmount();
+                            if (doses > combo)
+                                doses = combo;
+                            // Master Poisoner
+                            Unit::AuraEffectList const& auraList = m_caster->ToPlayer()->GetAuraEffectsByType(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK);
+                            for (Unit::AuraEffectList::const_iterator iter = auraList.begin(); iter != auraList.end(); ++iter)
+                            {
+                                if ((*iter)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_ROGUE && (*iter)->GetSpellProto()->SpellIconID == 1960)
+                                {
+                                    uint32 chance = SpellMgr::CalculateSpellEffectAmount((*iter)->GetSpellProto(), 2, m_caster);
+
+                                    if (chance && roll_chance_i(chance))
+                                        needConsume = false;
+
+                                    break;
+                                }
+                            }
+
+                            if (needConsume)
+                                for (uint32 i = 0; i < doses; ++i)
+                                    unitTarget->RemoveAuraFromStack(spellId);
+                            damage *= doses;
+                            damage += int32(((Player*)m_caster)->GetTotalAttackPowerValue(BASE_ATTACK) * 0.09f * doses);
+                        }
+                        // Eviscerate and Envenom Bonus Damage (item set effect)
+                        if (m_caster->HasAura(37169))
+                            damage += ((Player*)m_caster)->GetComboPoints()*40;
+                    }
+                }
+                // Eviscerate
+                else if ((m_spellInfo->SpellFamilyFlags[0] & 0x00020000) && m_caster->GetTypeId() == TYPEID_PLAYER)
+                {
+                    if (uint32 combo = ((Player*)m_caster)->GetComboPoints())
+                    {
+                        float ap = m_caster->GetTotalAttackPowerValue(BASE_ATTACK);
+                        damage += irand(int32(ap * combo * 0.03f), int32(ap * combo * 0.07f));
+
+                        // Eviscerate and Envenom Bonus Damage (item set effect)
+                        if (m_caster->HasAura(37169))
+                            damage += combo*40;
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_HUNTER:
+            {
+                //Gore
+                if (m_spellInfo->SpellIconID == 1578)
+                {
+                    if (m_caster->HasAura(57627))           // Charge 6 sec post-affect
+                        damage *= 2;
+                }
+                // Steady Shot
+                else if (m_spellInfo->SpellFamilyFlags[1] & 0x1)
+                {
+                    bool found = false;
+                    // check dazed affect
+                    Unit::AuraEffectList const& decSpeedList = unitTarget->GetAuraEffectsByType(SPELL_AURA_MOD_DECREASE_SPEED);
+                    for (Unit::AuraEffectList::const_iterator iter = decSpeedList.begin(); iter != decSpeedList.end(); ++iter)
+                    {
+                        if ((*iter)->GetSpellProto()->SpellIconID == 15 && (*iter)->GetSpellProto()->Dispel == 0)
+                        {
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    // TODO: should this be put on taken but not done?
+                    if (found)
+                        damage += SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
+
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        // Add Ammo and Weapon damage plus RAP * 0.1
+                        Item *item = m_caster->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK);
+                        if (item)
+                        {
+                            float dmg_min = item->GetProto()->Damage->DamageMin;
+                            float dmg_max = item->GetProto()->Damage->DamageMax;
+                            if (dmg_max == 0.0f && dmg_min > dmg_max)
+                                damage += int32(dmg_min);
+                            else
+                                damage += irand(int32(dmg_min), int32(dmg_max));
+                            damage += int32(m_caster->ToPlayer()->GetAmmoDPS()*item->GetProto()->Delay*0.001f);
+                        }
+                    }
+                }
+                break;
+            }
+            case SPELLFAMILY_PALADIN:
+            {
+                // Hammer of the Righteous
+                if (m_spellInfo->SpellFamilyFlags[1]&0x00040000)
+                {
+                    // Add main hand dps * effect[2] amount
+                    float average = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2;
+                    int32 count = m_caster->CalculateSpellDamage(unitTarget, m_spellInfo, 2);
+                    damage += count * int32(average * IN_MILLISECONDS) / m_caster->GetAttackTime(BASE_ATTACK);
+                }
+                // Shield of Righteousness
+                else if (m_spellInfo->SpellFamilyFlags[1]&0x00100000)
+                {
+                    damage += int32(m_caster->GetShieldBlockValue() * 1.3f);
+                }
+                break;
+            }
+            case SPELLFAMILY_DEATHKNIGHT:
+            {
+                // Blood Boil - bonus for diseased targets
+                if (m_spellInfo->SpellFamilyFlags[0] & 0x00040000 && unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0, 0, 0x00000002, m_caster->GetGUID()))
+                {
+                    damage += m_damage / 2;
+                    damage += int32(m_caster->GetTotalAttackPowerValue(RANGED_ATTACK)* 0.035f);
+                }
+                break;
+            }
+        }
+
+        if (m_originalCaster && damage > 0 && apply_direct_bonus)
+            damage = m_originalCaster->SpellDamageBonus(unitTarget, m_spellInfo, (uint32)damage, SPELL_DIRECT_DAMAGE);
+
+        m_damage += damage;
+    }
+}
+
+void Spell::EffectDummy(SpellEffIndex effIndex)
+{
+    if (!unitTarget && !gameObjTarget && !itemTarget)
+        return;
+
+    uint32 spell_id = 0;
+    int32 bp = 0;
+    bool triggered = true;
+    SpellCastTargets targets;
+
+    // selection by spell family
+    switch (m_spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch (m_spellInfo->Id)
+            {
+                case 8593:                                  // Symbol of life (restore creature to life)
+                case 31225:                                 // Shimmering Vessel (restore creature to life)
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+                    unitTarget->ToCreature()->setDeathState(JUST_ALIVED);
+                    return;
+                }
+                case 12162:                                 // Deep wounds
+                case 12850:                                 // (now good common check for this spells)
+                case 12868:
+                {
+                    if (!unitTarget)
+                        return;
+
+                    float damage;
+                    // DW should benefit of attack power, damage percent mods etc.
+                    // TODO: check if using offhand damage is correct and if it should be divided by 2
+                    if (m_caster->haveOffhandWeapon() && m_caster->getAttackTimer(BASE_ATTACK) > m_caster->getAttackTimer(OFF_ATTACK))
+                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE))/2;
+                    else
+                        damage = (m_caster->GetFloatValue(UNIT_FIELD_MINDAMAGE) + m_caster->GetFloatValue(UNIT_FIELD_MAXDAMAGE))/2;
+
+                    switch (m_spellInfo->Id)
+                    {
+                        case 12162: damage *= 0.16f; break; // Rank 1
+                        case 12850: damage *= 0.32f; break; // Rank 2
+                        case 12868: damage *= 0.48f; break; // Rank 3
+                        default:
+                            sLog.outError("Spell::EffectDummy: Spell %u not handled in DW",m_spellInfo->Id);
+                            return;
+                    };
+
+                    // get remaining damage of old Deep Wound aura
+                    AuraEffect* deepWound = unitTarget->GetAuraEffect(12721, 0);
+                    if (deepWound)
+                    {
+                        int32 remainingTicks = deepWound->GetBase()->GetDuration() / deepWound->GetAmplitude();
+                        damage += remainingTicks * deepWound->GetAmount();
+                    }
+
+                    // 1 tick/sec * 6 sec = 6 ticks
+                    int32 deepWoundsDotBasePoints0 = int32(damage / 6);
+                    m_caster->CastCustomSpell(unitTarget, 12721, &deepWoundsDotBasePoints0, NULL, NULL, true, NULL);
+                    return;
+                }
+                case 13567:                                 // Dummy Trigger
+                {
+                    // can be used for different aura triggering, so select by aura
+                    if (!m_triggeredByAuraSpell || !unitTarget)
+                        return;
+
+                    switch (m_triggeredByAuraSpell->Id)
+                    {
+                        case 26467:                         // Persistent Shield
+                            m_caster->CastCustomSpell(unitTarget, 26470, &damage, NULL, NULL, true);
+                            break;
+                        default:
+                            sLog.outError("EffectDummy: Non-handled case for spell 13567 for triggered aura %u",m_triggeredByAuraSpell->Id);
+                            break;
+                    }
+                    return;
+                }
+                case 17251:                                 // Spirit Healer Res
+                {
+                    if (!unitTarget || !m_originalCaster)
+                        return;
+
+                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        WorldPacket data(SMSG_SPIRIT_HEALER_CONFIRM, 8);
+                        data << uint64(unitTarget->GetGUID());
+                        m_originalCaster->ToPlayer()->GetSession()->SendPacket(&data);
+                    }
+                    return;
+                }
+                case 20577:                                 // Cannibalize
+                    if (unitTarget)
+                        m_caster->CastSpell(m_caster, 20578, false, NULL);
+                    return;
+                case 23019:                                 // Crystal Prison Dummy DND
+                {
+                    if (!unitTarget || !unitTarget->isAlive() || unitTarget->GetTypeId() != TYPEID_UNIT || unitTarget->ToCreature()->isPet())
+                        return;
+
+                    Creature* creatureTarget = unitTarget->ToCreature();
+
+                    m_caster->SummonGameObject(179644, creatureTarget->GetPositionX(), creatureTarget->GetPositionY(), creatureTarget->GetPositionZ(), creatureTarget->GetOrientation(), 0, 0, 0, 0, uint32(creatureTarget->GetRespawnTime()-time(NULL)));
+                    sLog.outDebug("SummonGameObject at SpellEfects.cpp EffectDummy for Spell 23019");
+
+                    creatureTarget->ForcedDespawn();
+
+                    return;
+                }
+                case 23448:                                 // Transporter Arrival - Ultrasafe Transporter: Gadgetzan - backfires
+                {
+                    int32 r = irand(0, 119);
+                    if (r < 20)                           // Transporter Malfunction - 1/6 polymorph
+                        m_caster->CastSpell(m_caster, 23444, true);
+                    else if (r < 100)                     // Evil Twin               - 4/6 evil twin
+                        m_caster->CastSpell(m_caster, 23445, true);
+                    else                                    // Transporter Malfunction - 1/6 miss the target
+                        m_caster->CastSpell(m_caster, 36902, true);
+                    return;
+                }
+                case 23453:                                 // Gnomish Transporter - Ultrasafe Transporter: Gadgetzan
+                    if (roll_chance_i(50))                // Gadgetzan Transporter         - success
+                        m_caster->CastSpell(m_caster, 23441, true);
+                    else                                    // Gadgetzan Transporter Failure - failure
+                        m_caster->CastSpell(m_caster, 23446, true);
+                    return;
+                case 25860:                                 // Reindeer Transformation
+                {
+                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
+                        return;
+
+                    float flyspeed = m_caster->GetSpeedRate(MOVE_FLIGHT);
+                    float speed = m_caster->GetSpeedRate(MOVE_RUN);
+
+                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    //5 different spells used depending on mounted speed and if mount can fly or not
+                    if (flyspeed >= 4.1f)
+                        // Flying Reindeer
+                        m_caster->CastSpell(m_caster, 44827, true); //310% flying Reindeer
+                    else if (flyspeed >= 3.8f)
+                        // Flying Reindeer
+                        m_caster->CastSpell(m_caster, 44825, true); //280% flying Reindeer
+                    else if (flyspeed >= 1.6f)
+                        // Flying Reindeer
+                        m_caster->CastSpell(m_caster, 44824, true); //60% flying Reindeer
+                    else if (speed >= 2.0f)
+                        // Reindeer
+                        m_caster->CastSpell(m_caster, 25859, true); //100% ground Reindeer
+                    else
+                        // Reindeer
+                        m_caster->CastSpell(m_caster, 25858, true); //60% ground Reindeer
+
+                    return;
+                }
+                case 26074:                                 // Holiday Cheer
+                    // implemented at client side
+                    return;
+                // Polarity Shift
+                case 28089:
+                    if (unitTarget)
+                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 28059 : 28084, true, NULL, NULL, m_caster->GetGUID());
+                    break;
+                // Polarity Shift
+                case 39096:
+                    if (unitTarget)
+                        unitTarget->CastSpell(unitTarget, roll_chance_i(50) ? 39088 : 39091, true, NULL, NULL, m_caster->GetGUID());
+                    break;
+                case 29200:                                 // Purify Helboar Meat
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    uint32 spell_id = roll_chance_i(50)
+                        ? 29277                             // Summon Purified Helboar Meat
+                        : 29278;                            // Summon Toxic Helboar Meat
+
+                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
+                    return;
+                }
+                case 29858:                                 // Soulshatter
+                    if (unitTarget && unitTarget->CanHaveThreatList()
+                        && unitTarget->getThreatManager().getThreat(m_caster) > 0.0f)
+                        m_caster->CastSpell(unitTarget,32835,true);
+                    return;
+                case 30458:                                 // Nigh Invulnerability
+                    if (!m_CastItem) return;
+                    if (roll_chance_i(86))                   // Nigh-Invulnerability   - success
+                        m_caster->CastSpell(m_caster, 30456, true, m_CastItem);
+                    else                                    // Complete Vulnerability - backfire in 14% casts
+                        m_caster->CastSpell(m_caster, 30457, true, m_CastItem);
+                    return;
+                case 30507:                                 // Poultryizer
+                    if (!m_CastItem) return;
+                    if (roll_chance_i(80))                   // Poultryized! - success
+                        m_caster->CastSpell(unitTarget, 30501, true, m_CastItem);
+                    else                                    // Poultryized! - backfire 20%
+                        m_caster->CastSpell(unitTarget, 30504, true, m_CastItem);
+                    return;
+                case 35745:                                 // Socrethar's Stone
+                {
+                    uint32 spell_id;
+                    switch(m_caster->GetAreaId())
+                    {
+                        case 3900: spell_id = 35743; break; // Socrethar Portal
+                        case 3742: spell_id = 35744; break; // Socrethar Portal
+                        default: return;
+                    }
+
+                    m_caster->CastSpell(m_caster, spell_id, true);
+                    return;
+                }
+                case 37674:                                 // Chaos Blast
+                {
+                    if (!unitTarget)
+                        return;
+
+                    int32 basepoints0 = 100;
+                    m_caster->CastCustomSpell(unitTarget, 37675, &basepoints0, NULL, NULL, true);
+                    return;
+                }
+                // Wrath of the Astromancer
+                case 42784:
+                {
+                    uint32 count = 0;
+                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1<<effIndex))
+                            ++count;
+
+                    damage = 12000; // maybe wrong value
+                    damage /= count;
+
+                    SpellEntry const *spellInfo = sSpellStore.LookupEntry(42784);
+
+                     // now deal the damage
+                    for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1<<effIndex))
+                        {
+                            if (Unit* casttarget = Unit::GetUnit((*unitTarget), ihit->targetGUID))
+                                m_caster->DealDamage(casttarget, damage, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_ARCANE, spellInfo, false);
+                        }
+
+                    return;
+                }
+                // Demon Broiled Surprise
+                case 43723:
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    Player *player = (Player*)m_caster;
+
+                    if (player && player->GetQuestStatus(11379) == QUEST_STATUS_INCOMPLETE)
+                    {
+                        Creature *creature = player->FindNearestCreature(19973, 10, false);
+                        if (!creature)
+                        {
+                            SendCastResult(SPELL_FAILED_NOT_HERE);
+                            return;
+                        }
+
+                        player->CastSpell(player, 43753, false);
+                    }
+                    return;
+                }
+                case 44875:                                 // Complete Raptor Capture
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    unitTarget->ToCreature()->ForcedDespawn();
+
+                    //cast spell Raptor Capture Credit
+                    m_caster->CastSpell(m_caster, 42337, true, NULL);
+                    return;
+                }
+                case 47170:                                 // Impale Leviroth
+                {
+                    if (!unitTarget && unitTarget->GetEntry() != 26452 && unitTarget->HealthAbovePct(95))
+                        return;
+
+                        m_caster->DealDamage(unitTarget, unitTarget->CountPctFromMaxHealth(93));
+                        return;
+                }
+                case 49357:                                 // Brewfest Mount Transformation
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
+                        return;
+                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                    // Ram for Alliance, Kodo for Horde
+                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                    {
+                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Ram
+                            m_caster->CastSpell(m_caster, 43900, true);
+                        else
+                            // 60% Ram
+                            m_caster->CastSpell(m_caster, 43899, true);
+                    }
+                    else
+                    {
+                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Kodo
+                            m_caster->CastSpell(m_caster, 49379, true);
+                        else
+                            // 60% Kodo
+                            m_caster->CastSpell(m_caster, 49378, true);
+                    }
+                    return;
+                case 52845:                                 // Brewfest Mount Transformation (Faction Swap)
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    if (!m_caster->HasAuraType(SPELL_AURA_MOUNTED))
+                        return;
+                    m_caster->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                    // Ram for Horde, Kodo for Alliance
+                    if (m_caster->ToPlayer()->GetTeam() == HORDE)
+                    {
+                        if (m_caster->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Ram
+                            m_caster->CastSpell(m_caster, 43900, true);
+                        else
+                            // 60% Ram
+                            m_caster->CastSpell(m_caster, 43899, true);
+                    }
+                    else
+                    {
+                        if (m_caster->ToPlayer()->GetSpeedRate(MOVE_RUN) >= 2.0f)
+                            // 100% Kodo
+                            m_caster->CastSpell(m_caster, 49379, true);
+                        else
+                            // 60% Kodo
+                            m_caster->CastSpell(m_caster, 49378, true);
+                    }
+                    return;
+                case 55004:                                 // Nitro Boosts
+                    if (!m_CastItem)
+                        return;
+                    if (roll_chance_i(95))                  // Nitro Boosts - success
+                        m_caster->CastSpell(m_caster, 54861, true, m_CastItem);
+                    else                                    // Knocked Up   - backfire 5%
+                        m_caster->CastSpell(m_caster, 46014, true, m_CastItem);
+                    return;
+                case 50243:                                 // Teach Language
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // spell has a 1/3 chance to trigger one of the below
+                    if (roll_chance_i(66))
+                        return;
+                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                    {
+                        // 1000001 - gnomish binary
+                        m_caster->CastSpell(m_caster, 50242, true);
+                    }
+                    else
+                    {
+                        // 01001000 - goblin binary
+                        m_caster->CastSpell(m_caster, 50246, true);
+                    }
+
+                    return;
+                }
+                case 51582:                                 //Rocket Boots Engaged (Rocket Boots Xtreme and Rocket Boots Xtreme Lite)
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    if (Battleground* bg = m_caster->ToPlayer()->GetBattleground())
+                        bg->EventPlayerDroppedFlag(m_caster->ToPlayer());
+
+                    m_caster->CastSpell(m_caster, 30452, true, NULL);
+                    return;
+                }
+                case 52759:                                 // Ancestral Awakening
+                    if (!unitTarget)
+                        return;
+                    m_caster->CastCustomSpell(unitTarget, 52752, &damage, NULL, NULL, true);
+                    return;
+                case 54171:                                   //Divine Storm
+                {
+                    m_caster->CastCustomSpell(unitTarget, 54172, &damage, 0, 0, true);
+                    return;
+                }
+                case 58418:                                 // Portal to Orgrimmar
+                case 58420:                                 // Portal to Stormwind
+                    return;                                 // implemented in EffectScript[0]
+                case 62324: // Throw Passenger
+                {
+                    if (m_targets.HasTraj())
+                    {
+                        if (Vehicle *vehicle = m_caster->GetVehicleKit())
+                            if (Unit *passenger = vehicle->GetPassenger(damage - 1))
+                            {
+                                std::list<Unit*> unitList;
+                                // use 99 because it is 3d search
+                                SearchAreaTarget(unitList, 99, PUSH_DST_CENTER, SPELL_TARGETS_ENTRY, 33114);
+                                float minDist = 99 * 99;
+                                Vehicle *target = NULL;
+                                for (std::list<Unit*>::iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+                                {
+                                    if (Vehicle *seat = (*itr)->GetVehicleKit())
+                                        if (!seat->GetPassenger(0))
+                                            if (Unit *device = seat->GetPassenger(2))
+                                                if (!device->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+                                                {
+                                                    float dist = (*itr)->GetExactDistSq(&m_targets.m_dstPos);
+                                                    if (dist < minDist)
+                                                    {
+                                                        minDist = dist;
+                                                        target = seat;
+                                                    }
+                                                }
+                                }
+                                if (target && target->GetBase()->IsWithinDist2d(&m_targets.m_dstPos, GetSpellRadius(m_spellInfo, effIndex, false) * 2)) // now we use *2 because the location of the seat is not correct
+                                    passenger->EnterVehicle(target, 0);
+                                else
+                                {
+                                    passenger->ExitVehicle();
+                                    float x, y, z;
+                                    m_targets.m_dstPos.GetPosition(x, y, z);
+                                    passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
+                                }
+                            }
+                    }
+                    return;
+                }
+                case 64385:                                 // Unusual Compass
+                {
+                    m_caster->SetOrientation(float(urand(0,62832)) / 10000.0f);
+                    WorldPacket data;
+                    m_caster->BuildHeartBeatMsg(&data);
+                    m_caster->SendMessageToSet(&data,true);
+                    return;
+                }
+            }
+
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+            // Charge
+            if (m_spellInfo->SpellFamilyFlags & SPELLFAMILYFLAG_WARRIOR_CHARGE && m_spellInfo->SpellVisual[0] == 867)
+            {
+                int32 chargeBasePoints0 = damage;
+                m_caster->CastCustomSpell(m_caster, 34846, &chargeBasePoints0, NULL, NULL, true);
+
+                //Juggernaut crit bonus
+                if (m_caster->HasAura(64976))
+                    m_caster->CastSpell(m_caster, 65156, true);
+                return;
+            }
+            //Slam
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_SLAM && m_spellInfo->SpellIconID == 559)
+            {
+                int32 bp0 = damage;
+                m_caster->CastCustomSpell(unitTarget, 50783, &bp0, NULL, NULL, true, 0);
+                return;
+            }
+            // Execute
+            if (m_spellInfo->SpellFamilyFlags[EFFECT_0] & SPELLFAMILYFLAG_WARRIOR_EXECUTE)
+            {
+                if (!unitTarget)
+                    return;
+
+                spell_id = 20647;
+
+                int32 rageUsed = std::min<int32>(300 - m_powerCost, m_caster->GetPower(POWER_RAGE));
+                int32 newRage = std::max<int32>(0, m_caster->GetPower(POWER_RAGE) - rageUsed);
+
+                // Sudden Death rage save
+                if (AuraEffect * aurEff = m_caster->GetAuraEffect(SPELL_AURA_PROC_TRIGGER_SPELL, SPELLFAMILY_GENERIC, 1989, EFFECT_0))
+                {
+                    int32 ragesave = SpellMgr::CalculateSpellEffectAmount(aurEff->GetSpellProto(), EFFECT_1) * 10;
+                    newRage = std::max(newRage, ragesave);
+                }
+
+                m_caster->SetPower(POWER_RAGE, uint32(newRage));
+
+                // Glyph of Execution bonus
+                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58367, EFFECT_0))
+                    rageUsed += aurEff->GetAmount() * 10;
+
+                bp = damage + int32(rageUsed * m_spellInfo->EffectDamageMultiplier[effIndex] + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.2f);
+                break;
+            }
+            // Concussion Blow
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARRIOR_CONCUSSION_BLOW)
+            {
+                m_damage+= uint32(damage * m_caster->GetTotalAttackPowerValue(BASE_ATTACK) / 100);
+                return;
+            }
+            switch(m_spellInfo->Id)
+            {
+                // Bloodthirst
+                case 23881:
+                {
+                    m_caster->CastCustomSpell(unitTarget, 23885, &damage, NULL, NULL, true, NULL);
+                    return;
+                }
+            }
+            break;
+        case SPELLFAMILY_WARLOCK:
+            // Life Tap
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_WARLOCK_LIFETAP)
+            {
+                float spFactor = 0.0f;
+                switch (m_spellInfo->Id)
+                {
+                    case 11689: spFactor = 0.2f; break;
+                    case 27222:
+                    case 57946: spFactor = 0.5f; break;
+                }
+                int32 damage = int32(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0) + (6.3875 * m_spellInfo->baseLevel));
+                int32 mana = int32(damage + (m_caster->ToPlayer()->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+SPELL_SCHOOL_SHADOW) * spFactor));
+
+                if (unitTarget && (int32(unitTarget->GetHealth()) > damage))
+                {
+                    // Shouldn't Appear in Combat Log
+                    unitTarget->ModifyHealth(-damage);
+
+                    // Improved Life Tap mod
+                    if (AuraEffect const * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 208, 0))
+                        mana = (aurEff->GetAmount() + 100)* mana / 100;
+
+                    m_caster->CastCustomSpell(unitTarget, 31818, &mana, NULL, NULL, true);
+
+                    // Mana Feed
+                    int32 manaFeedVal = 0;
+                    if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_WARLOCK, 1982, 0))
+                        manaFeedVal = aurEff->GetAmount();
+
+                    if (manaFeedVal > 0)
+                    {
+                        manaFeedVal = manaFeedVal * mana / 100;
+                        m_caster->CastCustomSpell(m_caster, 32553, &manaFeedVal, NULL, NULL, true, NULL);
+                    }
+                }
+                else
+                    SendCastResult(SPELL_FAILED_FIZZLE);
+                return;
+            }
+            break;
+        case SPELLFAMILY_DRUID:
+            // Starfall
+            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_DRUID_STARFALL)
+            {
+                //Shapeshifting into an animal form or mounting cancels the effect.
+                if (m_caster->GetCreatureType() == CREATURE_TYPE_BEAST || m_caster->IsMounted())
+                {
+                    if (m_triggeredByAuraSpell)
+                        m_caster->RemoveAurasDueToSpell(m_triggeredByAuraSpell->Id);
+                    return;
+                }
+
+                //Any effect which causes you to lose control of your character will supress the starfall effect.
+                if (m_caster->hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_FLEEING | UNIT_STAT_ROOT | UNIT_STAT_CONFUSED))
+                    return;
+
+                m_caster->CastSpell(unitTarget, damage, true);
+                return;
+            }
+            break;
+        case SPELLFAMILY_PALADIN:
+            // Divine Storm
+            if (m_spellInfo->SpellFamilyFlags[1] & SPELLFAMILYFLAG1_PALADIN_DIVINESTORM && effIndex == 1)
+            {
+                int32 dmg = m_damage * damage / 100;
+                if (!unitTarget)
+                    unitTarget = m_caster;
+                m_caster->CastCustomSpell(unitTarget, 54171, &dmg, 0, 0, true);
+                return;
+            }
+
+            switch(m_spellInfo->Id)
+            {
+                case 31789:                                 // Righteous Defense (step 1)
+                {
+                    // Clear targets for eff 1
+                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        ihit->effectMask &= ~(1<<1);
+
+                    // not empty (checked), copy
+                    Unit::AttackerSet attackers = unitTarget->getAttackers();
+
+                    // selected from list 3
+                    for (uint32 i = 0; i < std::min(size_t(3), attackers.size()); ++i)
+                    {
+                        Unit::AttackerSet::iterator aItr = attackers.begin();
+                        std::advance(aItr, rand() % attackers.size());
+                        AddUnitTarget((*aItr), 1);
+                        attackers.erase(aItr);
+                    }
+
+                    // now let next effect cast spell at each target.
+                    return;
+                }
+            }
+            break;
+        case SPELLFAMILY_SHAMAN:
+            // Cleansing Totem Pulse
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_TOTEM_EFFECTS && m_spellInfo->SpellIconID == 1673)
+            {
+                int32 bp1 = 1;
+                // Cleansing Totem Effect
+                if (unitTarget)
+                    m_caster->CastCustomSpell(unitTarget, 52025, NULL, &bp1, NULL, true, NULL, NULL, m_originalCasterGUID);
+                return;
+            }
+            // Healing Stream Totem
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_HEALING_STREAM)
+            {
+                if (!unitTarget)
+                    return;
+                // Restorative Totems
+                if (Unit *owner = m_caster->GetOwner())
+                    if (AuraEffect *dummy = owner->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 338, 1))
+                        damage += damage * dummy->GetAmount() / 100;
+
+                    m_caster->CastCustomSpell(unitTarget, 52042, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
+                return;
+            }
+            // Mana Spring Totem
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_SHAMAN_MANA_SPRING)
+            {
+                if (!unitTarget || unitTarget->getPowerType() != POWER_MANA)
+                    return;
+                m_caster->CastCustomSpell(unitTarget, 52032, &damage, 0, 0, true, 0, 0, m_originalCasterGUID);
+                return;
+            }
+            // Lava Lash
+            if (m_spellInfo->SpellFamilyFlags[2] & SPELLFAMILYFLAG2_SHAMAN_LAVA_LASH)
+            {
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return;
+
+                if (m_caster->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
+                {
+                    // Damage is increased by 25% if your off-hand weapon is enchanted with Flametongue.
+                    if (m_caster->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 0x200000, 0, 0))
+                        m_damage += m_damage * damage / 100;
+                }
+                return;
+            }
+            break;
+        case SPELLFAMILY_DEATHKNIGHT:
+            // Death strike
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_STRIKE)
+            {
+                uint32 count = unitTarget->GetDiseasesByCaster(m_caster->GetGUID());
+                int32 bp = int32(count * m_caster->CountPctFromMaxHealth(int32(m_spellInfo->EffectDamageMultiplier[0])));
+                // Improved Death Strike
+                if (AuraEffect const * aurEff = m_caster->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DEATHKNIGHT, 2751, 0))
+                    bp = int32(bp * (m_caster->CalculateSpellDamage(m_caster, aurEff->GetSpellProto(), 2) + 100.0f) / 100.0f);
+                m_caster->CastCustomSpell(m_caster, 45470, &bp, NULL, NULL, false);
+                return;
+            }
+            // Death Coil
+            if (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_DK_DEATH_COIL)
+            {
+                if (m_caster->IsFriendlyTo(unitTarget))
+                {
+                    int32 bp = int32(damage * 1.5f);
+                    m_caster->CastCustomSpell(unitTarget, 47633, &bp, NULL, NULL, true);
+                }
+                else
+                {
+                    int32 bp = damage;
+                    m_caster->CastCustomSpell(unitTarget, 47632, &bp, NULL, NULL, true);
+                }
+                return;
+            }
+            switch (m_spellInfo->Id)
+            {
+            case 49560: // Death Grip
+                Position pos;
+                GetSummonPosition(effIndex, pos);
+                if (Unit *unit = unitTarget->GetVehicleBase()) // what is this for?
+                    unit->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
+                else
+                    unitTarget->CastSpell(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), damage, true);
+                return;
+            case 46584: // Raise Dead
+                if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                    return;
+
+                // Do we have talent Master of Ghouls?
+                if (m_caster->HasAura(52143))
+                    // summon as pet
+                    bp = 52150;
+                else
+                    // or guardian
+                    bp = 46585;
+
+                if (m_targets.HasDst())
+                    targets.setDst(m_targets.m_dstPos);
+                else
+                {
+                    targets.setDst(*m_caster);
+                    // Corpse not found - take reagents (only not triggered cast can take them)
+                    triggered = false;
+                }
+                // Remove cooldown - summon spellls have category
+                m_caster->ToPlayer()->RemoveSpellCooldown(m_spellInfo->Id, true);
+                spell_id = 48289;
+                break;
+            // Raise dead - take reagents and trigger summon spells
+            case 48289:
+                if (m_targets.HasDst())
+                    targets.setDst(m_targets.m_dstPos);
+
+                spell_id = CalculateDamage(0, NULL);
+                break;
+            }
+            break;
+    }
+
+    //spells triggered by dummy effect should not miss
+    if (spell_id)
+    {
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
+
+        if (!spellInfo)
+        {
+            sLog.outError("EffectDummy of spell %u: triggering unknown spell id %i\n", m_spellInfo->Id, spell_id);
+            return;
+        }
+
+        targets.setUnitTarget(unitTarget);
+        Spell* spell = new Spell(m_caster, spellInfo, triggered, m_originalCasterGUID, true);
+        if (bp) spell->SetSpellValue(SPELLVALUE_BASE_POINT0, bp);
+        spell->prepare(&targets);
+    }
+
+    // pet auras
+    if (PetAura const* petSpell = sSpellMgr.GetPetAura(m_spellInfo->Id,effIndex))
+    {
+        m_caster->AddPetAura(petSpell);
+        return;
+    }
+
+    // normal DB scripted effect
+    sLog.outDebug("Spell ScriptStart spellid %u in EffectDummy(%u)", m_spellInfo->Id, effIndex);
+    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
+
+    // Script based implementation. Must be used only for not good for implementation in core spell effects
+    // So called only for not proccessed cases
+    if (gameObjTarget)
+        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, gameObjTarget);
+    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_UNIT)
+        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, unitTarget->ToCreature());
+    else if (itemTarget)
+        sScriptMgr.OnDummyEffect(m_caster, m_spellInfo->Id, effIndex, itemTarget);
+}
+
+void Spell::EffectTriggerSpellWithValue(SpellEffIndex effIndex)
+{
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerSpellWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    int32 bp = damage;
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastCustomSpell(unitTarget,triggered_spell_id,&bp,&bp,&bp,true);
+}
+
+void Spell::EffectTriggerRitualOfSummoning(SpellEffIndex effIndex)
+{
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerRitualOfSummoning of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    finish();
+
+    m_caster->CastSpell(unitTarget,spellInfo,false);
+}
+
+void Spell::EffectForceCast(SpellEffIndex effIndex)
+{
+      switch(m_spellInfo->Id)
+      {
+               case 66548://Teleport (IC battleground)
+               {
+                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(23472,60.0f,true))
+                       {
+                               float x,y,z,o;
+                               TargetTeleport->GetPosition(x,y,z,o);
+                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
+                                       return;
+                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
+                       }
+                       return;        
+               }
+               case 66549:
+               {
+                       if(Creature* TargetTeleport=m_caster->FindNearestCreature(22515,60.0f,true))
+                       {
+                               float x,y,z,o;
+                               TargetTeleport->GetPosition(x,y,z,o);
+                               if(m_caster->GetTypeId()!=TYPEID_PLAYER)
+                                       return;
+                               m_caster->ToPlayer()->TeleportTo(628,x,y,z,o);
+                       }
+                       return;
+               }
+       }
+
+    if (!unitTarget)
+        return;
+
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectForceCast of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    if (damage)
+    {
+        switch(m_spellInfo->Id)
+        {
+                case 66218: //Catapulte
+                if (Vehicle *vehicle = m_caster->GetVehicleKit())
+                    if (Unit *passenger = vehicle->GetPassenger(0))
+                    {
+                        passenger->ExitVehicle();
+                    passenger->AddAura(66251,passenger);
+                        float x, y, z;
+                        m_targets.m_dstPos.GetPosition(x, y, z);
+                        passenger->GetMotionMaster()->MoveJump(x, y, z, m_targets.GetSpeedXY(), m_targets.GetSpeedZ());
+                    }                    
+                return;    
+            case 66629:
+            case 66638:
+            {
+                if(!(m_caster->GetTypeId()==TYPEID_PLAYER))
+                    return;
+                Player *plr = m_caster->ToPlayer();
+                if (Battleground *bg = plr->GetBattleground())
+                    {
+                        if (bg->GetTypeID(true) == BATTLEGROUND_IC)
+                            bg->EventPlayerCapturedFlag(plr);
+                        return;
+                    }
+                
+                return;
+            }
+            case 52588: // Skeletal Gryphon Escape
+            case 48598: // Ride Flamebringer Cue
+                unitTarget->RemoveAura(damage);
+                break;
+            case 52463: // Hide In Mine Car
+            case 52349: // Overtake
+                unitTarget->CastCustomSpell(unitTarget, spellInfo->Id, &damage, NULL, NULL, true, NULL, NULL, m_originalCasterGUID);
+                return;
+            case 72378: // Blood Nova
+            case 73058: // Blood Nova
+                spellInfo = sSpellMgr.GetSpellForDifficultyFromSpell(spellInfo, m_caster);
+                break;
+        }
+    }
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastSpell(unitTarget, spellInfo, true, NULL, NULL, m_originalCasterGUID);
+}
+
+void Spell::EffectForceCastWithValue(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectForceCastWithValue of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+    int32 bp = damage;
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastCustomSpell(unitTarget, spellInfo->Id, &bp, &bp, &bp, true, NULL, NULL, m_originalCasterGUID);
+}
+
+
+void Spell::EffectTriggerSpell(SpellEffIndex effIndex)
+{
+    // only unit case known
+    if (!unitTarget)
+    {
+        if (gameObjTarget || itemTarget)
+            sLog.outError("Spell::EffectTriggerSpell (Spell: %u): Unsupported non-unit case!",m_spellInfo->Id);
+        return;
+    }
+
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+    Unit* originalCaster = NULL;
+
+    // special cases
+    switch(triggered_spell_id)
+    {
+        // Mirror Image
+        case 58832:
+        {
+            // Glyph of Mirror Image
+            if (m_caster->HasAura(63093))
+               m_caster->CastSpell(m_caster, 65047, true); // Mirror Image
+
+            break;
+        }
+        // Vanish (not exist)
+        case 18461:
+        {
+            unitTarget->RemoveMovementImpairingAuras();
+            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
+
+            // if this spell is given to NPC it must handle rest by it's own AI
+            if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+                return;
+
+            // get highest rank of the Stealth spell
+            uint32 spellId = 0;
+            SpellEntry const *spellInfo;
+            const PlayerSpellMap& sp_list = unitTarget->ToPlayer()->GetSpellMap();
+            for (PlayerSpellMap::const_iterator itr = sp_list.begin(); itr != sp_list.end(); ++itr)
+            {
+                // only highest rank is shown in spell book, so simply check if shown in spell book
+                if (!itr->second->active || itr->second->disabled || itr->second->state == PLAYERSPELL_REMOVED)
+                    continue;
+
+                spellInfo = sSpellStore.LookupEntry(itr->first);
+                if (!spellInfo)
+                    continue;
+
+                if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_ROGUE_STEALTH)
+                {
+                    spellId = spellInfo->Id;
+                    break;
+                }
+            }
+
+            // no Stealth spell found
+            if (!spellId)
+                return;
+
+            // reset cooldown on it if needed
+            if (unitTarget->ToPlayer()->HasSpellCooldown(spellId))
+                unitTarget->ToPlayer()->RemoveSpellCooldown(spellId);
+
+            triggered_spell_id =  spellId;
+            break;
+        }
+        // Demonic Empowerment -- succubus
+        case 54437:
+        {
+            unitTarget->RemoveMovementImpairingAuras();
+            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STALKED);
+            unitTarget->RemoveAurasByType(SPELL_AURA_MOD_STUN);
+
+            // Cast Lesser Invisibility
+            triggered_spell_id = 7870;
+            break;
+        }
+        // just skip
+        case 23770:                                         // Sayge's Dark Fortune of *
+            // not exist, common cooldown can be implemented in scripts if need.
+            return;
+        // Brittle Armor - (need add max stack of 24575 Brittle Armor)
+        case 29284:
+        {
+            // Brittle Armor
+            SpellEntry const* spell = sSpellStore.LookupEntry(24575);
+            if (!spell)
+                return;
+
+            for (uint32 j = 0; j < spell->StackAmount; ++j)
+                m_caster->CastSpell(unitTarget, spell->Id, true);
+            return;
+        }
+        // Mercurial Shield - (need add max stack of 26464 Mercurial Shield)
+        case 29286:
+        {
+            // Mercurial Shield
+            SpellEntry const* spell = sSpellStore.LookupEntry(26464);
+            if (!spell)
+                return;
+
+            for (uint32 j = 0; j < spell->StackAmount; ++j)
+                m_caster->CastSpell(unitTarget, spell->Id, true);
+            return;
+        }
+        // Righteous Defense
+        case 31980:
+        {
+            m_caster->CastSpell(unitTarget, 31790, true);
+            return;
+        }
+        // Cloak of Shadows
+        case 35729:
+        {
+            uint32 dispelMask = GetDispellMask(DISPEL_ALL);
+            Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::iterator iter = Auras.begin(); iter != Auras.end();)
+            {
+                // remove all harmful spells on you...
+                SpellEntry const* spell = iter->second->GetBase()->GetSpellProto();
+                if ((spell->DmgClass == SPELL_DAMAGE_CLASS_MAGIC // only affect magic spells
+                    || ((1<<spell->Dispel) & dispelMask))
+                    // ignore positive and passive auras
+                    && !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive())
+                {
+                    m_caster->RemoveAura(iter);
+                }
+                else
+                    iter++;
+            }
+            return;
+        }
+        // Priest Shadowfiend (34433) need apply mana gain trigger aura on pet
+        case 41967:
+        {
+            if (Unit *pet = unitTarget->GetGuardianPet())
+                pet->CastSpell(pet, 28305, true);
+            return;
+        }
+        // Empower Rune Weapon
+        case 53258:
+            return; // skip, hack-added in spell effect
+        // Snake Trap
+        case 57879:
+            originalCaster = m_originalCaster;
+            break;
+        // Coldflame
+        case 33801:
+            return; // just make the core stfu
+    }
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerSpell of spell %u: triggering unknown spell id %i", m_spellInfo->Id,triggered_spell_id);
+        return;
+    }
+
+    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
+    // Needed by freezing arrow and few other spells
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
+        && m_spellInfo->Category == spellInfo->Category)
+        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
+
+    // Note: not exist spells with weapon req. and IsSpellHaveCasterSourceTargets == true
+    // so this just for speedup places in else
+    Unit * caster = GetTriggeredSpellCaster(spellInfo, m_caster, unitTarget);
+
+    caster->CastSpell(unitTarget,spellInfo,true, 0, 0, (originalCaster ? originalCaster->GetGUID() : 0));
+}
+
+void Spell::EffectTriggerMissileSpell(SpellEffIndex effIndex)
+{
+    uint32 triggered_spell_id = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    // normal case
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(triggered_spell_id);
+
+    if (!spellInfo)
+    {
+        sLog.outError("EffectTriggerMissileSpell of spell %u (eff: %u): triggering unknown spell id %u",
+            m_spellInfo->Id,effIndex,triggered_spell_id);
+        return;
+    }
+
+    if (m_CastItem)
+        sLog.outStaticDebug("WORLD: cast Item spellId - %i", spellInfo->Id);
+
+    // Remove spell cooldown (not category) if spell triggering spell with cooldown and same category
+    // Needed by freezing arrow and few other spells
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->CategoryRecoveryTime && spellInfo->CategoryRecoveryTime
+        && m_spellInfo->Category == spellInfo->Category)
+        m_caster->ToPlayer()->RemoveSpellCooldown(spellInfo->Id);
+
+    float x, y, z;
+    m_targets.m_dstPos.GetPosition(x, y, z);
+    m_caster->CastSpell(x, y, z, spellInfo->Id, true, m_CastItem, 0, m_originalCasterGUID);
+}
+
+void Spell::EffectJump(SpellEffIndex effIndex)
+{
+    if (m_caster->isInFlight())
+        return;
+
+    float x,y,z,o;
+    if (m_targets.getUnitTarget())
+    {
+        m_targets.getUnitTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
+        o = m_caster->GetOrientation();
+    }
+    else if (m_targets.getGOTarget())
+    {
+        m_targets.getGOTarget()->GetContactPoint(m_caster,x,y,z,CONTACT_DISTANCE);
+        o = m_caster->GetOrientation();
+    }
+    else
+    {
+        sLog.outError("Spell::EffectJump - unsupported target mode for spell ID %u", m_spellInfo->Id);
+        return;
+    }
+
+    float speedXY, speedZ;
+    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
+    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+}
+
+void Spell::EffectJumpDest(SpellEffIndex effIndex)
+{
+    if (m_caster->isInFlight())
+        return;
+
+    // Init dest coordinates
+    float x,y,z,o;
+    if (m_targets.HasDst())
+    {
+        m_targets.m_dstPos.GetPosition(x, y, z);
+
+        if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DEST_TARGET_BACK)
+        {
+            // explicit cast data from client or server-side cast
+            // some spell at client send caster
+            Unit* pTarget = NULL;
+            if (m_targets.getUnitTarget() && m_targets.getUnitTarget() != m_caster)
+                pTarget = m_targets.getUnitTarget();
+            else if (m_caster->getVictim())
+                pTarget = m_caster->getVictim();
+            else if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                pTarget = ObjectAccessor::GetUnit(*m_caster, m_caster->ToPlayer()->GetSelection());
+
+            o = pTarget ? pTarget->GetOrientation() : m_caster->GetOrientation();
+        }
+        else
+            o = m_caster->GetOrientation();
+    }
+    else
+    {
+        sLog.outError("Spell::EffectJumpDest - unsupported target mode for spell ID %u", m_spellInfo->Id);
+        return;
+    }
+
+    float speedXY, speedZ;
+    CalculateJumpSpeeds(effIndex, m_caster->GetExactDist2d(x, y), speedXY, speedZ);
+    m_caster->GetMotionMaster()->MoveJump(x, y, z, speedXY, speedZ);
+}
+
+void Spell::CalculateJumpSpeeds(uint8 i, float dist, float & speedXY, float & speedZ)
+{
+    if (m_spellInfo->EffectMiscValue[i])
+        speedZ = float(m_spellInfo->EffectMiscValue[i])/10;
+    else if (m_spellInfo->EffectMiscValueB[i])
+        speedZ = float(m_spellInfo->EffectMiscValueB[i])/10;
+    else
+        speedZ = 10.0f;
+    speedXY = dist * 10.0f / speedZ;
+}
+
+void Spell::EffectTeleportUnits(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->isInFlight())
+        return;
+
+    // Pre effects
+    uint8 uiMaxSafeLevel = 0;
+    switch (m_spellInfo->Id)
+    {
+        case 66550:
+            return;
+        case 48129:  // Scroll of Recall
+            uiMaxSafeLevel = 40;
+        case 60320:  // Scroll of Recall II
+            if (!uiMaxSafeLevel)
+                uiMaxSafeLevel = 70;
+        case 60321:  // Scroll of Recal III
+            if (!uiMaxSafeLevel)
+                uiMaxSafeLevel = 80;
+
+            if (unitTarget->getLevel() > uiMaxSafeLevel)
+            {
+                unitTarget->AddAura(60444,unitTarget); //Apply Lost! Aura
+                return;
+            }
+            break;
+    }
+
+    // If not exist data for dest location - return
+    if (!m_targets.HasDst())
+    {
+        sLog.outError("Spell::EffectTeleportUnits - does not have destination for spell ID %u\n", m_spellInfo->Id);
+        return;
+    }
+
+    // Init dest coordinates
+    uint32 mapid = m_targets.m_dstPos.GetMapId();
+    if (mapid == MAPID_INVALID)
+        mapid = unitTarget->GetMapId();
+    float x, y, z, orientation;
+    m_targets.m_dstPos.GetPosition(x, y, z, orientation);
+    if (!orientation && m_targets.getUnitTarget())
+        orientation = m_targets.getUnitTarget()->GetOrientation();
+    sLog.outDebug("Spell::EffectTeleportUnits - teleport unit to %u %f %f %f %f\n", mapid, x, y, z, orientation);
+
+    if (mapid == unitTarget->GetMapId())
+        unitTarget->NearTeleportTo(x, y, z, orientation, unitTarget == m_caster);
+    else if (unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->TeleportTo(mapid, x, y, z, orientation, unitTarget == m_caster ? TELE_TO_SPELL : 0);
+
+    // post effects for TARGET_DST_DB
+    switch (m_spellInfo->Id)
+    {
+        // Dimensional Ripper - Everlook
+        case 23442:
+        {
+            int32 r = irand(0, 119);
+            if (r >= 70)                                  // 7/12 success
+            {
+                if (r < 100)                              // 4/12 evil twin
+                    m_caster->CastSpell(m_caster, 23445, true);
+                else                                        // 1/12 fire
+                    m_caster->CastSpell(m_caster, 23449, true);
+            }
+            return;
+        }
+        // Ultrasafe Transporter: Toshley's Station
+        case 36941:
+        {
+            if (roll_chance_i(50))                        // 50% success
+            {
+                int32 rand_eff = urand(1, 7);
+                switch (rand_eff)
+                {
+                    case 1:
+                        // soul split - evil
+                        m_caster->CastSpell(m_caster, 36900, true);
+                        break;
+                    case 2:
+                        // soul split - good
+                        m_caster->CastSpell(m_caster, 36901, true);
+                        break;
+                    case 3:
+                        // Increase the size
+                        m_caster->CastSpell(m_caster, 36895, true);
+                        break;
+                    case 4:
+                        // Decrease the size
+                        m_caster->CastSpell(m_caster, 36893, true);
+                        break;
+                    case 5:
+                    // Transform
+                    {
+                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                            m_caster->CastSpell(m_caster, 36897, true);
+                        else
+                            m_caster->CastSpell(m_caster, 36899, true);
+                        break;
+                    }
+                    case 6:
+                        // chicken
+                        m_caster->CastSpell(m_caster, 36940, true);
+                        break;
+                    case 7:
+                        // evil twin
+                        m_caster->CastSpell(m_caster, 23445, true);
+                        break;
+                }
+            }
+            return;
+        }
+        // Dimensional Ripper - Area 52
+        case 36890:
+        {
+            if (roll_chance_i(50))                        // 50% success
+            {
+                int32 rand_eff = urand(1, 4);
+                switch (rand_eff)
+                {
+                    case 1:
+                        // soul split - evil
+                        m_caster->CastSpell(m_caster, 36900, true);
+                        break;
+                    case 2:
+                        // soul split - good
+                        m_caster->CastSpell(m_caster, 36901, true);
+                        break;
+                    case 3:
+                        // Increase the size
+                        m_caster->CastSpell(m_caster, 36895, true);
+                        break;
+                    case 4:
+                        // Transform
+                    {
+                        if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+                            m_caster->CastSpell(m_caster, 36897, true);
+                        else
+                            m_caster->CastSpell(m_caster, 36899, true);
+                        break;
+                    }
+                }
+            }
+            return;
+        }
+    }
+}
+
+void Spell::EffectApplyAura(SpellEffIndex effIndex)
+{
+    if (!m_spellAura || !unitTarget)
+        return;
+    ASSERT(unitTarget == m_spellAura->GetOwner());
+    m_spellAura->_ApplyEffectForTargets(effIndex);
+}
+
+void Spell::EffectApplyAreaAura(SpellEffIndex effIndex)
+{
+    if (!m_spellAura || !unitTarget)
+        return;
+    ASSERT (unitTarget == m_spellAura->GetOwner());
+    m_spellAura->_ApplyEffectForTargets(effIndex);
+}
+
+void Spell::EffectUnlearnSpecialization(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)unitTarget;
+    uint32 spellToUnlearn = m_spellInfo->EffectTriggerSpell[effIndex];
+
+    _player->removeSpell(spellToUnlearn);
+
+    sLog.outDebug("Spell: Player %u has unlearned spell %u from NpcGUID: %u", _player->GetGUIDLow(), spellToUnlearn, m_caster->GetGUIDLow());
+}
+
+void Spell::EffectPowerDrain(SpellEffIndex effIndex)
+{
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
+        return;
+
+    // add spell damage bonus
+    damage = m_caster->SpellDamageBonus(unitTarget, m_spellInfo, uint32(damage), SPELL_DIRECT_DAMAGE);
+
+    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
+    int32 power = damage;
+    if (powerType == POWER_MANA)
+        power -= unitTarget->GetSpellCritDamageReduction(power);
+
+    int32 newDamage = -(unitTarget->ModifyPower(powerType, -int32(power)));
+
+    float gainMultiplier = 0.0f;
+
+    // Don`t restore from self drain
+    if (m_caster != unitTarget)
+    {
+        gainMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
+
+        int32 gain = int32(newDamage * gainMultiplier);
+
+        m_caster->EnergizeBySpell(m_caster, m_spellInfo->Id, gain, powerType);
+    }
+    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, gainMultiplier);
+}
+
+void Spell::EffectSendEvent(SpellEffIndex effIndex)
+{
+    /*
+    we do not handle a flag dropping or clicking on flag in battleground by sendevent system
+    */
+    sLog.outDebug("Spell ScriptStart %u for spellid %u in EffectSendEvent ", m_spellInfo->EffectMiscValue[effIndex], m_spellInfo->Id);
+
+    Object *pTarget;
+    if (focusObject)
+        pTarget = focusObject;
+    else if (unitTarget)
+        pTarget = unitTarget;
+    else if (gameObjTarget)
+        pTarget = gameObjTarget;
+    else
+        pTarget = NULL;
+
+    m_caster->GetMap()->ScriptsStart(sEventScripts, m_spellInfo->EffectMiscValue[effIndex], m_caster, pTarget);
+}
+
+void Spell::EffectPowerBurn(SpellEffIndex effIndex)
+{
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers powerType = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    if (!unitTarget || !unitTarget->isAlive() || unitTarget->getPowerType() != powerType || damage < 0)
+        return;
+
+    // burn x% of target's mana, up to maximum of 2x% of caster's mana (Mana Burn)
+    if (m_spellInfo->ManaCostPercentage)
+    {
+        int32 maxDamage = m_caster->GetMaxPower(powerType) * damage * 2 / 100;
+        damage = unitTarget->GetMaxPower(powerType) * damage / 100;
+        damage = std::min(damage, maxDamage);
+    }
+
+    int32 power = damage;
+    // resilience reduce mana draining effect at spell crit damage reduction (added in 2.4)
+    if (powerType == POWER_MANA)
+        power -= unitTarget->GetSpellCritDamageReduction(power);
+
+    int32 newDamage = -(unitTarget->ModifyPower(powerType, -power));
+
+    // NO - Not a typo - EffectPowerBurn uses effect value multiplier - not effect damage multiplier
+    float dmgMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
+
+    // add log data before multiplication (need power amount, not damage)
+    ExecuteLogEffectTakeTargetPower(effIndex, unitTarget, powerType, newDamage, 0.0f);
+
+    newDamage = int32(newDamage * dmgMultiplier);
+
+    m_damage += newDamage;
+}
+
+void Spell::EffectHeal(SpellEffIndex /*effIndex*/)
+{
+}
+
+void Spell::SpellDamageHeal(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->isAlive() && damage >= 0)
+    {
+        // Try to get original caster
+        Unit *caster = m_originalCasterGUID ? m_originalCaster : m_caster;
+
+        // Skip if m_originalCaster not available
+        if (!caster)
+            return;
+
+        int32 addhealth = damage;
+
+        // Vessel of the Naaru (Vial of the Sunwell trinket)
+        if (m_spellInfo->Id == 45064)
+        {
+            // Amount of heal - depends from stacked Holy Energy
+            int damageAmount = 0;
+            if (AuraEffect const * aurEff = m_caster->GetAuraEffect(45062, 0))
+            {
+                damageAmount+= aurEff->GetAmount();
+                m_caster->RemoveAurasDueToSpell(45062);
+            }
+
+            addhealth += damageAmount;
+        }
+        // Swiftmend - consumes Regrowth or Rejuvenation
+        else if (m_spellInfo->TargetAuraState == AURA_STATE_SWIFTMEND && unitTarget->HasAuraState(AURA_STATE_SWIFTMEND, m_spellInfo, m_caster))
+        {
+            Unit::AuraEffectList const& RejorRegr = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+            // find most short by duration
+            AuraEffect *targetAura = NULL;
+            for (Unit::AuraEffectList::const_iterator i = RejorRegr.begin(); i != RejorRegr.end(); ++i)
+            {
+                if ((*i)->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID
+                    && (*i)->GetSpellProto()->SpellFamilyFlags[0] & 0x50)
+                {
+                    if (!targetAura || (*i)->GetBase()->GetDuration() < targetAura->GetBase()->GetDuration())
+                        targetAura = *i;
+                }
+            }
+
+            if (!targetAura)
+            {
+                sLog.outError("Target(GUID:" UI64FMTD ") has aurastate AURA_STATE_SWIFTMEND but no matching aura.", unitTarget->GetGUID());
+                return;
+            }
+
+            int32 tickheal = targetAura->GetAmount();
+            if (Unit* auraCaster = targetAura->GetCaster())
+                tickheal = auraCaster->SpellHealingBonus(unitTarget, targetAura->GetSpellProto(), tickheal, DOT);
+            //int32 tickheal = targetAura->GetSpellProto()->EffectBasePoints[idx] + 1;
+            //It is said that talent bonus should not be included
+
+            int32 tickcount = 0;
+            // Rejuvenation
+            if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x10)
+                tickcount = 4;
+            // Regrowth
+            else // if (targetAura->GetSpellProto()->SpellFamilyFlags[0] & 0x40)
+                tickcount = 6;
+
+            addhealth += tickheal * tickcount;
+
+            // Glyph of Swiftmend
+            if (!caster->HasAura(54824))
+                unitTarget->RemoveAura(targetAura->GetId(), targetAura->GetCasterGUID());
+
+            //addhealth += tickheal * tickcount;
+            //addhealth = caster->SpellHealingBonus(m_spellInfo, addhealth,HEAL, unitTarget);
+        }
+        // Glyph of Nourish
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x2000000)
+        {
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
+
+            if (AuraEffect const* aurEff = m_caster->GetAuraEffect(62971, 0))
+            {
+                Unit::AuraEffectList const& Periodic = unitTarget->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+                for (Unit::AuraEffectList::const_iterator i = Periodic.begin(); i != Periodic.end(); ++i)
+                {
+                    if (m_caster->GetGUID() == (*i)->GetCasterGUID())
+                        addhealth += addhealth * aurEff->GetAmount() / 100;
+                }
+            }
+        }
+        // Lifebloom - final heal coef multiplied by original DoT stack
+        else if (m_spellInfo->Id == 33778)
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL, m_spellValue->EffectBasePoints[1]);
+        // Riptide - increase healing done by Chain Heal
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x100)
+        {
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
+            if (AuraEffect * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0, 0, 0x10, m_originalCasterGUID))
+            {
+                addhealth = int32(addhealth * 1.25f);
+                // consume aura
+                unitTarget->RemoveAura(aurEff->GetBase());
+            }
+        }
+        // Death Pact - return pct of max health to caster
+        else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, int32(caster->CountPctFromMaxHealth(damage)), HEAL);
+        else
+            addhealth = caster->SpellHealingBonus(unitTarget, m_spellInfo, addhealth, HEAL);
+
+        // Remove Grievious bite if fully healed
+        if (unitTarget->HasAura(48920) && (unitTarget->GetHealth() + addhealth >= unitTarget->GetMaxHealth()))
+            unitTarget->RemoveAura(48920);
+
+        m_damage -= addhealth;
+    }
+}
+
+void Spell::EffectHealPct(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
+        return;
+
+    // Skip if m_originalCaster not available
+    if (!m_originalCaster)
+        return;
+
+    // Rune Tap - Party
+    if (m_spellInfo->Id == 59754 && unitTarget == m_caster)
+        return;
+
+    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, unitTarget->CountPctFromMaxHealth(damage), HEAL);
+}
+
+void Spell::EffectHealMechanical(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
+        return;
+
+    // Skip if m_originalCaster not available
+    if (!m_originalCaster)
+        return;
+
+    m_healing += m_originalCaster->SpellHealingBonus(unitTarget, m_spellInfo, uint32(damage), HEAL);
+}
+
+void Spell::EffectHealthLeech(SpellEffIndex effIndex)
+{
+    if (!unitTarget || !unitTarget->isAlive() || damage < 0)
+        return;
+
+    sLog.outDebug("HealthLeech :%i", damage);
+
+    float healMultiplier = SpellMgr::CalculateSpellEffectValueMultiplier(m_spellInfo, effIndex, m_originalCaster, this);
+
+    m_damage += damage;
+    // get max possible damage, don't count overkill for heal
+    uint32 healthGain = uint32(-unitTarget->GetHealthGain(-damage) * healMultiplier);
+
+    if (m_caster->isAlive())
+    {
+        healthGain = m_caster->SpellHealingBonus(m_caster, m_spellInfo, healthGain, HEAL);
+        m_caster->HealBySpell(m_caster, m_spellInfo, uint32(healthGain));
+    }
+}
+
+void Spell::DoCreateItem(uint32 /*i*/, uint32 itemtype)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* player = (Player*)unitTarget;
+
+    uint32 newitemid = itemtype;
+    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(newitemid);
+    if (!pProto)
+    {
+        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+        return;
+    }
+
+    // bg reward have some special in code work
+    uint32 bgType = 0;
+    switch(m_spellInfo->Id)
+    {
+        case SPELL_AV_MARK_WINNER:
+        case SPELL_AV_MARK_LOSER:
+            bgType = BATTLEGROUND_AV;
+            break;
+        case SPELL_WS_MARK_WINNER:
+        case SPELL_WS_MARK_LOSER:
+            bgType = BATTLEGROUND_WS;
+            break;
+        case SPELL_AB_MARK_WINNER:
+        case SPELL_AB_MARK_LOSER:
+            bgType = BATTLEGROUND_AB;
+            break;
+        default:
+            break;
+    }
+
+    uint32 num_to_add = damage;
+
+    if (num_to_add < 1)
+        num_to_add = 1;
+    if (num_to_add > pProto->GetMaxStackSize())
+        num_to_add = pProto->GetMaxStackSize();
+
+    // init items_count to 1, since 1 item will be created regardless of specialization
+    int items_count=1;
+    // the chance to create additional items
+    float additionalCreateChance=0.0f;
+    // the maximum number of created additional items
+    uint8 additionalMaxNum=0;
+    // get the chance and maximum number for creating extra items
+    if (canCreateExtraItems(player, m_spellInfo->Id, additionalCreateChance, additionalMaxNum))
+    {
+        // roll with this chance till we roll not to create or we create the max num
+        while (roll_chance_f(additionalCreateChance) && items_count <= additionalMaxNum)
+            ++items_count;
+    }
+
+    // really will be created more items
+    num_to_add *= items_count;
+
+    // can the player store the new item?
+    ItemPosCountVec dest;
+    uint32 no_space = 0;
+    uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, num_to_add, &no_space);
+    if (msg != EQUIP_ERR_OK)
+    {
+        // convert to possible store amount
+        if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+            num_to_add -= no_space;
+        else
+        {
+            // if not created by another reason from full inventory or unique items amount limitation
+            player->SendEquipError(msg, NULL, NULL, newitemid);
+            return;
+        }
+    }
+
+    if (num_to_add)
+    {
+        // create the new item and store it
+        Item* pItem = player->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+
+        // was it successful? return error if not
+        if (!pItem)
+        {
+            player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+            return;
+        }
+
+        // set the "Crafted by ..." property of the item
+        if (pItem->GetProto()->Class != ITEM_CLASS_CONSUMABLE && pItem->GetProto()->Class != ITEM_CLASS_QUEST && newitemid != 6265 && newitemid != 6948)
+            pItem->SetUInt32Value(ITEM_FIELD_CREATOR, player->GetGUIDLow());
+
+        // send info to the client
+        if (pItem)
+            player->SendNewItem(pItem, num_to_add, true, bgType == 0);
+
+        // we succeeded in creating at least one item, so a levelup is possible
+        if (bgType == 0)
+            player->UpdateCraftSkill(m_spellInfo->Id);
+    }
+
+/*
+    // for battleground marks send by mail if not add all expected
+    if (no_space > 0 && bgType)
+    {
+        if (Battleground* bg = sBattlegroundMgr.GetBattlegroundTemplate(BattlegroundTypeId(bgType)))
+            bg->SendRewardMarkByMail(player, newitemid, no_space);
+    }
+*/
+}
+
+void Spell::EffectCreateItem(SpellEffIndex effIndex)
+{
+    DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
+    ExecuteLogEffectCreateItem(effIndex, m_spellInfo->EffectItemType[effIndex]);
+}
+
+void Spell::EffectCreateItem2(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player* player = (Player*)m_caster;
+
+    uint32 item_id = m_spellInfo->EffectItemType[effIndex];
+
+    if (item_id)
+        DoCreateItem(effIndex, item_id);
+
+    // special case: fake item replaced by generate using spell_loot_template
+    if (IsLootCraftingSpell(m_spellInfo))
+    {
+        if (item_id)
+        {
+            if (!player->HasItemCount(item_id, 1))
+                return;
+
+            // remove reagent
+            uint32 count = 1;
+            player->DestroyItemCount(item_id, count, true);
+
+            // create some random items
+            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
+        }
+        else
+            player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);    // create some random items
+    }
+    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
+}
+
+void Spell::EffectCreateRandomItem(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player* player = (Player*)m_caster;
+
+    // create some random items
+    player->AutoStoreLoot(m_spellInfo->Id, LootTemplates_Spell);
+    // TODO: ExecuteLogEffectCreateItem(i, m_spellInfo->EffectItemType[i]);
+}
+
+void Spell::EffectPersistentAA(SpellEffIndex effIndex)
+{
+    if (!m_spellAura)
+    {
+        float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+        if (Player* modOwner = m_originalCaster->GetSpellModOwner())
+            modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RADIUS, radius);
+
+        Unit *caster = m_caster->GetEntry() == WORLD_TRIGGER ? m_originalCaster : m_caster;
+        // Caster not in world, might be spell triggered from aura removal
+        if (!caster->IsInWorld())
+            return;
+        DynamicObject* dynObj = new DynamicObject;
+        if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), caster, m_spellInfo->Id, m_targets.m_dstPos, radius, false))
+        {
+            delete dynObj;
+            return;
+        }
+        caster->AddDynObject(dynObj);
+        dynObj->GetMap()->Add(dynObj);
+
+        if (Aura * aura = Aura::TryCreate(m_spellInfo, dynObj, caster, &m_spellValue->EffectBasePoints[0]))
+            m_spellAura = aura;
+        else
+        {
+            ASSERT(false);
+            return;
+        }
+        m_spellAura->_RegisterForTargets();
+    }
+    ASSERT(m_spellAura->GetDynobjOwner());
+    m_spellAura->_ApplyEffectForTargets(effIndex);
+}
+
+void Spell::EffectEnergize(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (!unitTarget->isAlive())
+        return;
+
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    // Some level depends spells
+    int level_multiplier = 0;
+    int level_diff = 0;
+    switch (m_spellInfo->Id)
+    {
+        case 9512:                                          // Restore Energy
+            level_diff = m_caster->getLevel() - 40;
+            level_multiplier = 2;
+            break;
+        case 24571:                                         // Blood Fury
+            level_diff = m_caster->getLevel() - 60;
+            level_multiplier = 10;
+            break;
+        case 24532:                                         // Burst of Energy
+            level_diff = m_caster->getLevel() - 60;
+            level_multiplier = 4;
+            break;
+        case 31930:                                         // Judgements of the Wise
+        case 63375:                                         // Improved Stormstrike
+        case 68082:                                         // Glyph of Seal of Command
+            damage = damage * unitTarget->GetCreateMana() / 100;
+            break;
+        case 48542:                                         // Revitalize
+            damage = damage * unitTarget->GetMaxPower(power) / 100;
+            break;
+        default:
+            break;
+    }
+
+    if (level_diff > 0)
+        damage -= level_multiplier * level_diff;
+
+    if (damage < 0)
+        return;
+
+    if (unitTarget->GetMaxPower(power) == 0)
+        return;
+
+    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, damage, power);
+
+    // Mad Alchemist's Potion
+    if (m_spellInfo->Id == 45051)
+    {
+        // find elixirs on target
+        bool guardianFound = false;
+        bool battleFound = false;
+        Unit::AuraApplicationMap& Auras = unitTarget->GetAppliedAuras();
+        for (Unit::AuraApplicationMap::iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+        {
+            uint32 spell_id = itr->second->GetBase()->GetId();
+            if (!guardianFound)
+                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_GUARDIAN))
+                    guardianFound = true;
+            if (!battleFound)
+                if (sSpellMgr.IsSpellMemberOfSpellGroup(spell_id, SPELL_GROUP_ELIXIR_BATTLE))
+                    battleFound = true;
+            if (battleFound && guardianFound)
+                break;
+        }
+
+        // get all available elixirs by mask and spell level
+        std::set<uint32> avalibleElixirs;
+        if (!guardianFound)
+            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_GUARDIAN, avalibleElixirs);
+        if (!battleFound)
+            sSpellMgr.GetSetOfSpellsInSpellGroup(SPELL_GROUP_ELIXIR_BATTLE, avalibleElixirs);
+        for (std::set<uint32>::iterator itr = avalibleElixirs.begin(); itr != avalibleElixirs.end() ;)
+        {
+            SpellEntry const *spellInfo = sSpellStore.LookupEntry(*itr);
+            if (spellInfo->spellLevel < m_spellInfo->spellLevel || spellInfo->spellLevel > unitTarget->getLevel())
+                avalibleElixirs.erase(itr++);
+            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_SHATTRATH))
+                avalibleElixirs.erase(itr++);
+            else if (sSpellMgr.IsSpellMemberOfSpellGroup(*itr, SPELL_GROUP_ELIXIR_UNSTABLE))
+                avalibleElixirs.erase(itr++);
+            else
+                ++itr;
+        }
+
+        if (!avalibleElixirs.empty())
+        {
+            // cast random elixir on target
+            uint32 rand_spell = urand(0,avalibleElixirs.size()-1);
+            std::set<uint32>::iterator itr = avalibleElixirs.begin();
+            std::advance(itr, rand_spell);
+            m_caster->CastSpell(unitTarget,*itr,true,m_CastItem);
+        }
+    }
+}
+
+void Spell::EffectEnergizePct(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (!unitTarget->isAlive())
+        return;
+
+    if (m_spellInfo->EffectMiscValue[effIndex] < 0 || m_spellInfo->EffectMiscValue[effIndex] >= int8(MAX_POWERS))
+        return;
+
+    Powers power = Powers(m_spellInfo->EffectMiscValue[effIndex]);
+
+    uint32 maxPower = unitTarget->GetMaxPower(power);
+    if (maxPower == 0)
+        return;
+
+    uint32 gain = damage * maxPower / 100;
+    m_caster->EnergizeBySpell(unitTarget, m_spellInfo->Id, gain, power);
+}
+
+void Spell::SendLoot(uint64 guid, LootType loottype)
+{
+    Player* player = (Player*)m_caster;
+    if (!player)
+        return;
+
+    if (gameObjTarget)
+    {
+        if (sScriptMgr.OnGossipHello(player, gameObjTarget))
+            return;
+
+        switch (gameObjTarget->GetGoType())
+        {
+            case GAMEOBJECT_TYPE_DOOR:
+            case GAMEOBJECT_TYPE_BUTTON:
+                gameObjTarget->UseDoorOrButton();
+                player->GetMap()->ScriptsStart(sGameObjectScripts, gameObjTarget->GetDBTableGUIDLow(), player, gameObjTarget);
+                return;
+
+            case GAMEOBJECT_TYPE_QUESTGIVER:
+                // start or end quest
+                player->PrepareQuestMenu(guid);
+                player->SendPreparedQuest(guid);
+                return;
+
+            case GAMEOBJECT_TYPE_SPELL_FOCUS:
+                // triggering linked GO
+                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->spellFocus.linkedTrapId)
+                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
+                return;
+
+            case GAMEOBJECT_TYPE_GOOBER:
+                gameObjTarget->Use(m_caster);
+                return;
+
+            case GAMEOBJECT_TYPE_CHEST:
+                // TODO: possible must be moved to loot release (in different from linked triggering)
+                if (gameObjTarget->GetGOInfo()->chest.eventId)
+                {
+                    sLog.outDebug("Chest ScriptStart id %u for GO %u", gameObjTarget->GetGOInfo()->chest.eventId,gameObjTarget->GetDBTableGUIDLow());
+                    player->GetMap()->ScriptsStart(sEventScripts, gameObjTarget->GetGOInfo()->chest.eventId, player, gameObjTarget);
+                }
+
+                // triggering linked GO
+                if (uint32 trapEntry = gameObjTarget->GetGOInfo()->chest.linkedTrapId)
+                    gameObjTarget->TriggeringLinkedGameObject(trapEntry,m_caster);
+
+                // Don't return, let loots been taken
+            default:
+                break;
+        }
+    }
+
+    // Send loot
+    player->SendLoot(guid, loottype);
+}
+
+void Spell::EffectOpenLock(SpellEffIndex effIndex)
+{
+    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
+    {
+        sLog.outDebug("WORLD: Open Lock - No Player Caster!");
+        return;
+    }
+
+    Player* player = (Player*)m_caster;
+
+    uint32 lockId = 0;
+    uint64 guid = 0;
+
+    // Get lockId
+    if (gameObjTarget)
+    {
+        GameObjectInfo const* goInfo = gameObjTarget->GetGOInfo();
+        // Arathi Basin banner opening !
+        if ((goInfo->type == GAMEOBJECT_TYPE_BUTTON && goInfo->button.noDamageImmune) ||
+            (goInfo->type == GAMEOBJECT_TYPE_GOOBER && goInfo->goober.losOK))
+        {
+            //CanUseBattlegroundObject() already called in CheckCast()
+            // in battleground check
+            if (Battleground *bg = player->GetBattleground())
+          {
+        bg->EventPlayerClickedOnFlag(player, gameObjTarget);
+        return;
+          }
+        }
+        else if (goInfo->type == GAMEOBJECT_TYPE_FLAGSTAND)
+        {
+            //CanUseBattlegroundObject() already called in CheckCast()
+            // in battleground check
+            if (Battleground *bg = player->GetBattleground())
+            {
+                if (bg->GetTypeID(true) == BATTLEGROUND_EY)
+                    bg->EventPlayerClickedOnFlag(player, gameObjTarget);
+                return;
+            }
+        }else if (m_spellInfo->Id == 1842 && gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_TRAP && gameObjTarget->GetOwner())
+        {
+            gameObjTarget->SetLootState(GO_JUST_DEACTIVATED);
+            return;
+        }
+        // TODO: Add script for spell 41920 - Filling, becouse server it freze when use this spell
+        // handle outdoor pvp object opening, return true if go was registered for handling
+        // these objects must have been spawned by outdoorpvp!
+        else if (gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
+            return;
+        lockId = goInfo->GetLockId();
+        guid = gameObjTarget->GetGUID();
+    }
+    else if (itemTarget)
+    {
+        lockId = itemTarget->GetProto()->LockID;
+        guid = itemTarget->GetGUID();
+    }
+    else
+    {
+        sLog.outDebug("WORLD: Open Lock - No GameObject/Item Target!");
+        return;
+    }
+
+    SkillType skillId = SKILL_NONE;
+    int32 reqSkillValue = 0;
+    int32 skillValue;
+
+    SpellCastResult res = CanOpenLock(effIndex, lockId, skillId, reqSkillValue, skillValue);
+    if (res != SPELL_CAST_OK)
+    {
+        SendCastResult(res);
+        return;
+    }
+
+    if (gameObjTarget)
+        SendLoot(guid, LOOT_SKINNING);
+    else
+        itemTarget->SetFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_UNLOCKED);
+
+    // not allow use skill grow at item base open
+    if (!m_CastItem && skillId != SKILL_NONE)
+    {
+        // update skill if really known
+        if (uint32 pureSkillValue = player->GetPureSkillValue(skillId))
+        {
+            if (gameObjTarget)
+            {
+                // Allow one skill-up until respawned
+                if (!gameObjTarget->IsInSkillupList(player->GetGUIDLow()) &&
+                    player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue))
+                    gameObjTarget->AddToSkillupList(player->GetGUIDLow());
+            }
+            else if (itemTarget)
+            {
+                // Do one skill-up
+                player->UpdateGatherSkill(skillId, pureSkillValue, reqSkillValue);
+            }
+        }
+    }
+    ExecuteLogEffectOpenLock(effIndex, gameObjTarget ? (Object*)gameObjTarget : (Object*)itemTarget);
+}
+
+void Spell::EffectSummonChangeItem(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *player = (Player*)m_caster;
+
+    // applied only to using item
+    if (!m_CastItem)
+        return;
+
+    // ... only to item in own inventory/bank/equip_slot
+    if (m_CastItem->GetOwnerGUID() != player->GetGUID())
+        return;
+
+    uint32 newitemid = m_spellInfo->EffectItemType[effIndex];
+    if (!newitemid)
+        return;
+
+    uint16 pos = m_CastItem->GetPos();
+
+    Item *pNewItem = Item::CreateItem(newitemid, 1, player);
+    if (!pNewItem)
+        return;
+
+    for (uint8 j = PERM_ENCHANTMENT_SLOT; j <= TEMP_ENCHANTMENT_SLOT; ++j)
+        if (m_CastItem->GetEnchantmentId(EnchantmentSlot(j)))
+            pNewItem->SetEnchantment(EnchantmentSlot(j), m_CastItem->GetEnchantmentId(EnchantmentSlot(j)), m_CastItem->GetEnchantmentDuration(EnchantmentSlot(j)), m_CastItem->GetEnchantmentCharges(EnchantmentSlot(j)));
+
+    if (m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) < m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY))
+    {
+        double loosePercent = 1 - m_CastItem->GetUInt32Value(ITEM_FIELD_DURABILITY) / double(m_CastItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY));
+        player->DurabilityLoss(pNewItem, loosePercent);
+    }
+
+    if (player->IsInventoryPos(pos))
+    {
+        ItemPosCountVec dest;
+        uint8 msg = player->CanStoreItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
+        if (msg == EQUIP_ERR_OK)
+        {
+            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
+
+            // prevent crash at access and unexpected charges counting with item update queue corrupt
+            if (m_CastItem == m_targets.getItemTarget())
+                m_targets.setItemTarget(NULL);
+
+            m_CastItem = NULL;
+
+            player->StoreItem(dest, pNewItem, true);
+            return;
+        }
+    }
+    else if (player->IsBankPos(pos))
+    {
+        ItemPosCountVec dest;
+        uint8 msg = player->CanBankItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), dest, pNewItem, true);
+        if (msg == EQUIP_ERR_OK)
+        {
+            player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
+
+            // prevent crash at access and unexpected charges counting with item update queue corrupt
+            if (m_CastItem == m_targets.getItemTarget())
+                m_targets.setItemTarget(NULL);
+
+            m_CastItem = NULL;
+
+            player->BankItem(dest, pNewItem, true);
+            return;
+        }
+    }
+    else if (player->IsEquipmentPos(pos))
+    {
+        uint16 dest;
+
+        player->DestroyItem(m_CastItem->GetBagSlot(), m_CastItem->GetSlot(), true);
+
+        uint8 msg = player->CanEquipItem(m_CastItem->GetSlot(), dest, pNewItem, true);
+
+        if (msg == EQUIP_ERR_OK || msg == EQUIP_ERR_CANT_DO_RIGHT_NOW)
+        {
+            if (msg == EQUIP_ERR_CANT_DO_RIGHT_NOW) dest = EQUIPMENT_SLOT_MAINHAND;
+
+            // prevent crash at access and unexpected charges counting with item update queue corrupt
+            if (m_CastItem == m_targets.getItemTarget())
+                m_targets.setItemTarget(NULL);
+
+            m_CastItem = NULL;
+
+            player->EquipItem(dest, pNewItem, true);
+            player->AutoUnequipOffhandIfNeed();
+            return;
+        }
+    }
+
+    // fail
+    delete pNewItem;
+}
+
+void Spell::EffectProficiency(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player *p_target = (Player*)unitTarget;
+
+    uint32 subClassMask = m_spellInfo->EquippedItemSubClassMask;
+    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON && !(p_target->GetWeaponProficiency() & subClassMask))
+    {
+        p_target->AddWeaponProficiency(subClassMask);
+        p_target->SendProficiency(ITEM_CLASS_WEAPON, p_target->GetWeaponProficiency());
+    }
+    if (m_spellInfo->EquippedItemClass == ITEM_CLASS_ARMOR && !(p_target->GetArmorProficiency() & subClassMask))
+    {
+        p_target->AddArmorProficiency(subClassMask);
+        p_target->SendProficiency(ITEM_CLASS_ARMOR, p_target->GetArmorProficiency());
+    }
+}
+
+void Spell::EffectSummonType(SpellEffIndex effIndex)
+{
+    uint32 entry = m_spellInfo->EffectMiscValue[effIndex];
+    if (!entry)
+        return;
+
+    SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(m_spellInfo->EffectMiscValueB[effIndex]);
+    if (!properties)
+    {
+        sLog.outError("EffectSummonType: Unhandled summon type %u", m_spellInfo->EffectMiscValueB[effIndex]);
+        return;
+    }
+
+    if (!m_originalCaster)
+        return;
+
+    int32 duration = GetSpellDuration(m_spellInfo);
+    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
+        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
+
+    Position pos;
+    GetSummonPosition(effIndex, pos);
+
+    /*//totem must be at same Z in case swimming caster and etc.
+        if (fabs(z - m_caster->GetPositionZ()) > 5)
+            z = m_caster->GetPositionZ();
+
+    uint8 level = m_caster->getLevel();
+
+    // level of creature summoned using engineering item based at engineering skill level
+    if (m_caster->GetTypeId() == TYPEID_PLAYER && m_CastItem)
+    {
+        ItemPrototype const *proto = m_CastItem->GetProto();
+        if (proto && proto->RequiredSkill == SKILL_ENGINERING)
+        {
+            uint16 skill202 = m_caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING);
+            if (skill202)
+                level = skill202/5;
+        }
+    }*/
+
+    TempSummon *summon = NULL;
+
+    switch (properties->Category)
+    {
+        default:
+            if (properties->Flags & 512)
+            {
+                SummonGuardian(effIndex, entry, properties);
+                break;
+            }
+            switch (properties->Type)
+            {
+                case SUMMON_TYPE_PET:
+                case SUMMON_TYPE_GUARDIAN:
+                case SUMMON_TYPE_GUARDIAN2:
+                case SUMMON_TYPE_MINION:
+                    SummonGuardian(effIndex, entry, properties);
+                    break;
+                case SUMMON_TYPE_VEHICLE:
+                case SUMMON_TYPE_VEHICLE2:
+                    if (m_originalCaster)
+                        summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+                    break;
+                case SUMMON_TYPE_TOTEM:
+                {
+                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+                    if (!summon || !summon->isTotem())
+                        return;
+
+                    if (damage)                                            // if not spell info, DB values used
+                    {
+                        summon->SetMaxHealth(damage);
+                        summon->SetHealth(damage);
+                    }
+
+                    //summon->SetUInt32Value(UNIT_CREATED_BY_SPELL,m_spellInfo->Id);
+
+                    if (m_originalCaster->GetTypeId() == TYPEID_PLAYER
+                        && properties->Slot >= SUMMON_SLOT_TOTEM
+                        && properties->Slot < MAX_TOTEM_SLOT)
+                    {
+                        // set display id depending on race
+                        uint32 displayId = m_originalCaster->GetModelForTotem(PlayerTotemType(properties->Id));
+                        summon->SetNativeDisplayId(displayId);
+                        summon->SetDisplayId(displayId);
+
+                        //summon->SendUpdateToPlayerm_originalCaster->ToPlayer();
+                        WorldPacket data(SMSG_TOTEM_CREATED, 1+8+4+4);
+                        data << uint8(properties->Slot-1);
+                        data << uint64(m_originalCaster->GetGUID());
+                        data << uint32(duration);
+                        data << uint32(m_spellInfo->Id);
+                        m_originalCaster->ToPlayer()->SendDirectMessage(&data);
+                    }
+                    break;
+                }
+                case SUMMON_TYPE_MINIPET:
+                {
+                    summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+                    if (!summon || !summon->HasUnitTypeMask(UNIT_MASK_MINION))
+                        return;
+
+                    //summon->InitPetCreateSpells();                         // e.g. disgusting oozeling has a create spell as summon...
+                    summon->SelectLevel(summon->GetCreatureInfo());       // some summoned creaters have different from 1 DB data for level/hp
+                    summon->SetUInt32Value(UNIT_NPC_FLAGS, summon->GetCreatureInfo()->npcflag);
+
+                    summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+                    summon->AI()->EnterEvadeMode();
+
+                    std::string name = m_originalCaster->GetName();
+                    name.append(petTypeSuffix[3]);
+                    summon->SetName(name);
+                    break;
+                }
+                default:
+                {
+                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+
+                    uint32 amount = damage > 0 ? damage : 1;
+                    if (m_spellInfo->Id == 18662) // Curse of Doom
+                        amount = 1;
+
+                    for (uint32 count = 0; count < amount; ++count)
+                    {
+                        GetSummonPosition(effIndex, pos, radius, count);
+
+                        TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
+
+                        summon = m_originalCaster->SummonCreature(entry, pos, summonType, duration);
+                        if (!summon)
+                            continue;
+                        if (properties->Category == SUMMON_CATEGORY_ALLY)
+                        {
+                            summon->SetUInt64Value(UNIT_FIELD_SUMMONEDBY, m_originalCaster->GetGUID());
+                            summon->setFaction(m_originalCaster->getFaction());
+                            summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+                        }
+                        ExecuteLogEffectSummonObject(effIndex, summon);
+                    }
+                    return;
+                }
+            }//switch
+            break;
+        case SUMMON_CATEGORY_PET:
+            SummonGuardian(effIndex, entry, properties);
+            break;
+        case SUMMON_CATEGORY_PUPPET:
+            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_originalCaster);
+            break;
+        case SUMMON_CATEGORY_VEHICLE:
+        {
+            float x, y, z;
+            m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+            summon = m_caster->GetMap()->SummonCreature(entry, pos, properties, duration, m_caster);
+            if (!summon || !summon->IsVehicle())
+                return;
+
+            if (m_spellInfo->EffectBasePoints[effIndex])
+            {
+                SpellEntry const *spellProto = sSpellStore.LookupEntry(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
+                if (spellProto)
+                    m_caster->CastSpell(summon, spellProto, true);
+            }
+
+            m_caster->EnterVehicle(summon->GetVehicleKit());
+            break;
+        }
+    }
+
+    if (summon)
+    {
+        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+        summon->SetCreatorGUID(m_originalCaster->GetGUID());
+        ExecuteLogEffectSummonObject(effIndex, summon);
+    }
+}
+
+void Spell::EffectLearnSpell(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+    {
+        if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            EffectLearnPetSpell(effIndex);
+
+        return;
+    }
+
+    Player *player = (Player*)unitTarget;
+
+    uint32 spellToLearn = (m_spellInfo->Id == 483 || m_spellInfo->Id == 55884) ? damage : m_spellInfo->EffectTriggerSpell[effIndex];
+    player->learnSpell(spellToLearn, false);
+
+    sLog.outDebug("Spell: Player %u has learned spell %u from NpcGUID=%u", player->GetGUIDLow(), spellToLearn, m_caster->GetGUIDLow());
+}
+
+typedef std::list< std::pair<uint32, uint64> > DispelList;
+typedef std::list< std::pair<Aura *, uint8> > DispelChargesList;
+void Spell::EffectDispel(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    DispelChargesList dispel_list;
+
+    // Create dispel mask by dispel type
+    uint32 dispel_type = m_spellInfo->EffectMiscValue[effIndex];
+    uint32 dispelMask  = GetDispellMask(DispelType(dispel_type));
+
+    // we should not be able to dispel diseases if the target is affected by unholy blight
+    if (dispelMask & (1 << DISPEL_DISEASE) && unitTarget->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura * aura = itr->second;
+        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
+        {
+            if (aura->GetSpellProto()->Dispel == DISPEL_MAGIC)
+            {
+                bool positive = aurApp->IsPositive() ? (!(aura->GetSpellProto()->AttributesEx & SPELL_ATTR_EX_NEGATIVE)) : false;
+
+                // do not remove positive auras if friendly target
+                //               negative auras if non-friendly target
+                if (positive == unitTarget->IsFriendlyTo(m_caster))
+                    continue;
+            }
+
+            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
+            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
+            // Polymorph instead of 1 / (5 + 1) -> 16%.
+            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
+            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispel_list.push_back(std::make_pair(aura, charges));
+        }
+    }
+
+    if (dispel_list.empty())
+        return;
+
+    // Ok if exist some buffs for dispel try dispel it
+    uint32 failCount = 0;
+    DispelList success_list;
+    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
+    // dispel N = damage buffs (or while exist buffs for dispel)
+    for (int32 count = 0; count < damage && !dispel_list.empty();)
+    {
+        // Random select buff for dispel
+        DispelChargesList::iterator itr = dispel_list.begin();
+        std::advance(itr, urand(0, dispel_list.size() - 1));
+
+        bool success = false;
+        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
+        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
+        {
+            dispel_list.erase(itr);
+            continue;
+        }
+        else
+        {
+            if (success)
+            {
+                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
+                --itr->second;
+                if (itr->second <= 0)
+                    dispel_list.erase(itr);
+            }
+            else
+            {
+                if (!failCount)
+                {
+                    // Failed to dispell
+                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
+                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
+                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
+                }
+                ++failCount;
+                dataFail << uint32(itr->first->GetId());                         // Spell Id
+            }
+            ++count;
+        }
+    }
+
+    if (failCount)
+        m_caster->SendMessageToSet(&dataFail, true);
+
+    if (success_list.empty())
+        return;
+
+    WorldPacket dataSuccess(SMSG_SPELLDISPELLOG, 8+8+4+1+4+damage*5);
+    // Send packet header
+    dataSuccess.append(unitTarget->GetPackGUID());         // Victim GUID
+    dataSuccess.append(m_caster->GetPackGUID());           // Caster GUID
+    dataSuccess << uint32(m_spellInfo->Id);                // dispel spell id
+    dataSuccess << uint8(0);                               // not used
+    dataSuccess << uint32(success_list.size());            // count
+    for (DispelList::iterator itr = success_list.begin(); itr != success_list.end(); ++itr)
+    {
+        // Send dispelled spell info
+        dataSuccess << uint32(itr->first);              // Spell Id
+        dataSuccess << uint8(0);                        // 0 - dispelled !=0 cleansed
+        unitTarget->RemoveAurasDueToSpellByDispel(itr->first, itr->second, m_caster);
+    }
+    m_caster->SendMessageToSet(&dataSuccess, true);
+
+    // On success dispel
+    // Devour Magic
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK && m_spellInfo->Category == SPELLCATEGORY_DEVOUR_MAGIC)
+    {
+        int32 heal_amount = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
+        m_caster->CastCustomSpell(m_caster, 19658, &heal_amount, NULL, NULL, true);
+    }
+}
+
+void Spell::EffectDualWield(SpellEffIndex /*effIndex*/)
+{
+    unitTarget->SetCanDualWield(true);
+    if (unitTarget->GetTypeId() == TYPEID_UNIT)
+        unitTarget->ToCreature()->UpdateDamagePhysical(OFF_ATTACK);
+}
+
+void Spell::EffectPull(SpellEffIndex /*effIndex*/)
+{
+    // TODO: create a proper pull towards distract spell center for distract
+    sLog.outDebug("WORLD: Spell Effect DUMMY");
+}
+
+void Spell::EffectDistract(SpellEffIndex /*effIndex*/)
+{
+    // Check for possible target
+    if (!unitTarget || unitTarget->isInCombat())
+        return;
+
+    // target must be OK to do this
+    if (unitTarget->hasUnitState(UNIT_STAT_CONFUSED | UNIT_STAT_STUNNED | UNIT_STAT_FLEEING))
+        return;
+
+    float angle = unitTarget->GetAngle(&m_targets.m_dstPos);
+
+    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
+    {
+        // For players just turn them
+        unitTarget->ToPlayer()->SetPosition(unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), angle, false);
+        unitTarget->ToPlayer()->SendTeleportAckPacket();
+    }
+    else
+    {
+        // Set creature Distracted, Stop it, And turn it
+        unitTarget->SetOrientation(angle);
+        unitTarget->StopMoving();
+        unitTarget->GetMotionMaster()->MoveDistract(damage * IN_MILLISECONDS);
+    }
+}
+
+void Spell::EffectPickPocket(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // victim must be creature and attackable
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT || m_caster->IsFriendlyTo(unitTarget))
+        return;
+
+    // victim have to be alive and humanoid or undead
+    if (unitTarget->isAlive() && (unitTarget->GetCreatureTypeMask() &CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0)
+        m_caster->ToPlayer()->SendLoot(unitTarget->GetGUID(),LOOT_PICKPOCKETING);
+}
+
+void Spell::EffectAddFarsight(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+    int32 duration = GetSpellDuration(m_spellInfo);
+    // Caster not in world, might be spell triggered from aura removal
+    if (!m_caster->IsInWorld())
+        return;
+    DynamicObject* dynObj = new DynamicObject;
+    if (!dynObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_DYNAMICOBJECT), m_caster, m_spellInfo->Id, m_targets.m_dstPos, radius, true))
+    {
+        delete dynObj;
+        return;
+    }
+    dynObj->SetDuration(duration);
+    dynObj->SetUInt32Value(DYNAMICOBJECT_BYTES, 0x80000002);
+    m_caster->AddDynObject(dynObj);
+
+    dynObj->setActive(true);    //must before add to map to be put in world container
+    dynObj->GetMap()->Add(dynObj); //grid will also be loaded
+
+    // Need to update visibility of object for client to accept farsight guid
+    m_caster->ToPlayer()->SetViewpoint(dynObj, true);
+    //m_caster->ToPlayer()->UpdateVisibilityOf(dynObj);
+}
+
+void Spell::EffectTeleUnitsFaceCaster(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    if (unitTarget->isInFlight())
+        return;
+
+    float dis = (float)m_caster->GetSpellRadiusForTarget(unitTarget, sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+
+    float fx,fy,fz;
+    m_caster->GetClosePoint(fx,fy,fz,unitTarget->GetObjectSize(),dis);
+
+    unitTarget->NearTeleportTo(fx,fy,fz,-m_caster->GetOrientation(),unitTarget == m_caster);
+}
+
+void Spell::EffectLearnSkill(SpellEffIndex effIndex)
+{
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (damage < 0)
+        return;
+
+    uint32 skillid =  m_spellInfo->EffectMiscValue[effIndex];
+    uint16 skillval = unitTarget->ToPlayer()->GetPureSkillValue(skillid);
+    unitTarget->ToPlayer()->SetSkill(skillid, SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex), skillval?skillval:1, damage*75);
+}
+
+void Spell::EffectAddHonor(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // not scale value for item based reward (/10 value expected)
+    if (m_CastItem)
+    {
+        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage/10);
+        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %d honor points (item %u) for player: %u", m_spellInfo->Id, damage/10, m_CastItem->GetEntry(),unitTarget->ToPlayer()->GetGUIDLow());
+        return;
+    }
+
+    // do not allow to add too many honor for player (50 * 21) = 1040 at level 70, or (50 * 31) = 1550 at level 80
+    if (damage <= 50)
+    {
+        uint32 honor_reward = Trinity::Honor::hk_honor_at_level(unitTarget->getLevel(), damage);
+        unitTarget->ToPlayer()->RewardHonor(NULL, 1, honor_reward);
+        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (scale) to player: %u", m_spellInfo->Id, honor_reward, unitTarget->ToPlayer()->GetGUIDLow());
+    }
+    else
+    {
+        //maybe we have correct honor_gain in damage already
+        unitTarget->ToPlayer()->RewardHonor(NULL, 1, damage);
+        sLog.outDebug("SpellEffect::AddHonor (spell_id %u) rewards %u honor points (non scale) for player: %u", m_spellInfo->Id, damage, unitTarget->ToPlayer()->GetGUIDLow());
+    }
+}
+
+void Spell::EffectTradeSkill(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    // uint32 skillid =  m_spellInfo->EffectMiscValue[i];
+    // uint16 skillmax = unitTarget->ToPlayer()->(skillid);
+    // unitTarget->ToPlayer()->SetSkill(skillid,skillval?skillval:1,skillmax+75);
+}
+
+void Spell::EffectEnchantItemPerm(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!itemTarget)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+
+    // Handle vellums
+    if (itemTarget->IsWeaponVellum() || itemTarget->IsArmorVellum())
+    {
+        // destroy one vellum from stack
+        uint32 count = 1;
+        p_caster->DestroyItemCount(itemTarget,count,true);
+        unitTarget=p_caster;
+        // and add a scroll
+        DoCreateItem(effIndex,m_spellInfo->EffectItemType[effIndex]);
+        itemTarget=NULL;
+        m_targets.setItemTarget(NULL);
+    }
+    else
+    {
+        // do not increase skill if vellum used
+        if (!(m_CastItem && m_CastItem->GetProto()->Flags & ITEM_PROTO_FLAG_TRIGGERED_CAST))
+            p_caster->UpdateCraftSkill(m_spellInfo->Id);
+
+        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+        if (!enchant_id)
+            return;
+
+        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            return;
+        
+        // item can be in trade slot and have owner diff. from caster
+        Player* item_owner = itemTarget->GetOwner();
+        if (!item_owner)
+            return;
+        
+        // Prevent applying enchanements with Use: spell on items that already have a Use: effect, this is usually blocked from client side and 
+        // can only be bypassed with memory manipulation.
+        for (int s = 0; s < 3; ++s) {
+            if (pEnchant->type[s] == ITEM_ENCHANTMENT_TYPE_USE_SPELL) {
+                for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i) {
+                    ItemPrototype const *proto = itemTarget->GetProto();
+                    if (proto->Spells[i].SpellId && proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE) {
+                        sLog.outError("Exploiting attempt: Player %s(GUID: %u) tried to apply an enchanement with Use: spell on an item that already has a Use: effect,"
+                                      " this should be blocked from client side.", p_caster->GetName(), p_caster->GetGUIDLow());
+                        return;
+                    }
+                }
+            }
+        }
+
+        if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
+        {
+            sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
+                p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
+                itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
+                item_owner->GetName(),item_owner->GetSession()->GetAccountId());
+        }
+
+        // remove old enchanting before applying new if equipped
+        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,false);
+
+        itemTarget->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchant_id, 0, 0);
+
+        // add new enchanting if equipped
+        item_owner->ApplyEnchantment(itemTarget,PERM_ENCHANTMENT_SLOT,true);
+
+        itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
+    }
+}
+
+void Spell::EffectEnchantItemPrismatic(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!itemTarget)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+
+    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    // support only enchantings with add socket in this slot
+    {
+        bool add_socket = false;
+        for (uint8 i = 0; i < MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+        {
+            if (pEnchant->type[i] == ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET)
+            {
+                add_socket = true;
+                break;
+            }
+        }
+        if (!add_socket)
+        {
+            sLog.outError("Spell::EffectEnchantItemPrismatic: attempt apply enchant spell %u with SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC (%u) but without ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET (%u), not suppoted yet.",
+                m_spellInfo->Id,SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC,ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET);
+            return;
+        }
+    }
+
+    // item can be in trade slot and have owner diff. from caster
+    Player* item_owner = itemTarget->GetOwner();
+    if (!item_owner)
+        return;
+
+    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
+    {
+        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(perm): %s (Entry: %d) for player: %s (Account: %u)",
+            p_caster->GetName(),p_caster->GetSession()->GetAccountId(),
+            itemTarget->GetProto()->Name1,itemTarget->GetEntry(),
+            item_owner->GetName(),item_owner->GetSession()->GetAccountId());
+    }
+
+    // remove old enchanting before applying new if equipped
+    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,false);
+
+    itemTarget->SetEnchantment(PRISMATIC_ENCHANTMENT_SLOT, enchant_id, 0, 0);
+
+    // add new enchanting if equipped
+    item_owner->ApplyEnchantment(itemTarget,PRISMATIC_ENCHANTMENT_SLOT,true);
+
+    itemTarget->SetSoulboundTradeable(NULL, item_owner, false);
+}
+
+void Spell::EffectEnchantItemTmp(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+
+    // Rockbiter Weapon apply to both weapon
+    if (!itemTarget)
+    return;
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[0] & 0x400000)
+    {
+        uint32 spell_id = 0;
+
+        // enchanting spell selected by calculated damage-per-sec stored in Effect[1] base value
+        // Note: damage calculated (correctly) with rounding int32(float(v)) but
+        // RW enchantments applied damage int32(float(v)+0.5), this create  0..1 difference sometime
+        switch(damage)
+        {
+            // Rank 1
+            case  2: spell_id = 36744; break;               //  0% [ 7% == 2, 14% == 2, 20% == 2]
+            // Rank 2
+            case  4: spell_id = 36753; break;               //  0% [ 7% == 4, 14% == 4]
+            case  5: spell_id = 36751; break;               // 20%
+            // Rank 3
+            case  6: spell_id = 36754; break;               //  0% [ 7% == 6, 14% == 6]
+            case  7: spell_id = 36755; break;               // 20%
+            // Rank 4
+            case  9: spell_id = 36761; break;               //  0% [ 7% == 6]
+            case 10: spell_id = 36758; break;               // 14%
+            case 11: spell_id = 36760; break;               // 20%
+            default:
+                sLog.outError("Spell::EffectEnchantItemTmp: Damage %u not handled in S'RW",damage);
+                return;
+        }
+
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
+        if (!spellInfo)
+        {
+            sLog.outError("Spell::EffectEnchantItemTmp: unknown spell id %i", spell_id);
+            return;
+
+        }
+
+        for (int j = BASE_ATTACK; j <= OFF_ATTACK; ++j)
+        {
+            if (Item* item = p_caster->GetWeaponForAttack(WeaponAttackType(j)))
+            {
+                if (item->IsFitToSpellRequirements(m_spellInfo))
+                {
+                    Spell *spell = new Spell(m_caster, spellInfo, true);
+                    SpellCastTargets targets;
+                    targets.setItemTarget(item);
+                    spell->prepare(&targets);
+                }
+            }
+        }
+        return;
+    }
+    if (!itemTarget)
+        return;
+
+    uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    if (!enchant_id)
+    {
+        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have 0 as enchanting id",m_spellInfo->Id,effIndex);
+        return;
+    }
+
+    SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+    {
+        sLog.outError("Spell %u Effect %u (SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY) have not existed enchanting id %u ",m_spellInfo->Id,effIndex,enchant_id);
+        return;
+    }
+
+    // select enchantment duration
+    uint32 duration;
+
+    // rogue family enchantments exception by duration
+    if (m_spellInfo->Id == 38615)
+        duration = 1800;                                    // 30 mins
+    // other rogue family enchantments always 1 hour (some have spell damage=0, but some have wrong data in EffBasePoints)
+    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE)
+        duration = 3600;                                    // 1 hour
+    // shaman family enchantments
+    else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN)
+        duration = 1800;                                    // 30 mins
+    // other cases with this SpellVisual already selected
+    else if (m_spellInfo->SpellVisual[0] == 215)
+        duration = 1800;                                    // 30 mins
+    // some fishing pole bonuses except Glow Worm which lasts full hour
+    else if (m_spellInfo->SpellVisual[0] == 563 && m_spellInfo->Id != 64401)
+        duration = 600;                                     // 10 mins
+    // shaman rockbiter enchantments
+    else if (m_spellInfo->SpellVisual[0] == 0)
+        duration = 1800;                                    // 30 mins
+    else if (m_spellInfo->Id == 29702)
+        duration = 300;                                     // 5 mins
+    else if (m_spellInfo->Id == 37360)
+        duration = 300;                                     // 5 mins
+    // default case
+    else
+        duration = 3600;                                    // 1 hour
+
+    // item can be in trade slot and have owner diff. from caster
+    Player* item_owner = itemTarget->GetOwner();
+    if (!item_owner)
+        return;
+
+    if (item_owner != p_caster && p_caster->GetSession()->GetSecurity() > SEC_PLAYER && sWorld.getBoolConfig(CONFIG_GM_LOG_TRADE))
+    {
+        sLog.outCommand(p_caster->GetSession()->GetAccountId(),"GM %s (Account: %u) enchanting(temp): %s (Entry: %d) for player: %s (Account: %u)",
+            p_caster->GetName(), p_caster->GetSession()->GetAccountId(),
+            itemTarget->GetProto()->Name1, itemTarget->GetEntry(),
+            item_owner->GetName(), item_owner->GetSession()->GetAccountId());
+    }
+
+    // remove old enchanting before applying new if equipped
+    item_owner->ApplyEnchantment(itemTarget,TEMP_ENCHANTMENT_SLOT, false);
+
+    itemTarget->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, duration * 1000, 0);
+
+    // add new enchanting if equipped
+    item_owner->ApplyEnchantment(itemTarget, TEMP_ENCHANTMENT_SLOT, true);
+}
+
+void Spell::EffectTameCreature(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetPetGUID())
+        return;
+
+    if (!unitTarget)
+        return;
+
+    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+        return;
+
+    Creature* creatureTarget = unitTarget->ToCreature();
+
+    if (creatureTarget->isPet())
+        return;
+
+    if (m_caster->getClass() != CLASS_HUNTER)
+        return;
+
+    // cast finish successfully
+    //SendChannelUpdate(0);
+    finish();
+
+    Pet* pet = m_caster->CreateTamedPetFrom(creatureTarget,m_spellInfo->Id);
+    if (!pet)                                               // in very specific state like near world end/etc.
+        return;
+
+    // "kill" original creature
+    creatureTarget->ForcedDespawn();
+
+    uint8 level = (creatureTarget->getLevel() < (m_caster->getLevel() - 5)) ? (m_caster->getLevel() - 5) : creatureTarget->getLevel();
+
+    // prepare visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level - 1);
+
+    // add to world
+    pet->GetMap()->Add(pet->ToCreature());
+
+    // visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, level);
+
+    // caster have pet now
+    m_caster->SetMinion(pet, true);
+
+    pet->InitTalentForLevel();
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        m_caster->ToPlayer()->PetSpellInitialize();
+    }
+}
+
+void Spell::EffectSummonPet(SpellEffIndex effIndex)
+{
+    Player *owner = NULL;
+    if (m_originalCaster)
+    {
+        if (m_originalCaster->GetTypeId() == TYPEID_PLAYER)
+            owner = (Player*)m_originalCaster;
+        else if (m_originalCaster->ToCreature()->isTotem())
+            owner = m_originalCaster->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    uint32 petentry = m_spellInfo->EffectMiscValue[effIndex];
+
+    if (!owner)
+    {
+        SummonPropertiesEntry const *properties = sSummonPropertiesStore.LookupEntry(67);
+        if (properties)
+            SummonGuardian(effIndex, petentry, properties);
+        return;
+    }
+
+    Pet *OldSummon = owner->GetPet();
+
+    // if pet requested type already exist
+    if (OldSummon)
+    {
+        if (petentry == 0 || OldSummon->GetEntry() == petentry)
+        {
+            // pet in corpse state can't be summoned
+            if (OldSummon->isDead())
+                return;
+
+            ASSERT(OldSummon->GetMap() == owner->GetMap());
+
+            //OldSummon->GetMap()->Remove(OldSummon->ToCreature(),false);
+
+            float px, py, pz;
+            owner->GetClosePoint(px, py, pz, OldSummon->GetObjectSize());
+
+            OldSummon->NearTeleportTo(px, py, pz, OldSummon->GetOrientation());
+            //OldSummon->Relocate(px, py, pz, OldSummon->GetOrientation());
+            //OldSummon->SetMap(owner->GetMap());
+            //owner->GetMap()->Add(OldSummon->ToCreature());
+
+            if (owner->GetTypeId() == TYPEID_PLAYER && OldSummon->isControlled())
+                owner->ToPlayer()->PetSpellInitialize();
+
+            return;
+        }
+
+        if (owner->GetTypeId() == TYPEID_PLAYER)
+            owner->ToPlayer()->RemovePet(OldSummon,(OldSummon->getPetType() == HUNTER_PET ? PET_SAVE_AS_DELETED : PET_SAVE_NOT_IN_SLOT),false);
+        else
+            return;
+    }
+
+    float x, y, z;
+    owner->GetClosePoint(x, y, z, owner->GetObjectSize());
+    Pet* pet = owner->SummonPet(petentry, x, y, z, owner->GetOrientation(), SUMMON_PET, 0);
+    if (!pet)
+        return;
+
+    if (m_caster->GetTypeId() == TYPEID_UNIT)
+    {
+        if (m_caster->ToCreature()->isTotem())
+            pet->SetReactState(REACT_AGGRESSIVE);
+        else
+            pet->SetReactState(REACT_DEFENSIVE);
+    }
+
+    pet->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+
+    // generate new name for summon pet
+    std::string new_name=sObjectMgr.GeneratePetName(petentry);
+    if (!new_name.empty())
+        pet->SetName(new_name);
+
+    ExecuteLogEffectSummonObject(effIndex, pet);
+}
+
+void Spell::EffectLearnPetSpell(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)m_caster;
+
+    Pet *pet = _player->GetPet();
+    if (!pet)
+        return;
+    if (!pet->isAlive())
+        return;
+
+    SpellEntry const *learn_spellproto = sSpellStore.LookupEntry(m_spellInfo->EffectTriggerSpell[effIndex]);
+    if (!learn_spellproto)
+        return;
+
+    pet->learnSpell(learn_spellproto->Id);
+
+    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+    _player->PetSpellInitialize();
+}
+
+void Spell::EffectTaunt(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    // this effect use before aura Taunt apply for prevent taunt already attacking target
+    // for spell as marked "non effective at already attacking target"
+    if (!unitTarget || !unitTarget->CanHaveThreatList()
+        || unitTarget->getVictim() == m_caster)
+    {
+        SendCastResult(SPELL_FAILED_DONT_REPORT);
+        return;
+    }
+
+    if (m_spellInfo->Id == 62124)
+    {
+        int32 damageDone = int32(1 + m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.5f);
+        bool is_crit = m_caster->isSpellCrit(unitTarget, m_spellInfo, m_spellSchoolMask, m_attackType);
+        if (is_crit)
+            damageDone *= 2;
+        m_caster->DealDamage(unitTarget, damageDone, NULL, SPELL_DIRECT_DAMAGE, SPELL_SCHOOL_MASK_HOLY, m_spellInfo, false);
+        m_caster->SendSpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, damageDone, SPELL_SCHOOL_MASK_HOLY, 0, 0, false, false, is_crit);
+    }
+
+    // Also use this effect to set the taunter's threat to the taunted creature's highest value
+    if (unitTarget->getThreatManager().getCurrentVictim())
+    {
+        float myThreat = unitTarget->getThreatManager().getThreat(m_caster);
+        float itsThreat = unitTarget->getThreatManager().getCurrentVictim()->getThreat();
+        if (itsThreat > myThreat)
+            unitTarget->getThreatManager().addThreat(m_caster, itsThreat - myThreat);
+    }
+
+    //Set aggro victim to caster
+    if (!unitTarget->getThreatManager().getOnlineContainer().empty())
+        if (HostileReference* forcedVictim = unitTarget->getThreatManager().getOnlineContainer().getReferenceByTarget(m_caster))
+            unitTarget->getThreatManager().setCurrentVictim(forcedVictim);
+
+    if (unitTarget->ToCreature()->IsAIEnabled && !unitTarget->ToCreature()->HasReactState(REACT_PASSIVE))
+        unitTarget->ToCreature()->AI()->AttackStart(m_caster);
+}
+
+void Spell::EffectWeaponDmg(SpellEffIndex /*effIndex*/)
+{
+}
+
+void Spell::SpellDamageWeaponDmg(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (!unitTarget->isAlive())
+        return;
+
+    // multiple weapon dmg effect workaround
+    // execute only the last weapon damage
+    // and handle all effects at once
+    for (uint32 j = effIndex + 1; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        switch (m_spellInfo->Effect[j])
+        {
+            case SPELL_EFFECT_WEAPON_DAMAGE:
+            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                return;     // we must calculate only at last weapon effect
+            break;
+        }
+    }
+
+    // some spell specific modifiers
+    float totalDamagePercentMod  = 1.0f;                    // applied to final bonus+weapon damage
+    int32 fixed_bonus = 0;
+    int32 spell_bonus = 0;                                  // bonus specific for spell
+
+    switch (m_spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch (m_spellInfo->Id)
+            {
+                case 69055:     // Saber Lash
+                case 70814:     // Saber Lash
+                {
+                    uint32 count = 0;
+                    for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                        if (ihit->effectMask & (1 << effIndex))
+                            ++count;
+
+                    totalDamagePercentMod /= count;
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            // Devastate (player ones)
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x40)
+            {
+                // Player can apply only 58567 Sunder Armor effect.
+                bool needCast = !unitTarget->HasAura(58567, m_caster->GetGUID());
+                if (needCast)
+                    m_caster->CastSpell(unitTarget, 58567, true);
+
+                if (Aura * aur = unitTarget->GetAura(58567, m_caster->GetGUID()))
+                {
+                    // 58388 - Glyph of Devastate dummy aura.
+                    if (int32 num = (needCast ? 0 : 1) + (m_caster->HasAura(58388) ? 1 : 0))
+                        aur->ModStackAmount(num);
+                    fixed_bonus += (aur->GetStackAmount() - 1) * CalculateDamage(2, unitTarget);
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_ROGUE:
+        {
+            // Fan of Knives, Hemorrhage, Ghostly Strike
+            if ((m_spellInfo->SpellFamilyFlags[1] & 0x40000)
+                || (m_spellInfo->SpellFamilyFlags[0] & 0x6000000))
+            {
+                // Hemorrhage
+                if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
+                {
+                    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                        m_caster->ToPlayer()->AddComboPoints(unitTarget, 1, this);
+                }
+                // 50% more damage with daggers
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    if (Item* item = m_caster->ToPlayer()->GetWeaponForAttack(m_attackType, true))
+                        if (item->GetProto()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
+                            totalDamagePercentMod *= 1.5f;
+            }
+            // Mutilate (for each hand)
+            else if (m_spellInfo->SpellFamilyFlags[1] & 0x6)
+            {
+                bool found = false;
+                // fast check
+                if (unitTarget->HasAuraState(AURA_STATE_DEADLY_POISON, m_spellInfo, m_caster))
+                    found = true;
+                // full aura scan
+                else
+                {
+                    Unit::AuraApplicationMap const& auras = unitTarget->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        if (itr->second->GetBase()->GetSpellProto()->Dispel == DISPEL_POISON)
+                        {
+                            found = true;
+                            break;
+                        }
+                    }
+                }
+
+                if (found)
+                    totalDamagePercentMod *= 1.2f;          // 120% if poisoned
+            }
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Seal of Command - Increase damage by 36% on every swing
+            if (m_spellInfo->SpellFamilyFlags[0] & 0x2000000)
+            {
+                totalDamagePercentMod *= 1.36f;            //136% damage
+            }
+
+            // Seal of Command Unleashed
+            else if (m_spellInfo->Id == 20467)
+            {
+                spell_bonus += int32(0.08f*m_caster->GetTotalAttackPowerValue(BASE_ATTACK));
+                spell_bonus += int32(0.13f*m_caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellInfo)));
+            }
+            break;
+        }
+        case SPELLFAMILY_SHAMAN:
+        {
+            // Skyshatter Harness item set bonus
+            // Stormstrike
+            if (AuraEffect * aurEff = m_caster->IsScriptOverriden(m_spellInfo, 5634))
+                m_caster->CastSpell(m_caster, 38430, true, NULL, aurEff);
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            // Mangle (Cat): CP
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x400)
+            {
+                if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                    m_caster->ToPlayer()->AddComboPoints(unitTarget,1, this);
+            }
+            // Shred, Maul - Rend and Tear
+            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00008800 && unitTarget->HasAuraState(AURA_STATE_BLEEDING))
+            {
+                if (AuraEffect const* rendAndTear = m_caster->GetDummyAuraEffect(SPELLFAMILY_DRUID, 2859, 0))
+                {
+                    totalDamagePercentMod *= float((rendAndTear->GetAmount() + 100.0f) / 100.0f);
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // Kill Shot - bonus damage from Ranged Attack Power
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x800000)
+                spell_bonus += int32(0.4f*m_caster->GetTotalAttackPowerValue(RANGED_ATTACK));
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Plague Strike
+            if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
+            {
+                // Glyph of Plague Strike
+                if (AuraEffect * aurEff = m_caster->GetAuraEffect(58657,0))
+                    totalDamagePercentMod *= float((aurEff->GetAmount() + 100.0f) / 100.0f);
+            }
+            // Blood Strike
+            else if (m_spellInfo->SpellFamilyFlags[0] & 0x400000)
+            {
+                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
+
+                // Glyph of Blood Strike
+                if (m_caster->GetAuraEffect(59332,0))
+                {
+                    if (unitTarget->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED))
+                       totalDamagePercentMod *= float((20 + 100.0f) / 100.0f);
+                }
+            }
+            // Death Strike
+            else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000010)
+            {
+                // Glyph of Death Strike
+                if (m_caster->GetAuraEffect(59336,0))
+                {
+                    if (uint32 runic = m_caster->GetPower(POWER_RUNIC_POWER))
+                    {
+                        if (runic > 25)
+                            runic = 25;
+
+                        totalDamagePercentMod *= float((runic + 100.0f) / 100.0f);
+                    }
+                }
+            }
+            // Obliterate (12.5% more damage per disease)
+            else if (m_spellInfo->SpellFamilyFlags[1] & 0x20000)
+            {
+                bool consumeDiseases = true;
+                // Annihilation
+                if (AuraEffect * aurEff = m_caster->GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2710, 0))
+                {
+                    // Do not consume diseases if roll sucesses
+                    if (roll_chance_i(aurEff->GetAmount()))
+                        consumeDiseases = false;
+                }
+                totalDamagePercentMod *= (float(CalculateDamage(2, unitTarget) * unitTarget->GetDiseasesByCaster(m_caster->GetGUID(), consumeDiseases) / 2) + 100.0f) / 100.0f;
+            }
+            // Blood-Caked Strike - Blood-Caked Blade
+            else if (m_spellInfo->SpellIconID == 1736)
+                totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
+            break;
+        }
+    }
+
+    bool normalized = false;
+    float weaponDamagePercentMod = 1.0;
+    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        switch(m_spellInfo->Effect[j])
+        {
+            case SPELL_EFFECT_WEAPON_DAMAGE:
+            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+                fixed_bonus += CalculateDamage(j, unitTarget);
+                break;
+            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                fixed_bonus += CalculateDamage(j, unitTarget);
+                normalized = true;
+                break;
+            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                weaponDamagePercentMod *= float(CalculateDamage(j,unitTarget)) / 100.0f;
+                break;
+            default:
+                break;                                      // not weapon damage effect, just skip
+        }
+    }
+
+    // apply to non-weapon bonus weapon total pct effect, weapon total flat effect included in weapon damage
+    if (fixed_bonus || spell_bonus)
+    {
+        UnitMods unitMod;
+        switch(m_attackType)
+        {
+            default:
+            case BASE_ATTACK:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
+            case OFF_ATTACK:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
+            case RANGED_ATTACK: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
+        }
+
+        float weapon_total_pct = 1.0f;
+        if (m_spellInfo->SchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+             weapon_total_pct = m_caster->GetModifierValue(unitMod, TOTAL_PCT);
+
+        if (fixed_bonus)
+            fixed_bonus = int32(fixed_bonus * weapon_total_pct);
+        if (spell_bonus)
+            spell_bonus = int32(spell_bonus * weapon_total_pct);
+    }
+
+    int32 weaponDamage = m_caster->CalculateDamage(m_attackType, normalized, true);
+
+    // Sequence is important
+    for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+    {
+        // We assume that a spell have at most one fixed_bonus
+        // and at most one weaponDamagePercentMod
+        switch(m_spellInfo->Effect[j])
+        {
+            case SPELL_EFFECT_WEAPON_DAMAGE:
+            case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+            case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                weaponDamage += fixed_bonus;
+                break;
+            case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                weaponDamage = int32(weaponDamage * weaponDamagePercentMod);
+            default:
+                break;                                      // not weapon damage effect, just skip
+        }
+    }
+
+    if (spell_bonus)
+        weaponDamage += spell_bonus;
+
+    if (totalDamagePercentMod != 1.0f)
+        weaponDamage = int32(weaponDamage * totalDamagePercentMod);
+
+    // prevent negative damage
+    uint32 eff_damage = uint32(weaponDamage > 0 ? weaponDamage : 0);
+
+    // Add melee damage bonuses (also check for negative)
+    m_caster->MeleeDamageBonus(unitTarget, &eff_damage, m_attackType, m_spellInfo);
+    m_damage+= eff_damage;
+}
+
+void Spell::EffectThreat(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive() || !m_caster->isAlive())
+        return;
+
+    if (!unitTarget->CanHaveThreatList())
+        return;
+
+    unitTarget->AddThreat(m_caster, float(damage));
+}
+
+void Spell::EffectHealMaxHealth(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || !unitTarget->isAlive())
+        return;
+
+    int32 addhealth;
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_PALADIN) // Lay on Hands
+    {
+        if (m_caster->GetGUID() == unitTarget->GetGUID())
+        {
+            m_caster->CastSpell(m_caster, 25771, true); // Forbearance
+            m_caster->CastSpell(m_caster, 61988, true); // Immune shield marker (serverside)
+            m_caster->CastSpell(m_caster, 61987, true); // Avenging Wrath marker
+        }
+    }
+
+    // damage == 0 - heal for caster max health
+    if (damage == 0)
+        addhealth = m_caster->GetMaxHealth();
+    else
+        addhealth = unitTarget->GetMaxHealth() - unitTarget->GetHealth();
+
+    if (m_originalCaster)
+         m_healing += m_originalCaster->SpellHealingBonus(unitTarget,m_spellInfo, addhealth, HEAL);
+}
+
+void Spell::EffectInterruptCast(SpellEffIndex effIndex)
+{
+    if (!unitTarget || !unitTarget->isAlive())
+        return;
+
+    // TODO: not all spells that used this effect apply cooldown at school spells
+    // also exist case: apply cooldown to interrupted cast only and to all spells
+    for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; ++i)
+    {
+        if (Spell* spell = unitTarget->GetCurrentSpell(CurrentSpellTypes(i)))
+        {
+            SpellEntry const* curSpellInfo = spell->m_spellInfo;
+            // check if we can interrupt spell
+            if ((spell->getState() == SPELL_STATE_CASTING
+                || (spell->getState() == SPELL_STATE_PREPARING && spell->GetCastTime() > 0.0f))
+                && curSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT && curSpellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+            {
+                if (m_originalCaster)
+                {
+                    int32 duration = m_originalCaster->ModSpellDuration(m_spellInfo, unitTarget, m_originalCaster->CalcSpellDuration(m_spellInfo), false);
+                    unitTarget->ProhibitSpellScholl(GetSpellSchoolMask(curSpellInfo), duration/*GetSpellDuration(m_spellInfo)*/);
+                }
+                ExecuteLogEffectInterruptCast(effIndex, unitTarget, curSpellInfo->Id);
+                unitTarget->InterruptSpell(CurrentSpellTypes(i), false);
+            }
+        }
+    }
+}
+
+void Spell::EffectSummonObjectWild(SpellEffIndex effIndex)
+{
+    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    GameObject* pGameObj = new GameObject;
+
+    WorldObject* target = focusObject;
+    if (!target)
+        target = m_caster;
+
+    float x, y, z;
+    if (m_targets.HasDst())
+        m_targets.m_dstPos.GetPosition(x, y, z);
+    else
+        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+
+    Map *map = target->GetMap();
+
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id, map,
+        m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    int32 duration = GetSpellDuration(m_spellInfo);
+
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+    pGameObj->SetSpellId(m_spellInfo->Id);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    // Wild object not have owner and check clickable by players
+    map->Add(pGameObj);
+
+    if (pGameObj->GetGoType() == GAMEOBJECT_TYPE_FLAGDROP && m_caster->GetTypeId() == TYPEID_PLAYER)
+    {
+        Player *pl = m_caster->ToPlayer();
+        Battleground* bg = pl->GetBattleground();
+
+        switch(pGameObj->GetMapId())
+        {
+            case 489:                                       //WS
+            {
+                if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS && bg->GetStatus() == STATUS_IN_PROGRESS)
+                {
+                    uint32 team = ALLIANCE;
+
+                    if (pl->GetTeam() == team)
+                        team = HORDE;
+
+                    ((BattlegroundWS*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID(),team);
+                }
+                break;
+            }
+            case 566:                                       //EY
+            {
+                if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY && bg->GetStatus() == STATUS_IN_PROGRESS)
+                {
+                    ((BattlegroundEY*)bg)->SetDroppedFlagGUID(pGameObj->GetGUID());
+                }
+                break;
+            }
+        }
+    }
+
+    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
+    {
+        GameObject* linkedGO = new GameObject;
+        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, map,
+            m_caster->GetPhaseMask(), x, y, z, target->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+        {
+            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+            linkedGO->SetSpellId(m_spellInfo->Id);
+
+            ExecuteLogEffectSummonObject(effIndex, linkedGO);
+
+            // Wild object not have owner and check clickable by players
+            map->Add(linkedGO);
+        }
+        else
+        {
+            delete linkedGO;
+            linkedGO = NULL;
+            return;
+        }
+    }
+}
+
+void Spell::EffectScriptEffect(SpellEffIndex effIndex)
+{
+    // TODO: we must implement hunter pet summon at login there (spell 6962)
+
+    switch(m_spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            switch(m_spellInfo->Id)
+            {
+                //Teleport to Lake Wintergrasp
+                case 58622:
+                   {
+                  if(OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197))
+                        if(pvpWG->isWarTime() || pvpWG->m_timer<300000)
+                        {
+                        if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                        else if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_HORDE_CAMP, true);
+                    
+                        if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                        else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                        unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_ALLIENCE_CAMP, true);
+                        }
+                return;
+                   }
+                
+                // Glyph of Backstab
+                case 63975:
+                {
+                    if (AuraEffect const * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE,SPELLFAMILY_ROGUE,0x00100000,0,0,m_caster->GetGUID()))
+                    {
+                        uint32 countMin = aurEff->GetBase()->GetMaxDuration();
+                        uint32 countMax = 12000;
+                        countMax += m_caster->HasAura(56801) ? 4000 : 0;
+
+                        if (countMin < countMax)
+                        {
+                            aurEff->GetBase()->SetDuration(uint32(aurEff->GetBase()->GetDuration()+3000));
+                            aurEff->GetBase()->SetMaxDuration(countMin+2000);
+                        }
+
+                    }
+                    return;
+                }
+                case 72219:
+                case 72551:
+                case 72552:
+                case 72553:
+                {
+                    if(!unitTarget)
+                        return;
+
+                    uint32 spellId = 0;
+                    uint32 auraId = 0;
+
+                    switch (m_spellInfo->Id)
+                    {
+                        case 72219: spellId = 72227; auraId = 72219; break;
+                        case 72551: spellId = 72228; auraId = 72551; break;
+                        case 72552: spellId = 72229; auraId = 72552; break;
+                        case 72553: spellId = 72230; auraId = 72553; break;
+                    }
+
+                    if(Aura* GastricAur = unitTarget->GetAura(auraId))
+                    {
+                        if (GastricAur->GetStackAmount() > 9)
+                        {
+                            unitTarget->RemoveAurasDueToSpell(auraId);
+                            unitTarget->CastSpell(unitTarget, spellId, true);  //cast gastric explosion
+                        }
+                    }
+                    return;
+                }
+                case 69200:                                 // Raging Spirit
+                {
+                    if (!unitTarget)
+                        return;
+
+                    unitTarget->CastSpell(unitTarget, 69201, true);
+                    return;
+                }
+                case 71446:                                 // Twilight Bloodbolt 10N
+                case 71478:                                 // Twilight Bloodbolt 25N
+                case 71479:                                 // Twilight Bloodbolt 10H
+                case 71480:                                 // Twilight Bloodbolt 25H
+                {
+                    if (!unitTarget)
+                        return;
+
+                    uint32 spellId = 71447;
+                    switch (m_spellInfo->Id)
+                    {
+                        case 71478: spellId = 71481; break;
+                        case 71479: spellId = 71482; break;
+                        case 71480: spellId = 71483; break;
+                    }
+                    unitTarget->CastSpell(unitTarget, spellId, true);
+                    return;
+                }
+                case 71899:                                 // Bloodbolt Whirl 10N
+                case 71900:                                 // Bloodbolt Whirl 25N
+                case 71901:                                 // Bloodbolt Whirl 10H
+                case 71902:                                 // Bloodbolt Whirl 25H
+                {
+                    if (!unitTarget)
+                        return;
+
+                    uint32 spellId = 71446;
+                    switch (m_spellInfo->Id)
+                    {
+                        case 71900: spellId = 71478; break;
+                        case 71901: spellId = 71479; break;
+                        case 71902: spellId = 71480; break;
+                    }
+                    m_caster->CastSpell(unitTarget, spellId, true);
+                    return;
+                }
+
+                case 45204: // Clone Me!
+                case 41055: // Copy Weapon
+                case 45206: // Copy Off-hand Weapon
+                    unitTarget->CastSpell(m_caster, damage, false);
+                    break;
+                case 45205: // Copy Offhand Weapon
+                case 41054: // Copy Weapon
+                    m_caster->CastSpell(unitTarget, damage, false);
+                    break;
+                case 55693:                                 // Remove Collapsing Cave Aura
+                    if (!unitTarget)
+                        return;
+                    unitTarget->RemoveAurasDueToSpell(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex));
+                    break;
+                // PX-238 Winter Wondervolt TRAP
+                case 26275:
+                {
+                    uint32 spells[4] = { 26272, 26157, 26273, 26274 };
+
+                    // check presence
+                    for (uint8 j = 0; j < 4; ++j)
+                        if (unitTarget->HasAuraEffect(spells[j],0))
+                            return;
+
+                    // select spell
+                    uint32 iTmpSpellId = spells[urand(0,3)];
+
+                    // cast
+                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
+                    return;
+                }
+                // Bending Shinbone
+                case 8856:
+                {
+                    if (!itemTarget && m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    uint32 spell_id = 0;
+                    switch(urand(1, 5))
+                    {
+                    case 1:  spell_id = 8854; break;
+                    default: spell_id = 8855; break;
+                    }
+
+                    m_caster->CastSpell(m_caster,spell_id,true,NULL);
+                    return;
+                }
+                // Brittle Armor - need remove one 24575 Brittle Armor aura
+                case 24590:
+                    unitTarget->RemoveAuraFromStack(24575);
+                    return;
+                // Mercurial Shield - need remove one 26464 Mercurial Shield aura
+                case 26465:
+                    unitTarget->RemoveAuraFromStack(26464);
+                    return;
+				case 62575:
+				{
+					if(m_caster->GetOwner())
+						m_caster->GetOwner()->CastSpell(unitTarget,62626,true );
+						return;
+				}
+				case 62960:
+				{
+					if (!unitTarget)
+						return;
+					m_caster->CastSpell(unitTarget,62563,true );
+					m_caster->CastSpell(unitTarget,68321,true );
+					return;
+				}
+				case 62626:
+				case 68321:
+				{
+					if(!unitTarget)
+						return;
+					if (unitTarget->GetAura(62719))
+						unitTarget->RemoveAuraFromStack(62719);
+
+					if(unitTarget->GetAura(64100))
+						unitTarget->RemoveAuraFromStack(64100);
+					return;
+				}
+					// Shadow Flame (All script effects, not just end ones to prevent player from dodging the last triggered spell)
+                case 22539:
+                case 22972:
+                case 22975:
+                case 22976:
+                case 22977:
+                case 22978:
+                case 22979:
+                case 22980:
+                case 22981:
+                case 22982:
+                case 22983:
+                case 22984:
+                case 22985:
+                {
+                    if (!unitTarget || !unitTarget->isAlive())
+                        return;
+
+                    // Onyxia Scale Cloak
+                    if (unitTarget->HasAura(22683))
+                        return;
+
+                    // Shadow Flame
+                    m_caster->CastSpell(unitTarget, 22682, true);
+                    return;
+                }
+                // Piccolo of the Flaming Fire
+                case 17512:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    unitTarget->HandleEmoteCommand(EMOTE_STATE_DANCE);
+                    return;
+                }
+                // Escape artist
+                case 20589:
+                    m_caster->RemoveMovementImpairingAuras();
+                    return;
+                // Decimate
+                case 28374:
+                case 54426:
+                    if (unitTarget)
+                    {
+                        int32 damage = int32(unitTarget->GetHealth()) - int32(unitTarget->CountPctFromMaxHealth(5));
+                        if (damage > 0)
+                            m_caster->CastCustomSpell(28375, SPELLVALUE_BASE_POINT0, damage, unitTarget);
+                    }
+                    return;
+                // Mirren's Drinking Hat
+                case 29830:
+                {
+                    uint32 item = 0;
+                    switch (urand(1, 6))
+                    {
+                        case 1:
+                        case 2:
+                        case 3:
+                            item = 23584; break;            // Loch Modan Lager
+                        case 4:
+                        case 5:
+                            item = 23585; break;            // Stouthammer Lite
+                        case 6:
+                            item = 23586; break;            // Aerie Peak Pale Ale
+                    }
+                    if (item)
+                        DoCreateItem(effIndex,item);
+                    break;
+                }
+                // Improved Sprint
+                case 30918:
+                {
+                    // Removes snares and roots.
+                    unitTarget->RemoveMovementImpairingAuras();
+                    break;
+                }
+                // Spirit Walk
+                case 58876:
+                {
+                    // Removes snares and roots.
+                    unitTarget->RemoveMovementImpairingAuras();
+                    break;
+                }
+                // Plant Warmaul Ogre Banner
+                case 32307:
+                {
+                    Player *p_caster = dynamic_cast<Player*>(m_caster);
+                    if (!p_caster)
+                        break;
+                    p_caster->RewardPlayerAndGroupAtEvent(18388, unitTarget);
+                    Creature *cTarget = dynamic_cast<Creature*>(unitTarget);
+                    if (!cTarget)
+                        break;
+                    cTarget->setDeathState(CORPSE);
+                    cTarget->RemoveCorpse();
+                    break;
+                }
+                case 48025:                                     // Headless Horseman's Mount
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 51621, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 48024, true); break;
+                    case 225:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 51617, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 48024, true);
+                        }break;
+                    case 300:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 48023, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 48024, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 47977:                                     // Magic Broom
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 42680, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 42683, true); break;
+                    case 225:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 42667, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 42683, true);
+                        }break;
+                    case 300:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 42668, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 42683, true);
+                        }break;
+                    }
+                    return;
+                }
+                // Mug Transformation
+                case 41931:
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    uint8 bag = 19;
+                    uint8 slot = 0;
+                    Item *item = NULL;
+
+                    while (bag) // 256 = 0 due to var type
+                    {
+                        item = m_caster->ToPlayer()->GetItemByPos(bag, slot);
+                        if (item && item->GetEntry() == 38587) break;
+                        ++slot;
+                        if (slot == 39)
+                        {
+                            slot = 0;
+                            ++bag;
+                        }
+                    }
+                    if (bag)
+                    {
+                        if (m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount() == 1) m_caster->ToPlayer()->RemoveItem(bag,slot,true);
+                        else m_caster->ToPlayer()->GetItemByPos(bag,slot)->SetCount(m_caster->ToPlayer()->GetItemByPos(bag,slot)->GetCount()-1);
+                        // Spell 42518 (Braufest - Gratisprobe des Braufest herstellen)
+                        m_caster->CastSpell(m_caster, 42518, true);
+                        return;
+                    }
+                    break;
+                }
+                // Brutallus - Burn
+                case 45141:
+                case 45151:
+                {
+                    //Workaround for Range ... should be global for every ScriptEffect
+                    float radius = GetSpellRadiusForHostile(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+                    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER && unitTarget->GetDistance(m_caster) >= radius && !unitTarget->HasAura(46394) && unitTarget != m_caster)
+                        unitTarget->CastSpell(unitTarget, 46394, true);
+
+                    break;
+                }
+                // Goblin Weather Machine
+                case 46203:
+                {
+                    if (!unitTarget)
+                        return;
+
+                    uint32 spellId = 0;
+                    switch(rand() % 4)
+                    {
+                        case 0: spellId = 46740; break;
+                        case 1: spellId = 46739; break;
+                        case 2: spellId = 46738; break;
+                        case 3: spellId = 46736; break;
+                    }
+                    unitTarget->CastSpell(unitTarget, spellId, true);
+                    break;
+                }
+                // 5,000 Gold
+                case 46642:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    unitTarget->ToPlayer()->ModifyMoney(5000 * GOLD);
+
+                    break;
+                }
+                // Roll Dice - Decahedral Dwarven Dice
+                case 47770:
+                {
+                    char buf[128];
+                    const char *gender = "his";
+                    if (m_caster->getGender() > 0)
+                        gender = "her";
+                    sprintf(buf, "%s rubs %s [Decahedral Dwarven Dice] between %s hands and rolls. One %u and one %u.", m_caster->GetName(), gender, gender, urand(1,10), urand(1,10));
+                    m_caster->MonsterTextEmote(buf, 0);
+                    break;
+                }
+                // Roll 'dem Bones - Worn Troll Dice
+                case 47776:
+                {
+                    char buf[128];
+                    const char *gender = "his";
+                    if (m_caster->getGender() > 0)
+                        gender = "her";
+                    sprintf(buf, "%s causually tosses %s [Worn Troll Dice]. One %u and one %u.", m_caster->GetName(), gender, urand(1,6), urand(1,6));
+                    m_caster->MonsterTextEmote(buf, 0);
+                    break;
+                }
+                // Vigilance
+                case 50725:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Remove Taunt cooldown
+                    unitTarget->ToPlayer()->RemoveSpellCooldown(355, true);
+
+                    return;
+                }
+                // Death Knight Initiate Visual
+                case 51519:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    uint32 iTmpSpellId = 0;
+                    switch (unitTarget->GetDisplayId())
+                    {
+                        case 25369: iTmpSpellId = 51552; break; // bloodelf female
+                        case 25373: iTmpSpellId = 51551; break; // bloodelf male
+                        case 25363: iTmpSpellId = 51542; break; // draenei female
+                        case 25357: iTmpSpellId = 51541; break; // draenei male
+                        case 25361: iTmpSpellId = 51537; break; // dwarf female
+                        case 25356: iTmpSpellId = 51538; break; // dwarf male
+                        case 25372: iTmpSpellId = 51550; break; // forsaken female
+                        case 25367: iTmpSpellId = 51549; break; // forsaken male
+                        case 25362: iTmpSpellId = 51540; break; // gnome female
+                        case 25359: iTmpSpellId = 51539; break; // gnome male
+                        case 25355: iTmpSpellId = 51534; break; // human female
+                        case 25354: iTmpSpellId = 51520; break; // human male
+                        case 25360: iTmpSpellId = 51536; break; // nightelf female
+                        case 25358: iTmpSpellId = 51535; break; // nightelf male
+                        case 25368: iTmpSpellId = 51544; break; // orc female
+                        case 25364: iTmpSpellId = 51543; break; // orc male
+                        case 25371: iTmpSpellId = 51548; break; // tauren female
+                        case 25366: iTmpSpellId = 51547; break; // tauren male
+                        case 25370: iTmpSpellId = 51545; break; // troll female
+                        case 25365: iTmpSpellId = 51546; break; // troll male
+                        default: return;
+                    }
+
+                    unitTarget->CastSpell(unitTarget, iTmpSpellId, true);
+                    Creature* npc = unitTarget->ToCreature();
+                    npc->LoadEquipment(npc->GetEquipmentId());
+                    return;
+                }
+                // Emblazon Runeblade
+                case 51770:
+                {
+                    if (!m_originalCaster)
+                        return;
+
+                    m_originalCaster->CastSpell(m_originalCaster, damage, false);
+                    break;
+                }
+                // Deathbolt from Thalgran Blightbringer
+                // reflected by Freya's Ward
+                // Retribution by Sevenfold Retribution
+                case 51854:
+                {
+                    if (!m_caster || !unitTarget)
+                        return;
+                    if (unitTarget->HasAura(51845))
+                        unitTarget->CastSpell(m_caster, 51856, true);
+                    else
+                        m_caster->CastSpell(unitTarget, 51855, true);
+                    break;
+                }
+                // Summon Ghouls On Scarlet Crusade
+                case 51904:
+                {
+                    if (!m_targets.HasDst())
+                        return;
+
+                    float x, y, z;
+                    float radius = GetSpellRadius(m_spellInfo, effIndex, true);
+                    for (uint8 i = 0; i < 15; ++i)
+                    {
+                        m_caster->GetRandomPoint(m_targets.m_dstPos, radius, x, y, z);
+                        m_caster->CastSpell(x, y, z, 54522, true);
+                    }
+                    break;
+                }
+                case 52173: // Coyote Spirit Despawn
+                case 60243: // Blood Parrot Despawn
+                    if (unitTarget->GetTypeId() == TYPEID_UNIT && unitTarget->ToCreature()->isSummon())
+                        unitTarget->ToTempSummon()->UnSummon();
+                    return;
+                case 52479: // Gift of the Harvester
+                    if (unitTarget && m_originalCaster)
+                        m_originalCaster->CastSpell(unitTarget, urand(0, 1) ? damage : 52505, true);
+                    return;
+                // Death Gate
+                case 52751:
+                {
+                    if (!unitTarget || unitTarget->getClass() != CLASS_DEATH_KNIGHT)
+                        return;
+                    // triggered spell is stored in m_spellInfo->EffectBasePoints[0]
+                    unitTarget->CastSpell(unitTarget, damage, false);
+                    break;
+                }
+                case 53110: // Devour Humanoid
+                    if (unitTarget)
+                        unitTarget->CastSpell(m_caster, damage, true);
+                    return;
+                // Winged Steed of the Ebon Blade
+                case 54729:
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 300)
+                            unitTarget->CastSpell(unitTarget, 54727, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 54726, true);
+                    }
+                    return;
+                }
+                case 58418:                                 // Portal to Orgrimmar
+                case 58420:                                 // Portal to Stormwind
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || effIndex != 0)
+                        return;
+
+                    uint32 spellID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 0);
+                    uint32 questID = SpellMgr::CalculateSpellEffectAmount(m_spellInfo, 1);
+
+                    if (unitTarget->ToPlayer()->GetQuestStatus(questID) == QUEST_STATUS_COMPLETE && !unitTarget->ToPlayer()->GetQuestRewardStatus (questID))
+                        unitTarget->CastSpell(unitTarget, spellID, true);
+
+                    return;
+                }
+                case 58941:                                 // Rock Shards
+                    if (unitTarget && m_originalCaster)
+                    {
+                        for (uint32 i = 0; i < 3; ++i)
+                        {
+                            m_originalCaster->CastSpell(unitTarget, 58689, true);
+                            m_originalCaster->CastSpell(unitTarget, 58692, true);
+                        }
+                        if (((InstanceMap*)m_originalCaster->GetMap())->GetDifficulty() == REGULAR_DIFFICULTY)
+                        {
+                            m_originalCaster->CastSpell(unitTarget, 58695, true);
+                            m_originalCaster->CastSpell(unitTarget, 58696, true);
+                        }
+                        else
+                        {
+                            m_originalCaster->CastSpell(unitTarget, 60883, true);
+                            m_originalCaster->CastSpell(unitTarget, 60884, true);
+                        }
+                    }
+                    return;
+                case 58983: // Big Blizzard Bear
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 150)
+                            unitTarget->CastSpell(unitTarget, 58999, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 58997, true);
+                    }
+                    return;
+                }
+                case 63845: // Create Lance
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    if (m_caster->ToPlayer()->GetTeam() == ALLIANCE)
+			{
+                        m_caster->CastSpell(m_caster, 63914, true);
+			DoCreateItem(0,46069);
+			}
+                    else
+			{
+                        DoCreateItem(0,46070);
+			m_caster->CastSpell(m_caster, 63919, true);
+			}
+                    return;
+                }
+                case 62705:
+                {
+ 	                if (!unitTarget->isInCombat())
+ 	                    unitTarget->SetHealth(unitTarget->GetMaxHealth());
+                }
+                case 71342:                                     // Big Love Rocket
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 0: unitTarget->CastSpell(unitTarget, 71343, true); break;
+                    case 75: unitTarget->CastSpell(unitTarget, 71344, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 71345, true); break;
+                    case 225:
+                        {
+                        if (canFly)
+                                unitTarget->CastSpell(unitTarget, 71346, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 71345, true);
+                        }break;
+                    case 300:
+                        {
+                        if (canFly)
+                            unitTarget->CastSpell(unitTarget, 71347, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 71345, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 72286:                                     // Invincible
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 72281, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 72282, true); break;
+                    case 225:
+                        {
+                        if (canFly)
+                                unitTarget->CastSpell(unitTarget, 72283, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 72282, true);
+                        }break;
+                    case 300:
+                        {
+                        if (canFly)
+                            unitTarget->CastSpell(unitTarget, 72284, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 72282, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 74856:                                     // Blazing Hippogryph
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 300)
+                            unitTarget->CastSpell(unitTarget, 74855, true);
+                        else
+                            unitTarget->CastSpell(unitTarget, 74854, true);
+                    }
+                    return;
+                }
+                case 75614:                                     // Celestial Steed
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts and client crashes upon dismounting
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill and zone
+                    bool canFly = true;
+                    uint32 v_map = GetVirtualMapForMapAndZone(unitTarget->GetMapId(), unitTarget->GetZoneId());
+                    if (v_map != 530 && v_map != 571)
+                        canFly = false;
+
+                    if (canFly && v_map == 571 && !unitTarget->ToPlayer()->HasSpell(54197))
+                        canFly = false;
+
+                    float x, y, z;
+                    unitTarget->GetPosition(x, y, z);
+                    uint32 areaFlag = unitTarget->GetBaseMap()->GetAreaFlag(x, y, z);
+                    AreaTableEntry const *pArea = sAreaStore.LookupEntry(areaFlag);
+                    if (canFly && pArea->flags & AREA_FLAG_NO_FLY_ZONE)
+                        canFly = false;
+
+                    switch(unitTarget->ToPlayer()->GetBaseSkillValue(SKILL_RIDING))
+                    {
+                    case 75: unitTarget->CastSpell(unitTarget, 75619, true); break;
+                    case 150: unitTarget->CastSpell(unitTarget, 75620, true); break;
+                    case 225:
+                        {
+                            if (canFly)
+                                unitTarget->CastSpell(unitTarget, 75617, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 75620, true);
+                        }break;
+                    case 300:
+                        {
+                            if (canFly)
+                            {
+                                if (unitTarget->ToPlayer()->Has310Flyer(false))
+                                    unitTarget->CastSpell(unitTarget, 76153, true);
+                                else
+                                    unitTarget->CastSpell(unitTarget, 75618, true);
+                            }
+                            else
+                                unitTarget->CastSpell(unitTarget, 75620, true);
+                        }break;
+                    }
+                    return;
+                }
+                case 75973:                                     // X-53 Touring Rocket
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // Prevent stacking of mounts
+                    unitTarget->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+                    // Triggered spell id dependent on riding skill
+                    if (uint16 skillval = unitTarget->ToPlayer()->GetSkillValue(SKILL_RIDING))
+                    {
+                        if (skillval >= 300)
+                        {
+                            if (unitTarget->ToPlayer()->Has310Flyer(false))
+                                unitTarget->CastSpell(unitTarget, 76154, true);
+                            else
+                                unitTarget->CastSpell(unitTarget, 75972, true);
+                        }
+                        else
+                            unitTarget->CastSpell(unitTarget, 75957, true);
+                    }
+                    return;
+                }
+                case 59317:                                 // Teleporting
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // return from top
+                    if (unitTarget->ToPlayer()->GetAreaId() == 4637)
+                        unitTarget->CastSpell(unitTarget, 59316, true);
+                    // teleport atop
+                    else
+                        unitTarget->CastSpell(unitTarget, 59314, true);
+
+                    return;
+                // random spell learn instead placeholder
+                case 60893:                                 // Northrend Alchemy Research
+                case 61177:                                 // Northrend Inscription Research
+                case 61288:                                 // Minor Inscription Research
+                case 61756:                                 // Northrend Inscription Research (FAST QA VERSION)
+                case 64323:                                 // Book of Glyph Mastery
+                {
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    // learn random explicit discovery recipe (if any)
+                    if (uint32 discoveredSpell = GetExplicitDiscoverySpell(m_spellInfo->Id, (Player*)m_caster))
+                        m_caster->ToPlayer()->learnSpell(discoveredSpell, false);
+                    return;
+                }
+                case 62428: // Load into Catapult
+                {
+                    if (Vehicle *seat = m_caster->GetVehicleKit())
+                        if (Unit *passenger = seat->GetPassenger(0))
+                            if (Unit *demolisher = m_caster->GetVehicleBase())
+                                passenger->CastSpell(demolisher, damage, true);
+                    return;
+                }
+                case 62482: // Grab Crate
+                {
+                    if (unitTarget)
+                    {
+                        if (Vehicle *seat = m_caster->GetVehicleKit())
+                        {
+                            if (Creature *oldContainer = dynamic_cast<Creature*>(seat->GetPassenger(1)))
+                                oldContainer->DisappearAndDie();
+                            // TODO: a hack, range = 11, should after some time cast, otherwise too far
+                            unitTarget->CastSpell(seat->GetBase(), 62496, true);
+                            unitTarget->EnterVehicle(seat, 1);
+                        }
+                    }
+                    return;
+                }
+                case 60123: // Lightwell
+                {
+                    if (m_caster->GetTypeId() != TYPEID_UNIT || !m_caster->ToCreature()->isSummon())
+                        return;
+
+                    uint32 spell_heal;
+
+                    switch(m_caster->GetEntry())
+                    {
+                        case 31897: spell_heal = 7001; break;
+                        case 31896: spell_heal = 27873; break;
+                        case 31895: spell_heal = 27874; break;
+                        case 31894: spell_heal = 28276; break;
+                        case 31893: spell_heal = 48084; break;
+                        case 31883: spell_heal = 48085; break;
+                        default:
+                            sLog.outError("Unknown Lightwell spell caster %u", m_caster->GetEntry());
+                            return;
+                    }
+                    Aura * chargesaura = m_caster->GetAura(59907);
+
+                    if (chargesaura && chargesaura->GetCharges() > 1)
+                    {
+                        chargesaura->SetCharges(chargesaura->GetCharges() - 1);
+                        m_caster->CastSpell(unitTarget, spell_heal, true, NULL, NULL, m_caster->ToTempSummon()->GetSummonerGUID());
+                    }
+                    else
+                        m_caster->ToTempSummon()->UnSummon();
+                    return;
+                }
+                // Stoneclaw Totem
+                case 55328: // Rank 1
+                case 55329: // Rank 2
+                case 55330: // Rank 3
+                case 55332: // Rank 4
+                case 55333: // Rank 5
+                case 55335: // Rank 6
+                case 55278: // Rank 7
+                case 58589: // Rank 8
+                case 58590: // Rank 9
+                case 58591: // Rank 10
+                {
+                    int32 basepoints0 = damage;
+                    // Cast Absorb on totems
+                    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
+                    {
+                        if (!unitTarget->m_SummonSlot[slot])
+                            continue;
+
+                        Creature* totem = unitTarget->GetMap()->GetCreature(unitTarget->m_SummonSlot[slot]);
+                        if (totem && totem->isTotem())
+                        {
+                            m_caster->CastCustomSpell(totem, 55277, &basepoints0, NULL, NULL, true);
+                        }
+                    }
+                    // Glyph of Stoneclaw Totem
+                    if (AuraEffect *aur=unitTarget->GetAuraEffect(63298, 0))
+                    {
+                        basepoints0 *= aur->GetAmount();
+                        m_caster->CastCustomSpell(unitTarget, 55277, &basepoints0, NULL, NULL, true);
+                    }
+                    break;
+                }
+                case 66545: //Summon Memory
+                {
+                    uint8 uiRandom = urand(0,25);
+                    uint32 uiSpells[26] = {66704,66705,66706,66707,66709,66710,66711,66712,66713,66714,66715,66708,66708,66691,66692,66694,66695,66696,66697,66698,66699,66700,66701,66702,66703,66543};
+
+                    m_caster->CastSpell(m_caster,uiSpells[uiRandom],true);
+                    break;
+                }
+                case 45668:                                 // Ultra-Advanced Proto-Typical Shortening Blaster
+                {
+                    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    if (roll_chance_i(50))                  // chance unknown, using 50
+                        return;
+
+                    static uint32 const spellPlayer[5] =
+                    {
+                        45674,                            // Bigger!
+                        45675,                            // Shrunk
+                        45678,                            // Yellow
+                        45682,                            // Ghost
+                        45684                             // Polymorph
+                    };
+
+                    static uint32 const spellTarget[5] = {
+                        45673,                            // Bigger!
+                        45672,                            // Shrunk
+                        45677,                            // Yellow
+                        45681,                            // Ghost
+                        45683                             // Polymorph
+                    };
+
+                    m_caster->CastSpell(m_caster, spellPlayer[urand(0,4)], true);
+                    unitTarget->CastSpell(unitTarget, spellTarget[urand(0,4)], true);
+                    break;
+                }
+                case 64142:                                 // Upper Deck - Create Foam Sword
+		{
+                    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+                        return;
+                    Player *plr = unitTarget->ToPlayer();
+                    static uint32 const itemId[] = {45061, 45176, 45177, 45178, 45179, 0};
+                    // player can only have one of these items
+                    for (uint32 const *itr = &itemId[0]; *itr; ++itr)
+                        if (plr->HasItemCount(*itr, 1, true))
+                            return;
+                    DoCreateItem(effIndex, itemId[urand(0,4)]);
+                    return;
+		}
+            }
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Judgement (seal trigger)
+            if (m_spellInfo->Category == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (!unitTarget || !unitTarget->isAlive())
+                    return;
+                uint32 spellId1 = 0;
+                uint32 spellId2 = 0;
+                uint32 spellId3 = 0;
+
+                // Judgement self add switch
+                switch (m_spellInfo->Id)
+                {
+                    case 53407: spellId1 = 20184; break;    // Judgement of Justice
+                    case 20271:                             // Judgement of Light
+                    case 57774: spellId1 = 20185; break;    // Judgement of Light
+                    case 53408: spellId1 = 20186; break;    // Judgement of Wisdom
+                    default:
+                        sLog.outError("Unsupported Judgement (seal trigger) spell (Id: %u) in Spell::EffectScriptEffect",m_spellInfo->Id);
+                        return;
+                }
+                // all seals have aura dummy in 2 effect
+                Unit::AuraApplicationMap & sealAuras = m_caster->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::iterator iter = sealAuras.begin(); iter != sealAuras.end();)
+                {
+                    switch (iter->first)
+                    {
+                        // Heart of the Crusader
+                        case 20335: // Rank 1
+                            spellId3 = 21183;
+                            break;
+                        case 20336: // Rank 2
+                            spellId3 = 54498;
+                            break;
+                        case 20337: // Rank 3
+                            spellId3 = 54499;
+                            break;
+                    }
+                    Aura * aura = iter->second->GetBase();
+                    if (IsSealSpell(aura->GetSpellProto()))
+                    {
+                        if (AuraEffect * aureff = aura->GetEffect(2))
+                            if (aureff->GetAuraType() == SPELL_AURA_DUMMY)
+                            {
+                                if (sSpellStore.LookupEntry(aureff->GetAmount()))
+                                    spellId2 = aureff->GetAmount();
+                                break;
+                            }
+                        if (!spellId2)
+                        {
+                            switch (iter->first)
+                            {
+                                // Seal of light, Seal of wisdom, Seal of justice
+                                case 20165:
+                                case 20166:
+                                case 20164:
+                                    spellId2 = 54158;
+                            }
+                        }
+                        break;
+                    }
+                    else
+                        ++iter;
+                }
+                if (spellId1)
+                    m_caster->CastSpell(unitTarget, spellId1, true);
+                if (spellId2)
+                    m_caster->CastSpell(unitTarget, spellId2, true);
+                if (spellId3)
+                    m_caster->CastSpell(unitTarget, spellId3, true);
+                return;
+            }
+        }
+        case SPELLFAMILY_POTION:
+        {
+            switch(m_spellInfo->Id)
+            {
+                // Netherbloom
+                case 28702:
+                {
+                    if (!unitTarget)
+                        return;
+                    // 25% chance of casting a random buff
+                    if (roll_chance_i(75))
+                        return;
+
+                    // triggered spells are 28703 to 28707
+                    // Note: some sources say, that there was the possibility of
+                    //       receiving a debuff. However, this seems to be removed by a patch.
+                    const uint32 spellid = 28703;
+
+                    // don't overwrite an existing aura
+                    for (uint8 i = 0; i < 5; ++i)
+                        if (unitTarget->HasAura(spellid + i))
+                            return;
+                    unitTarget->CastSpell(unitTarget, spellid+urand(0, 4), true);
+                    break;
+                }
+
+                // Nightmare Vine
+                case 28720:
+                {
+                    if (!unitTarget)
+                        return;
+                    // 25% chance of casting Nightmare Pollen
+                    if (roll_chance_i(75))
+                        return;
+                    unitTarget->CastSpell(unitTarget, 28721, true);
+                    break;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Pestilence
+            if (m_spellInfo->SpellFamilyFlags[1]&0x10000)
+            {
+                // Get diseases on target of spell
+                if (m_targets.getUnitTarget() &&  // Glyph of Disease - cast on unit target too to refresh aura
+                    (m_targets.getUnitTarget() != unitTarget || m_caster->GetAura(63334)))
+                {
+                    // And spread them on target
+                    // Blood Plague
+                    if (m_targets.getUnitTarget()->GetAura(55078))
+                        m_caster->CastSpell(unitTarget, 55078, true);
+                    // Frost Fever
+                    if (m_targets.getUnitTarget()->GetAura(55095))
+                        m_caster->CastSpell(unitTarget, 55095, true);
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            // Shattering Throw
+            if (m_spellInfo->SpellFamilyFlags[1] & 0x00400000)
+            {
+                if (!unitTarget)
+                    return;
+                // remove shields, will still display immune to damage part
+                unitTarget->RemoveAurasWithMechanic(1<<MECHANIC_IMMUNE_SHIELD, AURA_REMOVE_BY_ENEMY_SPELL);
+                return;
+            }
+            break;
+        }
+    }
+
+    // normal DB scripted effect
+    sLog.outDebug("Spell ScriptStart spellid %u in EffectScriptEffect(%u)", m_spellInfo->Id, effIndex);
+    m_caster->GetMap()->ScriptsStart(sSpellScripts, uint32(m_spellInfo->Id | (effIndex << 24)), m_caster, unitTarget);
+}
+
+void Spell::EffectSanctuary(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    std::list<Unit*> targets;
+    Trinity::AnyUnfriendlyUnitInObjectRangeCheck u_check(unitTarget, unitTarget, m_caster->GetMap()->GetVisibilityDistance());
+    Trinity::UnitListSearcher<Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(unitTarget, targets, u_check);
+    unitTarget->VisitNearbyObject(m_caster->GetMap()->GetVisibilityDistance(), searcher);
+    for (std::list<Unit*>::iterator iter = targets.begin(); iter != targets.end(); ++iter)
+    {
+        if (!(*iter)->hasUnitState(UNIT_STAT_CASTING))
+            continue;
+
+        for (uint32 i = CURRENT_FIRST_NON_MELEE_SPELL; i < CURRENT_MAX_SPELL; i++)
+        {
+            if ((*iter)->GetCurrentSpell(i)
+            && (*iter)->GetCurrentSpell(i)->m_targets.getUnitTargetGUID() == unitTarget->GetGUID())
+            {
+                (*iter)->InterruptSpell(CurrentSpellTypes(i), false);
+            }
+        }
+    }
+
+    unitTarget->CombatStop();
+    unitTarget->getHostileRefManager().deleteReferences();   // stop all fighting
+    // Vanish allows to remove all threat and cast regular stealth so other spells can be used
+    if (m_caster->GetTypeId() == TYPEID_PLAYER
+        && m_spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE
+        && (m_spellInfo->SpellFamilyFlags[0] & SPELLFAMILYFLAG_ROGUE_VANISH))
+    {
+        
+        // Overkill
+        if (m_caster->ToPlayer()->HasSpell(58426))
+           m_caster->CastSpell(m_caster, 58427, true);
+    }
+}
+
+void Spell::EffectAddComboPoints(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    if (!m_caster->m_movedPlayer)
+        return;
+
+    if (damage <= 0)
+        return;
+
+    m_caster->m_movedPlayer->AddComboPoints(unitTarget, damage, this);
+}
+
+void Spell::EffectDuel(SpellEffIndex effIndex)
+{
+    if (!m_caster || !unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *caster = (Player*)m_caster;
+    Player *target = (Player*)unitTarget;
+
+    // caster or target already have requested duel
+    if (caster->duel || target->duel || !target->GetSocial() || target->GetSocial()->HasIgnore(caster->GetGUIDLow()))
+        return;
+
+    // Players can only fight a duel with each other outside (=not inside dungeons and not in capital cities)
+    // Don't have to check the target's map since you cannot challenge someone across maps
+    if (caster->GetMap()->Instanceable())
+    //if (mapid != 0 && mapid != 1 && mapid != 530 && mapid != 571 && mapid != 609)
+    {
+        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
+        return;
+    }
+
+    AreaTableEntry const* casterAreaEntry = GetAreaEntryByAreaID(caster->GetZoneId());
+    if (casterAreaEntry && (casterAreaEntry->flags & AREA_FLAG_CAPITAL))
+    {
+        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
+        return;
+    }
+
+    AreaTableEntry const* targetAreaEntry = GetAreaEntryByAreaID(target->GetZoneId());
+    if (targetAreaEntry && (targetAreaEntry->flags & AREA_FLAG_CAPITAL))
+    {
+        SendCastResult(SPELL_FAILED_NO_DUELING);            // Dueling isn't allowed here
+        return;
+    }
+
+    //CREATE DUEL FLAG OBJECT
+    GameObject* pGameObj = new GameObject;
+
+    uint32 gameobject_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    Map *map = m_caster->GetMap();
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), gameobject_id,
+        map, m_caster->GetPhaseMask(),
+        m_caster->GetPositionX()+(unitTarget->GetPositionX()-m_caster->GetPositionX())/2 ,
+        m_caster->GetPositionY()+(unitTarget->GetPositionY()-m_caster->GetPositionY())/2 ,
+        m_caster->GetPositionZ(),
+        m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    pGameObj->SetUInt32Value(GAMEOBJECT_FACTION, m_caster->getFaction());
+    pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel()+1);
+    int32 duration = GetSpellDuration(m_spellInfo);
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+    pGameObj->SetSpellId(m_spellInfo->Id);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    m_caster->AddGameObject(pGameObj);
+    map->Add(pGameObj);
+    //END
+
+    // Send request
+    WorldPacket data(SMSG_DUEL_REQUESTED, 8 + 8);
+    data << uint64(pGameObj->GetGUID());
+    data << uint64(caster->GetGUID());
+    caster->GetSession()->SendPacket(&data);
+    target->GetSession()->SendPacket(&data);
+
+    // create duel-info
+    DuelInfo *duel   = new DuelInfo;
+    duel->initiator  = caster;
+    duel->opponent   = target;
+    duel->startTime  = 0;
+    duel->startTimer = 0;
+    caster->duel     = duel;
+
+    DuelInfo *duel2   = new DuelInfo;
+    duel2->initiator  = caster;
+    duel2->opponent   = caster;
+    duel2->startTime  = 0;
+    duel2->startTimer = 0;
+    target->duel      = duel2;
+
+    caster->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
+    target->SetUInt64Value(PLAYER_DUEL_ARBITER, pGameObj->GetGUID());
+
+    sScriptMgr.OnPlayerDuelRequest(target, caster);
+}
+
+void Spell::EffectStuck(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (!sWorld.getBoolConfig(CONFIG_CAST_UNSTUCK))
+        return;
+
+    Player* pTarget = (Player*)unitTarget;
+
+    sLog.outDebug("Spell Effect: Stuck");
+    sLog.outDetail("Player %s (guid %u) used auto-unstuck future at map %u (%f, %f, %f)", pTarget->GetName(), pTarget->GetGUIDLow(), m_caster->GetMapId(), m_caster->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ());
+
+    if (pTarget->isInFlight())
+        return;
+
+    pTarget->TeleportTo(pTarget->GetStartPosition(), unitTarget == m_caster ? TELE_TO_SPELL : 0);
+    // homebind location is loaded always
+    // pTarget->TeleportTo(pTarget->m_homebindMapId,pTarget->m_homebindX,pTarget->m_homebindY,pTarget->m_homebindZ,pTarget->GetOrientation(), (unitTarget == m_caster ? TELE_TO_SPELL : 0));
+
+    // Stuck spell trigger Hearthstone cooldown
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(8690);
+    if (!spellInfo)
+        return;
+    Spell spell(pTarget, spellInfo, true, 0);
+    spell.SendSpellCooldown();
+}
+
+void Spell::EffectSummonPlayer(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    // Evil Twin (ignore player summon, but hide this for summoner)
+    if (unitTarget->HasAura(23445))
+        return;
+
+    float x, y, z;
+    m_caster->GetClosePoint(x, y, z, unitTarget->GetObjectSize());
+
+    unitTarget->ToPlayer()->SetSummonPoint(m_caster->GetMapId(),x,y,z);
+
+    WorldPacket data(SMSG_SUMMON_REQUEST, 8+4+4);
+    data << uint64(m_caster->GetGUID());                    // summoner guid
+    data << uint32(m_caster->GetZoneId());                  // summoner zone
+    data << uint32(MAX_PLAYER_SUMMON_DELAY*IN_MILLISECONDS); // auto decline after msecs
+    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+static ScriptInfo generateActivateCommand()
+{
+    ScriptInfo si;
+    si.command = SCRIPT_COMMAND_ACTIVATE_OBJECT;
+    return si;
+}
+
+void Spell::EffectActivateObject(SpellEffIndex effIndex)
+{
+    if (!gameObjTarget)
+        return;
+
+    static ScriptInfo activateCommand = generateActivateCommand();
+
+    int32 delay_secs = m_spellInfo->EffectMiscValue[effIndex];
+
+    gameObjTarget->GetMap()->ScriptCommandStart(activateCommand, delay_secs, m_caster, gameObjTarget);
+}
+
+void Spell::EffectApplyGlyph(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER || m_glyphIndex >= MAX_GLYPH_SLOT_INDEX)
+        return;
+
+    Player *player = (Player*)m_caster;
+
+    // glyph sockets level requirement
+    uint8 minLevel = 0;
+    switch (m_glyphIndex)
+    {
+        case 0:
+        case 1: minLevel = 15; break;
+        case 2: minLevel = 50; break;
+        case 3: minLevel = 30; break;
+        case 4: minLevel = 70; break;
+        case 5: minLevel = 80; break;
+    }
+    if (minLevel && m_caster->getLevel() < minLevel)
+    {
+        SendCastResult(SPELL_FAILED_GLYPH_SOCKET_LOCKED);
+        return;
+    }
+
+    // apply new one
+    if (uint32 glyph = m_spellInfo->EffectMiscValue[effIndex])
+    {
+        if (GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(glyph))
+        {
+            if (GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(player->GetGlyphSlot(m_glyphIndex)))
+            {
+                if (gp->TypeFlags != gs->TypeFlags)
+                {
+                    SendCastResult(SPELL_FAILED_INVALID_GLYPH);
+                    return;                                 // glyph slot mismatch
+                }
+            }
+
+            // remove old glyph
+            if (uint32 oldglyph = player->GetGlyph(m_glyphIndex))
+            {
+                if (GlyphPropertiesEntry const *old_gp = sGlyphPropertiesStore.LookupEntry(oldglyph))
+                {
+                    player->RemoveAurasDueToSpell(old_gp->SpellId);
+                    player->SetGlyph(m_glyphIndex, 0);
+                }
+            }
+
+            player->CastSpell(m_caster, gp->SpellId, true);
+            player->SetGlyph(m_glyphIndex, glyph);
+            player->SendTalentsInfoData(false);
+        }
+    }
+}
+
+void Spell::EffectEnchantHeldItem(SpellEffIndex effIndex)
+{
+    // this is only item spell effect applied to main-hand weapon of target player (players in area)
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* item_owner = (Player*)unitTarget;
+    Item* item = item_owner->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+    if (!item)
+        return;
+
+    // must be equipped
+    if (!item ->IsEquipped())
+        return;
+
+    if (m_spellInfo->EffectMiscValue[effIndex])
+    {
+        uint32 enchant_id = m_spellInfo->EffectMiscValue[effIndex];
+        int32 duration = GetSpellDuration(m_spellInfo);          //Try duration index first ..
+        if (!duration)
+            duration = damage;//+1;            //Base points after ..
+        if (!duration)
+            duration = 10;                                  //10 seconds for enchants which don't have listed duration
+
+        SpellItemEnchantmentEntry const *pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            return;
+
+        // Always go to temp enchantment slot
+        EnchantmentSlot slot = TEMP_ENCHANTMENT_SLOT;
+
+        // Enchantment will not be applied if a different one already exists
+        if (item->GetEnchantmentId(slot) && item->GetEnchantmentId(slot) != enchant_id)
+            return;
+
+        // Apply the temporary enchantment
+        item->SetEnchantment(slot, enchant_id, duration*IN_MILLISECONDS, 0);
+        item_owner->ApplyEnchantment(item, slot, true);
+    }
+}
+
+void Spell::EffectDisEnchant(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+    if (!itemTarget || !itemTarget->GetProto()->DisenchantID)
+        return;
+
+    p_caster->UpdateCraftSkill(m_spellInfo->Id);
+
+    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(),LOOT_DISENCHANTING);
+
+    // item will be removed at disenchanting end
+}
+
+void Spell::EffectInebriate(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *player = (Player*)unitTarget;
+    uint16 currentDrunk = player->GetDrunkValue();
+    uint16 drunkMod = damage * 256;
+    if (currentDrunk + drunkMod > 0xFFFF)
+        currentDrunk = 0xFFFF;
+    else
+        currentDrunk += drunkMod;
+    player->SetDrunkValue(currentDrunk, m_CastItem ? m_CastItem->GetEntry() : 0);
+}
+
+void Spell::EffectFeedPet(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)m_caster;
+
+    Item* foodItem = m_targets.getItemTarget();
+    if (!foodItem)
+        return;
+
+    Pet *pet = _player->GetPet();
+    if (!pet)
+        return;
+
+    if (!pet->isAlive())
+        return;
+
+    int32 benefit = pet->GetCurrentFoodBenefitLevel(foodItem->GetProto()->ItemLevel);
+    if (benefit <= 0)
+        return;
+
+    ExecuteLogEffectDestroyItem(effIndex, foodItem->GetEntry());
+
+    uint32 count = 1;
+    _player->DestroyItemCount(foodItem, count, true);
+    // TODO: fix crash when a spell has two effects, both pointed at the same item target
+
+    m_caster->CastCustomSpell(pet, m_spellInfo->EffectTriggerSpell[effIndex], &benefit, NULL, NULL, true);
+}
+
+void Spell::EffectDismissPet(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Pet* pet = m_caster->ToPlayer()->GetPet();
+
+    // not let dismiss dead pet
+    if (!pet||!pet->isAlive())
+        return;
+
+    ExecuteLogEffectUnsummonObject(effIndex, pet);
+    m_caster->ToPlayer()->RemovePet(pet, PET_SAVE_NOT_IN_SLOT);
+}
+
+void Spell::EffectSummonObject(SpellEffIndex effIndex)
+{
+    uint32 go_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    uint8 slot = 0;
+    switch(m_spellInfo->Effect[effIndex])
+    {
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT1: slot = 0; break;
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT2: slot = 1; break;
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT3: slot = 2; break;
+        case SPELL_EFFECT_SUMMON_OBJECT_SLOT4: slot = 3; break;
+        default: return;
+    }
+
+    uint64 guid = m_caster->m_ObjectSlot[slot];
+    if (guid != 0)
+    {
+        GameObject* obj = NULL;
+        if (m_caster)
+            obj = m_caster->GetMap()->GetGameObject(guid);
+
+        if (obj)
+        {
+            // Recast case - null spell id to make auras not be removed on object remove from world
+            if (m_spellInfo->Id == obj->GetSpellId())
+                obj->SetSpellId(0);
+            m_caster->RemoveGameObject(obj, true);
+        }
+        m_caster->m_ObjectSlot[slot] = 0;
+    }
+
+    GameObject* pGameObj = new GameObject;
+
+    float x, y, z;
+    // If dest location if present
+    if (m_targets.HasDst())
+        m_targets.m_dstPos.GetPosition(x, y, z);
+    // Summon in random point all other units if location present
+    else
+        m_caster->GetClosePoint(x, y, z, DEFAULT_WORLD_OBJECT_SIZE);
+
+    Map *map = m_caster->GetMap();
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), go_id, map,
+        m_caster->GetPhaseMask(), x, y, z, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL,m_caster->getLevel());
+    int32 duration = GetSpellDuration(m_spellInfo);
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+    pGameObj->SetSpellId(m_spellInfo->Id);
+    m_caster->AddGameObject(pGameObj);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    map->Add(pGameObj);
+
+    m_caster->m_ObjectSlot[slot] = pGameObj->GetGUID();
+}
+
+void Spell::EffectResurrect(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    if (unitTarget->isAlive())
+        return;
+    if (!unitTarget->IsInWorld())
+        return;
+
+    switch (m_spellInfo->Id)
+    {
+        // Defibrillate (Goblin Jumper Cables) have 33% chance on success
+        case 8342:
+            if (roll_chance_i(67))
+            {
+                m_caster->CastSpell(m_caster, 8338, true, m_CastItem);
+                return;
+            }
+            break;
+        // Defibrillate (Goblin Jumper Cables XL) have 50% chance on success
+        case 22999:
+            if (roll_chance_i(50))
+            {
+                m_caster->CastSpell(m_caster, 23055, true, m_CastItem);
+                return;
+            }
+            break;
+        // Defibrillate ( Gnomish Army Knife) have 67% chance on success_list
+        case 54732:
+            if (roll_chance_i(33))
+            {
+                return;
+            }
+            break;
+        default:
+            break;
+    }
+
+    Player* pTarget = unitTarget->ToPlayer();
+
+    if (pTarget->isRessurectRequested())       // already have one active request
+        return;
+
+    uint32 health = pTarget->CountPctFromMaxHealth(damage);
+    uint32 mana   = pTarget->GetMaxPower(POWER_MANA) * damage / 100;
+
+    ExecuteLogEffectResurrect(effIndex, pTarget);
+
+    pTarget->setResurrectRequestData(m_caster->GetGUID(), m_caster->GetMapId(), m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ(), health, mana);
+    SendResurrectRequest(pTarget);
+}
+
+void Spell::EffectAddExtraAttacks(SpellEffIndex effIndex)
+{
+    if (!unitTarget || !unitTarget->isAlive() || !unitTarget->getVictim())
+        return;
+
+    if (unitTarget->m_extraAttacks)
+        return;
+
+    unitTarget->m_extraAttacks = damage;
+
+    ExecuteLogEffectExtraAttacks(effIndex, unitTarget->getVictim(), damage);
+}
+
+void Spell::EffectParry(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->SetCanParry(true);
+}
+
+void Spell::EffectBlock(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->SetCanBlock(true);
+}
+
+void Spell::EffectLeap(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->isInFlight())
+        return;
+
+    if (!m_targets.HasDst())
+        return;
+
+    unitTarget->NearTeleportTo(m_targets.m_dstPos.GetPositionX(), m_targets.m_dstPos.GetPositionY(), m_targets.m_dstPos.GetPositionZ(), m_targets.m_dstPos.GetOrientation(), unitTarget == m_caster);
+}
+
+void Spell::EffectReputation(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *_player = (Player*)unitTarget;
+
+    int32  rep_change = damage;//+1;           // field store reputation change -1
+
+    uint32 faction_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id);
+
+    if (!factionEntry)
+        return;
+
+    if (RepRewardRate const * repData = sObjectMgr.GetRepRewardRate(faction_id))
+    {
+        rep_change = int32((float)rep_change * repData->spell_rate);
+    }
+
+    _player->GetReputationMgr().ModifyReputation(factionEntry, rep_change);
+}
+
+void Spell::EffectQuestComplete(SpellEffIndex effIndex)
+{
+    Player *pPlayer;
+
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = (Player*)m_caster;
+    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = (Player*)unitTarget;
+    else
+        return;
+
+    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
+    if (quest_id)
+    {
+        uint16 log_slot = pPlayer->FindQuestSlot(quest_id);
+        if (log_slot < MAX_QUEST_LOG_SIZE)
+            pPlayer->AreaExploredOrEventHappens(quest_id);
+        else if (!pPlayer->GetQuestRewardStatus(quest_id))   // never rewarded before
+            pPlayer->CompleteQuest(quest_id);   // quest not in log - for internal use
+    }
+}
+
+void Spell::EffectForceDeselect(SpellEffIndex /*effIndex*/)
+{
+    WorldPacket data(SMSG_CLEAR_TARGET, 8);
+    data << uint64(m_caster->GetGUID());
+    m_caster->SendMessageToSet(&data, true);
+}
+
+void Spell::EffectSelfResurrect(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->isAlive())
+        return;
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!unitTarget->IsInWorld())
+        return;
+
+    uint32 health = 0;
+    uint32 mana = 0;
+
+    // flat case
+    if (damage < 0)
+    {
+        health = uint32(-damage);
+        mana = m_spellInfo->EffectMiscValue[effIndex];
+    }
+    // percent case
+    else
+    {
+        health = unitTarget->CountPctFromMaxHealth(damage);
+        if (unitTarget->GetMaxPower(POWER_MANA) > 0)
+            mana = uint32(damage/100.0f*unitTarget->GetMaxPower(POWER_MANA));
+    }
+
+    Player *plr = unitTarget->ToPlayer();
+    plr->ResurrectPlayer(0.0f);
+
+    plr->SetHealth(health);
+    plr->SetPower(POWER_MANA, mana);
+    plr->SetPower(POWER_RAGE, 0);
+    plr->SetPower(POWER_ENERGY, plr->GetMaxPower(POWER_ENERGY));
+
+    plr->SpawnCorpseBones();
+}
+
+void Spell::EffectSkinning(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+        return;
+    if (!m_caster || m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Creature* creature = unitTarget->ToCreature();
+    int32 targetLevel = creature->getLevel();
+
+    uint32 skill = creature->GetCreatureInfo()->GetRequiredLootSkill();
+
+    m_caster->ToPlayer()->SendLoot(creature->GetGUID(),LOOT_SKINNING);
+    creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+
+    int32 reqValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel-10)*10 : targetLevel*5;
+
+    int32 skillValue = m_caster->ToPlayer()->GetPureSkillValue(skill);
+
+    // Double chances for elites
+    m_caster->ToPlayer()->UpdateGatherSkill(skill, skillValue, reqValue, creature->isElite() ? 2 : 1);
+}
+
+void Spell::EffectCharge(SpellEffIndex /*effIndex*/)
+{
+    Unit *target = m_targets.getUnitTarget();
+    if (!target)
+        return;
+
+    float x, y, z;
+    target->GetContactPoint(m_caster, x, y, z);
+    m_caster->GetMotionMaster()->MoveCharge(x, y, z);
+
+    // not all charge effects used in negative spells
+    if (!IsPositiveSpell(m_spellInfo->Id) && m_caster->GetTypeId() == TYPEID_PLAYER)
+        m_caster->Attack(target, true);
+}
+
+void Spell::EffectChargeDest(SpellEffIndex /*effIndex*/)
+{
+    if (m_targets.HasDst())
+    {
+        float x, y, z;
+        m_targets.m_dstPos.GetPosition(x, y, z);
+        m_caster->GetMotionMaster()->MoveCharge(x, y, z);
+    }
+}
+
+void Spell::EffectKnockBack(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    // Instantly interrupt non melee spells being casted
+    if (unitTarget->IsNonMeleeSpellCasted(true))
+        unitTarget->InterruptNonMeleeSpells(true);
+
+    // Typhoon
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && m_spellInfo->SpellFamilyFlags[1] & 0x01000000)
+    {
+        // Glyph of Typhoon
+        if (m_caster->HasAura(62135))
+            return;
+    }
+
+    // Thunderstorm
+    if (m_spellInfo->SpellFamilyName == SPELLFAMILY_SHAMAN && m_spellInfo->SpellFamilyFlags[1] & 0x00002000)
+    {
+        // Glyph of Thunderstorm
+        if (m_caster->HasAura(62132))
+            return;
+    }
+
+    float ratio = m_caster->GetCombatReach() / std::max(unitTarget->GetCombatReach(), 1.0f);
+    if (ratio < 1.0f)
+        ratio = ratio * ratio * ratio * 0.1f; // volume = length^3
+    else
+        ratio = 0.1f; // dbc value ratio
+    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex]) * ratio;
+    float speedz = float(damage) * ratio;
+    if (speedxy < 0.1f && speedz < 0.1f)
+        return;
+
+    float x, y;
+    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_KNOCK_BACK_DEST)
+    {
+        if (m_targets.HasDst())
+            m_targets.m_dstPos.GetPosition(x, y);
+        else
+            return;
+    }
+    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_KNOCK_BACK)
+    {
+        m_caster->GetPosition(x, y);
+    }
+
+    unitTarget->KnockbackFrom(x, y, speedxy, speedz);
+}
+
+void Spell::EffectLeapBack(SpellEffIndex effIndex)
+{
+    float speedxy = float(m_spellInfo->EffectMiscValue[effIndex])/10;
+    float speedz = float(damage/10);
+    if (!speedxy)
+    {
+        if (m_targets.getUnitTarget())
+            m_caster->JumpTo(m_targets.getUnitTarget(), speedz);
+    }
+    else
+    {
+        //1891: Disengage
+        m_caster->JumpTo(speedxy, speedz, m_spellInfo->SpellIconID != 1891);
+    }
+}
+
+void Spell::EffectQuestClear(SpellEffIndex effIndex)
+{
+    Player *pPlayer = NULL;
+    if (m_caster->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = m_caster->ToPlayer();
+    else if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        pPlayer = unitTarget->ToPlayer();
+
+    if (!pPlayer)
+        return;
+
+    uint32 quest_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest_id);
+
+    if (!pQuest)
+        return;
+
+    QuestStatusMap::iterator qs_itr = pPlayer->getQuestStatusMap().find(quest_id);
+    // Player has never done this quest
+    if (qs_itr == pPlayer->getQuestStatusMap().end())
+        return;
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 quest = pPlayer->GetQuestSlotQuestId(slot);
+        if (quest == quest_id)
+        {
+            pPlayer->SetQuestSlot(slot, 0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            pPlayer->TakeQuestSourceItem(quest, false);
+        }
+    }
+
+    // set quest status to not started (will be updated in DB at next save)
+    pPlayer->SetQuestStatus(quest_id, QUEST_STATUS_NONE);
+
+    // reset rewarded for restart repeatable quest
+    QuestStatusData &data = qs_itr->second;
+    data.m_rewarded = false;
+}
+
+void Spell::EffectSendTaxi(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->ActivateTaxiPathTo(m_spellInfo->EffectMiscValue[effIndex],m_spellInfo->Id);
+}
+
+void Spell::EffectPullTowards(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    float speedZ = (float)(SpellMgr::CalculateSpellEffectAmount(m_spellInfo, effIndex) / 10);
+    float speedXY = (float)(m_spellInfo->EffectMiscValue[effIndex]/10);
+    Position pos;
+    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_PULL_TOWARDS_DEST)
+    {
+        if (m_targets.HasDst())
+            pos.Relocate(m_targets.m_dstPos);
+        else
+            return;
+    }
+    else //if (m_spellInfo->Effect[i] == SPELL_EFFECT_PULL_TOWARDS)
+    {
+        pos.Relocate(m_caster);
+    }
+
+    unitTarget->GetMotionMaster()->MoveJump(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), speedXY, speedZ);
+}
+
+void Spell::EffectDispelMechanic(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+
+    uint32 mechanic = m_spellInfo->EffectMiscValue[effIndex];
+
+    std::queue < std::pair < uint32, uint64 > > dispel_list;
+
+    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura * aura = itr->second;
+        if (!aura->GetApplicationOfTarget(unitTarget->GetGUID()))
+            continue;
+        bool success = false;
+        GetDispelChance(aura->GetCaster(), unitTarget, aura->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success);
+        if ((GetAllSpellMechanicMask(aura->GetSpellProto()) & (1 << mechanic)) && success)
+            dispel_list.push(std::make_pair(aura->GetId(), aura->GetCasterGUID()));
+    }
+
+    for (; dispel_list.size(); dispel_list.pop())
+    {
+        unitTarget->RemoveAura(dispel_list.front().first, dispel_list.front().second, 0, AURA_REMOVE_BY_ENEMY_SPELL);
+    }
+}
+
+void Spell::EffectSummonDeadPet(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+    Player *_player = (Player*)m_caster;
+    Pet *pet = _player->GetPet();
+    if (!pet)
+        return;
+    if (pet->isAlive())
+        return;
+    if (damage < 0)
+        return;
+
+    float x,y,z;
+    _player->GetPosition(x, y, z);
+    _player->GetMap()->CreatureRelocation(pet, x, y, z, _player->GetOrientation());
+
+    pet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
+    pet->RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+    pet->setDeathState(ALIVE);
+    pet->clearUnitState(UNIT_STAT_ALL_STATE);
+    pet->SetHealth(pet->CountPctFromMaxHealth(damage));
+
+    //pet->AIM_Initialize();
+    //_player->PetSpellInitialize();
+    pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+}
+
+void Spell::EffectDestroyAllTotems(SpellEffIndex /*effIndex*/)
+{
+    int32 mana = 0;
+    for (uint8 slot = SUMMON_SLOT_TOTEM; slot < MAX_TOTEM_SLOT; ++slot)
+    {
+        if (!m_caster->m_SummonSlot[slot])
+            continue;
+
+        Creature* totem = m_caster->GetMap()->GetCreature(m_caster->m_SummonSlot[slot]);
+        if (totem && totem->isTotem())
+        {
+            uint32 spell_id = totem->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell_id);
+            if (spellInfo)
+            {
+                mana += spellInfo->manaCost;
+                mana += spellInfo->ManaCostPercentage * m_caster->GetCreateMana() / 100;
+            }
+            totem->ToTotem()->UnSummon();
+        }
+    }
+    mana = mana * damage / 100;
+
+    if (mana)
+        m_caster->CastCustomSpell(m_caster, 39104, &mana, NULL, NULL, true);
+}
+
+void Spell::EffectDurabilityDamage(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
+
+    // FIXME: some spells effects have value -1/-2
+    // Possibly its mean -1 all player equipped items and -2 all items
+    if (slot < 0)
+    {
+        unitTarget->ToPlayer()->DurabilityPointsLossAll(damage, (slot < -1));
+        return;
+    }
+
+    // invalid slot value
+    if (slot >= INVENTORY_SLOT_BAG_END)
+        return;
+
+    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        unitTarget->ToPlayer()->DurabilityPointsLoss(item, damage);
+
+    ExecuteLogEffectDurabilityDamage(effIndex, unitTarget, slot, damage);
+}
+
+void Spell::EffectDurabilityDamagePCT(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    int32 slot = m_spellInfo->EffectMiscValue[effIndex];
+
+    // FIXME: some spells effects have value -1/-2
+    // Possibly its mean -1 all player equipped items and -2 all items
+    if (slot < 0)
+    {
+        unitTarget->ToPlayer()->DurabilityLossAll(double(damage)/100.0f, (slot < -1));
+        return;
+    }
+
+    // invalid slot value
+    if (slot >= INVENTORY_SLOT_BAG_END)
+        return;
+
+    if (damage <= 0)
+        return;
+
+    if (Item* item = unitTarget->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        unitTarget->ToPlayer()->DurabilityLoss(item, double(damage)/100.0f);
+}
+
+void Spell::EffectModifyThreatPercent(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget)
+        return;
+
+    unitTarget->getThreatManager().modifyThreatPercent(m_caster, damage);
+}
+
+void Spell::EffectTransmitted(SpellEffIndex effIndex)
+{
+    uint32 name_id = m_spellInfo->EffectMiscValue[effIndex];
+
+    GameObjectInfo const* goinfo = sObjectMgr.GetGameObjectInfo(name_id);
+
+    if (!goinfo)
+    {
+        sLog.outErrorDb("Gameobject (Entry: %u) not exist and not created at spell (ID: %u) cast",name_id, m_spellInfo->Id);
+        return;
+    }
+
+    float fx, fy, fz;
+
+    if (m_targets.HasDst())
+        m_targets.m_dstPos.GetPosition(fx, fy, fz);
+    //FIXME: this can be better check for most objects but still hack
+    else if (m_spellInfo->EffectRadiusIndex[effIndex] && m_spellInfo->speed == 0)
+    {
+        float dis = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[effIndex]));
+        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
+    }
+    else
+    {
+        //GO is always friendly to it's creator, get range for friends
+        float min_dis = GetSpellMinRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
+        float max_dis = GetSpellMaxRangeForFriend(sSpellRangeStore.LookupEntry(m_spellInfo->rangeIndex));
+        float dis = (float)rand_norm() * (max_dis - min_dis) + min_dis;
+
+        m_caster->GetClosePoint(fx, fy, fz, DEFAULT_WORLD_OBJECT_SIZE, dis);
+    }
+
+    Map *cMap = m_caster->GetMap();
+    if (goinfo->type == GAMEOBJECT_TYPE_FISHINGNODE)
+    {
+        LiquidData liqData;
+        if ( !cMap->IsInWater(fx, fy, fz + 1.f/* -0.5f */, &liqData))             // Hack to prevent fishing bobber from failing to land on fishing hole
+        { // but this is not proper, we really need to ignore not materialized objects
+            SendCastResult(SPELL_FAILED_NOT_HERE);
+            SendChannelUpdate(0);
+            return;
+        }
+
+        // replace by water level in this case
+        //fz = cMap->GetWaterLevel(fx, fy);
+        fz = liqData.level;
+    }
+    // if gameobject is summoning object, it should be spawned right on caster's position
+    else if (goinfo->type == GAMEOBJECT_TYPE_SUMMONING_RITUAL)
+    {
+        m_caster->GetPosition(fx, fy, fz);
+    }
+
+    GameObject* pGameObj = new GameObject;
+
+    if (!pGameObj->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), name_id, cMap,
+        m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+    {
+        delete pGameObj;
+        return;
+    }
+
+    int32 duration = GetSpellDuration(m_spellInfo);
+
+    switch(goinfo->type)
+    {
+        case GAMEOBJECT_TYPE_FISHINGNODE:
+        {
+            m_caster->SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT,pGameObj->GetGUID());
+            m_caster->AddGameObject(pGameObj);              // will removed at spell cancel
+
+            // end time of range when possible catch fish (FISHING_BOBBER_READY_TIME..GetDuration(m_spellInfo))
+            // start time == fish-FISHING_BOBBER_READY_TIME (0..GetDuration(m_spellInfo)-FISHING_BOBBER_READY_TIME)
+            int32 lastSec = 0;
+            switch(urand(0, 3))
+            {
+                case 0: lastSec =  3; break;
+                case 1: lastSec =  7; break;
+                case 2: lastSec = 13; break;
+                case 3: lastSec = 17; break;
+            }
+
+            duration = duration - lastSec*IN_MILLISECONDS + FISHING_BOBBER_READY_TIME*IN_MILLISECONDS;
+            break;
+        }
+        case GAMEOBJECT_TYPE_SUMMONING_RITUAL:
+        {
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+            {
+          pGameObj->AddUniqueUse(m_caster->ToPlayer());
+          m_caster->AddGameObject(pGameObj);          // will removed at spell cancel
+            }
+            break;
+        }
+        case GAMEOBJECT_TYPE_DUEL_ARBITER: // 52991
+            m_caster->AddGameObject(pGameObj);
+            break;
+        case GAMEOBJECT_TYPE_FISHINGHOLE:
+        case GAMEOBJECT_TYPE_CHEST:
+        default:
+            break;
+    }
+
+    pGameObj->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+
+    pGameObj->SetOwnerGUID(m_caster->GetGUID());
+
+    //pGameObj->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
+    pGameObj->SetSpellId(m_spellInfo->Id);
+
+    ExecuteLogEffectSummonObject(effIndex, pGameObj);
+
+    sLog.outStaticDebug("AddObject at SpellEfects.cpp EffectTransmitted");
+    //m_caster->AddGameObject(pGameObj);
+    //m_ObjToDel.push_back(pGameObj);
+
+    cMap->Add(pGameObj);
+
+    if (uint32 linkedEntry = pGameObj->GetGOInfo()->GetLinkedGameObjectEntry())
+    {
+        GameObject* linkedGO = new GameObject;
+        if (linkedGO->Create(sObjectMgr.GenerateLowGuid(HIGHGUID_GAMEOBJECT), linkedEntry, cMap,
+            m_caster->GetPhaseMask(), fx, fy, fz, m_caster->GetOrientation(), 0.0f, 0.0f, 0.0f, 0.0f, 100, GO_STATE_READY))
+        {
+            linkedGO->SetRespawnTime(duration > 0 ? duration/IN_MILLISECONDS : 0);
+            //linkedGO->SetUInt32Value(GAMEOBJECT_LEVEL, m_caster->getLevel());
+            linkedGO->SetSpellId(m_spellInfo->Id);
+            linkedGO->SetOwnerGUID(m_caster->GetGUID());
+
+            ExecuteLogEffectSummonObject(effIndex, linkedGO);
+
+            linkedGO->GetMap()->Add(linkedGO);
+        }
+        else
+        {
+            delete linkedGO;
+            linkedGO = NULL;
+            return;
+        }
+    }
+}
+
+void Spell::EffectProspecting(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_PROSPECTABLE))
+        return;
+
+    if (itemTarget->GetCount() < 5)
+        return;
+
+    if (sWorld.getBoolConfig(CONFIG_SKILL_PROSPECTING))
+    {
+        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_JEWELCRAFTING);
+        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
+        p_caster->UpdateGatherSkill(SKILL_JEWELCRAFTING, SkillValue, reqSkillValue);
+    }
+
+    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_PROSPECTING);
+}
+
+void Spell::EffectMilling(SpellEffIndex /*effIndex*/)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* p_caster = (Player*)m_caster;
+    if (!itemTarget || !(itemTarget->GetProto()->Flags & ITEM_PROTO_FLAG_MILLABLE))
+        return;
+
+    if (itemTarget->GetCount() < 5)
+        return;
+
+    if (sWorld.getBoolConfig(CONFIG_SKILL_MILLING))
+    {
+        uint32 SkillValue = p_caster->GetPureSkillValue(SKILL_INSCRIPTION);
+        uint32 reqSkillValue = itemTarget->GetProto()->RequiredSkillRank;
+        p_caster->UpdateGatherSkill(SKILL_INSCRIPTION, SkillValue, reqSkillValue);
+    }
+
+    m_caster->ToPlayer()->SendLoot(itemTarget->GetGUID(), LOOT_MILLING);
+}
+
+void Spell::EffectSkill(SpellEffIndex /*effIndex*/)
+{
+    sLog.outDebug("WORLD: SkillEFFECT");
+}
+
+/* There is currently no need for this effect. We handle it in Battleground.cpp
+   If we would handle the resurrection here, the spiritguide would instantly disappear as the
+   player revives, and so we wouldn't see the spirit heal visual effect on the npc.
+   This is why we use a half sec delay between the visual effect and the resurrection itself */
+void Spell::EffectSpiritHeal(SpellEffIndex /*effIndex*/)
+{
+    /*
+    if (!unitTarget || unitTarget->isAlive())
+        return;
+    if (unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    if (!unitTarget->IsInWorld())
+        return;
+
+    //m_spellInfo->EffectBasePoints[i]; == 99 (percent?)
+    //unitTarget->ToPlayer()->setResurrect(m_caster->GetGUID(), unitTarget->GetPositionX(), unitTarget->GetPositionY(), unitTarget->GetPositionZ(), unitTarget->GetMaxHealth(), unitTarget->GetMaxPower(POWER_MANA));
+    unitTarget->ToPlayer()->ResurrectPlayer(1.0f);
+    unitTarget->ToPlayer()->SpawnCorpseBones();
+    */
+}
+
+// remove insignia spell effect
+void Spell::EffectSkinPlayerCorpse(SpellEffIndex /*effIndex*/)
+{
+    sLog.outDebug("Effect: SkinPlayerCorpse");
+    if ((m_caster->GetTypeId() != TYPEID_PLAYER) || (unitTarget->GetTypeId() != TYPEID_PLAYER) || (unitTarget->isAlive()))
+        return;
+
+    unitTarget->ToPlayer()->RemovedInsignia((Player*)m_caster);
+}
+
+void Spell::EffectStealBeneficialBuff(SpellEffIndex effIndex)
+{
+    sLog.outDebug("Effect: StealBeneficialBuff");
+
+    if (!unitTarget || unitTarget == m_caster)                 // can't steal from self
+        return;
+
+    DispelChargesList steal_list;
+
+    // Create dispel mask by dispel type
+    uint32 dispelMask  = GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[effIndex]));
+    Unit::AuraMap const& auras = unitTarget->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura * aura = itr->second;
+        AuraApplication * aurApp = aura->GetApplicationOfTarget(unitTarget->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if ((1<<aura->GetSpellProto()->Dispel) & dispelMask)
+        {
+            // Need check for passive? this
+            if (!aurApp->IsPositive() || aura->IsPassive() || aura->GetSpellProto()->AttributesEx4 & SPELL_ATTR_EX4_NOT_STEALABLE)
+                continue;
+
+            // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
+            // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
+            // Polymorph instead of 1 / (5 + 1) -> 16%.
+            bool dispel_charges = aura->GetSpellProto()->AttributesEx7 & SPELL_ATTR_EX7_DISPEL_CHARGES;
+            uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                steal_list.push_back(std::make_pair(aura, charges));
+        }
+    }
+
+    if (steal_list.empty())
+        return;
+
+    // Ok if exist some buffs for dispel try dispel it
+    uint32 failCount = 0;
+    DispelList success_list;
+    WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+damage*4);
+    // dispel N = damage buffs (or while exist buffs for dispel)
+    for (int32 count = 0; count < damage && !steal_list.empty();)
+    {
+        // Random select buff for dispel
+        DispelChargesList::iterator itr = steal_list.begin();
+        std::advance(itr, urand(0, steal_list.size() - 1));
+
+        bool success = false;
+        // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
+        if (!GetDispelChance(itr->first->GetCaster(), unitTarget, itr->first->GetId(), !unitTarget->IsFriendlyTo(m_caster), &success))
+        {
+            steal_list.erase(itr);
+            continue;
+        }
+        else
+        {
+            if (success)
+            {
+                success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
+                --itr->second;
+                if (itr->second <= 0)
+                    steal_list.erase(itr);
+            }
+            else
+            {
+                if (!failCount)
+                {
+                    // Failed to dispell
+                    dataFail << uint64(m_caster->GetGUID());            // Caster GUID
+                    dataFail << uint64(unitTarget->GetGUID());          // Victim GUID
+                    dataFail << uint32(m_spellInfo->Id);                // dispel spell id
+                }
+                ++failCount;
+                dataFail << uint32(itr->first->GetId());                         // Spell Id
+            }
+            ++count;
+        }
+    }
+
+    if (failCount)
+        m_caster->SendMessageToSet(&dataFail, true);
+
+    if (success_list.empty())
+        return;
+
+    WorldPacket dataSuccess(SMSG_SPELLSTEALLOG, 8+8+4+1+4+damage*5);
+    dataSuccess.append(unitTarget->GetPackGUID());  // Victim GUID
+    dataSuccess.append(m_caster->GetPackGUID());    // Caster GUID
+    dataSuccess << uint32(m_spellInfo->Id);         // dispel spell id
+    dataSuccess << uint8(0);                        // not used
+    dataSuccess << uint32(success_list.size());     // count
+    for (DispelList::iterator itr = success_list.begin(); itr!=success_list.end(); ++itr)
+    {
+        dataSuccess << uint32(itr->first);          // Spell Id
+        dataSuccess << uint8(0);                    // 0 - steals !=0 transfers
+        unitTarget->RemoveAurasDueToSpellBySteal(itr->first, itr->second, m_caster);
+    }
+    m_caster->SendMessageToSet(&dataSuccess, true);
+}
+
+void Spell::EffectKillCreditPersonal(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->KilledMonsterCredit(m_spellInfo->EffectMiscValue[effIndex], 0);
+}
+
+void Spell::EffectKillCredit(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    int32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
+    if (!creatureEntry)
+    {
+        if (m_spellInfo->Id == 42793) // Burn Body
+            creatureEntry = 24008; // Fallen Combatant
+    }
+
+    if (creatureEntry)
+        unitTarget->ToPlayer()->RewardPlayerAndGroupAtEvent(creatureEntry, unitTarget);
+}
+
+void Spell::EffectQuestFail(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->FailQuest(m_spellInfo->EffectMiscValue[effIndex]);
+}
+
+void Spell::EffectQuestStart(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player * player = unitTarget->ToPlayer();
+    if (Quest const* qInfo = sObjectMgr.GetQuestTemplate(m_spellInfo->EffectMiscValue[effIndex]))
+    {
+        if (player->CanTakeQuest(qInfo, false) && player->CanAddQuest(qInfo, false))
+        {
+            player->AddQuest(qInfo, NULL);
+        }
+    }
+}
+
+void Spell::EffectActivateRune(SpellEffIndex effIndex)
+{
+    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *plr = (Player*)m_caster;
+
+    if (plr->getClass() != CLASS_DEATH_KNIGHT)
+        return;
+
+    // needed later
+    m_runesState = m_caster->ToPlayer()->GetRunesState();
+
+    uint32 count = damage;
+    if (count == 0) count = 1;
+    for (uint32 j = 0; j < MAX_RUNES && count > 0; ++j)
+    {
+        if (plr->GetRuneCooldown(j) && plr->GetCurrentRune(j) == RuneType(m_spellInfo->EffectMiscValue[effIndex]))
+        {
+            plr->SetRuneCooldown(j, 0);
+            --count;
+        }
+    }
+    // Empower rune weapon
+    if (m_spellInfo->Id == 47568)
+    {
+        // Need to do this just once
+        if (effIndex != 0)
+            return;
+
+        for (uint32 i = 0; i < MAX_RUNES; ++i)
+        {
+            if (plr->GetRuneCooldown(i) && (plr->GetCurrentRune(i) == RUNE_FROST ||  plr->GetCurrentRune(i) == RUNE_DEATH))
+                plr->SetRuneCooldown(i, 0);
+        }
+    }
+}
+
+void Spell::EffectCreateTamedPet(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER || unitTarget->GetPetGUID() || unitTarget->getClass() != CLASS_HUNTER)
+        return;
+
+    uint32 creatureEntry = m_spellInfo->EffectMiscValue[effIndex];
+    Pet * pet = unitTarget->CreateTamedPetFrom(creatureEntry, m_spellInfo->Id);
+    if (!pet)
+        return;
+
+    // add to world
+    pet->GetMap()->Add(pet->ToCreature());
+
+    // unitTarget has pet now
+    unitTarget->SetMinion(pet, true);
+
+    pet->InitTalentForLevel();
+
+    if (unitTarget->GetTypeId() == TYPEID_PLAYER)
+    {
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        unitTarget->ToPlayer()->PetSpellInitialize();
+    }
+}
+
+void Spell::EffectDiscoverTaxi(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+    uint32 nodeid = m_spellInfo->EffectMiscValue[effIndex];
+    if (sTaxiNodesStore.LookupEntry(nodeid))
+        unitTarget->ToPlayer()->GetSession()->SendDiscoverNewTaxiNode(nodeid);
+}
+
+void Spell::EffectTitanGrip(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget && unitTarget->GetTypeId() == TYPEID_PLAYER)
+        unitTarget->ToPlayer()->SetCanTitanGrip(true);
+}
+
+void Spell::EffectRedirectThreat(SpellEffIndex /*effIndex*/)
+{
+    if (unitTarget)
+        m_caster->SetReducedThreatPercent((uint32)damage, unitTarget->GetGUID());
+}
+
+void Spell::EffectWMODamage(SpellEffIndex /*effIndex*/)
+{
+    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        Unit *caster = m_originalCaster;
+        if (!caster)
+            return;
+
+        FactionTemplateEntry const *casterft, *goft;
+        casterft = caster->getFactionTemplateEntry();
+        goft = sFactionTemplateStore.LookupEntry(gameObjTarget->GetUInt32Value(GAMEOBJECT_FACTION));
+        // Do not allow to damage GO's of friendly factions (ie: Wintergrasp Walls)
+        if (casterft && goft && !casterft->IsFriendlyTo(*goft))
+        {
+            gameObjTarget->TakenDamage(uint32(damage), caster);
+            WorldPacket data(SMSG_DESTRUCTIBLE_BUILDING_DAMAGE, 8+8+8+4+4);
+            data.append(gameObjTarget->GetPackGUID());
+            data.append(caster->GetPackGUID());
+            if (Unit *who = caster->GetCharmerOrOwner())
+                data.append(who->GetPackGUID());
+            else
+                data << uint8(0);
+            data << uint32(damage);
+            data << uint32(m_spellInfo->Id);
+            gameObjTarget->SendMessageToSet(&data, false);
+        }
+    }
+}
+
+void Spell::EffectWMORepair(SpellEffIndex /*effIndex*/)
+{
+    if (gameObjTarget && gameObjTarget->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        gameObjTarget->Rebuild();
+}
+
+void Spell::SummonGuardian(uint32 i, uint32 entry, SummonPropertiesEntry const *properties)
+{
+    Unit *caster = m_originalCaster;
+    if (!caster)
+        return;
+
+    if (caster->isTotem())
+      caster = caster->ToTotem()->GetOwner();
+
+    // in another case summon new
+    uint8 level = caster->getLevel();
+
+    // level of pet summoned using engineering item based at engineering skill level
+    if (m_CastItem && caster->GetTypeId() == TYPEID_PLAYER)
+        if (ItemPrototype const *proto = m_CastItem->GetProto())
+            if (proto->RequiredSkill == SKILL_ENGINERING)
+                if (uint16 skill202 = caster->ToPlayer()->GetSkillValue(SKILL_ENGINERING))
+                    level = skill202/5;
+
+    //float radius = GetSpellRadiusForFriend(sSpellRadiusStore.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
+    float radius = 5.0f;
+    uint32 amount = damage > 0 ? damage : 1;
+    int32 duration = GetSpellDuration(m_spellInfo);
+    switch (m_spellInfo->Id)
+    {
+        case 1122: // Inferno
+            amount = 1;
+            break;
+        case 49028: // Dancing Rune Weapon
+            if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(63330, 0)) // glyph of Dancing Rune Weapon
+                duration += aurEff->GetAmount();
+            break;
+    }
+    if (Player* modOwner = m_originalCaster->GetSpellModOwner())
+        modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
+
+    //TempSummonType summonType = (duration == 0) ? TEMPSUMMON_DEAD_DESPAWN : TEMPSUMMON_TIMED_DESPAWN;
+    Map *map = caster->GetMap();
+
+    for (uint32 count = 0; count < amount; ++count)
+    {
+        Position pos;
+        GetSummonPosition(i, pos, radius, count);
+
+        TempSummon *summon = map->SummonCreature(entry, pos, properties, duration, caster);
+        if (!summon)
+            return;
+        if (summon->HasUnitTypeMask(UNIT_MASK_GUARDIAN))
+            ((Guardian*)summon)->InitStatsForLevel(level);
+
+        summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, m_spellInfo->Id);
+        if (summon->HasUnitTypeMask(UNIT_MASK_MINION) && m_targets.HasDst())
+            ((Minion*)summon)->SetFollowAngle(m_caster->GetAngle(summon));
+
+        if (summon->GetEntry() == 27893)
+        {
+            if (uint32 weapon = m_caster->GetUInt32Value(PLAYER_VISIBLE_ITEM_16_ENTRYID))
+            {
+                summon->SetDisplayId(11686);
+                summon->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, weapon);
+            }
+            else
+                summon->SetDisplayId(1126);
+        }
+
+        summon->AI()->EnterEvadeMode();
+
+        ExecuteLogEffectSummonObject(i, summon);
+    }
+}
+
+void Spell::GetSummonPosition(uint32 i, Position &pos, float radius, uint32 count)
+{
+    pos.SetOrientation(m_caster->GetOrientation());
+
+    if (m_targets.HasDst())
+    {
+        // Summon 1 unit in dest location
+        if (count == 0)
+            pos.Relocate(m_targets.m_dstPos);
+        // Summon in random point all other units if location present
+        else
+        {
+            //This is a workaround. Do not have time to write much about it
+            switch (m_spellInfo->EffectImplicitTargetA[i])
+            {
+                case TARGET_MINION:
+                case TARGET_DEST_CASTER_RANDOM:
+                    m_caster->GetNearPosition(pos, radius * (float)rand_norm(), (float)rand_norm()*static_cast<float>(2*M_PI));
+                    break;
+                case TARGET_DEST_DEST_RANDOM:
+                case TARGET_DEST_TARGET_RANDOM:
+                    m_caster->GetRandomPoint(m_targets.m_dstPos, radius, pos);
+                    break;
+                default:
+                    pos.Relocate(m_targets.m_dstPos);
+                    break;
+            }
+        }
+    }
+    // Summon if dest location not present near caster
+    else
+    {
+        float x, y, z;
+        m_caster->GetClosePoint(x,y,z,3.0f);
+        pos.Relocate(x, y, z);
+    }
+}
+
+void Spell::EffectRenamePet(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_UNIT ||
+        !unitTarget->ToCreature()->isPet() || ((Pet*)unitTarget)->getPetType() != HUNTER_PET)
+        return;
+
+    unitTarget->RemoveByteFlag(UNIT_FIELD_BYTES_2, 2, UNIT_CAN_BE_RENAMED);
+}
+
+void Spell::EffectPlayMusic(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    uint32 soundid = m_spellInfo->EffectMiscValue[effIndex];
+
+    if (!sSoundEntriesStore.LookupEntry(soundid))
+    {
+        sLog.outError("EffectPlayMusic: Sound (Id: %u) not exist in spell %u.",soundid,m_spellInfo->Id);
+        return;
+    }
+
+    WorldPacket data(SMSG_PLAY_MUSIC, 4);
+    data << uint32(soundid);
+    unitTarget->ToPlayer()->GetSession()->SendPacket(&data);
+}
+
+void Spell::EffectSpecCount(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->UpdateSpecCount(damage);
+}
+
+void Spell::EffectActivateSpec(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    unitTarget->ToPlayer()->ActivateSpec(damage-1);  // damage is 1 or 2, spec is 0 or 1
+}
+
+void Spell::EffectPlayerNotification(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
+
+    switch(m_spellInfo->Id)
+    {
+        case 58730: // Restricted Flight Area
+           {
+             if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+              {
+              if (pvpWG->isWarTime()==true)
+               {
+                unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+                unitTarget->PlayDirectSound(9417); // Fel Reaver sound
+                unitTarget->MonsterTextEmote("The air is too thin in Wintergrasp for normal flight. You will be ejected in 9 sec.",unitTarget->GetGUID(),true);
+               break;
+               } else unitTarget->RemoveAura(58730);
+              }
+            break;
+            }
+        case 58600: // Restricted Flight Area
+            unitTarget->ToPlayer()->GetSession()->SendNotification(LANG_ZONE_NOFLYZONE);
+            break;
+    }
+}
+
+void Spell::EffectRemoveAura(SpellEffIndex effIndex)
+{
+    if (!unitTarget)
+        return;
+    // there may be need of specifying casterguid of removed auras
+    unitTarget->RemoveAurasDueToSpell(m_spellInfo->EffectTriggerSpell[effIndex]);
+}
+
+void Spell::EffectCastButtons(SpellEffIndex effIndex)
+{
+    if (!unitTarget || m_caster->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *p_caster = (Player*)m_caster;
+    uint32 button_id = m_spellInfo->EffectMiscValue[effIndex] + 132;
+    uint32 n_buttons = m_spellInfo->EffectMiscValueB[effIndex];
+
+    for (; n_buttons; n_buttons--, button_id++)
+    {
+        ActionButton const* ab = p_caster->GetActionButton(button_id);
+        if (!ab || ab->GetType() != ACTION_BUTTON_SPELL)
+            continue;
+
+        uint32 spell_id = ab->GetAction();
+        if (!spell_id)
+            continue;
+
+        if (p_caster->HasSpellCooldown(spell_id))
+            continue;
+
+        SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell_id);
+        uint32 cost = CalculatePowerCost(spellInfo, m_caster, GetSpellSchoolMask(spellInfo));
+
+        if (m_caster->GetPower(POWER_MANA) < cost)
+            break;
+
+        m_caster->CastSpell(unitTarget, spell_id, true);
+        m_caster->ModifyPower(POWER_MANA, -(int32)cost);
+        p_caster->AddSpellAndCategoryCooldowns(spellInfo, 0);
+    }
+}
+
+void Spell::EffectRechargeManaGem(SpellEffIndex /*effIndex*/)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player *player = m_caster->ToPlayer();
+
+    if (!player)
+        return;
+
+    uint32 item_id = m_spellInfo->EffectItemType[0];
+
+    ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(item_id);
+    if (!pProto)
+    {
+        player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+        return;
+    }
+
+    if (Item* pItem = player->GetItemByEntry(item_id))
+    {
+        for (int x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
+            pItem->SetSpellCharges(x,pProto->Spells[x].SpellCharges);
+        pItem->SetState(ITEM_CHANGED,player);
+    }
+}
+
+void Spell::EffectBind(SpellEffIndex effIndex)
+{
+    if (!unitTarget || unitTarget->GetTypeId() != TYPEID_PLAYER)
+        return;
+
+    Player* player = (Player*)unitTarget;
+
+    uint32 area_id;
+    WorldLocation loc;
+    if (m_spellInfo->EffectImplicitTargetA[effIndex] == TARGET_DST_DB || m_spellInfo->EffectImplicitTargetB[effIndex] == TARGET_DST_DB)
+    {
+        SpellTargetPosition const* st = sSpellMgr.GetSpellTargetPosition(m_spellInfo->Id);
+        if (!st)
+        {
+            sLog.outError( "Spell::EffectBind - unknown teleport coordinates for spell ID %u", m_spellInfo->Id );
+            return;
+        }
+
+        loc.m_mapId         = st->target_mapId;
+        loc.m_positionX   = st->target_X;
+        loc.m_positionY   = st->target_Y;
+        loc.m_positionZ   = st->target_Y;
+        loc.m_orientation = st->target_Orientation;
+        area_id = player->GetAreaId();
+    }
+    else
+    {
+        player->GetPosition(&loc);
+        area_id = player->GetAreaId();
+    }
+
+    player->SetHomebind(loc, area_id);
+
+    // binding
+    WorldPacket data( SMSG_BINDPOINTUPDATE, (4+4+4+4+4) );
+    data << float(loc.m_positionX);
+    data << float(loc.m_positionY);
+    data << float(loc.m_positionZ);
+    data << uint32(loc.m_mapId);
+    data << uint32(area_id);
+    player->SendDirectMessage( &data );
+
+    sLog.outStaticDebug("New homebind X      : %f", loc.m_positionX);
+    sLog.outStaticDebug("New homebind Y      : %f", loc.m_positionY);
+    sLog.outStaticDebug("New homebind Z      : %f", loc.m_positionZ);
+    sLog.outStaticDebug("New homebind MapId  : %u", loc.m_mapId);
+    sLog.outStaticDebug("New homebind AreaId : %u", area_id);
+
+    // zone update
+    data.Initialize(SMSG_PLAYERBOUND, 8+4);
+    data << uint64(player->GetGUID());
+    data << uint32(area_id);
+    player->SendDirectMessage( &data );
+}
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -1,4076 +1,4078 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "SpellMgr.h"
-#include "ObjectMgr.h"
-#include "SpellAuraDefines.h"
-#include "ProgressBar.h"
-#include "DBCStores.h"
-#include "World.h"
-#include "Chat.h"
-#include "Spell.h"
-#include "BattlegroundMgr.h"
-#include "CreatureAI.h"
-#include "MapManager.h"
-#include "OutdoorPvPMgr.h"
-#include "OutdoorPvPWG.h"
-
-bool IsAreaEffectTarget[TOTAL_SPELL_TARGETS];
-SpellEffectTargetTypes EffectTargetType[TOTAL_SPELL_EFFECTS];
-SpellSelectTargetTypes SpellTargetType[TOTAL_SPELL_TARGETS];
-
-SpellMgr::SpellMgr()
-{
-    for (int i = 0; i < TOTAL_SPELL_EFFECTS; ++i)
-    {
-        switch(i)
-        {
-            case SPELL_EFFECT_PERSISTENT_AREA_AURA: //27
-            case SPELL_EFFECT_SUMMON:               //28
-            case SPELL_EFFECT_TRIGGER_MISSILE:      //32
-            case SPELL_EFFECT_TRANS_DOOR:           //50 summon object
-            case SPELL_EFFECT_SUMMON_PET:           //56
-            case SPELL_EFFECT_ADD_FARSIGHT:         //72
-            case SPELL_EFFECT_SUMMON_OBJECT_WILD:   //76
-            //case SPELL_EFFECT_SUMMON_CRITTER:       //97 not 303
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT1:  //104
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT2:  //105
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT3:  //106
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT4:  //107
-            case SPELL_EFFECT_SUMMON_DEAD_PET:      //109
-            case SPELL_EFFECT_TRIGGER_SPELL_2:      //151 ritual of summon
-                EffectTargetType[i] = SPELL_REQUIRE_DEST;
-                break;
-            case SPELL_EFFECT_PARRY: // 0
-            case SPELL_EFFECT_BLOCK: // 0
-            case SPELL_EFFECT_SKILL: // always with dummy 3 as A
-            //case SPELL_EFFECT_LEARN_SPELL: // 0 may be 5 pet
-            case SPELL_EFFECT_TRADE_SKILL: // 0 or 1
-            case SPELL_EFFECT_PROFICIENCY: // 0
-                EffectTargetType[i] = SPELL_REQUIRE_NONE;
-                break;
-            case SPELL_EFFECT_ENCHANT_ITEM:
-            case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
-            case SPELL_EFFECT_DISENCHANT:
-            //in 243 this is 0, in 309 it is 1
-            //so both item target and unit target is pushed, and cause crash
-            //case SPELL_EFFECT_FEED_PET:
-            case SPELL_EFFECT_PROSPECTING:
-            case SPELL_EFFECT_MILLING:
-            case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
-                EffectTargetType[i] = SPELL_REQUIRE_ITEM;
-                break;
-            //caster must be pushed otherwise no sound
-            case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
-            case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
-            case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
-            case SPELL_EFFECT_APPLY_AREA_AURA_PET:
-            case SPELL_EFFECT_APPLY_AREA_AURA_OWNER:
-            case SPELL_EFFECT_APPLY_AREA_AURA_RAID:
-            case SPELL_EFFECT_CHARGE:
-            case SPELL_EFFECT_CHARGE_DEST:
-            case SPELL_EFFECT_JUMP:
-            case SPELL_EFFECT_JUMP_DEST:
-            case SPELL_EFFECT_LEAP_BACK:
-                EffectTargetType[i] = SPELL_REQUIRE_CASTER;
-                break;
-            //case SPELL_EFFECT_WMO_DAMAGE:
-            //case SPELL_EFFECT_WMO_REPAIR:
-            //case SPELL_EFFECT_WMO_CHANGE:
-            //    EffectTargetType[i] = SPELL_REQUIRE_GOBJECT;
-            //    break;
-            default:
-                EffectTargetType[i] = SPELL_REQUIRE_UNIT;
-                break;
-        }
-    }
-
-    for (int i = 0; i < TOTAL_SPELL_TARGETS; ++i)
-    {
-        switch(i)
-        {
-            case TARGET_UNIT_CASTER:
-            case TARGET_UNIT_CASTER_FISHING:
-            case TARGET_UNIT_MASTER:
-            case TARGET_UNIT_PET:
-            case TARGET_UNIT_PARTY_CASTER:
-            case TARGET_UNIT_RAID_CASTER:
-            case TARGET_UNIT_VEHICLE:
-            case TARGET_UNIT_PASSENGER_0:
-            case TARGET_UNIT_PASSENGER_1:
-            case TARGET_UNIT_PASSENGER_2:
-            case TARGET_UNIT_PASSENGER_3:
-            case TARGET_UNIT_PASSENGER_4:
-            case TARGET_UNIT_PASSENGER_5:
-            case TARGET_UNIT_PASSENGER_6:
-            case TARGET_UNIT_PASSENGER_7:
-            case TARGET_UNIT_SUMMONER:
-                SpellTargetType[i] = TARGET_TYPE_UNIT_CASTER;
-                break;
-            case TARGET_UNIT_TARGET_PUPPET:
-            case TARGET_UNIT_TARGET_ALLY:
-            case TARGET_UNIT_TARGET_RAID:
-            case TARGET_UNIT_TARGET_ANY:
-            case TARGET_UNIT_TARGET_ENEMY:
-            case TARGET_UNIT_TARGET_PARTY:
-            case TARGET_UNIT_PARTY_TARGET:
-            case TARGET_UNIT_CLASS_TARGET:
-            case TARGET_UNIT_CHAINHEAL:
-                SpellTargetType[i] = TARGET_TYPE_UNIT_TARGET;
-                break;
-            case TARGET_UNIT_NEARBY_ENEMY:
-            case TARGET_UNIT_NEARBY_ALLY:
-            case TARGET_UNIT_NEARBY_ALLY_UNK:
-            case TARGET_UNIT_NEARBY_ENTRY:
-            case TARGET_UNIT_NEARBY_RAID:
-            case TARGET_GAMEOBJECT_NEARBY_ENTRY:
-                SpellTargetType[i] = TARGET_TYPE_UNIT_NEARBY;
-                break;
-            case TARGET_UNIT_AREA_ENEMY_SRC:
-            case TARGET_UNIT_AREA_ALLY_SRC:
-            case TARGET_UNIT_AREA_ENTRY_SRC:
-            case TARGET_UNIT_AREA_PARTY_SRC:
-            case TARGET_GAMEOBJECT_AREA_SRC:
-                SpellTargetType[i] = TARGET_TYPE_AREA_SRC;
-                break;
-            case TARGET_UNIT_AREA_ENEMY_DST:
-            case TARGET_UNIT_AREA_ALLY_DST:
-            case TARGET_UNIT_AREA_ENTRY_DST:
-            case TARGET_UNIT_AREA_PARTY_DST:
-            case TARGET_GAMEOBJECT_AREA_DST:
-                SpellTargetType[i] = TARGET_TYPE_AREA_DST;
-                break;
-            case TARGET_UNIT_CONE_ENEMY:
-            case TARGET_UNIT_CONE_ALLY:
-            case TARGET_UNIT_CONE_ENTRY:
-            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
-            case TARGET_UNIT_AREA_PATH:
-            case TARGET_GAMEOBJECT_AREA_PATH:
-                SpellTargetType[i] = TARGET_TYPE_AREA_CONE;
-                break;
-            case TARGET_DST_CASTER:
-            case TARGET_SRC_CASTER:
-            case TARGET_MINION:
-            case TARGET_DEST_CASTER_FRONT_LEAP:
-            case TARGET_DEST_CASTER_FRONT:
-            case TARGET_DEST_CASTER_BACK:
-            case TARGET_DEST_CASTER_RIGHT:
-            case TARGET_DEST_CASTER_LEFT:
-            case TARGET_DEST_CASTER_FRONT_LEFT:
-            case TARGET_DEST_CASTER_BACK_LEFT:
-            case TARGET_DEST_CASTER_BACK_RIGHT:
-            case TARGET_DEST_CASTER_FRONT_RIGHT:
-            case TARGET_DEST_CASTER_RANDOM:
-            case TARGET_DEST_CASTER_RADIUS:
-                SpellTargetType[i] = TARGET_TYPE_DEST_CASTER;
-                break;
-            case TARGET_DST_TARGET_ENEMY:
-            case TARGET_DEST_TARGET_ANY:
-            case TARGET_DEST_TARGET_FRONT:
-            case TARGET_DEST_TARGET_BACK:
-            case TARGET_DEST_TARGET_RIGHT:
-            case TARGET_DEST_TARGET_LEFT:
-            case TARGET_DEST_TARGET_FRONT_LEFT:
-            case TARGET_DEST_TARGET_BACK_LEFT:
-            case TARGET_DEST_TARGET_BACK_RIGHT:
-            case TARGET_DEST_TARGET_FRONT_RIGHT:
-            case TARGET_DEST_TARGET_RANDOM:
-            case TARGET_DEST_TARGET_RADIUS:
-                SpellTargetType[i] = TARGET_TYPE_DEST_TARGET;
-                break;
-            case TARGET_DEST_DYNOBJ_ENEMY:
-            case TARGET_DEST_DYNOBJ_ALLY:
-            case TARGET_DEST_DYNOBJ_NONE:
-            case TARGET_DEST_DEST:
-            case TARGET_DEST_TRAJ:
-            case TARGET_DEST_DEST_FRONT_LEFT:
-            case TARGET_DEST_DEST_BACK_LEFT:
-            case TARGET_DEST_DEST_BACK_RIGHT:
-            case TARGET_DEST_DEST_FRONT_RIGHT:
-            case TARGET_DEST_DEST_FRONT:
-            case TARGET_DEST_DEST_BACK:
-            case TARGET_DEST_DEST_RIGHT:
-            case TARGET_DEST_DEST_LEFT:
-            case TARGET_DEST_DEST_RANDOM:
-            case TARGET_DEST_DEST_RANDOM_DIR_DIST:
-                SpellTargetType[i] = TARGET_TYPE_DEST_DEST;
-                break;
-            case TARGET_DST_DB:
-            case TARGET_DST_HOME:
-            case TARGET_DST_NEARBY_ENTRY:
-                SpellTargetType[i] = TARGET_TYPE_DEST_SPECIAL;
-                break;
-            case TARGET_UNIT_CHANNEL_TARGET:
-            case TARGET_DEST_CHANNEL_TARGET:
-            case TARGET_DEST_CHANNEL_CASTER:
-                SpellTargetType[i] = TARGET_TYPE_CHANNEL;
-                break;
-            default:
-                SpellTargetType[i] = TARGET_TYPE_DEFAULT;
-        }
-    }
-
-    for (int32 i = 0; i < TOTAL_SPELL_TARGETS; ++i)
-    {
-        switch(i)
-        {
-            case TARGET_UNIT_AREA_ENEMY_DST:
-            case TARGET_UNIT_AREA_ENEMY_SRC:
-            case TARGET_UNIT_AREA_ALLY_DST:
-            case TARGET_UNIT_AREA_ALLY_SRC:
-            case TARGET_UNIT_AREA_ENTRY_DST:
-            case TARGET_UNIT_AREA_ENTRY_SRC:
-            case TARGET_UNIT_AREA_PARTY_DST:
-            case TARGET_UNIT_AREA_PARTY_SRC:
-            case TARGET_UNIT_PARTY_TARGET:
-            case TARGET_UNIT_PARTY_CASTER:
-            case TARGET_UNIT_CONE_ENEMY:
-            case TARGET_UNIT_CONE_ALLY:
-            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
-            case TARGET_UNIT_AREA_PATH:
-            case TARGET_GAMEOBJECT_AREA_PATH:
-            case TARGET_UNIT_RAID_CASTER:
-                IsAreaEffectTarget[i] = true;
-                break;
-            default:
-                IsAreaEffectTarget[i] = false;
-                break;
-        }
-    }
-}
-
-SpellMgr::~SpellMgr()
-{
-}
-
-SpellMgr& SpellMgr::Instance()
-{
-    static SpellMgr spellMgr;
-    return spellMgr;
-}
-
-bool SpellMgr::IsSrcTargetSpell(SpellEntry const *spellInfo) const
-{
-    for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
-    {
-        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_AREA_SRC || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_AREA_SRC)
-            return true;
-    }
-    return false;
-}
-
-int32 GetSpellDuration(SpellEntry const *spellInfo)
-{
-    if (!spellInfo)
-        return 0;
-    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
-    if (!du)
-        return 0;
-    return (du->Duration[0] == -1) ? -1 : abs(du->Duration[0]);
-}
-
-int32 GetSpellMaxDuration(SpellEntry const *spellInfo)
-{
-    if (!spellInfo)
-        return 0;
-    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
-    if (!du)
-        return 0;
-    return (du->Duration[2] == -1) ? -1 : abs(du->Duration[2]);
-}
-
-uint32 GetDispelChance(Unit* auraCaster, Unit* target, uint32 spellId, bool offensive, bool *result)
-{
-    // we assume that aura dispel chance is 100% on start
-    // need formula for level difference based chance
-    int32 resist_chance = 0;
-
-    // Apply dispel mod from aura caster
-    if (auraCaster)
-        if (Player* modOwner = auraCaster->GetSpellModOwner())
-            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_DISPEL_CHANCE, resist_chance);
-
-    // Dispel resistance from target SPELL_AURA_MOD_DISPEL_RESIST
-    // Only affects offensive dispels
-    if (offensive && target)
-        resist_chance += target->GetTotalAuraModifier(SPELL_AURA_MOD_DISPEL_RESIST);
-
-    // Try dispel
-    if (result)
-        *result = !roll_chance_i(resist_chance);
-
-    resist_chance = resist_chance < 0 ? 0 : resist_chance;
-    resist_chance = resist_chance > 100 ? 100 : resist_chance;
-    return 100 - resist_chance;
-}
-
-uint32 GetSpellCastTime(SpellEntry const* spellInfo, Spell * spell)
-{
-    SpellCastTimesEntry const *spellCastTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
-
-    // not all spells have cast time index and this is all is pasiive abilities
-    if (!spellCastTimeEntry)
-        return 0;
-
-    int32 castTime = spellCastTimeEntry->CastTime;
-
-    if (spell && spell->GetCaster())
-        spell->GetCaster()->ModSpellCastTime(spellInfo, castTime, spell);
-
-    if (spellInfo->Attributes & SPELL_ATTR_REQ_AMMO && (!spell || !(spell->IsAutoRepeat())))
-        castTime += 500;
-
-    return (castTime > 0) ? uint32(castTime) : 0;
-}
-
-bool IsPassiveSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-    return IsPassiveSpell(spellInfo);
-}
-
-bool IsPassiveSpell(SpellEntry const * spellInfo)
-{
-    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
-        return true;
-    return false;
-}
-
-bool IsAutocastableSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
-        return false;
-    if (spellInfo->AttributesEx & SPELL_ATTR_EX_UNAUTOCASTABLE_BY_PET)
-        return false;
-    return true;
-}
-
-bool IsHigherHankOfSpell(uint32 spellId_1, uint32 spellId_2)
-{
-    return sSpellMgr.GetSpellRank(spellId_1)<sSpellMgr.GetSpellRank(spellId_2);
-}
-
-uint32 CalculatePowerCost(SpellEntry const * spellInfo, Unit const * caster, SpellSchoolMask schoolMask)
-{
-    // Spell drain all exist power on cast (Only paladin lay of Hands)
-    if (spellInfo->AttributesEx & SPELL_ATTR_EX_DRAIN_ALL_POWER)
-    {
-        // If power type - health drain all
-        if (spellInfo->powerType == POWER_HEALTH)
-            return caster->GetHealth();
-        // Else drain all power
-        if (spellInfo->powerType < MAX_POWERS)
-            return caster->GetPower(Powers(spellInfo->powerType));
-        sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
-        return 0;
-    }
-
-    // Base powerCost
-    int32 powerCost = spellInfo->manaCost;
-    // PCT cost from total amount
-    if (spellInfo->ManaCostPercentage)
-    {
-        switch (spellInfo->powerType)
-        {
-            // health as power used
-            case POWER_HEALTH:
-                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateHealth() / 100;
-                break;
-            case POWER_MANA:
-                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateMana() / 100;
-                break;
-            case POWER_RAGE:
-            case POWER_FOCUS:
-            case POWER_ENERGY:
-            case POWER_HAPPINESS:
-                powerCost += spellInfo->ManaCostPercentage * caster->GetMaxPower(Powers(spellInfo->powerType)) / 100;
-                break;
-            case POWER_RUNE:
-            case POWER_RUNIC_POWER:
-                sLog.outDebug("CalculateManaCost: Not implemented yet!");
-                break;
-            default:
-                sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
-                return 0;
-        }
-    }
-    SpellSchools school = GetFirstSchoolInMask(schoolMask);
-    // Flat mod from caster auras by spell school
-    powerCost += caster->GetInt32Value(UNIT_FIELD_POWER_COST_MODIFIER + school);
-    // Shiv - costs 20 + weaponSpeed*10 energy (apply only to non-triggered spell with energy cost)
-    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_SPELL_VS_EXTEND_COST)
-        powerCost += caster->GetAttackTime(OFF_ATTACK)/100;
-    // Apply cost mod by spell
-    if (Player* modOwner = caster->GetSpellModOwner())
-        modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_COST, powerCost);
-
-    if (spellInfo->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION)
-        powerCost = int32(powerCost/ (1.117f* spellInfo->spellLevel / caster->getLevel() -0.1327f));
-
-    // PCT mod from user auras by school
-    powerCost = int32(powerCost * (1.0f+caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+school)));
-    if (powerCost < 0)
-        powerCost = 0;
-    return powerCost;
-}
-
-Unit* GetTriggeredSpellCaster(SpellEntry const * spellInfo, Unit * caster, Unit * target)
-{
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET
-            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_UNIT_TARGET
-            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_CHANNEL
-            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_CHANNEL
-            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_DEST_TARGET
-            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_DEST_TARGET)
-            return caster;
-    }
-    return target;
-}
-
-AuraState GetSpellAuraState(SpellEntry const * spellInfo)
-{
-    // Seals
-    if (IsSealSpell(spellInfo))
-        return AURA_STATE_JUDGEMENT;
-
-    // Conflagrate aura state on Immolate and Shadowflame
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
-        // Immolate
-        ((spellInfo->SpellFamilyFlags[0] & 4) ||
-        // Shadowflame
-        (spellInfo->SpellFamilyFlags[2] & 2)))
-        return AURA_STATE_CONFLAGRATE;
-
-    // Faerie Fire (druid versions)
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x400)
-        return AURA_STATE_FAERIE_FIRE;
-
-    // Sting (hunter's pet ability)
-    if (spellInfo->Category == 1133)
-        return AURA_STATE_FAERIE_FIRE;
-
-    // Victorious
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARRIOR &&  spellInfo->SpellFamilyFlags[1] & 0x00040000)
-        return AURA_STATE_WARRIOR_VICTORY_RUSH;
-
-    // Swiftmend state on Regrowth & Rejuvenation
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x50)
-        return AURA_STATE_SWIFTMEND;
-
-    // Deadly poison aura state
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] & 0x10000)
-        return AURA_STATE_DEADLY_POISON;
-
-    // Enrage aura state
-    if (spellInfo->Dispel == DISPEL_ENRAGE)
-        return AURA_STATE_ENRAGE;
-
-    // Bleeding aura state
-    if (GetAllSpellMechanicMask(spellInfo) & 1<<MECHANIC_BLEED)
-        return AURA_STATE_BLEEDING;
-
-    if (GetSpellSchoolMask(spellInfo) & SPELL_SCHOOL_MASK_FROST)
-    {
-        for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
-        {
-            if (spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_STUN
-                || spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT)
-                return AURA_STATE_FROZEN;
-        }
-    }
-    return AURA_STATE_NONE;
-}
-
-SpellSpecific GetSpellSpecific(SpellEntry const * spellInfo)
-{
-    switch(spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            // Food / Drinks (mostly)
-            if (spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
-            {
-                bool food = false;
-                bool drink = false;
-                for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-                {
-                    switch(spellInfo->EffectApplyAuraName[i])
-                    {
-                        // Food
-                        case SPELL_AURA_MOD_REGEN:
-                        case SPELL_AURA_OBS_MOD_HEALTH:
-                            food = true;
-                            break;
-                        // Drink
-                        case SPELL_AURA_MOD_POWER_REGEN:
-                        case SPELL_AURA_OBS_MOD_POWER:
-                            drink = true;
-                            break;
-                        default:
-                            break;
-                    }
-                }
-
-                if (food && drink)
-                    return SPELL_SPECIFIC_FOOD_AND_DRINK;
-                else if (food)
-                    return SPELL_SPECIFIC_FOOD;
-                else if (drink)
-                    return SPELL_SPECIFIC_DRINK;
-            }
-            // scrolls effects
-            else
-            {
-                uint32 firstSpell = sSpellMgr.GetFirstSpellInChain(spellInfo->Id);
-                switch (firstSpell)
-                {
-                    case 8118: // Strength
-                    case 8099: // Stamina
-                    case 8112: // Spirit
-                    case 8096: // Intellect
-                    case 8115: // Agility
-                    case 8091: // Armor
-                        return SPELL_SPECIFIC_SCROLL;
-                    case 12880: // Enrage (Enrage)
-                    case 57518: // Enrage (Wrecking Crew)
-                        return SPELL_SPECIFIC_WARRIOR_ENRAGE;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_MAGE:
-        {
-            // family flags 18(Molten), 25(Frost/Ice), 28(Mage)
-            if (spellInfo->SpellFamilyFlags[0] & 0x12040000)
-                return SPELL_SPECIFIC_MAGE_ARMOR;
-
-            // Arcane brillance and Arcane intelect (normal check fails because of flags difference)
-            if (spellInfo->SpellFamilyFlags[0] & 0x400)
-                return SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE;
-
-            if ((spellInfo->SpellFamilyFlags[0] & 0x1000000) && spellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOD_CONFUSE)
-                return SPELL_SPECIFIC_MAGE_POLYMORPH;
-
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            if (spellInfo->Id == 12292) // Death Wish
-                return SPELL_SPECIFIC_WARRIOR_ENRAGE;
-
-            break;
-        }
-        case SPELLFAMILY_WARLOCK:
-        {
-            // only warlock curses have this
-            if (spellInfo->Dispel == DISPEL_CURSE)
-                return SPELL_SPECIFIC_CURSE;
-
-            // Warlock (Demon Armor | Demon Skin | Fel Armor)
-            if (spellInfo->SpellFamilyFlags[1] & 0x20000020 || spellInfo->SpellFamilyFlags[2] & 0x00000010)
-                return SPELL_SPECIFIC_WARLOCK_ARMOR;
-
-            //seed of corruption and corruption
-            if (spellInfo->SpellFamilyFlags[1] & 0x10 || spellInfo->SpellFamilyFlags[0] & 0x2)
-                return SPELL_SPECIFIC_WARLOCK_CORRUPTION;
-            break;
-        }
-        case SPELLFAMILY_PRIEST:
-        {
-            // Divine Spirit and Prayer of Spirit
-            if (spellInfo->SpellFamilyFlags[0] & 0x20)
-                return SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT;
-
-            break;
-        }
-        case SPELLFAMILY_HUNTER:
-        {
-            // only hunter stings have this
-            if (spellInfo->Dispel == DISPEL_POISON)
-                return SPELL_SPECIFIC_STING;
-
-            // only hunter aspects have this (but not all aspects in hunter family)
-            if (spellInfo->SpellFamilyFlags.HasFlag(0x00380000, 0x00440000, 0x00001010))
-                return SPELL_SPECIFIC_ASPECT;
-
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            if (IsSealSpell(spellInfo))
-                return SPELL_SPECIFIC_SEAL;
-
-            if (spellInfo->SpellFamilyFlags[0] & 0x00002190)
-                return SPELL_SPECIFIC_HAND;
-
-            // Judgement of Wisdom, Judgement of Light, Judgement of Justice
-            if (spellInfo->Id == 20184 || spellInfo->Id == 20185 || spellInfo->Id == 20186)
-                return SPELL_SPECIFIC_JUDGEMENT;
-
-            // only paladin auras have this (for palaldin class family)
-            if (spellInfo->SpellFamilyFlags[2] & 0x00000020)
-                return SPELL_SPECIFIC_AURA;
-
-            break;
-        }
-        case SPELLFAMILY_SHAMAN:
-        {
-            if (IsElementalShield(spellInfo))
-                return SPELL_SPECIFIC_ELEMENTAL_SHIELD;
-
-            break;
-        }
-
-        case SPELLFAMILY_DEATHKNIGHT:
-            if (spellInfo->Id == 48266 || spellInfo->Id == 48263 || spellInfo->Id == 48265)
-            //if (spellInfo->Category == 47)
-                return SPELL_SPECIFIC_PRESENCE;
-            break;
-    }
-
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
-        {
-            switch(spellInfo->EffectApplyAuraName[i])
-            {
-                case SPELL_AURA_MOD_CHARM:
-                case SPELL_AURA_MOD_POSSESS_PET:
-                case SPELL_AURA_MOD_POSSESS:
-                case SPELL_AURA_AOE_CHARM:
-                    return SPELL_SPECIFIC_CHARM;
-                case SPELL_AURA_TRACK_CREATURES:
-                case SPELL_AURA_TRACK_RESOURCES:
-                case SPELL_AURA_TRACK_STEALTHED:
-                    return SPELL_SPECIFIC_TRACKER;
-                case SPELL_AURA_PHASE:
-                    return SPELL_SPECIFIC_PHASE;
-            }
-        }
-    }
-
-    return SPELL_SPECIFIC_NORMAL;
-}
-
-// target not allow have more one spell specific from same caster
-bool IsSingleFromSpellSpecificPerCaster(SpellSpecific spellSpec1,SpellSpecific spellSpec2)
-{
-    switch(spellSpec1)
-    {
-        case SPELL_SPECIFIC_SEAL:
-        case SPELL_SPECIFIC_HAND:
-        case SPELL_SPECIFIC_AURA:
-        case SPELL_SPECIFIC_STING:
-        case SPELL_SPECIFIC_CURSE:
-        case SPELL_SPECIFIC_ASPECT:
-        case SPELL_SPECIFIC_JUDGEMENT:
-        case SPELL_SPECIFIC_WARLOCK_CORRUPTION:
-            return spellSpec1 == spellSpec2;
-        default:
-            return false;
-    }
-}
-
-bool IsSingleFromSpellSpecificPerTarget(SpellSpecific spellSpec1, SpellSpecific spellSpec2)
-{
-    switch(spellSpec1)
-    {
-        case SPELL_SPECIFIC_PHASE:
-        case SPELL_SPECIFIC_TRACKER:
-        case SPELL_SPECIFIC_WARLOCK_ARMOR:
-        case SPELL_SPECIFIC_MAGE_ARMOR:
-        case SPELL_SPECIFIC_ELEMENTAL_SHIELD:
-        case SPELL_SPECIFIC_MAGE_POLYMORPH:
-        case SPELL_SPECIFIC_PRESENCE:
-        case SPELL_SPECIFIC_CHARM:
-        case SPELL_SPECIFIC_SCROLL:
-        case SPELL_SPECIFIC_WARRIOR_ENRAGE:
-        case SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE:
-        case SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT:
-            return spellSpec1 == spellSpec2;
-        case SPELL_SPECIFIC_FOOD:
-            return spellSpec2 == SPELL_SPECIFIC_FOOD
-                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
-        case SPELL_SPECIFIC_DRINK:
-            return spellSpec2 == SPELL_SPECIFIC_DRINK
-                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
-        case SPELL_SPECIFIC_FOOD_AND_DRINK:
-            return spellSpec2 == SPELL_SPECIFIC_FOOD
-                || spellSpec2 == SPELL_SPECIFIC_DRINK
-                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
-        default:
-            return false;
-    }
-}
-
-bool IsPositiveTarget(uint32 targetA, uint32 targetB)
-{
-    // non-positive targets
-    switch(targetA)
-    {
-        case TARGET_UNIT_NEARBY_ENEMY:
-        case TARGET_UNIT_TARGET_ENEMY:
-        case TARGET_UNIT_AREA_ENEMY_SRC:
-        case TARGET_UNIT_AREA_ENEMY_DST:
-        case TARGET_UNIT_CONE_ENEMY:
-        case TARGET_DEST_DYNOBJ_ENEMY:
-        case TARGET_DST_TARGET_ENEMY:
-            return false;
-        default:
-            break;
-    }
-    if (targetB)
-        return IsPositiveTarget(targetB, 0);
-    return true;
-}
-
-bool SpellMgr::_isPositiveEffect(uint32 spellId, uint32 effIndex, bool deep) const
-{
-    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
-    if (!spellproto) return false;
-
-    // not found a single positive spell with this attribute
-    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1)
-        return false;
-
-    switch (spellproto->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-            switch (spellId)
-            {
-                case 34700: // Allergic Reaction
-                case 61987: // Avenging Wrath Marker
-                case 61988: // Divine Shield exclude aura
-                    return false;
-                case 30877: // Tag Murloc
-                    return true;
-                default:
-                    break;
-            }
-            break;
-        case SPELLFAMILY_MAGE:
-            // Amplify Magic, Dampen Magic
-            if (spellproto->SpellFamilyFlags[0] == 0x00002000)
-                return true;
-            break;
-        case SPELLFAMILY_PRIEST:
-            switch (spellId)
-            {
-                case 64844: // Divine Hymn
-                case 64904: // Hymn of Hope
-                case 47585: // Dispersion
-                    return true;
-                default:
-                    break;
-            }
-            break;
-        case SPELLFAMILY_HUNTER:
-            // Aspect of the Viper
-            if (spellId == 34074)
-                return true;
-            break;
-        case SPELLFAMILY_SHAMAN:
-            if (spellId == 30708)
-                return false;
-            break;
-        default:
-            break;
-    }
-
-    switch (spellproto->Mechanic)
-    {
-        case MECHANIC_IMMUNE_SHIELD:
-            return true;
-        default:
-            break;
-    }
-
-    // Special case: effects which determine positivity of whole spell
-    for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
-    {
-        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_STEALTH)
-            return true;
-    }
-
-    switch(spellproto->Effect[effIndex])
-    {
-        case SPELL_EFFECT_DUMMY:
-            // some explicitly required dummy effect sets
-            switch(spellId)
-            {
-                case 28441: return false;                   // AB Effect 000
-                default:
-                    break;
-            }
-            break;
-        // always positive effects (check before target checks that provided non-positive result in some case for positive effects)
-        case SPELL_EFFECT_HEAL:
-        case SPELL_EFFECT_LEARN_SPELL:
-        case SPELL_EFFECT_SKILL_STEP:
-        case SPELL_EFFECT_HEAL_PCT:
-        case SPELL_EFFECT_ENERGIZE_PCT:
-            return true;
-
-            // non-positive aura use
-        case SPELL_EFFECT_APPLY_AURA:
-        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
-        {
-            switch(spellproto->EffectApplyAuraName[effIndex])
-            {
-                case SPELL_AURA_MOD_DAMAGE_DONE:            // dependent from bas point sign (negative -> negative)
-                case SPELL_AURA_MOD_STAT:
-                case SPELL_AURA_MOD_SKILL:
-                case SPELL_AURA_MOD_HEALING_PCT:
-                case SPELL_AURA_MOD_HEALING_DONE:
-                case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE:
-                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) < 0)
-                        return false;
-                    break;
-                case SPELL_AURA_MOD_DAMAGE_TAKEN:           // dependent from bas point sign (positive -> negative)
-                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
-                        return false;
-                    break;
-                case SPELL_AURA_MOD_CRIT_PCT:
-                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
-                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
-                        return true;                        // some expected positive spells have SPELL_ATTR_EX_NEGATIVE
-                    break;
-                case SPELL_AURA_ADD_TARGET_TRIGGER:
-                    return true;
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
-                    if (!deep)
-                    {
-                        uint32 spellTriggeredId = spellproto->EffectTriggerSpell[effIndex];
-                        SpellEntry const *spellTriggeredProto = sSpellStore.LookupEntry(spellTriggeredId);
-
-                        if (spellTriggeredProto)
-                        {
-                            // non-positive targets of main spell return early
-                            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-                            {
-                                if (!spellTriggeredProto->Effect[i])
-                                    continue;
-                                // if non-positive trigger cast targeted to positive target this main cast is non-positive
-                                // this will place this spell auras as debuffs
-                                if (IsPositiveTarget(spellTriggeredProto->EffectImplicitTargetA[effIndex],spellTriggeredProto->EffectImplicitTargetB[effIndex]) && !_isPositiveEffect(spellTriggeredId,i, true))
-                                    return false;
-                            }
-                        }
-                    }
-                case SPELL_AURA_PROC_TRIGGER_SPELL:
-                    // many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
-                    break;
-                case SPELL_AURA_MOD_STUN:                   //have positive and negative spells, we can't sort its correctly at this moment.
-                    if (effIndex == 0 && spellproto->Effect[1] == 0 && spellproto->Effect[2] == 0)
-                        return false;                       // but all single stun aura spells is negative
-                    break;
-                case SPELL_AURA_MOD_PACIFY_SILENCE:
-                    if (spellproto->Id == 24740)             // Wisp Costume
-                        return true;
-                    return false;
-                case SPELL_AURA_MOD_ROOT:
-                case SPELL_AURA_MOD_SILENCE:
-                case SPELL_AURA_GHOST:
-                case SPELL_AURA_PERIODIC_LEECH:
-                case SPELL_AURA_MOD_STALKED:
-                case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
-                case SPELL_AURA_PREVENT_RESSURECTION:
-                    return false;
-                case SPELL_AURA_PERIODIC_DAMAGE:            // used in positive spells also.
-                    // part of negative spell if casted at self (prevent cancel)
-                    if (spellproto->EffectImplicitTargetA[effIndex] == TARGET_UNIT_CASTER)
-                        return false;
-                    break;
-                case SPELL_AURA_MOD_DECREASE_SPEED:         // used in positive spells also
-                    // part of positive spell if casted at self
-                    if (spellproto->EffectImplicitTargetA[effIndex] != TARGET_UNIT_CASTER)
-                        return false;
-                    // but not this if this first effect (didn't find better check)
-                    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1 && effIndex == 0)
-                        return false;
-                    break;
-                case SPELL_AURA_MECHANIC_IMMUNITY:
-                {
-                    // non-positive immunities
-                    switch(spellproto->EffectMiscValue[effIndex])
-                    {
-                        case MECHANIC_BANDAGE:
-                        case MECHANIC_SHIELD:
-                        case MECHANIC_MOUNT:
-                        case MECHANIC_INVULNERABILITY:
-                            return false;
-                        default:
-                            break;
-                    }
-                }   break;
-                case SPELL_AURA_ADD_FLAT_MODIFIER:          // mods
-                case SPELL_AURA_ADD_PCT_MODIFIER:
-                {
-                    // non-positive mods
-                    switch(spellproto->EffectMiscValue[effIndex])
-                    {
-                        case SPELLMOD_COST:                 // dependent from bas point sign (negative -> positive)
-                            if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
-                            {
-                                if (!deep)
-                                {
-                                    bool negative = true;
-                                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; ++i)
-                                    {
-                                        if (i != effIndex)
-                                            if (_isPositiveEffect(spellId, i, true))
-                                            {
-                                                negative = false;
-                                                break;
-                                            }
-                                    }
-                                    if (negative)
-                                        return false;
-                                }
-                            }
-                            break;
-                        default:
-                            break;
-                    }
-                }   break;
-                default:
-                    break;
-            }
-            break;
-        }
-        default:
-            break;
-    }
-
-    // non-positive targets
-    if (!IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex]))
-        return false;
-
-    // AttributesEx check
-    if (spellproto->AttributesEx & SPELL_ATTR_EX_NEGATIVE)
-        return false;
-
-    if (!deep && spellproto->EffectTriggerSpell[effIndex]
-        && !spellproto->EffectApplyAuraName[effIndex]
-        && IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex])
-        && !_isPositiveSpell(spellproto->EffectTriggerSpell[effIndex], true))
-        return false;
-
-    // ok, positive
-    return true;
-}
-
-bool IsPositiveSpell(uint32 spellId)
-{
-    if (!sSpellStore.LookupEntry(spellId)) // non-existing spells
-        return false;
-    return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE);
-}
-
-bool IsPositiveEffect(uint32 spellId, uint32 effIndex)
-{
-    if (!sSpellStore.LookupEntry(spellId))
-        return false;
-    switch(effIndex)
-    {
-        default:
-        case 0: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF0);
-        case 1: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF1);
-        case 2: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF2);
-    }
-}
-
-bool SpellMgr::_isPositiveSpell(uint32 spellId, bool deep) const
-{
-    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
-    if (!spellproto) return false;
-
-    // spells with at least one negative effect are considered negative
-    // some self-applied spells have negative effects but in self casting case negative check ignored.
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        if (!_isPositiveEffect(spellId, i, deep))
-            return false;
-    return true;
-}
-
-bool IsSingleTargetSpell(SpellEntry const *spellInfo)
-{
-    // all other single target spells have if it has AttributesEx5
-    if (spellInfo->AttributesEx5 & SPELL_ATTR_EX5_SINGLE_TARGET_SPELL)
-        return true;
-
-    switch(GetSpellSpecific(spellInfo))
-    {
-        case SPELL_SPECIFIC_JUDGEMENT:
-            return true;
-        default:
-            break;
-    }
-
-    return false;
-}
-
-bool IsSingleTargetSpells(SpellEntry const *spellInfo1, SpellEntry const *spellInfo2)
-{
-    // TODO - need better check
-    // Equal icon and spellfamily
-    if (spellInfo1->SpellFamilyName == spellInfo2->SpellFamilyName &&
-        spellInfo1->SpellIconID == spellInfo2->SpellIconID)
-        return true;
-
-    // TODO - need found Judgements rule
-    SpellSpecific spec1 = GetSpellSpecific(spellInfo1);
-    // spell with single target specific types
-    switch(spec1)
-    {
-        case SPELL_SPECIFIC_JUDGEMENT:
-        case SPELL_SPECIFIC_MAGE_POLYMORPH:
-            if (GetSpellSpecific(spellInfo2) == spec1)
-                return true;
-            break;
-        default:
-            break;
-    }
-
-    return false;
-}
-
-SpellCastResult GetErrorAtShapeshiftedCast (SpellEntry const *spellInfo, uint32 form)
-{
-    // talents that learn spells can have stance requirements that need ignore
-    // (this requirement only for client-side stance show in talent description)
-    if (GetTalentSpellCost(spellInfo->Id) > 0 &&
-        (spellInfo->Effect[0] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[1] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[2] == SPELL_EFFECT_LEARN_SPELL))
-        return SPELL_CAST_OK;
-
-    uint32 stanceMask = (form ? 1 << (form - 1) : 0);
-
-    if (stanceMask & spellInfo->StancesNot)                 // can explicitly not be casted in this stance
-        return SPELL_FAILED_NOT_SHAPESHIFT;
-
-    if (stanceMask & spellInfo->Stances)                    // can explicitly be casted in this stance
-        return SPELL_CAST_OK;
-
-    bool actAsShifted = false;
-    SpellShapeshiftEntry const *shapeInfo = NULL;
-    if (form > 0)
-    {
-        shapeInfo = sSpellShapeshiftStore.LookupEntry(form);
-        if (!shapeInfo)
-        {
-            sLog.outError("GetErrorAtShapeshiftedCast: unknown shapeshift %u", form);
-            return SPELL_CAST_OK;
-        }
-        actAsShifted = !(shapeInfo->flags1 & 1);            // shapeshift acts as normal form for spells
-    }
-
-    if (actAsShifted)
-    {
-        if (spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT) // not while shapeshifted
-            return SPELL_FAILED_NOT_SHAPESHIFT;
-        else if (spellInfo->Stances != 0)                   // needs other shapeshift
-            return SPELL_FAILED_ONLY_SHAPESHIFT;
-    }
-    else
-    {
-        // needs shapeshift
-        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_NEED_SHAPESHIFT) && spellInfo->Stances != 0)
-            return SPELL_FAILED_ONLY_SHAPESHIFT;
-    }
-
-    // Check if stance disables cast of not-stance spells
-    // Example: cannot cast any other spells in zombie or ghoul form
-    // TODO: Find a way to disable use of these spells clientside
-    if (shapeInfo && shapeInfo->flags1 & 0x400)
-    {
-        if (!(stanceMask & spellInfo->Stances))
-            return SPELL_FAILED_ONLY_SHAPESHIFT;
-    }
-
-    return SPELL_CAST_OK;
-}
-
-void SpellMgr::LoadSpellTargetPositions()
-{
-    mSpellTargetPositions.clear();                                // need for reload case
-
-    uint32 count = 0;
-
-    //                                                0   1           2                  3                  4                  5
-    QueryResult result = WorldDatabase.Query("SELECT id, target_map, target_position_x, target_position_y, target_position_z, target_orientation FROM spell_target_position");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell target coordinates", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 Spell_ID = fields[0].GetUInt32();
-
-        SpellTargetPosition st;
-
-        st.target_mapId       = fields[1].GetUInt32();
-        st.target_X           = fields[2].GetFloat();
-        st.target_Y           = fields[3].GetFloat();
-        st.target_Z           = fields[4].GetFloat();
-        st.target_Orientation = fields[5].GetFloat();
-
-        MapEntry const* mapEntry = sMapStore.LookupEntry(st.target_mapId);
-        if (!mapEntry)
-        {
-            sLog.outErrorDb("Spell (ID:%u) target map (ID: %u) does not exist in `Map.dbc`.",Spell_ID,st.target_mapId);
-            continue;
-        }
-
-        if (st.target_X==0 && st.target_Y==0 && st.target_Z==0)
-        {
-            sLog.outErrorDb("Spell (ID:%u) target coordinates not provided.",Spell_ID);
-            continue;
-        }
-
-        SpellEntry const* spellInfo = sSpellStore.LookupEntry(Spell_ID);
-        if (!spellInfo)
-        {
-            sLog.outErrorDb("Spell (ID:%u) listed in `spell_target_position` does not exist.",Spell_ID);
-            continue;
-        }
-
-        bool found = false;
-        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (spellInfo->EffectImplicitTargetA[i] == TARGET_DST_DB || spellInfo->EffectImplicitTargetB[i] == TARGET_DST_DB)
-            {
-                // additional requirements
-                if (spellInfo->Effect[i]==SPELL_EFFECT_BIND && spellInfo->EffectMiscValue[i])
-                {
-                    uint32 area_id = sMapMgr.GetAreaId(st.target_mapId, st.target_X, st.target_Y, st.target_Z);
-                    if (area_id != uint32(spellInfo->EffectMiscValue[i]))
-                    {
-                        sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` expected point to zone %u bit point to zone %u.",Spell_ID, spellInfo->EffectMiscValue[i], area_id);
-                        break;
-                    }
-                }
-
-                found = true;
-                break;
-            }
-        }
-        if (!found)
-        {
-            sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` does not have target TARGET_DST_DB (17).",Spell_ID);
-            continue;
-        }
-
-        mSpellTargetPositions[Spell_ID] = st;
-        ++count;
-
-    } while (result->NextRow());
-
-    // Check all spells
-    for (uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
-    {
-        SpellEntry const * spellInfo = sSpellStore.LookupEntry(i);
-        if (!spellInfo)
-            continue;
-
-        bool found = false;
-        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            switch(spellInfo->EffectImplicitTargetA[j])
-            {
-                case TARGET_DST_DB:
-                    found = true;
-                    break;
-            }
-            if (found)
-                break;
-            switch(spellInfo->EffectImplicitTargetB[j])
-            {
-                case TARGET_DST_DB:
-                    found = true;
-                    break;
-            }
-            if (found)
-                break;
-        }
-        if (found)
-        {
-//            if (!sSpellMgr.GetSpellTargetPosition(i))
-//                sLog.outDebug("Spell (ID: %u) does not have record in `spell_target_position`", i);
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell teleport coordinates", count);
-}
-
-bool SpellMgr::IsAffectedByMod(SpellEntry const *spellInfo, SpellModifier *mod) const
-{
-    // false for spellInfo == NULL
-    if (!spellInfo || !mod)
-        return false;
-
-    SpellEntry const *affect_spell = sSpellStore.LookupEntry(mod->spellId);
-    // False if affect_spell == NULL or spellFamily not equal
-    if (!affect_spell || affect_spell->SpellFamilyName != spellInfo->SpellFamilyName)
-        return false;
-
-    // true
-    if (mod->mask  & spellInfo->SpellFamilyFlags)
-        return true;
-
-    return false;
-}
-
-void SpellMgr::LoadSpellProcEvents()
-{
-    mSpellProcEventMap.clear();                             // need for reload case
-
-    uint32 count = 0;
-
-    //                                                0      1           2                3                 4                 5                 6          7       8        9             10
-    QueryResult result = WorldDatabase.Query("SELECT entry, SchoolMask, SpellFamilyName, SpellFamilyMask0, SpellFamilyMask1, SpellFamilyMask2, procFlags, procEx, ppmRate, CustomChance, Cooldown FROM spell_proc_event");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell proc event conditions", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-    uint32 customProc = 0;
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 entry = fields[0].GetUInt32();
-
-        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
-        if (!spell)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_proc_event` does not exist", entry);
-            continue;
-        }
-
-        SpellProcEventEntry spe;
-
-        spe.schoolMask      = fields[1].GetUInt32();
-        spe.spellFamilyName = fields[2].GetUInt32();
-        spe.spellFamilyMask[0] = fields[3].GetUInt32();
-        spe.spellFamilyMask[1] = fields[4].GetUInt32();
-        spe.spellFamilyMask[2] = fields[5].GetUInt32();
-        spe.procFlags       = fields[6].GetUInt32();
-        spe.procEx          = fields[7].GetUInt32();
-        spe.ppmRate         = fields[8].GetFloat();
-        spe.customChance    = fields[9].GetFloat();
-        spe.cooldown        = fields[10].GetUInt32();
-
-        mSpellProcEventMap[entry] = spe;
-
-        if (spell->procFlags == 0)
-        {
-            if (spe.procFlags == 0)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_proc_event` probally not triggered spell", entry);
-                continue;
-            }
-            customProc++;
-        }
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    if (customProc)
-        sLog.outString(">> Loaded %u extra spell proc event conditions + %u custom",  count, customProc);
-    else
-        sLog.outString(">> Loaded %u extra spell proc event conditions", count);
-}
-
-void SpellMgr::LoadSpellBonusess()
-{
-    mSpellBonusMap.clear();                             // need for reload case
-    uint32 count = 0;
-    //                                                0      1             2          3         4
-    QueryResult result = WorldDatabase.Query("SELECT entry, direct_bonus, dot_bonus, ap_bonus, ap_dot_bonus FROM spell_bonus_data");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell bonus data", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        Field *fields = result->Fetch();
-        bar.step();
-        uint32 entry = fields[0].GetUInt32();
-
-        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
-        if (!spell)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_bonus_data` does not exist", entry);
-            continue;
-        }
-
-        SpellBonusEntry sbe;
-
-        sbe.direct_damage = fields[1].GetFloat();
-        sbe.dot_damage    = fields[2].GetFloat();
-        sbe.ap_bonus      = fields[3].GetFloat();
-        sbe.ap_dot_bonus   = fields[4].GetFloat();
-
-        mSpellBonusMap[entry] = sbe;
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u extra spell bonus data",  count);
-}
-
-bool SpellMgr::IsSpellProcEventCanTriggeredBy(SpellProcEventEntry const* spellProcEvent, uint32 EventProcFlag, SpellEntry const * procSpell, uint32 procFlags, uint32 procExtra, bool active)
-{
-    // No extra req need
-    uint32 procEvent_procEx = PROC_EX_NONE;
-
-    // check prockFlags for condition
-    if ((procFlags & EventProcFlag) == 0)
-        return false;
-
-    bool hasFamilyMask = false;
-
-    /* Check Periodic Auras
-
-    *Dots can trigger if spell has no PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
-        nor PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
-
-    *Only Hots can trigger if spell has PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
-
-    *Only dots can trigger if spell has both positivity flags or PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
-
-    *Aura has to have PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL or spellfamily specified to trigger from Hot
-
-    */
-
-    if (procFlags & PROC_FLAG_DONE_PERIODIC)
-    {
-        if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG)
-        {
-            if (!(procExtra & PROC_EX_INTERNAL_DOT))
-                return false;
-        }
-        else if (procExtra & PROC_EX_INTERNAL_HOT)
-            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
-        else if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS)
-            return false;
-    }
-
-    if (procFlags & PROC_FLAG_TAKEN_PERIODIC)
-    {
-        if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)
-        {
-            if (!(procExtra & PROC_EX_INTERNAL_DOT))
-                return false;
-        }
-        else if (procExtra & PROC_EX_INTERNAL_HOT)
-            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
-        else if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_POS)
-            return false;
-    }
-    // Trap casts are active by default
-    if (procFlags & PROC_FLAG_DONE_TRAP_ACTIVATION)
-        active = true;
-
-    // Always trigger for this
-    if (procFlags & (PROC_FLAG_KILLED | PROC_FLAG_KILL | PROC_FLAG_DEATH))
-        return true;
-
-    if (spellProcEvent)     // Exist event data
-    {
-        // Store extra req
-        procEvent_procEx = spellProcEvent->procEx;
-
-        // For melee triggers
-        if (procSpell == NULL)
-        {
-            // Check (if set) for school (melee attack have Normal school)
-            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
-                return false;
-        }
-        else // For spells need check school/spell family/family mask
-        {
-            // Check (if set) for school
-            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & procSpell->SchoolMask) == 0)
-                return false;
-
-            // Check (if set) for spellFamilyName
-            if (spellProcEvent->spellFamilyName && (spellProcEvent->spellFamilyName != procSpell->SpellFamilyName))
-                return false;
-
-            // spellFamilyName is Ok need check for spellFamilyMask if present
-            if (spellProcEvent->spellFamilyMask)
-            {
-                if ((spellProcEvent->spellFamilyMask & procSpell->SpellFamilyFlags) == 0)
-                    return false;
-                hasFamilyMask = true;
-                // Some spells are not considered as active even with have spellfamilyflags
-                if (!(procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL))
-                    active = true;
-            }
-        }
-    }
-
-    if (procExtra & (PROC_EX_INTERNAL_REQ_FAMILY))
-    {
-        if (!hasFamilyMask)
-            return false;
-    }
-
-    // Check for extra req (if none) and hit/crit
-    if (procEvent_procEx == PROC_EX_NONE)
-    {
-        // No extra req, so can trigger only for hit/crit - spell has to be active
-        if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && active)
-            return true;
-    }
-    else // Passive spells hits here only if resist/reflect/immune/evade
-    {
-        if (procExtra & AURA_SPELL_PROC_EX_MASK)
-        {
-            // if spell marked as procing only from not active spells
-            if (active && procEvent_procEx & PROC_EX_NOT_ACTIVE_SPELL)
-                return false;
-            // if spell marked as procing only from active spells
-            if (!active && procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL)
-                return false;
-            // Exist req for PROC_EX_EX_TRIGGER_ALWAYS
-            if (procEvent_procEx & PROC_EX_EX_TRIGGER_ALWAYS)
-                return true;
-            // PROC_EX_NOT_ACTIVE_SPELL and PROC_EX_ONLY_ACTIVE_SPELL flags handle: if passed checks before
-            if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && ((procEvent_procEx & (AURA_SPELL_PROC_EX_MASK)) == 0))
-                return true;
-        }
-        // Check Extra Requirement like (hit/crit/miss/resist/parry/dodge/block/immune/reflect/absorb and other)
-        if (procEvent_procEx & procExtra)
-            return true;
-    }
-    return false;
-}
-
-void SpellMgr::LoadSpellGroups()
-{
-    mSpellSpellGroup.clear();                                  // need for reload case
-    mSpellGroupSpell.clear();
-
-    uint32 count = 0;
-
-    //                                                       0   1
-    QueryResult result = WorldDatabase.Query("SELECT id, spell_id FROM spell_group");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell group definitions", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    std::set<uint32> groups;
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 group_id = fields[0].GetUInt32();
-        if (group_id <= SPELL_GROUP_DB_RANGE_MIN && group_id >= SPELL_GROUP_CORE_RANGE_MAX)
-        {
-            sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` is in core range, but is not defined in core!", group_id);
-            continue;
-        }
-        int32 spell_id = fields[1].GetInt32();
-
-        groups.insert(std::set<uint32>::value_type(group_id));
-        mSpellGroupSpell.insert(SpellGroupSpellMap::value_type((SpellGroup)group_id, spell_id));
-
-    } while (result->NextRow());
-
-    for (SpellGroupSpellMap::iterator itr = mSpellGroupSpell.begin(); itr!= mSpellGroupSpell.end() ;)
-    {
-        if (itr->second < 0)
-        {
-            if (groups.find(abs(itr->second)) == groups.end())
-            {
-                sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` does not exist", abs(itr->second));
-                mSpellGroupSpell.erase(itr++);
-            }
-            else
-                ++itr;
-        }
-        else
-        {
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(itr->second);
-
-            if (!spellInfo)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_group` does not exist", itr->second);
-                mSpellGroupSpell.erase(itr++);
-            }
-            else if (GetSpellRank(itr->second) > 1)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_group` is not first rank of spell", itr->second);
-                mSpellGroupSpell.erase(itr++);
-            }
-            else
-                ++itr;
-        }
-    }
-
-    for (std::set<uint32>::iterator groupItr = groups.begin() ; groupItr != groups.end() ; ++groupItr)
-    {
-        std::set<uint32> spells;
-        GetSetOfSpellsInSpellGroup(SpellGroup(*groupItr), spells);
-
-        for (std::set<uint32>::iterator spellItr = spells.begin() ; spellItr != spells.end() ; ++spellItr)
-        {
-            ++count;
-            mSpellSpellGroup.insert(SpellSpellGroupMap::value_type(*spellItr, SpellGroup(*groupItr)));
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell group definitions", count);
-}
-
-void SpellMgr::LoadSpellGroupStackRules()
-{
-    mSpellGroupStack.clear();                                  // need for reload case
-
-    uint32 count = 0;
-
-    //                                                       0         1
-    QueryResult result = WorldDatabase.Query("SELECT group_id, stack_rule FROM spell_group_stack_rules");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell group stack rules", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 group_id = fields[0].GetUInt32();
-        uint8 stack_rule = fields[1].GetUInt32();
-        if (stack_rule >= SPELL_GROUP_STACK_RULE_MAX)
-        {
-            sLog.outErrorDb("SpellGroupStackRule %u listed in `spell_group_stack_rules` does not exist", stack_rule);
-            continue;
-        }
-
-        SpellGroupSpellMapBounds spellGroup = GetSpellGroupSpellMapBounds((SpellGroup)group_id);
-
-        if (spellGroup.first == spellGroup.second)
-        {
-            sLog.outErrorDb("SpellGroup id %u listed in `spell_group_stack_rules` does not exist", group_id);
-            continue;
-        }
-
-        mSpellGroupStack[(SpellGroup)group_id] = (SpellGroupStackRule)stack_rule;
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell group stack rules", count);
-}
-
-void SpellMgr::LoadSpellThreats()
-{
-    mSpellThreatMap.clear();                                // need for reload case
-
-    uint32 count = 0;
-
-    //                                                0      1
-    QueryResult result = WorldDatabase.Query("SELECT entry, Threat FROM spell_threat");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u aggro generating spells", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 entry = fields[0].GetUInt32();
-        uint16 Threat = fields[1].GetUInt16();
-
-        if (!sSpellStore.LookupEntry(entry))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_threat` does not exist", entry);
-            continue;
-        }
-
-        mSpellThreatMap[entry] = Threat;
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u aggro generating spells", count);
-}
-
-bool SpellMgr::IsRankSpellDueToSpell(SpellEntry const *spellInfo_1,uint32 spellId_2) const
-{
-    SpellEntry const *spellInfo_2 = sSpellStore.LookupEntry(spellId_2);
-    if (!spellInfo_1 || !spellInfo_2) return false;
-    if (spellInfo_1->Id == spellId_2) return false;
-
-    return GetFirstSpellInChain(spellInfo_1->Id) == GetFirstSpellInChain(spellId_2);
-}
-
-bool SpellMgr::canStackSpellRanks(SpellEntry const *spellInfo)
-{
-    if (IsPassiveSpell(spellInfo->Id))                       // ranked passive spell
-        return false;
-    if (spellInfo->powerType != POWER_MANA && spellInfo->powerType != POWER_HEALTH)
-        return false;
-    if (IsProfessionOrRidingSpell(spellInfo->Id))
-        return false;
-
-    if (sSpellMgr.IsSkillBonusSpell(spellInfo->Id))
-        return false;
-
-    // All stance spells. if any better way, change it.
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch(spellInfo->SpellFamilyName)
-        {
-            case SPELLFAMILY_PALADIN:
-                // Paladin aura Spell
-                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID)
-                    return false;
-                break;
-            case SPELLFAMILY_DRUID:
-                // Druid form Spell
-                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
-                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
-                    return false;
-                break;
-            case SPELLFAMILY_ROGUE:
-                // Rogue Stealth
-                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
-                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
-                    return false;
-        }
-    }
-    return true;
-}
-
-bool SpellMgr::IsProfessionOrRidingSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
-        {
-            uint32 skill = spellInfo->EffectMiscValue[i];
-
-            bool found = IsProfessionOrRidingSkill(skill);
-            if (found)
-                return true;
-        }
-    }
-    return false;
-}
-
-bool SpellMgr::IsProfessionSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
-        {
-            uint32 skill = spellInfo->EffectMiscValue[i];
-
-            bool found = IsProfessionSkill(skill);
-            if (found)
-                return true;
-        }
-    }
-    return false;
-}
-
-bool SpellMgr::IsPrimaryProfessionSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
-        {
-            uint32 skill = spellInfo->EffectMiscValue[i];
-
-            bool found = IsPrimaryProfessionSkill(skill);
-            if (found)
-                return true;
-        }
-    }
-    return false;
-}
-
-bool SpellMgr::IsPrimaryProfessionFirstRankSpell(uint32 spellId) const
-{
-    return IsPrimaryProfessionSpell(spellId) && GetSpellRank(spellId) == 1;
-}
-
-bool SpellMgr::IsSkillBonusSpell(uint32 spellId) const
-{
-    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
-
-    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
-    {
-        SkillLineAbilityEntry const *pAbility = _spell_idx->second;
-        if (!pAbility || pAbility->learnOnGetSkill != ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
-            continue;
-
-        if (pAbility->req_skill_value > 0)
-            return true;
-    }
-
-    return false;
-}
-
-bool SpellMgr::IsSkillTypeSpell(uint32 spellId, SkillType type) const
-{
-    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
-
-    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
-        if (_spell_idx->second->skillId == uint32(type))
-            return true;
-
-    return false;
-}
-
-// basepoints provided here have to be valid basepoints (use SpellMgr::CalculateSpellEffectBaseAmount)
-int32 SpellMgr::CalculateSpellEffectAmount(SpellEntry const * spellEntry, uint8 effIndex, Unit const * caster, int32 const * effBasePoints, Unit const * /*target*/)
-{
-    float basePointsPerLevel = spellEntry->EffectRealPointsPerLevel[effIndex];
-    int32 basePoints = effBasePoints ? *effBasePoints : spellEntry->EffectBasePoints[effIndex];
-    int32 randomPoints = int32(spellEntry->EffectDieSides[effIndex]);
-
-    // base amount modification based on spell lvl vs caster lvl
-    if (caster)
-    {
-        int32 level = int32(caster->getLevel());
-        if (level > int32(spellEntry->maxLevel) && spellEntry->maxLevel > 0)
-            level = int32(spellEntry->maxLevel);
-        else if (level < int32(spellEntry->baseLevel))
-            level = int32(spellEntry->baseLevel);
-        level -= int32(spellEntry->spellLevel);
-        basePoints += int32(level * basePointsPerLevel);
-    }
-
-    // roll in a range <1;EffectDieSides> as of patch 3.3.3
-    switch(randomPoints)
-    {
-        case 0: break;
-        case 1: basePoints += 1; break;                     // range 1..1
-        default:
-            // range can have positive (1..rand) and negative (rand..1) values, so order its for irand
-            int32 randvalue = (randomPoints >= 1)
-                ? irand(1, randomPoints)
-                : irand(randomPoints, 1);
-
-            basePoints += randvalue;
-            break;
-    }
-
-    int32 value = basePoints;
-
-    // random damage
-    if (caster)
-    {
-        // bonus amount from combo points
-        if  (caster->m_movedPlayer)
-            if (uint8 comboPoints = caster->m_movedPlayer->GetComboPoints())
-                if (float comboDamage = spellEntry->EffectPointsPerComboPoint[effIndex])
-                    value += int32(comboDamage * comboPoints);
-
-        value = caster->ApplyEffectModifiers(spellEntry, effIndex, value);
-
-        // amount multiplication based on caster's level
-        if (!basePointsPerLevel && (spellEntry->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION && spellEntry->spellLevel) &&
-                spellEntry->Effect[effIndex] != SPELL_EFFECT_WEAPON_PERCENT_DAMAGE &&
-                spellEntry->Effect[effIndex] != SPELL_EFFECT_KNOCK_BACK &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_ALWAYS &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_NOT_STACK &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_INCREASE_SPEED &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_DECREASE_SPEED)
-                //there are many more: slow speed, -healing pct
-            value = int32(value*0.25f*exp(caster->getLevel()*(70-spellEntry->spellLevel)/1000.0f));
-            //value = int32(value * (int32)getLevel() / (int32)(spellProto->spellLevel ? spellProto->spellLevel : 1));
-    }
-
-    return value;
-}
-
-int32 SpellMgr::CalculateSpellEffectBaseAmount(int32 value, SpellEntry const * spellEntry, uint8 effIndex)
-{
-    if (spellEntry->EffectDieSides[effIndex] == 0)
-        return value;
-    else
-        return value - 1;
-}
-
-float SpellMgr::CalculateSpellEffectValueMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
-{
-    float multiplier = spellEntry->EffectValueMultiplier[effIndex];
-
-    if (caster)
-        if (Player * modOwner = caster->GetSpellModOwner())
-            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_VALUE_MULTIPLIER, multiplier, spell);
-    return multiplier;
-}
-
-float SpellMgr::CalculateSpellEffectDamageMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
-{
-    float multiplier = spellEntry->EffectDamageMultiplier[effIndex];
-
-    if (caster)
-        if (Player * modOwner = caster->GetSpellModOwner())
-            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_DAMAGE_MULTIPLIER, multiplier, spell);
-    return multiplier;
-}
-
-SpellEntry const* SpellMgr::SelectAuraRankForPlayerLevel(SpellEntry const* spellInfo, uint32 playerLevel) const
-{
-    // ignore passive spells
-    if (IsPassiveSpell(spellInfo->Id))
-        return spellInfo;
-
-    bool needRankSelection = false;
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (IsPositiveEffect(spellInfo->Id, i) && (
-            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA ||
-            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
-            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID
-))
-        {
-            needRankSelection = true;
-            break;
-        }
-    }
-
-    // not required
-    if (!needRankSelection)
-        return spellInfo;
-
-    for (uint32 nextSpellId = spellInfo->Id; nextSpellId != 0; nextSpellId = GetPrevSpellInChain(nextSpellId))
-    {
-        SpellEntry const *nextSpellInfo = sSpellStore.LookupEntry(nextSpellId);
-        if (!nextSpellInfo)
-            break;
-
-        // if found appropriate level
-        if (playerLevel + 10 >= nextSpellInfo->spellLevel)
-            return nextSpellInfo;
-
-        // one rank less then
-    }
-
-    // not found
-    return NULL;
-}
-
-void SpellMgr::LoadSpellLearnSkills()
-{
-    mSpellLearnSkills.clear();                              // need for reload case
-
-    // search auto-learned skills and add its to map also for use in unlearn spells/talents
-    uint32 dbc_count = 0;
-    barGoLink bar(sSpellStore.GetNumRows());
-    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
-    {
-        bar.step();
-        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
-
-        if (!entry)
-            continue;
-
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (entry->Effect[i] == SPELL_EFFECT_SKILL)
-            {
-                SpellLearnSkillNode dbc_node;
-                dbc_node.skill = entry->EffectMiscValue[i];
-                dbc_node.step  = SpellMgr::CalculateSpellEffectAmount(entry, i);
-                if (dbc_node.skill != SKILL_RIDING)
-                    dbc_node.value = 1;
-                else
-                    dbc_node.value = dbc_node.step * 75;
-                dbc_node.maxvalue = dbc_node.step * 75;
-                mSpellLearnSkills[spell] = dbc_node;
-                ++dbc_count;
-                break;
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u Spell Learn Skills from DBC", dbc_count);
-}
-
-void SpellMgr::LoadSpellLearnSpells()
-{
-    mSpellLearnSpells.clear();                              // need for reload case
-
-    //                                                  0      1        2
-    QueryResult result = WorldDatabase.Query("SELECT entry, SpellID, Active FROM spell_learn_spell");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded 0 spell learn spells");
-        sLog.outErrorDb("`spell_learn_spell` table is empty!");
-        return;
-    }
-
-    uint32 count = 0;
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        bar.step();
-        Field *fields = result->Fetch();
-
-        uint32 spell_id = fields[0].GetUInt32();
-
-        SpellLearnSpellNode node;
-        node.spell      = fields[1].GetUInt32();
-        node.active     = fields[2].GetBool();
-        node.autoLearned= false;
-
-        if (!sSpellStore.LookupEntry(spell_id))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` does not exist", spell_id);
-            continue;
-        }
-
-        if (!sSpellStore.LookupEntry(node.spell))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` learning not existed spell %u", spell_id, node.spell);
-            continue;
-        }
-
-        if (GetTalentSpellCost(node.spell))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` attempt learning talent spell %u, skipped", spell_id, node.spell);
-            continue;
-        }
-
-        mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell_id,node));
-
-        ++count;
-    } while (result->NextRow());
-
-    // search auto-learned spells and add its to map also for use in unlearn spells/talents
-    uint32 dbc_count = 0;
-    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
-    {
-        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
-
-        if (!entry)
-            continue;
-
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (entry->Effect[i] == SPELL_EFFECT_LEARN_SPELL)
-            {
-                SpellLearnSpellNode dbc_node;
-                dbc_node.spell = entry->EffectTriggerSpell[i];
-                dbc_node.active = true;                     // all dbc based learned spells is active (show in spell book or hide by client itself)
-
-                // ignore learning not existed spells (broken/outdated/or generic learnig spell 483
-                if (!sSpellStore.LookupEntry(dbc_node.spell))
-                    continue;
-
-                // talent or passive spells or skill-step spells auto-casted and not need dependent learning,
-                // pet teaching spells don't must be dependent learning (casted)
-                // other required explicit dependent learning
-                dbc_node.autoLearned = entry->EffectImplicitTargetA[i] == TARGET_UNIT_PET || GetTalentSpellCost(spell) > 0 || IsPassiveSpell(spell) || IsSpellHaveEffect(entry,SPELL_EFFECT_SKILL_STEP);
-
-                SpellLearnSpellMapBounds db_node_bounds = GetSpellLearnSpellMapBounds(spell);
-
-                bool found = false;
-                for (SpellLearnSpellMap::const_iterator itr = db_node_bounds.first; itr != db_node_bounds.second; ++itr)
-                {
-                    if (itr->second.spell == dbc_node.spell)
-                    {
-                        sLog.outErrorDb("Spell %u auto-learn spell %u in spell.dbc then the record in `spell_learn_spell` is redundant, please fix DB.",
-                            spell,dbc_node.spell);
-                        found = true;
-                        break;
-                    }
-                }
-
-                if (!found)                                  // add new spell-spell pair if not found
-                {
-                    mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell,dbc_node));
-                    ++dbc_count;
-                }
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell learn spells + %u found in DBC", count, dbc_count);
-}
-
-void SpellMgr::LoadSpellPetAuras()
-{
-    mSpellPetAuraMap.clear();                                  // need for reload case
-
-    uint32 count = 0;
-
-    //                                                  0       1       2    3
-    QueryResult result = WorldDatabase.Query("SELECT spell, effectId, pet, aura FROM spell_pet_auras");
-    if (!result)
-    {
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell pet auras", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 spell = fields[0].GetUInt32();
-        uint8 eff = fields[1].GetUInt8();
-        uint32 pet = fields[2].GetUInt32();
-        uint32 aura = fields[3].GetUInt32();
-
-        SpellPetAuraMap::iterator itr = mSpellPetAuraMap.find((spell<<8) + eff);
-        if (itr != mSpellPetAuraMap.end())
-            itr->second.AddAura(pet, aura);
-        else
-        {
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell);
-            if (!spellInfo)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_pet_auras` does not exist", spell);
-                continue;
-            }
-            if (spellInfo->Effect[eff] != SPELL_EFFECT_DUMMY &&
-               (spellInfo->Effect[eff] != SPELL_EFFECT_APPLY_AURA ||
-                spellInfo->EffectApplyAuraName[eff] != SPELL_AURA_DUMMY))
-            {
-                sLog.outError("Spell %u listed in `spell_pet_auras` does not have dummy aura or dummy effect", spell);
-                continue;
-            }
-
-            SpellEntry const* spellInfo2 = sSpellStore.LookupEntry(aura);
-            if (!spellInfo2)
-            {
-                sLog.outErrorDb("Aura %u listed in `spell_pet_auras` does not exist", aura);
-                continue;
-            }
-
-            PetAura pa(pet, aura, spellInfo->EffectImplicitTargetA[eff] == TARGET_UNIT_PET, SpellMgr::CalculateSpellEffectAmount(spellInfo, eff));
-            mSpellPetAuraMap[(spell<<8) + eff] = pa;
-        }
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell pet auras", count);
-}
-
-void SpellMgr::LoadPetLevelupSpellMap()
-{
-    mPetLevelupSpellMap.clear();                                   // need for reload case
-
-    uint32 count = 0;
-    uint32 family_count = 0;
-
-    barGoLink bar(sCreatureFamilyStore.GetNumRows());
-
-    for (uint32 i = 0; i < sCreatureFamilyStore.GetNumRows(); ++i)
-    {
-        bar.step();
-
-        CreatureFamilyEntry const *creatureFamily = sCreatureFamilyStore.LookupEntry(i);
-        if (!creatureFamily)                                     // not exist
-            continue;
-
-        for (uint8 j = 0; j < 2; ++j)
-        {
-            if (!creatureFamily->skillLine[j])
-                continue;
-
-            for (uint32 k = 0; k < sSkillLineAbilityStore.GetNumRows(); ++k)
-            {
-                SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(k);
-                if (!skillLine)
-                    continue;
-
-                //if (skillLine->skillId != creatureFamily->skillLine[0] &&
-                //    (!creatureFamily->skillLine[1] || skillLine->skillId != creatureFamily->skillLine[1]))
-                //    continue;
-
-                if (skillLine->skillId != creatureFamily->skillLine[j])
-                    continue;
-
-                if (skillLine->learnOnGetSkill != ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL)
-                    continue;
-
-                SpellEntry const *spell = sSpellStore.LookupEntry(skillLine->spellId);
-                if (!spell) // not exist or triggered or talent
-                    continue;
-
-                if (!spell->spellLevel)
-                    continue;
-
-                PetLevelupSpellSet& spellSet = mPetLevelupSpellMap[creatureFamily->ID];
-                if (spellSet.empty())
-                    ++family_count;
-
-                spellSet.insert(PetLevelupSpellSet::value_type(spell->spellLevel,spell->Id));
-                ++count;
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u pet levelup and default spells for %u families", count, family_count);
-}
-
-bool LoadPetDefaultSpells_helper(CreatureInfo const* cInfo, PetDefaultSpellsEntry& petDefSpells)
-{
-    // skip empty list;
-    bool have_spell = false;
-    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-    {
-        if (petDefSpells.spellid[j])
-        {
-            have_spell = true;
-            break;
-        }
-    }
-    if (!have_spell)
-        return false;
-
-    // remove duplicates with levelupSpells if any
-    if (PetLevelupSpellSet const *levelupSpells = cInfo->family ? sSpellMgr.GetPetLevelupSpellList(cInfo->family) : NULL)
-    {
-        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-        {
-            if (!petDefSpells.spellid[j])
-                continue;
-
-            for (PetLevelupSpellSet::const_iterator itr = levelupSpells->begin(); itr != levelupSpells->end(); ++itr)
-            {
-                if (itr->second == petDefSpells.spellid[j])
-                {
-                    petDefSpells.spellid[j] = 0;
-                    break;
-                }
-            }
-        }
-    }
-
-    // skip empty list;
-    have_spell = false;
-    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-    {
-        if (petDefSpells.spellid[j])
-        {
-            have_spell = true;
-            break;
-        }
-    }
-
-    return have_spell;
-}
-
-void SpellMgr::LoadPetDefaultSpells()
-{
-    mPetDefaultSpellsMap.clear();
-
-    uint32 countCreature = 0;
-    uint32 countData = 0;
-
-    barGoLink bar(sCreatureStorage.MaxEntry + sSpellStore.GetNumRows());
-
-    for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
-    {
-        bar.step();
-
-        CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i);
-        if (!cInfo)
-            continue;
-
-        if (!cInfo->PetSpellDataId)
-            continue;
-
-        // for creature with PetSpellDataId get default pet spells from dbc
-        CreatureSpellDataEntry const* spellDataEntry = sCreatureSpellDataStore.LookupEntry(cInfo->PetSpellDataId);
-        if (!spellDataEntry)
-            continue;
-
-        int32 petSpellsId = -int32(cInfo->PetSpellDataId);
-        PetDefaultSpellsEntry petDefSpells;
-        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-            petDefSpells.spellid[j] = spellDataEntry->spellId[j];
-
-        if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
-        {
-            mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
-            ++countData;
-        }
-    }
-
-    // different summon spells
-    for (uint32 i = 0; i < sSpellStore.GetNumRows(); ++i)
-    {
-        bar.step();
-
-        SpellEntry const* spellEntry = sSpellStore.LookupEntry(i);
-        if (!spellEntry)
-            continue;
-
-        for (uint8 k = 0; k < MAX_SPELL_EFFECTS; ++k)
-        {
-            if (spellEntry->Effect[k] == SPELL_EFFECT_SUMMON || spellEntry->Effect[k] == SPELL_EFFECT_SUMMON_PET)
-            {
-                uint32 creature_id = spellEntry->EffectMiscValue[k];
-                CreatureInfo const *cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(creature_id);
-                if (!cInfo)
-                    continue;
-
-                // already loaded
-                if (cInfo->PetSpellDataId)
-                    continue;
-
-                // for creature without PetSpellDataId get default pet spells from creature_template
-                int32 petSpellsId = cInfo->Entry;
-                if (mPetDefaultSpellsMap.find(cInfo->Entry) != mPetDefaultSpellsMap.end())
-                    continue;
-
-                PetDefaultSpellsEntry petDefSpells;
-                for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-                    petDefSpells.spellid[j] = cInfo->spells[j];
-
-                if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
-                {
-                    mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
-                    ++countCreature;
-                }
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded addition spells for %u pet spell data entries.", countData);
-    sLog.outString(">> Loaded %u summonable creature templates.", countCreature);
-}
-
-/// Some checks for spells, to prevent adding deprecated/broken spells for trainers, spell book, etc
-bool SpellMgr::IsSpellValid(SpellEntry const *spellInfo, Player *pl, bool msg)
-{
-    // not exist
-    if (!spellInfo)
-        return false;
-
-    bool need_check_reagents = false;
-
-    // check effects
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch (spellInfo->Effect[i])
-        {
-            case 0:
-                continue;
-
-            // craft spell for crafting non-existed item (break client recipes list show)
-            case SPELL_EFFECT_CREATE_ITEM:
-            case SPELL_EFFECT_CREATE_ITEM_2:
-            {
-                if (spellInfo->EffectItemType[i] == 0)
-                {
-                    // skip auto-loot crafting spells, its not need explicit item info (but have special fake items sometime)
-                    if (!IsLootCraftingSpell(spellInfo))
-                    {
-                        if (msg)
-                        {
-                            if (pl)
-                                ChatHandler(pl).PSendSysMessage("Craft spell %u not have create item entry.",spellInfo->Id);
-                            else
-                                sLog.outErrorDb("Craft spell %u not have create item entry.",spellInfo->Id);
-                        }
-                        return false;
-                    }
-
-                }
-                // also possible IsLootCraftingSpell case but fake item must exist anyway
-                else if (!ObjectMgr::GetItemPrototype(spellInfo->EffectItemType[i]))
-                {
-                    if (msg)
-                    {
-                        if (pl)
-                            ChatHandler(pl).PSendSysMessage("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
-                        else
-                            sLog.outErrorDb("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
-                    }
-                    return false;
-                }
-
-                need_check_reagents = true;
-                break;
-            }
-            case SPELL_EFFECT_LEARN_SPELL:
-            {
-                SpellEntry const *spellInfo2 = sSpellStore.LookupEntry(spellInfo->EffectTriggerSpell[i]);
-                if (!IsSpellValid(spellInfo2,pl,msg))
-                {
-                    if (msg)
-                    {
-                        if (pl)
-                            ChatHandler(pl).PSendSysMessage("Spell %u learn to broken spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
-                        else
-                            sLog.outErrorDb("Spell %u learn to invalid spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
-                    }
-                    return false;
-                }
-                break;
-            }
-        }
-    }
-
-    if (need_check_reagents)
-    {
-        for (uint8 j = 0; j < MAX_SPELL_REAGENTS; ++j)
-        {
-            if (spellInfo->Reagent[j] > 0 && !ObjectMgr::GetItemPrototype(spellInfo->Reagent[j]))
-            {
-                if (msg)
-                {
-                    if (pl)
-                        ChatHandler(pl).PSendSysMessage("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
-                    else
-                        sLog.outErrorDb("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
-                }
-                return false;
-            }
-        }
-    }
-
-    return true;
-}
-
-void SpellMgr::LoadSpellAreas()
-{
-    mSpellAreaMap.clear();                                  // need for reload case
-    mSpellAreaForQuestMap.clear();
-    mSpellAreaForActiveQuestMap.clear();
-    mSpellAreaForQuestEndMap.clear();
-    mSpellAreaForAuraMap.clear();
-
-    uint32 count = 0;
-
-    //                                                  0     1         2              3               4           5          6        7       8
-    QueryResult result = WorldDatabase.Query("SELECT spell, area, quest_start, quest_start_active, quest_end, aura_spell, racemask, gender, autocast FROM spell_area");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell area requirements", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 spell = fields[0].GetUInt32();
-        SpellArea spellArea;
-        spellArea.spellId             = spell;
-        spellArea.areaId              = fields[1].GetUInt32();
-        spellArea.questStart          = fields[2].GetUInt32();
-        spellArea.questStartCanActive = fields[3].GetBool();
-        spellArea.questEnd            = fields[4].GetUInt32();
-        spellArea.auraSpell           = fields[5].GetInt32();
-        spellArea.raceMask            = fields[6].GetUInt32();
-        spellArea.gender              = Gender(fields[7].GetUInt8());
-        spellArea.autocast            = fields[8].GetBool();
-
-        if (const SpellEntry* spellInfo = sSpellStore.LookupEntry(spell))
-        {
-            if (spellArea.autocast)
-                const_cast<SpellEntry*>(spellInfo)->Attributes |= SPELL_ATTR_CANT_CANCEL;
-        }
-        else
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` does not exist", spell);
-            continue;
-        }
-
-        {
-            bool ok = true;
-            SpellAreaMapBounds sa_bounds = GetSpellAreaMapBounds(spellArea.spellId);
-            for (SpellAreaMap::const_iterator itr = sa_bounds.first; itr != sa_bounds.second; ++itr)
-            {
-                if (spellArea.spellId != itr->second.spellId)
-                    continue;
-                if (spellArea.areaId != itr->second.areaId)
-                    continue;
-                if (spellArea.questStart != itr->second.questStart)
-                    continue;
-                if (spellArea.auraSpell != itr->second.auraSpell)
-                    continue;
-                if ((spellArea.raceMask & itr->second.raceMask) == 0)
-                    continue;
-                if (spellArea.gender != itr->second.gender)
-                    continue;
-
-                // duplicate by requirements
-                ok =false;
-                break;
-            }
-
-            if (!ok)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` already listed with similar requirements.", spell);
-                continue;
-            }
-        }
-
-        if (spellArea.areaId && !GetAreaEntryByAreaID(spellArea.areaId))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong area (%u) requirement", spell,spellArea.areaId);
-            continue;
-        }
-
-        if (spellArea.questStart && !sObjectMgr.GetQuestTemplate(spellArea.questStart))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong start quest (%u) requirement", spell,spellArea.questStart);
-            continue;
-        }
-
-        if (spellArea.questEnd)
-        {
-            if (!sObjectMgr.GetQuestTemplate(spellArea.questEnd))
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong end quest (%u) requirement", spell,spellArea.questEnd);
-                continue;
-            }
-
-            if (spellArea.questEnd == spellArea.questStart && !spellArea.questStartCanActive)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have quest (%u) requirement for start and end in same time", spell,spellArea.questEnd);
-                continue;
-            }
-        }
-
-        if (spellArea.auraSpell)
-        {
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(spellArea.auraSpell));
-            if (!spellInfo)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong aura spell (%u) requirement", spell,abs(spellArea.auraSpell));
-                continue;
-            }
-
-            if (uint32(abs(spellArea.auraSpell)) == spellArea.spellId)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement for itself", spell,abs(spellArea.auraSpell));
-                continue;
-            }
-
-            // not allow autocast chains by auraSpell field (but allow use as alternative if not present)
-            if (spellArea.autocast && spellArea.auraSpell > 0)
-            {
-                bool chain = false;
-                SpellAreaForAuraMapBounds saBound = GetSpellAreaForAuraMapBounds(spellArea.spellId);
-                for (SpellAreaForAuraMap::const_iterator itr = saBound.first; itr != saBound.second; ++itr)
-                {
-                    if (itr->second->autocast && itr->second->auraSpell > 0)
-                    {
-                        chain = true;
-                        break;
-                    }
-                }
-
-                if (chain)
-                {
-                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
-                    continue;
-                }
-
-                SpellAreaMapBounds saBound2 = GetSpellAreaMapBounds(spellArea.auraSpell);
-                for (SpellAreaMap::const_iterator itr2 = saBound2.first; itr2 != saBound2.second; ++itr2)
-                {
-                    if (itr2->second.autocast && itr2->second.auraSpell > 0)
-                    {
-                        chain = true;
-                        break;
-                    }
-                }
-
-                if (chain)
-                {
-                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
-                    continue;
-                }
-            }
-        }
-
-        if (spellArea.raceMask && (spellArea.raceMask & RACEMASK_ALL_PLAYABLE) == 0)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong race mask (%u) requirement", spell,spellArea.raceMask);
-            continue;
-        }
-
-        if (spellArea.gender != GENDER_NONE && spellArea.gender != GENDER_FEMALE && spellArea.gender != GENDER_MALE)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong gender (%u) requirement", spell, spellArea.gender);
-            continue;
-        }
-
-        SpellArea const* sa = &mSpellAreaMap.insert(SpellAreaMap::value_type(spell,spellArea))->second;
-
-        // for search by current zone/subzone at zone/subzone change
-        if (spellArea.areaId)
-            mSpellAreaForAreaMap.insert(SpellAreaForAreaMap::value_type(spellArea.areaId,sa));
-
-        // for search at quest start/reward
-        if (spellArea.questStart)
-        {
-            if (spellArea.questStartCanActive)
-                mSpellAreaForActiveQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
-            else
-                mSpellAreaForQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
-        }
-
-        // for search at quest start/reward
-        if (spellArea.questEnd)
-            mSpellAreaForQuestEndMap.insert(SpellAreaForQuestMap::value_type(spellArea.questEnd,sa));
-
-        // for search at aura apply
-        if (spellArea.auraSpell)
-            mSpellAreaForAuraMap.insert(SpellAreaForAuraMap::value_type(abs(spellArea.auraSpell),sa));
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell area requirements", count);
-}
-
-SpellCastResult SpellMgr::GetSpellAllowedInLocationError(SpellEntry const *spellInfo, uint32 map_id, uint32 zone_id, uint32 area_id, Player const* player)
-{
-    // normal case
-    if (spellInfo->AreaGroupId > 0)
-    {
-        bool found = false;
-        AreaGroupEntry const* groupEntry = sAreaGroupStore.LookupEntry(spellInfo->AreaGroupId);
-        while (groupEntry)
-        {
-            for (uint8 i = 0; i < MAX_GROUP_AREA_IDS; ++i)
-                if (groupEntry->AreaId[i] == zone_id || groupEntry->AreaId[i] == area_id)
-                    found = true;
-            if (found || !groupEntry->nextGroup)
-                break;
-            // Try search in next group
-            groupEntry = sAreaGroupStore.LookupEntry(groupEntry->nextGroup);
-        }
-
-        if (!found)
-            return SPELL_FAILED_INCORRECT_AREA;
-    }
-
-    // continent limitation (virtual continent)
-    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_CAST_ONLY_IN_OUTLAND)
-    {
-        uint32 v_map = GetVirtualMapForMapAndZone(map_id, zone_id);
-        MapEntry const *mapEntry = sMapStore.LookupEntry(v_map);
-        if (!mapEntry || mapEntry->addon < 1 || !mapEntry->IsContinent())
-            return SPELL_FAILED_INCORRECT_AREA;
-    }
-
-    // raid instance limitation
-    if (spellInfo->AttributesEx6 & SPELL_ATTR_EX6_NOT_IN_RAID_INSTANCE)
-    {
-        MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-        if (!mapEntry || mapEntry->IsRaid())
-            return SPELL_FAILED_NOT_IN_RAID_INSTANCE;
-    }
-
-    // DB base check (if non empty then must fit at least single for allow)
-    SpellAreaMapBounds saBounds = sSpellMgr.GetSpellAreaMapBounds(spellInfo->Id);
-    if (saBounds.first != saBounds.second)
-    {
-        for (SpellAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
-        {
-            if (itr->second.IsFitToRequirements(player,zone_id,area_id))
-                return SPELL_CAST_OK;
-        }
-        return SPELL_FAILED_INCORRECT_AREA;
-    }
-
-    // bg spell checks
-    switch(spellInfo->Id)
-    {
-        case 23333:                                         // Warsong Flag
-        case 23335:                                         // Silverwing Flag
-            return map_id == 489 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        case 34976:                                         // Netherstorm Flag
-            return map_id == 566 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        case 2584:                                          // Waiting to Resurrect
-        case 22011:                                         // Spirit Heal Channel
-        case 22012:                                         // Spirit Heal
-        case 24171:                                         // Resurrection Impact Visual
-        case 42792:                                         // Recently Dropped Flag
-        case 43681:                                         // Inactive
-        case 44535:                                         // Spirit Heal (mana)
-        {
-            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            return zone_id == 4197 || (mapEntry->IsBattleground() && player && player->InBattleground()) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-        case 44521:                                         // Preparation
-        {
-            if (!player)
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            if (!mapEntry->IsBattleground())
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            Battleground* bg = player->GetBattleground();
-            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-        case 32724:                                         // Gold Team (Alliance)
-        case 32725:                                         // Green Team (Alliance)
-        case 35774:                                         // Gold Team (Horde)
-        case 35775:                                         // Green Team (Horde)
-        {
-            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            return mapEntry->IsBattleArena() && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-        case 32727:                                         // Arena Preparation
-        {
-            if (!player)
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            if (!mapEntry->IsBattleArena())
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            Battleground *bg = player->GetBattleground();
-            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-    }
-
-    // aura limitations
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch (spellInfo->EffectApplyAuraName[i])
-        {
-            case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
-            case SPELL_AURA_FLY:
-            {
-                if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
-                    return SPELL_FAILED_INCORRECT_AREA;
-            }
-        }
-    }
-
-    return SPELL_CAST_OK;
-}
-
-void SpellMgr::LoadSkillLineAbilityMap()
-{
-    mSkillLineAbilityMap.clear();
-
-    barGoLink bar(sSkillLineAbilityStore.GetNumRows());
-    uint32 count = 0;
-
-    for (uint32 i = 0; i < sSkillLineAbilityStore.GetNumRows(); ++i)
-    {
-        bar.step();
-        SkillLineAbilityEntry const *SkillInfo = sSkillLineAbilityStore.LookupEntry(i);
-        if (!SkillInfo)
-            continue;
-
-        mSkillLineAbilityMap.insert(SkillLineAbilityMap::value_type(SkillInfo->spellId,SkillInfo));
-        ++count;
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u SkillLineAbility MultiMap Data", count);
-}
-
-DiminishingGroup GetDiminishingReturnsGroupForSpell(SpellEntry const* spellproto, bool triggered)
-{
-    // Explicit Diminishing Groups
-    switch (spellproto->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-            // some generic arena related spells have by some strange reason MECHANIC_TURN
-            if  (spellproto->Mechanic == MECHANIC_TURN)
-                return DIMINISHING_NONE;
-            break;
-        case SPELLFAMILY_MAGE:
-        {
-            // Frostbite
-            if (spellproto->SpellFamilyFlags[1] & 0x80000000)
-                return DIMINISHING_TRIGGER_ROOT;
-            //Shattered Barrier: only flag SpellFamilyFlags[0] = 0x00080000 shared
-            //by most frost spells, using id instead
-            if (spellproto->Id == 55080)
-                return DIMINISHING_TRIGGER_ROOT;
-            // Frost Nova / Freeze (Water Elemental)
-            if (spellproto->SpellIconID == 193)
-                return DIMINISHING_CONTROL_ROOT;
-            break;
-        }
-        case SPELLFAMILY_ROGUE:
-        {
-            // Sap 0x80 Gouge 0x8
-            if (spellproto->SpellFamilyFlags[0] & 0x88)
-                return DIMINISHING_POLYMORPH;
-            // Blind
-            else if (spellproto->SpellFamilyFlags[0] & 0x1000000)
-                return DIMINISHING_FEAR_BLIND;
-            // Cheap Shot
-            else if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return DIMINISHING_CHEAPSHOT_POUNCE;
-            // Crippling poison - Limit to 10 seconds in PvP (No SpellFamilyFlags)
-            else if (spellproto->SpellIconID == 163)
-                return DIMINISHING_LIMITONLY;
-            break;
-        }
-        case SPELLFAMILY_WARLOCK:
-        {
-            // Death Coil
-            if (spellproto->SpellFamilyFlags[0] & 0x80000)
-                return DIMINISHING_DEATHCOIL;
-            // Curses/etc
-            else if (spellproto->SpellFamilyFlags[0] & 0x80000000)
-                return DIMINISHING_LIMITONLY;
-            // Howl of Terror
-            else if (spellproto->SpellFamilyFlags[1] & 0x8)
-                return DIMINISHING_FEAR_BLIND;
-            // Seduction
-            else if (spellproto->SpellFamilyFlags[0] & 0x40000000)
-                return DIMINISHING_FEAR_BLIND;
-            break;
-        }
-        case SPELLFAMILY_DRUID:
-        {
-            // Pounce
-            if (spellproto->SpellFamilyFlags[0] & 0x20000)
-                return DIMINISHING_CHEAPSHOT_POUNCE;
-            // Cyclone
-            else if (spellproto->SpellFamilyFlags[1] & 0x20)
-                return DIMINISHING_CYCLONE;
-            // Entangling Roots: to force natures grasp proc to be control root
-            else if (spellproto->SpellFamilyFlags[0] & 0x00000200)
-                return DIMINISHING_CONTROL_ROOT;
-            // Faerie Fire
-            else if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return DIMINISHING_LIMITONLY;
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            // Hamstring - limit duration to 10s in PvP
-            if (spellproto->SpellFamilyFlags[0] & 0x2)
-                return DIMINISHING_LIMITONLY;
-            // Intimidating Shout
-            else if (spellproto->SpellFamilyFlags[0] & 0x40000)
-                return DIMINISHING_FEAR_BLIND;
-            // Charge Stun
-            else if (spellproto->SpellFamilyFlags[0] & 0x01000000)
-                return DIMINISHING_NONE;
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Repentance
-            if (spellproto->SpellFamilyFlags[0] & 0x4)
-                return DIMINISHING_POLYMORPH;
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Hungering Cold (no flags)
-            if (spellproto->SpellIconID == 2797)
-                return DIMINISHING_POLYMORPH;
-            // Mark of Blood
-            else if ((spellproto->SpellFamilyFlags[0] & 0x10000000)
-                && spellproto->SpellIconID == 2285)
-                return DIMINISHING_LIMITONLY;
-            break;
-        }
-        case SPELLFAMILY_HUNTER:
-        {
-            // Hunter's mark
-            if ((spellproto->SpellFamilyFlags[0] & 0x400) && spellproto->SpellIconID == 538)
-                return DIMINISHING_LIMITONLY;
-            // Scatter Shot
-            if ((spellproto->SpellFamilyFlags[0] & 0x40000) && spellproto->SpellIconID == 132)
-                return DIMINISHING_NONE;
-            break;
-        }
-        default:
-            break;
-    }
-
-    // Get by mechanic
-    uint32 mechanic = GetAllSpellMechanicMask(spellproto);
-    if (mechanic == MECHANIC_NONE)          return DIMINISHING_NONE;
-    if (mechanic & ((1<<MECHANIC_STUN) |
-                    (1<<MECHANIC_SHACKLE))) return triggered ? DIMINISHING_TRIGGER_STUN : DIMINISHING_CONTROL_STUN;
-    if (mechanic & ((1<<MECHANIC_SLEEP) |
-                    (1<<MECHANIC_FREEZE))) return DIMINISHING_FREEZE_SLEEP;
-    if (mechanic & (1<<MECHANIC_POLYMORPH)) return DIMINISHING_POLYMORPH;
-    if (mechanic & (1<<MECHANIC_ROOT))      return triggered ? DIMINISHING_TRIGGER_ROOT : DIMINISHING_CONTROL_ROOT;
-    if (mechanic & ((1<<MECHANIC_FEAR) |
-                    (1<<MECHANIC_TURN)))    return DIMINISHING_FEAR_BLIND;
-    if (mechanic & (1<<MECHANIC_CHARM))     return DIMINISHING_CHARM;
-    if (mechanic & (1<<MECHANIC_SILENCE))   return DIMINISHING_SILENCE;
-    if (mechanic & (1<<MECHANIC_DISARM))    return DIMINISHING_DISARM;
-    if (mechanic & (1<<MECHANIC_FREEZE))    return DIMINISHING_FREEZE_SLEEP;
-    if (mechanic & ((1<<MECHANIC_KNOCKOUT) |
-                    (1<<MECHANIC_SAPPED)))  return DIMINISHING_KNOCKOUT;
-    if (mechanic & (1<<MECHANIC_BANISH))    return DIMINISHING_BANISH;
-    if (mechanic & (1<<MECHANIC_HORROR))    return DIMINISHING_DEATHCOIL;
-
-    // Get by effect
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_TAUNT)
-            return DIMINISHING_TAUNT;
-    }
-    return DIMINISHING_NONE;
-}
-
-int32 GetDiminishingReturnsLimitDuration(DiminishingGroup group, SpellEntry const* spellproto)
-{
-    if (!IsDiminishingReturnsGroupDurationLimited(group))
-        return 0;
-
-    // Explicit diminishing duration
-    switch(spellproto->SpellFamilyName)
-    {
-        case SPELLFAMILY_HUNTER:
-        {
-            // Wyvern Sting
-            if (spellproto->SpellFamilyFlags[1] & 0x1000)
-                return 6 * IN_MILLISECONDS;
-            // Hunter's Mark
-            if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return 120 * IN_MILLISECONDS;
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Repentance - limit to 6 seconds in PvP
-            if (spellproto->SpellFamilyFlags[0] & 0x4)
-                return 6 * IN_MILLISECONDS;
-            break;
-        }
-        case SPELLFAMILY_DRUID:
-        {
-            // Faerie Fire - limit to 40 seconds in PvP (3.1)
-            if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return 40 * IN_MILLISECONDS;
-            break;
-        }
-        default:
-            break;
-    }
-
-    return 10 * IN_MILLISECONDS;
-}
-
-bool IsDiminishingReturnsGroupDurationLimited(DiminishingGroup group)
-{
-    switch(group)
-    {
-        case DIMINISHING_CONTROL_STUN:
-        case DIMINISHING_TRIGGER_STUN:
-        case DIMINISHING_FREEZE_SLEEP:
-        case DIMINISHING_CONTROL_ROOT:
-        case DIMINISHING_TRIGGER_ROOT:
-        case DIMINISHING_FEAR_BLIND:
-        case DIMINISHING_CHARM:
-        case DIMINISHING_POLYMORPH:
-        case DIMINISHING_KNOCKOUT:
-        case DIMINISHING_CYCLONE:
-        case DIMINISHING_BANISH:
-        case DIMINISHING_LIMITONLY:
-        case DIMINISHING_CHEAPSHOT_POUNCE:
-            return true;
-        default:
-            return false;
-    }
-}
-
-DiminishingLevels GetDiminishingReturnsMaxLevel(DiminishingGroup group)
-{
-    switch(group)
-    {
-        case DIMINISHING_TAUNT:
-            return DIMINISHING_LEVEL_TAUNT_IMMUNE;
-        default:
-            return DIMINISHING_LEVEL_IMMUNE;
-    }
-}
-
-DiminishingReturnsType GetDiminishingReturnsGroupType(DiminishingGroup group)
-{
-    switch(group)
-    {
-        case DIMINISHING_TAUNT:
-        case DIMINISHING_CONTROL_STUN:
-        case DIMINISHING_TRIGGER_STUN:
-        case DIMINISHING_CHEAPSHOT_POUNCE:
-        case DIMINISHING_CYCLONE:
-            return DRTYPE_ALL;
-        case DIMINISHING_FEAR_BLIND:
-        case DIMINISHING_CONTROL_ROOT:
-        case DIMINISHING_TRIGGER_ROOT:
-        case DIMINISHING_CHARM:
-        case DIMINISHING_POLYMORPH:
-        case DIMINISHING_SILENCE:
-        case DIMINISHING_DISARM:
-        case DIMINISHING_DEATHCOIL:
-        case DIMINISHING_FREEZE_SLEEP:
-        case DIMINISHING_BANISH:
-        case DIMINISHING_KNOCKOUT:
-            return DRTYPE_PLAYER;
-        default:
-            break;
-    }
-
-    return DRTYPE_NONE;
-}
-
-bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32 newArea) const
-{
-    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
-
-    if (gender != GENDER_NONE)                   // not in expected gender
-        if (!player || gender != player->getGender())
-            return false;
-
-    if (raceMask)                                // not in expected race
-        if (!player || !(raceMask & player->getRaceMask()))
-            return false;
-
-    if (areaId)                                  // not in expected zone
-        if (newZone != areaId && newArea != areaId)
-            return false;
-
-    if (questStart)                              // not in expected required quest state
-        if (!player || ((!questStartCanActive || !player->IsActiveQuest(questStart)) && !player->GetQuestRewardStatus(questStart)))
-            return false;
-
-    if (questEnd)                                // not in expected forbidden quest state
-        if (!player || player->GetQuestRewardStatus(questEnd))
-            return false;
-
-    if (auraSpell)                               // not have expected aura
-        if (!player || (auraSpell > 0 && !player->HasAura(auraSpell)) || (auraSpell < 0 && player->HasAura(-auraSpell)))
-            return false;
-
-    // Extra conditions -- leaving the possibility add extra conditions...
-    switch(spellId)
-    {
-        case 58600: // No fly Zone - Dalaran
-			{
-            if (!player)
-                return false;
-
-            AreaTableEntry const* pArea = GetAreaEntryByAreaID(player->GetAreaId());
-            if (!(pArea && pArea->flags & AREA_FLAG_NO_FLY_ZONE))
-                return false;
-            if (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY))
-                return false;
-			}
-            break;
-        case 58730: // No fly Zone - Wintergrasp
-			{
-				if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
-				{
-				  if ((pvpWG->isWarTime()==false) || !player || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)) || player->HasAura(45472) || player->HasAura(44795) || player->GetPositionZ() > 619.2f || player->isInFlight())
-				    return false;
-				}
-			}
-            break;
-        case 58045: // Essence of Wintergrasp - Wintergrasp
-        case 57940: // Essence of Wintergrasp - Northrend
-             if (!player || player->GetTeamId() != sWorld.getWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION))
-             return false;
-            break;
-    }
-
-    return true;
-}
-
-//-----------TRINITY-------------
-
-bool SpellMgr::CanAurasStack(SpellEntry const *spellInfo_1, SpellEntry const *spellInfo_2, bool sameCaster) const
-{
-    SpellSpecific spellSpec_1 = GetSpellSpecific(spellInfo_1);
-    SpellSpecific spellSpec_2 = GetSpellSpecific(spellInfo_2);
-    if (spellSpec_1 && spellSpec_2)
-        if (IsSingleFromSpellSpecificPerTarget(spellSpec_1, spellSpec_2)
-            || (sameCaster && IsSingleFromSpellSpecificPerCaster(spellSpec_1, spellSpec_2)))
-            return false;
-
-    SpellGroupStackRule stackRule = CheckSpellGroupStackRules(spellInfo_1->Id, spellInfo_2->Id);
-    if (stackRule)
-    {
-        if (stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE)
-            return false;
-        if (sameCaster && stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE_FROM_SAME_CASTER)
-            return false;
-    }
-
-    if (spellInfo_1->SpellFamilyName != spellInfo_2->SpellFamilyName)
-        return true;
-
-    if (!sameCaster)
-    {
-        if (spellInfo_1->AttributesEx & SPELL_ATTR_EX_STACK_FOR_DIFF_CASTERS
-            || spellInfo_1->AttributesEx3 & SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS)
-            return true;
-
-        // check same periodic auras
-        for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            switch(spellInfo_1->EffectApplyAuraName[i])
-            {
-                // DOT or HOT from different casters will stack
-                case SPELL_AURA_PERIODIC_DAMAGE:
-                case SPELL_AURA_PERIODIC_DUMMY:
-                case SPELL_AURA_PERIODIC_HEAL:
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
-                case SPELL_AURA_PERIODIC_ENERGIZE:
-                case SPELL_AURA_PERIODIC_MANA_LEECH:
-                case SPELL_AURA_PERIODIC_LEECH:
-                case SPELL_AURA_POWER_BURN_MANA:
-                case SPELL_AURA_OBS_MOD_POWER:
-                case SPELL_AURA_OBS_MOD_HEALTH:
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
-                    return true;
-                default:
-                    break;
-            }
-        }
-    }
-
-    uint32 spellId_1 = GetLastSpellInChain(spellInfo_1->Id);
-    uint32 spellId_2 = GetLastSpellInChain(spellInfo_2->Id);
-
-    // same spell
-    if (spellId_1 == spellId_2)
-    {
-        // Hack for Incanter's Absorption
-        if (spellId_1 == 44413)
-            return true;
-        // same spell with same caster should not stack
-        return false;
-    }
-
-    return true;
-}
-
-bool CanSpellDispelAura(SpellEntry const * dispelSpell, SpellEntry const * aura)
-{
-    // These auras (like ressurection sickness) can't be dispelled
-    if (aura->Attributes & SPELL_ATTR_NEGATIVE_1)
-        return false;
-
-    // These spells (like Mass Dispel) can dispell all auras
-    if (dispelSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return true;
-
-    // These auras (like Divine Shield) can't be dispelled
-    if (aura->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return false;
-
-    // These auras (Cyclone for example) are not dispelable
-    if (aura->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
-        return false;
-
-    return true;
-}
-
-bool CanSpellPierceImmuneAura(SpellEntry const * pierceSpell, SpellEntry const * aura)
-{
-    // these spells pierce all avalible spells (Resurrection Sickness for example)
-    if (pierceSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return true;
-
-    // these spells (Cyclone for example) can pierce all...
-    if ((pierceSpell->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
-        // ...but not these (Divine shield for example)
-        && !(aura && (aura->Mechanic == MECHANIC_IMMUNE_SHIELD || aura->Mechanic == MECHANIC_INVULNERABILITY)))
-        return true;
-
-    return false;
-}
-
-void SpellMgr::LoadSpellEnchantProcData()
-{
-    mSpellEnchantProcEventMap.clear();                             // need for reload case
-
-    uint32 count = 0;
-
-    //                                                  0         1           2         3
-    QueryResult result = WorldDatabase.Query("SELECT entry, customChance, PPMChance, procEx FROM spell_enchant_proc_data");
-    if (!result)
-    {
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell enchant proc event conditions", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 enchantId = fields[0].GetUInt32();
-
-        SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchantId);
-        if (!ench)
-        {
-            sLog.outErrorDb("Enchancment %u listed in `spell_enchant_proc_data` does not exist", enchantId);
-            continue;
-        }
-
-        SpellEnchantProcEntry spe;
-
-        spe.customChance = fields[1].GetUInt32();
-        spe.PPMChance = fields[2].GetFloat();
-        spe.procEx = fields[3].GetUInt32();
-
-        mSpellEnchantProcEventMap[enchantId] = spe;
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u enchant proc data definitions", count);
-}
-
-void SpellMgr::LoadSpellRequired()
-{
-    mSpellsReqSpell.clear();                                   // need for reload case
-    mSpellReq.clear();                                         // need for reload case
-
-    QueryResult result = WorldDatabase.Query("SELECT spell_id, req_spell from spell_required");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded 0 spell required records");
-        sLog.outErrorDb("`spell_required` table is empty!");
-        return;
-    }
-    uint32 rows = 0;
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        bar.step();
-        Field *fields = result->Fetch();
-
-        uint32 spell_id =  fields[0].GetUInt32();
-        uint32 spell_req = fields[1].GetUInt32();
-        // check if chain is made with valid first spell
-        SpellEntry const * spell = sSpellStore.LookupEntry(spell_id);
-        if (!spell)
-        {
-            sLog.outErrorDb("spell_id %u in `spell_required` table is not found in dbcs, skipped", spell_id);
-            continue;
-        }
-        SpellEntry const * req_spell = sSpellStore.LookupEntry(spell_req);
-        if (!req_spell)
-        {
-            sLog.outErrorDb("req_spell %u in `spell_required` table is not found in dbcs, skipped", spell_req);
-            continue;
-        }
-        if (GetFirstSpellInChain(spell_id) == GetFirstSpellInChain(spell_req))
-        {
-            sLog.outErrorDb("req_spell %u and spell_id %u in `spell_required` table are ranks of the same spell, entry not needed, skipped", spell_req, spell_id);
-            continue;
-        }
-        if (IsSpellRequiringSpell(spell_id, spell_req))
-        {
-            sLog.outErrorDb("duplicated entry of req_spell %u and spell_id %u in `spell_required`, skipped", spell_req, spell_id);
-            continue;
-        }
-
-        mSpellReq.insert (std::pair<uint32, uint32>(spell_id, spell_req));
-        mSpellsReqSpell.insert (std::pair<uint32, uint32>(spell_req, spell_id));
-        ++rows;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell required records", rows);
-}
-
-void SpellMgr::LoadSpellRanks()
-{
-    mSpellChains.clear();                                   // need for reload case
-
-    QueryResult result = WorldDatabase.Query("SELECT first_spell_id, spell_id, rank from spell_ranks ORDER BY first_spell_id , rank");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded 0 spell rank records");
-        sLog.outErrorDb("`spell_ranks` table is empty!");
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    uint32 rows = 0;
-    bool finished = false;
-
-    do
-    {
-                        // spellid, rank
-        std::list < std::pair < int32, int32 > > rankChain;
-        int32 currentSpell = -1;
-        int32 lastSpell = -1;
-
-        // fill one chain
-        while (currentSpell == lastSpell && !finished)
-        {
-            Field *fields = result->Fetch();
-
-            currentSpell = fields[0].GetUInt32();
-            if (lastSpell == -1)
-                lastSpell = currentSpell;
-            uint32 spell_id = fields[1].GetUInt32();
-            uint32 rank = fields[2].GetUInt32();
-
-            // don't drop the row if we're moving to the next rank
-            if (currentSpell == lastSpell)
-            {
-                bar.step();
-                rankChain.push_back(std::make_pair(spell_id, rank));
-                if (!result->NextRow())
-                    finished = true;
-            }
-            else
-                break;
-        }
-        // check if chain is made with valid first spell
-        SpellEntry const * first = sSpellStore.LookupEntry(lastSpell);
-        if (!first)
-        {
-            sLog.outErrorDb("Spell rank identifier(first_spell_id) %u listed in `spell_ranks` does not exist!", lastSpell);
-            continue;
-        }
-        // check if chain is long enough
-        if (rankChain.size() < 2)
-        {
-            sLog.outErrorDb("There is only 1 spell rank for identifier(first_spell_id) %u in `spell_ranks`, entry is not needed!", lastSpell);
-            continue;
-        }
-        int32 curRank = 0;
-        bool valid = true;
-        // check spells in chain
-        for (std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin() ; itr!= rankChain.end(); ++itr)
-        {
-            SpellEntry const * spell = sSpellStore.LookupEntry(itr->first);
-            if (!spell)
-            {
-                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not exist!", itr->first, itr->second, lastSpell);
-                valid = false;
-                break;
-            }
-            ++curRank;
-            if (itr->second != curRank)
-            {
-                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not have proper rank value(should be %u)!", itr->first, itr->second, lastSpell, curRank);
-                valid = false;
-                break;
-            }
-        }
-        if (!valid)
-            continue;
-        int32 prevRank = 0;
-        // insert the chain
-        std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin();
-        do
-        {
-            ++rows;
-            int32 addedSpell = itr->first;
-            mSpellChains[addedSpell].first = lastSpell;
-            mSpellChains[addedSpell].last = rankChain.back().first;
-            mSpellChains[addedSpell].rank = itr->second;
-            mSpellChains[addedSpell].prev = prevRank;
-            prevRank = addedSpell;
-            ++itr;
-            if (itr == rankChain.end())
-            {
-                mSpellChains[addedSpell].next = 0;
-                break;
-            }
-            else
-                mSpellChains[addedSpell].next = itr->first;
-        }
-        while (true);
-    } while (!finished);
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell rank records", rows);
-}
-
-// set data in core for now
-void SpellMgr::LoadSpellCustomAttr()
-{
-    mSpellCustomAttr.resize(GetSpellStore()->GetNumRows());
-
-    barGoLink bar(GetSpellStore()->GetNumRows());
-
-    uint32 count = 0;
-
-    SpellEntry *spellInfo;
-    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
-    {
-        bar.step();
-
-        mSpellCustomAttr[i] = 0;
-        spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
-        if (!spellInfo)
-            continue;
-
-        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            switch (spellInfo->Effect[j])
-            {
-                case SPELL_EFFECT_SCHOOL_DAMAGE:
-                case SPELL_EFFECT_WEAPON_DAMAGE:
-                case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-                case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                case SPELL_EFFECT_HEAL:
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_DIRECT_DAMAGE;
-                    count++;
-                    break;
-                case SPELL_EFFECT_CHARGE:
-                case SPELL_EFFECT_CHARGE_DEST:
-                case SPELL_EFFECT_JUMP:
-                case SPELL_EFFECT_JUMP_DEST:
-                case SPELL_EFFECT_LEAP_BACK:
-                    if (!spellInfo->speed && !spellInfo->SpellFamilyName)
-                        spellInfo->speed = SPEED_CHARGE;
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_CHARGE;
-                    count++;
-                    break;
-                case SPELL_EFFECT_PICKPOCKET:
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_PICKPOCKET;
-                    break;
-                case SPELL_EFFECT_TRIGGER_SPELL:
-                    if (IsPositionTarget(spellInfo->EffectImplicitTargetA[j]) ||
-                        spellInfo->Targets & (TARGET_FLAG_SOURCE_LOCATION|TARGET_FLAG_DEST_LOCATION))
-                        spellInfo->Effect[j] = SPELL_EFFECT_TRIGGER_MISSILE;
-                    count++;
-                    break;
-            }
-
-            switch (SpellTargetType[spellInfo->EffectImplicitTargetA[j]])
-            {
-                case TARGET_TYPE_UNIT_TARGET:
-                case TARGET_TYPE_DEST_TARGET:
-                    spellInfo->Targets |= TARGET_FLAG_UNIT;
-                    count++;
-                    break;
-                default:
-                    break;
-            }
-        }
-
-        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            switch (spellInfo->EffectApplyAuraName[j])
-            {
-                case SPELL_AURA_MOD_POSSESS:
-                case SPELL_AURA_MOD_CONFUSE:
-                case SPELL_AURA_MOD_CHARM:
-                case SPELL_AURA_AOE_CHARM:
-                case SPELL_AURA_MOD_FEAR:
-                case SPELL_AURA_MOD_STUN:
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
-                    count++;
-                    break;
-            }
-        }
-
-        if (!_isPositiveEffect(i, 0, false))
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF0;
-            count++;
-        }
-        if (!_isPositiveEffect(i, 1, false))
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF1;
-            count++;
-        }
-        if (!_isPositiveEffect(i, 2, false))
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF2;
-            count++;
-        }
-
-        if (spellInfo->SpellVisual[0] == 3879)
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_BACK;
-            count++;
-        }
-
-        if (spellInfo->activeIconID == 2158)  // flight
-        {
-            spellInfo->Attributes |= SPELL_ATTR_PASSIVE;
-            count++;
-        }
-
-        switch(i)
-        {
-        // Bind
-        case 3286:
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_TARGET_ENEMY;
-            spellInfo->EffectImplicitTargetA[1] = TARGET_UNIT_TARGET_ENEMY;
-            count++;
-            break;
-        // Heroism
-        case 32182:
-            spellInfo->excludeCasterAuraSpell = 57723; // Exhaustion
-            count++;
-            break;
-        // Blazing Harpoon
-        case 61588:
-            spellInfo->MaxAffectedTargets = 1;
-            count++;
-            break;
-        // Bloodlust
-        case 2825:
-            spellInfo->excludeCasterAuraSpell = 57724; // Sated
-            count++;
-            break;
-        // Heart of the Crusader
-        case 20335:
-        case 20336:
-        case 20337:
-        // Glyph of Life Tap
-        case 63320:
-        // Entries were not updated after spell effect change, we have to do that manually :/
-            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_CAN_PROC_TRIGGERED;
-            count++;
-            break;
-        case 16007: // Draco-Incarcinatrix 900
-            // was 46, but effect is aura effect
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_NEARBY_ENTRY;
-            spellInfo->EffectImplicitTargetB[0] = TARGET_DST_NEARBY_ENTRY;
-            count++;
-            break;
-        case 26029: // dark glare
-        case 37433: // spout
-        case 43140: case 43215: // flame breath
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_LINE;
-            count++;
-            break;
-        case 24340: case 26558: case 28884:     // Meteor
-        case 36837: case 38903: case 41276:     // Meteor
-        case 57467:                             // Meteor
-        case 26789:                             // Shard of the Fallen Star
-        case 31436:                             // Malevolent Cleave
-        case 35181:                             // Dive Bomb
-        case 40810: case 43267: case 43268:     // Saber Lash
-        case 42384:                             // Brutal Swipe
-        case 45150:                             // Meteor Slash
-        case 64422: case 64688:                 // Sonic Screech
-        case 72373:                             // Shared Suffering
-        case 71904:                             // Chaos Bane
-            // ONLY SPELLS WITH SPELLFAMILY_GENERIC and EFFECT_SCHOOL_DAMAGE
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_SHARE_DAMAGE;
-            count++;
-            break;
-        case 59725:                             // Improved Spell Reflection - aoe aura
-            // Target entry seems to be wrong for this spell :/
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_PARTY_CASTER;
-            spellInfo->EffectRadiusIndex[0] = 45;
-            count++;
-            break;
-        case 27820:                             // Mana Detonation
-        //case 28062: case 39090:                 // Positive/Negative Charge
-        //case 28085: case 39093:
-        case 69782: case 69796:                 // Ooze Flood
-        case 69798: case 69801:                 // Ooze Flood
-        case 69538: case 69553: case 69610:     // Ooze Combine
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
-            count++;
-            break;
-        case 44978: case 45001: case 45002:     // Wild Magic
-        case 45004: case 45006: case 45010:     // Wild Magic
-        case 31347: // Doom
-        case 41635: // Prayer of Mending
-        case 44869: // Spectral Blast
-        case 45027: // Revitalize
-        case 45976: // Muru Portal Channel
-        case 39365: // Thundering Storm
-        case 41071: // Raise Dead (HACK)
-        case 52124: // Sky Darkener Assault
-        case 42442: // Vengeance Landing Cannonfire
-        case 45863: // Cosmetic - Incinerate to Random Target
-        case 25425: // Shoot
-        case 45761: // Shoot
-        case 42611: // Shoot
-        case 62374: // Pursued
-            spellInfo->MaxAffectedTargets = 1;
-            count++;
-            break;
-        case 52479: // Gift of the Harvester
-            spellInfo->MaxAffectedTargets = 1;
-            // a trap always has dst = src?
-            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_CASTER;
-            spellInfo->EffectImplicitTargetA[1] = TARGET_DST_CASTER;
-            count++;
-            break;
-        case 41376: // Spite
-        case 39992: // Needle Spine
-        case 29576: // Multi-Shot
-        case 40816: // Saber Lash
-        case 37790: // Spread Shot
-        case 46771: // Flame Sear
-        case 45248: // Shadow Blades
-        case 41303: // Soul Drain
-        case 54172: // Divine Storm (heal)
-        case 29213: // Curse of the Plaguebringer - Noth
-        case 28542: // Life Drain - Sapphiron
-        case 66588: // Flaming Spear
-        case 54171: // Divine Storm
-            spellInfo->MaxAffectedTargets = 3;
-            count++;
-            break;
-        case 38310: // Multi-Shot
-        case 53385: // Divine Storm (Damage)
-            spellInfo->MaxAffectedTargets = 4;
-            count++;
-            break;
-        case 42005: // Bloodboil
-        case 38296: // Spitfire Totem
-        case 37676: // Insidious Whisper
-        case 46008: // Negative Energy
-        case 45641: // Fire Bloom
-        case 55665: // Life Drain - Sapphiron (H)
-        case 28796: // Poison Bolt Volly - Faerlina
-            spellInfo->MaxAffectedTargets = 5;
-            count++;
-            break;
-        case 40827: // Sinful Beam
-        case 40859: // Sinister Beam
-        case 40860: // Vile Beam
-        case 40861: // Wicked Beam
-        case 54835: // Curse of the Plaguebringer - Noth (H)
-        case 54098: // Poison Bolt Volly - Faerlina (H)
-            spellInfo->MaxAffectedTargets = 10;
-            count++;
-            break;
-        case 50312: // Unholy Frenzy
-            spellInfo->MaxAffectedTargets = 15;
-            count++;
-            break;
-        case 38794: case 33711: //Murmur's Touch
-            spellInfo->MaxAffectedTargets = 1;
-            spellInfo->EffectTriggerSpell[0] = 33760;
-            count++;
-            break;
-        case 17941:    // Shadow Trance
-        case 22008:    // Netherwind Focus
-        case 31834:    // Light's Grace
-        case 34754:    // Clearcasting
-        case 34936:    // Backlash
-        case 48108:    // Hot Streak
-        case 51124:    // Killing Machine
-        case 54741:    // Firestarter
-        case 57761:    // Fireball!
-        case 39805:    // Lightning Overload
-        case 64823:    // Item - Druid T8 Balance 4P Bonus
-        case 44401:
-            spellInfo->procCharges = 1;
-            count++;
-            break;
-        case 53390: // Tidal Wave
-            spellInfo->procCharges = 2;
-            count++;
-            break;
-        case 44544:    // Fingers of Frost
-            spellInfo->EffectSpellClassMask[0] = flag96(685904631, 1151048, 0);
-            count++;
-            break;
-        case 74396:    // Fingers of Frost visual buff
-            spellInfo->procCharges = 2;
-            spellInfo->StackAmount = 0;
-            count++;
-            break;
-        case 28200:    // Ascendance (Talisman of Ascendance trinket)
-            spellInfo->procCharges = 6;
-            count++;
-            break;
-        case 47201:    // Everlasting Affliction
-        case 47202:
-        case 47203:
-        case 47204:
-        case 47205:
-            // add corruption to affected spells
-            spellInfo->EffectSpellClassMask[1][0] |= 2;
-            count++;
-            break;
-        case 51852:    // The Eye of Acherus (no spawn in phase 2 in db)
-            spellInfo->EffectMiscValue[0] |= 1;
-            count++;
-            break;
-        case 52025:    // Cleansing Totem Effect
-            spellInfo->EffectDieSides[1] = 1;
-            count++;
-            break;
-        case 51904:     // Summon Ghouls On Scarlet Crusade (core does not know the triggered spell is summon spell)
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
-            count++;
-            break;
-        case 29809:     // Desecration Arm - 36 instead of 37 - typo? :/
-            spellInfo->EffectRadiusIndex[0] = 37;
-            count++;
-            break;
-        // Master Shapeshifter: missing stance data for forms other than bear - bear version has correct data
-        // To prevent aura staying on target after talent unlearned
-        case 48420:
-            spellInfo->Stances = 1 << (FORM_CAT - 1);
-            count++;
-            break;
-        case 48421:
-            spellInfo->Stances = 1 << (FORM_MOONKIN - 1);
-            count++;
-            break;
-        case 48422:
-            spellInfo->Stances = 1 << (FORM_TREE - 1);
-            count++;
-            break;
-        case 30421:     // Nether Portal - Perseverence
-            spellInfo->EffectBasePoints[2] += 30000;
-            count++;
-            break;
-        // some dummy spell only has dest, should push caster in this case
-        case 62324: // Throw Passenger
-            spellInfo->Targets |= TARGET_FLAG_UNIT_CASTER;
-            count++;
-            break;
-        case 51735: // Ebon Plague
-        case 51734:
-        case 51726:
-            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS;
-            spellInfo->SpellFamilyFlags[2] = 0x10;
-            count++;
-            break;
-        case 41013:     // Parasitic Shadowfiend Passive
-            spellInfo->EffectApplyAuraName[0] = 4; // proc debuff, and summon infinite fiends
-            count++;
-            break;
-        case 27892:     // To Anchor 1
-        case 27928:     // To Anchor 1
-        case 27935:     // To Anchor 1
-        case 27915:     // Anchor to Skulls
-        case 27931:     // Anchor to Skulls
-        case 27937:     // Anchor to Skulls
-            spellInfo->rangeIndex = 13;
-            count++;
-            break;
-        case 48743: // Death Pact
-            spellInfo->AttributesEx &= ~SPELL_ATTR_EX_CANT_TARGET_SELF;
-            count++;
-            break;
-        // target allys instead of enemies, target A is src_caster, spells with effect like that have ally target
-        // this is the only known exception, probably just wrong data
-        case 29214: // Wrath of the Plaguebringer
-        case 54836: // Wrath of the Plaguebringer
-            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_AREA_ALLY_SRC;
-            spellInfo->EffectImplicitTargetB[1] = TARGET_UNIT_AREA_ALLY_SRC;
-            count++;
-            break;
-        case 31687: // Summon Water Elemental
-            // 322-330 switch - effect changed to dummy, target entry not changed in client:(
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
-            count++;
-            break;
-        case 25771: // Forbearance - wrong mechanic immunity in DBC since 3.0.x
-            spellInfo->EffectMiscValue[0] = MECHANIC_IMMUNE_SHIELD;
-            count++;
-            break;
-        case 64321: // Potent Pheromones
-            // spell should dispel area aura, but doesn't have the attribute
-            // may be db data bug, or blizz may keep reapplying area auras every update with checking immunity
-            // that will be clear if we get more spells with problem like this
-            spellInfo->AttributesEx |= SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY;
-            count++;
-            break;
-        case 69055:     // Saber Lash
-        case 70814:     // Saber Lash
-            spellInfo->EffectRadiusIndex[0] = 8;
-            count++;
-            break;
-        case 69075:     // Bone Storm
-        case 70834:     // Bone Storm
-        case 70835:     // Bone Storm
-        case 70836:     // Bone Storm
-            spellInfo->EffectRadiusIndex[0] = 12;
-            count++;
-            break;
-        case 18500: // Wing Buffet
-        case 33086: // Wild Bite
-        case 49749: // Piercing Blow
-        case 52890: // Penetrating Strike
-        case 53454: // Impale
-        case 59446: // Impale
-        case 62383: // Shatter
-        case 64777: // Machine Gun
-        case 65239: // Machine Gun
-        case 65919: // Impale
-        case 67858: // Impale
-        case 67859: // Impale
-        case 67860: // Impale
-        case 69293: // Wing Buffet
-        case 74439: // Machine Gun
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_IGNORE_ARMOR;
-            count++;
-            break;
-        // THESE SPELLS ARE WORKING CORRECTLY EVEN WITHOUT THIS HACK
-        // THE ONLY REASON ITS HERE IS THAT CURRENT GRID SYSTEM
-        // DOES NOT ALLOW FAR OBJECT SELECTION (dist > 333)
-        case 70781: // Light's Hammer Teleport
-        case 70856: // Oratory of the Damned Teleport
-        case 70857: // Rampart of Skulls Teleport
-        case 70858: // Deathbringer's Rise Teleport
-        case 70859: // Upper Spire Teleport
-        case 70860: // Frozen Throne Teleport
-        case 70861: // Sindragosa's Lair Teleport
-            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_DB;
-            count++;
-            break;
-        case 63675: // Improved Devouring Plague
-            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_NO_DONE_BONUS;
-            count++;
-            break;
-        case 53241: // Marked for Death (Rank 1)
-        case 53243: // Marked for Death (Rank 2)
-        case 53244: // Marked for Death (Rank 3)
-        case 53245: // Marked for Death (Rank 4)
-        case 53246: // Marked for Death (Rank 5)
-            spellInfo->EffectSpellClassMask[0] = flag96(423937, 276955137, 2049);
-            count++;
-            break;
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "SpellMgr.h"
+#include "ObjectMgr.h"
+#include "SpellAuraDefines.h"
+#include "ProgressBar.h"
+#include "DBCStores.h"
+#include "World.h"
+#include "Chat.h"
+#include "Spell.h"
+#include "BattlegroundMgr.h"
+#include "CreatureAI.h"
+#include "MapManager.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
+
+bool IsAreaEffectTarget[TOTAL_SPELL_TARGETS];
+SpellEffectTargetTypes EffectTargetType[TOTAL_SPELL_EFFECTS];
+SpellSelectTargetTypes SpellTargetType[TOTAL_SPELL_TARGETS];
+
+SpellMgr::SpellMgr()
+{
+    for (int i = 0; i < TOTAL_SPELL_EFFECTS; ++i)
+    {
+        switch(i)
+        {
+            case SPELL_EFFECT_PERSISTENT_AREA_AURA: //27
+            case SPELL_EFFECT_SUMMON:               //28
+            case SPELL_EFFECT_TRIGGER_MISSILE:      //32
+            case SPELL_EFFECT_TRANS_DOOR:           //50 summon object
+            case SPELL_EFFECT_SUMMON_PET:           //56
+            case SPELL_EFFECT_ADD_FARSIGHT:         //72
+            case SPELL_EFFECT_SUMMON_OBJECT_WILD:   //76
+            //case SPELL_EFFECT_SUMMON_CRITTER:       //97 not 303
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT1:  //104
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT2:  //105
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT3:  //106
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT4:  //107
+            case SPELL_EFFECT_SUMMON_DEAD_PET:      //109
+            case SPELL_EFFECT_TRIGGER_SPELL_2:      //151 ritual of summon
+                EffectTargetType[i] = SPELL_REQUIRE_DEST;
+                break;
+            case SPELL_EFFECT_PARRY: // 0
+            case SPELL_EFFECT_BLOCK: // 0
+            case SPELL_EFFECT_SKILL: // always with dummy 3 as A
+            //case SPELL_EFFECT_LEARN_SPELL: // 0 may be 5 pet
+            case SPELL_EFFECT_TRADE_SKILL: // 0 or 1
+            case SPELL_EFFECT_PROFICIENCY: // 0
+                EffectTargetType[i] = SPELL_REQUIRE_NONE;
+                break;
+            case SPELL_EFFECT_ENCHANT_ITEM:
+            case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
+            case SPELL_EFFECT_DISENCHANT:
+            //in 243 this is 0, in 309 it is 1
+            //so both item target and unit target is pushed, and cause crash
+            //case SPELL_EFFECT_FEED_PET:
+            case SPELL_EFFECT_PROSPECTING:
+            case SPELL_EFFECT_MILLING:
+            case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
+                EffectTargetType[i] = SPELL_REQUIRE_ITEM;
+                break;
+            //caster must be pushed otherwise no sound
+            case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
+            case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
+            case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
+            case SPELL_EFFECT_APPLY_AREA_AURA_PET:
+            case SPELL_EFFECT_APPLY_AREA_AURA_OWNER:
+            case SPELL_EFFECT_APPLY_AREA_AURA_RAID:
+            case SPELL_EFFECT_CHARGE:
+            case SPELL_EFFECT_CHARGE_DEST:
+            case SPELL_EFFECT_JUMP:
+            case SPELL_EFFECT_JUMP_DEST:
+            case SPELL_EFFECT_LEAP_BACK:
+                EffectTargetType[i] = SPELL_REQUIRE_CASTER;
+                break;
+            //case SPELL_EFFECT_WMO_DAMAGE:
+            //case SPELL_EFFECT_WMO_REPAIR:
+            //case SPELL_EFFECT_WMO_CHANGE:
+            //    EffectTargetType[i] = SPELL_REQUIRE_GOBJECT;
+            //    break;
+            default:
+                EffectTargetType[i] = SPELL_REQUIRE_UNIT;
+                break;
+        }
+    }
+
+    for (int i = 0; i < TOTAL_SPELL_TARGETS; ++i)
+    {
+        switch(i)
+        {
+            case TARGET_UNIT_CASTER:
+            case TARGET_UNIT_CASTER_FISHING:
+            case TARGET_UNIT_MASTER:
+            case TARGET_UNIT_PET:
+            case TARGET_UNIT_PARTY_CASTER:
+            case TARGET_UNIT_RAID_CASTER:
+            case TARGET_UNIT_VEHICLE:
+            case TARGET_UNIT_PASSENGER_0:
+            case TARGET_UNIT_PASSENGER_1:
+            case TARGET_UNIT_PASSENGER_2:
+            case TARGET_UNIT_PASSENGER_3:
+            case TARGET_UNIT_PASSENGER_4:
+            case TARGET_UNIT_PASSENGER_5:
+            case TARGET_UNIT_PASSENGER_6:
+            case TARGET_UNIT_PASSENGER_7:
+            case TARGET_UNIT_SUMMONER:
+                SpellTargetType[i] = TARGET_TYPE_UNIT_CASTER;
+                break;
+            case TARGET_UNIT_TARGET_PUPPET:
+            case TARGET_UNIT_TARGET_ALLY:
+            case TARGET_UNIT_TARGET_RAID:
+            case TARGET_UNIT_TARGET_ANY:
+            case TARGET_UNIT_TARGET_ENEMY:
+            case TARGET_UNIT_TARGET_PARTY:
+            case TARGET_UNIT_PARTY_TARGET:
+            case TARGET_UNIT_CLASS_TARGET:
+            case TARGET_UNIT_CHAINHEAL:
+                SpellTargetType[i] = TARGET_TYPE_UNIT_TARGET;
+                break;
+            case TARGET_UNIT_NEARBY_ENEMY:
+            case TARGET_UNIT_NEARBY_ALLY:
+            case TARGET_UNIT_NEARBY_ALLY_UNK:
+            case TARGET_UNIT_NEARBY_ENTRY:
+            case TARGET_UNIT_NEARBY_RAID:
+            case TARGET_GAMEOBJECT_NEARBY_ENTRY:
+                SpellTargetType[i] = TARGET_TYPE_UNIT_NEARBY;
+                break;
+            case TARGET_UNIT_AREA_ENEMY_SRC:
+            case TARGET_UNIT_AREA_ALLY_SRC:
+            case TARGET_UNIT_AREA_ENTRY_SRC:
+            case TARGET_UNIT_AREA_PARTY_SRC:
+            case TARGET_GAMEOBJECT_AREA_SRC:
+                SpellTargetType[i] = TARGET_TYPE_AREA_SRC;
+                break;
+            case TARGET_UNIT_AREA_ENEMY_DST:
+            case TARGET_UNIT_AREA_ALLY_DST:
+            case TARGET_UNIT_AREA_ENTRY_DST:
+            case TARGET_UNIT_AREA_PARTY_DST:
+            case TARGET_GAMEOBJECT_AREA_DST:
+                SpellTargetType[i] = TARGET_TYPE_AREA_DST;
+                break;
+            case TARGET_UNIT_CONE_ENEMY:
+            case TARGET_UNIT_CONE_ALLY:
+            case TARGET_UNIT_CONE_ENTRY:
+            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
+            case TARGET_UNIT_AREA_PATH:
+            case TARGET_GAMEOBJECT_AREA_PATH:
+                SpellTargetType[i] = TARGET_TYPE_AREA_CONE;
+                break;
+            case TARGET_DST_CASTER:
+            case TARGET_SRC_CASTER:
+            case TARGET_MINION:
+            case TARGET_DEST_CASTER_FRONT_LEAP:
+            case TARGET_DEST_CASTER_FRONT:
+            case TARGET_DEST_CASTER_BACK:
+            case TARGET_DEST_CASTER_RIGHT:
+            case TARGET_DEST_CASTER_LEFT:
+            case TARGET_DEST_CASTER_FRONT_LEFT:
+            case TARGET_DEST_CASTER_BACK_LEFT:
+            case TARGET_DEST_CASTER_BACK_RIGHT:
+            case TARGET_DEST_CASTER_FRONT_RIGHT:
+            case TARGET_DEST_CASTER_RANDOM:
+            case TARGET_DEST_CASTER_RADIUS:
+                SpellTargetType[i] = TARGET_TYPE_DEST_CASTER;
+                break;
+            case TARGET_DST_TARGET_ENEMY:
+            case TARGET_DEST_TARGET_ANY:
+            case TARGET_DEST_TARGET_FRONT:
+            case TARGET_DEST_TARGET_BACK:
+            case TARGET_DEST_TARGET_RIGHT:
+            case TARGET_DEST_TARGET_LEFT:
+            case TARGET_DEST_TARGET_FRONT_LEFT:
+            case TARGET_DEST_TARGET_BACK_LEFT:
+            case TARGET_DEST_TARGET_BACK_RIGHT:
+            case TARGET_DEST_TARGET_FRONT_RIGHT:
+            case TARGET_DEST_TARGET_RANDOM:
+            case TARGET_DEST_TARGET_RADIUS:
+                SpellTargetType[i] = TARGET_TYPE_DEST_TARGET;
+                break;
+            case TARGET_DEST_DYNOBJ_ENEMY:
+            case TARGET_DEST_DYNOBJ_ALLY:
+            case TARGET_DEST_DYNOBJ_NONE:
+            case TARGET_DEST_DEST:
+            case TARGET_DEST_TRAJ:
+            case TARGET_DEST_DEST_FRONT_LEFT:
+            case TARGET_DEST_DEST_BACK_LEFT:
+            case TARGET_DEST_DEST_BACK_RIGHT:
+            case TARGET_DEST_DEST_FRONT_RIGHT:
+            case TARGET_DEST_DEST_FRONT:
+            case TARGET_DEST_DEST_BACK:
+            case TARGET_DEST_DEST_RIGHT:
+            case TARGET_DEST_DEST_LEFT:
+            case TARGET_DEST_DEST_RANDOM:
+            case TARGET_DEST_DEST_RANDOM_DIR_DIST:
+                SpellTargetType[i] = TARGET_TYPE_DEST_DEST;
+                break;
+            case TARGET_DST_DB:
+            case TARGET_DST_HOME:
+            case TARGET_DST_NEARBY_ENTRY:
+                SpellTargetType[i] = TARGET_TYPE_DEST_SPECIAL;
+                break;
+            case TARGET_UNIT_CHANNEL_TARGET:
+            case TARGET_DEST_CHANNEL_TARGET:
+            case TARGET_DEST_CHANNEL_CASTER:
+                SpellTargetType[i] = TARGET_TYPE_CHANNEL;
+                break;
+            default:
+                SpellTargetType[i] = TARGET_TYPE_DEFAULT;
+        }
+    }
+
+    for (int32 i = 0; i < TOTAL_SPELL_TARGETS; ++i)
+    {
+        switch(i)
+        {
+            case TARGET_UNIT_AREA_ENEMY_DST:
+            case TARGET_UNIT_AREA_ENEMY_SRC:
+            case TARGET_UNIT_AREA_ALLY_DST:
+            case TARGET_UNIT_AREA_ALLY_SRC:
+            case TARGET_UNIT_AREA_ENTRY_DST:
+            case TARGET_UNIT_AREA_ENTRY_SRC:
+            case TARGET_UNIT_AREA_PARTY_DST:
+            case TARGET_UNIT_AREA_PARTY_SRC:
+            case TARGET_UNIT_PARTY_TARGET:
+            case TARGET_UNIT_PARTY_CASTER:
+            case TARGET_UNIT_CONE_ENEMY:
+            case TARGET_UNIT_CONE_ALLY:
+            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
+            case TARGET_UNIT_AREA_PATH:
+            case TARGET_GAMEOBJECT_AREA_PATH:
+            case TARGET_UNIT_RAID_CASTER:
+                IsAreaEffectTarget[i] = true;
+                break;
+            default:
+                IsAreaEffectTarget[i] = false;
+                break;
+        }
+    }
+}
+
+SpellMgr::~SpellMgr()
+{
+}
+
+SpellMgr& SpellMgr::Instance()
+{
+    static SpellMgr spellMgr;
+    return spellMgr;
+}
+
+bool SpellMgr::IsSrcTargetSpell(SpellEntry const *spellInfo) const
+{
+    for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
+    {
+        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_AREA_SRC || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_AREA_SRC)
+            return true;
+    }
+    return false;
+}
+
+int32 GetSpellDuration(SpellEntry const *spellInfo)
+{
+    if (!spellInfo)
+        return 0;
+    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
+    if (!du)
+        return 0;
+    return (du->Duration[0] == -1) ? -1 : abs(du->Duration[0]);
+}
+
+int32 GetSpellMaxDuration(SpellEntry const *spellInfo)
+{
+    if (!spellInfo)
+        return 0;
+    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
+    if (!du)
+        return 0;
+    return (du->Duration[2] == -1) ? -1 : abs(du->Duration[2]);
+}
+
+uint32 GetDispelChance(Unit* auraCaster, Unit* target, uint32 spellId, bool offensive, bool *result)
+{
+    // we assume that aura dispel chance is 100% on start
+    // need formula for level difference based chance
+    int32 resist_chance = 0;
+
+    // Apply dispel mod from aura caster
+    if (auraCaster)
+        if (Player* modOwner = auraCaster->GetSpellModOwner())
+            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_DISPEL_CHANCE, resist_chance);
+
+    // Dispel resistance from target SPELL_AURA_MOD_DISPEL_RESIST
+    // Only affects offensive dispels
+    if (offensive && target)
+        resist_chance += target->GetTotalAuraModifier(SPELL_AURA_MOD_DISPEL_RESIST);
+
+    // Try dispel
+    if (result)
+        *result = !roll_chance_i(resist_chance);
+
+    resist_chance = resist_chance < 0 ? 0 : resist_chance;
+    resist_chance = resist_chance > 100 ? 100 : resist_chance;
+    return 100 - resist_chance;
+}
+
+uint32 GetSpellCastTime(SpellEntry const* spellInfo, Spell * spell)
+{
+    SpellCastTimesEntry const *spellCastTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
+
+    // not all spells have cast time index and this is all is pasiive abilities
+    if (!spellCastTimeEntry)
+        return 0;
+
+    int32 castTime = spellCastTimeEntry->CastTime;
+
+    if (spell && spell->GetCaster())
+        spell->GetCaster()->ModSpellCastTime(spellInfo, castTime, spell);
+
+    if (spellInfo->Attributes & SPELL_ATTR_REQ_AMMO && (!spell || !(spell->IsAutoRepeat())))
+        castTime += 500;
+
+    return (castTime > 0) ? uint32(castTime) : 0;
+}
+
+bool IsPassiveSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+    return IsPassiveSpell(spellInfo);
+}
+
+bool IsPassiveSpell(SpellEntry const * spellInfo)
+{
+    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
+        return true;
+    return false;
+}
+
+bool IsAutocastableSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
+        return false;
+    if (spellInfo->AttributesEx & SPELL_ATTR_EX_UNAUTOCASTABLE_BY_PET)
+        return false;
+    return true;
+}
+
+bool IsHigherHankOfSpell(uint32 spellId_1, uint32 spellId_2)
+{
+    return sSpellMgr.GetSpellRank(spellId_1)<sSpellMgr.GetSpellRank(spellId_2);
+}
+
+uint32 CalculatePowerCost(SpellEntry const * spellInfo, Unit const * caster, SpellSchoolMask schoolMask)
+{
+    // Spell drain all exist power on cast (Only paladin lay of Hands)
+    if (spellInfo->AttributesEx & SPELL_ATTR_EX_DRAIN_ALL_POWER)
+    {
+        // If power type - health drain all
+        if (spellInfo->powerType == POWER_HEALTH)
+            return caster->GetHealth();
+        // Else drain all power
+        if (spellInfo->powerType < MAX_POWERS)
+            return caster->GetPower(Powers(spellInfo->powerType));
+        sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
+        return 0;
+    }
+
+    // Base powerCost
+    int32 powerCost = spellInfo->manaCost;
+    // PCT cost from total amount
+    if (spellInfo->ManaCostPercentage)
+    {
+        switch (spellInfo->powerType)
+        {
+            // health as power used
+            case POWER_HEALTH:
+                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateHealth() / 100;
+                break;
+            case POWER_MANA:
+                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateMana() / 100;
+                break;
+            case POWER_RAGE:
+            case POWER_FOCUS:
+            case POWER_ENERGY:
+            case POWER_HAPPINESS:
+                powerCost += spellInfo->ManaCostPercentage * caster->GetMaxPower(Powers(spellInfo->powerType)) / 100;
+                break;
+            case POWER_RUNE:
+            case POWER_RUNIC_POWER:
+                sLog.outDebug("CalculateManaCost: Not implemented yet!");
+                break;
+            default:
+                sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
+                return 0;
+        }
+    }
+    SpellSchools school = GetFirstSchoolInMask(schoolMask);
+    // Flat mod from caster auras by spell school
+    powerCost += caster->GetInt32Value(UNIT_FIELD_POWER_COST_MODIFIER + school);
+    // Shiv - costs 20 + weaponSpeed*10 energy (apply only to non-triggered spell with energy cost)
+    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_SPELL_VS_EXTEND_COST)
+        powerCost += caster->GetAttackTime(OFF_ATTACK)/100;
+    // Apply cost mod by spell
+    if (Player* modOwner = caster->GetSpellModOwner())
+        modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_COST, powerCost);
+
+    if (spellInfo->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION)
+        powerCost = int32(powerCost/ (1.117f* spellInfo->spellLevel / caster->getLevel() -0.1327f));
+
+    // PCT mod from user auras by school
+    powerCost = int32(powerCost * (1.0f+caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+school)));
+    if (powerCost < 0)
+        powerCost = 0;
+    return powerCost;
+}
+
+Unit* GetTriggeredSpellCaster(SpellEntry const * spellInfo, Unit * caster, Unit * target)
+{
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET
+            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_UNIT_TARGET
+            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_CHANNEL
+            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_CHANNEL
+            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_DEST_TARGET
+            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_DEST_TARGET)
+            return caster;
+    }
+    return target;
+}
+
+AuraState GetSpellAuraState(SpellEntry const * spellInfo)
+{
+    // Seals
+    if (IsSealSpell(spellInfo))
+        return AURA_STATE_JUDGEMENT;
+
+    // Conflagrate aura state on Immolate and Shadowflame
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+        // Immolate
+        ((spellInfo->SpellFamilyFlags[0] & 4) ||
+        // Shadowflame
+        (spellInfo->SpellFamilyFlags[2] & 2)))
+        return AURA_STATE_CONFLAGRATE;
+
+    // Faerie Fire (druid versions)
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x400)
+        return AURA_STATE_FAERIE_FIRE;
+
+    // Sting (hunter's pet ability)
+    if (spellInfo->Category == 1133)
+        return AURA_STATE_FAERIE_FIRE;
+
+    // Victorious
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARRIOR &&  spellInfo->SpellFamilyFlags[1] & 0x00040000)
+        return AURA_STATE_WARRIOR_VICTORY_RUSH;
+
+    // Swiftmend state on Regrowth & Rejuvenation
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x50)
+        return AURA_STATE_SWIFTMEND;
+
+    // Deadly poison aura state
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] & 0x10000)
+        return AURA_STATE_DEADLY_POISON;
+
+    // Enrage aura state
+    if (spellInfo->Dispel == DISPEL_ENRAGE)
+        return AURA_STATE_ENRAGE;
+
+    // Bleeding aura state
+    if (GetAllSpellMechanicMask(spellInfo) & 1<<MECHANIC_BLEED)
+        return AURA_STATE_BLEEDING;
+
+    if (GetSpellSchoolMask(spellInfo) & SPELL_SCHOOL_MASK_FROST)
+    {
+        for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_STUN
+                || spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT)
+                return AURA_STATE_FROZEN;
+        }
+    }
+    return AURA_STATE_NONE;
+}
+
+SpellSpecific GetSpellSpecific(SpellEntry const * spellInfo)
+{
+    switch(spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            // Food / Drinks (mostly)
+            if (spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
+            {
+                bool food = false;
+                bool drink = false;
+                for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch(spellInfo->EffectApplyAuraName[i])
+                    {
+                        // Food
+                        case SPELL_AURA_MOD_REGEN:
+                        case SPELL_AURA_OBS_MOD_HEALTH:
+                            food = true;
+                            break;
+                        // Drink
+                        case SPELL_AURA_MOD_POWER_REGEN:
+                        case SPELL_AURA_OBS_MOD_POWER:
+                            drink = true;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                if (food && drink)
+                    return SPELL_SPECIFIC_FOOD_AND_DRINK;
+                else if (food)
+                    return SPELL_SPECIFIC_FOOD;
+                else if (drink)
+                    return SPELL_SPECIFIC_DRINK;
+            }
+            // scrolls effects
+            else
+            {
+                uint32 firstSpell = sSpellMgr.GetFirstSpellInChain(spellInfo->Id);
+                switch (firstSpell)
+                {
+                    case 8118: // Strength
+                    case 8099: // Stamina
+                    case 8112: // Spirit
+                    case 8096: // Intellect
+                    case 8115: // Agility
+                    case 8091: // Armor
+                        return SPELL_SPECIFIC_SCROLL;
+                    case 12880: // Enrage (Enrage)
+                    case 57518: // Enrage (Wrecking Crew)
+                        return SPELL_SPECIFIC_WARRIOR_ENRAGE;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_MAGE:
+        {
+            // family flags 18(Molten), 25(Frost/Ice), 28(Mage)
+            if (spellInfo->SpellFamilyFlags[0] & 0x12040000)
+                return SPELL_SPECIFIC_MAGE_ARMOR;
+
+            // Arcane brillance and Arcane intelect (normal check fails because of flags difference)
+            if (spellInfo->SpellFamilyFlags[0] & 0x400)
+                return SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE;
+
+            if ((spellInfo->SpellFamilyFlags[0] & 0x1000000) && spellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOD_CONFUSE)
+                return SPELL_SPECIFIC_MAGE_POLYMORPH;
+
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            if (spellInfo->Id == 12292) // Death Wish
+                return SPELL_SPECIFIC_WARRIOR_ENRAGE;
+
+            break;
+        }
+        case SPELLFAMILY_WARLOCK:
+        {
+            // only warlock curses have this
+            if (spellInfo->Dispel == DISPEL_CURSE)
+                return SPELL_SPECIFIC_CURSE;
+
+            // Warlock (Demon Armor | Demon Skin | Fel Armor)
+            if (spellInfo->SpellFamilyFlags[1] & 0x20000020 || spellInfo->SpellFamilyFlags[2] & 0x00000010)
+                return SPELL_SPECIFIC_WARLOCK_ARMOR;
+
+            //seed of corruption and corruption
+            if (spellInfo->SpellFamilyFlags[1] & 0x10 || spellInfo->SpellFamilyFlags[0] & 0x2)
+                return SPELL_SPECIFIC_WARLOCK_CORRUPTION;
+            break;
+        }
+        case SPELLFAMILY_PRIEST:
+        {
+            // Divine Spirit and Prayer of Spirit
+            if (spellInfo->SpellFamilyFlags[0] & 0x20)
+                return SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT;
+
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // only hunter stings have this
+            if (spellInfo->Dispel == DISPEL_POISON)
+                return SPELL_SPECIFIC_STING;
+
+            // only hunter aspects have this (but not all aspects in hunter family)
+            if (spellInfo->SpellFamilyFlags.HasFlag(0x00380000, 0x00440000, 0x00001010))
+                return SPELL_SPECIFIC_ASPECT;
+
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            if (IsSealSpell(spellInfo))
+                return SPELL_SPECIFIC_SEAL;
+
+            if (spellInfo->SpellFamilyFlags[0] & 0x00002190)
+                return SPELL_SPECIFIC_HAND;
+
+            // Judgement of Wisdom, Judgement of Light, Judgement of Justice
+            if (spellInfo->Id == 20184 || spellInfo->Id == 20185 || spellInfo->Id == 20186)
+                return SPELL_SPECIFIC_JUDGEMENT;
+
+            // only paladin auras have this (for palaldin class family)
+            if (spellInfo->SpellFamilyFlags[2] & 0x00000020)
+                return SPELL_SPECIFIC_AURA;
+
+            break;
+        }
+        case SPELLFAMILY_SHAMAN:
+        {
+            if (IsElementalShield(spellInfo))
+                return SPELL_SPECIFIC_ELEMENTAL_SHIELD;
+
+            break;
+        }
+
+        case SPELLFAMILY_DEATHKNIGHT:
+            if (spellInfo->Id == 48266 || spellInfo->Id == 48263 || spellInfo->Id == 48265)
+            //if (spellInfo->Category == 47)
+                return SPELL_SPECIFIC_PRESENCE;
+            break;
+    }
+
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
+        {
+            switch(spellInfo->EffectApplyAuraName[i])
+            {
+                case SPELL_AURA_MOD_CHARM:
+                case SPELL_AURA_MOD_POSSESS_PET:
+                case SPELL_AURA_MOD_POSSESS:
+                case SPELL_AURA_AOE_CHARM:
+                    return SPELL_SPECIFIC_CHARM;
+                case SPELL_AURA_TRACK_CREATURES:
+                case SPELL_AURA_TRACK_RESOURCES:
+                case SPELL_AURA_TRACK_STEALTHED:
+                    return SPELL_SPECIFIC_TRACKER;
+                case SPELL_AURA_PHASE:
+                    return SPELL_SPECIFIC_PHASE;
+            }
+        }
+    }
+
+    return SPELL_SPECIFIC_NORMAL;
+}
+
+// target not allow have more one spell specific from same caster
+bool IsSingleFromSpellSpecificPerCaster(SpellSpecific spellSpec1,SpellSpecific spellSpec2)
+{
+    switch(spellSpec1)
+    {
+        case SPELL_SPECIFIC_SEAL:
+        case SPELL_SPECIFIC_HAND:
+        case SPELL_SPECIFIC_AURA:
+        case SPELL_SPECIFIC_STING:
+        case SPELL_SPECIFIC_CURSE:
+        case SPELL_SPECIFIC_ASPECT:
+        case SPELL_SPECIFIC_JUDGEMENT:
+        case SPELL_SPECIFIC_WARLOCK_CORRUPTION:
+            return spellSpec1 == spellSpec2;
+        default:
+            return false;
+    }
+}
+
+bool IsSingleFromSpellSpecificPerTarget(SpellSpecific spellSpec1, SpellSpecific spellSpec2)
+{
+    switch(spellSpec1)
+    {
+        case SPELL_SPECIFIC_PHASE:
+        case SPELL_SPECIFIC_TRACKER:
+        case SPELL_SPECIFIC_WARLOCK_ARMOR:
+        case SPELL_SPECIFIC_MAGE_ARMOR:
+        case SPELL_SPECIFIC_ELEMENTAL_SHIELD:
+        case SPELL_SPECIFIC_MAGE_POLYMORPH:
+        case SPELL_SPECIFIC_PRESENCE:
+        case SPELL_SPECIFIC_CHARM:
+        case SPELL_SPECIFIC_SCROLL:
+        case SPELL_SPECIFIC_WARRIOR_ENRAGE:
+        case SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE:
+        case SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT:
+            return spellSpec1 == spellSpec2;
+        case SPELL_SPECIFIC_FOOD:
+            return spellSpec2 == SPELL_SPECIFIC_FOOD
+                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
+        case SPELL_SPECIFIC_DRINK:
+            return spellSpec2 == SPELL_SPECIFIC_DRINK
+                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
+        case SPELL_SPECIFIC_FOOD_AND_DRINK:
+            return spellSpec2 == SPELL_SPECIFIC_FOOD
+                || spellSpec2 == SPELL_SPECIFIC_DRINK
+                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
+        default:
+            return false;
+    }
+}
+
+bool IsPositiveTarget(uint32 targetA, uint32 targetB)
+{
+    // non-positive targets
+    switch(targetA)
+    {
+        case TARGET_UNIT_NEARBY_ENEMY:
+        case TARGET_UNIT_TARGET_ENEMY:
+        case TARGET_UNIT_AREA_ENEMY_SRC:
+        case TARGET_UNIT_AREA_ENEMY_DST:
+        case TARGET_UNIT_CONE_ENEMY:
+        case TARGET_DEST_DYNOBJ_ENEMY:
+        case TARGET_DST_TARGET_ENEMY:
+            return false;
+        default:
+            break;
+    }
+    if (targetB)
+        return IsPositiveTarget(targetB, 0);
+    return true;
+}
+
+bool SpellMgr::_isPositiveEffect(uint32 spellId, uint32 effIndex, bool deep) const
+{
+    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
+    if (!spellproto) return false;
+
+    // not found a single positive spell with this attribute
+    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1)
+        return false;
+
+    switch (spellproto->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+            switch (spellId)
+            {
+                case 34700: // Allergic Reaction
+                case 61987: // Avenging Wrath Marker
+                case 61988: // Divine Shield exclude aura
+                    return false;
+                case 30877: // Tag Murloc
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case SPELLFAMILY_MAGE:
+            // Amplify Magic, Dampen Magic
+            if (spellproto->SpellFamilyFlags[0] == 0x00002000)
+                return true;
+            break;
+        case SPELLFAMILY_PRIEST:
+            switch (spellId)
+            {
+                case 64844: // Divine Hymn
+                case 64904: // Hymn of Hope
+                case 47585: // Dispersion
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case SPELLFAMILY_HUNTER:
+            // Aspect of the Viper
+            if (spellId == 34074)
+                return true;
+            break;
+        case SPELLFAMILY_SHAMAN:
+            if (spellId == 30708)
+                return false;
+            break;
+        default:
+            break;
+    }
+
+    switch (spellproto->Mechanic)
+    {
+        case MECHANIC_IMMUNE_SHIELD:
+            return true;
+        default:
+            break;
+    }
+
+    // Special case: effects which determine positivity of whole spell
+    for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_STEALTH)
+            return true;
+    }
+
+    switch(spellproto->Effect[effIndex])
+    {
+        case SPELL_EFFECT_DUMMY:
+            // some explicitly required dummy effect sets
+            switch(spellId)
+            {
+                case 28441: return false;                   // AB Effect 000
+                default:
+                    break;
+            }
+            break;
+        // always positive effects (check before target checks that provided non-positive result in some case for positive effects)
+        case SPELL_EFFECT_HEAL:
+        case SPELL_EFFECT_LEARN_SPELL:
+        case SPELL_EFFECT_SKILL_STEP:
+        case SPELL_EFFECT_HEAL_PCT:
+        case SPELL_EFFECT_ENERGIZE_PCT:
+            return true;
+
+            // non-positive aura use
+        case SPELL_EFFECT_APPLY_AURA:
+        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
+        {
+            switch(spellproto->EffectApplyAuraName[effIndex])
+            {
+                case SPELL_AURA_MOD_DAMAGE_DONE:            // dependent from bas point sign (negative -> negative)
+                case SPELL_AURA_MOD_STAT:
+                case SPELL_AURA_MOD_SKILL:
+                case SPELL_AURA_MOD_HEALING_PCT:
+                case SPELL_AURA_MOD_HEALING_DONE:
+                case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE:
+                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) < 0)
+                        return false;
+                    break;
+                case SPELL_AURA_MOD_DAMAGE_TAKEN:           // dependent from bas point sign (positive -> negative)
+                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
+                        return false;
+                    break;
+                case SPELL_AURA_MOD_CRIT_PCT:
+                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
+                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
+                        return true;                        // some expected positive spells have SPELL_ATTR_EX_NEGATIVE
+                    break;
+                case SPELL_AURA_ADD_TARGET_TRIGGER:
+                    return true;
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
+                    if (!deep)
+                    {
+                        uint32 spellTriggeredId = spellproto->EffectTriggerSpell[effIndex];
+                        SpellEntry const *spellTriggeredProto = sSpellStore.LookupEntry(spellTriggeredId);
+
+                        if (spellTriggeredProto)
+                        {
+                            // non-positive targets of main spell return early
+                            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                            {
+                                if (!spellTriggeredProto->Effect[i])
+                                    continue;
+                                // if non-positive trigger cast targeted to positive target this main cast is non-positive
+                                // this will place this spell auras as debuffs
+                                if (IsPositiveTarget(spellTriggeredProto->EffectImplicitTargetA[effIndex],spellTriggeredProto->EffectImplicitTargetB[effIndex]) && !_isPositiveEffect(spellTriggeredId,i, true))
+                                    return false;
+                            }
+                        }
+                    }
+                case SPELL_AURA_PROC_TRIGGER_SPELL:
+                    // many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
+                    break;
+                case SPELL_AURA_MOD_STUN:                   //have positive and negative spells, we can't sort its correctly at this moment.
+                    if (effIndex == 0 && spellproto->Effect[1] == 0 && spellproto->Effect[2] == 0)
+                        return false;                       // but all single stun aura spells is negative
+                    break;
+                case SPELL_AURA_MOD_PACIFY_SILENCE:
+                    if (spellproto->Id == 24740)             // Wisp Costume
+                        return true;
+                    return false;
+                case SPELL_AURA_MOD_ROOT:
+                case SPELL_AURA_MOD_SILENCE:
+                case SPELL_AURA_GHOST:
+                case SPELL_AURA_PERIODIC_LEECH:
+                case SPELL_AURA_MOD_STALKED:
+                case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
+                case SPELL_AURA_PREVENT_RESSURECTION:
+                    return false;
+                case SPELL_AURA_PERIODIC_DAMAGE:            // used in positive spells also.
+                    // part of negative spell if casted at self (prevent cancel)
+                    if (spellproto->EffectImplicitTargetA[effIndex] == TARGET_UNIT_CASTER)
+                        return false;
+                    break;
+                case SPELL_AURA_MOD_DECREASE_SPEED:         // used in positive spells also
+                    // part of positive spell if casted at self
+                    if (spellproto->EffectImplicitTargetA[effIndex] != TARGET_UNIT_CASTER)
+                        return false;
+                    // but not this if this first effect (didn't find better check)
+                    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1 && effIndex == 0)
+                        return false;
+                    break;
+                case SPELL_AURA_MECHANIC_IMMUNITY:
+                {
+                    // non-positive immunities
+                    switch(spellproto->EffectMiscValue[effIndex])
+                    {
+                        case MECHANIC_BANDAGE:
+                        case MECHANIC_SHIELD:
+                        case MECHANIC_MOUNT:
+                        case MECHANIC_INVULNERABILITY:
+                            return false;
+                        default:
+                            break;
+                    }
+                }   break;
+                case SPELL_AURA_ADD_FLAT_MODIFIER:          // mods
+                case SPELL_AURA_ADD_PCT_MODIFIER:
+                {
+                    // non-positive mods
+                    switch(spellproto->EffectMiscValue[effIndex])
+                    {
+                        case SPELLMOD_COST:                 // dependent from bas point sign (negative -> positive)
+                            if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
+                            {
+                                if (!deep)
+                                {
+                                    bool negative = true;
+                                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (i != effIndex)
+                                            if (_isPositiveEffect(spellId, i, true))
+                                            {
+                                                negative = false;
+                                                break;
+                                            }
+                                    }
+                                    if (negative)
+                                        return false;
+                                }
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                }   break;
+                default:
+                    break;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    // non-positive targets
+    if (!IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex]))
+        return false;
+
+    // AttributesEx check
+    if (spellproto->AttributesEx & SPELL_ATTR_EX_NEGATIVE)
+        return false;
+
+    if (!deep && spellproto->EffectTriggerSpell[effIndex]
+        && !spellproto->EffectApplyAuraName[effIndex]
+        && IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex])
+        && !_isPositiveSpell(spellproto->EffectTriggerSpell[effIndex], true))
+        return false;
+
+    // ok, positive
+    return true;
+}
+
+bool IsPositiveSpell(uint32 spellId)
+{
+    if (!sSpellStore.LookupEntry(spellId)) // non-existing spells
+        return false;
+    return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE);
+}
+
+bool IsPositiveEffect(uint32 spellId, uint32 effIndex)
+{
+    if (!sSpellStore.LookupEntry(spellId))
+        return false;
+    switch(effIndex)
+    {
+        default:
+        case 0: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF0);
+        case 1: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF1);
+        case 2: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF2);
+    }
+}
+
+bool SpellMgr::_isPositiveSpell(uint32 spellId, bool deep) const
+{
+    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
+    if (!spellproto) return false;
+
+    // spells with at least one negative effect are considered negative
+    // some self-applied spells have negative effects but in self casting case negative check ignored.
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        if (!_isPositiveEffect(spellId, i, deep))
+            return false;
+    return true;
+}
+
+bool IsSingleTargetSpell(SpellEntry const *spellInfo)
+{
+    // all other single target spells have if it has AttributesEx5
+    if (spellInfo->AttributesEx5 & SPELL_ATTR_EX5_SINGLE_TARGET_SPELL)
+        return true;
+
+    switch(GetSpellSpecific(spellInfo))
+    {
+        case SPELL_SPECIFIC_JUDGEMENT:
+            return true;
+        default:
+            break;
+    }
+
+    return false;
+}
+
+bool IsSingleTargetSpells(SpellEntry const *spellInfo1, SpellEntry const *spellInfo2)
+{
+    // TODO - need better check
+    // Equal icon and spellfamily
+    if (spellInfo1->SpellFamilyName == spellInfo2->SpellFamilyName &&
+        spellInfo1->SpellIconID == spellInfo2->SpellIconID)
+        return true;
+
+    // TODO - need found Judgements rule
+    SpellSpecific spec1 = GetSpellSpecific(spellInfo1);
+    // spell with single target specific types
+    switch(spec1)
+    {
+        case SPELL_SPECIFIC_JUDGEMENT:
+        case SPELL_SPECIFIC_MAGE_POLYMORPH:
+            if (GetSpellSpecific(spellInfo2) == spec1)
+                return true;
+            break;
+        default:
+            break;
+    }
+
+    return false;
+}
+
+SpellCastResult GetErrorAtShapeshiftedCast (SpellEntry const *spellInfo, uint32 form)
+{
+    // talents that learn spells can have stance requirements that need ignore
+    // (this requirement only for client-side stance show in talent description)
+    if (GetTalentSpellCost(spellInfo->Id) > 0 &&
+        (spellInfo->Effect[0] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[1] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[2] == SPELL_EFFECT_LEARN_SPELL))
+        return SPELL_CAST_OK;
+
+    uint32 stanceMask = (form ? 1 << (form - 1) : 0);
+
+    if (stanceMask & spellInfo->StancesNot)                 // can explicitly not be casted in this stance
+        return SPELL_FAILED_NOT_SHAPESHIFT;
+
+    if (stanceMask & spellInfo->Stances)                    // can explicitly be casted in this stance
+        return SPELL_CAST_OK;
+
+    bool actAsShifted = false;
+    SpellShapeshiftEntry const *shapeInfo = NULL;
+    if (form > 0)
+    {
+        shapeInfo = sSpellShapeshiftStore.LookupEntry(form);
+        if (!shapeInfo)
+        {
+            sLog.outError("GetErrorAtShapeshiftedCast: unknown shapeshift %u", form);
+            return SPELL_CAST_OK;
+        }
+        actAsShifted = !(shapeInfo->flags1 & 1);            // shapeshift acts as normal form for spells
+    }
+
+    if (actAsShifted)
+    {
+        if (spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT) // not while shapeshifted
+            return SPELL_FAILED_NOT_SHAPESHIFT;
+        else if (spellInfo->Stances != 0)                   // needs other shapeshift
+            return SPELL_FAILED_ONLY_SHAPESHIFT;
+    }
+    else
+    {
+        // needs shapeshift
+        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_NEED_SHAPESHIFT) && spellInfo->Stances != 0)
+            return SPELL_FAILED_ONLY_SHAPESHIFT;
+    }
+
+    // Check if stance disables cast of not-stance spells
+    // Example: cannot cast any other spells in zombie or ghoul form
+    // TODO: Find a way to disable use of these spells clientside
+    if (shapeInfo && shapeInfo->flags1 & 0x400)
+    {
+        if (!(stanceMask & spellInfo->Stances))
+            return SPELL_FAILED_ONLY_SHAPESHIFT;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+void SpellMgr::LoadSpellTargetPositions()
+{
+    mSpellTargetPositions.clear();                                // need for reload case
+
+    uint32 count = 0;
+
+    //                                                0   1           2                  3                  4                  5
+    QueryResult result = WorldDatabase.Query("SELECT id, target_map, target_position_x, target_position_y, target_position_z, target_orientation FROM spell_target_position");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell target coordinates", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 Spell_ID = fields[0].GetUInt32();
+
+        SpellTargetPosition st;
+
+        st.target_mapId       = fields[1].GetUInt32();
+        st.target_X           = fields[2].GetFloat();
+        st.target_Y           = fields[3].GetFloat();
+        st.target_Z           = fields[4].GetFloat();
+        st.target_Orientation = fields[5].GetFloat();
+
+        MapEntry const* mapEntry = sMapStore.LookupEntry(st.target_mapId);
+        if (!mapEntry)
+        {
+            sLog.outErrorDb("Spell (ID:%u) target map (ID: %u) does not exist in `Map.dbc`.",Spell_ID,st.target_mapId);
+            continue;
+        }
+
+        if (st.target_X==0 && st.target_Y==0 && st.target_Z==0)
+        {
+            sLog.outErrorDb("Spell (ID:%u) target coordinates not provided.",Spell_ID);
+            continue;
+        }
+
+        SpellEntry const* spellInfo = sSpellStore.LookupEntry(Spell_ID);
+        if (!spellInfo)
+        {
+            sLog.outErrorDb("Spell (ID:%u) listed in `spell_target_position` does not exist.",Spell_ID);
+            continue;
+        }
+
+        bool found = false;
+        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->EffectImplicitTargetA[i] == TARGET_DST_DB || spellInfo->EffectImplicitTargetB[i] == TARGET_DST_DB)
+            {
+                // additional requirements
+                if (spellInfo->Effect[i]==SPELL_EFFECT_BIND && spellInfo->EffectMiscValue[i])
+                {
+                    uint32 area_id = sMapMgr.GetAreaId(st.target_mapId, st.target_X, st.target_Y, st.target_Z);
+                    if (area_id != uint32(spellInfo->EffectMiscValue[i]))
+                    {
+                        sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` expected point to zone %u bit point to zone %u.",Spell_ID, spellInfo->EffectMiscValue[i], area_id);
+                        break;
+                    }
+                }
+
+                found = true;
+                break;
+            }
+        }
+        if (!found)
+        {
+            sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` does not have target TARGET_DST_DB (17).",Spell_ID);
+            continue;
+        }
+
+        mSpellTargetPositions[Spell_ID] = st;
+        ++count;
+
+    } while (result->NextRow());
+
+    // Check all spells
+    for (uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
+    {
+        SpellEntry const * spellInfo = sSpellStore.LookupEntry(i);
+        if (!spellInfo)
+            continue;
+
+        bool found = false;
+        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            switch(spellInfo->EffectImplicitTargetA[j])
+            {
+                case TARGET_DST_DB:
+                    found = true;
+                    break;
+            }
+            if (found)
+                break;
+            switch(spellInfo->EffectImplicitTargetB[j])
+            {
+                case TARGET_DST_DB:
+                    found = true;
+                    break;
+            }
+            if (found)
+                break;
+        }
+        if (found)
+        {
+//            if (!sSpellMgr.GetSpellTargetPosition(i))
+//                sLog.outDebug("Spell (ID: %u) does not have record in `spell_target_position`", i);
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell teleport coordinates", count);
+}
+
+bool SpellMgr::IsAffectedByMod(SpellEntry const *spellInfo, SpellModifier *mod) const
+{
+    // false for spellInfo == NULL
+    if (!spellInfo || !mod)
+        return false;
+
+    SpellEntry const *affect_spell = sSpellStore.LookupEntry(mod->spellId);
+    // False if affect_spell == NULL or spellFamily not equal
+    if (!affect_spell || affect_spell->SpellFamilyName != spellInfo->SpellFamilyName)
+        return false;
+
+    // true
+    if (mod->mask  & spellInfo->SpellFamilyFlags)
+        return true;
+
+    return false;
+}
+
+void SpellMgr::LoadSpellProcEvents()
+{
+    mSpellProcEventMap.clear();                             // need for reload case
+
+    uint32 count = 0;
+
+    //                                                0      1           2                3                 4                 5                 6          7       8        9             10
+    QueryResult result = WorldDatabase.Query("SELECT entry, SchoolMask, SpellFamilyName, SpellFamilyMask0, SpellFamilyMask1, SpellFamilyMask2, procFlags, procEx, ppmRate, CustomChance, Cooldown FROM spell_proc_event");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell proc event conditions", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+    uint32 customProc = 0;
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 entry = fields[0].GetUInt32();
+
+        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
+        if (!spell)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_proc_event` does not exist", entry);
+            continue;
+        }
+
+        SpellProcEventEntry spe;
+
+        spe.schoolMask      = fields[1].GetUInt32();
+        spe.spellFamilyName = fields[2].GetUInt32();
+        spe.spellFamilyMask[0] = fields[3].GetUInt32();
+        spe.spellFamilyMask[1] = fields[4].GetUInt32();
+        spe.spellFamilyMask[2] = fields[5].GetUInt32();
+        spe.procFlags       = fields[6].GetUInt32();
+        spe.procEx          = fields[7].GetUInt32();
+        spe.ppmRate         = fields[8].GetFloat();
+        spe.customChance    = fields[9].GetFloat();
+        spe.cooldown        = fields[10].GetUInt32();
+
+        mSpellProcEventMap[entry] = spe;
+
+        if (spell->procFlags == 0)
+        {
+            if (spe.procFlags == 0)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_proc_event` probally not triggered spell", entry);
+                continue;
+            }
+            customProc++;
+        }
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    if (customProc)
+        sLog.outString(">> Loaded %u extra spell proc event conditions + %u custom",  count, customProc);
+    else
+        sLog.outString(">> Loaded %u extra spell proc event conditions", count);
+}
+
+void SpellMgr::LoadSpellBonusess()
+{
+    mSpellBonusMap.clear();                             // need for reload case
+    uint32 count = 0;
+    //                                                0      1             2          3         4
+    QueryResult result = WorldDatabase.Query("SELECT entry, direct_bonus, dot_bonus, ap_bonus, ap_dot_bonus FROM spell_bonus_data");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell bonus data", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        Field *fields = result->Fetch();
+        bar.step();
+        uint32 entry = fields[0].GetUInt32();
+
+        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
+        if (!spell)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_bonus_data` does not exist", entry);
+            continue;
+        }
+
+        SpellBonusEntry sbe;
+
+        sbe.direct_damage = fields[1].GetFloat();
+        sbe.dot_damage    = fields[2].GetFloat();
+        sbe.ap_bonus      = fields[3].GetFloat();
+        sbe.ap_dot_bonus   = fields[4].GetFloat();
+
+        mSpellBonusMap[entry] = sbe;
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u extra spell bonus data",  count);
+}
+
+bool SpellMgr::IsSpellProcEventCanTriggeredBy(SpellProcEventEntry const* spellProcEvent, uint32 EventProcFlag, SpellEntry const * procSpell, uint32 procFlags, uint32 procExtra, bool active)
+{
+    // No extra req need
+    uint32 procEvent_procEx = PROC_EX_NONE;
+
+    // check prockFlags for condition
+    if ((procFlags & EventProcFlag) == 0)
+        return false;
+
+    bool hasFamilyMask = false;
+
+    /* Check Periodic Auras
+
+    *Dots can trigger if spell has no PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
+        nor PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
+
+    *Only Hots can trigger if spell has PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
+
+    *Only dots can trigger if spell has both positivity flags or PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
+
+    *Aura has to have PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL or spellfamily specified to trigger from Hot
+
+    */
+
+    if (procFlags & PROC_FLAG_DONE_PERIODIC)
+    {
+        if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG)
+        {
+            if (!(procExtra & PROC_EX_INTERNAL_DOT))
+                return false;
+        }
+        else if (procExtra & PROC_EX_INTERNAL_HOT)
+            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
+        else if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS)
+            return false;
+    }
+
+    if (procFlags & PROC_FLAG_TAKEN_PERIODIC)
+    {
+        if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)
+        {
+            if (!(procExtra & PROC_EX_INTERNAL_DOT))
+                return false;
+        }
+        else if (procExtra & PROC_EX_INTERNAL_HOT)
+            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
+        else if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_POS)
+            return false;
+    }
+    // Trap casts are active by default
+    if (procFlags & PROC_FLAG_DONE_TRAP_ACTIVATION)
+        active = true;
+
+    // Always trigger for this
+    if (procFlags & (PROC_FLAG_KILLED | PROC_FLAG_KILL | PROC_FLAG_DEATH))
+        return true;
+
+    if (spellProcEvent)     // Exist event data
+    {
+        // Store extra req
+        procEvent_procEx = spellProcEvent->procEx;
+
+        // For melee triggers
+        if (procSpell == NULL)
+        {
+            // Check (if set) for school (melee attack have Normal school)
+            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
+                return false;
+        }
+        else // For spells need check school/spell family/family mask
+        {
+            // Check (if set) for school
+            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & procSpell->SchoolMask) == 0)
+                return false;
+
+            // Check (if set) for spellFamilyName
+            if (spellProcEvent->spellFamilyName && (spellProcEvent->spellFamilyName != procSpell->SpellFamilyName))
+                return false;
+
+            // spellFamilyName is Ok need check for spellFamilyMask if present
+            if (spellProcEvent->spellFamilyMask)
+            {
+                if ((spellProcEvent->spellFamilyMask & procSpell->SpellFamilyFlags) == 0)
+                    return false;
+                hasFamilyMask = true;
+                // Some spells are not considered as active even with have spellfamilyflags
+                if (!(procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL))
+                    active = true;
+            }
+        }
+    }
+
+    if (procExtra & (PROC_EX_INTERNAL_REQ_FAMILY))
+    {
+        if (!hasFamilyMask)
+            return false;
+    }
+
+    // Check for extra req (if none) and hit/crit
+    if (procEvent_procEx == PROC_EX_NONE)
+    {
+        // No extra req, so can trigger only for hit/crit - spell has to be active
+        if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && active)
+            return true;
+    }
+    else // Passive spells hits here only if resist/reflect/immune/evade
+    {
+        if (procExtra & AURA_SPELL_PROC_EX_MASK)
+        {
+            // if spell marked as procing only from not active spells
+            if (active && procEvent_procEx & PROC_EX_NOT_ACTIVE_SPELL)
+                return false;
+            // if spell marked as procing only from active spells
+            if (!active && procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL)
+                return false;
+            // Exist req for PROC_EX_EX_TRIGGER_ALWAYS
+            if (procEvent_procEx & PROC_EX_EX_TRIGGER_ALWAYS)
+                return true;
+            // PROC_EX_NOT_ACTIVE_SPELL and PROC_EX_ONLY_ACTIVE_SPELL flags handle: if passed checks before
+            if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && ((procEvent_procEx & (AURA_SPELL_PROC_EX_MASK)) == 0))
+                return true;
+        }
+        // Check Extra Requirement like (hit/crit/miss/resist/parry/dodge/block/immune/reflect/absorb and other)
+        if (procEvent_procEx & procExtra)
+            return true;
+    }
+    return false;
+}
+
+void SpellMgr::LoadSpellGroups()
+{
+    mSpellSpellGroup.clear();                                  // need for reload case
+    mSpellGroupSpell.clear();
+
+    uint32 count = 0;
+
+    //                                                       0   1
+    QueryResult result = WorldDatabase.Query("SELECT id, spell_id FROM spell_group");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell group definitions", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    std::set<uint32> groups;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 group_id = fields[0].GetUInt32();
+        if (group_id <= SPELL_GROUP_DB_RANGE_MIN && group_id >= SPELL_GROUP_CORE_RANGE_MAX)
+        {
+            sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` is in core range, but is not defined in core!", group_id);
+            continue;
+        }
+        int32 spell_id = fields[1].GetInt32();
+
+        groups.insert(std::set<uint32>::value_type(group_id));
+        mSpellGroupSpell.insert(SpellGroupSpellMap::value_type((SpellGroup)group_id, spell_id));
+
+    } while (result->NextRow());
+
+    for (SpellGroupSpellMap::iterator itr = mSpellGroupSpell.begin(); itr!= mSpellGroupSpell.end() ;)
+    {
+        if (itr->second < 0)
+        {
+            if (groups.find(abs(itr->second)) == groups.end())
+            {
+                sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` does not exist", abs(itr->second));
+                mSpellGroupSpell.erase(itr++);
+            }
+            else
+                ++itr;
+        }
+        else
+        {
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(itr->second);
+
+            if (!spellInfo)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_group` does not exist", itr->second);
+                mSpellGroupSpell.erase(itr++);
+            }
+            else if (GetSpellRank(itr->second) > 1)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_group` is not first rank of spell", itr->second);
+                mSpellGroupSpell.erase(itr++);
+            }
+            else
+                ++itr;
+        }
+    }
+
+    for (std::set<uint32>::iterator groupItr = groups.begin() ; groupItr != groups.end() ; ++groupItr)
+    {
+        std::set<uint32> spells;
+        GetSetOfSpellsInSpellGroup(SpellGroup(*groupItr), spells);
+
+        for (std::set<uint32>::iterator spellItr = spells.begin() ; spellItr != spells.end() ; ++spellItr)
+        {
+            ++count;
+            mSpellSpellGroup.insert(SpellSpellGroupMap::value_type(*spellItr, SpellGroup(*groupItr)));
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell group definitions", count);
+}
+
+void SpellMgr::LoadSpellGroupStackRules()
+{
+    mSpellGroupStack.clear();                                  // need for reload case
+
+    uint32 count = 0;
+
+    //                                                       0         1
+    QueryResult result = WorldDatabase.Query("SELECT group_id, stack_rule FROM spell_group_stack_rules");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell group stack rules", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 group_id = fields[0].GetUInt32();
+        uint8 stack_rule = fields[1].GetUInt32();
+        if (stack_rule >= SPELL_GROUP_STACK_RULE_MAX)
+        {
+            sLog.outErrorDb("SpellGroupStackRule %u listed in `spell_group_stack_rules` does not exist", stack_rule);
+            continue;
+        }
+
+        SpellGroupSpellMapBounds spellGroup = GetSpellGroupSpellMapBounds((SpellGroup)group_id);
+
+        if (spellGroup.first == spellGroup.second)
+        {
+            sLog.outErrorDb("SpellGroup id %u listed in `spell_group_stack_rules` does not exist", group_id);
+            continue;
+        }
+
+        mSpellGroupStack[(SpellGroup)group_id] = (SpellGroupStackRule)stack_rule;
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell group stack rules", count);
+}
+
+void SpellMgr::LoadSpellThreats()
+{
+    mSpellThreatMap.clear();                                // need for reload case
+
+    uint32 count = 0;
+
+    //                                                0      1
+    QueryResult result = WorldDatabase.Query("SELECT entry, Threat FROM spell_threat");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u aggro generating spells", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 entry = fields[0].GetUInt32();
+        uint16 Threat = fields[1].GetUInt16();
+
+        if (!sSpellStore.LookupEntry(entry))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_threat` does not exist", entry);
+            continue;
+        }
+
+        mSpellThreatMap[entry] = Threat;
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u aggro generating spells", count);
+}
+
+bool SpellMgr::IsRankSpellDueToSpell(SpellEntry const *spellInfo_1,uint32 spellId_2) const
+{
+    SpellEntry const *spellInfo_2 = sSpellStore.LookupEntry(spellId_2);
+    if (!spellInfo_1 || !spellInfo_2) return false;
+    if (spellInfo_1->Id == spellId_2) return false;
+
+    return GetFirstSpellInChain(spellInfo_1->Id) == GetFirstSpellInChain(spellId_2);
+}
+
+bool SpellMgr::canStackSpellRanks(SpellEntry const *spellInfo)
+{
+    if (IsPassiveSpell(spellInfo->Id))                       // ranked passive spell
+        return false;
+    if (spellInfo->powerType != POWER_MANA && spellInfo->powerType != POWER_HEALTH)
+        return false;
+    if (IsProfessionOrRidingSpell(spellInfo->Id))
+        return false;
+
+    if (sSpellMgr.IsSkillBonusSpell(spellInfo->Id))
+        return false;
+
+    // All stance spells. if any better way, change it.
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch(spellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_PALADIN:
+                // Paladin aura Spell
+                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID)
+                    return false;
+                break;
+            case SPELLFAMILY_DRUID:
+                // Druid form Spell
+                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
+                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
+                    return false;
+                break;
+            case SPELLFAMILY_ROGUE:
+                // Rogue Stealth
+                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
+                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
+                    return false;
+        }
+    }
+    return true;
+}
+
+bool SpellMgr::IsProfessionOrRidingSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
+        {
+            uint32 skill = spellInfo->EffectMiscValue[i];
+
+            bool found = IsProfessionOrRidingSkill(skill);
+            if (found)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool SpellMgr::IsProfessionSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
+        {
+            uint32 skill = spellInfo->EffectMiscValue[i];
+
+            bool found = IsProfessionSkill(skill);
+            if (found)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool SpellMgr::IsPrimaryProfessionSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
+        {
+            uint32 skill = spellInfo->EffectMiscValue[i];
+
+            bool found = IsPrimaryProfessionSkill(skill);
+            if (found)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool SpellMgr::IsPrimaryProfessionFirstRankSpell(uint32 spellId) const
+{
+    return IsPrimaryProfessionSpell(spellId) && GetSpellRank(spellId) == 1;
+}
+
+bool SpellMgr::IsSkillBonusSpell(uint32 spellId) const
+{
+    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
+
+    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
+    {
+        SkillLineAbilityEntry const *pAbility = _spell_idx->second;
+        if (!pAbility || pAbility->learnOnGetSkill != ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
+            continue;
+
+        if (pAbility->req_skill_value > 0)
+            return true;
+    }
+
+    return false;
+}
+
+bool SpellMgr::IsSkillTypeSpell(uint32 spellId, SkillType type) const
+{
+    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
+
+    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
+        if (_spell_idx->second->skillId == uint32(type))
+            return true;
+
+    return false;
+}
+
+// basepoints provided here have to be valid basepoints (use SpellMgr::CalculateSpellEffectBaseAmount)
+int32 SpellMgr::CalculateSpellEffectAmount(SpellEntry const * spellEntry, uint8 effIndex, Unit const * caster, int32 const * effBasePoints, Unit const * /*target*/)
+{
+    float basePointsPerLevel = spellEntry->EffectRealPointsPerLevel[effIndex];
+    int32 basePoints = effBasePoints ? *effBasePoints : spellEntry->EffectBasePoints[effIndex];
+    int32 randomPoints = int32(spellEntry->EffectDieSides[effIndex]);
+
+    // base amount modification based on spell lvl vs caster lvl
+    if (caster)
+    {
+        int32 level = int32(caster->getLevel());
+        if (level > int32(spellEntry->maxLevel) && spellEntry->maxLevel > 0)
+            level = int32(spellEntry->maxLevel);
+        else if (level < int32(spellEntry->baseLevel))
+            level = int32(spellEntry->baseLevel);
+        level -= int32(spellEntry->spellLevel);
+        basePoints += int32(level * basePointsPerLevel);
+    }
+
+    // roll in a range <1;EffectDieSides> as of patch 3.3.3
+    switch(randomPoints)
+    {
+        case 0: break;
+        case 1: basePoints += 1; break;                     // range 1..1
+        default:
+            // range can have positive (1..rand) and negative (rand..1) values, so order its for irand
+            int32 randvalue = (randomPoints >= 1)
+                ? irand(1, randomPoints)
+                : irand(randomPoints, 1);
+
+            basePoints += randvalue;
+            break;
+    }
+
+    int32 value = basePoints;
+
+    // random damage
+    if (caster)
+    {
+        // bonus amount from combo points
+        if  (caster->m_movedPlayer)
+            if (uint8 comboPoints = caster->m_movedPlayer->GetComboPoints())
+                if (float comboDamage = spellEntry->EffectPointsPerComboPoint[effIndex])
+                    value += int32(comboDamage * comboPoints);
+
+        value = caster->ApplyEffectModifiers(spellEntry, effIndex, value);
+
+        // amount multiplication based on caster's level
+        if (!basePointsPerLevel && (spellEntry->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION && spellEntry->spellLevel) &&
+                spellEntry->Effect[effIndex] != SPELL_EFFECT_WEAPON_PERCENT_DAMAGE &&
+                spellEntry->Effect[effIndex] != SPELL_EFFECT_KNOCK_BACK &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_ALWAYS &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_NOT_STACK &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_INCREASE_SPEED &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_DECREASE_SPEED)
+                //there are many more: slow speed, -healing pct
+            value = int32(value*0.25f*exp(caster->getLevel()*(70-spellEntry->spellLevel)/1000.0f));
+            //value = int32(value * (int32)getLevel() / (int32)(spellProto->spellLevel ? spellProto->spellLevel : 1));
+    }
+
+    return value;
+}
+
+int32 SpellMgr::CalculateSpellEffectBaseAmount(int32 value, SpellEntry const * spellEntry, uint8 effIndex)
+{
+    if (spellEntry->EffectDieSides[effIndex] == 0)
+        return value;
+    else
+        return value - 1;
+}
+
+float SpellMgr::CalculateSpellEffectValueMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
+{
+    float multiplier = spellEntry->EffectValueMultiplier[effIndex];
+
+    if (caster)
+        if (Player * modOwner = caster->GetSpellModOwner())
+            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_VALUE_MULTIPLIER, multiplier, spell);
+    return multiplier;
+}
+
+float SpellMgr::CalculateSpellEffectDamageMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
+{
+    float multiplier = spellEntry->EffectDamageMultiplier[effIndex];
+
+    if (caster)
+        if (Player * modOwner = caster->GetSpellModOwner())
+            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_DAMAGE_MULTIPLIER, multiplier, spell);
+    return multiplier;
+}
+
+SpellEntry const* SpellMgr::SelectAuraRankForPlayerLevel(SpellEntry const* spellInfo, uint32 playerLevel) const
+{
+    // ignore passive spells
+    if (IsPassiveSpell(spellInfo->Id))
+        return spellInfo;
+
+    bool needRankSelection = false;
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (IsPositiveEffect(spellInfo->Id, i) && (
+            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA ||
+            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
+            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID
+))
+        {
+            needRankSelection = true;
+            break;
+        }
+    }
+
+    // not required
+    if (!needRankSelection)
+        return spellInfo;
+
+    for (uint32 nextSpellId = spellInfo->Id; nextSpellId != 0; nextSpellId = GetPrevSpellInChain(nextSpellId))
+    {
+        SpellEntry const *nextSpellInfo = sSpellStore.LookupEntry(nextSpellId);
+        if (!nextSpellInfo)
+            break;
+
+        // if found appropriate level
+        if (playerLevel + 10 >= nextSpellInfo->spellLevel)
+            return nextSpellInfo;
+
+        // one rank less then
+    }
+
+    // not found
+    return NULL;
+}
+
+void SpellMgr::LoadSpellLearnSkills()
+{
+    mSpellLearnSkills.clear();                              // need for reload case
+
+    // search auto-learned skills and add its to map also for use in unlearn spells/talents
+    uint32 dbc_count = 0;
+    barGoLink bar(sSpellStore.GetNumRows());
+    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
+    {
+        bar.step();
+        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
+
+        if (!entry)
+            continue;
+
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (entry->Effect[i] == SPELL_EFFECT_SKILL)
+            {
+                SpellLearnSkillNode dbc_node;
+                dbc_node.skill = entry->EffectMiscValue[i];
+                dbc_node.step  = SpellMgr::CalculateSpellEffectAmount(entry, i);
+                if (dbc_node.skill != SKILL_RIDING)
+                    dbc_node.value = 1;
+                else
+                    dbc_node.value = dbc_node.step * 75;
+                dbc_node.maxvalue = dbc_node.step * 75;
+                mSpellLearnSkills[spell] = dbc_node;
+                ++dbc_count;
+                break;
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u Spell Learn Skills from DBC", dbc_count);
+}
+
+void SpellMgr::LoadSpellLearnSpells()
+{
+    mSpellLearnSpells.clear();                              // need for reload case
+
+    //                                                  0      1        2
+    QueryResult result = WorldDatabase.Query("SELECT entry, SpellID, Active FROM spell_learn_spell");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded 0 spell learn spells");
+        sLog.outErrorDb("`spell_learn_spell` table is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        bar.step();
+        Field *fields = result->Fetch();
+
+        uint32 spell_id = fields[0].GetUInt32();
+
+        SpellLearnSpellNode node;
+        node.spell      = fields[1].GetUInt32();
+        node.active     = fields[2].GetBool();
+        node.autoLearned= false;
+
+        if (!sSpellStore.LookupEntry(spell_id))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` does not exist", spell_id);
+            continue;
+        }
+
+        if (!sSpellStore.LookupEntry(node.spell))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` learning not existed spell %u", spell_id, node.spell);
+            continue;
+        }
+
+        if (GetTalentSpellCost(node.spell))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` attempt learning talent spell %u, skipped", spell_id, node.spell);
+            continue;
+        }
+
+        mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell_id,node));
+
+        ++count;
+    } while (result->NextRow());
+
+    // search auto-learned spells and add its to map also for use in unlearn spells/talents
+    uint32 dbc_count = 0;
+    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
+    {
+        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
+
+        if (!entry)
+            continue;
+
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (entry->Effect[i] == SPELL_EFFECT_LEARN_SPELL)
+            {
+                SpellLearnSpellNode dbc_node;
+                dbc_node.spell = entry->EffectTriggerSpell[i];
+                dbc_node.active = true;                     // all dbc based learned spells is active (show in spell book or hide by client itself)
+
+                // ignore learning not existed spells (broken/outdated/or generic learnig spell 483
+                if (!sSpellStore.LookupEntry(dbc_node.spell))
+                    continue;
+
+                // talent or passive spells or skill-step spells auto-casted and not need dependent learning,
+                // pet teaching spells don't must be dependent learning (casted)
+                // other required explicit dependent learning
+                dbc_node.autoLearned = entry->EffectImplicitTargetA[i] == TARGET_UNIT_PET || GetTalentSpellCost(spell) > 0 || IsPassiveSpell(spell) || IsSpellHaveEffect(entry,SPELL_EFFECT_SKILL_STEP);
+
+                SpellLearnSpellMapBounds db_node_bounds = GetSpellLearnSpellMapBounds(spell);
+
+                bool found = false;
+                for (SpellLearnSpellMap::const_iterator itr = db_node_bounds.first; itr != db_node_bounds.second; ++itr)
+                {
+                    if (itr->second.spell == dbc_node.spell)
+                    {
+                        sLog.outErrorDb("Spell %u auto-learn spell %u in spell.dbc then the record in `spell_learn_spell` is redundant, please fix DB.",
+                            spell,dbc_node.spell);
+                        found = true;
+                        break;
+                    }
+                }
+
+                if (!found)                                  // add new spell-spell pair if not found
+                {
+                    mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell,dbc_node));
+                    ++dbc_count;
+                }
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell learn spells + %u found in DBC", count, dbc_count);
+}
+
+void SpellMgr::LoadSpellPetAuras()
+{
+    mSpellPetAuraMap.clear();                                  // need for reload case
+
+    uint32 count = 0;
+
+    //                                                  0       1       2    3
+    QueryResult result = WorldDatabase.Query("SELECT spell, effectId, pet, aura FROM spell_pet_auras");
+    if (!result)
+    {
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell pet auras", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 spell = fields[0].GetUInt32();
+        uint8 eff = fields[1].GetUInt8();
+        uint32 pet = fields[2].GetUInt32();
+        uint32 aura = fields[3].GetUInt32();
+
+        SpellPetAuraMap::iterator itr = mSpellPetAuraMap.find((spell<<8) + eff);
+        if (itr != mSpellPetAuraMap.end())
+            itr->second.AddAura(pet, aura);
+        else
+        {
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell);
+            if (!spellInfo)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_pet_auras` does not exist", spell);
+                continue;
+            }
+            if (spellInfo->Effect[eff] != SPELL_EFFECT_DUMMY &&
+               (spellInfo->Effect[eff] != SPELL_EFFECT_APPLY_AURA ||
+                spellInfo->EffectApplyAuraName[eff] != SPELL_AURA_DUMMY))
+            {
+                sLog.outError("Spell %u listed in `spell_pet_auras` does not have dummy aura or dummy effect", spell);
+                continue;
+            }
+
+            SpellEntry const* spellInfo2 = sSpellStore.LookupEntry(aura);
+            if (!spellInfo2)
+            {
+                sLog.outErrorDb("Aura %u listed in `spell_pet_auras` does not exist", aura);
+                continue;
+            }
+
+            PetAura pa(pet, aura, spellInfo->EffectImplicitTargetA[eff] == TARGET_UNIT_PET, SpellMgr::CalculateSpellEffectAmount(spellInfo, eff));
+            mSpellPetAuraMap[(spell<<8) + eff] = pa;
+        }
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell pet auras", count);
+}
+
+void SpellMgr::LoadPetLevelupSpellMap()
+{
+    mPetLevelupSpellMap.clear();                                   // need for reload case
+
+    uint32 count = 0;
+    uint32 family_count = 0;
+
+    barGoLink bar(sCreatureFamilyStore.GetNumRows());
+
+    for (uint32 i = 0; i < sCreatureFamilyStore.GetNumRows(); ++i)
+    {
+        bar.step();
+
+        CreatureFamilyEntry const *creatureFamily = sCreatureFamilyStore.LookupEntry(i);
+        if (!creatureFamily)                                     // not exist
+            continue;
+
+        for (uint8 j = 0; j < 2; ++j)
+        {
+            if (!creatureFamily->skillLine[j])
+                continue;
+
+            for (uint32 k = 0; k < sSkillLineAbilityStore.GetNumRows(); ++k)
+            {
+                SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(k);
+                if (!skillLine)
+                    continue;
+
+                //if (skillLine->skillId != creatureFamily->skillLine[0] &&
+                //    (!creatureFamily->skillLine[1] || skillLine->skillId != creatureFamily->skillLine[1]))
+                //    continue;
+
+                if (skillLine->skillId != creatureFamily->skillLine[j])
+                    continue;
+
+                if (skillLine->learnOnGetSkill != ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL)
+                    continue;
+
+                SpellEntry const *spell = sSpellStore.LookupEntry(skillLine->spellId);
+                if (!spell) // not exist or triggered or talent
+                    continue;
+
+                if (!spell->spellLevel)
+                    continue;
+
+                PetLevelupSpellSet& spellSet = mPetLevelupSpellMap[creatureFamily->ID];
+                if (spellSet.empty())
+                    ++family_count;
+
+                spellSet.insert(PetLevelupSpellSet::value_type(spell->spellLevel,spell->Id));
+                ++count;
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u pet levelup and default spells for %u families", count, family_count);
+}
+
+bool LoadPetDefaultSpells_helper(CreatureInfo const* cInfo, PetDefaultSpellsEntry& petDefSpells)
+{
+    // skip empty list;
+    bool have_spell = false;
+    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+    {
+        if (petDefSpells.spellid[j])
+        {
+            have_spell = true;
+            break;
+        }
+    }
+    if (!have_spell)
+        return false;
+
+    // remove duplicates with levelupSpells if any
+    if (PetLevelupSpellSet const *levelupSpells = cInfo->family ? sSpellMgr.GetPetLevelupSpellList(cInfo->family) : NULL)
+    {
+        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+        {
+            if (!petDefSpells.spellid[j])
+                continue;
+
+            for (PetLevelupSpellSet::const_iterator itr = levelupSpells->begin(); itr != levelupSpells->end(); ++itr)
+            {
+                if (itr->second == petDefSpells.spellid[j])
+                {
+                    petDefSpells.spellid[j] = 0;
+                    break;
+                }
+            }
+        }
+    }
+
+    // skip empty list;
+    have_spell = false;
+    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+    {
+        if (petDefSpells.spellid[j])
+        {
+            have_spell = true;
+            break;
+        }
+    }
+
+    return have_spell;
+}
+
+void SpellMgr::LoadPetDefaultSpells()
+{
+    mPetDefaultSpellsMap.clear();
+
+    uint32 countCreature = 0;
+    uint32 countData = 0;
+
+    barGoLink bar(sCreatureStorage.MaxEntry + sSpellStore.GetNumRows());
+
+    for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
+    {
+        bar.step();
+
+        CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i);
+        if (!cInfo)
+            continue;
+
+        if (!cInfo->PetSpellDataId)
+            continue;
+
+        // for creature with PetSpellDataId get default pet spells from dbc
+        CreatureSpellDataEntry const* spellDataEntry = sCreatureSpellDataStore.LookupEntry(cInfo->PetSpellDataId);
+        if (!spellDataEntry)
+            continue;
+
+        int32 petSpellsId = -int32(cInfo->PetSpellDataId);
+        PetDefaultSpellsEntry petDefSpells;
+        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+            petDefSpells.spellid[j] = spellDataEntry->spellId[j];
+
+        if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
+        {
+            mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
+            ++countData;
+        }
+    }
+
+    // different summon spells
+    for (uint32 i = 0; i < sSpellStore.GetNumRows(); ++i)
+    {
+        bar.step();
+
+        SpellEntry const* spellEntry = sSpellStore.LookupEntry(i);
+        if (!spellEntry)
+            continue;
+
+        for (uint8 k = 0; k < MAX_SPELL_EFFECTS; ++k)
+        {
+            if (spellEntry->Effect[k] == SPELL_EFFECT_SUMMON || spellEntry->Effect[k] == SPELL_EFFECT_SUMMON_PET)
+            {
+                uint32 creature_id = spellEntry->EffectMiscValue[k];
+                CreatureInfo const *cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(creature_id);
+                if (!cInfo)
+                    continue;
+
+                // already loaded
+                if (cInfo->PetSpellDataId)
+                    continue;
+
+                // for creature without PetSpellDataId get default pet spells from creature_template
+                int32 petSpellsId = cInfo->Entry;
+                if (mPetDefaultSpellsMap.find(cInfo->Entry) != mPetDefaultSpellsMap.end())
+                    continue;
+
+                PetDefaultSpellsEntry petDefSpells;
+                for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+                    petDefSpells.spellid[j] = cInfo->spells[j];
+
+                if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
+                {
+                    mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
+                    ++countCreature;
+                }
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded addition spells for %u pet spell data entries.", countData);
+    sLog.outString(">> Loaded %u summonable creature templates.", countCreature);
+}
+
+/// Some checks for spells, to prevent adding deprecated/broken spells for trainers, spell book, etc
+bool SpellMgr::IsSpellValid(SpellEntry const *spellInfo, Player *pl, bool msg)
+{
+    // not exist
+    if (!spellInfo)
+        return false;
+
+    bool need_check_reagents = false;
+
+    // check effects
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spellInfo->Effect[i])
+        {
+            case 0:
+                continue;
+
+            // craft spell for crafting non-existed item (break client recipes list show)
+            case SPELL_EFFECT_CREATE_ITEM:
+            case SPELL_EFFECT_CREATE_ITEM_2:
+            {
+                if (spellInfo->EffectItemType[i] == 0)
+                {
+                    // skip auto-loot crafting spells, its not need explicit item info (but have special fake items sometime)
+                    if (!IsLootCraftingSpell(spellInfo))
+                    {
+                        if (msg)
+                        {
+                            if (pl)
+                                ChatHandler(pl).PSendSysMessage("Craft spell %u not have create item entry.",spellInfo->Id);
+                            else
+                                sLog.outErrorDb("Craft spell %u not have create item entry.",spellInfo->Id);
+                        }
+                        return false;
+                    }
+
+                }
+                // also possible IsLootCraftingSpell case but fake item must exist anyway
+                else if (!ObjectMgr::GetItemPrototype(spellInfo->EffectItemType[i]))
+                {
+                    if (msg)
+                    {
+                        if (pl)
+                            ChatHandler(pl).PSendSysMessage("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
+                        else
+                            sLog.outErrorDb("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
+                    }
+                    return false;
+                }
+
+                need_check_reagents = true;
+                break;
+            }
+            case SPELL_EFFECT_LEARN_SPELL:
+            {
+                SpellEntry const *spellInfo2 = sSpellStore.LookupEntry(spellInfo->EffectTriggerSpell[i]);
+                if (!IsSpellValid(spellInfo2,pl,msg))
+                {
+                    if (msg)
+                    {
+                        if (pl)
+                            ChatHandler(pl).PSendSysMessage("Spell %u learn to broken spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
+                        else
+                            sLog.outErrorDb("Spell %u learn to invalid spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
+                    }
+                    return false;
+                }
+                break;
+            }
+        }
+    }
+
+    if (need_check_reagents)
+    {
+        for (uint8 j = 0; j < MAX_SPELL_REAGENTS; ++j)
+        {
+            if (spellInfo->Reagent[j] > 0 && !ObjectMgr::GetItemPrototype(spellInfo->Reagent[j]))
+            {
+                if (msg)
+                {
+                    if (pl)
+                        ChatHandler(pl).PSendSysMessage("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
+                    else
+                        sLog.outErrorDb("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
+                }
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
+void SpellMgr::LoadSpellAreas()
+{
+    mSpellAreaMap.clear();                                  // need for reload case
+    mSpellAreaForQuestMap.clear();
+    mSpellAreaForActiveQuestMap.clear();
+    mSpellAreaForQuestEndMap.clear();
+    mSpellAreaForAuraMap.clear();
+
+    uint32 count = 0;
+
+    //                                                  0     1         2              3               4           5          6        7       8
+    QueryResult result = WorldDatabase.Query("SELECT spell, area, quest_start, quest_start_active, quest_end, aura_spell, racemask, gender, autocast FROM spell_area");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell area requirements", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 spell = fields[0].GetUInt32();
+        SpellArea spellArea;
+        spellArea.spellId             = spell;
+        spellArea.areaId              = fields[1].GetUInt32();
+        spellArea.questStart          = fields[2].GetUInt32();
+        spellArea.questStartCanActive = fields[3].GetBool();
+        spellArea.questEnd            = fields[4].GetUInt32();
+        spellArea.auraSpell           = fields[5].GetInt32();
+        spellArea.raceMask            = fields[6].GetUInt32();
+        spellArea.gender              = Gender(fields[7].GetUInt8());
+        spellArea.autocast            = fields[8].GetBool();
+
+        if (const SpellEntry* spellInfo = sSpellStore.LookupEntry(spell))
+        {
+            if (spellArea.autocast)
+                const_cast<SpellEntry*>(spellInfo)->Attributes |= SPELL_ATTR_CANT_CANCEL;
+        }
+        else
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` does not exist", spell);
+            continue;
+        }
+
+        {
+            bool ok = true;
+            SpellAreaMapBounds sa_bounds = GetSpellAreaMapBounds(spellArea.spellId);
+            for (SpellAreaMap::const_iterator itr = sa_bounds.first; itr != sa_bounds.second; ++itr)
+            {
+                if (spellArea.spellId != itr->second.spellId)
+                    continue;
+                if (spellArea.areaId != itr->second.areaId)
+                    continue;
+                if (spellArea.questStart != itr->second.questStart)
+                    continue;
+                if (spellArea.auraSpell != itr->second.auraSpell)
+                    continue;
+                if ((spellArea.raceMask & itr->second.raceMask) == 0)
+                    continue;
+                if (spellArea.gender != itr->second.gender)
+                    continue;
+
+                // duplicate by requirements
+                ok =false;
+                break;
+            }
+
+            if (!ok)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` already listed with similar requirements.", spell);
+                continue;
+            }
+        }
+
+        if (spellArea.areaId && !GetAreaEntryByAreaID(spellArea.areaId))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong area (%u) requirement", spell,spellArea.areaId);
+            continue;
+        }
+
+        if (spellArea.questStart && !sObjectMgr.GetQuestTemplate(spellArea.questStart))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong start quest (%u) requirement", spell,spellArea.questStart);
+            continue;
+        }
+
+        if (spellArea.questEnd)
+        {
+            if (!sObjectMgr.GetQuestTemplate(spellArea.questEnd))
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong end quest (%u) requirement", spell,spellArea.questEnd);
+                continue;
+            }
+
+            if (spellArea.questEnd == spellArea.questStart && !spellArea.questStartCanActive)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have quest (%u) requirement for start and end in same time", spell,spellArea.questEnd);
+                continue;
+            }
+        }
+
+        if (spellArea.auraSpell)
+        {
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(spellArea.auraSpell));
+            if (!spellInfo)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong aura spell (%u) requirement", spell,abs(spellArea.auraSpell));
+                continue;
+            }
+
+            if (uint32(abs(spellArea.auraSpell)) == spellArea.spellId)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement for itself", spell,abs(spellArea.auraSpell));
+                continue;
+            }
+
+            // not allow autocast chains by auraSpell field (but allow use as alternative if not present)
+            if (spellArea.autocast && spellArea.auraSpell > 0)
+            {
+                bool chain = false;
+                SpellAreaForAuraMapBounds saBound = GetSpellAreaForAuraMapBounds(spellArea.spellId);
+                for (SpellAreaForAuraMap::const_iterator itr = saBound.first; itr != saBound.second; ++itr)
+                {
+                    if (itr->second->autocast && itr->second->auraSpell > 0)
+                    {
+                        chain = true;
+                        break;
+                    }
+                }
+
+                if (chain)
+                {
+                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
+                    continue;
+                }
+
+                SpellAreaMapBounds saBound2 = GetSpellAreaMapBounds(spellArea.auraSpell);
+                for (SpellAreaMap::const_iterator itr2 = saBound2.first; itr2 != saBound2.second; ++itr2)
+                {
+                    if (itr2->second.autocast && itr2->second.auraSpell > 0)
+                    {
+                        chain = true;
+                        break;
+                    }
+                }
+
+                if (chain)
+                {
+                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
+                    continue;
+                }
+            }
+        }
+
+        if (spellArea.raceMask && (spellArea.raceMask & RACEMASK_ALL_PLAYABLE) == 0)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong race mask (%u) requirement", spell,spellArea.raceMask);
+            continue;
+        }
+
+        if (spellArea.gender != GENDER_NONE && spellArea.gender != GENDER_FEMALE && spellArea.gender != GENDER_MALE)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong gender (%u) requirement", spell, spellArea.gender);
+            continue;
+        }
+
+        SpellArea const* sa = &mSpellAreaMap.insert(SpellAreaMap::value_type(spell,spellArea))->second;
+
+        // for search by current zone/subzone at zone/subzone change
+        if (spellArea.areaId)
+            mSpellAreaForAreaMap.insert(SpellAreaForAreaMap::value_type(spellArea.areaId,sa));
+
+        // for search at quest start/reward
+        if (spellArea.questStart)
+        {
+            if (spellArea.questStartCanActive)
+                mSpellAreaForActiveQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
+            else
+                mSpellAreaForQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
+        }
+
+        // for search at quest start/reward
+        if (spellArea.questEnd)
+            mSpellAreaForQuestEndMap.insert(SpellAreaForQuestMap::value_type(spellArea.questEnd,sa));
+
+        // for search at aura apply
+        if (spellArea.auraSpell)
+            mSpellAreaForAuraMap.insert(SpellAreaForAuraMap::value_type(abs(spellArea.auraSpell),sa));
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell area requirements", count);
+}
+
+SpellCastResult SpellMgr::GetSpellAllowedInLocationError(SpellEntry const *spellInfo, uint32 map_id, uint32 zone_id, uint32 area_id, Player const* player)
+{
+    // normal case
+    if (spellInfo->AreaGroupId > 0)
+    {
+        bool found = false;
+        AreaGroupEntry const* groupEntry = sAreaGroupStore.LookupEntry(spellInfo->AreaGroupId);
+        while (groupEntry)
+        {
+            for (uint8 i = 0; i < MAX_GROUP_AREA_IDS; ++i)
+                if (groupEntry->AreaId[i] == zone_id || groupEntry->AreaId[i] == area_id)
+                    found = true;
+            if (found || !groupEntry->nextGroup)
+                break;
+            // Try search in next group
+            groupEntry = sAreaGroupStore.LookupEntry(groupEntry->nextGroup);
+        }
+
+        if (!found)
+            return SPELL_FAILED_INCORRECT_AREA;
+    }
+
+    // continent limitation (virtual continent)
+    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_CAST_ONLY_IN_OUTLAND)
+    {
+        uint32 v_map = GetVirtualMapForMapAndZone(map_id, zone_id);
+        MapEntry const *mapEntry = sMapStore.LookupEntry(v_map);
+        if (!mapEntry || mapEntry->addon < 1 || !mapEntry->IsContinent())
+            return SPELL_FAILED_INCORRECT_AREA;
+    }
+
+    // raid instance limitation
+    if (spellInfo->AttributesEx6 & SPELL_ATTR_EX6_NOT_IN_RAID_INSTANCE)
+    {
+        MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+        if (!mapEntry || mapEntry->IsRaid())
+            return SPELL_FAILED_NOT_IN_RAID_INSTANCE;
+    }
+
+    // DB base check (if non empty then must fit at least single for allow)
+    SpellAreaMapBounds saBounds = sSpellMgr.GetSpellAreaMapBounds(spellInfo->Id);
+    if (saBounds.first != saBounds.second)
+    {
+        for (SpellAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+        {
+            if (itr->second.IsFitToRequirements(player,zone_id,area_id))
+                return SPELL_CAST_OK;
+        }
+        return SPELL_FAILED_INCORRECT_AREA;
+    }
+
+    // bg spell checks
+    switch(spellInfo->Id)
+    {
+        case 23333:                                         // Warsong Flag
+        case 23335:                                         // Silverwing Flag
+            return map_id == 489 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        case 34976:                                         // Netherstorm Flag
+            return map_id == 566 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        case 2584:                                          // Waiting to Resurrect
+        case 22011:                                         // Spirit Heal Channel
+        case 22012:                                         // Spirit Heal
+        case 24171:                                         // Resurrection Impact Visual
+        case 42792:                                         // Recently Dropped Flag
+        case 43681:                                         // Inactive
+        case 44535:                                         // Spirit Heal (mana)
+        {
+            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            return zone_id == 4197 || (mapEntry->IsBattleground() && player && player->InBattleground()) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+        case 44521:                                         // Preparation
+        {
+            if (!player)
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            if (!mapEntry->IsBattleground())
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            Battleground* bg = player->GetBattleground();
+            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+        case 32724:                                         // Gold Team (Alliance)
+        case 32725:                                         // Green Team (Alliance)
+        case 35774:                                         // Gold Team (Horde)
+        case 35775:                                         // Green Team (Horde)
+        {
+            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            return mapEntry->IsBattleArena() && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+        case 32727:                                         // Arena Preparation
+        {
+            if (!player)
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            if (!mapEntry->IsBattleArena())
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            Battleground *bg = player->GetBattleground();
+            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+    }
+
+    // aura limitations
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spellInfo->EffectApplyAuraName[i])
+        {
+            case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
+            case SPELL_AURA_FLY:
+            {
+                if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
+                    return SPELL_FAILED_INCORRECT_AREA;
+            }
+        }
+    }
+
+    return SPELL_CAST_OK;
+}
+
+void SpellMgr::LoadSkillLineAbilityMap()
+{
+    mSkillLineAbilityMap.clear();
+
+    barGoLink bar(sSkillLineAbilityStore.GetNumRows());
+    uint32 count = 0;
+
+    for (uint32 i = 0; i < sSkillLineAbilityStore.GetNumRows(); ++i)
+    {
+        bar.step();
+        SkillLineAbilityEntry const *SkillInfo = sSkillLineAbilityStore.LookupEntry(i);
+        if (!SkillInfo)
+            continue;
+
+        mSkillLineAbilityMap.insert(SkillLineAbilityMap::value_type(SkillInfo->spellId,SkillInfo));
+        ++count;
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u SkillLineAbility MultiMap Data", count);
+}
+
+DiminishingGroup GetDiminishingReturnsGroupForSpell(SpellEntry const* spellproto, bool triggered)
+{
+    // Explicit Diminishing Groups
+    switch (spellproto->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+            // some generic arena related spells have by some strange reason MECHANIC_TURN
+            if  (spellproto->Mechanic == MECHANIC_TURN)
+                return DIMINISHING_NONE;
+            break;
+        case SPELLFAMILY_MAGE:
+        {
+            // Frostbite
+            if (spellproto->SpellFamilyFlags[1] & 0x80000000)
+                return DIMINISHING_TRIGGER_ROOT;
+            //Shattered Barrier: only flag SpellFamilyFlags[0] = 0x00080000 shared
+            //by most frost spells, using id instead
+            if (spellproto->Id == 55080)
+                return DIMINISHING_TRIGGER_ROOT;
+            // Frost Nova / Freeze (Water Elemental)
+            if (spellproto->SpellIconID == 193)
+                return DIMINISHING_CONTROL_ROOT;
+            break;
+        }
+        case SPELLFAMILY_ROGUE:
+        {
+            // Sap 0x80 Gouge 0x8
+            if (spellproto->SpellFamilyFlags[0] & 0x88)
+                return DIMINISHING_POLYMORPH;
+            // Blind
+            else if (spellproto->SpellFamilyFlags[0] & 0x1000000)
+                return DIMINISHING_FEAR_BLIND;
+            // Cheap Shot
+            else if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return DIMINISHING_CHEAPSHOT_POUNCE;
+            // Crippling poison - Limit to 10 seconds in PvP (No SpellFamilyFlags)
+            else if (spellproto->SpellIconID == 163)
+                return DIMINISHING_LIMITONLY;
+            break;
+        }
+        case SPELLFAMILY_WARLOCK:
+        {
+            // Death Coil
+            if (spellproto->SpellFamilyFlags[0] & 0x80000)
+                return DIMINISHING_DEATHCOIL;
+            // Curses/etc
+            else if (spellproto->SpellFamilyFlags[0] & 0x80000000)
+                return DIMINISHING_LIMITONLY;
+            // Howl of Terror
+            else if (spellproto->SpellFamilyFlags[1] & 0x8)
+                return DIMINISHING_FEAR_BLIND;
+            // Seduction
+            else if (spellproto->SpellFamilyFlags[0] & 0x40000000)
+                return DIMINISHING_FEAR_BLIND;
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            // Pounce
+            if (spellproto->SpellFamilyFlags[0] & 0x20000)
+                return DIMINISHING_CHEAPSHOT_POUNCE;
+            // Cyclone
+            else if (spellproto->SpellFamilyFlags[1] & 0x20)
+                return DIMINISHING_CYCLONE;
+            // Entangling Roots: to force natures grasp proc to be control root
+            else if (spellproto->SpellFamilyFlags[0] & 0x00000200)
+                return DIMINISHING_CONTROL_ROOT;
+            // Faerie Fire
+            else if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return DIMINISHING_LIMITONLY;
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            // Hamstring - limit duration to 10s in PvP
+            if (spellproto->SpellFamilyFlags[0] & 0x2)
+                return DIMINISHING_LIMITONLY;
+            // Intimidating Shout
+            else if (spellproto->SpellFamilyFlags[0] & 0x40000)
+                return DIMINISHING_FEAR_BLIND;
+            // Charge Stun
+            else if (spellproto->SpellFamilyFlags[0] & 0x01000000)
+                return DIMINISHING_NONE;
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Repentance
+            if (spellproto->SpellFamilyFlags[0] & 0x4)
+                return DIMINISHING_POLYMORPH;
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Hungering Cold (no flags)
+            if (spellproto->SpellIconID == 2797)
+                return DIMINISHING_POLYMORPH;
+            // Mark of Blood
+            else if ((spellproto->SpellFamilyFlags[0] & 0x10000000)
+                && spellproto->SpellIconID == 2285)
+                return DIMINISHING_LIMITONLY;
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // Hunter's mark
+            if ((spellproto->SpellFamilyFlags[0] & 0x400) && spellproto->SpellIconID == 538)
+                return DIMINISHING_LIMITONLY;
+            // Scatter Shot
+            if ((spellproto->SpellFamilyFlags[0] & 0x40000) && spellproto->SpellIconID == 132)
+                return DIMINISHING_NONE;
+            break;
+        }
+        default:
+            break;
+    }
+
+    // Get by mechanic
+    uint32 mechanic = GetAllSpellMechanicMask(spellproto);
+    if (mechanic == MECHANIC_NONE)          return DIMINISHING_NONE;
+    if (mechanic & ((1<<MECHANIC_STUN) |
+                    (1<<MECHANIC_SHACKLE))) return triggered ? DIMINISHING_TRIGGER_STUN : DIMINISHING_CONTROL_STUN;
+    if (mechanic & ((1<<MECHANIC_SLEEP) |
+                    (1<<MECHANIC_FREEZE))) return DIMINISHING_FREEZE_SLEEP;
+    if (mechanic & (1<<MECHANIC_POLYMORPH)) return DIMINISHING_POLYMORPH;
+    if (mechanic & (1<<MECHANIC_ROOT))      return triggered ? DIMINISHING_TRIGGER_ROOT : DIMINISHING_CONTROL_ROOT;
+    if (mechanic & ((1<<MECHANIC_FEAR) |
+                    (1<<MECHANIC_TURN)))    return DIMINISHING_FEAR_BLIND;
+    if (mechanic & (1<<MECHANIC_CHARM))     return DIMINISHING_CHARM;
+    if (mechanic & (1<<MECHANIC_SILENCE))   return DIMINISHING_SILENCE;
+    if (mechanic & (1<<MECHANIC_DISARM))    return DIMINISHING_DISARM;
+    if (mechanic & (1<<MECHANIC_FREEZE))    return DIMINISHING_FREEZE_SLEEP;
+    if (mechanic & ((1<<MECHANIC_KNOCKOUT) |
+                    (1<<MECHANIC_SAPPED)))  return DIMINISHING_KNOCKOUT;
+    if (mechanic & (1<<MECHANIC_BANISH))    return DIMINISHING_BANISH;
+    if (mechanic & (1<<MECHANIC_HORROR))    return DIMINISHING_DEATHCOIL;
+
+    // Get by effect
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_TAUNT)
+            return DIMINISHING_TAUNT;
+    }
+    return DIMINISHING_NONE;
+}
+
+int32 GetDiminishingReturnsLimitDuration(DiminishingGroup group, SpellEntry const* spellproto)
+{
+    if (!IsDiminishingReturnsGroupDurationLimited(group))
+        return 0;
+
+    // Explicit diminishing duration
+    switch(spellproto->SpellFamilyName)
+    {
+        case SPELLFAMILY_HUNTER:
+        {
+            // Wyvern Sting
+            if (spellproto->SpellFamilyFlags[1] & 0x1000)
+                return 6 * IN_MILLISECONDS;
+            // Hunter's Mark
+            if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return 120 * IN_MILLISECONDS;
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Repentance - limit to 6 seconds in PvP
+            if (spellproto->SpellFamilyFlags[0] & 0x4)
+                return 6 * IN_MILLISECONDS;
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            // Faerie Fire - limit to 40 seconds in PvP (3.1)
+            if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return 40 * IN_MILLISECONDS;
+            break;
+        }
+        default:
+            break;
+    }
+
+    return 10 * IN_MILLISECONDS;
+}
+
+bool IsDiminishingReturnsGroupDurationLimited(DiminishingGroup group)
+{
+    switch(group)
+    {
+        case DIMINISHING_CONTROL_STUN:
+        case DIMINISHING_TRIGGER_STUN:
+        case DIMINISHING_FREEZE_SLEEP:
+        case DIMINISHING_CONTROL_ROOT:
+        case DIMINISHING_TRIGGER_ROOT:
+        case DIMINISHING_FEAR_BLIND:
+        case DIMINISHING_CHARM:
+        case DIMINISHING_POLYMORPH:
+        case DIMINISHING_KNOCKOUT:
+        case DIMINISHING_CYCLONE:
+        case DIMINISHING_BANISH:
+        case DIMINISHING_LIMITONLY:
+        case DIMINISHING_CHEAPSHOT_POUNCE:
+            return true;
+        default:
+            return false;
+    }
+}
+
+DiminishingLevels GetDiminishingReturnsMaxLevel(DiminishingGroup group)
+{
+    switch(group)
+    {
+        case DIMINISHING_TAUNT:
+            return DIMINISHING_LEVEL_TAUNT_IMMUNE;
+        default:
+            return DIMINISHING_LEVEL_IMMUNE;
+    }
+}
+
+DiminishingReturnsType GetDiminishingReturnsGroupType(DiminishingGroup group)
+{
+    switch(group)
+    {
+        case DIMINISHING_TAUNT:
+        case DIMINISHING_CONTROL_STUN:
+        case DIMINISHING_TRIGGER_STUN:
+        case DIMINISHING_CHEAPSHOT_POUNCE:
+        case DIMINISHING_CYCLONE:
+            return DRTYPE_ALL;
+        case DIMINISHING_FEAR_BLIND:
+        case DIMINISHING_CONTROL_ROOT:
+        case DIMINISHING_TRIGGER_ROOT:
+        case DIMINISHING_CHARM:
+        case DIMINISHING_POLYMORPH:
+        case DIMINISHING_SILENCE:
+        case DIMINISHING_DISARM:
+        case DIMINISHING_DEATHCOIL:
+        case DIMINISHING_FREEZE_SLEEP:
+        case DIMINISHING_BANISH:
+        case DIMINISHING_KNOCKOUT:
+            return DRTYPE_PLAYER;
+        default:
+            break;
+    }
+
+    return DRTYPE_NONE;
+}
+
+bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32 newArea) const
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr.GetOutdoorPvPToZoneId(4197);
+
+    if (gender != GENDER_NONE)                   // not in expected gender
+        if (!player || gender != player->getGender())
+            return false;
+
+    if (raceMask)                                // not in expected race
+        if (!player || !(raceMask & player->getRaceMask()))
+            return false;
+
+    if (areaId)                                  // not in expected zone
+        if (newZone != areaId && newArea != areaId)
+            return false;
+
+    if (questStart)                              // not in expected required quest state
+        if (!player || ((!questStartCanActive || !player->IsActiveQuest(questStart)) && !player->GetQuestRewardStatus(questStart)))
+            return false;
+
+    if (questEnd)                                // not in expected forbidden quest state
+        if (!player || player->GetQuestRewardStatus(questEnd))
+            return false;
+
+    if (auraSpell)                               // not have expected aura
+        if (!player || (auraSpell > 0 && !player->HasAura(auraSpell)) || (auraSpell < 0 && player->HasAura(-auraSpell)))
+            return false;
+
+    // Extra conditions -- leaving the possibility add extra conditions...
+    switch(spellId)
+    {
+        case 58600: // No fly Zone - Dalaran
+			{
+            if (!player)
+                return false;
+
+            AreaTableEntry const* pArea = GetAreaEntryByAreaID(player->GetAreaId());
+            if (!(pArea && pArea->flags & AREA_FLAG_NO_FLY_ZONE))
+                return false;
+            if (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY))
+                return false;
+			}
+            break;
+        case 58730: // No fly Zone - Wintergrasp
+			{
+				if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+				{
+				  if ((pvpWG->isWarTime()==false) || !player || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)) || player->HasAura(45472) || player->HasAura(44795) || player->GetPositionZ() > 619.2f || player->isInFlight())
+				    return false;
+				}
+			}
+            break;
+        case 58045: // Essence of Wintergrasp - Wintergrasp
+        case 57940: // Essence of Wintergrasp - Northrend
+             if (!player || player->GetTeamId() != sWorld.getWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION))
+             return false;
+            break;
+    }
+
+    return true;
+}
+
+//-----------TRINITY-------------
+
+bool SpellMgr::CanAurasStack(SpellEntry const *spellInfo_1, SpellEntry const *spellInfo_2, bool sameCaster) const
+{
+    SpellSpecific spellSpec_1 = GetSpellSpecific(spellInfo_1);
+    SpellSpecific spellSpec_2 = GetSpellSpecific(spellInfo_2);
+    if (spellSpec_1 && spellSpec_2)
+        if (IsSingleFromSpellSpecificPerTarget(spellSpec_1, spellSpec_2)
+            || (sameCaster && IsSingleFromSpellSpecificPerCaster(spellSpec_1, spellSpec_2)))
+            return false;
+
+    SpellGroupStackRule stackRule = CheckSpellGroupStackRules(spellInfo_1->Id, spellInfo_2->Id);
+    if (stackRule)
+    {
+        if (stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE)
+            return false;
+        if (sameCaster && stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE_FROM_SAME_CASTER)
+            return false;
+    }
+
+    if (spellInfo_1->SpellFamilyName != spellInfo_2->SpellFamilyName)
+        return true;
+
+    if (!sameCaster)
+    {
+        if (spellInfo_1->AttributesEx & SPELL_ATTR_EX_STACK_FOR_DIFF_CASTERS
+            || spellInfo_1->AttributesEx3 & SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS)
+            return true;
+
+        // check same periodic auras
+        for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            switch(spellInfo_1->EffectApplyAuraName[i])
+            {
+                // DOT or HOT from different casters will stack
+                case SPELL_AURA_PERIODIC_DAMAGE:
+                case SPELL_AURA_PERIODIC_DUMMY:
+                case SPELL_AURA_PERIODIC_HEAL:
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
+                case SPELL_AURA_PERIODIC_ENERGIZE:
+                case SPELL_AURA_PERIODIC_MANA_LEECH:
+                case SPELL_AURA_PERIODIC_LEECH:
+                case SPELL_AURA_POWER_BURN_MANA:
+                case SPELL_AURA_OBS_MOD_POWER:
+                case SPELL_AURA_OBS_MOD_HEALTH:
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+                    return true;
+                default:
+                    break;
+            }
+        }
+    }
+
+    uint32 spellId_1 = GetLastSpellInChain(spellInfo_1->Id);
+    uint32 spellId_2 = GetLastSpellInChain(spellInfo_2->Id);
+
+    // same spell
+    if (spellId_1 == spellId_2)
+    {
+        // Hack for Incanter's Absorption
+        if (spellId_1 == 44413)
+            return true;
+        // same spell with same caster should not stack
+        return false;
+    }
+
+    return true;
+}
+
+bool CanSpellDispelAura(SpellEntry const * dispelSpell, SpellEntry const * aura)
+{
+    // These auras (like ressurection sickness) can't be dispelled
+    if (aura->Attributes & SPELL_ATTR_NEGATIVE_1)
+        return false;
+
+    // These spells (like Mass Dispel) can dispell all auras
+    if (dispelSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return true;
+
+    // These auras (like Divine Shield) can't be dispelled
+    if (aura->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return false;
+
+    // These auras (Cyclone for example) are not dispelable
+    if (aura->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
+        return false;
+
+    return true;
+}
+
+bool CanSpellPierceImmuneAura(SpellEntry const * pierceSpell, SpellEntry const * aura)
+{
+    // these spells pierce all avalible spells (Resurrection Sickness for example)
+    if (pierceSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return true;
+
+    // these spells (Cyclone for example) can pierce all...
+    if ((pierceSpell->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
+        // ...but not these (Divine shield for example)
+        && !(aura && (aura->Mechanic == MECHANIC_IMMUNE_SHIELD || aura->Mechanic == MECHANIC_INVULNERABILITY)))
+        return true;
+
+    return false;
+}
+
+void SpellMgr::LoadSpellEnchantProcData()
+{
+    mSpellEnchantProcEventMap.clear();                             // need for reload case
+
+    uint32 count = 0;
+
+    //                                                  0         1           2         3
+    QueryResult result = WorldDatabase.Query("SELECT entry, customChance, PPMChance, procEx FROM spell_enchant_proc_data");
+    if (!result)
+    {
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell enchant proc event conditions", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 enchantId = fields[0].GetUInt32();
+
+        SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchantId);
+        if (!ench)
+        {
+            sLog.outErrorDb("Enchancment %u listed in `spell_enchant_proc_data` does not exist", enchantId);
+            continue;
+        }
+
+        SpellEnchantProcEntry spe;
+
+        spe.customChance = fields[1].GetUInt32();
+        spe.PPMChance = fields[2].GetFloat();
+        spe.procEx = fields[3].GetUInt32();
+
+        mSpellEnchantProcEventMap[enchantId] = spe;
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u enchant proc data definitions", count);
+}
+
+void SpellMgr::LoadSpellRequired()
+{
+    mSpellsReqSpell.clear();                                   // need for reload case
+    mSpellReq.clear();                                         // need for reload case
+
+    QueryResult result = WorldDatabase.Query("SELECT spell_id, req_spell from spell_required");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded 0 spell required records");
+        sLog.outErrorDb("`spell_required` table is empty!");
+        return;
+    }
+    uint32 rows = 0;
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        bar.step();
+        Field *fields = result->Fetch();
+
+        uint32 spell_id =  fields[0].GetUInt32();
+        uint32 spell_req = fields[1].GetUInt32();
+        // check if chain is made with valid first spell
+        SpellEntry const * spell = sSpellStore.LookupEntry(spell_id);
+        if (!spell)
+        {
+            sLog.outErrorDb("spell_id %u in `spell_required` table is not found in dbcs, skipped", spell_id);
+            continue;
+        }
+        SpellEntry const * req_spell = sSpellStore.LookupEntry(spell_req);
+        if (!req_spell)
+        {
+            sLog.outErrorDb("req_spell %u in `spell_required` table is not found in dbcs, skipped", spell_req);
+            continue;
+        }
+        if (GetFirstSpellInChain(spell_id) == GetFirstSpellInChain(spell_req))
+        {
+            sLog.outErrorDb("req_spell %u and spell_id %u in `spell_required` table are ranks of the same spell, entry not needed, skipped", spell_req, spell_id);
+            continue;
+        }
+        if (IsSpellRequiringSpell(spell_id, spell_req))
+        {
+            sLog.outErrorDb("duplicated entry of req_spell %u and spell_id %u in `spell_required`, skipped", spell_req, spell_id);
+            continue;
+        }
+
+        mSpellReq.insert (std::pair<uint32, uint32>(spell_id, spell_req));
+        mSpellsReqSpell.insert (std::pair<uint32, uint32>(spell_req, spell_id));
+        ++rows;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell required records", rows);
+}
+
+void SpellMgr::LoadSpellRanks()
+{
+    mSpellChains.clear();                                   // need for reload case
+
+    QueryResult result = WorldDatabase.Query("SELECT first_spell_id, spell_id, rank from spell_ranks ORDER BY first_spell_id , rank");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded 0 spell rank records");
+        sLog.outErrorDb("`spell_ranks` table is empty!");
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    uint32 rows = 0;
+    bool finished = false;
+
+    do
+    {
+                        // spellid, rank
+        std::list < std::pair < int32, int32 > > rankChain;
+        int32 currentSpell = -1;
+        int32 lastSpell = -1;
+
+        // fill one chain
+        while (currentSpell == lastSpell && !finished)
+        {
+            Field *fields = result->Fetch();
+
+            currentSpell = fields[0].GetUInt32();
+            if (lastSpell == -1)
+                lastSpell = currentSpell;
+            uint32 spell_id = fields[1].GetUInt32();
+            uint32 rank = fields[2].GetUInt32();
+
+            // don't drop the row if we're moving to the next rank
+            if (currentSpell == lastSpell)
+            {
+                bar.step();
+                rankChain.push_back(std::make_pair(spell_id, rank));
+                if (!result->NextRow())
+                    finished = true;
+            }
+            else
+                break;
+        }
+        // check if chain is made with valid first spell
+        SpellEntry const * first = sSpellStore.LookupEntry(lastSpell);
+        if (!first)
+        {
+            sLog.outErrorDb("Spell rank identifier(first_spell_id) %u listed in `spell_ranks` does not exist!", lastSpell);
+            continue;
+        }
+        // check if chain is long enough
+        if (rankChain.size() < 2)
+        {
+            sLog.outErrorDb("There is only 1 spell rank for identifier(first_spell_id) %u in `spell_ranks`, entry is not needed!", lastSpell);
+            continue;
+        }
+        int32 curRank = 0;
+        bool valid = true;
+        // check spells in chain
+        for (std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin() ; itr!= rankChain.end(); ++itr)
+        {
+            SpellEntry const * spell = sSpellStore.LookupEntry(itr->first);
+            if (!spell)
+            {
+                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not exist!", itr->first, itr->second, lastSpell);
+                valid = false;
+                break;
+            }
+            ++curRank;
+            if (itr->second != curRank)
+            {
+                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not have proper rank value(should be %u)!", itr->first, itr->second, lastSpell, curRank);
+                valid = false;
+                break;
+            }
+        }
+        if (!valid)
+            continue;
+        int32 prevRank = 0;
+        // insert the chain
+        std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin();
+        do
+        {
+            ++rows;
+            int32 addedSpell = itr->first;
+            mSpellChains[addedSpell].first = lastSpell;
+            mSpellChains[addedSpell].last = rankChain.back().first;
+            mSpellChains[addedSpell].rank = itr->second;
+            mSpellChains[addedSpell].prev = prevRank;
+            prevRank = addedSpell;
+            ++itr;
+            if (itr == rankChain.end())
+            {
+                mSpellChains[addedSpell].next = 0;
+                break;
+            }
+            else
+                mSpellChains[addedSpell].next = itr->first;
+        }
+        while (true);
+    } while (!finished);
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell rank records", rows);
+}
+
+// set data in core for now
+void SpellMgr::LoadSpellCustomAttr()
+{
+    mSpellCustomAttr.resize(GetSpellStore()->GetNumRows());
+
+    barGoLink bar(GetSpellStore()->GetNumRows());
+
+    uint32 count = 0;
+
+    SpellEntry *spellInfo;
+    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
+    {
+        bar.step();
+
+        mSpellCustomAttr[i] = 0;
+        spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
+        if (!spellInfo)
+            continue;
+
+        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            switch (spellInfo->Effect[j])
+            {
+                case SPELL_EFFECT_SCHOOL_DAMAGE:
+                case SPELL_EFFECT_WEAPON_DAMAGE:
+                case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+                case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                case SPELL_EFFECT_HEAL:
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_DIRECT_DAMAGE;
+                    count++;
+                    break;
+                case SPELL_EFFECT_CHARGE:
+                case SPELL_EFFECT_CHARGE_DEST:
+                case SPELL_EFFECT_JUMP:
+                case SPELL_EFFECT_JUMP_DEST:
+                case SPELL_EFFECT_LEAP_BACK:
+                    if (!spellInfo->speed && !spellInfo->SpellFamilyName)
+                        spellInfo->speed = SPEED_CHARGE;
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_CHARGE;
+                    count++;
+                    break;
+                case SPELL_EFFECT_PICKPOCKET:
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_PICKPOCKET;
+                    break;
+                case SPELL_EFFECT_TRIGGER_SPELL:
+                    if (IsPositionTarget(spellInfo->EffectImplicitTargetA[j]) ||
+                        spellInfo->Targets & (TARGET_FLAG_SOURCE_LOCATION|TARGET_FLAG_DEST_LOCATION))
+                        spellInfo->Effect[j] = SPELL_EFFECT_TRIGGER_MISSILE;
+                    count++;
+                    break;
+            }
+
+            switch (SpellTargetType[spellInfo->EffectImplicitTargetA[j]])
+            {
+                case TARGET_TYPE_UNIT_TARGET:
+                case TARGET_TYPE_DEST_TARGET:
+                    spellInfo->Targets |= TARGET_FLAG_UNIT;
+                    count++;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            switch (spellInfo->EffectApplyAuraName[j])
+            {
+                case SPELL_AURA_MOD_POSSESS:
+                case SPELL_AURA_MOD_CONFUSE:
+                case SPELL_AURA_MOD_CHARM:
+                case SPELL_AURA_AOE_CHARM:
+                case SPELL_AURA_MOD_FEAR:
+                case SPELL_AURA_MOD_STUN:
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
+                    count++;
+                    break;
+            }
+        }
+
+        if (!_isPositiveEffect(i, 0, false))
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF0;
+            count++;
+        }
+        if (!_isPositiveEffect(i, 1, false))
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF1;
+            count++;
+        }
+        if (!_isPositiveEffect(i, 2, false))
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF2;
+            count++;
+        }
+
+        if (spellInfo->SpellVisual[0] == 3879)
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_BACK;
+            count++;
+        }
+
+        if (spellInfo->activeIconID == 2158)  // flight
+        {
+            spellInfo->Attributes |= SPELL_ATTR_PASSIVE;
+            count++;
+        }
+
+        switch(i)
+        {
+        // Bind
+        case 3286:
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_TARGET_ENEMY;
+            spellInfo->EffectImplicitTargetA[1] = TARGET_UNIT_TARGET_ENEMY;
+            count++;
+            break;
+        // Heroism
+        case 32182:
+            spellInfo->excludeCasterAuraSpell = 57723; // Exhaustion
+            count++;
+            break;
+        // Blazing Harpoon
+        case 61588:
+            spellInfo->MaxAffectedTargets = 1;
+            count++;
+            break;
+        // Bloodlust
+        case 2825:
+            spellInfo->excludeCasterAuraSpell = 57724; // Sated
+            count++;
+            break;
+        // Heart of the Crusader
+        case 20335:
+        case 20336:
+        case 20337:
+        // Glyph of Life Tap
+        case 63320:
+        // Entries were not updated after spell effect change, we have to do that manually :/
+            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_CAN_PROC_TRIGGERED;
+            count++;
+            break;
+        case 16007: // Draco-Incarcinatrix 900
+            // was 46, but effect is aura effect
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_NEARBY_ENTRY;
+            spellInfo->EffectImplicitTargetB[0] = TARGET_DST_NEARBY_ENTRY;
+            count++;
+            break;
+        case 26029: // dark glare
+        case 37433: // spout
+        case 43140: case 43215: // flame breath
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_LINE;
+            count++;
+            break;
+        case 24340: case 26558: case 28884:     // Meteor
+        case 36837: case 38903: case 41276:     // Meteor
+        case 57467:                             // Meteor
+        case 26789:                             // Shard of the Fallen Star
+        case 31436:                             // Malevolent Cleave
+        case 35181:                             // Dive Bomb
+        case 40810: case 43267: case 43268:     // Saber Lash
+        case 42384:                             // Brutal Swipe
+        case 45150:                             // Meteor Slash
+        case 64422: case 64688:                 // Sonic Screech
+        case 72373:                             // Shared Suffering
+        case 71904:                             // Chaos Bane
+            // ONLY SPELLS WITH SPELLFAMILY_GENERIC and EFFECT_SCHOOL_DAMAGE
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_SHARE_DAMAGE;
+            count++;
+            break;
+        case 59725:                             // Improved Spell Reflection - aoe aura
+            // Target entry seems to be wrong for this spell :/
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_PARTY_CASTER;
+            spellInfo->EffectRadiusIndex[0] = 45;
+            count++;
+            break;
+        case 27820:                             // Mana Detonation
+        //case 28062: case 39090:                 // Positive/Negative Charge
+        //case 28085: case 39093:
+        case 69782: case 69796:                 // Ooze Flood
+        case 69798: case 69801:                 // Ooze Flood
+        case 69538: case 69553: case 69610:     // Ooze Combine
+	    case 71614:                             // Ice Lock
+
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
+            count++;
+            break;
+        case 44978: case 45001: case 45002:     // Wild Magic
+        case 45004: case 45006: case 45010:     // Wild Magic
+        case 31347: // Doom
+        case 41635: // Prayer of Mending
+        case 44869: // Spectral Blast
+        case 45027: // Revitalize
+        case 45976: // Muru Portal Channel
+        case 39365: // Thundering Storm
+        case 41071: // Raise Dead (HACK)
+        case 52124: // Sky Darkener Assault
+        case 42442: // Vengeance Landing Cannonfire
+        case 45863: // Cosmetic - Incinerate to Random Target
+        case 25425: // Shoot
+        case 45761: // Shoot
+        case 42611: // Shoot
+        case 62374: // Pursued
+            spellInfo->MaxAffectedTargets = 1;
+            count++;
+            break;
+        case 52479: // Gift of the Harvester
+            spellInfo->MaxAffectedTargets = 1;
+            // a trap always has dst = src?
+            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_CASTER;
+            spellInfo->EffectImplicitTargetA[1] = TARGET_DST_CASTER;
+            count++;
+            break;
+        case 41376: // Spite
+        case 39992: // Needle Spine
+        case 29576: // Multi-Shot
+        case 40816: // Saber Lash
+        case 37790: // Spread Shot
+        case 46771: // Flame Sear
+        case 45248: // Shadow Blades
+        case 41303: // Soul Drain
+        case 54172: // Divine Storm (heal)
+        case 29213: // Curse of the Plaguebringer - Noth
+        case 28542: // Life Drain - Sapphiron
+        case 66588: // Flaming Spear
+        case 54171: // Divine Storm
+            spellInfo->MaxAffectedTargets = 3;
+            count++;
+            break;
+        case 38310: // Multi-Shot
+        case 53385: // Divine Storm (Damage)
+            spellInfo->MaxAffectedTargets = 4;
+            count++;
+            break;
+        case 42005: // Bloodboil
+        case 38296: // Spitfire Totem
+        case 37676: // Insidious Whisper
+        case 46008: // Negative Energy
+        case 45641: // Fire Bloom
+        case 55665: // Life Drain - Sapphiron (H)
+        case 28796: // Poison Bolt Volly - Faerlina
+            spellInfo->MaxAffectedTargets = 5;
+            count++;
+            break;
+        case 40827: // Sinful Beam
+        case 40859: // Sinister Beam
+        case 40860: // Vile Beam
+        case 40861: // Wicked Beam
+        case 54835: // Curse of the Plaguebringer - Noth (H)
+        case 54098: // Poison Bolt Volly - Faerlina (H)
+            spellInfo->MaxAffectedTargets = 10;
+            count++;
+            break;
+        case 50312: // Unholy Frenzy
+            spellInfo->MaxAffectedTargets = 15;
+            count++;
+            break;
+        case 38794: case 33711: //Murmur's Touch
+            spellInfo->MaxAffectedTargets = 1;
+            spellInfo->EffectTriggerSpell[0] = 33760;
+            count++;
+            break;
+        case 17941:    // Shadow Trance
+        case 22008:    // Netherwind Focus
+        case 31834:    // Light's Grace
+        case 34754:    // Clearcasting
+        case 34936:    // Backlash
+        case 48108:    // Hot Streak
+        case 51124:    // Killing Machine
+        case 54741:    // Firestarter
+        case 57761:    // Fireball!
+        case 39805:    // Lightning Overload
+        case 64823:    // Item - Druid T8 Balance 4P Bonus
+        case 44401:
+            spellInfo->procCharges = 1;
+            count++;
+            break;
+        case 53390: // Tidal Wave
+            spellInfo->procCharges = 2;
+            count++;
+            break;
+        case 44544:    // Fingers of Frost
+            spellInfo->EffectSpellClassMask[0] = flag96(685904631, 1151048, 0);
+            count++;
+            break;
+        case 74396:    // Fingers of Frost visual buff
+            spellInfo->procCharges = 2;
+            spellInfo->StackAmount = 0;
+            count++;
+            break;
+        case 28200:    // Ascendance (Talisman of Ascendance trinket)
+            spellInfo->procCharges = 6;
+            count++;
+            break;
+        case 47201:    // Everlasting Affliction
+        case 47202:
+        case 47203:
+        case 47204:
+        case 47205:
+            // add corruption to affected spells
+            spellInfo->EffectSpellClassMask[1][0] |= 2;
+            count++;
+            break;
+        case 51852:    // The Eye of Acherus (no spawn in phase 2 in db)
+            spellInfo->EffectMiscValue[0] |= 1;
+            count++;
+            break;
+        case 52025:    // Cleansing Totem Effect
+            spellInfo->EffectDieSides[1] = 1;
+            count++;
+            break;
+        case 51904:     // Summon Ghouls On Scarlet Crusade (core does not know the triggered spell is summon spell)
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
+            count++;
+            break;
+        case 29809:     // Desecration Arm - 36 instead of 37 - typo? :/
+            spellInfo->EffectRadiusIndex[0] = 37;
+            count++;
+            break;
+        // Master Shapeshifter: missing stance data for forms other than bear - bear version has correct data
+        // To prevent aura staying on target after talent unlearned
+        case 48420:
+            spellInfo->Stances = 1 << (FORM_CAT - 1);
+            count++;
+            break;
+        case 48421:
+            spellInfo->Stances = 1 << (FORM_MOONKIN - 1);
+            count++;
+            break;
+        case 48422:
+            spellInfo->Stances = 1 << (FORM_TREE - 1);
+            count++;
+            break;
+        case 30421:     // Nether Portal - Perseverence
+            spellInfo->EffectBasePoints[2] += 30000;
+            count++;
+            break;
+        // some dummy spell only has dest, should push caster in this case
+        case 62324: // Throw Passenger
+            spellInfo->Targets |= TARGET_FLAG_UNIT_CASTER;
+            count++;
+            break;
+        case 51735: // Ebon Plague
+        case 51734:
+        case 51726:
+            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS;
+            spellInfo->SpellFamilyFlags[2] = 0x10;
+            count++;
+            break;
+        case 41013:     // Parasitic Shadowfiend Passive
+            spellInfo->EffectApplyAuraName[0] = 4; // proc debuff, and summon infinite fiends
+            count++;
+            break;
+        case 27892:     // To Anchor 1
+        case 27928:     // To Anchor 1
+        case 27935:     // To Anchor 1
+        case 27915:     // Anchor to Skulls
+        case 27931:     // Anchor to Skulls
+        case 27937:     // Anchor to Skulls
+            spellInfo->rangeIndex = 13;
+            count++;
+            break;
+        case 48743: // Death Pact
+            spellInfo->AttributesEx &= ~SPELL_ATTR_EX_CANT_TARGET_SELF;
+            count++;
+            break;
+        // target allys instead of enemies, target A is src_caster, spells with effect like that have ally target
+        // this is the only known exception, probably just wrong data
+        case 29214: // Wrath of the Plaguebringer
+        case 54836: // Wrath of the Plaguebringer
+            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_AREA_ALLY_SRC;
+            spellInfo->EffectImplicitTargetB[1] = TARGET_UNIT_AREA_ALLY_SRC;
+            count++;
+            break;
+        case 31687: // Summon Water Elemental
+            // 322-330 switch - effect changed to dummy, target entry not changed in client:(
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
+            count++;
+            break;
+        case 25771: // Forbearance - wrong mechanic immunity in DBC since 3.0.x
+            spellInfo->EffectMiscValue[0] = MECHANIC_IMMUNE_SHIELD;
+            count++;
+            break;
+        case 64321: // Potent Pheromones
+            // spell should dispel area aura, but doesn't have the attribute
+            // may be db data bug, or blizz may keep reapplying area auras every update with checking immunity
+            // that will be clear if we get more spells with problem like this
+            spellInfo->AttributesEx |= SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY;
+            count++;
+            break;
+        case 69055:     // Saber Lash
+        case 70814:     // Saber Lash
+            spellInfo->EffectRadiusIndex[0] = 8;
+            count++;
+            break;
+        case 69075:     // Bone Storm
+        case 70834:     // Bone Storm
+        case 70835:     // Bone Storm
+        case 70836:     // Bone Storm
+            spellInfo->EffectRadiusIndex[0] = 12;
+            count++;
+            break;
+        case 18500: // Wing Buffet
+        case 33086: // Wild Bite
+        case 49749: // Piercing Blow
+        case 52890: // Penetrating Strike
+        case 53454: // Impale
+        case 59446: // Impale
+        case 62383: // Shatter
+        case 64777: // Machine Gun
+        case 65239: // Machine Gun
+        case 65919: // Impale
+        case 67858: // Impale
+        case 67859: // Impale
+        case 67860: // Impale
+        case 69293: // Wing Buffet
+        case 74439: // Machine Gun
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_IGNORE_ARMOR;
+            count++;
+            break;
+        // THESE SPELLS ARE WORKING CORRECTLY EVEN WITHOUT THIS HACK
+        // THE ONLY REASON ITS HERE IS THAT CURRENT GRID SYSTEM
+        // DOES NOT ALLOW FAR OBJECT SELECTION (dist > 333)
+        case 70781: // Light's Hammer Teleport
+        case 70856: // Oratory of the Damned Teleport
+        case 70857: // Rampart of Skulls Teleport
+        case 70858: // Deathbringer's Rise Teleport
+        case 70859: // Upper Spire Teleport
+        case 70860: // Frozen Throne Teleport
+        case 70861: // Sindragosa's Lair Teleport
+            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_DB;
+            count++;
+            break;
+        case 63675: // Improved Devouring Plague
+            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_NO_DONE_BONUS;
+            count++;
+            break;
+        case 53241: // Marked for Death (Rank 1)
+        case 53243: // Marked for Death (Rank 2)
+        case 53244: // Marked for Death (Rank 3)
+        case 53245: // Marked for Death (Rank 4)
+        case 53246: // Marked for Death (Rank 5)
+            spellInfo->EffectSpellClassMask[0] = flag96(423937, 276955137, 2049);
+            count++;
+            break;
 			case 70728: // Exploit Weakness
             spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
             spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_PET;
             count++;
             break;
-
-        default:
-            break;
-        }
-
-        switch(spellInfo->SpellFamilyName)
-        {
-            case SPELLFAMILY_WARRIOR:
-                // Shout
-                if (spellInfo->SpellFamilyFlags[0] & 0x20000 || spellInfo->SpellFamilyFlags[1] & 0x20)
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
-                else
-                    break;
-                count++;
-                break;
-            case SPELLFAMILY_DRUID:
-                // Starfall Target Selection
-                if (spellInfo->SpellFamilyFlags[2] & 0x100)
-                    spellInfo->MaxAffectedTargets = 2;
-                // Starfall AOE Damage
-                else if (spellInfo->SpellFamilyFlags[2] & 0x800000)
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
-                // Roar
-                else if (spellInfo->SpellFamilyFlags[0] & 0x8)
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
-                else
-                    break;
-                count++;
-                break;
-                // Do not allow Deadly throw and Slice and Dice to proc twice
-            case SPELLFAMILY_ROGUE:
-                if (spellInfo->SpellFamilyFlags[1] & 0x1 || spellInfo->SpellFamilyFlags[0] & 0x40000)
-                    spellInfo->AttributesEx4 |= SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST;
-                else
-                    break;
-                count++;
-                break;
-        }
-    }
-
-    SummonPropertiesEntry *properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(121));
-    properties->Type = SUMMON_TYPE_TOTEM;
-    properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(647)); // 52893
-    properties->Type = SUMMON_TYPE_TOTEM;
-
-    CreatureAI::FillAISpellInfo();
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u custom spell attributes", count);
-}
-
-// Fill custom data about enchancments
-void SpellMgr::LoadEnchantCustomAttr()
-{
-    uint32 size = sSpellItemEnchantmentStore.GetNumRows();
-    mEnchantCustomAttr.resize(size);
-
-    barGoLink bar(GetSpellStore()->GetNumRows());
-
-    uint32 count = 0;
-
-    for (uint32 i = 0; i < size; ++i)
-       mEnchantCustomAttr[i] = 0;
-
-    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
-    {
-        bar.step();
-
-        SpellEntry * spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
-        if (!spellInfo)
-            continue;
-
-        // TODO: find a better check
-        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_UNK13) || !(spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT))
-            continue;
-
-        for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            if (spellInfo->Effect[j] == SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY)
-            {
-                uint32 enchId = spellInfo->EffectMiscValue[j];
-                SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchId);
-                if (!ench)
-                    continue;
-                mEnchantCustomAttr[enchId] = true;
-                count++;
-                break;
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u custom enchant attributes", count);
-}
-
-void SpellMgr::LoadSpellLinked()
-{
-    mSpellLinkedMap.clear();    // need for reload case
-    uint32 count = 0;
-
-    //                                                0              1             2
-    QueryResult result = WorldDatabase.Query("SELECT spell_trigger, spell_effect, type FROM spell_linked_spell");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-        sLog.outString();
-        sLog.outString(">> Loaded %u linked spells", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        int32 trigger = fields[0].GetInt32();
-        int32 effect =  fields[1].GetInt32();
-        int32 type =    fields[2].GetInt32();
-
-        SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(trigger));
-        if (!spellInfo)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(trigger));
-            continue;
-        }
-        spellInfo = sSpellStore.LookupEntry(abs(effect));
-        if (!spellInfo)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(effect));
-            continue;
-        }
-
-        if (trigger > 0)
-        {
-            switch(type)
-            {
-                case 0: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_CAST; break;
-                case 1: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_HIT;  break;
-                case 2: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_AURA; break;
-            }
-        }
-        else
-        {
-            mSpellCustomAttr[-trigger] |= SPELL_ATTR_CU_LINK_REMOVE;
-        }
-
-        if (type) //we will find a better way when more types are needed
-        {
-            if (trigger > 0)
-                trigger += SPELL_LINKED_MAX_SPELLS * type;
-            else
-                trigger -= SPELL_LINKED_MAX_SPELLS * type;
-        }
-        mSpellLinkedMap[trigger].push_back(effect);
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u linked spells", count);
-}
+
+        default:
+            break;
+        }
+
+        switch(spellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_WARRIOR:
+                // Shout
+                if (spellInfo->SpellFamilyFlags[0] & 0x20000 || spellInfo->SpellFamilyFlags[1] & 0x20)
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
+                else
+                    break;
+                count++;
+                break;
+            case SPELLFAMILY_DRUID:
+                // Starfall Target Selection
+                if (spellInfo->SpellFamilyFlags[2] & 0x100)
+                    spellInfo->MaxAffectedTargets = 2;
+                // Starfall AOE Damage
+                else if (spellInfo->SpellFamilyFlags[2] & 0x800000)
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
+                // Roar
+                else if (spellInfo->SpellFamilyFlags[0] & 0x8)
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
+                else
+                    break;
+                count++;
+                break;
+                // Do not allow Deadly throw and Slice and Dice to proc twice
+            case SPELLFAMILY_ROGUE:
+                if (spellInfo->SpellFamilyFlags[1] & 0x1 || spellInfo->SpellFamilyFlags[0] & 0x40000)
+                    spellInfo->AttributesEx4 |= SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST;
+                else
+                    break;
+                count++;
+                break;
+        }
+    }
+
+    SummonPropertiesEntry *properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(121));
+    properties->Type = SUMMON_TYPE_TOTEM;
+    properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(647)); // 52893
+    properties->Type = SUMMON_TYPE_TOTEM;
+
+    CreatureAI::FillAISpellInfo();
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u custom spell attributes", count);
+}
+
+// Fill custom data about enchancments
+void SpellMgr::LoadEnchantCustomAttr()
+{
+    uint32 size = sSpellItemEnchantmentStore.GetNumRows();
+    mEnchantCustomAttr.resize(size);
+
+    barGoLink bar(GetSpellStore()->GetNumRows());
+
+    uint32 count = 0;
+
+    for (uint32 i = 0; i < size; ++i)
+       mEnchantCustomAttr[i] = 0;
+
+    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
+    {
+        bar.step();
+
+        SpellEntry * spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
+        if (!spellInfo)
+            continue;
+
+        // TODO: find a better check
+        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_UNK13) || !(spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT))
+            continue;
+
+        for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            if (spellInfo->Effect[j] == SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY)
+            {
+                uint32 enchId = spellInfo->EffectMiscValue[j];
+                SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchId);
+                if (!ench)
+                    continue;
+                mEnchantCustomAttr[enchId] = true;
+                count++;
+                break;
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u custom enchant attributes", count);
+}
+
+void SpellMgr::LoadSpellLinked()
+{
+    mSpellLinkedMap.clear();    // need for reload case
+    uint32 count = 0;
+
+    //                                                0              1             2
+    QueryResult result = WorldDatabase.Query("SELECT spell_trigger, spell_effect, type FROM spell_linked_spell");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded %u linked spells", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        int32 trigger = fields[0].GetInt32();
+        int32 effect =  fields[1].GetInt32();
+        int32 type =    fields[2].GetInt32();
+
+        SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(trigger));
+        if (!spellInfo)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(trigger));
+            continue;
+        }
+        spellInfo = sSpellStore.LookupEntry(abs(effect));
+        if (!spellInfo)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(effect));
+            continue;
+        }
+
+        if (trigger > 0)
+        {
+            switch(type)
+            {
+                case 0: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_CAST; break;
+                case 1: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_HIT;  break;
+                case 2: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_AURA; break;
+            }
+        }
+        else
+        {
+            mSpellCustomAttr[-trigger] |= SPELL_ATTR_CU_LINK_REMOVE;
+        }
+
+        if (type) //we will find a better way when more types are needed
+        {
+            if (trigger > 0)
+                trigger += SPELL_LINKED_MAX_SPELLS * type;
+            else
+                trigger -= SPELL_LINKED_MAX_SPELLS * type;
+        }
+        mSpellLinkedMap[trigger].push_back(effect);
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u linked spells", count);
+}
diff --git a/src/server/scripts/Northrend/CMakeLists.txt b/src/server/scripts/Northrend/CMakeLists.txt
--- a/src/server/scripts/Northrend/CMakeLists.txt
+++ b/src/server/scripts/Northrend/CMakeLists.txt
@@ -166,7 +166,7 @@
 
 Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
 
-Northrend/IcecrownCitadel/boss_blood_queen_lanathel.cpp
+Northrend/IcecrownCitadel/boss_blood_queen_lana_thel.cpp
 
 Northrend/IcecrownCitadel/boss_gunship_battle.cpp
 
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_deathbringer_saurfang.cpp
@@ -1,26 +1,35 @@
 /*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-enum eScriptTexts
+enum Yells
 {
+    SAY_AGGRO                       = -1631045,
+    SAY_MARK_OF_THE_FALLEN_CHAMPION = -1631046,
+    SAY_BLOOD_BEASTS                = -1631047,
+    SAY_KILL_1                      = -1631048,
+    SAY_KILL_2                      = -1631049,
+    SAY_FRENZY                      = -1631050,
+    SAY_BERSERK                     = -1631051,
+    SAY_DEATH                       = -1631052,
+
     SAY_INTRO_ALLIANCE_1            = -1631029,
     SAY_INTRO_ALLIANCE_2            = -1631030,
     SAY_INTRO_ALLIANCE_3            = -1631031,
@@ -39,16 +48,7 @@
     SAY_INTRO_HORDE_8               = -1631043,
     SAY_INTRO_HORDE_9               = -1631044,
 
-    SAY_AGGRO                       = -1631045,
-    SAY_MARK_OF_THE_FALLEN_CHAMPION = -1631046,
-    SAY_BLOOD_BEASTS                = -1631047,
-    SAY_KILL_1                      = -1631048,
-    SAY_KILL_2                      = -1631049,
-    SAY_FRENZY                      = -1631050,
-    SAY_BERSERK                     = -1631051,
-    SAY_DEATH                       = -1631052,
-
-    SAY_OUTRO_ALLIANCE_1            = -1631053, // TODO ALLIANCE OUTRO
+    SAY_OUTRO_ALLIANCE_1            = -1631053,
     SAY_OUTRO_ALLIANCE_2            = -1631054,
     SAY_OUTRO_ALLIANCE_3            = -1631055,
     SAY_OUTRO_ALLIANCE_4            = -1631056,
@@ -59,7 +59,7 @@
     SAY_OUTRO_ALLIANCE_9            = -1631061,
     SAY_OUTRO_ALLIANCE_10           = -1631062,
     SAY_OUTRO_ALLIANCE_11           = -1631063,
-    SAY_OUTRO_ALLIANCE_12           = -1631064, // kneel after WP reached
+    SAY_OUTRO_ALLIANCE_12           = -1631064,
     SAY_OUTRO_ALLIANCE_13           = -1631065,
     SAY_OUTRO_ALLIANCE_14           = -1631066,
     SAY_OUTRO_ALLIANCE_15           = -1631067,
@@ -76,1064 +76,288 @@
     SAY_OUTRO_HORDE_4               = -1631077
 };
 
-enum eSpells
+enum Spells
 {
-    // Deathbringer Saurfang
-    SPELL_ZERO_POWER                    = 72242,
-    SPELL_GRIP_OF_AGONY                 = 70572, // Intro
-    SPELL_BLOOD_LINK                    = 72178,
-    SPELL_MARK_OF_THE_FALLEN_CHAMPION_S = 72256,
-    SPELL_RUNE_OF_BLOOD_S               = 72408,
-
-    SPELL_SUMMON_BLOOD_BEAST            = 72172,
-    SPELL_SUMMON_BLOOD_BEAST_25_MAN     = 72356, // Additional cast, does not replace
-    SPELL_FRENZY                        = 72737,
-    SPELL_BLOOD_NOVA_TRIGGER            = 72378,
-    SPELL_BLOOD_NOVA                    = 72380,
-    SPELL_BLOOD_POWER                   = 72371,
-    SPELL_BLOOD_LINK_POWER              = 72195,
-    SPELL_BLOOD_LINK_DUMMY              = 72202,
-    SPELL_MARK_OF_THE_FALLEN_CHAMPION   = 72293,
-    SPELL_BOILING_BLOOD                 = 72385,
-    SPELL_RUNE_OF_BLOOD                 = 72410,
-
-    // Blood Beast
-    SPELL_BLOOD_LINK_BEAST              = 72176,
-    SPELL_RESISTANT_SKIN                = 72723,
-    SPELL_SCENT_OF_BLOOD                = 72769, // Heroic only
-
-    SPELL_RIDE_VEHICLE                  = 70640, // Outro
-    SPELL_ACHIEVEMENT                   = 72928
+    SPELL_BLOOD_LINK            = 72178,
+    SPELL_BLOOD_POWER           = 72371,
+    SPELL_SUMMON_BLOOD_BEAST_1  = 72172,
+    SPELL_SUMMON_BLOOD_BEAST_2  = 72173,
+    SPELL_SUMMON_BLOOD_BEAST_3  = 72356,
+    SPELL_SUMMON_BLOOD_BEAST_4  = 72357,
+    SPELL_SUMMON_BLOOD_BEAST_5  = 72358,
+    SPELL_FRENZY                = 72737,
+    SPELL_TASTE_OF_BLOOD        = 69634,
+    SPELL_FALLEN_CHAMPION       = 72293,
+    SPELL_FALLEN_CHAMPION_AURA  = 72256,
+    SPELL_BOILING_BLOOD         = 72385,
+    SPELL_BLOOD_NOVA            = 72378,
+    SPELL_RUNE_OF_BLOOD_AURA    = 72408,
+    SPELL_RUNE_OF_BLOOD         = 72410,
+    SPELL_BLOOD_LINK_BEAST      = 72176,
+    SPELL_RESISTAN_SKIN         = 72723,
+    SPELL_SCENT_OF_BLOOD        = 72769,
+    SPELL_AGONY                 = 70572, //saurfang event
+    SPELL_ZERO_POWER            = 72242
 };
 
-// Helper to get id of the aura on different modes (HasAura(baseId) wont work)
-#define BOILING_BLOOD_HELPER RAID_MODE<int32>(72385,72441,72442,72443)
-
-enum eEvents
-{
-    EVENT_INTRO_ALLIANCE_1      = 1,
-    EVENT_INTRO_ALLIANCE_2      = 2,
-    EVENT_INTRO_ALLIANCE_3      = 3,
-    EVENT_INTRO_ALLIANCE_4      = 4,
-    EVENT_INTRO_ALLIANCE_5      = 5,
-    EVENT_INTRO_ALLIANCE_6      = 6,
-    EVENT_INTRO_ALLIANCE_7      = 7,
-
-    EVENT_INTRO_HORDE_1         = 8,
-    EVENT_INTRO_HORDE_2         = 9,
-    EVENT_INTRO_HORDE_3         = 10,
-    EVENT_INTRO_HORDE_4         = 11,
-    EVENT_INTRO_HORDE_5         = 12,
-    EVENT_INTRO_HORDE_6         = 13,
-    EVENT_INTRO_HORDE_7         = 14,
-    EVENT_INTRO_HORDE_8         = 15,
-    EVENT_INTRO_HORDE_9         = 16,
-
-    EVENT_INTRO_FINISH          = 17,
-
-    EVENT_BERSERK               = 18,
-    EVENT_SUMMON_BLOOD_BEAST    = 19,
-    EVENT_BOILING_BLOOD         = 20,
-    EVENT_BLOOD_NOVA            = 21,
-    EVENT_RUNE_OF_BLOOD         = 22,
-
-    EVENT_OUTRO_ALLIANCE_1      = 23,
-    EVENT_OUTRO_ALLIANCE_2      = 24,
-    EVENT_OUTRO_ALLIANCE_3      = 25,
-    EVENT_OUTRO_ALLIANCE_4      = 26,
-    EVENT_OUTRO_ALLIANCE_5      = 27,
-    EVENT_OUTRO_ALLIANCE_6      = 28,
-    EVENT_OUTRO_ALLIANCE_7      = 29,
-    EVENT_OUTRO_ALLIANCE_8      = 30,
-    EVENT_OUTRO_ALLIANCE_9      = 31,
-    EVENT_OUTRO_ALLIANCE_10     = 32,
-    EVENT_OUTRO_ALLIANCE_11     = 33,
-    EVENT_OUTRO_ALLIANCE_12     = 34,
-    EVENT_OUTRO_ALLIANCE_13     = 35,
-    EVENT_OUTRO_ALLIANCE_14     = 36,
-    EVENT_OUTRO_ALLIANCE_15     = 37,
-    EVENT_OUTRO_ALLIANCE_16     = 38,
-    EVENT_OUTRO_ALLIANCE_17     = 39,
-    EVENT_OUTRO_ALLIANCE_18     = 40,
-    EVENT_OUTRO_ALLIANCE_19     = 41,
-    EVENT_OUTRO_ALLIANCE_20     = 42,
-    EVENT_OUTRO_ALLIANCE_21     = 43,
-
-    EVENT_OUTRO_HORDE_1         = 44,
-    EVENT_OUTRO_HORDE_2         = 45,
-    EVENT_OUTRO_HORDE_3         = 46,
-    EVENT_OUTRO_HORDE_4         = 47,
-    EVENT_OUTRO_HORDE_5         = 48,
-    EVENT_OUTRO_HORDE_6         = 49,
-    EVENT_OUTRO_HORDE_7         = 50,
-    EVENT_OUTRO_HORDE_8         = 51
-};
-
-enum ePhases
-{
-    PHASE_INTRO_A       = 1,
-    PHASE_INTRO_H       = 2,
-    PHASE_COMBAT        = 3,
-
-    PHASE_INTRO_MASK    = (1 << PHASE_INTRO_A) | (1 << PHASE_INTRO_H),
-};
-
-enum eActions
-{
-    ACTION_START_EVENT                  = -3781300,
-    ACTION_CONTINUE_INTRO               = -3781301,
-    ACTION_CHARGE                       = -3781302,
-    ACTION_START_OUTRO                  = -3781303,
-    ACTION_DESPAWN                      = -3781304,
-    ACTION_MARK_OF_THE_FALLEN_CHAMPION  = -72293,
-};
-
-#define DATA_MADE_A_MESS 45374613 // 4537, 4613 are achievement IDs
-
-enum eMovePoints
-{
-    POINT_SAURFANG          = 3781300,
-    POINT_FIRST_STEP        = 3781301,
-    POINT_CHARGE            = 3781302,
-    POINT_CHOKE             = 3781303,
-    POINT_CORPSE            = 3781304,
-    POINT_FINAL             = 3781305
-};
-
-static const Position deathbringerPos = {-496.3542f, 2211.33f, 541.1138f, 0.0f};
-static const Position firstStepPos = {-541.3177f, 2211.365f, 539.2921f, 0.0f};
-
-static const Position chargePos[6] =
-{
-    {-509.6505f, 2211.377f, 539.2872f, 0.0f}, // High Overlord Saurfang/Muradin Bronzebeard
-    {-508.7480f, 2211.897f, 539.2870f, 0.0f}, // front left
-    {-509.2929f, 2211.411f, 539.2870f, 0.0f}, // front right
-    {-506.6607f, 2211.367f, 539.2870f, 0.0f}, // back middle
-    {-506.1137f, 2213.306f, 539.2870f, 0.0f}, // back left
-    {-509.0040f, 2211.743f, 539.2870f, 0.0f}  // back right
-};
-
-static const Position chokePos[6] =
-{
-    {-514.4834f, 2211.334f, 549.2887f, 0.0f}, // High Overlord Saurfang/Muradin Bronzebeard
-    {-510.1081f, 2211.592f, 546.3773f, 0.0f}, // front left
-    {-513.3210f, 2211.396f, 551.2882f, 0.0f}, // front right
-    {-507.3684f, 2210.353f, 545.7497f, 0.0f}, // back middle
-    {-507.0486f, 2212.999f, 545.5512f, 0.0f}, // back left
-    {-510.7041f, 2211.069f, 546.5298f, 0.0f}  // back right
-};
-
-static const Position finalPos = {-563.7552f, 2211.328f, 538.7848f, 0.0f};
-
-class boss_deathbringer_saurfang : public CreatureScript
+class boss_saurfang : public CreatureScript
 {
     public:
-        boss_deathbringer_saurfang() : CreatureScript("boss_deathbringer_saurfang") { }
+        boss_saurfang() : CreatureScript("boss_saurfang") { }
 
-        struct boss_deathbringer_saurfangAI : public BossAI
+        struct boss_saurfangAI : public BossAI
         {
-            boss_deathbringer_saurfangAI(Creature* pCreature) : BossAI(pCreature, DATA_DEATHBRINGER_SAURFANG)
+            boss_saurfangAI(Creature* pCreature) : BossAI(pCreature, DATA_SAURFANG_EVENT), vehicle(pCreature->GetVehicleKit())
             {
-                ASSERT(instance);
-                ASSERT(pCreature->GetVehicleKit()); // we dont actually use it, just check if exists
-                bIntroDone = false;
-                uiFallenChampionCount = 0;
+                pInstance = me->GetInstanceScript();
+                assert(vehicle);
+                bFrenzy = false;
+                me->CastSpell(me, SPELL_ZERO_POWER, true);
+                me->SetPower(me->getPowerType(), 0);
+                m_uiAchievementCount = RAID_MODE(3,5,3,5);
             }
 
             void Reset()
             {
-                events.Reset();
-                events.SetPhase(PHASE_COMBAT);
-                bFrenzy = false;
-                me->SetPower(POWER_ENERGY, 0);
-                DoCast(me, SPELL_ZERO_POWER, true);
-                DoCast(me, SPELL_BLOOD_LINK, true);
-                DoCast(me, SPELL_MARK_OF_THE_FALLEN_CHAMPION_S, true);
-                DoCast(me, SPELL_RUNE_OF_BLOOD_S, true);
-                me->RemoveAurasDueToSpell(SPELL_BERSERK);
-                me->RemoveAurasDueToSpell(SPELL_FRENZY);
-                me->RemoveAurasDueToSpell(SPELL_BLOOD_POWER);
-                summons.DespawnAll();
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, NOT_STARTED);
+                m_uiBoilingBloodTimer = 25000;
+                m_uiBloodNovaTimer = 30000;
+                m_uiRuneOfBloodTimer = 20000;
+                m_uiSummonBloodBeastTimer = 40000;
+                m_uiBerserkTimer = 480000;
+
+                m_uiMessCount = 0;
+
+                me->GetVehicleKit();
+
+                if (pInstance && me->isAlive())
+                    pInstance->SetData(DATA_SAURFANG_EVENT, NOT_STARTED);
             }
 
-            void EnterCombat(Unit* /*who*/)
+            void EnterCombat(Unit* /*pWho*/)
             {
+
                 DoScriptText(SAY_AGGRO, me);
-                events.ScheduleEvent(EVENT_SUMMON_BLOOD_BEAST, 30000, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_BERSERK, 480000, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_BOILING_BLOOD, 15500, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_BLOOD_NOVA, 17000, 0, PHASE_COMBAT);
-                events.ScheduleEvent(EVENT_RUNE_OF_BLOOD, 20000, 0, PHASE_COMBAT);
 
-                uiFallenChampionCount = 0;
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, IN_PROGRESS);
+                DoCast(me, SPELL_BLOOD_LINK, true);
+                DoCast(me, SPELL_BLOOD_POWER, true);
+                DoCast(me, SPELL_FALLEN_CHAMPION_AURA, true);
+                DoCast(me, SPELL_RUNE_OF_BLOOD_AURA, true);
+
+                if (pInstance)
+                    pInstance->SetData(DATA_SAURFANG_EVENT, IN_PROGRESS);
             }
 
-            void JustDied(Unit* /*killer*/)
+            void JustDied(Unit* /*pKiller*/)
             {
-                DoCastAOE(SPELL_ACHIEVEMENT, true);
+                if (!pInstance)
+                    return;
+
                 DoScriptText(SAY_DEATH, me);
 
-                instance->DoRemoveAurasDueToSpellOnPlayers(SPELL_MARK_OF_THE_FALLEN_CHAMPION);
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, DONE);
-                if (Creature* creature = ObjectAccessor::GetCreature(*me, instance->GetData64(DATA_SAURFANG_EVENT_NPC)))
-                    creature->AI()->DoAction(ACTION_START_OUTRO);
-            }
+                pInstance->SetData(DATA_SAURFANG_EVENT, DONE);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_FALLEN_CHAMPION);
+                me->RemoveAurasDueToSpell(SPELL_FALLEN_CHAMPION_AURA);
+                me->RemoveAurasDueToSpell(SPELL_RUNE_OF_BLOOD_AURA);
+                me->SetPower(me->getPowerType(), 0);
 
-            void MoveInLineOfSight(Unit* /*who*/)
-            {
-                // not calling CreatureAI::MoveInLineOfSight to prevent entering combat
-            }
+                if(m_uiMessCount < m_uiAchievementCount)
+                    pInstance->DoCompleteAchievement(RAID_MODE(ACHIEV_MESS_10, ACHIEV_MESS_25));
 
-            void AttackStart(Unit* victim)
-            {
-                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
-                    return;
-
-                ScriptedAI::AttackStart(victim);
-            }
-
-            void EnterEvadeMode()
-            {
-                ScriptedAI::EnterEvadeMode();
-                if (bIntroDone)
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
             }
 
             void JustReachedHome()
             {
-                instance->SetBossState(DATA_DEATHBRINGER_SAURFANG, FAIL);
+                if (!pInstance)
+                    return;
+
+                pInstance->SetData(DATA_SAURFANG_EVENT, FAIL);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_FALLEN_CHAMPION);
+                me->RemoveAurasDueToSpell(SPELL_BLOOD_LINK);
+                me->RemoveAurasDueToSpell(SPELL_BLOOD_POWER);
+                me->RemoveAurasDueToSpell(SPELL_FALLEN_CHAMPION_AURA);
+                me->RemoveAurasDueToSpell(SPELL_RUNE_OF_BLOOD_AURA);
             }
 
-            void KilledUnit(Unit *victim)
+            void KilledUnit(Unit* victim)
             {
                 if (victim->GetTypeId() == TYPEID_PLAYER)
-                    DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
-            }
-
-            void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/)
-            {
-                if (!bFrenzy && HealthBelowPct(31)) // AT 30%, not below
                 {
-                    bFrenzy = true;
-                    DoCast(me, SPELL_FRENZY);
-                    DoScriptText(SAY_FRENZY, me);
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
                 }
             }
 
             void JustSummoned(Creature* summon)
             {
-                if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1))
-                    summon->AI()->AttackStart(pTarget);
-
-                if (IsHeroic())
-                    DoCast(summon, SPELL_SCENT_OF_BLOOD);
-
-                summon->AI()->DoCast(summon, SPELL_BLOOD_LINK_BEAST, true);
-                summon->AI()->DoCast(summon, SPELL_RESISTANT_SKIN, true);
-                summons.Summon(summon);
-            }
-
-            void SummonedCreatureDespawn(Creature* summon)
-            {
-                summons.Despawn(summon);
-            }
-
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE && id != POINT_SAURFANG)
-                    return;
-
-                instance->HandleGameObject(instance->GetData64(GO_SAURFANG_S_DOOR), false);
-            }
-
-            void SpellHitTarget(Unit* target, const SpellEntry* spell)
-            {
-                switch (spell->Id)
+                float x, y, z;
+                if(Unit* pTarget = SelectUnit(SELECT_TARGET_FARTHEST, 0))
                 {
-                    case SPELL_MARK_OF_THE_FALLEN_CHAMPION:
-                        DoScriptText(SAY_MARK_OF_THE_FALLEN_CHAMPION, me);
-                        break;
-                    case 72255: // Mark of the Fallen Champion, triggered id
-                    case 72444:
-                    case 72445:
-                    case 72446:
-                        if (me->GetPower(POWER_ENERGY) != me->GetMaxPower(POWER_ENERGY))
-                            target->CastCustomSpell(SPELL_BLOOD_LINK_DUMMY, SPELLVALUE_BASE_POINT0, 1, me, true);
-                        break;
-                    default:
-                        break;
+                    pTarget->GetPosition(x, y, z);
+                    summon->AddThreat(pTarget, 50000.0f);
+                    summon->GetMotionMaster()->MovePoint(0, x, y, z);
                 }
             }
 
-            void UpdateAI(const uint32 diff)
+            void UpdateAI(const uint32 uiDiff)
             {
-                if (!UpdateVictim() && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
+                if(!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                if (m_uiBoilingBloodTimer < uiDiff)
+                {
+                    if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                    {
+                        DoCast(pTarget, SPELL_BOILING_BLOOD);
+                        m_uiBoilingBloodTimer = 25000;
+                    }
+                } else m_uiBoilingBloodTimer -= uiDiff;
 
-                if (me->hasUnitState(UNIT_STAT_CASTING))
-                    return;
+                if (m_uiBloodNovaTimer < uiDiff)
+                {
+                    uint32 count = RAID_MODE(1,3,1,3);
+                    for (uint8 i = 1; i <= count; i++)
+                    {
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                        {
+                            DoCast(pTarget, SPELL_BLOOD_NOVA);
+                            m_uiBloodNovaTimer = 30000;
+                        }
+                    }
+                } else m_uiBloodNovaTimer -= uiDiff;
 
-                while (uint32 eventId = events.ExecuteEvent())
+                if (m_uiSummonBloodBeastTimer <= uiDiff)
                 {
-                    switch (eventId)
+                    if (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL || getDifficulty() == RAID_DIFFICULTY_10MAN_HEROIC)
                     {
-                        case EVENT_INTRO_ALLIANCE_2:
-                            DoScriptText(SAY_INTRO_ALLIANCE_2, me);
-                            break;
-                        case EVENT_INTRO_ALLIANCE_3:
-                            DoScriptText(SAY_INTRO_ALLIANCE_3, me);
-                            break;
-                        case EVENT_INTRO_ALLIANCE_6:
-                            DoScriptText(SAY_INTRO_ALLIANCE_6, me);
-                            DoScriptText(SAY_INTRO_ALLIANCE_7, me);
-                            DoCast(me, SPELL_GRIP_OF_AGONY);
-                            break;
-                        case EVENT_INTRO_HORDE_2:
-                            DoScriptText(SAY_INTRO_HORDE_2, me);
-                            break;
-                        case EVENT_INTRO_HORDE_4:
-                            DoScriptText(SAY_INTRO_HORDE_4, me);
-                            break;
-                        case EVENT_INTRO_HORDE_9:
-                            DoCast(me, SPELL_GRIP_OF_AGONY);
-                            DoScriptText(SAY_INTRO_HORDE_9, me);
-                            break;
-                        case EVENT_INTRO_FINISH:
-                            events.SetPhase(PHASE_COMBAT);
-                            bIntroDone = true;
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
-                            break;
-                        case EVENT_SUMMON_BLOOD_BEAST:
-                            for (uint8 i10 = 0; i10 < 2; ++i10)
-                                DoCast(me, SPELL_SUMMON_BLOOD_BEAST+i10);
-                            if (Is25ManRaid())
-                                for (uint8 i25 = 0; i25 < 3; ++i25)
-                                    DoCast(me, SPELL_SUMMON_BLOOD_BEAST_25_MAN+i25);
-                            DoScriptText(SAY_BLOOD_BEASTS, me);
-                            events.ScheduleEvent(EVENT_SUMMON_BLOOD_BEAST, 40000, 0, PHASE_COMBAT);
-                            break;
-                        case EVENT_BLOOD_NOVA:
-                        {
-                            // select at range only
-                            Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, -10.0f, true);
-                            if (!target)
-                                target = SelectTarget(SELECT_TARGET_RANDOM, 1, 10.0f, true);    // noone? select melee
-                            if (target)
-                                DoCast(target, SPELL_BLOOD_NOVA_TRIGGER);
-                            events.ScheduleEvent(EVENT_BLOOD_NOVA, urand(20000, 25000), 0, PHASE_COMBAT);
-                            break;
-                        }
-                        case EVENT_RUNE_OF_BLOOD:
-                            DoCastVictim(SPELL_RUNE_OF_BLOOD);
-                            events.ScheduleEvent(EVENT_RUNE_OF_BLOOD, urand(20000, 25000), 0, PHASE_COMBAT);
-                            break;
-                        case EVENT_BOILING_BLOOD:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -BOILING_BLOOD_HELPER))
-                                DoCast(target, SPELL_BOILING_BLOOD);
-                            events.ScheduleEvent(EVENT_BOILING_BLOOD, urand(15000, 20000), 0, PHASE_COMBAT);
-                            break;
-                        case EVENT_BERSERK:
-                            DoCast(me, SPELL_BERSERK);
-                            DoScriptText(SAY_BERSERK, me);
-                            break;
-                        default:
-                            break;
+                        DoCast(me, SPELL_SUMMON_BLOOD_BEAST_1);
+                        DoCast(me, SPELL_SUMMON_BLOOD_BEAST_2);
+                    }
+                    else
+                    {
+                        DoCast(me, SPELL_SUMMON_BLOOD_BEAST_1);
+                        DoCast(me, SPELL_SUMMON_BLOOD_BEAST_2);
+                        DoCast(me, SPELL_SUMMON_BLOOD_BEAST_3);
+                        DoCast(me, SPELL_SUMMON_BLOOD_BEAST_4);
+                        DoCast(me, SPELL_SUMMON_BLOOD_BEAST_5);
+                    }
+                    DoScriptText(SAY_BLOOD_BEASTS, me);
+                    m_uiSummonBloodBeastTimer = 40000;
+                } else m_uiSummonBloodBeastTimer -= uiDiff;
+
+                if (me->GetPower(POWER_ENERGY) > 99)
+                {
+                    Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1);
+
+                    if(pTarget && !pTarget->HasAura(SPELL_FALLEN_CHAMPION))
+                    {
+                        DoCast(pTarget, SPELL_FALLEN_CHAMPION);
+                        DoScriptText(SAY_MARK_OF_THE_FALLEN_CHAMPION, me);
+                        me->SetPower(me->getPowerType(), 0);
+                        ++m_uiMessCount;
                     }
                 }
 
+                if (m_uiRuneOfBloodTimer < uiDiff)
+                {
+                    DoCast(me->getVictim(), SPELL_RUNE_OF_BLOOD);
+                    m_uiRuneOfBloodTimer = 20000;
+                } else m_uiRuneOfBloodTimer -= uiDiff;
+
+                if(me->GetHealth()*100 / me->GetMaxHealth() < 31)
+                {
+                    if (!bFrenzy)
+                    {
+                        DoCast(me, SPELL_FRENZY);
+                        DoScriptText(SAY_FRENZY, me);
+                        bFrenzy = true;
+                    }
+                }
+
+                if (m_uiBerserkTimer < uiDiff)
+                {
+                    DoCast(SPELL_BERSERK);
+                    DoScriptText(SAY_BERSERK, me);
+                    m_uiBerserkTimer = 480000;
+                } else m_uiBerserkTimer -= uiDiff;
+
                 DoMeleeAttackIfReady();
             }
 
-            uint32 GetData(uint32 type)
-            {
-                if (type == DATA_MADE_A_MESS)
-                    if (uiFallenChampionCount < RAID_MODE<uint32>(3, 5, 3, 5))
-                        return 1;
+        private:
+            InstanceScript* pInstance;
 
-                return 0;
-            }
+            Vehicle* vehicle;
 
-            // intro setup
-            void DoAction(const int32 action)
-            {
-                if (action == PHASE_INTRO_A || action == PHASE_INTRO_H)
-                {
-                    if (GameObject* teleporter = GameObject::GetGameObject(*me, instance->GetData64(GO_SCOURGE_TRANSPORTER_SAURFANG)))
-                    {
-                        instance->HandleGameObject(0, false, teleporter);
-                        teleporter->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-                    }
+            uint32 m_uiBoilingBloodTimer;
+            uint32 m_uiBloodNovaTimer;
+            uint32 m_uiRuneOfBloodTimer;
+            uint32 m_uiSummonBloodBeastTimer;
+            uint32 m_uiBerserkTimer;
 
-                    me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                    // controls what events will execute
-                    events.SetPhase(uint32(action));
+            uint8 m_uiMessCount;
+            uint8 m_uiAchievementCount;
 
-                    me->SetHomePosition(deathbringerPos.GetPositionX(), deathbringerPos.GetPositionY(), deathbringerPos.GetPositionZ(), me->GetOrientation());
-                    me->GetMotionMaster()->MovePoint(POINT_SAURFANG, deathbringerPos.GetPositionX(), deathbringerPos.GetPositionY(), deathbringerPos.GetPositionZ());
-
-                    events.ScheduleEvent(EVENT_INTRO_ALLIANCE_2, 2500, 0, PHASE_INTRO_A);
-                    events.ScheduleEvent(EVENT_INTRO_ALLIANCE_3, 20000, 0, PHASE_INTRO_A);
-
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_2, 5000, 0, PHASE_INTRO_H);
-                }
-                else if (action == ACTION_CONTINUE_INTRO)
-                {
-                    events.ScheduleEvent(EVENT_INTRO_ALLIANCE_6, 6500+500, 0, PHASE_INTRO_A);
-                    events.ScheduleEvent(EVENT_INTRO_FINISH, 8000, 0, PHASE_INTRO_A);
-
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_4, 6500, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_9, 46700+1000+500, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_FINISH,  46700+1000+8000, 0, PHASE_INTRO_H);
-                }
-                else if (action == ACTION_MARK_OF_THE_FALLEN_CHAMPION)
-                {
-                    if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true, -SPELL_MARK_OF_THE_FALLEN_CHAMPION))
-                    {
-                        ++uiFallenChampionCount;
-                        me->RemoveAurasDueToSpell(SPELL_BLOOD_POWER);
-                        DoCast(target, SPELL_MARK_OF_THE_FALLEN_CHAMPION);
-                        me->SetPower(POWER_ENERGY, 0);
-                    }
-                }
-                else
-                    ASSERT(false);
-            }
-
-        private:
-            bool bIntroDone;
-            bool bFrenzy;   // faster than iterating all auras to find Frenzy
-            uint32 uiFallenChampionCount;
+            bool bFrenzy;
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new boss_deathbringer_saurfangAI(pCreature);
+            return new boss_saurfangAI(pCreature);
         }
 };
 
-class npc_high_overlord_saurfang_icc : public CreatureScript
+class npc_bloodbeast : public CreatureScript
 {
     public:
-        npc_high_overlord_saurfang_icc() : CreatureScript("npc_high_overlord_saurfang_icc") { }
+        npc_bloodbeast() : CreatureScript("npc_bloodbeast") { }
 
-        struct npc_high_overlord_saurfangAI : public ScriptedAI
+        struct npc_bloodbeastAI : public ScriptedAI
         {
-            npc_high_overlord_saurfangAI(Creature* pCreature) : ScriptedAI(pCreature), vehicle(pCreature->GetVehicleKit())
+            npc_bloodbeastAI(Creature* pCreature) : ScriptedAI(pCreature)
             {
-                ASSERT(vehicle);
-                pInstance = me->GetInstanceScript();
+                pInstance = pCreature->GetInstanceScript();
             }
 
             void Reset()
             {
-                events.Reset();
+                DoCast(me, SPELL_BLOOD_LINK_BEAST, true);
+                DoCast(me, SPELL_RESISTAN_SKIN, true);
+
+                if (IsHeroic())
+                    DoCast(me, SPELL_SCENT_OF_BLOOD);
             }
 
-            void DoAction(const int32 action)
+            void EnterCombat(Unit* /*pWho*/) { }
+
+            void KilledUnit(Unit* /*pVictim*/)
             {
-                if (action == ACTION_START_EVENT)
+                Creature* Saurfang = me->GetCreature(*me, pInstance->GetData64(DATA_SAURFANG));
+                if (Saurfang && Saurfang->isAlive())
                 {
-                    // Prevent crashes
-                    if (events.GetPhaseMask() & PHASE_INTRO_MASK)
-                        return;
-
-                    GetCreatureListWithEntryInGrid(guardList, me, NPC_SE_KOR_KRON_REAVER, 20.0f);
-                    guardList.sort(Trinity::ObjectDistanceOrderPred(me));
-                    uint32 x = 1;
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++x, ++itr)
-                        (*itr)->AI()->SetData(0, x);
-
-                    me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                    DoScriptText(SAY_INTRO_HORDE_1, me);
-                    events.SetPhase(PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_3, 18500, 0, PHASE_INTRO_H);
-                    if (pInstance)
-                    {
-                        uiDeathbringerSaurfangGUID = pInstance->GetData64(DATA_DEATHBRINGER_SAURFANG);
-                        pInstance->HandleGameObject(pInstance->GetData64(GO_SAURFANG_S_DOOR), true);
-                    }
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                        deathbringer->AI()->DoAction(PHASE_INTRO_H);
-                }
-                else if (action == ACTION_START_OUTRO)
-                {
-                    me->RemoveAurasDueToSpell(SPELL_GRIP_OF_AGONY);
-                    DoScriptText(SAY_OUTRO_HORDE_1, me);
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_2, 10000);   // say
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_3, 18000);   // say
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_4, 24000);   // cast
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_5, 30000);   // move
-                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->SendMovementFlagUpdate();
-                    me->Relocate(me->GetPositionX(), me->GetPositionY(), 539.2917f);
-                    me->SendMonsterMove(me->GetPositionX(), me->GetPositionY(), 539.2917f, SPLINEFLAG_FALLING, 0, 0.0f);
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                        (*itr)->AI()->DoAction(ACTION_DESPAWN);
+                    Saurfang->ModifyHealth(uint32(Saurfang->GetMaxHealth() * 0.05));
                 }
             }
 
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
+            void UpdateAI(const uint32 /*uiDiff*/)
             {
-                if (spell->Id == SPELL_GRIP_OF_AGONY)
-                {
-                    me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->GetMotionMaster()->MovePoint(POINT_CHOKE, chokePos[0]);
-                }
+                DoMeleeAttackIfReady();
             }
 
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE)
-                    return;
-
-                if (id == POINT_FIRST_STEP)
-                {
-                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                    DoScriptText(SAY_INTRO_HORDE_3, me);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_5, 15500, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_6, 29500, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_7, 43800, 0, PHASE_INTRO_H);
-                    events.ScheduleEvent(EVENT_INTRO_HORDE_8, 47000, 0, PHASE_INTRO_H);
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                        deathbringer->AI()->DoAction(ACTION_CONTINUE_INTRO);
-                }
-                //else if (id == EVENT_FALL_GROUND)
-                //    me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                else if (id == POINT_CORPSE)
-                {
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                    {
-                        deathbringer->CastSpell(me, SPELL_RIDE_VEHICLE, true);  // for the packet logs.
-                        deathbringer->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                        deathbringer->setDeathState(ALIVE);
-                        deathbringer->EnterVehicle(vehicle, 0);
-                    }
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_5, 1000);    // move
-                    events.ScheduleEvent(EVENT_OUTRO_HORDE_6, 4000);    // say
-                }
-                else if (id == POINT_FINAL)
-                {
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                        deathbringer->ForcedDespawn();
-                    me->ForcedDespawn();
-                }
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                events.Update(diff);
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_INTRO_HORDE_3:
-                            me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                            me->GetMotionMaster()->MovePoint(POINT_FIRST_STEP, firstStepPos.GetPositionX(), firstStepPos.GetPositionY(), firstStepPos.GetPositionZ());
-                            break;
-                        case EVENT_INTRO_HORDE_5:
-                            DoScriptText(SAY_INTRO_HORDE_5, me);
-                            break;
-                        case EVENT_INTRO_HORDE_6:
-                            DoScriptText(SAY_INTRO_HORDE_6, me);
-                            break;
-                        case EVENT_INTRO_HORDE_7:
-                            DoScriptText(SAY_INTRO_HORDE_7, me);
-                            break;
-                        case EVENT_INTRO_HORDE_8:
-                            DoScriptText(SAY_INTRO_HORDE_8, me);
-                            for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                                (*itr)->AI()->DoAction(ACTION_CHARGE);
-                            me->GetMotionMaster()->MoveCharge(chargePos[0].GetPositionX(), chargePos[0].GetPositionY(), chargePos[0].GetPositionZ(), 8.5f, POINT_CHARGE);
-                            break;
-                        case EVENT_OUTRO_HORDE_2:   // say
-                            if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                                me->SetFacingToObject(deathbringer);
-                            DoScriptText(SAY_OUTRO_HORDE_2, me);
-                            break;
-                        case EVENT_OUTRO_HORDE_3:   // say
-                            DoScriptText(SAY_OUTRO_HORDE_3, me);
-                            break;
-                        case EVENT_OUTRO_HORDE_4:   // move
-                            if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                            {
-                                float x, y, z;
-                                deathbringer->GetClosePoint(x, y, z, deathbringer->GetObjectSize());
-                                me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                                me->GetMotionMaster()->MovePoint(POINT_CORPSE ,x, y, z);
-                            }
-                            break;
-                        case EVENT_OUTRO_HORDE_5:   // move
-                            me->GetMotionMaster()->MovePoint(POINT_FINAL, finalPos);
-                            break;
-                        case EVENT_OUTRO_HORDE_6:   // say
-                            DoScriptText(SAY_OUTRO_HORDE_4, me);
-                            break;
-                    }
-                }
-            }
-
-        private:
-            EventMap events;
-            InstanceScript* pInstance;
-            Vehicle* vehicle;
-            uint64 uiDeathbringerSaurfangGUID;
-            std::list<Creature*> guardList;
-        };
-
-        bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-        {
-            if (pCreature->GetPositionZ() < 530.0f)
-                return false;
-
-            InstanceScript* pInstance = pCreature->GetInstanceScript();
-            if (pInstance && pInstance->GetBossState(DATA_DEATHBRINGER_SAURFANG) != DONE)
-            {
-                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Let it begin...", 631, -ACTION_START_EVENT);
-                pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pCreature->GetGUID());
-            }
-
-            return true;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* pCreature, uint32 /*sender*/, uint32 action)
-        {
-            player->PlayerTalkClass->ClearMenus();
-            player->CLOSE_GOSSIP_MENU();
-            if (action == -ACTION_START_EVENT)
-                pCreature->AI()->DoAction(ACTION_START_EVENT);
-
-            return true;
-        }
-
-        CreatureAI* GetAI(Creature* pCreature) const
-        {
-            return new npc_high_overlord_saurfangAI(pCreature);
-        }
-};
-
-class npc_muradin_bronzebeard_icc : public CreatureScript
-{
-    public:
-        npc_muradin_bronzebeard_icc() : CreatureScript("npc_muradin_bronzebeard_icc") { }
-
-        struct npc_muradin_bronzebeard_iccAI : public ScriptedAI
-        {
-            npc_muradin_bronzebeard_iccAI(Creature* pCreature) : ScriptedAI(pCreature)
-            {
-                pInstance = me->GetInstanceScript();
-            }
-
-            void Reset()
-            {
-                events.Reset();
-            }
-
-            void DoAction(const int32 action)
-            {
-                if (action == ACTION_START_EVENT)
-                {
-                    // Prevent crashes
-                    if (events.GetPhaseMask() & PHASE_INTRO_MASK)
-                        return;
-
-                    events.SetPhase(PHASE_INTRO_A);
-                    GetCreatureListWithEntryInGrid(guardList, me, NPC_SE_SKYBREAKER_MARINE, 20.0f);
-                    guardList.sort(Trinity::ObjectDistanceOrderPred(me));
-                    uint32 x = 1;
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++x, ++itr)
-                        (*itr)->AI()->SetData(0, x);
-
-                    me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
-                    DoScriptText(SAY_INTRO_ALLIANCE_1, me);
-                    events.ScheduleEvent(EVENT_INTRO_ALLIANCE_4, 2500+17500+9500, 0, PHASE_INTRO_A);
-                    if (pInstance)
-                    {
-                        uiDeathbringerSaurfangGUID = pInstance->GetData64(DATA_DEATHBRINGER_SAURFANG);
-                        pInstance->HandleGameObject(pInstance->GetData64(GO_SAURFANG_S_DOOR), true);
-                    }
-                    if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                        deathbringer->AI()->DoAction(PHASE_INTRO_A);
-                }
-                else if (action == ACTION_START_OUTRO)
-                {
-                    me->RemoveAurasDueToSpell(SPELL_GRIP_OF_AGONY);
-                    DoScriptText(SAY_OUTRO_ALLIANCE_1, me);
-                    me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->SendMovementFlagUpdate();
-                    me->Relocate(me->GetPositionX(), me->GetPositionY(), 539.2917f);
-                    me->SendMonsterMove(me->GetPositionX(), me->GetPositionY(), 539.2917f, SPLINEFLAG_FALLING, 0, 0.0f);
-                    for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                        (*itr)->AI()->DoAction(ACTION_DESPAWN);
-                }
-            }
-
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_GRIP_OF_AGONY)
-                {
-                    me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->GetMotionMaster()->MovePoint(POINT_CHOKE, chokePos[0]);
-                }
-            }
-
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE || id != POINT_FIRST_STEP)
-                    return;
-
-                me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                DoScriptText(SAY_INTRO_ALLIANCE_4, me);
-                events.ScheduleEvent(EVENT_INTRO_ALLIANCE_5, 5000, 0, PHASE_INTRO_A);
-                if (Creature* deathbringer = ObjectAccessor::GetCreature(*me, uiDeathbringerSaurfangGUID))
-                    deathbringer->AI()->DoAction(ACTION_CONTINUE_INTRO);
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                events.Update(diff);
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_INTRO_ALLIANCE_4:
-                            me->AddUnitMovementFlag(MOVEMENTFLAG_WALKING);
-                            me->GetMotionMaster()->MovePoint(POINT_FIRST_STEP, firstStepPos.GetPositionX(), firstStepPos.GetPositionY(), firstStepPos.GetPositionZ());
-                            break;
-                        case EVENT_INTRO_ALLIANCE_5:
-                            DoScriptText(SAY_INTRO_ALLIANCE_5, me);
-                            for (std::list<Creature*>::iterator itr = guardList.begin(); itr != guardList.end(); ++itr)
-                                (*itr)->AI()->DoAction(ACTION_CHARGE);
-                            me->GetMotionMaster()->MoveCharge(chargePos[0].GetPositionX(), chargePos[0].GetPositionY(), chargePos[0].GetPositionZ(), 8.5f, POINT_CHARGE);
-                            break;
-                    }
-                }
-            }
-
-        private:
-            EventMap events;
-            InstanceScript* pInstance;
-            uint64 uiDeathbringerSaurfangGUID;
-            std::list<Creature*> guardList;
-        };
-
-        bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-        {
-            if (pCreature->GetPositionZ() < 530.0f)
-                return false;
-
-            InstanceScript* pInstance = pCreature->GetInstanceScript();
-            if (pInstance && pInstance->GetBossState(DATA_DEATHBRINGER_SAURFANG) != DONE)
-            {
-                pPlayer->ADD_GOSSIP_ITEM(0, "Let it begin...", 631, -ACTION_START_EVENT+1);
-                pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pCreature->GetGUID());
-            }
-
-            return true;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* pCreature, uint32 /*sender*/, uint32 action)
-        {
-            player->PlayerTalkClass->ClearMenus();
-            player->CLOSE_GOSSIP_MENU();
-            if (action == -ACTION_START_EVENT+1)
-                pCreature->AI()->DoAction(ACTION_START_EVENT);
-
-            return true;
-        }
-
-        CreatureAI* GetAI(Creature* pCreature) const
-        {
-            return new npc_muradin_bronzebeard_iccAI(pCreature);
-        }
-};
-
-class npc_saurfang_event : public CreatureScript
-{
-    public:
-        npc_saurfang_event() : CreatureScript("npc_saurfang_event") { }
-
-        struct npc_saurfang_eventAI : public ScriptedAI
-        {
-            npc_saurfang_eventAI(Creature* pCreature) : ScriptedAI(pCreature)
-            {
-                uiNPCindex = 0;
-            }
-
-            void SetData(uint32 type, uint32 data)
-            {
-                ASSERT(!type && data && data < 6);
-                uiNPCindex = data;
-            }
-
-            void SpellHit(Unit* /*caster*/, SpellEntry const* spell)
-            {
-                if (spell->Id == SPELL_GRIP_OF_AGONY)
-                {
-                    me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                    me->GetMotionMaster()->MovePoint(POINT_CHOKE, chokePos[uiNPCindex]);
-                }
-            }
-
-            void DoAction(const int32 action)
-            {
-                if (action == ACTION_CHARGE && uiNPCindex)
-                    me->GetMotionMaster()->MoveCharge(chargePos[uiNPCindex].GetPositionX(), chargePos[uiNPCindex].GetPositionY(), chargePos[uiNPCindex].GetPositionZ(), 13.0f, POINT_CHARGE);
-                else if (action == ACTION_DESPAWN)
-                    me->ForcedDespawn();
-            }
-
-        private:
-            EventMap events;
-            uint32 uiNPCindex;
+            private:
+                InstanceScript* pInstance;
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new npc_saurfang_eventAI(pCreature);
+            return new npc_bloodbeastAI(pCreature);
         }
 };
 
-class spell_deathbringer_blood_link : public SpellScriptLoader
+void AddSC_boss_saurfang()
 {
-    public:
-        spell_deathbringer_blood_link() : SpellScriptLoader("spell_deathbringer_blood_link") { }
-
-        class spell_deathbringer_blood_link_SpellScript : public SpellScript
-        {
-			PrepareSpellScript(spell_deathbringer_blood_link_SpellScript)
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_LINK_POWER))
-                    return false;
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_POWER))
-                    return false;
-                return true;
-            }
-
-            void HandleDummy(SpellEffIndex /*effIndex*/)
-            {
-                GetHitUnit()->CastCustomSpell(SPELL_BLOOD_LINK_POWER, SPELLVALUE_BASE_POINT0, GetEffectValue(), GetHitUnit(), true);
-                if (!GetHitUnit()->HasAura(SPELL_BLOOD_POWER))
-                    GetHitUnit()->CastSpell(GetHitUnit(), SPELL_BLOOD_POWER, true);
-                else if (Aura* bloodPower = GetHitUnit()->GetAura(SPELL_BLOOD_POWER))
-                    bloodPower->RecalculateAmountOfEffects();
-                PreventHitDefaultEffect(EFFECT_0);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_deathbringer_blood_link_SpellScript::HandleDummy, EFFECT_0, SPELL_EFFECT_DUMMY);
-            }
-
-            bool Load()
-            {
-                if (GetSpellInfo()->Id != SPELL_BLOOD_LINK_DUMMY)
-                    return false;
-                return true;
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_blood_link_SpellScript();
-        }
-};
-
-class spell_deathbringer_blood_link_aura : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_blood_link_aura() : SpellScriptLoader("spell_deathbringer_blood_link_aura") { }
-
-        class spell_deathbringer_blood_link_AuraScript : public AuraScript
-        {
-			PrepareAuraScript(spell_deathbringer_blood_link_AuraScript)
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_MARK_OF_THE_FALLEN_CHAMPION))
-                    return false;
-                return true;
-            }
-
-            void HandlePeriodicTick(AuraEffect const * /*aurEff*/, AuraApplication const * /*aurApp*/)
-            {
-                if (GetUnitOwner()->getPowerType() == POWER_ENERGY && GetUnitOwner()->GetPower(POWER_ENERGY) == GetUnitOwner()->GetMaxPower(POWER_ENERGY))
-                    if (Creature* saurfang = GetUnitOwner()->ToCreature())
-                        saurfang->AI()->DoAction(ACTION_MARK_OF_THE_FALLEN_CHAMPION);
-
-                PreventDefaultAction();
-            }
-
-            void Register()
-            {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_deathbringer_blood_link_AuraScript::HandlePeriodicTick, EFFECT_1, SPELL_AURA_PERIODIC_DUMMY);
-            }
-
-            bool Load()
-            {
-                if (GetSpellProto()->Id != SPELL_BLOOD_LINK)
-                    return false;
-                return true;
-            }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_deathbringer_blood_link_AuraScript();
-        }
-};
-
-class spell_deathbringer_blood_power : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_blood_power() : SpellScriptLoader("spell_deathbringer_blood_power") { }
-
-        class spell_deathbringer_blood_power_SpellScript : public SpellScript
-        {
-			PrepareSpellScript(spell_deathbringer_blood_power_SpellScript)
-            void ModAuraValue()
-            {
-                if (Aura* aura = GetHitAura())
-                    aura->RecalculateAmountOfEffects();
-            }
-
-            void Register()
-            {
-                AfterHit += SpellHitFn(spell_deathbringer_blood_power_SpellScript::ModAuraValue);
-            }
-        };
-
-        class spell_deathbringer_blood_power_AuraScript : public AuraScript
-        {
-               PrepareAuraScript(spell_deathbringer_blood_power_AuraScript)
-				 
-            void RecalculateHook(AuraEffect const* /*aurEffect*/, int32& amount, bool& canBeRecalculated)
-            {
-                amount = GetUnitOwner()->GetPower(POWER_ENERGY);
-                canBeRecalculated = true;
-            }
-
-            void Register()
-            {
-                OnEffectCalcAmount += AuraEffectCalcAmountFn(spell_deathbringer_blood_power_AuraScript::RecalculateHook, EFFECT_0, SPELL_AURA_MOD_SCALE);
-                OnEffectCalcAmount += AuraEffectCalcAmountFn(spell_deathbringer_blood_power_AuraScript::RecalculateHook, EFFECT_1, SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
-            }
-
-            bool Load()
-            {
-                if (GetUnitOwner()->getPowerType() != POWER_ENERGY)
-                    return false;
-                return true;
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_blood_power_SpellScript();
-        }
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_deathbringer_blood_power_AuraScript();
-        }
-};
-
-class spell_deathbringer_rune_of_blood : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_rune_of_blood() : SpellScriptLoader("spell_deathbringer_rune_of_blood") { }
-
-        class spell_deathbringer_rune_of_blood_SpellScript : public SpellScript
-        {
-			PrepareSpellScript(spell_deathbringer_rune_of_blood_SpellScript)
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_LINK_DUMMY))
-                    return false;
-                return true;
-            }
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
-            {
-                PreventHitDefaultEffect(EFFECT_1);  // make this the default handler
-                if (GetCaster()->GetPower(POWER_ENERGY) != GetCaster()->GetMaxPower(POWER_ENERGY))
-                    GetHitUnit()->CastCustomSpell(SPELL_BLOOD_LINK_DUMMY, SPELLVALUE_BASE_POINT0, 1, GetCaster(), true);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_deathbringer_rune_of_blood_SpellScript::HandleScript, EFFECT_1, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_rune_of_blood_SpellScript();
-        }
-};
-
-class spell_deathbringer_blood_nova : public SpellScriptLoader
-{
-    public:
-        spell_deathbringer_blood_nova() : SpellScriptLoader("spell_deathbringer_blood_nova") { }
-
-        class spell_deathbringer_blood_nova_SpellScript : public SpellScript
-        {
-			PrepareSpellScript(spell_deathbringer_blood_nova_SpellScript)
-            bool Validate(SpellEntry const* /*spellInfo*/)
-            {
-                if (!sSpellStore.LookupEntry(SPELL_BLOOD_LINK_DUMMY))
-                    return false;
-                return true;
-            }
-
-            void HandleScript(SpellEffIndex /*effIndex*/)
-            {
-                PreventHitDefaultEffect(EFFECT_1);  // make this the default handler
-                if (GetCaster()->GetPower(POWER_ENERGY) != GetCaster()->GetMaxPower(POWER_ENERGY))
-                    GetHitUnit()->CastCustomSpell(SPELL_BLOOD_LINK_DUMMY, SPELLVALUE_BASE_POINT0, 2, GetCaster(), true);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_deathbringer_blood_nova_SpellScript::HandleScript, EFFECT_1, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_deathbringer_blood_nova_SpellScript();
-        }
-};
-
-class achievement_ive_gone_and_made_a_mess : public AchievementCriteriaScript
-{
-    public:
-        achievement_ive_gone_and_made_a_mess() : AchievementCriteriaScript("achievement_ive_gone_and_made_a_mess") { }
-
-        bool OnCheck(Player* /*source*/, Unit* target)
-        {
-            if (Creature* saurfang = target->ToCreature())
-                if (saurfang->AI()->GetData(DATA_MADE_A_MESS))
-                    return true;
-
-            return false;
-        }
-};
-
-void AddSC_boss_deathbringer_saurfang()
-{
-    new boss_deathbringer_saurfang();
-    new npc_high_overlord_saurfang_icc();
-    new npc_muradin_bronzebeard_icc();
-    new npc_saurfang_event();
-    new spell_deathbringer_blood_link();
-    new spell_deathbringer_blood_link_aura();
-    new spell_deathbringer_blood_power();
-    new spell_deathbringer_rune_of_blood();
-    new spell_deathbringer_blood_nova();
-    new achievement_ive_gone_and_made_a_mess();
-}
+    new boss_saurfang();
+    new npc_bloodbeast();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_festergut.cpp
@@ -1,27 +1,27 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-enum eScriptTexts
+enum Yells
 {
-    SAY_STINKY_DEAD             = -1631078,
+    SAY_STINKY                  = -1631078,
     SAY_AGGRO                   = -1631079,
     EMOTE_GAS_SPORE             = -1631081,
     EMOTE_WARN_GAS_SPORE        = -1631082,
@@ -34,44 +34,23 @@
     SAY_DEATH                   = -1631089
 };
 
-enum eSpells
+enum Spells
 {
-    // Festergut
-    SPELL_INHALE_BLIGHT         = 69165,
-    SPELL_PUNGENT_BLIGHT        = 69195,
-    SPELL_GASTRIC_BLOAT         = 72219, // 72214 is the proper way (with proc) but atm procs can't have cooldown for creatures
-    SPELL_GASTRIC_EXPLOSION     = 72227,
-    SPELL_GAS_SPORE             = 69278,
-    SPELL_VILE_GAS              = 69240,
-    SPELL_INOCULATED            = 69291,
-
-    // Stinky
-    SPELL_MORTAL_WOUND          = 71127,
-    SPELL_DECIMATE              = 71123,
-    SPELL_PLAGUE_STENCH         = 71805
+    SPELL_PUNGENT_BLIGHT     = 69195,
+    SPELL_INHALE_BLIGHT      = 69165,
+    SPELL_VILE_GAS           = 69240,
+    SPELL_GASTRIC_BLOAT      = 72219,
+    SPELL_GAS_SPORES         = 69278,
+    SPELL_UNOCULATED         = 69291,
+    SPELL_GAS_FLOOD          = 71379,
+    SPELL_MORTAL_WOUND       = 71127,
+    SPELL_DECIMATE           = 71123,
+    SPELL_PLAGUE_STENCH      = 71805
 };
 
-// Used for HasAura checks
-#define PUNGENT_BLIGHT_HELPER RAID_MODE<uint32>(69195,71219,73031,73032)
-#define INOCULATED_HELPER     RAID_MODE<uint32>(69291,72101,72102,72103)
-
 static const uint32 gaseousBlight[3]        = {69157, 69162, 69164};
 static const uint32 gaseousBlightVisual[3]  = {69126, 69152, 69154};
 
-enum eEvents
-{
-    EVENT_BERSERK       = 1,
-    EVENT_INHALE_BLIGHT = 2,
-    EVENT_VILE_GAS      = 3,
-    EVENT_GAS_SPORE     = 4,
-    EVENT_GASTRIC_BLOAT = 5,
-
-    EVENT_DECIMATE      = 6,
-    EVENT_MORTAL_WOUND  = 7
-};
-
-#define DATA_INOCULATED_STACK 69291
-
 class boss_festergut : public CreatureScript
 {
     public:
@@ -79,28 +58,26 @@
 
         struct boss_festergutAI : public BossAI
         {
-            boss_festergutAI(Creature* pCreature) : BossAI(pCreature, DATA_FESTERGUT)
+            boss_festergutAI(Creature* pCreature) : BossAI(pCreature, DATA_FESTERGURT)
             {
-                ASSERT(instance);
-                uiMaxInoculatedStack = 0;
-                uiInhaleCounter = 0;
-                gasDummyGUID = 0;
+                pInstance = me->GetInstanceScript();
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, true);
             }
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_BERSERK, 300000);
-                events.ScheduleEvent(EVENT_INHALE_BLIGHT, urand(25000, 30000));
-                events.ScheduleEvent(EVENT_VILE_GAS, urand(30000, 32500));
-                events.ScheduleEvent(EVENT_GAS_SPORE, urand(20000, 25000));
-                events.ScheduleEvent(EVENT_GASTRIC_BLOAT, urand(12500, 15000));
-                uiMaxInoculatedStack = 0;
-                uiInhaleCounter = 0;
-                me->RemoveAurasDueToSpell(SPELL_BERSERK2);
-                if (Creature* gasDummy = GetClosestCreatureWithEntry(me, NPC_GAS_DUMMY, 100.0f, true))
+                m_uiInhaleBlightTimer = urand(23000,29000);
+                m_uiVileGasTimer = 20000;
+                m_uiGasSporesTimer = 20000;
+                m_uiGastricBloatTimer = 12000;
+                m_uiBerserkTimer = 300000;
+                m_uiGaseousTimer = 1000;
+
+                m_uiInhaleBlightCount = 0;
+
+                if (Creature* gasDummy = GetClosestCreatureWithEntry(me, CREATURE_ORANGE_GAS_STALKER, 100.0f, true))
                 {
-                    gasDummyGUID = gasDummy->GetGUID();
+                    m_uiGasDummyGUID = gasDummy->GetGUID();
                     for (uint8 i = 0; i < 3; ++i)
                     {
                         gasDummy->RemoveAurasDueToSpell(gaseousBlight[i]);
@@ -108,144 +85,158 @@
                     }
                 }
 
-                instance->SetData(DATA_FESTERGUT, NOT_STARTED);
+                if (pInstance && me->isAlive())
+                    pInstance->SetData(DATA_FESTERGURT_EVENT, NOT_STARTED);
             }
 
             void EnterCombat(Unit* /*who*/)
             {
                 DoScriptText(SAY_AGGRO, me);
-                if (Creature* gasDummy = GetClosestCreatureWithEntry(me, NPC_GAS_DUMMY, 100.0f, true))
-                    gasDummyGUID = gasDummy->GetGUID();
-                instance->SetData(DATA_FESTERGUT, IN_PROGRESS);
+
+                if (pInstance)
+                    pInstance->SetData(DATA_FESTERGURT_EVENT, IN_PROGRESS);
+
                 if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
+                {
                     professor->AI()->DoAction(ACTION_FESTERGUT_COMBAT);
+                    professor->AI()->DoAction(ACTION_FESTERGUT_GAS);
+                }
 
-                DoZoneInCombat(me);
+                if (Creature* gasDummy = GetClosestCreatureWithEntry(me, CREATURE_ORANGE_GAS_STALKER, 100.0f, true))
+                {
+                    m_uiGasDummyGUID = gasDummy->GetGUID();
+                    for (uint8 i = 0; i < 3; ++i)
+                    {
+                        gasDummy->CastSpell(gasDummy,gaseousBlight[i], true);
+                    }
+                }
             }
 
-            void JustDied(Unit* /*killer*/)
+            void JustDied(Unit* /*pKiller*/)
             {
+                if (!pInstance)
+                    return;
+
                 DoScriptText(SAY_DEATH, me);
-                instance->SetData(DATA_FESTERGUT, DONE);
+
+                pInstance->SetData(DATA_FESTERGURT_EVENT, DONE);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_GASTRIC_BLOAT);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_VILE_GAS);
+                me->RemoveAurasDueToSpell(SPELL_PUNGENT_BLIGHT);
+
                 if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
                     professor->AI()->DoAction(ACTION_FESTERGUT_DEATH);
+                    
+                if (Creature* gasDummy = Unit::GetCreature(*me, m_uiGasDummyGUID))
+                    gasDummy->RemoveAllAuras();
             }
 
             void JustReachedHome()
             {
-                instance->SetData(DATA_FESTERGUT, FAIL);
+                if (!pInstance)
+                    return;
+
+                pInstance->SetData(DATA_FESTERGURT_EVENT, FAIL);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_GASTRIC_BLOAT);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_VILE_GAS);
+                me->RemoveAurasDueToSpell(SPELL_PUNGENT_BLIGHT);
             }
 
-            void EnterEvadeMode()
+            void KilledUnit(Unit* victim)
             {
-                ScriptedAI::EnterEvadeMode();
-                if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
-                    professor->AI()->EnterEvadeMode();
+                if (victim->GetTypeId() == TYPEID_PLAYER)
+                {
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
+                }
             }
 
-            void KilledUnit(Unit *victim)
+            void UpdateAI(const uint32 uiDiff)
             {
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
-            }
-
-            void MoveInLineOfSight(Unit* /*who*/)
-            {
-                // don't enter combat
-            }
-
-            void SpellHitTarget(Unit* target, const SpellEntry* spell)
-            {
-                if (spell->Id == PUNGENT_BLIGHT_HELPER)
-                    target->RemoveAurasDueToSpell(INOCULATED_HELPER);
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim() || !CheckInRoom())
+                if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                if (m_uiGastricBloatTimer < uiDiff)
+                {
+                    DoCast(me->getVictim(), SPELL_GASTRIC_BLOAT);
+                    m_uiGastricBloatTimer = 13000;
+                } else m_uiGastricBloatTimer -= uiDiff;
 
-                if (me->hasUnitState(UNIT_STAT_CASTING))
-                    return;
+                if (m_uiInhaleBlightTimer < uiDiff)
+                {
+                    if (Creature* gasDummy = Unit::GetCreature(*me, m_uiGasDummyGUID))
+                    {
+                        if(m_uiInhaleBlightCount == 3)
+                        {
+                            DoScriptText(EMOTE_WARN_PUNGENT_BLIGHT, me);
+                            DoCast(me, SPELL_PUNGENT_BLIGHT);
+                            DoScriptText(SAY_PUNGENT_BLIGHT, me);
+                            m_uiInhaleBlightCount = 0;
 
-                while (uint32 eventId = events.ExecuteEvent())
+                            if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
+                                professor->AI()->DoAction(ACTION_FESTERGUT_GAS);
+                        }
+                        else
+                        {
+                            DoCast(me, SPELL_INHALE_BLIGHT);
+                            gasDummy->RemoveAurasDueToSpell(gaseousBlight[m_uiInhaleBlightCount]);
+                            gasDummy->RemoveAurasDueToSpell(gaseousBlightVisual[m_uiInhaleBlightCount]);
+                            ++m_uiInhaleBlightCount;
+                        }
+                    }
+                    m_uiInhaleBlightTimer = urand(23000, 29000);
+                } else m_uiInhaleBlightTimer -= uiDiff;
+
+                if (m_uiVileGasTimer < uiDiff)
                 {
-                    switch (eventId)
+                    for (uint8 i = 1; i <= 3; i++)
                     {
-                        case EVENT_INHALE_BLIGHT:
+                        if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
                         {
-                            if (Creature* gasDummy = Unit::GetCreature(*me, gasDummyGUID))
-                                for (uint8 i = 0; i < 3; ++i)
-                                {
-                                    gasDummy->RemoveAurasDueToSpell(gaseousBlight[i]);
-                                    gasDummy->RemoveAurasDueToSpell(gaseousBlightVisual[i]);
-                                }
-                            if (uiInhaleCounter == 3)
-                            {
-                                DoScriptText(EMOTE_WARN_PUNGENT_BLIGHT, me);
-                                DoScriptText(SAY_PUNGENT_BLIGHT, me);
-                                DoCast(me, SPELL_PUNGENT_BLIGHT);
-                                uiInhaleCounter = 0;
-                                if (Creature* professor = Unit::GetCreature(*me, instance->GetData64(DATA_PROFESSOR_PUTRICIDE)))
-                                    professor->AI()->DoAction(ACTION_FESTERGUT_GAS);
-                            }
-                            else
-                            {
-                                DoCast(me, SPELL_INHALE_BLIGHT);
-                                // just cast and dont bother with target, conditions will handle it
-                                ++uiInhaleCounter;
-                                if (uiInhaleCounter < 3)
-                                    me->CastSpell(me, gaseousBlight[uiInhaleCounter], true, NULL, NULL, me->GetGUID());
-                            }
-                            events.ScheduleEvent(EVENT_INHALE_BLIGHT, urand(33500, 35000));
-                            return;
+                            DoCast(pTarget, SPELL_VILE_GAS, true);
                         }
-                        case EVENT_VILE_GAS:
-                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true))
-                                DoCast(target, SPELL_VILE_GAS);
-                            events.ScheduleEvent(EVENT_VILE_GAS, urand(28000, 35000));
-                            break;
-                        case EVENT_GAS_SPORE:
+                    }
+                    m_uiVileGasTimer = 20000;
+                } else m_uiVileGasTimer -= uiDiff;
+
+                if (m_uiGasSporesTimer < uiDiff)
+                {
+                    uint32 count = RAID_MODE(2,3,2,3);
+                    for (uint8 i = 1; i <= count; i++)
+                    {
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                        {
                             DoScriptText(EMOTE_WARN_GAS_SPORE, me);
-                            me->CastCustomSpell(SPELL_GAS_SPORE, SPELLVALUE_MAX_TARGETS, RAID_MODE<int32>(2,3,2,3), me);
+                            pTarget->CastSpell(pTarget, SPELL_GAS_SPORES, true);
                             DoScriptText(EMOTE_GAS_SPORE, me);
-                            events.ScheduleEvent(EVENT_GAS_SPORE, urand(40000, 45000));
-                        case EVENT_GASTRIC_BLOAT:
-                            DoCastVictim(SPELL_GASTRIC_BLOAT);
-                            events.ScheduleEvent(EVENT_GASTRIC_BLOAT, urand(15000, 17500));
-                            break;
-                        case EVENT_BERSERK:
-                            DoCast(me, SPELL_BERSERK2);
-                            DoScriptText(SAY_BERSERK, me);
-                            break;
-                        default:
-                            break;
+                        }
                     }
-                }
+                    m_uiGasSporesTimer = 20000;
+                } else m_uiGasSporesTimer -= uiDiff;
+
+                if(m_uiBerserkTimer < uiDiff)
+                {
+                    DoCast(me, SPELL_BERSERK);
+                    DoScriptText(SAY_BERSERK, me);
+                    m_uiBerserkTimer = 300000;
+                } else m_uiBerserkTimer -= uiDiff;
 
                 DoMeleeAttackIfReady();
             }
+        private:
+            InstanceScript* pInstance;
 
-            void SetData(uint32 type, uint32 data)
-            {
-                if (type == DATA_INOCULATED_STACK && data > uiMaxInoculatedStack)
-                    uiMaxInoculatedStack = data;
-            }
-
-            uint32 GetData(uint32 type)
-            {
-                if (type == DATA_INOCULATED_STACK)
-                    return uint32(uiMaxInoculatedStack);
-
-                return 0;
-            }
-
-        private:
-            uint32 uiMaxInoculatedStack;
-            uint8 uiInhaleCounter;
-            uint64 gasDummyGUID;
+            uint32 m_uiInhaleBlightTimer;
+            uint32 m_uiGasSporesTimer;
+            uint32 m_uiVileGasTimer;
+            uint32 m_uiGastricBloatTimer;
+            uint32 m_uiBerserkTimer;
+            uint32 m_uiGaseousTimer;
+            uint64 m_uiGasDummyGUID;
+            uint8 m_uiInhaleBlightCount;
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
@@ -268,52 +259,42 @@
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_DECIMATE, urand(20000, 25000));
-                events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(3000, 7000));
+                m_uiDecimateTimer = 23000;
+                m_uiMortalTimer = urand(8000, 10000);
+
                 DoCast(me, SPELL_PLAGUE_STENCH);
             }
 
-            void UpdateAI(const uint32 diff)
+            void UpdateAI(const uint32 uiDiff)
             {
                 if (!UpdateVictim())
                     return;
 
-                events.Update(diff);
+                if(m_uiDecimateTimer < uiDiff)
+                {
+                    DoCast(me->getVictim(), SPELL_DECIMATE);
+                    m_uiDecimateTimer = 23000;
+                } else m_uiDecimateTimer -= uiDiff;
 
-                if (me->hasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
+                if(m_uiMortalTimer < uiDiff)
                 {
-                    switch (eventId)
-                    {
-                        case EVENT_DECIMATE:
-                            DoCastVictim(SPELL_DECIMATE);
-                            events.ScheduleEvent(EVENT_DECIMATE, urand(20000, 25000));
-                            break;
-                        case EVENT_MORTAL_WOUND:
-                            DoCastVictim(SPELL_MORTAL_WOUND);
-                            events.ScheduleEvent(EVENT_MORTAL_WOUND, urand(10000, 12500));
-                            break;
-                        default:
-                            break;
-                    }
-                }
+                    DoCast(me->getVictim(), SPELL_MORTAL_WOUND);
+                    m_uiMortalTimer = urand(8000,10000);
+                } else m_uiMortalTimer -= uiDiff;
 
                 DoMeleeAttackIfReady();
             }
 
             void JustDied(Unit* /*who*/)
             {
-                uint64 festergutGUID = pInstance ? pInstance->GetData64(DATA_FESTERGUT) : 0;
+                uint64 festergutGUID = pInstance ? pInstance->GetData64(DATA_FESTERGURT) : 0;
                 if (Creature *festergut = me->GetCreature(*me, festergutGUID))
-                    DoScriptText(SAY_STINKY_DEAD, festergut);
+                    DoScriptText(SAY_STINKY, festergut);
             }
-
         private:
-            EventMap events;
             InstanceScript* pInstance;
+            uint32 m_uiDecimateTimer;
+            uint32 m_uiMortalTimer;
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
@@ -322,134 +303,8 @@
         }
 };
 
-class spell_festergut_pungent_blight : public SpellScriptLoader
-{
-    public:
-        spell_festergut_pungent_blight() : SpellScriptLoader("spell_festergut_pungent_blight") { }
-
-        class spell_festergut_pungent_blight_SpellScript : public SpellScript
-        {
-			PrepareSpellScript(spell_festergut_pungent_blight_SpellScript)
-            void HandleScript(SpellEffIndex /*effIndex*/)
-            {
-                SpellEntry const* spellInfo = sSpellStore.LookupEntry(GetEffectValue());
-                if (!spellInfo)
-                    return;
-
-                // Get Inhaled Blight id for our difficulty
-                spellInfo = sSpellMgr.GetSpellForDifficultyFromSpell(spellInfo, GetCaster());
-
-                // ...and remove it
-                GetCaster()->RemoveAurasDueToSpell(spellInfo->Id);
-                DoScriptText(EMOTE_PUNGENT_BLIGHT, GetCaster());
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_festergut_pungent_blight_SpellScript::HandleScript, EFFECT_1, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_festergut_pungent_blight_SpellScript();
-        }
-};
-
-class spell_festergut_gastric_bloat : public SpellScriptLoader
-{
-    public:
-        spell_festergut_gastric_bloat() : SpellScriptLoader("spell_festergut_gastric_bloat") { }
-
-        class spell_festergut_gastric_bloat_SpellScript : public SpellScript
-        {
-			PrepareSpellScript(spell_festergut_gastric_bloat_SpellScript)
-            void HandleScript(SpellEffIndex /*effIndex*/)
-            {
-                Aura const* aura = GetHitUnit()->GetAura(GetSpellInfo()->Id);
-                if (!(aura && aura->GetStackAmount() == 10))
-                    return;
-
-                //PreventHitAura();
-
-                SpellEntry const* spellInfo = sSpellStore.LookupEntry(SPELL_GASTRIC_EXPLOSION);
-                if (!spellInfo)
-                    return;
-
-                // Get Gastric Explosion id for our difficulty
-                spellInfo = sSpellMgr.GetSpellForDifficultyFromSpell(spellInfo, GetCaster());
-                GetHitUnit()->RemoveAurasDueToSpell(GetSpellInfo()->Id);
-                GetHitUnit()->CastSpell(GetHitUnit(), spellInfo, true);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_festergut_gastric_bloat_SpellScript::HandleScript, EFFECT_2, SPELL_EFFECT_SCRIPT_EFFECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_festergut_gastric_bloat_SpellScript();
-        }
-};
-
-class spell_festergut_blighted_spores : public SpellScriptLoader
-{
-    public:
-        spell_festergut_blighted_spores() : SpellScriptLoader("spell_festergut_blighted_spores") { }
-
-        class spell_festergut_blighted_spores_AuraScript : public AuraScript
-        {
-			PrepareAuraScript(spell_festergut_blighted_spores_AuraScript)
-            void ExtraEffect(AuraEffect const* /*aurEff*/, AuraApplication const* aurApp, AuraEffectHandleModes /*mode*/)
-            {
-                if (!GetCaster()->IsAIEnabled || GetCaster()->GetTypeId() != TYPEID_UNIT)
-                    return;
-
-                uint32 inoculateId = CAST_AI(ScriptedAI, GetCaster()->ToCreature()->AI())->INOCULATED_HELPER;
-                uint32 currStack = 0;
-                if (Aura const* inoculate = aurApp->GetTarget()->GetAura(inoculateId))
-                    currStack = inoculate->GetStackAmount();
-
-                aurApp->GetTarget()->CastSpell(aurApp->GetTarget(), SPELL_INOCULATED, true);
-                ++currStack;
-                if (GetCaster())
-                    GetCaster()->ToCreature()->AI()->SetData(DATA_INOCULATED_STACK, currStack);
-            }
-
-            void Register()
-            {
-                OnEffectApply += AuraEffectApplyFn(spell_festergut_blighted_spores_AuraScript::ExtraEffect, EFFECT_0, SPELL_AURA_PERIODIC_DAMAGE, AURA_EFFECT_HANDLE_REAL);
-            }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_festergut_blighted_spores_AuraScript();
-        }
-};
-
-class achievement_flu_shot_shortage : public AchievementCriteriaScript
-{
-    public:
-        achievement_flu_shot_shortage() : AchievementCriteriaScript("achievement_flu_shot_shortage") { }
-
-        bool OnCheck(Player* /*source*/, Unit* target)
-        {
-            if (target && target->GetTypeId() == TYPEID_UNIT)
-                return target->ToCreature()->AI()->GetData(DATA_INOCULATED_STACK) < 3;
-
-            return false;
-        }
-};
-
 void AddSC_boss_festergut()
 {
     new boss_festergut();
     new npc_stinky_icc();
-    new spell_festergut_pungent_blight();
-    new spell_festergut_gastric_bloat();
-    new spell_festergut_blighted_spores();
-    new achievement_flu_shot_shortage();
-}
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_lady_deathwhisper.cpp
@@ -1,155 +1,75 @@
 /*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-enum eScriptTexts
+enum Spells
 {
-    SAY_INTRO_1                 = -1631011,
-    SAY_INTRO_2                 = -1631012,
-    SAY_INTRO_3                 = -1631013,
-    SAY_INTRO_4                 = -1631014,
-    SAY_INTRO_5                 = -1631015,
-    SAY_INTRO_6                 = -1631016,
-    SAY_INTRO_7                 = -1631017,
-    SAY_AGGRO                   = -1631018,
-    SAY_PHASE_2                 = -1631019,
-    SAY_PHASE_2_EMOTE           = -1631020,
-    SAY_DOMINATE_MIND           = -1631021,
-    SAY_DARK_EMPOWERMENT        = -1631022,
-    SAY_DARK_TRANSFORMATION     = -1631023,
-    SAY_ANIMATE_DEAD            = -1631024,
-    SAY_KILL_1                  = -1631025,
-    SAY_KILL_2                  = -1631026,
-    SAY_BERSERK                 = -1631027,
-    SAY_DEATH                   = -1631028
+    SPELL_DEATH_AND_DECAY   = 71001,
+    SPELL_DOMINATE_MIND     = 71289,
+    SPELL_SHADOW_BOLT       = 71254,
+    SPELL_MANA_BARRIER      = 70842,
+    SPELL_TRANSFORMATION    = 70900,
+    SPELL_FROST_BOLT        = 71420,
+    SPELL_FROST_BOLT_VALLEY = 72905,
+    SPELL_SUMMON_SHADE      = 71363,
+    SPELL_INSIGNIFICANCE    = 71204,
+    SPELL_BLAST             = 71494,
+    SPELL_VENGEFUL_BLAST    = 71544,
+    SPELL_PORT_VISUAL       = 41236,
+    SPELL_SHADOW_CHANNELING = 43897,
+    SPELL_TRANSFORMATION_T  = 70895,
+    SPELL_EMPOWERMENT_T     = 70896,
+    //SPELL_ANIMATED_DEAD   = ????? // not in DBC! Need sniffs
 };
 
-enum eSpells
+enum Yells
 {
-    // Lady Deathwhisper
-    SPELL_MANA_BARRIER              = 70842,
-    SPELL_SHADOW_BOLT               = 71254,
-    SPELL_DEATH_AND_DECAY           = 71001,
-    SPELL_DOMINATE_MIND_H           = 71289,
-    SPELL_FROSTBOLT                 = 71420,
-    SPELL_FROSTBOLT_VOLLEY          = 72905,
-    SPELL_TOUCH_OF_INSIGNIFICANCE   = 71204,
-    SPELL_SUMMON_SHADE              = 71363,
-    SPELL_SHADOW_CHANNELING         = 43897, // Prefight, during intro
-    SPELL_DARK_TRANSFORMATION_T     = 70895,
-    SPELL_DARK_EMPOWERMENT_T        = 70896,
-    SPELL_DARK_MARTYRDOM_T          = 70897,
-
-    // Achievement
-    SPELL_FULL_HOUSE                = 72827, // does not exist in dbc but still can be used for criteria check
-
-    // Both Adds
-    SPELL_TELEPORT_VISUAL           = 41236,
-
-    // Fanatics
-    SPELL_DARK_TRANSFORMATION       = 70900,
-    SPELL_NECROTIC_STRIKE           = 70659,
-    SPELL_SHADOW_CLEAVE             = 70670,
-    SPELL_VAMPIRIC_MIGHT            = 70674,
-    SPELL_FANATIC_S_DETERMINATION   = 71235,
-    SPELL_DARK_MARTYRDOM_FANATIC    = 71236,
-
-    //  Adherents
-    SPELL_DARK_EMPOWERMENT          = 70901,
-    SPELL_FROST_FEVER               = 67767,
-    SPELL_DEATHCHILL_BOLT           = 70594,
-    SPELL_DEATHCHILL_BLAST          = 70906,
-    SPELL_CURSE_OF_TORPOR           = 71237,
-    SPELL_SHORUD_OF_THE_OCCULT      = 70768,
-    SPELL_ADHERENT_S_DETERMINATION  = 71234,
-    SPELL_DARK_MARTYRDOM_ADHERENT   = 70903,
-
-    // Vengeful Shade
-    SPELL_VENGEFUL_BLAST            = 71544,
-    SPELL_VENGEFUL_BLAST_PASSIVE    = 71494
+    SAY_INTRO_1        = -1631011,
+    SAY_INTRO_2        = -1631012,
+    SAY_INTRO_3        = -1631013,
+    SAY_INTRO_4        = -1631014,
+    SAY_INTRO_5        = -1631015,
+    SAY_INTRO_6        = -1631016,
+    SAY_INTRO_7        = -1631017,
+    SAY_AGGRO          = -1631018,
+    SAY_PHASE_2        = -1631019,
+    EMOTE_PHASE_2      = -1631020,
+    SAY_DOMINATE_MIND  = -1631021,
+    SAY_EMPOWERMENT    = -1631022,
+    SAY_TRANSFORMATION = -1631023,
+    SAY_ANIMATE_DEAD   = -1631024,
+    SAY_KILL_1         = -1631025,
+    SAY_KILL_2         = -1631026,
+    SAY_BERSERK        = -1631027,
+    SAY_DEATH          = -1631028
 };
 
-enum eEvents
+const Position SpawnLoc[]=
 {
-    // Lady Deathwhisper
-    EVENT_INTRO_2                       = 1,
-    EVENT_INTRO_3                       = 2,
-    EVENT_INTRO_4                       = 3,
-    EVENT_INTRO_5                       = 4,
-    EVENT_INTRO_6                       = 5,
-    EVENT_INTRO_7                       = 6,
-    EVENT_INTRO_FINISH                  = 7,
-    EVENT_BERSERK                       = 8,
-    EVENT_DEATH_AND_DECAY               = 9,
-    EVENT_DOMINATE_MIND_H               = 10,
-
-    // Phase 1 only
-    EVENT_P1_SUMMON_WAVE                = 11,
-    EVENT_P1_SHADOW_BOLT                = 12,
-    EVENT_P1_EMPOWER_CULTIST            = 13,
-    EVENT_P1_REANIMATE_CULTIST          = 14,
-
-    // Phase 2 only
-    EVENT_P2_SUMMON_WAVE                = 15,
-    EVENT_P2_FROSTBOLT                  = 16,
-    EVENT_P2_FROSTBOLT_VOLLEY           = 17,
-    EVENT_P2_TOUCH_OF_INSIGNIFICANCE    = 18,
-    EVENT_P2_SUMMON_SHADE               = 19,
-
-    // Shared adds events
-    EVENT_CULTIST_DARK_MARTYRDOM        = 20,
-
-    // Cult Fanatic
-    EVENT_FANATIC_NECROTIC_STRIKE       = 21,
-    EVENT_FANATIC_SHADOW_CLEAVE         = 22,
-    EVENT_FANATIC_VAMPIRIC_MIGHT        = 23,
-
-    // Cult Adherent
-    EVENT_ADHERENT_FROST_FEVER          = 24,
-    EVENT_ADHERENT_DEATHCHILL           = 25,
-    EVENT_ADHERENT_CURSE_OF_TORPOR      = 26,
-    EVENT_ADHERENT_SHORUD_OF_THE_OCCULT = 27
-};
-
-enum ePhases
-{
-    PHASE_ALL       = 0,
-    PHASE_INTRO     = 1,
-    PHASE_ONE       = 2,
-    PHASE_TWO       = 3,
-
-    PHASE_INTRO_MASK    = 1 << PHASE_INTRO,
-    PHASE_ONE_MASK      = 1 << PHASE_ONE,
-};
-
-static const uint32 uiAddEntries[2] = {NPC_CULT_FANATIC, NPC_CULT_ADHERENT};
-
-static const Position addSpawnPos[7] =
-{
-    {-578.7066f, 2154.167f, 51.01529f, 1.692969f}, // 1 Left Door 1 (Cult Fanatic)
-    {-598.9028f, 2155.005f, 51.01530f, 1.692969f}, // 2 Left Door 2 (Cult Adherent)
-    {-619.2864f, 2154.460f, 51.01530f, 1.692969f}, // 3 Left Door 3 (Cult Fanatic)
-    {-578.6996f, 2269.856f, 51.01529f, 4.590216f}, // 4 Right Door 1 (Cult Adherent)
-    {-598.9688f, 2269.264f, 51.01529f, 4.590216f}, // 5 Right Door 2 (Cult Fanatic)
-    {-619.4323f, 2268.523f, 51.01530f, 4.590216f}, // 6 Right Door 3 (Cult Adherent)
-    {-524.2480f, 2211.920f, 62.90960f, 3.141592f}  // 7 Upper (Random Cultist)
+    {-578.7066f, 2154.167f, 51.01529f, 1.692969f},
+    {-598.9028f, 2155.005f, 51.01530f, 1.692969f},
+    {-619.2864f, 2154.460f, 51.01530f, 1.692969f},
+    {-578.6996f, 2269.856f, 51.01529f, 4.590216f},
+    {-598.9688f, 2269.264f, 51.01529f, 4.590216f},
+    {-619.4323f, 2268.523f, 51.01530f, 4.590216f},
+    {-524.2480f, 2211.920f, 62.90960f, 3.141592f},
+    {-623.0554f, 2211.326f, 51.76425f, 3.444574f}
 };
 
 class boss_lady_deathwhisper : public CreatureScript
@@ -159,353 +79,153 @@
 
         struct boss_lady_deathwhisperAI : public BossAI
         {
-            boss_lady_deathwhisperAI(Creature* pCreature) : BossAI(pCreature, DATA_LADY_DEATHWHISPER)
+            boss_lady_deathwhisperAI(Creature* pCreature) : BossAI(pCreature, DATA_DEATHWHISPER), summons(me)
             {
-                ASSERT(instance);
-                bIntroDone = false;
-                uiDominateMindCount = RAID_MODE(0,1,1,3);
+                pInstance = pCreature->GetInstanceScript();
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
+                me->ApplySpellImmune(SPELL_FROST_BOLT, IMMUNITY_EFFECT, SPELL_EFFECT_INTERRUPT_CAST, false);
+                bIntro = false;
+                bCombat = false;
+                bFirstSummon = false;
+                m_uiCount = RAID_MODE(0,1,1,3);
             }
 
             void Reset()
             {
-                me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
-                me->SetLastManaUse(0xFFFFFFFF); // hacky, but no other way atm to prevent mana regen
-                events.Reset();
-                events.SetPhase(PHASE_ONE);
-                uiAddWaveCounter = 0;
-                uiNextVengefulShadeTarget = 0;
+                m_uiPhase = 1;
+                m_uiIntroPhase = 1;
+                m_uiStage = 1;
+
+                m_uiIntroTimer = 1000;
+                m_uiSummonWaveTimer = !bFirstSummon ? 10000 : 60000;
+                m_uiDeathandDecayTimer = 10000;
+                m_uiFrostBoltTimer = 10000;
+                m_uiFrostValleyTimer = 18000;
+                m_uiShadowBoltTimer = 6000;
+                m_uiBerserkTimer = 600000;
+                m_uiInsignificanceTimer = 7000;
+                m_uiShadeTimer = 10000;
+                m_uiDominateMindTimer = 27000;
+                m_uiCultTimer = urand(20000, 23000);
+
+                pSummoned = NULL;
+
+                me->SetLastManaUse(0xFFFFFFFF);
+
                 DoCast(me, SPELL_SHADOW_CHANNELING);
-                me->RemoveAurasDueToSpell(SPELL_BERSERK);
-                me->RemoveAurasDueToSpell(SPELL_MANA_BARRIER);
-                me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, false);
-                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, false);
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, NOT_STARTED);
+
+                if(m_uiPhase == 1)
+                    DoStartNoMovement(me->getVictim());
+                else if(m_uiPhase == 2)
+                    DoStartMovement(me->getVictim());
+
+                if (pInstance && me->isAlive())
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, NOT_STARTED);
             }
 
-            void MoveInLineOfSight(Unit* who)
+            void EnterCombat(Unit* /*pWho*/)
             {
-                if (!bIntroDone && me->IsWithinDistInMap(who, 100.0f))
-                {
-                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                    bIntroDone = true;
-                    DoScriptText(SAY_INTRO_1, me);
-                    events.SetPhase(PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_2, 11000, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_3, 21000, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_4, 31500, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_5, 39500, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_6, 48500, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_7, 58000, 0, PHASE_INTRO);
-                    events.ScheduleEvent(EVENT_INTRO_FINISH, 76000, 0, PHASE_INTRO);
-                }
+                DoScriptText(SAY_AGGRO, me);
+                me->RemoveAurasDueToSpell(SPELL_SHADOW_CHANNELING);
+
+                bCombat = true;
+
+                if (pInstance)
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, IN_PROGRESS);
             }
 
-            void AttackStart(Unit* victim)
-            {
-                if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
-                    return;
-
-                if (victim && me->Attack(victim, true) && !(events.GetPhaseMask() & PHASE_ONE_MASK))
-                    me->GetMotionMaster()->MoveChase(victim);
-            }
-
-            void EnterCombat(Unit* who)
-            {
-                events.Reset();
-                events.SetPhase(PHASE_ONE);
-                // phase-independent events
-                events.ScheduleEvent(EVENT_BERSERK, 600000);
-                events.ScheduleEvent(EVENT_DEATH_AND_DECAY, 10000);
-                // phase one only
-                events.ScheduleEvent(EVENT_P1_SUMMON_WAVE, 5000, 0, PHASE_ONE);
-                events.ScheduleEvent(EVENT_P1_SHADOW_BOLT, urand(5500, 6000), 0, PHASE_ONE);
-                events.ScheduleEvent(EVENT_P1_EMPOWER_CULTIST, urand(20000, 30000), 0, PHASE_ONE);
-                if (getDifficulty() != RAID_DIFFICULTY_10MAN_NORMAL)
-                    events.ScheduleEvent(EVENT_DOMINATE_MIND_H, 27000);
-
-                DoScriptText(SAY_AGGRO, me);
-                DoStartNoMovement(who);
-                me->RemoveAurasDueToSpell(SPELL_SHADOW_CHANNELING);
-                DoCast(me, SPELL_MANA_BARRIER, true);
-
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, IN_PROGRESS);
-            }
-
-            void JustDied(Unit* killer)
+            void JustDied(Unit* /*pKiller*/)
             {
                 DoScriptText(SAY_DEATH, me);
 
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, DONE);
-
-                std::set<uint32> livingAddEntries;
-                // Full House achievement
-                for (SummonList::iterator itr = summons.begin(); itr != summons.end(); ++itr)
-                    if (Unit* unit = ObjectAccessor::GetUnit(*me, *itr))
-                        if (unit->isAlive() && unit->GetEntry() != NPC_VENGEFUL_SHADE)
-                            livingAddEntries.insert(unit->GetEntry());
-
-                if (livingAddEntries.size() >= 5)
-                {
-                    if (Player *player = killer->GetCharmerOrOwnerPlayerOrPlayerItself())
-                    {
-                        if (Group* group = player->GetGroup())
-                        {
-                            for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
-                            {
-                                Player* member = itr->getSource();
-                                if (!member || !member->IsAtGroupRewardDistance(me))
-                                    continue;
-
-                                if (member->isAlive()|| !member->GetCorpse())
-                                    member->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_FULL_HOUSE, 0, me);
-                            }
-                        }
-                        else
-                            player->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, SPELL_FULL_HOUSE, 0, me);
-                    }
-                }
+                if (pInstance)
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, DONE);
 
                 summons.DespawnAll();
             }
 
             void JustReachedHome()
             {
-                instance->SetBossState(DATA_LADY_DEATHWHISPER, FAIL);
+                if(pInstance)
+                    pInstance->SetData(DATA_DEATHWHISPER_EVENT, FAIL);
 
                 summons.DespawnAll();
             }
 
-            void KilledUnit(Unit *victim)
+            void KilledUnit(Unit* pVictim)
             {
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
+                if (pVictim->GetTypeId() == TYPEID_PLAYER)
+                {
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
+                }
+            }
+
+            void MoveInLineOfSight(Unit *pWho)
+            {
+                if (!bIntro && me->IsWithinDistInMap(pWho, 100.0f, true))
+                {
+                    DoScriptText(SAY_INTRO_1, me);
+                    m_uiIntroTimer = 11000;
+                    bIntro = true;
+                }
+            }
+
+            void JustSummoned(Creature* pSummon)
+            {
+                DoCast(pSummon, SPELL_PORT_VISUAL);
+
+                pSummon->AddThreat(me->getVictim(), 1000.0f);
+                pSummon->GetMotionMaster()->MovePoint(1, SpawnLoc[7]);
+                summons.Summon(pSummon);
+            }
+
+            void RandomSpawn()
+            {
+                switch(m_uiStage)
+                {
+                    case 1:
+                        pSummoned = DoSummon(CREATURE_FANATIC, SpawnLoc[0]);
+                        pSummoned = DoSummon(CREATURE_ADHERENT, SpawnLoc[1]);
+                        pSummoned = DoSummon(CREATURE_FANATIC, SpawnLoc[2]);
+                        ++m_uiStage;
+                        break;
+                    case 2:
+                        pSummoned = DoSummon(CREATURE_ADHERENT, SpawnLoc[3]);
+                        pSummoned = DoSummon(CREATURE_FANATIC, SpawnLoc[4]);
+                        pSummoned = DoSummon(CREATURE_ADHERENT, SpawnLoc[5]);
+                        --m_uiStage;
+                        break;
+                }
             }
 
             void DamageTaken(Unit* /*damageDealer*/, uint32& uiDamage)
             {
-                // phase transition
-                if (events.GetPhaseMask() & PHASE_ONE_MASK && uiDamage > me->GetPower(POWER_MANA))
+                if(!me->HasAura(SPELL_MANA_BARRIER) && m_uiPhase == 1)
                 {
-                    DoScriptText(SAY_PHASE_2, me);
-                    DoScriptText(SAY_PHASE_2_EMOTE, me);
-                    DoStartMovement(me->getVictim());
-                    me->SetPower(POWER_MANA, 0);
-                    uiDamage -= me->GetPower(POWER_MANA);
-                    me->RemoveAurasDueToSpell(SPELL_MANA_BARRIER);
-                    events.SetPhase(PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_FROSTBOLT, urand(10000, 12000), 0, PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_FROSTBOLT_VOLLEY, urand(19000, 21000), 0, PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_TOUCH_OF_INSIGNIFICANCE, urand(6000, 9000), 0, PHASE_TWO);
-                    events.ScheduleEvent(EVENT_P2_SUMMON_SHADE, urand(12000, 15000), 0, PHASE_TWO);
-                    // on heroic mode Lady Deathwhisper is immune to taunt effects in phase 2 and continues summoning adds
-                    if (IsHeroic())
-                    {
-                        me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
-                        me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
-                        events.ScheduleEvent(EVENT_P2_SUMMON_WAVE, urand(30000, 60000), 0, PHASE_TWO);
-                    }
-                }
-            }
-
-            void JustSummoned(Creature* summon)
-            {
-                summons.push_back(summon->GetGUID());
-                Unit* target = NULL;
-                if (summon->GetEntry() == NPC_VENGEFUL_SHADE)
-                {
-                    target = ObjectAccessor::GetUnit(*me, uiNextVengefulShadeTarget);   // Vengeful Shade
-                    uiNextVengefulShadeTarget = 0;
-                }
-                else
-                    target = SelectTarget(SELECT_TARGET_RANDOM);                        // Wave adds
-
-                summon->AI()->AttackStart(target);                                      // CAN be NULL
-                if (summon->GetEntry() == NPC_REANIMATED_FANATIC)
-                    summon->AI()->DoCast(summon, SPELL_FANATIC_S_DETERMINATION);
-                else if (summon->GetEntry() == NPC_REANIMATED_ADHERENT)
-                    summon->AI()->DoCast(summon, SPELL_ADHERENT_S_DETERMINATION);
-            }
-
-            void SummonedCreatureDespawn(Creature* summon)
-            {
-                summons.remove(summon->GetGUID());
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                if ((!UpdateVictim() && !(events.GetPhaseMask() & PHASE_INTRO_MASK)) || !CheckInRoom())
-                    return;
-
-                events.Update(diff);
-
-                if (me->hasUnitState(UNIT_STAT_CASTING) && !(events.GetPhaseMask() & PHASE_INTRO_MASK))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_INTRO_2:
-                            DoScriptText(SAY_INTRO_2, me);
-                            break;
-                        case EVENT_INTRO_3:
-                            DoScriptText(SAY_INTRO_3, me);
-                            break;
-                        case EVENT_INTRO_4:
-                            DoScriptText(SAY_INTRO_4, me);
-                            break;
-                        case EVENT_INTRO_5:
-                            DoScriptText(SAY_INTRO_5, me);
-                            break;
-                        case EVENT_INTRO_6:
-                            DoScriptText(SAY_INTRO_6, me);
-                            break;
-                        case EVENT_INTRO_7:
-                            DoScriptText(SAY_INTRO_7, me);
-                            break;
-                        case EVENT_INTRO_FINISH:
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                            break;
-                        case EVENT_DEATH_AND_DECAY:
-                            if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM))
-                                DoCast(pTarget, SPELL_DEATH_AND_DECAY);
-                            events.ScheduleEvent(EVENT_DEATH_AND_DECAY, urand(10000, 12000));
-                            break;
-                        case EVENT_DOMINATE_MIND_H:
-                            DoScriptText(SAY_DOMINATE_MIND, me);
-                            for (uint8 i = 0; i < uiDominateMindCount; i++)
-                                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 0.0f, true, -SPELL_DOMINATE_MIND_H))
-                                    DoCast(target, SPELL_DOMINATE_MIND_H);
-                            events.ScheduleEvent(EVENT_DOMINATE_MIND_H, urand(18000, 22000));
-                            break;
-                        case EVENT_P1_SUMMON_WAVE:
-                            SummonWaveP1();
-                            events.ScheduleEvent(EVENT_P1_SUMMON_WAVE, 60000, 0, PHASE_ONE);
-                            break;
-                        case EVENT_P1_SHADOW_BOLT:
-                            if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM))
-                                DoCast(pTarget, SPELL_SHADOW_BOLT);
-                            events.ScheduleEvent(EVENT_P1_SHADOW_BOLT, urand(5000, 8000), 0, PHASE_ONE);
-                            break;
-                        case EVENT_P1_REANIMATE_CULTIST:
-                            ReanimateCultist();
-                            break;
-                        case EVENT_P1_EMPOWER_CULTIST:
-                            EmpowerCultist();
-                            events.ScheduleEvent(EVENT_P1_EMPOWER_CULTIST, urand(18000, 25000));
-                            break;
-                        case EVENT_P2_FROSTBOLT:
-                            DoCastVictim(SPELL_FROSTBOLT);
-                            events.ScheduleEvent(EVENT_P2_FROSTBOLT, urand(10000, 11000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_FROSTBOLT_VOLLEY:
-                            DoCastAOE(SPELL_FROSTBOLT_VOLLEY);
-                            events.ScheduleEvent(EVENT_P2_FROSTBOLT_VOLLEY, urand(13000, 15000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_TOUCH_OF_INSIGNIFICANCE:
-                            DoCastVictim(SPELL_TOUCH_OF_INSIGNIFICANCE);
-                            events.ScheduleEvent(EVENT_P2_TOUCH_OF_INSIGNIFICANCE, urand(9000, 13000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_SUMMON_SHADE:
-                            if (Unit* pShadeTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                            {
-                                uiNextVengefulShadeTarget = pShadeTarget->GetGUID();
-                                DoCast(pShadeTarget, SPELL_SUMMON_SHADE);
-                            }
-                            events.ScheduleEvent(EVENT_P2_SUMMON_SHADE, urand(18000, 23000), 0, PHASE_TWO);
-                            break;
-                        case EVENT_P2_SUMMON_WAVE:
-                            SummonWaveP2();
-                            events.ScheduleEvent(EVENT_P2_SUMMON_WAVE, 60000, 0, PHASE_TWO);
-                            break;
-                        case EVENT_BERSERK:
-                            DoCast(me, SPELL_BERSERK);
-                            DoScriptText(SAY_BERSERK, me);
-                            break;
-                    }
+                    me->CastSpell(me, SPELL_MANA_BARRIER, true);
                 }
 
-                // We should not melee attack when barrier is up
-                if (me->HasAura(SPELL_MANA_BARRIER))
-                    return;
+                if(me->HasAura(SPELL_MANA_BARRIER))
+                {
+                    me->SetHealth(me->GetHealth() +uiDamage);
+                    me->SetPower(POWER_MANA, (me->GetPower(POWER_MANA) -uiDamage));
 
-                DoMeleeAttackIfReady();
-            }
+                    if(uiDamage > me->GetPower(POWER_MANA) && m_uiPhase == 1)
+                    {
+                        DoScriptText(SAY_PHASE_2, me);
+                        DoScriptText(EMOTE_PHASE_2, me);
+                        me->SetPower(POWER_MANA, 0);
+                        me->RemoveAurasDueToSpell(SPELL_MANA_BARRIER);
+                        DoResetThreat();
+                        m_uiPhase = 2;
+                    }
 
-            // summoning function for first phase
-            void SummonWaveP1()
-            {
-                uint8 addIndex = uiAddWaveCounter & 1;
-                uint8 addIndexOther = addIndex ^ 1;
-                _SummonAdd(uiAddEntries[addIndex], addSpawnPos[addIndex*3]);
-                _SummonAdd(uiAddEntries[addIndexOther], addSpawnPos[addIndex*3+1]);
-                _SummonAdd(uiAddEntries[addIndex], addSpawnPos[addIndex*3+2]);
-                if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL || getDifficulty() == RAID_DIFFICULTY_25MAN_HEROIC)
-                {
-                    _SummonAdd(uiAddEntries[addIndexOther], addSpawnPos[addIndexOther*3]);
-                    _SummonAdd(uiAddEntries[addIndex], addSpawnPos[addIndexOther*3+1]);
-                    _SummonAdd(uiAddEntries[addIndexOther], addSpawnPos[addIndexOther*3+2]);
-                    _SummonAdd(uiAddEntries[urand(0,1)], addSpawnPos[6]);
-                }
-                ++uiAddWaveCounter;
-            }
-
-            // summoning function for second phase
-            void SummonWaveP2()
-            {
-                if (getDifficulty() == RAID_DIFFICULTY_25MAN_HEROIC)
-                {
-                    uint8 addIndex = uiAddWaveCounter & 1;
-                    _SummonAdd(uiAddEntries[addIndex], addSpawnPos[addIndex*3]);
-                    _SummonAdd(uiAddEntries[addIndex ^ 1], addSpawnPos[addIndex*3+1]);
-                    _SummonAdd(uiAddEntries[addIndex], addSpawnPos[addIndex*3+2]);
-                }
-                else
-                    _SummonAdd(uiAddEntries[urand(0,1)], addSpawnPos[6]);
-                ++uiAddWaveCounter;
-            }
-
-            // helper for summoning wave mobs
-            void _SummonAdd(uint32 entry, const Position& pos)
-            {
-                if (TempSummon* summon = me->SummonCreature(entry, pos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000))
-                    summon->AI()->DoCast(summon, SPELL_TELEPORT_VISUAL);
-            }
-
-            void AddToReanimationQueue(Unit* summon)
-            {
-                reanimationQueue.push_back(summon->GetGUID());
-                events.ScheduleEvent(EVENT_P1_REANIMATE_CULTIST, 3000, 0, PHASE_ONE);
-            }
-
-            void ReanimateCultist()
-            {
-                if (reanimationQueue.empty())
-                    return;
-
-                uint64 cultistGUID = reanimationQueue.front();
-                Creature* cultist = ObjectAccessor::GetCreature(*me, cultistGUID);
-                reanimationQueue.pop_front();
-                if (!cultist)
-                    return;
-
-                DoScriptText(SAY_ANIMATE_DEAD, me);
-                DoCast(cultist, SPELL_DARK_MARTYRDOM_T);
-            }
-
-            void SpellHitTarget(Unit * target, const SpellEntry * spell)
-            {
-                if (spell->Id == SPELL_DARK_MARTYRDOM_T)
-                {
-                    Position pos;
-                    target->GetPosition(&pos);
-                    if (target->GetEntry() == NPC_CULT_FANATIC)
-                        me->SummonCreature(NPC_REANIMATED_FANATIC, pos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000);
-                    else
-                        me->SummonCreature(NPC_REANIMATED_ADHERENT, pos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000);
-
-                    if (TempSummon* summon = target->ToTempSummon())
-                        summon->UnSummon();
+                    if (IsHeroic())
+                        me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
                 }
             }
 
@@ -517,28 +237,164 @@
                 std::list<Creature*> tmpList;
                 for (SummonList::iterator itr = summons.begin(); itr != summons.end(); ++itr)
                     if (Creature* cre = ObjectAccessor::GetCreature(*me, *itr))
-                        if (cre->isAlive() && (cre->GetEntry() == NPC_CULT_FANATIC || cre->GetEntry() == NPC_CULT_ADHERENT))
+                        if (cre->isAlive() && (cre->GetEntry() == CREATURE_FANATIC || cre->GetEntry() == CREATURE_ADHERENT))
                             tmpList.push_back(cre);
 
-                // noone to empower
                 if (tmpList.empty())
                     return;
 
-                // select random cultist
                 std::list<Creature*>::iterator cultistItr = tmpList.begin();
                 std::advance(cultistItr, urand(0, tmpList.size()-1));
 
                 Creature* cultist = *cultistItr;
-                DoCast(cultist, cultist->GetEntry() == NPC_CULT_FANATIC ? SPELL_DARK_TRANSFORMATION_T : SPELL_DARK_EMPOWERMENT_T, true);
-                DoScriptText(cultist->GetEntry() == NPC_CULT_FANATIC ? SAY_DARK_TRANSFORMATION : SAY_DARK_EMPOWERMENT, me);
+                DoCast(cultist, cultist->GetEntry() == CREATURE_FANATIC ? SPELL_TRANSFORMATION_T : SPELL_EMPOWERMENT_T, true);
+                DoScriptText(cultist->GetEntry() == CREATURE_FANATIC ? SAY_TRANSFORMATION : SAY_EMPOWERMENT, me);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (m_uiIntroTimer <= uiDiff && bIntro && m_uiIntroPhase < 7)
+                {
+                    switch (m_uiIntroPhase)
+                    {
+                        case 1: DoScriptText(SAY_INTRO_2, me); m_uiIntroTimer = 10000; break;
+                        case 2: DoScriptText(SAY_INTRO_3, me); m_uiIntroTimer = 7000;  break;
+                        case 3: DoScriptText(SAY_INTRO_4, me); m_uiIntroTimer = 12000; break;
+                        case 4: DoScriptText(SAY_INTRO_5, me); m_uiIntroTimer = 7000;  break;
+                        case 5: DoScriptText(SAY_INTRO_6, me); m_uiIntroTimer = 11000; break;
+                        case 6: DoScriptText(SAY_INTRO_7, me); m_uiIntroTimer = 20000; break;
+                    }
+                    ++m_uiIntroPhase;
+                } else m_uiIntroTimer -= uiDiff;
+
+                if(bCombat == true)
+                {
+                    if (m_uiBerserkTimer < uiDiff)
+                    {
+                        DoCast(me, SPELL_BERSERK);
+                        DoScriptText(SAY_BERSERK, me);
+                        m_uiBerserkTimer = 600000;
+                    } else m_uiBerserkTimer -= uiDiff;
+
+                    if (m_uiCultTimer < uiDiff)
+                    {
+                        EmpowerCultist();
+                        m_uiCultTimer = urand(20000, 23000);
+                    } else m_uiCultTimer -= uiDiff;
+
+                    if (m_uiDeathandDecayTimer < uiDiff)
+                    {
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            DoCast(pTarget, SPELL_DEATH_AND_DECAY);
+                        m_uiDeathandDecayTimer = 11000;
+                    } else m_uiDeathandDecayTimer -= uiDiff;
+
+                    if (m_uiDominateMindTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= m_uiCount; i++)
+                        {
+                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            {
+                                DoCast(pTarget, SPELL_DOMINATE_MIND);
+                                DoScriptText(SAY_DOMINATE_MIND, me);
+                            }
+                        }
+                        m_uiDominateMindTimer = 15000;
+                    } else m_uiDominateMindTimer -= uiDiff;
+
+                    if (m_uiPhase == 1)
+                    {
+                        if (m_uiShadowBoltTimer < uiDiff)
+                        {
+                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                                DoCast(pTarget, SPELL_SHADOW_BOLT);
+                            m_uiShadowBoltTimer = 6000;
+                        } else m_uiShadowBoltTimer -= uiDiff;
+
+                        if (m_uiSummonWaveTimer < uiDiff)
+                        {
+                            if (Difficulty() == RAID_DIFFICULTY_10MAN_NORMAL || Difficulty() == RAID_DIFFICULTY_10MAN_HEROIC)
+                                RandomSpawn();
+                            else
+                            {
+                                pSummoned = DoSummon(CREATURE_FANATIC, SpawnLoc[0]);
+                                pSummoned = DoSummon(CREATURE_ADHERENT, SpawnLoc[1]);
+                                pSummoned = DoSummon(CREATURE_FANATIC, SpawnLoc[2]);
+                                pSummoned = DoSummon(CREATURE_ADHERENT, SpawnLoc[3]);
+                                pSummoned = DoSummon(CREATURE_FANATIC, SpawnLoc[4]);
+                                pSummoned = DoSummon(CREATURE_ADHERENT, SpawnLoc[5]);
+                                pSummoned = DoSummon(RAND(CREATURE_FANATIC,CREATURE_ADHERENT), SpawnLoc[6]);
+                            }
+                                bFirstSummon = false ? true : true;
+                            m_uiSummonWaveTimer = !bFirstSummon ? 10000 : 60000;
+                        } else m_uiSummonWaveTimer -= uiDiff;
+                    }
+
+                    if (m_uiPhase == 2)
+                    {
+                        if (m_uiFrostBoltTimer < uiDiff)
+                        {
+                            DoCast(me->getVictim(), SPELL_FROST_BOLT);
+                            m_uiFrostBoltTimer = 10000;
+                        } else m_uiFrostBoltTimer -= uiDiff;
+
+                        if (m_uiFrostValleyTimer < uiDiff)
+                        {
+                            DoCast(SPELL_FROST_BOLT_VALLEY);
+                            m_uiFrostValleyTimer = 19000;
+                        } else m_uiFrostValleyTimer -= uiDiff;
+
+                        if (m_uiInsignificanceTimer < uiDiff)
+                        {
+                            DoCast(me->getVictim(), SPELL_INSIGNIFICANCE);
+                            m_uiInsignificanceTimer = 8000;
+                        } else m_uiInsignificanceTimer -= uiDiff;
+
+                        if (m_uiSummonWaveTimer < uiDiff)
+                        {
+                            if (Difficulty() == RAID_DIFFICULTY_10MAN_HEROIC)
+                                pSummoned = DoSummon(RAND(CREATURE_FANATIC,CREATURE_ADHERENT), SpawnLoc[6]);
+                            if (Difficulty() == RAID_DIFFICULTY_25MAN_HEROIC)
+                                RandomSpawn();
+                            m_uiSummonWaveTimer = 60000;
+                        } else m_uiSummonWaveTimer -= uiDiff;
+
+                        if (m_uiShadeTimer < uiDiff)
+                        {
+                            DoCast(SPELL_SUMMON_SHADE);
+                            m_uiShadeTimer = 15000;
+                        } else m_uiShadeTimer -= uiDiff;
+
+                        DoMeleeAttackIfReady();
+                    }
+                }
             }
 
         private:
-            bool bIntroDone;
-            uint32 uiAddWaveCounter;
-            uint64 uiNextVengefulShadeTarget;
-            std::deque<uint64> reanimationQueue;
-            uint8 uiDominateMindCount;
+            InstanceScript* pInstance;
+
+            uint8 m_uiPhase;
+            uint8 m_uiIntroPhase;
+            uint8 m_uiStage;
+            uint8 m_uiCount;
+            uint32 m_uiDominateMindTimer;
+            uint32 m_uiSummonWaveTimer;
+            uint32 m_uiDeathandDecayTimer;
+            uint32 m_uiFrostBoltTimer;
+            uint32 m_uiFrostValleyTimer;
+            uint32 m_uiShadowBoltTimer;
+            uint32 m_uiBerserkTimer;
+            uint32 m_uiInsignificanceTimer;
+            uint32 m_uiShadeTimer;
+            uint32 m_uiCultTimer;
+            uint32 m_uiIntroTimer;
+
+            bool bIntro;
+            bool bCombat;
+            bool bFirstSummon;
+
+            SummonList summons;
+            Unit *pSummoned;
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
@@ -547,276 +403,43 @@
         }
 };
 
-class npc_cult_fanatic : public CreatureScript
+class npc_shade : public CreatureScript
 {
     public:
-        npc_cult_fanatic() : CreatureScript("npc_cult_fanatic") { }
+        npc_shade() : CreatureScript("npc_shade") { }
 
-        struct npc_cult_fanaticAI : public ScriptedAI
+        struct npc_shadeAI : public ScriptedAI
         {
-            npc_cult_fanaticAI(Creature* pCreature) : ScriptedAI(pCreature) {}
+            npc_shadeAI(Creature* pCreature) : ScriptedAI(pCreature) { }
 
             void Reset()
             {
-                events.Reset();
-                events.ScheduleEvent(EVENT_FANATIC_NECROTIC_STRIKE, urand(10000, 12000));
-                events.ScheduleEvent(EVENT_FANATIC_SHADOW_CLEAVE, urand(14000, 16000));
-                events.ScheduleEvent(EVENT_FANATIC_VAMPIRIC_MIGHT, urand(20000, 27000));
-                if (me->GetEntry() == NPC_CULT_FANATIC)
-                    events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(18000, 32000));
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                me->SetInCombatWithZone();
+                DoCast(me, SPELL_BLAST);
             }
 
-            void SpellHit(Unit* /*caster*/, const SpellEntry * spell)
+            void SpellHitTarget(Unit * /*pTarget*/, const SpellEntry *spell)
             {
-                if (spell->Id == SPELL_DARK_TRANSFORMATION)
-                    me->UpdateEntry(NPC_DEFORMED_FANATIC);
-                else if (spell->Id == SPELL_DARK_TRANSFORMATION_T)
-                {
-                    events.CancelEvent(EVENT_CULTIST_DARK_MARTYRDOM);
-                    me->InterruptNonMeleeSpells(true);
-                    DoCast(me, SPELL_DARK_TRANSFORMATION);
-                }
+                if (spell->Id == SPELL_VENGEFUL_BLAST)
+                    me->ForcedDespawn();
             }
 
-            void UpdateAI(const uint32 diff)
+            void UpdateAI(const uint32 /*uiDiff*/)
             {
-                if (!UpdateVictim())
-                    return;
-
-                events.Update(diff);
-
-                if (me->hasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_FANATIC_NECROTIC_STRIKE:
-                            DoCastVictim(SPELL_NECROTIC_STRIKE);
-                            events.ScheduleEvent(SPELL_NECROTIC_STRIKE, urand(11000, 13000));
-                            break;
-                        case EVENT_FANATIC_SHADOW_CLEAVE:
-                            DoCastVictim(SPELL_SHADOW_CLEAVE);
-                            events.ScheduleEvent(EVENT_FANATIC_SHADOW_CLEAVE, urand(9500, 11000));
-                            break;
-                        case EVENT_FANATIC_VAMPIRIC_MIGHT:
-                            DoCast(me, SPELL_VAMPIRIC_MIGHT);
-                            events.ScheduleEvent(EVENT_FANATIC_VAMPIRIC_MIGHT, urand(20000, 27000));
-                            break;
-                        case EVENT_CULTIST_DARK_MARTYRDOM:
-                            DoCast(me, SPELL_DARK_MARTYRDOM_FANATIC);
-                            events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(16000, 21000));
-                            break;
-                    }
-                }
-
                 DoMeleeAttackIfReady();
             }
-
-        private:
-            EventMap events;
-        };
-
-        CreatureAI* GetAI(Creature* pCreature) const
-        {
-            return new npc_cult_fanaticAI(pCreature);
-        }
-};
-
-class npc_cult_adherent : public CreatureScript
-{
-    public:
-        npc_cult_adherent() : CreatureScript("npc_cult_adherent") { }
-
-        struct npc_cult_adherentAI : public ScriptedAI
-        {
-            npc_cult_adherentAI(Creature* pCreature) : ScriptedAI(pCreature) {}
-
-            void Reset()
-            {
-                events.Reset();
-                events.ScheduleEvent(EVENT_ADHERENT_FROST_FEVER, urand(10000, 12000));
-                events.ScheduleEvent(EVENT_ADHERENT_DEATHCHILL, urand(14000, 16000));
-                events.ScheduleEvent(EVENT_ADHERENT_CURSE_OF_TORPOR, urand(14000, 16000));
-                events.ScheduleEvent(EVENT_ADHERENT_SHORUD_OF_THE_OCCULT, urand(32000, 39000));
-                if (me->GetEntry() == NPC_CULT_ADHERENT)
-                    events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(18000, 32000));
-            }
-
-            void SpellHit(Unit* /*caster*/, const SpellEntry * spell)
-            {
-                if (spell->Id == SPELL_DARK_EMPOWERMENT)
-                    me->UpdateEntry(NPC_EMPOWERED_ADHERENT);
-                else if (spell->Id == SPELL_DARK_EMPOWERMENT_T)
-                {
-                    events.CancelEvent(EVENT_CULTIST_DARK_MARTYRDOM);
-                    me->InterruptNonMeleeSpells(true);
-                    DoCast(me, SPELL_DARK_EMPOWERMENT);
-                }
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim())
-                    return;
-
-                events.Update(diff);
-
-                if (me->hasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_ADHERENT_FROST_FEVER:
-                            DoCastVictim(SPELL_FROST_FEVER);
-                            events.ScheduleEvent(EVENT_ADHERENT_FROST_FEVER, urand(9000, 13000));
-                            break;
-                        case EVENT_ADHERENT_DEATHCHILL:
-                            if (me->GetEntry() == NPC_EMPOWERED_ADHERENT)
-                                DoCastVictim(SPELL_DEATHCHILL_BLAST);
-                            else
-                                DoCastVictim(SPELL_DEATHCHILL_BOLT);
-                            events.ScheduleEvent(EVENT_ADHERENT_DEATHCHILL, urand(9000, 13000));
-                            break;
-                        case EVENT_ADHERENT_CURSE_OF_TORPOR:
-                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                                DoCast(pTarget, SPELL_CURSE_OF_TORPOR);
-                            events.ScheduleEvent(EVENT_ADHERENT_CURSE_OF_TORPOR, urand(9000, 13000));
-                            break;
-                        case EVENT_ADHERENT_SHORUD_OF_THE_OCCULT:
-                            DoCast(me, SPELL_SHORUD_OF_THE_OCCULT);
-                            events.ScheduleEvent(EVENT_ADHERENT_SHORUD_OF_THE_OCCULT, urand(27000, 32000));
-                            break;
-                        case EVENT_CULTIST_DARK_MARTYRDOM:
-                            DoCast(me, SPELL_DARK_MARTYRDOM_ADHERENT);
-                            events.ScheduleEvent(EVENT_CULTIST_DARK_MARTYRDOM, urand(16000, 21000));
-                            break;
-                    }
-                }
-
-                DoMeleeAttackIfReady();
-            }
-
-        private:
-            EventMap events;
-        };
-
-        CreatureAI* GetAI(Creature* pCreature) const
-        {
-            return new npc_cult_adherentAI(pCreature);
-        }
-};
-
-class npc_vengeful_shade : public CreatureScript
-{
-    public:
-        npc_vengeful_shade() : CreatureScript("npc_vengeful_shade") { }
-
-        struct npc_vengeful_shadeAI : public ScriptedAI
-        {
-            npc_vengeful_shadeAI(Creature* pCreature) : ScriptedAI(pCreature)
-            {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-            }
-
-            void Reset()
-            {
-                me->AddAura(SPELL_VENGEFUL_BLAST_PASSIVE, me);
-            }
-
-            void SpellHitTarget(Unit * /*pTarget*/, const SpellEntry * spell)
-            {
-                if (spell->Id == SPELL_VENGEFUL_BLAST)
-                    me->Kill(me);
-            }
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new npc_vengeful_shadeAI(pCreature);
-        }
-};
-
-class spell_deathwhisper_mana_barrier : public SpellScriptLoader
-{
-    public:
-        spell_deathwhisper_mana_barrier() : SpellScriptLoader("spell_deathwhisper_mana_barrier") { }
-
-        class spell_deathwhisper_mana_barrier_AuraScript : public AuraScript
-        {
-			PrepareAuraScript(spell_deathwhisper_mana_barrier_AuraScript)
-            void HandlePeriodicTick(AuraEffect const * /*aurEff*/, AuraApplication const * /*aurApp*/)
-            {
-                Unit* caster = GetCaster();
-                int32 missingHealth = caster->GetMaxHealth() - caster->GetHealth();
-                caster->ModifyHealth(missingHealth);
-                caster->ModifyPower(POWER_MANA, -missingHealth);
-                PreventDefaultAction();
-            }
-
-            void Register()
-            {
-                OnEffectPeriodic += AuraEffectPeriodicFn(spell_deathwhisper_mana_barrier_AuraScript::HandlePeriodicTick, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);
-            }
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_deathwhisper_mana_barrier_AuraScript();
-        }
-};
-
-class spell_cultist_dark_martyrdom : public SpellScriptLoader
-{
-    public:
-        spell_cultist_dark_martyrdom() : SpellScriptLoader("spell_cultist_dark_martyrdom") { }
-
-        class spell_cultist_dark_martyrdom_SpellScript : public SpellScript
-        {
-				PrepareSpellScript(spell_cultist_dark_martyrdom_SpellScript)
-            bool Validate(SpellEntry const* /*spellEntry*/)
-            {
-                if (uint32 scriptId = sObjectMgr.GetScriptId("boss_lady_deathwhisper"))
-                    if (CreatureInfo const* creInfo = ObjectMgr::GetCreatureTemplate(NPC_LADY_DEATHWHISPER))
-                        if (creInfo->ScriptID == scriptId)
-                            return true;
-
-                return false;
-            }
-
-            void HandleEffect(SpellEffIndex /*effIndex*/)
-            {
-                if (GetCaster()->isSummon())
-                    if (Unit* owner = GetCaster()->ToTempSummon()->GetSummoner())
-                        if (owner->GetEntry() == NPC_LADY_DEATHWHISPER)
-                            CAST_AI(boss_lady_deathwhisper::boss_lady_deathwhisperAI, owner->ToCreature()->AI())->AddToReanimationQueue(GetCaster());
-
-                GetCaster()->Kill(GetCaster());
-                GetCaster()->SetDisplayId(GetCaster()->GetEntry() == NPC_CULT_FANATIC ? 38009 : 38010);
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_cultist_dark_martyrdom_SpellScript::HandleEffect, EFFECT_2, SPELL_EFFECT_FORCE_DESELECT);
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_cultist_dark_martyrdom_SpellScript();
+            return new npc_shadeAI(pCreature);
         }
 };
 
 void AddSC_boss_lady_deathwhisper()
 {
     new boss_lady_deathwhisper();
-    new npc_cult_fanatic();
-    new npc_cult_adherent();
-    new npc_vengeful_shade();
-    new spell_deathwhisper_mana_barrier();
-    new spell_cultist_dark_martyrdom();
+    new npc_shade();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_lord_marrowgar.cpp
@@ -1,331 +1,47 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
-#include "MapManager.h"
-#include "Spell.h"
 
-enum eScriptTexts
+enum Yells
 {
-    SAY_ENTER_ZONE              = -1631000,
-    SAY_AGGRO                   = -1631001,
-    SAY_BONE_STORM              = -1631002,
-    SAY_BONESPIKE_1             = -1631003,
-    SAY_BONESPIKE_2             = -1631004,
-    SAY_BONESPIKE_3             = -1631005,
-    SAY_KILL_1                  = -1631006,
-    SAY_KILL_2                  = -1631007,
-    SAY_DEATH                   = -1631008,
-    SAY_BERSERK                 = -1631009,
-    SAY_BONE_STORM_EMOTE        = -1631010
+    SAY_INTRO     = -1631000,
+    SAY_AGGRO     = -1631001,
+    SAY_STORM     = -1631002,
+    SAY_SPIKE_1   = -1631003,
+    SAY_SPIKE_2   = -1631004,
+    SAY_SPIKE_3   = -1631005,
+    SAY_KILL_1    = -1631006,
+    SAY_KILL_2    = -1631007,
+    SAY_DEATH     = -1631008,
+    SAY_BERSERK   = -1631009,
+    STORM_EMOTE   = -1631010
 };
 
-enum eSpells
+enum Spells
 {
-    // Lord Marrowgar
-    SPELL_BONE_SLICE            = 69055,
-    SPELL_BONE_STORM            = 69076,
-    SPELL_BONE_SPIKE_GRAVEYARD  = 69057,
-    SPELL_COLDFLAME_NORMAL      = 69140,
-    SPELL_COLDFLAME_BONE_STORM  = 72705,
-
-    // Bone Spike
-    SPELL_IMPALED               = 69065,
-
-    // Coldflame
-    SPELL_COLDFLAME_PASSIVE     = 69145,
-};
-
-enum eEvents
-{
-    EVENT_BONE_SPIKE_GRAVEYARD  = 1,
-    EVENT_COLDFLAME             = 2,
-    EVENT_BONE_STORM_BEGIN      = 3,
-    EVENT_BONE_STORM_MOVE       = 4,
-    EVENT_BONE_STORM_END        = 5,
-    EVENT_ENABLE_BONE_SLICE     = 6,
-    EVENT_ENRAGE                = 7,
-    EVENT_WARN_BONE_STORM       = 8,
-
-    EVENT_COLDFLAME_TRIGGER     = 9,
-    EVENT_FAIL_BONED            = 10
-};
-
-enum eMovementPoints
-{
-    POINT_TARGET_BONESTORM_PLAYER   = 36612631, // entry+mapid
-    POINT_TARGET_COLDFLAME          = 36672631
-};
-
-class boss_lord_marrowgar : public CreatureScript
-{
-    public:
-        boss_lord_marrowgar() : CreatureScript("boss_lord_marrowgar") { }
-
-        struct boss_lord_marrowgarAI : public BossAI
-        {
-            boss_lord_marrowgarAI(Creature *pCreature) : BossAI(pCreature, DATA_LORD_MARROWGAR)
-            {
-                ASSERT(instance);
-                bIntroDone = false;
-                uiBoneStormDuration = RAID_MODE(20000,30000,20000,30000);
-                fBaseSpeed = pCreature->GetSpeedRate(MOVE_RUN);
-                bBoneSlice = false;
-                coldflameLastPos.Relocate(pCreature);
-            }
-
-            void Reset()
-            {
-                me->SetSpeed(MOVE_RUN, fBaseSpeed, true);
-                me->RemoveAurasDueToSpell(SPELL_BONE_STORM);
-                me->RemoveAurasDueToSpell(SPELL_BERSERK);
-                events.Reset();
-                events.ScheduleEvent(EVENT_ENABLE_BONE_SLICE, 10000);
-                events.ScheduleEvent(EVENT_BONE_SPIKE_GRAVEYARD, urand(20000, 30000));
-                events.ScheduleEvent(EVENT_COLDFLAME, urand(10000, 15000));
-                events.ScheduleEvent(EVENT_WARN_BONE_STORM, urand(35000, 50000));
-                events.ScheduleEvent(EVENT_ENRAGE, 600000);
-                instance->SetData(DATA_LORD_MARROWGAR, NOT_STARTED);
-            }
-
-            void EnterCombat(Unit* /*who*/)
-            {
-                DoScriptText(SAY_AGGRO, me);
-
-                instance->SetData(DATA_LORD_MARROWGAR, IN_PROGRESS);
-            }
-
-            void JustDied(Unit* /*killer*/)
-            {
-                DoScriptText(SAY_DEATH, me);
-
-                instance->SetData(DATA_LORD_MARROWGAR, DONE);
-            }
-
-            void JustReachedHome()
-            {
-                instance->SetData(DATA_LORD_MARROWGAR, FAIL);
-            }
-
-            void KilledUnit(Unit *victim)
-            {
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    DoScriptText(RAND(SAY_KILL_1, SAY_KILL_2), me);
-            }
-
-            void MoveInLineOfSight(Unit *who)
-            {
-                if (!bIntroDone && me->IsWithinDistInMap(who, 70.0f))
-                {
-                    DoScriptText(SAY_ENTER_ZONE, me);
-                    bIntroDone = true;
-                }
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                if (!UpdateVictim() || !CheckInRoom())
-                    return;
-
-                events.Update(diff);
-
-                if (me->hasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch (eventId)
-                    {
-                        case EVENT_BONE_SPIKE_GRAVEYARD:
-                            if (IsHeroic() || !me->HasAura(SPELL_BONE_STORM))
-                                DoCast(me, SPELL_BONE_SPIKE_GRAVEYARD);
-                            events.ScheduleEvent(EVENT_BONE_SPIKE_GRAVEYARD, urand(25000, 35000));
-                            break;
-                        case EVENT_COLDFLAME:
-                            coldflameLastPos.Relocate(me);
-                            if (!me->HasAura(SPELL_BONE_STORM))
-                                me->CastCustomSpell(SPELL_COLDFLAME_NORMAL, SPELLVALUE_MAX_TARGETS, 1, me);
-                            else
-                                DoCast(me, SPELL_COLDFLAME_BONE_STORM);
-                            events.ScheduleEvent(EVENT_COLDFLAME, urand(10000, 15000));
-                            break;
-                        case EVENT_WARN_BONE_STORM:
-                            bBoneSlice = false;
-                            DoScriptText(SAY_BONE_STORM_EMOTE, me);
-                            events.ScheduleEvent(EVENT_BONE_STORM_BEGIN, 3050);
-                            me->FinishSpell(CURRENT_MELEE_SPELL, false);
-                            DoCast(me, SPELL_BONE_STORM);
-                            break;
-                        case EVENT_BONE_STORM_BEGIN:
-                            if (Aura* pStorm = me->GetAura(SPELL_BONE_STORM))
-                                pStorm->SetDuration(int32(uiBoneStormDuration));
-                            me->SetSpeed(MOVE_RUN, fBaseSpeed*3.0f, true);
-                            DoScriptText(SAY_BONE_STORM, me);
-                            events.ScheduleEvent(EVENT_BONE_STORM_END, uiBoneStormDuration+1);
-                            // no break here
-                        case EVENT_BONE_STORM_MOVE:
-                        {
-                            events.ScheduleEvent(EVENT_BONE_STORM_MOVE, uiBoneStormDuration/3);
-                            Unit* pUnit = SelectUnit(SELECT_TARGET_RANDOM, 1);
-                            if (!pUnit)
-                                pUnit = SelectUnit(SELECT_TARGET_RANDOM, 0);
-                            if (pUnit)
-                                me->GetMotionMaster()->MovePoint(POINT_TARGET_BONESTORM_PLAYER, pUnit->GetPositionX(), pUnit->GetPositionY(), pUnit->GetPositionZ());
-                            break;
-                        }
-                        case EVENT_BONE_STORM_END:
-                            if (me->GetMotionMaster()->GetCurrentMovementGeneratorType() == POINT_MOTION_TYPE)
-                                me->GetMotionMaster()->MovementExpired();
-                            DoStartMovement(me->getVictim());
-                            me->SetSpeed(MOVE_RUN, fBaseSpeed, true);
-                            events.CancelEvent(EVENT_BONE_STORM_MOVE);
-                            events.ScheduleEvent(EVENT_ENABLE_BONE_SLICE, 10000);
-                            events.ScheduleEvent(EVENT_WARN_BONE_STORM, urand(35000, 50000));
-                            break;
-                        case EVENT_ENABLE_BONE_SLICE:
-                            bBoneSlice = true;
-                            break;
-                        case EVENT_ENRAGE:
-                            DoCast(me, SPELL_BERSERK, true);
-                            DoScriptText(SAY_BERSERK, me);
-                            break;
-                    }
-                }
-
-                // We should not melee attack when storming
-                if (me->HasAura(SPELL_BONE_STORM))
-                    return;
-
-                // After 10 seconds since encounter start Bone Slice replaces melee attacks
-                if (bBoneSlice && !me->GetCurrentSpell(CURRENT_MELEE_SPELL))
-                    DoCastVictim(SPELL_BONE_SLICE);
-
-                DoMeleeAttackIfReady();
-            }
-
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE || id != POINT_TARGET_BONESTORM_PLAYER)
-                    return;
-
-                // lock movement
-                DoStartNoMovement(me->getVictim());
-            }
-
-            const Position* GetLastColdflamePosition() const
-            {
-                return &coldflameLastPos;
-            }
-
-        private:
-            bool bIntroDone;
-            uint32 uiBoneStormDuration;
-            float fBaseSpeed;
-            bool bBoneSlice;
-            Position coldflameLastPos;
-        };
-
-        CreatureAI* GetAI(Creature* pCreature) const
-        {
-            return new boss_lord_marrowgarAI(pCreature);
-        }
-};
-
-class npc_coldflame : public CreatureScript
-{
-    public:
-        npc_coldflame() : CreatureScript("npc_coldflame") { }
-
-        struct npc_coldflameAI : public ScriptedAI
-        {
-            npc_coldflameAI(Creature *pCreature) : ScriptedAI(pCreature)
-            {
-            }
-
-            void IsSummonedBy(Unit* owner)
-            {
-                DoCast(me, SPELL_COLDFLAME_PASSIVE, true);
-                float x, y, z;
-                // random target case
-                if (!owner->HasAura(SPELL_BONE_STORM) && owner->GetTypeId() == TYPEID_UNIT)
-                {
-                    Creature* creOwner = owner->ToCreature();
-                    // select any unit but not the tank (by owners threatlist)
-                    Unit* target = creOwner->AI()->SelectTarget(SELECT_TARGET_RANDOM, 1, 40.0f, true);
-                    if (!target)
-                        target = creOwner->AI()->SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true); // or the tank if its solo
-                    if (!target)
-                    {
-                        me->ForcedDespawn();
-                        return;
-                    }
-
-                    target->GetPosition(x, y, z);
-                    float scale = 70.0f / me->GetExactDist2d(x, y);
-                    x = me->GetPositionX() + (x - me->GetPositionX()) * scale;
-                    y = me->GetPositionY() + (y - me->GetPositionY()) * scale;
-                }
-                else
-                {
-                    me->GetPosition(x, y, z);
-                    Position const* ownerPos = CAST_AI(boss_lord_marrowgar::boss_lord_marrowgarAI, owner->ToCreature()->AI())->GetLastColdflamePosition();
-                    float ang = me->GetAngle(ownerPos) - static_cast<float>(M_PI);
-                    MapManager::NormalizeOrientation(ang);
-                    x += 50.0f * cosf(ang);
-                    y += 50.0f * sinf(ang);
-                }
-                me->GetMotionMaster()->MovePoint(POINT_TARGET_COLDFLAME, x, y, z);
-                events.ScheduleEvent(EVENT_COLDFLAME_TRIGGER, 400);
-            }
-
-            void UpdateAI(const uint32 diff)
-            {
-                events.Update(diff);
-
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    if (eventId == EVENT_COLDFLAME_TRIGGER)
-                    {
-                        if (me->HasAura(SPELL_COLDFLAME_PASSIVE))
-                            DoCast(SPELL_COLDFLAME_PASSIVE);
-                        events.ScheduleEvent(EVENT_COLDFLAME_TRIGGER, 400);
-                    }
-                }
-            }
-
-            void MovementInform(uint32 type, uint32 id)
-            {
-                if (type != POINT_MOTION_TYPE || id != POINT_TARGET_COLDFLAME)
-                    return;
-
-                // stop triggering but dont despawn
-                me->RemoveAura(SPELL_COLDFLAME_PASSIVE);
-            }
-
-        private:
-            EventMap events;
-        };
-
-        CreatureAI* GetAI(Creature* pCreature) const
-        {
-            return new npc_coldflameAI(pCreature);
-        }
+    SPELL_SABER_SLASH        = 69055,
+    SPELL_COLD_FLAME         = 69146,
+    SPELL_BONE_SPIKE         = 73142,
+    SPELL_SPIKE_IMPALING     = 69065,
+    SPELL_BONE_STORM         = 69076,
+    SPELL_COLD_FLAME_SPAWN   = 69138,
+    SPELL_COLD_FLAME_SPAWN_B = 72701
 };
 
 class npc_bone_spike : public CreatureScript
@@ -338,59 +54,64 @@
             npc_bone_spikeAI(Creature *pCreature) : Scripted_NoMovementAI(pCreature), vehicle(pCreature->GetVehicleKit())
             {
                 ASSERT(vehicle);
-                uiTrappedGUID = 0;
+                BoneSpikeGUID = 0;
+                pInstance = pCreature->GetInstanceScript();
+            }
+
+            void SetPrisoner(Unit* pPrisoner)
+            {
+                BoneSpikeGUID = pPrisoner->GetGUID();
+                pPrisoner->EnterVehicle(vehicle, 0);
             }
 
             void Reset()
             {
-                uiTrappedGUID = 0;
+                BoneSpikeGUID = 0;
             }
 
-            void JustDied(Unit * /*killer*/)
+            void JustDied(Unit* pKiller)
             {
-                events.Reset();
-                if (Unit* trapped = Unit::GetUnit((*me), uiTrappedGUID))
-                    trapped->RemoveAurasDueToSpell(SPELL_IMPALED);
+                Unit* pBoned = Unit::GetUnit((*me), BoneSpikeGUID);
+                if (pBoned)
+                    pBoned->RemoveAurasDueToSpell(SPELL_SPIKE_IMPALING);
             }
 
-            void KilledUnit(Unit * /*pVictim*/)
+            void KilledUnit(Unit* pVictim)
             {
                 me->Kill(me);
             }
 
-            void UpdateAI(const uint32 diff)
-            {
-                if (!uiTrappedGUID)
-                    return;
-
-                events.Update(diff);
-                Unit* trapped = Unit::GetUnit(*me, uiTrappedGUID);
-                if ((trapped && trapped->isAlive() && !trapped->HasAura(SPELL_IMPALED)) || !trapped)
-                    me->Kill(me);
-
-                if (events.ExecuteEvent() == EVENT_FAIL_BONED)
-                    if (InstanceScript* instance = me->GetInstanceScript())
-                        instance->SetData(COMMAND_FAIL_BONED, 0);
-            }
-
-            void SetTrappedUnit(Unit* unit)
-            {
-                unit->EnterVehicle(vehicle, 0);
-                uiTrappedGUID = unit->GetGUID();
-            }
-
             void PassengerBoarded(Unit * who, int8 /*seatId*/, bool apply)
             {
                 if (!apply)
                     return;
 
-                me->AddAura(SPELL_IMPALED, who);
-                events.ScheduleEvent(EVENT_FAIL_BONED, 8000);
+                DoCast(who, SPELL_SPIKE_IMPALING, true);
+                m_uiAchievBonedTimer = 8000;
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!BoneSpikeGUID || !pInstance)
+                    return;
+
+                Unit* pBoned = Unit::GetUnit((*me), BoneSpikeGUID);
+                if ((pBoned && pBoned->isAlive() && !pBoned->HasAura(SPELL_SPIKE_IMPALING)) || !pBoned)
+                    me->Kill(me);
+
+                if (m_uiAchievBonedTimer <= uiDiff)
+                {
+                    pInstance->SetData(DATA_BONED, 1);
+                    m_uiAchievBonedTimer = 8000;
+                } else m_uiAchievBonedTimer -= uiDiff;
             }
 
         private:
-            uint64 uiTrappedGUID;
-            EventMap events;
+            InstanceScript* pInstance;
+
+            uint64 BoneSpikeGUID;
+            uint32 m_uiAchievBonedTimer;
+
             Vehicle* vehicle;
         };
 
@@ -400,142 +121,300 @@
         }
 };
 
-class spell_marrowgar_coldflame : public SpellScriptLoader
+class npc_cold_flame : public CreatureScript
 {
     public:
-        spell_marrowgar_coldflame() : SpellScriptLoader("spell_marrowgar_coldflame") { }
+        npc_cold_flame() : CreatureScript("npc_cold_flame") { }
 
-        class spell_marrowgar_coldflame_SpellScript : public SpellScript
+        struct npc_cold_flameAI : public ScriptedAI
         {
-			PrepareSpellScript(spell_marrowgar_coldflame_SpellScript)
-            void HandleScriptEffect(SpellEffIndex /*effIndex*/)
+            npc_cold_flameAI(Creature *pCreature) : ScriptedAI(pCreature)
             {
-                Unit* caster = GetCaster();
-                uint8 count = 1;
-                if (GetSpellInfo()->Id == 72705)
-                    count = 4;
-
-                for (uint8 i = 0; i < count; ++i)
-                    caster->CastSpell(caster, GetEffectValue()+i, true);
+                pInstance = pCreature->GetInstanceScript();
             }
 
-            void Register()
+            void Reset()
             {
-                OnEffect += SpellEffectFn(spell_marrowgar_coldflame_SpellScript::HandleScriptEffect, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);
+                m_uiColdFlameTimer = 900;
+
+                DoCast(me, SPELL_COLD_FLAME);
+
+                me->SetVisibility(VISIBILITY_OFF);
+                DoStartNoMovement(me->getVictim());
+
+                m_uiStage = 1;
+                m_uiRadius = 2;
+                m_uiOwnerEntry = 0;
             }
 
-            bool Load()
+            void IsSummonedBy(Unit* owner)
             {
-                if (GetCaster()->GetEntry() != NPC_LORD_MARROWGAR)
-                    return false;
-                return true;
+                if(owner)
+                {
+                    if(owner->HasAura(SPELL_BONE_STORM))
+                        bCrossfire = true;
+                    else
+                        bCrossfire = false;
+
+                    m_uiOwnerEntry = owner->GetEntry();
+                }
             }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if(m_uiColdFlameTimer <= uiDiff)
+                {
+                    if(m_uiOwnerEntry == CREATURE_MARROWGAR)
+                    {
+                        if(bCrossfire)
+                        {
+                            float x, y;
+                            me->GetNearPoint2D(x, y, m_uiRadius*m_uiStage, 0);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                            me->GetNearPoint2D(x, y, m_uiRadius*m_uiStage, M_PI/2);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                            me->GetNearPoint2D(x, y, m_uiRadius*m_uiStage, M_PI*(M_PI/2));
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                            me->GetNearPoint2D(x, y, m_uiRadius*m_uiStage, M_PI);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                        }
+                        else if (!bCrossfire)
+                        {
+                            float x, y;
+                            float angle = pInstance->GetData(DATA_ANGLE / 1000);
+                            me->GetNearPoint2D(x, y, m_uiRadius*m_uiStage, angle);
+                            me->SummonCreature(CREATURE_COLD_FLAME, x, y, me->GetPositionZ(), angle, TEMPSUMMON_TIMED_DESPAWN, 4000);
+                        }
+                        ++m_uiStage;
+                        m_uiColdFlameTimer = 1000;
+                    }
+                } else m_uiColdFlameTimer -= uiDiff;
+            }
+
+        private:
+            InstanceScript* pInstance;
+
+            uint32 m_uiColdFlameTimer;
+            uint8 m_uiRadius;
+            uint8 m_uiStage;
+            uint32 m_uiOwnerEntry;
+            bool bCrossfire;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_marrowgar_coldflame_SpellScript();
+            return new npc_cold_flameAI(pCreature);
         }
 };
 
-class spell_marrowgar_bone_spike_graveyard : public SpellScriptLoader
+class boss_lord_marrowgar : public CreatureScript
 {
     public:
-        spell_marrowgar_bone_spike_graveyard() : SpellScriptLoader("spell_marrowgar_bone_spike_graveyard") { }
+        boss_lord_marrowgar() : CreatureScript("boss_lord_marrowgar") { }
 
-        class spell_marrowgar_bone_spike_graveyard_SpellScript : public SpellScript
+        struct boss_lord_marrowgarAI : public BossAI
         {
-			PrepareSpellScript(spell_marrowgar_bone_spike_graveyard_SpellScript)
-            void HandleApplyAura(SpellEffIndex /*effIndex*/)
+            boss_lord_marrowgarAI(Creature* pCreature) : BossAI(pCreature, DATA_MARROWGAR), summons(me)
             {
-                CreatureAI* marrowgarAI = GetCaster()->ToCreature()->AI();
-                bool yell = false;
-                uint8 boneSpikeCount = GetCaster()->GetMap()->GetSpawnMode() & 1 ? 3 : 1;
-                for (uint8 i = 0; i < boneSpikeCount; ++i)
+                pInstance = pCreature->GetInstanceScript();
+                m_uiBoneCount = RAID_MODE(1,3,1,3);
+                fBaseSpeed = me->GetSpeedRate(MOVE_RUN);
+                me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
+                bIntro = false;
+            }
+
+            void Reset()
+            {
+                m_uiSaberSlashTimer = 7000;
+                m_uiBoneSpikeGraveyardTimer = 15000;
+                m_uiColdFlameTimer = 10000;
+                m_uiBoneStormTimer = 45000;
+                m_uiBoneStormRemoveTimer = 20000;
+                m_uiBerserkTimer = 600000;
+                m_uiMoveTimer = 5000;
+                angle = 0;
+
+                me->SetSpeed(MOVE_RUN, fBaseSpeed, true);
+
+                if (pInstance && me->isAlive())
+                    pInstance->SetData(DATA_MARROWGAR_EVENT, NOT_STARTED);
+            }
+
+            void EnterCombat(Unit* /*pWho*/)
+            {
+                DoScriptText(SAY_AGGRO, me);
+
+                if (pInstance)
+                    pInstance->SetData(DATA_MARROWGAR_EVENT, IN_PROGRESS);
+
+                summons.DespawnAll();
+            }
+
+            void JustSummoned(Creature* summon)
+            {
+                summons.Summon(summon);
+            }
+
+            void JustDied(Unit* /*pKiller*/)
+            {
+                if (!pInstance)
+                    return;
+
+                DoScriptText(SAY_DEATH, me);
+
+                pInstance->SetData(DATA_MARROWGAR_EVENT, DONE);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_SPIKE_IMPALING);
+
+                if(pInstance->GetData(DATA_BONED) == 0)
+                    pInstance->DoCompleteAchievement(RAID_MODE(ACHIEV_BONED_10, ACHIEV_BONED_25));
+
+                summons.DespawnAll();
+            }
+
+            void JustReachedHome()
+            {
+                if (!pInstance)
+                    return;
+
+                pInstance->SetData(DATA_MARROWGAR_EVENT, FAIL);
+                pInstance->DoRemoveAurasDueToSpellOnPlayers(SPELL_SPIKE_IMPALING);
+
+                summons.DespawnAll();
+            }
+
+            void KilledUnit(Unit* pVictim)
+            {
+                if (pVictim->GetTypeId() == TYPEID_PLAYER)
                 {
-                    // select any unit but not the tank
-                    Unit* target = marrowgarAI->SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_IMPALED);
-                    if (!target && !i)
-                        target = marrowgarAI->SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true, -SPELL_IMPALED);
-                    if (!target)
-                        break;
-                    yell = true;
-                    //marrowgarAI->DoCast(*itr, SPELL_IMPALE);    // this is the proper spell but if we use it we dont have any way to assign a victim to it
-                    Creature* pBone = GetCaster()->SummonCreature(NPC_BONE_SPIKE, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), 0, TEMPSUMMON_CORPSE_DESPAWN);
-                    CAST_AI(npc_bone_spike::npc_bone_spikeAI, pBone->AI())->SetTrappedUnit(target);
+                    switch(rand()%1)
+                    {
+                        case 0: DoScriptText(SAY_KILL_1, me); break;
+                        case 1: DoScriptText(SAY_KILL_2, me); break;
+                    }
+                }
+            }
+
+            void MoveInLineOfSight(Unit* pWho)
+            {
+                if (!bIntro && me->IsWithinDistInMap(pWho, 90.0f, true))
+                {
+                    DoScriptText(SAY_INTRO, me);
+                    bIntro = true;
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (m_uiBerserkTimer <= uiDiff)
+                {
+                    DoScriptText(SAY_BERSERK, me);
+                    DoCast(SPELL_BERSERK);
+                    m_uiBerserkTimer = 600000;
+                } else m_uiBerserkTimer -= uiDiff;
+
+                if (IsHeroic() || !me->HasAura(SPELL_BONE_STORM))
+                {
+                    if (m_uiBoneSpikeGraveyardTimer < uiDiff)
+                    {
+                        for (uint8 i = 1; i <= m_uiBoneCount; i++)
+                        {
+                            if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100, true))
+                            {
+                                Creature* pBone = me->SummonCreature(CREATURE_BONE_SPIKE, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 999999);
+                                CAST_AI(npc_bone_spike::npc_bone_spikeAI, pBone->AI())->SetPrisoner(pTarget);
+                            }
+                        }
+                        DoScriptText(RAND(SAY_SPIKE_1,SAY_SPIKE_2,SAY_SPIKE_3), me);
+                        m_uiBoneSpikeGraveyardTimer = 15000;
+                    } else m_uiBoneSpikeGraveyardTimer -= uiDiff;
                 }
 
-                if (yell)
-                    DoScriptText(RAND(SAY_BONESPIKE_1, SAY_BONESPIKE_2, SAY_BONESPIKE_3), GetCaster());
+                if (!me->HasAura(SPELL_BONE_STORM))
+                {
+                    if (m_uiBoneStormTimer <= uiDiff)
+                    {
+                        DoCast(SPELL_BONE_STORM);
+                        DoScriptText(SAY_STORM, me);
+                        DoScriptText(STORM_EMOTE, me);
+                        DoStartNoMovement(me->getVictim());
+                        me->SetSpeed(MOVE_RUN, fBaseSpeed*3.0f, true);
+                        m_uiBoneStormTimer = 45000; //bone storm 30 second + other spell casting time
+                    } else m_uiBoneStormTimer -= uiDiff;
+
+                    if (m_uiColdFlameTimer <= uiDiff)
+                    {
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_NEAREST, 1))
+                        {
+                            angle = me->GetAngle(pTarget);
+                            pInstance->SetData(DATA_ANGLE, angle*1000);
+                            DoCast(pTarget, SPELL_COLD_FLAME_SPAWN);
+                        }
+                        m_uiColdFlameTimer = 10000;
+                    } else m_uiColdFlameTimer -= uiDiff;
+
+                    if (m_uiSaberSlashTimer <= uiDiff)
+                    {
+                        DoCast(me->getVictim(), SPELL_SABER_SLASH);
+                        m_uiSaberSlashTimer = 7000;
+                    } else m_uiSaberSlashTimer -= uiDiff;
+                }
+                else
+                {
+                    if (m_uiBoneStormRemoveTimer <= uiDiff)
+                    {
+                        me->RemoveAurasDueToSpell(SPELL_BONE_STORM);
+                        DoStartMovement(me->getVictim());
+                        me->SetSpeed(MOVE_RUN, fBaseSpeed, true);
+                        m_uiBoneStormRemoveTimer = RAID_MODE(20000,30000,20000,30000);
+                    } else m_uiBoneStormRemoveTimer -= uiDiff;
+
+                    if(m_uiMoveTimer <= uiDiff)
+                    {
+                        float x, y, z;
+                        if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))
+                        {
+                            pTarget->GetPosition(x, y, z);
+                            me->GetMotionMaster()->MovePoint(0, x, y, z);
+                        }
+                        DoCast(SPELL_COLD_FLAME_SPAWN_B);
+                        m_uiMoveTimer = 5000;
+                    } else m_uiMoveTimer -= uiDiff;
+                }
+
+                DoMeleeAttackIfReady();
             }
 
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_marrowgar_bone_spike_graveyard_SpellScript::HandleApplyAura, EFFECT_1, SPELL_EFFECT_APPLY_AURA);
-            }
+        private:
+            InstanceScript* pInstance;
 
-            bool Load()
-            {
-                if (GetCaster()->GetEntry() != NPC_LORD_MARROWGAR)
-                    return false;
-                return true;
-            }
+            uint32 m_uiSaberSlashTimer;
+            uint32 m_uiBoneSpikeGraveyardTimer;
+            uint32 m_uiBoneStormTimer;
+            uint32 m_uiBoneStormRemoveTimer;
+            uint32 m_uiColdFlameTimer;
+            uint32 m_uiBerserkTimer;
+            uint32 m_uiResetTimer;
+            uint32 m_uiMoveTimer;
+            uint8 m_uiBoneCount;
+            float fBaseSpeed;
+            float angle;
+            bool bIntro;
+
+            SummonList summons;
         };
 
-        SpellScript* GetSpellScript() const
+        CreatureAI* GetAI(Creature* pCreature) const
         {
-            return new spell_marrowgar_bone_spike_graveyard_SpellScript();
-        }
-};
-
-class spell_marrowgar_bone_storm : public SpellScriptLoader
-{
-    public:
-        spell_marrowgar_bone_storm() : SpellScriptLoader("spell_marrowgar_bone_storm") { }
-
-        class spell_marrowgar_bone_storm_SpellScript : public SpellScript
-        {
-			PrepareSpellScript(spell_marrowgar_bone_storm_SpellScript)
-            void RecalculateDamage(SpellEffIndex /*effIndex*/)
-            {
-                int32 dmg = GetHitDamage();
-                float distance = GetHitUnit()->GetExactDist2d(GetCaster());
-                if (distance < 5.0f)
-                    return;
-
-                float distVar = distance >= 20.0f ? 4 : (10.0f/3.0f);
-                SetHitDamage(int32(dmg * distVar / distance));
-            }
-
-            void Register()
-            {
-                OnEffect += SpellEffectFn(spell_marrowgar_bone_storm_SpellScript::RecalculateDamage, EFFECT_0, SPELL_EFFECT_SCHOOL_DAMAGE);
-            }
-
-            bool Load()
-            {
-                if (GetCaster()->GetEntry() != NPC_LORD_MARROWGAR)
-                    return false;
-                return true;
-            }
-        };
-
-        SpellScript* GetSpellScript() const
-        {
-            return new spell_marrowgar_bone_storm_SpellScript();
+            return new boss_lord_marrowgarAI(pCreature);
         }
 };
 
 void AddSC_boss_lord_marrowgar()
 {
+    new npc_bone_spike();
+    new npc_cold_flame();
     new boss_lord_marrowgar();
-    new npc_coldflame();
-    new npc_bone_spike();
-    new spell_marrowgar_coldflame();
-    new spell_marrowgar_bone_spike_graveyard();
-    new spell_marrowgar_bone_storm();
-
-    // has to be done or else players threat will be wiped for impaled player and he will absorb all damage
-    if (VehicleSeatEntry* vehSeat = const_cast<VehicleSeatEntry*>(sVehicleSeatStore.LookupEntry(6206)))
-        vehSeat->m_flags |= 0x400;
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_professor_putricide.cpp
@@ -223,7 +223,7 @@
                         break;
                     case ACTION_FESTERGUT_GAS:
                         DoScriptText(SAY_FESTERGUT_GASEOUS_BLIGHT, me);
-                         if (Creature* bfestergut = Unit::GetCreature(*me, instance->GetData64(DATA_FESTERGURT)))
+                        if (Creature* bfestergut = Unit::GetCreature(*me, instance->GetData64(DATA_FESTERGURT)))
                         {
                             bfestergut->CastSpell(bfestergut, SPELL_RELEASE_GAS_VISUAL, false, NULL, NULL, me->GetGUID());
                         }
@@ -698,13 +698,12 @@
         {
             npc_abominationAI(Creature* pCreature) : ScriptedAI(pCreature), vehicle(pCreature->GetVehicleKit())
             {
-                pInstance = pCreature->GetInstanceScript();
                 assert(vehicle);
             }
 
             void Reset()
             {
-                m_uiGrabTimer = 1000;
+                m_uiGrabTimer = 500;
                 bVehicle = false;
             }
 
@@ -712,20 +711,18 @@
             {
                 if (m_uiGrabTimer < uiDiff)
                 {
-                    Unit* target = SelectUnit(SELECT_TARGET_NEAREST, 0);
+                    if(Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 1, 2.0f, true))
                     {
-                        if(target && !bVehicle && target->IsFriendlyTo(me))
+                        if(!bVehicle)
                         {
-                            target->EnterVehicle(vehicle, 0);
+                            target->EnterVehicle(vehicle);
                             bVehicle = true;
                         }
                     }
-                    m_uiGrabTimer = 1000;
+                    m_uiGrabTimer = 500;
                 } else m_uiGrabTimer -= uiDiff;
             }
         private:
-            InstanceScript* pInstance;
-
             Vehicle* vehicle;
 
             bool bVehicle;
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_rat_des_blutes.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
@@ -58,7 +58,7 @@
 
             void KilledUnit(Unit* /*victim*/) { }
 
-            void UpdateAI(const uint32 /* diff */ )
+            void UpdateAI(const uint32 diff)
             {
                 if (!UpdateVictim())
                     return;
@@ -93,7 +93,7 @@
 
             void KilledUnit(Unit* /*victim*/) { }
 
-            void UpdateAI(const uint32 /* diff */ )
+            void UpdateAI(const uint32 diff)
             {
                 if (!UpdateVictim())
                     return;
@@ -128,7 +128,7 @@
 
         void KilledUnit(Unit* /*victim*/) { }
 
-        void UpdateAI(const uint32 /* diff */ )
+        void UpdateAI(const uint32 diff)
         {
             if (!UpdateVictim())
                 return;
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_rotface.cpp
@@ -1,37 +1,39 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
+
+//Need fix 69783 and 69785 target
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-#define EMOTE_EXPLOSION "Big Ooze can barely maintain its form!"
-#define EMOTE_SLIME_SPRAY "Rotface begins to cast Slime Spray!"
-
 enum Yells
 {
-    SAY_PRECIOUS    = -1666015,
-    SAY_AGGRO       = -1666016,
-    SAY_DEATH       = -1666024,
-    SAY_KILL_1      = -1666022,
-    SAY_KILL_2      = -1666021,
-    SAY_BERSERK     = -1666023,
-    SAY_SPRAY       = -1666017,
-    SAY_OOZE_FLOOD  = -1666018
+    SAY_PRECIOUS    = -1631094,
+    SAY_AGGRO       = -1631095,
+    SAY_DEATH       = -1631103,
+    SAY_KILL_1      = -1631100,
+    SAY_KILL_2      = -1631101,
+    SAY_BERSERK     = -1631102,
+    SAY_SPRAY       = -1631097,
+    EMOTE_SPRAY     = -1631096,
+    SAY_OOZE_FLOOD  = -1631099,
+    EMOTE_EXPLOSION = -1631098,
+    SAY_EXPLOSION   = -1631099
 };
 
 enum Spells
@@ -105,7 +107,7 @@
                 m_uiInfectionTimer = 14000;
 
                 m_uiStage = 0;
-                m_uiFloodStage = 0;
+                m_uiFloodStage = 1;
 
                 if(pInstance && me->isAlive())
                     pInstance->SetData(DATA_ROTFACE_EVENT, NOT_STARTED);
@@ -184,7 +186,7 @@
                             me->CastSpell(trigger, SPELL_SLIME_SPRAY, true);
                         }
                         DoScriptText(SAY_SPRAY, me);
-                        me->MonsterTextEmote(EMOTE_SLIME_SPRAY, NULL);
+                        DoScriptText(EMOTE_SPRAY, me);
                     }
                     m_uiSlimeSprayTimer = 15000;
                 } else m_uiSlimeSprayTimer -= diff;
@@ -336,14 +338,17 @@
 
                 if(!bExplosion)
                 {
-                    Aura* UnstableAura = me->GetAura(SPELL_UNSTABLE_OOZE);
-                    if (UnstableAura && UnstableAura->GetStackAmount() > 4)
+                    if(Aura* UnstableAura = me->GetAura(SPELL_UNSTABLE_OOZE))
                     {
-                        me->RemoveAurasDueToSpell(SPELL_UNSTABLE_OOZE);
-                        me->MonsterTextEmote(EMOTE_EXPLOSION, NULL);
-                        DoCast(me, SPELL_EXPLOSION);
-                        bExplosion = true;
-                        //me->ForcedDespawn();
+                        uint8 stack = UnstableAura->GetStackAmount();
+                        if(stack >= 5)
+                        {
+                            DoCast(me, SPELL_EXPLOSION);
+                            me->RemoveAurasDueToSpell(SPELL_UNSTABLE_OOZE);
+                            DoScriptText(EMOTE_EXPLOSION, me);
+                            DoScriptText(SAY_EXPLOSION, me);
+                            bExplosion = true;
+                        }
                     }
                 }
 
@@ -351,6 +356,7 @@
             }
         private:
             InstanceScript* pInstance;
+
             uint32 m_uiStickyOozeTimer;
             bool bExplosion;
         };
@@ -576,6 +582,47 @@
         }
 };
 
+/*class spell_rotface_ooze_flood : public SpellScriptLoader
+{
+    public:
+        spell_rotface_ooze_flood() : SpellScriptLoader("spell_rotface_ooze_flood") { }
+
+
+        class spell_rotface_ooze_flood_SpellScript : public SpellScript
+        {
+            void HandleApplyAura(SpellEffIndex effIndex)
+            {
+                Creature* puddle = GetCaster()->FindNearestCreature(37824, 200.0f, true);
+                if(puddle)
+                {
+                    puddle->CastSpell(puddle, SPELL_OOZE_FLOOD_1, true);
+                    puddle->CastSpell(puddle, SPELL_OOZE_FLOOD_AURA, true);
+                }
+            }
+
+
+            void Register()
+            {
+                OnEffect += SpellEffectFn(spell_rotface_ooze_flood_SpellScript::HandleApplyAura, EFFECT_1, SPELL_EFFECT_APPLY_AURA);
+            }
+
+
+            bool Load()
+            {
+                if (GetCaster()->GetEntry() != CREATURE_PUDDLE_STALKER)
+                    return false;
+                return true;
+            }
+        };
+
+
+        SpellScript* GetSpellScript() const
+        {
+            return new spell_rotface_ooze_flood_SpellScript();
+        }
+};
+*/
+
 void AddSC_boss_rotface()
 {
     new boss_rotface();
@@ -585,4 +632,5 @@
     new npc_icc_puddle_stalker();
     new npc_ooze_explode_stalker();
     new npc_precious_icc();
+    //new spell_rotface_ooze_flood();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_sindragosa.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
 
 /*
 *Need correct timers
@@ -87,7 +87,7 @@
 
             void Reset()
             {
-                m_uiPhase = 0;
+                m_uiPhase = 1;
 
                 m_uiBreathTimer = 15000;
                 m_uiTailSmashTimer = 11000;
@@ -108,15 +108,19 @@
 
                 Switch = false;
 
-                memset(&marked, 0, sizeof(marked));
+                if(!pInstance)
+                    return;
+
+                pInstance->SetData(DATA_SINDRAGOSA_EVENT, NOT_STARTED);
             }
 
             void EnterCombat(Unit* /*who*/)
             {
+                if(pInstance)
+                    pInstance->SetData(DATA_SINDRAGOSA_EVENT, IN_PROGRESS);
+
                 DoCast(me, SPELL_FROST_AURA);
                 DoScriptText(SAY_AGGRO, me);
-
-                m_uiPhase = 1;
             }
 
             void JustDied(Unit* /*pKiller*/)
@@ -174,12 +178,8 @@
             {
                 for (uint8 i = 1; i <= count; i++)
                 {
-                    if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
-                    if(pTarget && !pTarget->HasAura(SPELL_FROST_BEACON))
-                    {
+                    if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, -SPELL_FROST_BEACON))
                         DoCast(pTarget, SPELL_FROST_BEACON);
-                        marked[i] = pTarget;
-                    }
                 }
             }
 
@@ -187,16 +187,15 @@
             {
                 for (uint8 i = 1; i <= count; i++)
                 {
-                    if (marked[i] && marked[i]->isAlive())
+                    if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true, SPELL_FROST_BEACON))
                     {
-                        DoCast(marked[i], SPELL_ICE_TOMB);
-                        DoCast(marked[i], SPELL_ASPHYXATION);
-                        marked[i]->RemoveAurasDueToSpell(SPELL_FROST_BEACON);
+                        DoCast(pTarget, SPELL_ICE_TOMB);
+                        DoCast(pTarget, SPELL_ASPHYXATION);
                         float x, y, z;
-                        marked[i]->GetPosition(x, y, z);
-                        if (Unit* tomb = DoSummon(CREATURE_ICE_TOMB, marked[i]))
-                            tomb->AddThreat(marked[i], 5000.0f);
-                    }
+                        pTarget->GetPosition(x, y, z);
+                        if (Unit* tomb = DoSummon(CREATURE_ICE_TOMB, pTarget))
+                            tomb->AddThreat(pTarget, 500000.0f);
+                     }
                 }
             }
 
@@ -220,7 +219,7 @@
                         for (uint8 i = 1; i <= mcount; i++)
                         {
                             if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
-                            if(pTarget && pTarget->getPowerType() == POWER_MANA && !pTarget->HasAura(SPELL_UNCHAINED_MAGIC) && pTarget->GetDistance2d(me->GetPositionX(), me->GetPositionY()) > 5) //hack
+                            if(pTarget->getPowerType() == POWER_MANA && !pTarget->HasAura(SPELL_UNCHAINED_MAGIC) && pTarget->GetDistance2d(me->GetPositionX(), me->GetPositionY()) > 5) //hack
                             {
                                 DoScriptText(SAY_UNCHAIND_MAGIC, me);
                                 DoCast(pTarget, SPELL_UNCHAINED_MAGIC);
@@ -377,7 +376,6 @@
             uint32 m_uiUnchainedMagicTimer;
             uint32 m_uiBombTimer;
             uint8 count;
-            Unit* marked[6];
 
             bool Switch;
         };
@@ -521,46 +519,21 @@
                 m_uiFrostBreathTimer = 5000;
                 m_uiIceBlastTimer = 7000;
                 me->SetFlying(true);
-
-                if(pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
-                   pInstance->SetData(DATA_SINDRAGOSA_EVENT, NOT_STARTED);
             }
 
             void EnterCombat(Unit* /*who*/)
             {
-                if(pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) == NOT_STARTED)
-                {
-                    pInstance->SetData(DATA_SINDRAGOSA_EVENT, IN_PROGRESS);
-                }
-
-                Creature* dragon = Unit::GetCreature(*me, pInstance->GetData64(DATA_SPINESTALKER));
-                if (dragon)
-                {
-                    if(dragon->isDead())
-                    {
-                        dragon->Respawn();
-                    }
-                    else
-                    {
-                        DoCast(me, SPELL_FROST_AURA_ADD);
-                        dragon->SetInCombatWithZone();
-                    }
-                }
+                DoCast(me, SPELL_FROST_AURA_ADD);
             }
 
             void JustDied(Unit* /*killer*/)
             {
-                if(pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
+                if(!pInstance)
+                    return;
+
+                if(pInstance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
                 {
-                    Creature* dragon = Unit::GetCreature(*me, pInstance->GetData64(DATA_SPINESTALKER));
-                    if(dragon && dragon->isDead())
-                    {
-                        Creature* DragonBoss = me->SummonCreature(CREATURE_SINDRAGOSA, SpawnLoc[1], TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,30000);
-                        /*if(DragonBoss)
-                        {
-                            DragonBoss->GetMotionMaster()->MovePoint(0, SpawnLoc[1]);
-                        }*/
-                    }
+                    pInstance->SetData(DATA_SPAWN, +1);
                 }
             }
 
@@ -569,11 +542,6 @@
                 if (!UpdateVictim())
                     return;
 
-                if (pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) == FAIL && me->isAlive())
-                {
-                    me->Kill(me);
-                }
-
                 if (m_uiFrostBreathTimer <= uiDiff)
                 {
                     DoCast(me->getVictim(), SPELL_FROST_BREATH_ADD);
@@ -620,45 +588,21 @@
                 m_uiCleaveTimer = 6000;
                 m_uiSweepTimer = 7000;
                 me->SetFlying(true);
-
-                if (pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
-                    pInstance->SetData(DATA_SINDRAGOSA_EVENT, NOT_STARTED);
             }
 
             void EnterCombat(Unit* /*who*/)
             {
-                if(pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) == NOT_STARTED)
-                {
-                    pInstance->SetData(DATA_SINDRAGOSA_EVENT, IN_PROGRESS);
-                }
-
-                Creature* dragon = me->GetCreature(*me, pInstance->GetData64(DATA_RIMEFANG));
-                if (dragon)
-                {
-                    if(dragon->isDead())
-                    {
-                        dragon->Respawn();
-                    }
-                    else
-                    {
-                        dragon->SetInCombatWithZone();
-                    }
-                }
+                DoCast(me, SPELL_FROST_AURA_ADD);
             }
 
             void JustDied(Unit* /*killer*/)
             {
-                if(pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
+                if(!pInstance)
+                    return;
+
+                if(pInstance->GetData(DATA_SINDRAGOSA_EVENT) != DONE)
                 {
-                    Creature* dragon = Unit::GetCreature(*me, pInstance->GetData64(DATA_RIMEFANG));
-                    if(dragon && dragon->isDead())
-                    {
-                        Creature* DragonBoss = me->SummonCreature(CREATURE_SINDRAGOSA, SpawnLoc[1], TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,30000);
-                        /*if(DragonBoss)
-                        {
-                            DragonBoss->GetMotionMaster()->MovePoint(0, SpawnLoc[1]);
-                        }*/
-                    }
+                    pInstance->SetData(DATA_SPAWN, +1);
                 }
             }
 
@@ -667,11 +611,6 @@
                 if (!UpdateVictim())
                     return;
 
-                if (pInstance && pInstance->GetData(DATA_SINDRAGOSA_EVENT) == FAIL && me->isAlive())
-                {
-                    me->Kill(me);
-                }
-
                 if (m_uiRoarTimer <= uiDiff)
                 {
                     DoCastAOE(SPELL_BELLOWING_ROAR);
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_the_lich_king.cpp
@@ -1,25 +1,30 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* Copyright (C) 2009 - 2010 TrinityCore <http://www.trinitycore.org/>
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*/
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
 
-#define GOSSIP_START_EVENT "We are ready, Tirion!"
+/*
+//Speaking to Tirion Fordring to begin the fight
+Long have I waited for this day, hero. Are you and your allies prepared to bring the Lich King to justice? We charge on your command!
+ We are prepared, Highlord. Let us battle for the fate of Azeroth! For the light of dawn!
+*/
+#define GOSSIP_START_EVENT "We are prepared, Highlord. Let us battle for the fate of Azeroth! For the light of dawn!"
 
 enum Yells
 {
@@ -65,7 +70,7 @@
     SPELL_SUMMON_DEFILE              = 72762,
     SPELL_SUMMON_VILE_SPIRIT         = 70498,
     SPELL_SUMMON_BROKEN_FROSTMOURNE  = 72406,
-    SPELL_SUMMON_SHADOW_TRAP         = 73540,
+    SPELL_SUMMON_SHADOW_TRAP         = 73539,
     SPELL_INFEST                     = 70541,
     SPELL_NECROTIC_PLAGUE            = 70337,
     SPELL_PLAGUE_SIPHON              = 74074,
@@ -88,14 +93,15 @@
     SPELL_REVIVE                     = 72423,
     SPELL_CLONE_PLAYER               = 57507,
     SPELL_RAGING_SPIRIT_VISUAL       = 69198,
-    SPELL_DEFILE                     = 72754,
+    SPELL_DEFILE                     = 72743,
     SPELL_ICE_SPHERE_VISUAL          = 69090,
     SPELL_ICE_PULSE                  = 69099,
     SPELL_ICE_BURST                  = 69108,
     SPELL_LIFE_SIPHON                = 73783,
     SPELL_SOUL_SHRIEK                = 69242,
     SPELL_WHOCKVAWE                  = 72149,
-    SPELL_ENRAGE                     = 72143
+    SPELL_ENRAGE                     = 72143,
+    SPELL_BURST                      = 70503
 };
 
 struct Position MovePos[]=
@@ -112,7 +118,7 @@
     float x,y,z;
 };
 
-static Locations MovePoint[]=
+static Locations TeleportPoint[]=
 {
     {959.996f, 212.576f, 193.843f},
     {932.537f, 231.813f, 193.838f},
@@ -155,7 +161,7 @@
                 m_uiNecroticPlagueTimer = 30000;
                 m_uiPlagueSiphonTimer = 5000;
                 m_uiTirionSpawnTimer = 5000;
-                m_uiQuakeTimer = 1000;
+                m_uiQuakeTimer = 3000;
                 m_uiIcePulsSummonTimer = 10000;
                 m_uiPainandSufferingTimer = 10000;
                 m_uiSummonSpiritTimer = 18000;
@@ -196,6 +202,16 @@
             {
                 DoScriptText(SAY_DEATH_KING, me);
 
+                if(pInstance)
+                    pInstance->SetData(DATA_LICH_KING_EVENT, DONE);
+
+                summons.DespawnAll();
+                
+                PlayerCinematic();
+            }
+            
+            void PlayerCinematic()
+            {
                 Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
 
                 if (PlList.isEmpty())
@@ -211,11 +227,6 @@
                         }
                     }
                 }
-
-                if(pInstance)
-                    pInstance->SetData(DATA_LICH_KING_EVENT, DONE);
-
-                summons.DespawnAll();
             }
 
             void JustReachedHome()
@@ -281,7 +292,7 @@
 
             void UpdateAI(const uint32 uiDiff)
             {
-                if(pInstance && pInstance->GetData(DATA_LICH_KING_EVENT) != IN_PROGRESS)
+                if (!UpdateVictim())
                     return;
 
                 if(!TransitionPhase3)
@@ -298,8 +309,7 @@
                     DoScriptText(SAY_BERSERK, me);
                     DoCast(me, SPELL_BERSERK);
                     m_uiBerserkTimer = 900000;
-                }
-                else m_uiBerserkTimer -= uiDiff;
+                } else m_uiBerserkTimer -= uiDiff;
 
                 if(m_uiPhase == 1)
                 {
@@ -307,8 +317,8 @@
                     {
                         if (m_uiSummonShadowTrap < uiDiff)
                         {
-                            if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                                pTarget->CastSpell(pTarget, SPELL_SUMMON_SHADOW_TRAP, true);
+                            if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                                DoCast(pTarget, SPELL_SUMMON_SHADOW_TRAP, true);
                             m_uiSummonShadowTrap = 30000;
                         } else m_uiSummonShadowTrap -= uiDiff;
                     }
@@ -316,7 +326,7 @@
                     if (m_uiInfestTimer < uiDiff)
                     {
                         if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                        DoCast(pTarget, SPELL_INFEST);
+                            DoCast(pTarget, SPELL_INFEST);
                         m_uiInfestTimer = 30000;
                     } else m_uiInfestTimer -= uiDiff;
 
@@ -341,12 +351,12 @@
                     if (m_uiNecroticPlagueTimer < uiDiff)
                     {
                         if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                        DoCast(pTarget, SPELL_NECROTIC_PLAGUE);
+                            DoCast(pTarget, SPELL_NECROTIC_PLAGUE);
                         m_uiNecroticPlagueTimer = 30000;
                     } else m_uiNecroticPlagueTimer -= uiDiff;
                 }
 
-                if(m_uiPhase == 2)
+                if(m_uiPhase == 2) //transition phase 1
                 {
                     if (m_uiQuakeTimer < uiDiff)
                     {
@@ -365,6 +375,7 @@
                                 DoScriptText(SAY_BROKEN_ARENA, me);
                                 DoCast(SPELL_QUAKE);
                                 m_uiQuakeTimer = 1000;
+                                --stage;
                                 m_uiPhase = 3;
                             }
                             break;
@@ -374,7 +385,7 @@
                     if (m_uiSummonSpiritTimer < uiDiff)
                     {
                         if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                        DoCast(pTarget, SPELL_SUMMON_RAGING_SPIRIT);
+                            DoCast(pTarget, SPELL_SUMMON_RAGING_SPIRIT);
                         m_uiSummonSpiritTimer = 16000;
                     } else m_uiSummonSpiritTimer -= uiDiff;
 
@@ -387,7 +398,7 @@
                     if (m_uiPainandSufferingTimer < uiDiff)
                     {
                         if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                        DoCast(pTarget, SPELL_PAIN_AND_SUFFERING);
+                            DoCast(pTarget, SPELL_PAIN_AND_SUFFERING);
                         m_uiPainandSufferingTimer = 2000;
                     } else m_uiPainandSufferingTimer -= uiDiff;
                 }
@@ -397,7 +408,7 @@
                     if (m_uiDefileTimer < uiDiff)
                     {
                         if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                        DoCast(pTarget, SPELL_SUMMON_DEFILE);
+                            DoCast(pTarget, SPELL_SUMMON_DEFILE);
                         m_uiDefileTimer = 20000;
                     } else m_uiDefileTimer -= uiDiff;
 
@@ -421,7 +432,7 @@
                     } else m_uiInfestTimer -= uiDiff;
                 }
 
-                if(m_uiPhase == 4)
+                if(m_uiPhase == 4) //transition phase 1
                 {
                     if (m_uiQuakeTimer < uiDiff)
                     {
@@ -440,7 +451,7 @@
                                 DoScriptText(SAY_BROKEN_ARENA, me);
                                 DoCast(SPELL_QUAKE);
                                 m_uiQuakeTimer = 1000;
-                                stage = 1;
+                                --stage;
                                 m_uiPhase = 5;
                             }
                             break;
@@ -450,7 +461,7 @@
                     if (m_uiSummonSpiritTimer < uiDiff)
                     {
                         if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                        DoCast(pTarget, SPELL_SUMMON_RAGING_SPIRIT);
+                            DoCast(pTarget, SPELL_SUMMON_RAGING_SPIRIT);
                         m_uiSummonSpiritTimer = 16000;
                     } else m_uiSummonSpiritTimer -= uiDiff;
 
@@ -463,7 +474,7 @@
                     if (m_uiPainandSufferingTimer < uiDiff)
                     {
                         if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                        DoCast(pTarget, SPELL_PAIN_AND_SUFFERING);
+                            DoCast(pTarget, SPELL_PAIN_AND_SUFFERING);
                         m_uiPainandSufferingTimer = 3000;
                     } else m_uiPainandSufferingTimer -= uiDiff;
                 }
@@ -479,7 +490,8 @@
                     if (m_uiHarvestSoulTimer < uiDiff)
                     {
                         DoScriptText(SAY_HARVEST_SOUL, me);
-                        DoCast(me->getVictim(), SPELL_HARVEST_SOULS);
+                        if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            DoCast(pTarget, SPELL_HARVEST_SOULS);
                         m_uiHarvestSoulTimer = 70000;
                     } else m_uiHarvestSoulTimer -= uiDiff;
                 }
@@ -743,10 +755,10 @@
 
             void UpdateAI(const uint32 diff)
             {
-                 if(!pInstance)
+                 if(!bIntro || !pInstance)
                      return;
 
-                if(bIntro == true && m_uiIntroTimer <= diff)
+                if(m_uiIntroTimer <= diff)
                 {
                     switch(m_uiIntroPhase)
                     {
@@ -803,7 +815,7 @@
                         ++m_uiIntroPhase;
                         break;
                     case 9:
-                        DoCast(me, SPELL_ICEBLOCK_TRIGGER);
+                        pLichKing->CastSpell(me, SPELL_ICEBLOCK_TRIGGER, true);
                         m_uiIntroTimer = 2000;
                         ++m_uiIntroPhase;
                         break;
@@ -842,18 +854,19 @@
 
         bool OnGossipHello(Player* pPlayer, Creature* pCreature)
         {
-            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START_EVENT, GOSSIP_SENDER_MAIN, 999999);
             pPlayer->SEND_GOSSIP_MENU(10600, pCreature->GetGUID());
+
             return true;
         }
 
         bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
         {
-            if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+            if (uiAction == 999999)
             {
+                CAST_AI(npc_tirion_icc::npc_tirion_iccAI, pCreature->AI())->StartEvent();
                 pCreature->RemoveFlag(UNIT_NPC_FLAGS,UNIT_NPC_FLAG_GOSSIP);
                 pPlayer->CLOSE_GOSSIP_MENU();
-                CAST_AI(npc_tirion_icc::npc_tirion_iccAI, pCreature->AI())->StartEvent();
             }
             return true;
         }
@@ -871,21 +884,17 @@
 
         struct npc_ice_puls_iccAI : public ScriptedAI
         {
-            npc_ice_puls_iccAI(Creature* pCreature) : ScriptedAI(pCreature)
-            {
-                pInstance = pCreature->GetInstanceScript();
-            }
+            npc_ice_puls_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
 
             void Reset()
             {
-                m_uiIcePulseTimer = 2000;
-                m_uiIceBurstCheckTimer = 2000;
+                m_uiIcePulseTimer = 3000;
 
-                DoCast(me, SPELL_ICE_SPHERE_VISUAL);
-
-                if(Unit* target = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                me->AddThreat(target, 500000.0f);
-                me->GetMotionMaster()->MoveChase(me->getVictim());
+                if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100.0f, true))
+                {
+                    me->AddThreat(pTarget, 500000.0f);
+                    me->GetMotionMaster()->MoveChase(pTarget);
+                }
             }
 
             void EnterCombat(Unit* /*who*/)
@@ -898,26 +907,17 @@
                 if (!UpdateVictim())
                     return;
 
-                if (me->getVictim()->GetTypeId() != TYPEID_PLAYER)
-                    return;
-
                 if (m_uiIcePulseTimer < uiDiff)
                 {
-                    if(Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
-                    DoCast(pTarget, SPELL_ICE_PULSE);
+                    DoCast(me->getVictim(), SPELL_ICE_PULSE);
+                    m_uiIcePulseTimer = 3000;
                 } else m_uiIcePulseTimer -= uiDiff;
 
-                if (m_uiIceBurstCheckTimer < uiDiff)
-                {
-                    if (me->IsWithinDistInMap(me->getVictim(), 3))
-                        DoCast(me, SPELL_ICE_BURST);
-                    m_uiIceBurstCheckTimer = 2000;
-                } else m_uiIceBurstCheckTimer -= uiDiff;
+                if (me->IsWithinDistInMap(me->getVictim(), 3))
+                    DoCast(me, SPELL_ICE_BURST);
             }
         private:
-            InstanceScript* pInstance;
             uint32 m_uiIcePulseTimer;
-            uint32 m_uiIceBurstCheckTimer;
         };
 
         CreatureAI* GetAI(Creature* pCreature) const
@@ -936,7 +936,6 @@
             npc_valkyr_iccAI(Creature* pCreature) : ScriptedAI(pCreature), vehicle(pCreature->GetVehicleKit())
             {
                 assert(vehicle);
-                pInstance = pCreature->GetInstanceScript();
             }
 
             void Reset()
@@ -971,9 +970,7 @@
                             InVehicle = true;
                             DoCast(me, SPELL_WINGS_OF_THE_DAMNED);
                             if (IsHeroic())
-                            {
                                 DoCast(pTarget, SPELL_LIFE_SIPHON);
-                            }
                         }
                     }
                     m_uiGrabTimer = 120000;
@@ -996,8 +993,6 @@
                 } else m_uiFallPlayerTimer -= uiDiff;
             }
         private:
-            InstanceScript* pInstance;
-
             uint32 m_uiGrabTimer;
             uint32 m_uiMovementTimer;
             uint32 m_uiFallPlayerTimer;
@@ -1021,10 +1016,7 @@
 
         struct npc_ghoul_iccAI : public ScriptedAI
         {
-            npc_ghoul_iccAI(Creature *pCreature) : ScriptedAI(pCreature)
-            {
-                pInstance = pCreature->GetInstanceScript();
-            }
+            npc_ghoul_iccAI(Creature *pCreature) : ScriptedAI(pCreature) { }
 
             void Reset()
             {
@@ -1058,7 +1050,6 @@
                 } else m_uiAggroTimer -= uiDiff;
             }
         private:
-            InstanceScript* pInstance;
             uint32 m_uiLifeTimer;
             uint32 m_uiAggroTimer;
 
@@ -1081,45 +1072,20 @@
         {
             npc_defile_iccAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
             {
-                pInstance = pCreature->GetInstanceScript();
                 me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);
             }
 
             void Reset()
             {
                 me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                m_uiDefileTimer = 1000;
                 m_uiDespawnTimer = 60000;
-                m_uiSize = me->GetFloatValue(OBJECT_FIELD_SCALE_X);
+                DoCast(me, SPELL_DEFILE);
 
                 Despawnd = false;
             }
 
-            void DefileDamage()
-            {
-                Map::PlayerList const &PlList = me->GetMap()->GetPlayers();
-
-                for (Map::PlayerList::const_iterator i = PlList.begin(); i != PlList.end(); ++i)
-                {
-                    if (Player* pPlayer = i->getSource())
-                    {
-                        if(pPlayer->GetDistance2d(me->GetPositionX(), me->GetPositionY()) <= 3)
-                        {
-                             me->SetFloatValue(OBJECT_FIELD_SCALE_X, +1);
-                             DoCast(pPlayer, SPELL_DEFILE);
-                        }
-                    }
-                }
-            }
-
             void UpdateAI(const uint32 uiDiff)
             {
-                if (m_uiDefileTimer < uiDiff)
-                {
-                    DefileDamage();
-                    m_uiDefileTimer = 1000;
-                } else m_uiDefileTimer -= uiDiff;
-
                 if (m_uiDespawnTimer < uiDiff && !Despawnd)
                 {
                     me->ForcedDespawn();
@@ -1127,11 +1093,6 @@
                 } else m_uiDespawnTimer -= uiDiff;
             }
         private:
-            InstanceScript* pInstance;
-
-            uint32 m_uiDefileTimer;
-            float  m_uiSize;
-            float  m_uiMaxSize;
             uint32 m_uiDespawnTimer;
 
             bool Despawnd;
@@ -1150,10 +1111,7 @@
 
         struct npc_raging_spirit_iccAI : public ScriptedAI
         {
-            npc_raging_spirit_iccAI(Creature* pCreature) : ScriptedAI(pCreature)
-            {
-                pInstance = pCreature->GetInstanceScript();
-            }
+            npc_raging_spirit_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
 
             void Reset()
             {
@@ -1179,8 +1137,6 @@
                 } else m_uiShriekTimer -= uiDiff;
             }
         private:
-            InstanceScript* pInstance;
-
             uint32 m_uiShriekTimer;
         };
 
@@ -1190,6 +1146,50 @@
         }
 };
 
+class npc_vile_spirit_icc : public CreatureScript
+{
+    public:
+        npc_vile_spirit_icc() : CreatureScript("npc_vile_spirit_icc") { }
+
+        struct npc_vile_spirit_iccAI : public ScriptedAI
+        {
+            npc_vile_spirit_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
+
+            void Reset()
+            {
+                m_uiMoveTimer = 15000;
+                bStartMove = false;
+
+                DoStartNoMovement(me->getVictim());
+
+                if(Unit* pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 100, true))
+                    me->AddThreat(pTarget, 100000.0f);
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!bStartMove && m_uiMoveTimer < uiDiff)
+                {
+                    DoStartMovement(me->getVictim());
+                    bStartMove = true;
+                    m_uiMoveTimer = 15000;
+                } else m_uiMoveTimer -= uiDiff;
+
+                if(bStartMove && me->IsWithinDistInMap(me, 2.0f, true))
+                    DoCast(me->getVictim(), SPELL_BURST, true);
+            }
+        private:
+            uint32 m_uiShriekTimer;
+            bool bStartMove;
+            uint32 m_uiMoveTimer;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_vile_spirit_iccAI(pCreature);
+        }
+};
+
 class npc_shambling_horror_icc : public CreatureScript
 {
     public:
@@ -1197,10 +1197,7 @@
 
         struct npc_shambling_horror_iccAI : public ScriptedAI
         {
-            npc_shambling_horror_iccAI(Creature* pCreature) : ScriptedAI(pCreature)
-            {
-                pInstance = pCreature->GetInstanceScript();
-            }
+            npc_shambling_horror_iccAI(Creature* pCreature) : ScriptedAI(pCreature) { }
 
             void Reset()
             {
@@ -1231,8 +1228,6 @@
                 } else m_uiShockTimer -= uiDiff;
             }
         private:
-            InstanceScript* pInstance;
-
             uint32 m_uiEnrageTimer;
             uint32 m_uiShockTimer;
         };
@@ -1253,4 +1248,5 @@
     new npc_defile_icc();
     new npc_raging_spirit_icc();
     new npc_shambling_horror_icc();
+    new npc_vile_spirit_icc();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_valithria_dreamwalker.cpp
@@ -278,18 +278,6 @@
                 m_uiChangeTimer = 10000;
             }
 
-            void MoveInLineOfSight(Unit *who)
-            {
-                if(me->GetEntry() == CREATURE_PORTAL_NORMAL_MODE_NPC || me->GetEntry() == CREATURE_PORTAL_HEROIC_MODE_NPC)
-                {
-                    if (me->IsWithinDistInMap(who, 2.0f))
-                    {
-                        who->CastSpell(who, SPELL_DREAM_STATE, true);
-                        me->ForcedDespawn();
-                    }
-                }
-            }
-
             void UpdateAI(const uint32 diff)
             {
                 if(me->GetEntry() == CREATURE_PORTAL_NORMAL_MODE_PRE)
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.cpp
@@ -1,23 +1,45 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
+#include "Spell.h"
+
+enum Spells
+{
+    SPELL_ON_ORGRIMS_HAMMER_DECK   = 70121, //maybe for gunship battle
+    SPELL_DARKMARTYRDOM_FANATIC     = 71236,
+    SPELL_DARKMARTYRDOM_ADHERENT    = 70903,
+    SPELL_DARKTRANSFORMATION        = 70900,
+    SPELL_NECROTICSTRIKE            = 70659,
+    SPELL_SHADOWCLEAVE              = 70670,
+    SPELL_VAMPIRICMIGHT             = 70674,
+    SPELL_FANATIC_DETERMINATION     = 71235,
+    SPELL_ADHERENT_DETERMINATION    = 71234,
+    SPELL_EMPOWEREMENT              = 70901,
+    SPELL_FROST_FEVER               = 67767,
+    SPELL_DEATHCHILL_BLAST          = 70906,
+    SPELL_DEATHCHILL_BOLT           = 70594,
+    SPELL_CURSE_OF_TORPOR           = 71237,
+    SPELL_SHORUD_OF_THE_OCCULT      = 70768,
+    SPELL_DARK_TRANSFORMATION_T     = 70895,
+    SPELL_DARK_EMPOWERMENT_T        = 70896,
+    SPELL_STANDART_HORDE            = 69811
+};
 
 enum TeleportSpells
 {
@@ -33,6 +55,152 @@
     LICHKING      = 70860
 };
 
+class npc_cult_fanatic_and_adherent : public CreatureScript
+{
+    public:
+        npc_cult_fanatic_and_adherent() : CreatureScript("npc_cult_fanatic_and_adherent") { }
+
+        struct npc_cult_fanatic_and_adherentAI : public ScriptedAI
+        {
+            npc_cult_fanatic_and_adherentAI(Creature *pCreature) : ScriptedAI(pCreature) { }
+
+            void Reset()
+            {
+                m_uiStrikeTimer = urand(8000, 11000);
+                m_uiVampirTimer = urand(19000, 22000);
+                m_uiCleaveTimer = urand(7000, 9000);
+                m_uiMartyrdomTimer = urand(24000, 30000);
+                m_uiFrostFeverTimer = urand(9000, 11000);
+                m_uiDeathchillTimer = urand(10000, 12000);
+                m_uiCurseTimer = urand(8000, 10000);
+                m_uiOccultTimer = urand(25000, 29000);
+
+                bEmpowerement = false;
+
+                if(me->GetEntry() == CREATURE_REANIMATED_ADHERENT)
+                    DoCast(me, SPELL_ADHERENT_DETERMINATION);
+                if(me->GetEntry() == CREATURE_REANIMATED_FANATIC)
+                    DoCast(me, SPELL_FANATIC_DETERMINATION);
+            }
+
+            void JustDied(Unit* /*who*/) { }
+
+            void SpellHit(Unit* /*caster*/, const SpellEntry * spell)
+            {
+                if(me->GetEntry() == CREATURE_ADHERENT)
+                {
+                    if (spell->Id == SPELL_EMPOWEREMENT)
+                        me->UpdateEntry(CREATURE_EMPOWERED_ADHERENT);
+                    else if (spell->Id == SPELL_DARK_EMPOWERMENT_T)
+                    {
+                        DoCast(me, SPELL_EMPOWEREMENT);
+                        bEmpowerement = true;
+                    }
+                }
+                if(me->GetEntry() == CREATURE_FANATIC)
+                {
+                    if (spell->Id == SPELL_DARKTRANSFORMATION)
+                        me->UpdateEntry(CREATURE_DEFORMED_FANATIC);
+                    else if (spell->Id == SPELL_DARK_TRANSFORMATION_T)
+                    {
+                        DoCast(me, SPELL_DARKTRANSFORMATION);
+                    }
+                }
+            }
+
+            void UpdateAI(const uint32 uiDiff)
+            {
+                if (!UpdateVictim())
+                    return;
+
+                if (me->hasUnitState(UNIT_STAT_CASTING))
+                    return;
+
+                if((me->GetEntry() == CREATURE_ADHERENT) || (me->GetEntry() == CREATURE_EMPOWERED_ADHERENT) || (me->GetEntry() == CREATURE_REANIMATED_ADHERENT))
+                {
+                    if (m_uiMartyrdomTimer <= uiDiff && !bEmpowerement)
+                    {
+                        DoCast(me, SPELL_DARKMARTYRDOM_ADHERENT);
+                        m_uiMartyrdomTimer = urand(24000, 30000);
+                    } else m_uiMartyrdomTimer -= uiDiff;
+
+                    if (m_uiFrostFeverTimer <= uiDiff)
+                    {
+                        DoCast(me->getVictim(), SPELL_FROST_FEVER);
+                        m_uiFrostFeverTimer = urand(9000, 11000);
+                    } else m_uiFrostFeverTimer -= uiDiff;
+
+                    if (m_uiDeathchillTimer <= uiDiff)
+                    {
+                        if (me->GetEntry() == CREATURE_EMPOWERED_ADHERENT)
+                            DoCast(me->getVictim(), SPELL_DEATHCHILL_BLAST);
+                        else
+                            DoCast(me->getVictim(), SPELL_DEATHCHILL_BOLT);
+                        m_uiDeathchillTimer = urand(10000, 12000);
+                    } else m_uiDeathchillTimer -= uiDiff;
+
+                    if (m_uiCurseTimer <= uiDiff)
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                            DoCast(pTarget, SPELL_CURSE_OF_TORPOR);
+                        m_uiCurseTimer = urand(8000, 10000);
+                    } else m_uiCurseTimer -= uiDiff;
+
+                    if (m_uiOccultTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_SHORUD_OF_THE_OCCULT);
+                        m_uiOccultTimer = urand(25000, 29000);
+                    } else m_uiOccultTimer -= uiDiff;
+                }
+                if((me->GetEntry() == CREATURE_FANATIC) || (me->GetEntry() == CREATURE_REANIMATED_FANATIC) || (me->GetEntry() == CREATURE_DEFORMED_FANATIC))
+                {
+                    if (m_uiMartyrdomTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_DARKMARTYRDOM_FANATIC);
+                        m_uiMartyrdomTimer = urand(24000, 30000);
+                    } else m_uiMartyrdomTimer -= uiDiff;
+
+                    if (m_uiStrikeTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_NECROTICSTRIKE);
+                        m_uiStrikeTimer = urand(8000, 11000);
+                    } else m_uiStrikeTimer -= uiDiff;
+
+                    if (m_uiCleaveTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_SHADOWCLEAVE);
+                        m_uiCleaveTimer = urand(7000, 9000);
+                    } else m_uiCleaveTimer -= uiDiff;
+
+                    if (m_uiVampirTimer <= uiDiff)
+                    {
+                        DoCast(me, SPELL_VAMPIRICMIGHT);
+                        m_uiVampirTimer = urand(19000, 22000);
+                    } else m_uiVampirTimer -= uiDiff;
+                }
+
+                DoMeleeAttackIfReady();
+            }
+
+        private:
+            uint32 m_uiStrikeTimer;
+            uint32 m_uiCleaveTimer;
+            uint32 m_uiVampirTimer;
+            uint32 m_uiMartyrdomTimer;
+            uint32 m_uiFrostFeverTimer;
+            uint32 m_uiDeathchillTimer;
+            uint32 m_uiCurseTimer;
+            uint32 m_uiOccultTimer;
+
+            bool bEmpowerement;
+        };
+
+        CreatureAI* GetAI(Creature* pCreature) const
+        {
+            return new npc_cult_fanatic_and_adherentAI(pCreature);
+        }
+};
+
 class go_icecrown_teleporter : public GameObjectScript
 {
     public:
@@ -40,37 +208,40 @@
 
         bool OnGossipHello(Player *pPlayer, GameObject *pGO)
         {
-            if(InstanceScript* pInstance = pGO->GetInstanceScript())
+            InstanceScript* pInstance = pGO->GetInstanceScript();
+            if(!pInstance)
+                return false;
+
+            if(pInstance->GetData(DATA_MARROWGAR_EVENT) == DONE)
             {
-                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Молот света.", GOSSIP_SENDER_MAIN, HAMMER);
-                if(pInstance->GetData(DATA_MARROWGAR_EVENT) == DONE)
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Молельня проклятых.", GOSSIP_SENDER_MAIN, ORATORY);
-                if(pInstance->GetData(DATA_DEATHWHISPER_EVENT) == DONE)
-                {
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Черепной вал.", GOSSIP_SENDER_MAIN, RAMPART);
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Подъём смертоносного.", GOSSIP_SENDER_MAIN, SAURFANG);
-                }
-                if(pInstance->GetData(DATA_SAURFANG_EVENT) == DONE)
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Шпиль.", GOSSIP_SENDER_MAIN, UPPER_SPIRE);
-                if(pInstance->GetData(DATA_PROFESSOR_PUTRICIDE_EVENT) == DONE)
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Чумодельня.", GOSSIP_SENDER_MAIN, PLAGUEWORKS);
-                if(pInstance->GetData(DATA_BLOOD_QUEEN_LANATHEL_EVENT) == DONE)
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Багровый зал.", GOSSIP_SENDER_MAIN, CRIMSONHALL);
-                if(pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == DONE)
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Логово Королевы Льда.", GOSSIP_SENDER_MAIN, QUEEN);
-                if(pInstance->GetData(DATA_SINDRAGOSA_EVENT) == DONE)
-                    pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Залы ледокрылых.", GOSSIP_SENDER_MAIN, FWHALLS);
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to Light's Hammer.", GOSSIP_SENDER_MAIN, HAMMER);
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Oratory of the Damned.", GOSSIP_SENDER_MAIN, ORATORY);
             }
+            if(pInstance->GetData(DATA_DEATHWHISPER_EVENT) == DONE)
+            {
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Rampart of Skulls.", GOSSIP_SENDER_MAIN, RAMPART);
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Deathbringer's Rise.", GOSSIP_SENDER_MAIN, SAURFANG);
+            }
+            if(pInstance->GetData(DATA_SAURFANG_EVENT) == DONE)
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Upper Spire.", GOSSIP_SENDER_MAIN, UPPER_SPIRE);
+            if(pInstance->GetData(DATA_PROFESSOR_PUTRICIDE_EVENT) == DONE)
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Plagueworks", GOSSIP_SENDER_MAIN, PLAGUEWORKS);
+            if(pInstance->GetData(DATA_BLOOD_QUEEN_LANATHEL_EVENT) == DONE)
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Crimson Halls", GOSSIP_SENDER_MAIN, CRIMSONHALL);
+            if(pInstance->GetData(DATA_VALITHRIA_DREAMWALKER_EVENT) == DONE)
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Sindragosa's Lair", GOSSIP_SENDER_MAIN, QUEEN);
+            if(pInstance->GetData(DATA_SINDRAGOSA_EVENT) == DONE)
+                pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Teleport to the Frostwing Halls", GOSSIP_SENDER_MAIN, FWHALLS);
 
             pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pGO->GetGUID());
             return true;
         }
 
-        bool OnGossipSelect(Player* pPlayer, GameObject* /*pGO*/, uint32 /*uiSender*/, uint32 uiAction)
+        bool OnGossipSelect(Player* pPlayer, GameObject* /*pGO*/, uint32 uiSender, uint32 uiAction)
         {
-            pPlayer->PlayerTalkClass->ClearMenus();
+            //pPlayer->PlayerTalkClass->ClearMenus();
             if(!pPlayer->getAttackers().empty())
-                return true;
+                return false;
 
             switch(uiAction)
             {
@@ -111,11 +282,27 @@
                     pPlayer->CLOSE_GOSSIP_MENU();
                     break;
             }
+
+            SpellEntry const* spell = sSpellStore.LookupEntry(uiAction);
+            if (!spell)
+                return false;
+
+
+            if (pPlayer->isInCombat())
+            {
+                Spell::SendCastResult(pPlayer, spell, 0, SPELL_FAILED_AFFECTING_COMBAT);
+                return true;
+            }
+
+            if (uiSender == GOSSIP_SENDER_MAIN)
+                pPlayer->CastSpell(pPlayer, spell, true);
+
             return true;
         }
 };
 
 void AddSC_icecrown_citadel()
 {
+    new npc_cult_fanatic_and_adherent();
     new go_icecrown_teleporter();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
--- a/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
+++ b/src/server/scripts/Northrend/IcecrownCitadel/icecrown_citadel.h
@@ -1,28 +1,26 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef DEF_ICECROWN_CITADEL_H
 #define DEF_ICECROWN_CITADEL_H
 
-enum eSharedSpells
+enum eSpells
 {
-    SPELL_BERSERK   = 26662,
-    SPELL_BERSERK2  = 47008
+    SPELL_BERSERK                         = 26662
 };
 
 enum eEnums
@@ -34,6 +32,10 @@
 
 enum eAchievements
 {
+    ACHIEV_BONED_10                       = 4534,
+    ACHIEV_BONED_25                       = 4610,
+    AVHIEV_FULL_HOUSE_10                  = 4535,
+    AVHIEV_FULL_HOUSE_25                  = 4611,
     ACHIEV_MESS_10                        = 4537,
     ACHIEV_MESS_25                        = 4613,
     ACHIEVMENT_ONCE_BITTEN_TWICE_SHY_10   = 4539,
@@ -69,11 +71,11 @@
 
 enum Data64
 {
-    DATA_LORD_MARROWGAR,
-    DATA_LADY_DEATHWHISPER,
-    DATA_DEATHBRINGER_SAURFANG,
+    DATA_MARROWGAR,
+    DATA_DEATHWHISPER,
+    DATA_SAURFANG,
     DATA_GUNSHIP_BATTLE,
-    DATA_FESTERGUT,
+    DATA_FESTERGURT,
     DATA_ROTFACE,
     DATA_STINKY,
     DATA_PRECIOUS,
@@ -85,73 +87,33 @@
     DATA_BLOOD_QUEEN_LANATHEL,
     DATA_VALITHRIA_DREAMWALKER,
     DATA_SINDRAGOSA,
-    DATA_SPINESTALKER,
-    DATA_RIMEFANG,
     DATA_LICH_KING,
-	DATA_FESTERGURT,
-    DATA_SAURFANG_EVENT_NPC,
-
-    COMMAND_FAIL_BONED
-};
-
-enum eGameobjectsTrinity
-{
-    GO_DOODAD_ICECROWN_ICEWALL02        = 201910,
-    GO_ICEWALL                          = 201911,
-    GO_LORD_MARROWGAR_S_ENTRANCE        = 201857,
-    GO_ORATORY_OF_THE_DAMNED_ENTRANCE   = 201563,
-    GO_LADY_DEATHWHISPER_ELEVATOR       = 202220,
-
-    ORGRIM_S_HAMMER_HORDE_ICC       = 201812,
-    ORGRIM_S_HAMMER_ALLIANCE_ICC    = 201581,
-    THE_SKYBREAKER_HORDE_ICC        = 201811,
-    THE_SKYBREAKER_ALLIANCE_ICC     = 201580,
-
-    GO_SAURFANG_S_DOOR                  = 201825,
-    GO_DEATHBRINGER_S_CACHE_10N         = 202239,
-    GO_DEATHBRINGER_S_CACHE_25N         = 202240,
-    GO_DEATHBRINGER_S_CACHE_10H         = 202238,
-    GO_DEATHBRINGER_S_CACHE_25H         = 202241,
-    GO_SCOURGE_TRANSPORTER_SAURFANG     = 202244,
-    GO_ORANGE_PLAGUE_MONSTER_ENTRANCE   = 201371,
-    GO_GREEN_PLAGUE_MONSTER_ENTRANCE    = 201370,
-    GO_SCIENTIST_AIRLOCK_DOOR_COLLISION = 201612,
-    GO_SCIENTIST_AIRLOCK_DOOR_ORANGE    = 201613,
-    GO_SCIENTIST_AIRLOCK_DOOR_GREEN     = 201614,
-    GO_DOODAD_ICECROWN_ORANGETUBES02    = 201617,
-    GO_DOODAD_ICECROWN_GREENTUBES02     = 201618,
-    GO_SCIENTIST_ENTRANCE               = 201372,
+    DATA_ANGLE,
+    DATA_BONED,
+    DATA_SPAWN
 };
 
 enum eCreatures
 {
-    NPC_LORD_MARROWGAR              = 36612,
-    NPC_BONE_SPIKE                  = 36619,
-    NPC_COLD_FLAME                  = 36672,
-
-    NPC_LADY_DEATHWHISPER           = 36855,
-    NPC_CULT_FANATIC                = 37890,
-    NPC_DEFORMED_FANATIC            = 38135,
-    NPC_REANIMATED_FANATIC          = 38009,
-    NPC_CULT_ADHERENT               = 37949,
-    NPC_EMPOWERED_ADHERENT          = 38136,
-    NPC_REANIMATED_ADHERENT         = 38010,
-    NPC_VENGEFUL_SHADE              = 38222,
-
-    NPC_DEATHBRINGER_SAURFANG       = 37813,
-    NPC_BLOOD_BEAST                 = 38508,
-    NPC_SE_JAINA_PROUDMOORE         = 37188,    // SE means Saurfang Event
-    NPC_SE_MURADIN_BRONZEBEARD      = 37200,
-    NPC_SE_KING_VARIAN_WRYNN        = 37879,
-    NPC_SE_HIGH_OVERLORD_SAURFANG   = 37187,
-    NPC_SE_KOR_KRON_REAVER          = 37920,
-    NPC_SE_SKYBREAKER_MARINE        = 37830,
-
-    NPC_FESTERGUT                   = 36626,
-    NPC_GAS_DUMMY                   = 36659,
-
+    CREATURE_MARROWGAR               = 36612,
+    CREATURE_BONE_SPIKE              = 36619,
+    CREATURE_COLD_FLAME              = 36672,
+    CREATURE_DEATHWHISPER            = 36855,
+    CREATURE_ADHERENT                = 37949,
+    CREATURE_EMPOWERED_ADHERENT      = 38136,
+    CREATURE_REANIMATED_ADHERENT     = 38010,
+    CREATURE_FANATIC                 = 37890,
+    CREATURE_DEFORMED_FANATIC        = 38135,
+    CREATURE_REANIMATED_FANATIC      = 38009,
     CREATURE_SHADE                   = 38222,
     CREATURE_GUNSHIP                 = 30343,
+    NPC_SE_MURADIN_BRONZEBEARD       = 37200,
+    NPC_SE_KING_VARIAN_WRYNN         = 37879,
+    NPC_SE_HIGH_OVERLORD_SAURFANG    = 37187,
+    NPC_SE_KOR_KRON_REAVER           = 37920,
+    NPC_SE_SKYBREAKER_MARINE         = 37830,
+    CREATURE_SAURFANG                = 37813,
+    CREATURE_FESTERGURT              = 36626,
     CREATURE_PUDDLE_STALKER          = 37013,
     CREATURE_ORANGE_GAS_STALKER      = 36659,
     CREATURE_VILE_GAS_STALKER        = 38548,
@@ -173,7 +135,7 @@
     CREATURE_BLOOD_QUEEN_LANATHEL    = 37955,
     CREATURE_SWARMING_SHADOWS        = 38163,
     CREATURE_VALITHRIA_DREAMWALKER   = 36789,
-	CREATURE_PORTAL_NORMAL_MODE_PRE  = 38186,
+    CREATURE_PORTAL_NORMAL_MODE_PRE  = 38186,
     CREATURE_PORTAL_NORMAL_MODE_NPC  = 37945,
     CREATURE_PORTAL_HEROIC_MODE_PRE  = 38429,
     CREATURE_PORTAL_HEROIC_MODE_NPC  = 38430,
@@ -209,6 +171,10 @@
     LORD_ENTRANCE                  = 201857,
     ORATORY_ENTRANCE               = 201563,
     LADY_ELEVATOR                  = 202220,
+    ORGRIM_S_HAMMER_HORDE_ICC      = 201812,
+    ORGRIM_S_HAMMER_ALLIANCE_ICC   = 201581,
+    THE_SKYBREAKER_HORDE_ICC       = 201811,
+    THE_SKYBREAKER_ALLIANCE_ICC    = 201580,
     SAURFANG_DOOR                  = 201825,
     BLOODWING_DOOR                 = 201920,
     FROSTWING_DOOR                 = 201919,
@@ -254,4 +220,4 @@
     LICH_TELEPORT                  = 202223
 };
 
-#endif
\ No newline at end of file
+#endif
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
@@ -1,24 +1,22 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * Copyright (C) 2010 Bolvor <http://bitbucket.org/bolvor/icecrown-citadel/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
 #include "icecrown_citadel.h"
-#include "MapManager.h"
 
 #define MAX_ENCOUNTER      12
 
@@ -37,9 +35,6 @@
                 uiLadyDeathwhisper      = 0;
                 uiGunship               = 0;
                 uiDeathbringerSaurfang  = 0;
-                uiSaurfangEventNPC      = 0;
-                uiDeathbringersCache    = 0;
-                uiSaurfangTeleport      = 0;
                 uiFestergut             = 0;
                 uiRotface               = 0;
                 uiStinky                = 0;
@@ -52,11 +47,12 @@
                 uiBloodQueenLanathel    = 0;
                 uiValithriaDreamwalker  = 0;
                 uiSindragosa            = 0;
-                uiRimefang              = 0;
-                uiSpinestalker          = 0;
                 uiLichKing              = 0;
                 m_uiSaurfangCacheGUID   = 0;
 
+                uiAngle                 = 0;
+                uiSpawn                 = 0;
+                uiBoned                 = 0;
                 uiIceWall1              = 0;
                 uiIceWall2              = 0;
                 uiMarrowgarEntrance     = 0;
@@ -106,47 +102,31 @@
             bool IsEncounterInProgress() const
             {
                 for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
-                    if (uiEncounter[i] == IN_PROGRESS) return true;
+                {
+                    if (uiEncounter[i] == IN_PROGRESS)
+                        return true;
+                }
 
                 return false;
             }
 
             void OnCreatureCreate(Creature* pCreature, bool /*add*/)
             {
-                Map::PlayerList const &players = instance->GetPlayers();
-                uint32 TeamInInstance = 0;
-
-                if (!players.isEmpty())
-                {
-                    if (Player* pPlayer = players.begin()->getSource())
-                        TeamInInstance = pPlayer->GetTeam();
-                }
                 switch(pCreature->GetEntry())
                 {
-                    case NPC_LORD_MARROWGAR:
+                    case CREATURE_MARROWGAR:
                         uiLordMarrowgar = pCreature->GetGUID();
                         break;
-                    case NPC_LADY_DEATHWHISPER:
+                    case CREATURE_DEATHWHISPER:
                         uiLadyDeathwhisper = pCreature->GetGUID();
                         break;
                     case CREATURE_GUNSHIP:
                         uiGunship = pCreature->GetGUID();
                         break;
-                    case NPC_DEATHBRINGER_SAURFANG:
+                    case CREATURE_SAURFANG:
                         uiDeathbringerSaurfang = pCreature->GetGUID();
                         break;
-                    case NPC_SE_HIGH_OVERLORD_SAURFANG:
-                        if (TeamInInstance == ALLIANCE)
-                            pCreature->UpdateEntry(NPC_SE_MURADIN_BRONZEBEARD, ALLIANCE);
-                    case NPC_SE_MURADIN_BRONZEBEARD:
-                        uiSaurfangEventNPC = pCreature->GetGUID();
-                        pCreature->LastUsedScriptID = pCreature->GetScriptId();
-                        break;
-                    case NPC_SE_KOR_KRON_REAVER:
-                        if (TeamInInstance == ALLIANCE)
-                            pCreature->UpdateEntry(NPC_SE_SKYBREAKER_MARINE, ALLIANCE);
-                        break;
-                    case NPC_FESTERGUT:
+                    case CREATURE_FESTERGURT:
                         uiFestergut = pCreature->GetGUID();
                         break;
                     case CREATURE_ROTFACE:
@@ -179,19 +159,13 @@
                     case CREATURE_SINDRAGOSA:
                         uiSindragosa = pCreature->GetGUID();
                         break;
-                    case CREATURE_RIMEFANG:
-                        uiRimefang = pCreature->GetGUID();
-                        break;
-                    case CREATURE_SPINESTALKER:
-                        uiSpinestalker = pCreature->GetGUID();
-                        break;
                     case CREATURE_LICH_KING:
                         uiLichKing = pCreature->GetGUID();
                         break;
                 }
             }
 
-            void OnGameObjectCreate(GameObject* pGo, bool add)
+            void OnGameObjectCreate(GameObject* pGo, bool /*add*/)
             {
                 switch (pGo->GetEntry())
                 {
@@ -220,15 +194,6 @@
                         if (uiEncounter[3] == NOT_STARTED)
                             HandleGameObject(NULL, false, pGo);
                         break;
-                    case GO_DEATHBRINGER_S_CACHE_10N:
-                    case GO_DEATHBRINGER_S_CACHE_25N:
-                    case GO_DEATHBRINGER_S_CACHE_10H:
-                    case GO_DEATHBRINGER_S_CACHE_25H:
-                        uiDeathbringersCache = pGo->GetGUID();
-                        break;
-                    case GO_SCOURGE_TRANSPORTER_SAURFANG:
-                        uiSaurfangTeleport = pGo->GetGUID();
-                        break;
                     case BLOODWING_DOOR:
                         uiBloodwingDoor = pGo->GetGUID();
                         if (uiEncounter[3] == DONE)
@@ -316,8 +281,6 @@
                         break;
                     case PROF_DOOR_GREEN:
                         uiProfDoorGreen = pGo->GetGUID();
-                        if (uiEncounter[5] == NOT_STARTED)
-                            HandleGameObject(NULL, true, pGo);
                         break;
                     case ORANGE_PIPE:
                         uiOrangePipe = pGo->GetGUID();
@@ -331,8 +294,6 @@
                         break;
                     case PROF_DOOR_ORANGE:
                         uiProfDoorOrange = pGo->GetGUID();
-                        if (uiEncounter[4] == NOT_STARTED)
-                            HandleGameObject(NULL, true, pGo);
                         break;
                     case ROTFACE_DOOR:
                         uiGreenMonsterDoor = pGo->GetGUID();
@@ -349,6 +310,12 @@
                         if (uiEncounter[6] == DONE)
                             HandleGameObject(NULL, true, pGo);
                         break;
+                    case SAURFANG_CACHE_10_N:
+                    case SAURFANG_CACHE_25_N:
+                    case SAURFANG_CACHE_10_H:
+                    case SAURFANG_CACHE_25_H:
+                        m_uiSaurfangCacheGUID = pGo->GetGUID();
+                        break;
                     case DREAMWALKER_CACHE_10_N:
                     case DREAMWALKER_CACHE_25_N:
                     case DREAMWALKER_CACHE_10_H:
@@ -377,6 +344,11 @@
                         if (uiEncounter[0] == NOT_STARTED)
                             HandleGameObject(NULL, false, pGo);
                         break;
+                    case GUNSHIP_TELEPORT:
+                        uiFlightWarTp = pGo->GetGUID();
+                        if (uiEncounter[2] == NOT_STARTED)
+                            HandleGameObject(NULL, false, pGo);
+                        break;
                     case SAURFANG_TELEPORT:
                         uiSaurfangTp = pGo->GetGUID();
                         if (uiEncounter[4] == NOT_STARTED)
@@ -404,14 +376,11 @@
             {
                 switch(identifier)
                 {
-                    case DATA_LORD_MARROWGAR:         return uiLordMarrowgar;
-                    case DATA_LADY_DEATHWHISPER:      return uiLadyDeathwhisper;
+                    case DATA_MARROWGAR:              return uiLordMarrowgar;
+                    case DATA_DEATHWHISPER:           return uiLadyDeathwhisper;
                     case DATA_GUNSHIP_BATTLE:         return uiGunship;
-                    case DATA_DEATHBRINGER_SAURFANG : return uiDeathbringerSaurfang;
-                    case DATA_SAURFANG_EVENT_NPC:     return uiSaurfangEventNPC;
-                    case SAURFANG_DOOR:               return uiSaurfangDoor;
-                    case GO_SCOURGE_TRANSPORTER_SAURFANG: return uiSaurfangTeleport;
-                    case DATA_FESTERGUT:              return uiFestergut;
+                    case DATA_SAURFANG:               return uiDeathbringerSaurfang;
+                    case DATA_FESTERGURT:             return uiFestergut;
                     case DATA_ROTFACE:                return uiRotface;
                     case DATA_STINKY:                 return uiStinky;
                     case DATA_PRECIOUS:               return uiPrecious;
@@ -423,9 +392,10 @@
                     case DATA_BLOOD_QUEEN_LANATHEL:   return uiBloodQueenLanathel;
                     case DATA_VALITHRIA_DREAMWALKER:  return uiValithriaDreamwalker;
                     case DATA_SINDRAGOSA:             return uiSindragosa;
-                    case DATA_RIMEFANG:               return uiRimefang;
-                    case DATA_SPINESTALKER:           return uiSpinestalker;
                     case DATA_LICH_KING:              return uiLichKing;
+                    case DATA_ANGLE:                  return uiAngle;
+                    case DATA_BONED:                  return uiBoned;
+                    case DATA_SPAWN:                  return uiSpawn;
                 }
                 return 0;
             }
@@ -435,73 +405,76 @@
                 switch(type)
                 {
                     case DATA_MARROWGAR_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                HandleGameObject(uiIceWall1, true);
-                                HandleGameObject(uiIceWall2, true);
-                                HandleGameObject(uiMarrowgarEntrance, true);
-                                if (GameObject* FirstTp = instance->GetGameObject(uiFirstTp))
-                                {
-                                    FirstTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                    FirstTp->SetGoState(GOState(0));
-                                }
-                                if (GameObject* MarrowgarTp = instance->GetGameObject(uiMarrowgarTp))
-                                {
-                                    MarrowgarTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                    MarrowgarTp->SetGoState(GOState(0));
-                                }
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiIceWall1, false);
-                                HandleGameObject(uiIceWall2, false);
-                                HandleGameObject(uiMarrowgarEntrance, true);
-                                if (GameObject* FirstTp = instance->GetGameObject(uiFirstTp))
-                                    FirstTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                if (GameObject* MarrowgarTp = instance->GetGameObject(uiMarrowgarTp))
-                                    MarrowgarTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                break;
-                            case IN_PROGRESS:
-                                HandleGameObject(uiMarrowgarEntrance, false);
-                                break;
+                            HandleGameObject(uiIceWall1, true);
+                            HandleGameObject(uiIceWall2, true);
+                            HandleGameObject(uiMarrowgarEntrance, true);
+                            if (GameObject* FirstTp = instance->GetGameObject(uiFirstTp))
+                            {
+                                FirstTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                FirstTp->SetGoState(GOState(0));
+                            }
+                            if (GameObject* MarrowgarTp = instance->GetGameObject(uiMarrowgarTp))
+                            {
+                                MarrowgarTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                MarrowgarTp->SetGoState(GOState(0));
+                            }
                         }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiIceWall1, false);
+                            HandleGameObject(uiIceWall2, false);
+                            HandleGameObject(uiMarrowgarEntrance, true);
+                            if (GameObject* FirstTp = instance->GetGameObject(uiFirstTp))
+                            {
+                                FirstTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                            }
+                            if (GameObject* MarrowgarTp = instance->GetGameObject(uiMarrowgarTp))
+                            {
+                                MarrowgarTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                            }
+                        }
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiMarrowgarEntrance, false);
                         uiEncounter[0] = data;
                         break;
                     case DATA_DEATHWHISPER_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                HandleGameObject(uiOratoryDoor, true);
-                                if (GameObject* pGO = instance->GetGameObject(uiLadyDeathwisperTransporter))
-                                {
-                                    pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
-                                    pGO->SetGoState(GO_STATE_READY);
-                                }
-                                if (GameObject* FlightWarTp = instance->GetGameObject(uiFlightWarTp))
-                                {
-                                    FlightWarTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                    FlightWarTp->SetGoState(GOState(0));
-                                }
-                                if (GameObject* SaurfangTp = instance->GetGameObject(uiSaurfangTp))
-                                {
-                                    SaurfangTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                    SaurfangTp->SetGoState(GOState(0));
-                                }
-                                break;
-                            case IN_PROGRESS:
-                                HandleGameObject(uiOratoryDoor, false);
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiOratoryDoor, true);
-                                if (GameObject* FlightWarTp = instance->GetGameObject(uiFlightWarTp))
-                                    FlightWarTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                if (GameObject* SaurfangTp = instance->GetGameObject(uiSaurfangTp))
-                                    SaurfangTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                break;
+                            HandleGameObject(uiOratoryDoor, true);
+                            if (GameObject* pGO = instance->GetGameObject(uiLadyDeathwisperTransporter))
+                            {
+                                pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                pGO->SetGoState(GO_STATE_READY);
+                            }
+                            if (GameObject* FlightWarTp = instance->GetGameObject(uiFlightWarTp))
+                            {
+                                FlightWarTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                FlightWarTp->SetGoState(GOState(0));
+                            }
+                            if (GameObject* SaurfangTp = instance->GetGameObject(uiSaurfangTp))
+                            {
+                                SaurfangTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                SaurfangTp->SetGoState(GOState(0));
+                            }
                         }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiOratoryDoor, true);
+                            if (GameObject* FlightWarTp = instance->GetGameObject(uiFlightWarTp))
+                            {
+                                FlightWarTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                            }
+                            if (GameObject* SaurfangTp = instance->GetGameObject(uiSaurfangTp))
+                            {
+                                SaurfangTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                            }
+                        }
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiOratoryDoor, false);
                         uiEncounter[1] = data;
                         break;
-
                     /*case DATA_GUNSHIP_BATTLE_EVENT:
                         switch(data)
                         {
@@ -512,235 +485,256 @@
                         }
                         uiEncounter[2] = data;
                         break;*/
-                    case DATA_DEATHBRINGER_SAURFANG:
-                        switch (data)
+                    case DATA_SAURFANG_EVENT:
+                        if(data == DONE)
                         {
-                            case DONE:
-                                HandleGameObject(uiSaurfangDoor, true);
-                                DoRespawnGameObject(uiDeathbringersCache, 7*DAY);
-                                break;
-                            case NOT_STARTED:
-                                if (GameObject* teleporter = instance->GetGameObject(uiSaurfangTeleport))
-                                {
-                                    HandleGameObject(uiSaurfangTeleport, true, teleporter);
-                                    teleporter->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-                                }
-                                break;
-                            case IN_PROGRESS:
-                                break;
+                            if (GameObject* pChest = instance->GetGameObject(m_uiSaurfangCacheGUID))
+                            {
+                                pChest->SetRespawnTime(pChest->GetRespawnDelay());
+                            }
+                            if (GameObject* CitadelTp = instance->GetGameObject(uiCitadelTp))
+                            {
+                                CitadelTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                CitadelTp->SetGoState(GOState(0));
+                            }
+                            HandleGameObject(uiSaurfangDoor, true);
+                            HandleGameObject(uiBloodwingDoor, true);
+                            HandleGameObject(uiFrostwingDoor, true);
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiSaurfangDoor, false);
+                            HandleGameObject(uiBloodwingDoor, false);
+                            HandleGameObject(uiFrostwingDoor, false);
+                            if (GameObject* CitadelTp = instance->GetGameObject(uiCitadelTp))
+                            {
+                                CitadelTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                            }
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiSaurfangDoor, false);
+                            HandleGameObject(uiBloodwingDoor, false);
+                            HandleGameObject(uiFrostwingDoor, false);
                         }
                         uiEncounter[3] = data;
                         break;
                     case DATA_FESTERGURT_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                HandleGameObject(uiOrangeMonsterDoor, true);
-                                HandleGameObject(uiOrangePipe, true);
-                                HandleGameObject(uiGasValve, true);
-                                HandleGameObject(uiProfDoorOrange, true);
-                                if (uiEncounter[5] == DONE)
-                                    HandleGameObject(uiProfCollisionDoor, true);
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiOrangeMonsterDoor, true);
-                                HandleGameObject(uiOrangePipe, false);
-                                HandleGameObject(uiGasValve, false);
-                                HandleGameObject(uiProfDoorOrange, false);
-                                break;
-                            case IN_PROGRESS:
-                                HandleGameObject(uiOrangeMonsterDoor, false);
-                                HandleGameObject(uiOrangePipe, false);
-                                HandleGameObject(uiGasValve, false);
-                                HandleGameObject(uiProfDoorOrange, false);
-                                break;
+                            HandleGameObject(uiOrangeMonsterDoor, true);
+                            HandleGameObject(uiOrangePipe, true);
+                            HandleGameObject(uiGasValve, true);
+                            if (uiEncounter[5] == DONE)
+                            {
+                                HandleGameObject(uiProfCollisionDoor, true);
+                                if (GameObject* Oprofessordoor = instance->GetGameObject(uiProfDoorOrange))
+                                {
+                                    Oprofessordoor->SetGoState(GOState(2));
+                                }
+                            }
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiOrangeMonsterDoor, true);
+                            HandleGameObject(uiOrangePipe, false);
+                            HandleGameObject(uiGasValve, false);
+                            HandleGameObject(uiProfDoorOrange, false);
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiOrangeMonsterDoor, false);
+                            HandleGameObject(uiOrangePipe, false);
+                            HandleGameObject(uiGasValve, false);
+                            HandleGameObject(uiProfDoorOrange, false);
                         }
                         uiEncounter[4] = data;
                         break;
                     case DATA_ROTFACE_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                HandleGameObject(uiGreenMonsterDoor, true);
-                                HandleGameObject(uiGreenPipe, true);
-                                HandleGameObject(uiOozeValve, true);
-                                HandleGameObject(uiProfDoorGreen, true);
-                                if (uiEncounter[4] == DONE)
-                                    HandleGameObject(uiProfCollisionDoor, true);
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiGreenMonsterDoor, true);
-                                HandleGameObject(uiGreenPipe, false);
-                                HandleGameObject(uiOozeValve, false);
-                                HandleGameObject(uiProfDoorGreen, false);
-                                break;
-                            case IN_PROGRESS:
-                                HandleGameObject(uiGreenMonsterDoor, false);
-                                HandleGameObject(uiGreenPipe, false);
-                                HandleGameObject(uiOozeValve, false);
-                                HandleGameObject(uiProfDoorGreen, false);
-                                break;
+                            HandleGameObject(uiGreenMonsterDoor, true);
+                            HandleGameObject(uiGreenPipe, true);
+                            HandleGameObject(uiOozeValve, true);
+                            if (uiEncounter[4] == DONE)
+                            {
+                                HandleGameObject(uiProfCollisionDoor, true);
+                                if (GameObject* Gprofessordoor = instance->GetGameObject(uiProfDoorGreen))
+                                {
+                                    Gprofessordoor->SetGoState(GOState(2));
+                                }
+                            }
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiGreenMonsterDoor, true);
+                            HandleGameObject(uiGreenPipe, false);
+                            HandleGameObject(uiOozeValve, false);
+                            HandleGameObject(uiProfDoorGreen, false);
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiGreenMonsterDoor, false);
+                            HandleGameObject(uiGreenPipe, false);
+                            HandleGameObject(uiOozeValve, false);
+                            HandleGameObject(uiProfDoorGreen, false);
                         }
                         uiEncounter[5] = data;
                         break;
                     case DATA_PROFESSOR_PUTRICIDE_EVENT:
-                        switch(data)
-                        {
-                            case DONE:
-                                HandleGameObject(uiProffesorDoor, true);
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiProffesorDoor, true);
-                                break;
-                            case IN_PROGRESS:
-                                HandleGameObject(uiProffesorDoor, false);
-                                break;
-                        }
+                        if(data == DONE)
+                            HandleGameObject(uiProffesorDoor, true);
+                        if(data == NOT_STARTED)
+                            HandleGameObject(uiProffesorDoor, true);
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiProffesorDoor, false);
                         uiEncounter[6] = data;
                         break;
                     case DATA_BLOOD_PRINCE_COUNCIL_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                HandleGameObject(uiCrimsonHallDoor1, true);
-                                HandleGameObject(uiCrimsonHallDoor2, true);
-                                HandleGameObject(uiCrimsonHallDoor3, true);
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiCrimsonHallDoor1, true);
-                                HandleGameObject(uiCrimsonHallDoor2, false);
-                                HandleGameObject(uiCrimsonHallDoor3, false);
-                                break;
-                            case IN_PROGRESS:
-                                HandleGameObject(uiCrimsonHallDoor1, false);
-                                break;
+                            HandleGameObject(uiCrimsonHallDoor1, true);
+                            HandleGameObject(uiCrimsonHallDoor2, true);
+                            HandleGameObject(uiCrimsonHallDoor3, true);
                         }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiCrimsonHallDoor1, true);
+                            HandleGameObject(uiCrimsonHallDoor2, false);
+                            HandleGameObject(uiCrimsonHallDoor3, false);
+                        }
+                        if(data == IN_PROGRESS)
+                            HandleGameObject(uiCrimsonHallDoor1, false);
                         uiEncounter[7] = data;
                         break;
                     case DATA_BLOOD_QUEEN_LANATHEL_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                if (GameObject* pGO = instance->GetGameObject(uiBloodQueenTransporter))
-                                {
-                                    pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
-                                    pGO->SetGoState(GO_STATE_READY);
-                                }
-                                break;
-                            case NOT_STARTED:
-                                break;
-                            case IN_PROGRESS:
-                                break;
+                            if (GameObject* pGO = instance->GetGameObject(uiBloodQueenTransporter))
+                            {
+                                pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                pGO->SetGoState(GO_STATE_READY);
+                            }
                         }
                         uiEncounter[8] = data;
                         break;
                     case DATA_VALITHRIA_DREAMWALKER_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                if (GameObject* pChest = instance->GetGameObject(m_uiDreamwalkerCacheGUID))
-                                {
-                                        pChest->SetRespawnTime(pChest->GetRespawnDelay());
-                                }
-                                if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
-                                {
-                                    SindragossaTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                    SindragossaTp->SetGoState(GOState(0));
-                                }
-                                if (GameObject* pGO = instance->GetGameObject(uiValithriaTransporter))
-                                {
-                                    pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
-                                    pGO->SetGoState(GO_STATE_READY);
-                                }
-                                if (GameObject* pGO = instance->GetGameObject(uiSindragossaTransporter))
-                                {
-                                    pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
-                                    pGO->SetGoState(GO_STATE_READY);
-                                }
-                                HandleGameObject(uiDragonDoor1, true);
-                                HandleGameObject(uiDragonDoor2, true);
-                                HandleGameObject(uiDragonDoor3, true);
+                            if (GameObject* pChest = instance->GetGameObject(m_uiDreamwalkerCacheGUID))
+                            {
+                                pChest->SetRespawnTime(pChest->GetRespawnDelay());
+                            }
+                            if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
+                            {
+                                SindragossaTp->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                                SindragossaTp->SetGoState(GOState(0));
+                            }
+                            if (GameObject* pGO = instance->GetGameObject(uiValithriaTransporter))
+                            {
+                                pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                pGO->SetGoState(GO_STATE_READY);
+                            }
+                            if (GameObject* pGO = instance->GetGameObject(uiSindragossaTransporter))
+                            {
+                                pGO->SetUInt32Value(GAMEOBJECT_LEVEL, 0);
+                                pGO->SetGoState(GO_STATE_READY);
+                            }
+                            HandleGameObject(uiDragonDoor1, true);
+                            HandleGameObject(uiDragonDoor2, true);
+                            HandleGameObject(uiDragonDoor3, true);
+                            HandleGameObject(uiRoostDoor1, false);
+                            HandleGameObject(uiRoostDoor2, false);
+                            HandleGameObject(uiRoostDoor3, false);
+                            HandleGameObject(uiRoostDoor4, false);
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiDragonDoor1, true);
+                            HandleGameObject(uiDragonDoor2, false);
+                            HandleGameObject(uiDragonDoor3, false);
+                            HandleGameObject(uiRoostDoor1, false);
+                            HandleGameObject(uiRoostDoor2, false);
+                            HandleGameObject(uiRoostDoor3, false);
+                            HandleGameObject(uiRoostDoor4, false);
+                            if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
+                                SindragossaTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            if (uiDifficulty == RAID_DIFFICULTY_10MAN_NORMAL || uiDifficulty == RAID_DIFFICULTY_10MAN_HEROIC)
+                            {
+                                HandleGameObject(uiDragonDoor1, false);
+                                HandleGameObject(uiDragonDoor2, false);
+                                HandleGameObject(uiRoostDoor3, true);
+                                HandleGameObject(uiRoostDoor2, true);
                                 HandleGameObject(uiRoostDoor1, false);
-                                HandleGameObject(uiRoostDoor2, false);
-                                HandleGameObject(uiRoostDoor3, false);
                                 HandleGameObject(uiRoostDoor4, false);
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiDragonDoor1, true);
+                            }
+                            else
+                            {
+                                HandleGameObject(uiDragonDoor1, false);
                                 HandleGameObject(uiDragonDoor2, false);
-                                HandleGameObject(uiDragonDoor3, false);
-                                HandleGameObject(uiRoostDoor1, false);
-                                HandleGameObject(uiRoostDoor2, false);
-                                HandleGameObject(uiRoostDoor3, false);
-                                HandleGameObject(uiRoostDoor4, false);
-                                if (GameObject* SindragossaTp = instance->GetGameObject(uiSindragossaTp))
-                                    SindragossaTp->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_INTERACT_COND);
-                                break;
-                            case IN_PROGRESS:
-                                if (uiDifficulty == RAID_DIFFICULTY_10MAN_NORMAL || uiDifficulty == RAID_DIFFICULTY_10MAN_HEROIC)
-                                {
-                                    HandleGameObject(uiDragonDoor1, false);
-                                    HandleGameObject(uiDragonDoor2, false);
-                                    HandleGameObject(uiRoostDoor3, true);
-                                    HandleGameObject(uiRoostDoor2, true);
-                                    HandleGameObject(uiRoostDoor1, false);
-                                    HandleGameObject(uiRoostDoor4, false);
-                                }
-                                else
-                                {
-                                    HandleGameObject(uiDragonDoor1, false);
-                                    HandleGameObject(uiDragonDoor2, false);
-                                    HandleGameObject(uiRoostDoor1, true);
-                                    HandleGameObject(uiRoostDoor2, true);
-                                    HandleGameObject(uiRoostDoor3, true);
-                                    HandleGameObject(uiRoostDoor4, true);
-                                }
-                                break;
+                                HandleGameObject(uiRoostDoor1, true);
+                                HandleGameObject(uiRoostDoor2, true);
+                                HandleGameObject(uiRoostDoor3, true);
+                                HandleGameObject(uiRoostDoor4, true);
                             }
-                            uiEncounter[9] = data;
-                            break;
+                        }
+                        uiEncounter[9] = data;
+                        break;
                     case DATA_SINDRAGOSA_EVENT:
-                        switch(data)
+                        if(data == DONE)
                         {
-                            case DONE:
-                                HandleGameObject(uiSindragosaDoor1, true);
-                                HandleGameObject(uiSindragosaDoor2, true);
-                                break;
-                            case NOT_STARTED:
-                                HandleGameObject(uiSindragosaDoor1, true);
-                                HandleGameObject(uiSindragosaDoor2, true);
-                                break;
-                            case IN_PROGRESS:
-                                HandleGameObject(uiSindragosaDoor1, false);
-                                HandleGameObject(uiSindragosaDoor2, false);
-                                break;
+                            HandleGameObject(uiSindragosaDoor1, true);
+                            HandleGameObject(uiSindragosaDoor2, true);
+                        }
+                        if(data == NOT_STARTED)
+                        {
+                            HandleGameObject(uiSindragosaDoor1, true);
+                            HandleGameObject(uiSindragosaDoor2, true);
+                        }
+                        if(data == IN_PROGRESS)
+                        {
+                            HandleGameObject(uiSindragosaDoor1, false);
+                            HandleGameObject(uiSindragosaDoor2, false);
                         }
                         uiEncounter[10] = data;
                         break;
                 }
 
                 if (data == DONE)
-                {
                     SaveToDB();
-                }
             }
 
             uint32 GetData(uint32 type)
             {
                 switch(type)
                 {
-                    case DATA_MARROWGAR_EVENT:             return uiEncounter[0];
-                    case DATA_DEATHWHISPER_EVENT:          return uiEncounter[1];
-                    case DATA_GUNSHIP_BATTLE_EVENT:        return uiEncounter[2];
-                    case DATA_SAURFANG_EVENT:              return uiEncounter[3];
-                    case DATA_FESTERGURT_EVENT:            return uiEncounter[4];
-                    case DATA_ROTFACE_EVENT:               return uiEncounter[5];
-                    case DATA_PROFESSOR_PUTRICIDE_EVENT:   return uiEncounter[6];
-                    case DATA_BLOOD_PRINCE_COUNCIL_EVENT:  return uiEncounter[7];
-                    case DATA_BLOOD_QUEEN_LANATHEL_EVENT:  return uiEncounter[8];
-                    case DATA_VALITHRIA_DREAMWALKER_EVENT: return uiEncounter[9];
-                    case DATA_SINDRAGOSA_EVENT:            return uiEncounter[10];
-                    case DATA_LICH_KING_EVENT:             return uiEncounter[11];
+                case DATA_MARROWGAR_EVENT:
+                    return uiEncounter[0];
+                case DATA_DEATHWHISPER_EVENT:
+                    return uiEncounter[1];
+                case DATA_GUNSHIP_BATTLE_EVENT:
+                    return uiEncounter[2];
+                case DATA_SAURFANG_EVENT:
+                    return uiEncounter[3];
+                case DATA_FESTERGURT_EVENT:
+                    return uiEncounter[4];
+                case DATA_ROTFACE_EVENT:
+                    return uiEncounter[5];
+                case DATA_PROFESSOR_PUTRICIDE_EVENT:
+                    return uiEncounter[6];
+                case DATA_BLOOD_PRINCE_COUNCIL_EVENT:
+                    return uiEncounter[7];
+                case DATA_BLOOD_QUEEN_LANATHEL_EVENT:
+                    return uiEncounter[8];
+                case DATA_VALITHRIA_DREAMWALKER_EVENT:
+                    return uiEncounter[9];
+                case DATA_SINDRAGOSA_EVENT:
+                    return uiEncounter[10];
+                case DATA_LICH_KING_EVENT:
+                    return uiEncounter[11];
                 }
                 return 0;
             }
@@ -769,7 +763,7 @@
                 OUT_LOAD_INST_DATA(in);
 
                 char dataHead1, dataHead2;
-                uint16 data0,data1,data2,data3,data4,data5,data6,data7,data8,data9,data10,data11;
+                uint32 data0,data1,data2,data3,data4,data5,data6,data7,data8,data9,data10,data11;
 
                 std::istringstream loadStream(in);
                 loadStream >> dataHead1 >> dataHead2 >> data0 >> data1 >> data2 >> data3 >> data4 >> data5 >> data6 >> data7 >> data8 >> data9 >> data10 >> data11;
@@ -790,8 +784,12 @@
                     uiEncounter[11] = data11;
 
                     for (uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+                    {
+                        loadStream >> uiEncounter[i];
+
                         if (uiEncounter[i] == IN_PROGRESS)
                             uiEncounter[i] = NOT_STARTED;
+                    }
 
                 } else OUT_LOAD_INST_DATA_FAIL;
 
@@ -803,8 +801,6 @@
             uint64 uiLadyDeathwhisper;
             uint64 uiGunship;
             uint64 uiDeathbringerSaurfang;
-            uint64 uiSaurfangEventNPC;  // Muradin Bronzebeard or High Overlord Saurfang
-            uint64 uiDeathbringersCache;
             uint64 uiFestergut;
             uint64 uiRotface;
             uint64 uiStinky;
@@ -817,15 +813,12 @@
             uint64 uiBloodQueenLanathel;
             uint64 uiValithriaDreamwalker;
             uint64 uiSindragosa;
-            uint64 uiRimefang;
-            uint64 uiSpinestalker;
             uint64 uiLichKing;
             uint64 uiIceWall1;
             uint64 uiIceWall2;
             uint64 uiMarrowgarEntrance;
             uint64 uiFrozenThrone;
             uint64 m_uiSaurfangCacheGUID;
-            uint64 uiSaurfangTeleport;
             uint64 uiLadyDeathwisperTransporter;
             uint64 uiOratoryDoor;
             uint64 uiSaurfangDoor;
@@ -867,6 +860,9 @@
             uint64 uiSindragossaTp;
             uint64 uiLichTp;
             uint8 uiDifficulty;
+            uint8 uiBoned;
+            uint8 uiSpawn;
+            uint64 uiAngle;
             uint32 uiEncounter[MAX_ENCOUNTER];
         };
 
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_anubrekhan.cpp b/src/server/scripts/Northrend/Naxxramas/boss_anubrekhan.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_anubrekhan.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_anubrekhan.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -24,7 +24,7 @@
 
 #define MOB_CRYPT_GUARD     16573
 
-const Position GuardSummonPos = {3333.72f, -3476.30f, 287.1f, 6.2801f};
+const Position GuardSummonPos = {3333.72, -3476.30, 287.1, 6.2801};
 
 enum Events
 {
@@ -51,30 +51,20 @@
     ACHIEV_TIMED_START_EVENT                      = 9891,
 };
 
-class boss_anubrekhan : public CreatureScript
+struct boss_anubrekhanAI : public BossAI
 {
-public:
-    boss_anubrekhan() : CreatureScript("boss_anubrekhan") { }
+    boss_anubrekhanAI(Creature *c) : BossAI(c, BOSS_ANUBREKHAN) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    bool hasTaunted;
+
+    void Reset()
     {
-        return new boss_anubrekhanAI (pCreature);
-    }
+        _Reset();
 
-    struct boss_anubrekhanAI : public BossAI
-    {
-        boss_anubrekhanAI(Creature *c) : BossAI(c, BOSS_ANUBREKHAN) {}
+        hasTaunted = false;
 
-        bool hasTaunted;
-
-        void Reset()
+        if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
         {
-            _Reset();
-
-            hasTaunted = false;
-
-            //if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
-            //{
             Position pos;
 
             // respawn guard using home position,
@@ -83,118 +73,114 @@
             pos.m_positionY -= 10.0f;
             me->SummonCreature(MOB_CRYPT_GUARD, pos, TEMPSUMMON_CORPSE_DESPAWN);
 
-            if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
+            pos = me->GetHomePosition();
+            pos.m_positionY += 10.0f;
+            me->SummonCreature(MOB_CRYPT_GUARD, pos, TEMPSUMMON_CORPSE_DESPAWN);
+        }
+    }
+
+    void KilledUnit(Unit* victim)
+    {
+        //Force the player to spawn corpse scarabs via spell, TODO: Check percent chance for scarabs, 20% at the moment
+        if (!(rand()%5))
+            if (victim->GetTypeId() == TYPEID_PLAYER)
+                victim->CastSpell(victim, SPELL_SUMMON_CORPSE_SCARABS_PLR, true, NULL, NULL, me->GetGUID());
+
+        DoScriptText(SAY_SLAY, me);
+    }
+
+    void JustDied(Unit *)
+    {
+        _JustDied();
+
+        // start achievement timer (kill Maexna within 20 min)
+        if (instance)
+            instance->DoStartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_TIMED_START_EVENT);
+    }
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+        DoScriptText(SAY_AGGRO, me);
+        events.ScheduleEvent(EVENT_IMPALE, 10000 + rand()%10000);
+        events.ScheduleEvent(EVENT_LOCUST, 90000);
+        events.ScheduleEvent(EVENT_BERSERK, 600000);
+
+        if (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL)
+            events.ScheduleEvent(EVENT_SPAWN_GUARDIAN_NORMAL, urand(15000,20000));
+    }
+
+    void MoveInLineOfSight(Unit *who)
+    {
+        if (!hasTaunted && me->IsWithinDistInMap(who, 60.0f) && who->GetTypeId() == TYPEID_PLAYER)
+        {
+            DoScriptText(SAY_GREET, me);
+            hasTaunted = true;
+        }
+        ScriptedAI::MoveInLineOfSight(who);
+    }
+
+    void SummonedCreatureDespawn(Creature *summon)
+    {
+        BossAI::SummonedCreatureDespawn(summon);
+
+        // check if it is an actual killed guard
+        if (!me->isAlive() || summon->isAlive() || summon->GetEntry() != MOB_CRYPT_GUARD)
+            return;
+
+        summon->CastSpell(summon, SPELL_SUMMON_CORPSE_SCARABS_MOB, true, NULL, NULL, me->GetGUID());
+    }
+
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictim() || !CheckInRoom())
+            return;
+
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
+        {
+            switch(eventId)
             {
-                pos = me->GetHomePosition();
-                pos.m_positionY += 10.0f;
-                me->SummonCreature(MOB_CRYPT_GUARD, pos, TEMPSUMMON_CORPSE_DESPAWN);
+                case EVENT_IMPALE:
+                    //Cast Impale on a random target
+                    //Do NOT cast it when we are afflicted by locust swarm
+                    if (!me->HasAura(RAID_MODE(SPELL_LOCUST_SWARM_10,SPELL_LOCUST_SWARM_25)))
+                        if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                            DoCast(pTarget, RAID_MODE(SPELL_IMPALE_10,SPELL_IMPALE_25));
+                    events.ScheduleEvent(EVENT_IMPALE, urand(10000,20000));
+                    break;
+                case EVENT_LOCUST:
+                    // TODO : Add Text
+                    DoCast(me, RAID_MODE(SPELL_LOCUST_SWARM_10,SPELL_LOCUST_SWARM_25));
+                    DoSummon(MOB_CRYPT_GUARD, GuardSummonPos, 0, TEMPSUMMON_CORPSE_DESPAWN);
+                    events.ScheduleEvent(EVENT_LOCUST, 90000);
+                    break;
+                case EVENT_SPAWN_GUARDIAN_NORMAL:
+                    // TODO : Add Text
+                    DoSummon(MOB_CRYPT_GUARD, GuardSummonPos, 0, TEMPSUMMON_CORPSE_DESPAWN);
+                    break;
+                case EVENT_BERSERK:
+                    DoCast(me, SPELL_BERSERK, true);
+                    events.ScheduleEvent(EVENT_BERSERK, 600000);
+                    break;
             }
         }
 
-        void KilledUnit(Unit* victim)
-        {
-            //Force the player to spawn corpse scarabs via spell, TODO: Check percent chance for scarabs, 20% at the moment
-            if (!(rand()%5))
-                if (victim->GetTypeId() == TYPEID_PLAYER)
-                    victim->CastSpell(victim, SPELL_SUMMON_CORPSE_SCARABS_PLR, true, NULL, NULL, me->GetGUID());
-
-            DoScriptText(SAY_SLAY, me);
-        }
-
-        void JustDied(Unit *)
-        {
-            _JustDied();
-
-            // start achievement timer (kill Maexna within 20 min)
-            if (instance)
-                instance->DoStartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_TIMED_START_EVENT);
-        }
-
-        void EnterCombat(Unit * /*who*/)
-        {
-            _EnterCombat();
-            DoScriptText(SAY_AGGRO, me);
-            events.ScheduleEvent(EVENT_IMPALE, 10000 + rand()%10000);
-            events.ScheduleEvent(EVENT_LOCUST, urand(80000,120000));
-            events.ScheduleEvent(EVENT_BERSERK, 600000);
-
-            //if (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL)
-            events.ScheduleEvent(EVENT_SPAWN_GUARDIAN_NORMAL, urand(15000,20000));
-        }
-
-        void MoveInLineOfSight(Unit *who)
-        {
-            if (!hasTaunted && me->IsWithinDistInMap(who, 60.0f) && who->GetTypeId() == TYPEID_PLAYER)
-            {
-                DoScriptText(SAY_GREET, me);
-                hasTaunted = true;
-            }
-            ScriptedAI::MoveInLineOfSight(who);
-        }
-
-        void SummonedCreatureDespawn(Creature *summon)
-        {
-            BossAI::SummonedCreatureDespawn(summon);
-
-            // check if it is an actual killed guard
-            if (!me->isAlive() || summon->isAlive() || summon->GetEntry() != MOB_CRYPT_GUARD)
-                return;
-
-            summon->CastSpell(summon, SPELL_SUMMON_CORPSE_SCARABS_MOB, true, NULL, NULL, me->GetGUID());
-        }
-
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim() || !CheckInRoom())
-                return;
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_IMPALE:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            //Cast Impale on a random target
-                            //Do NOT cast it when we are afflicted by locust swarm
-                            if (!me->HasAura(RAID_MODE(SPELL_LOCUST_SWARM_10,SPELL_LOCUST_SWARM_25)))
-                                if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
-                                    DoCast(pTarget, RAID_MODE(SPELL_IMPALE_10,SPELL_IMPALE_25));
-                            events.ScheduleEvent(EVENT_IMPALE, urand(10000,20000));
-                        }
-                        break;
-                    case EVENT_LOCUST:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            // TODO : Add Text
-                            DoCast(me, RAID_MODE(SPELL_LOCUST_SWARM_10,SPELL_LOCUST_SWARM_25));
-                            DoSummon(MOB_CRYPT_GUARD, GuardSummonPos, 0, TEMPSUMMON_CORPSE_DESPAWN);
-                            events.ScheduleEvent(EVENT_LOCUST, urand(85000,95000));
-                        }
-                        break;
-                    case EVENT_SPAWN_GUARDIAN_NORMAL:
-                        // TODO : Add Text
-                        DoSummon(MOB_CRYPT_GUARD, GuardSummonPos, 0, TEMPSUMMON_CORPSE_DESPAWN);
-                        break;
-                    case EVENT_BERSERK:
-                        if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
-                            DoCast(me, SPELL_BERSERK, true);
-                        events.ScheduleEvent(EVENT_BERSERK, 600000);
-                        break;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_boss_anubrekhan(Creature* pCreature)
+{
+    return new boss_anubrekhanAI (pCreature);
+}
 
 void AddSC_boss_anubrekhan()
 {
-    new boss_anubrekhan();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_anubrekhan";
+    newscript->GetAI = &GetAI_boss_anubrekhan;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp b/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_faerlina.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 #include "ScriptPCH.h"
 #include "naxxramas.h"
 
@@ -40,10 +40,7 @@
     SPELL_FRENZY                = 28798,
     H_SPELL_FRENZY              = 54100,
     SPELL_WIDOWS_EMBRACE        = 28732,
-    H_SPELL_WIDOWS_EMBRACE      = 54097,
-
-    SPELL_FIREBALL              = 54095,
-    H_SPELL_FIREBALL            = 54096
+    H_SPELL_WIDOWS_EMBRACE      = 54097
 };
 
 enum Events
@@ -60,200 +57,161 @@
     ACHIEVEMENT_MOMMA_SAID_KNOCK_YOU_OUT_25 = 2140
 };
 
-class boss_faerlina : public CreatureScript
+struct boss_faerlinaAI : public BossAI
 {
-public:
-    boss_faerlina() : CreatureScript("boss_faerlina") { }
+    boss_faerlinaAI(Creature *c) : BossAI(c, BOSS_FAERLINA), greet(false) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    bool greet;
+    bool doDelayFrenzy;
+    bool bAchievement;
+
+    void EnterCombat(Unit * /*who*/)
     {
-        return new boss_faerlinaAI (pCreature);
+        _EnterCombat();
+        DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2,SAY_AGGRO_3,SAY_AGGRO_4), me);
+        events.ScheduleEvent(EVENT_POISON, urand(10000,15000));
+        events.ScheduleEvent(EVENT_FIRE, urand(6000,18000));
+        events.ScheduleEvent(EVENT_FRENZY, urand(60000,80000));
     }
 
-    struct boss_faerlinaAI : public BossAI
+    void Reset()
     {
-        boss_faerlinaAI(Creature *c) : BossAI(c, BOSS_FAERLINA), greet(false) {}
+        doDelayFrenzy = false;
+        bAchievement = true;
+        _Reset();
+    }
 
-        bool greet;
-        bool doDelayFrenzy;
-        bool bAchievement;
+    void MoveInLineOfSight(Unit *who)
+    {
+        if (!greet && who->GetTypeId() == TYPEID_PLAYER)
+        {
+            DoScriptText(SAY_GREET, me);
+            greet = true;
+        }
+        BossAI::MoveInLineOfSight(who);
+    }
 
-        void EnterCombat(Unit * /*who*/)
+    void KilledUnit(Unit* /*victim*/)
+    {
+        if (!(rand()%3))
+            DoScriptText(RAND(SAY_SLAY_1,SAY_SLAY_2), me);
+    }
+
+    void JustDied(Unit* /*Killer*/)
+    {
+        _JustDied();
+        DoScriptText(SAY_DEATH, me);
+
+        if (instance && bAchievement)
+            instance->DoCompleteAchievement(RAID_MODE(ACHIEVEMENT_MOMMA_SAID_KNOCK_YOU_OUT_10,ACHIEVEMENT_MOMMA_SAID_KNOCK_YOU_OUT_25));
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictim())
+            return;
+
+        if (doDelayFrenzy && !me->HasAura(RAID_MODE(SPELL_WIDOWS_EMBRACE, H_SPELL_WIDOWS_EMBRACE)))
         {
-            _EnterCombat();
-            DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2,SAY_AGGRO_3,SAY_AGGRO_4), me);
-            events.ScheduleEvent(EVENT_POISON, urand(10000,15000));
-            events.ScheduleEvent(EVENT_FIRE, urand(6000,18000));
-            events.ScheduleEvent(EVENT_FRENZY, urand(60000,80000));
+            doDelayFrenzy = false;
+            DoCast(me, RAID_MODE(SPELL_FRENZY, H_SPELL_FRENZY), true);
         }
 
-        void Reset()
+        events.Update(diff);
+
+        if (me->hasUnitState(UNIT_STAT_CASTING))
+            return;
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            _Reset();
-            doDelayFrenzy = false;
-            bAchievement = true;
+            switch(eventId)
+            {
+                case EVENT_POISON:
+                    if (!me->HasAura(RAID_MODE(SPELL_WIDOWS_EMBRACE,H_SPELL_WIDOWS_EMBRACE)))
+                        DoCastAOE(RAID_MODE(SPELL_POISON_BOLT_VOLLEY,H_SPELL_POISON_BOLT_VOLLEY));
+                    events.ScheduleEvent(EVENT_POISON, urand(8000,15000));
+                    break;
+                case EVENT_FIRE:
+                    if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                        DoCast(pTarget, RAID_MODE(SPELL_RAIN_OF_FIRE, H_SPELL_RAIN_OF_FIRE));
+                    events.ScheduleEvent(EVENT_FIRE, urand(6000,18000));
+                    break;
+                case EVENT_FRENZY:
+                    // TODO : Add Text
+                    if (!me->HasAura(RAID_MODE(SPELL_WIDOWS_EMBRACE,H_SPELL_WIDOWS_EMBRACE)))
+                        DoCast(me, RAID_MODE(SPELL_FRENZY, H_SPELL_FRENZY));
+                    else
+                        doDelayFrenzy = true;
+
+                    events.ScheduleEvent(EVENT_FRENZY, urand(60000,80000));
+                    break;
+            }
         }
 
-        void MoveInLineOfSight(Unit *who)
+        DoMeleeAttackIfReady();
+    }
+
+    void SpellHit(Unit* caster, const SpellEntry *spell)
+    {
+        if (spell->Id == SPELL_WIDOWS_EMBRACE || spell->Id == H_SPELL_WIDOWS_EMBRACE)
         {
-            if (!greet && who->GetTypeId() == TYPEID_PLAYER)
-            {
-                DoScriptText(SAY_GREET, me);
-                greet = true;
-            }
-            BossAI::MoveInLineOfSight(who);
+             // TODO : Add Text
+             bAchievement = false;
+             doDelayFrenzy = true;
+             me->Kill(caster);
         }
-
-        void KilledUnit(Unit* victim)
-        {
-            if (!victim->isPet())
-                if (!(rand()%3))
-                    DoScriptText(RAND(SAY_SLAY_1,SAY_SLAY_2), me);
-        }
-
-        void JustDied(Unit* /*Killer*/)
-        {
-            _JustDied();
-            DoScriptText(SAY_DEATH, me);
-
-            if (instance && bAchievement)
-                instance->DoCompleteAchievement(RAID_MODE(ACHIEVEMENT_MOMMA_SAID_KNOCK_YOU_OUT_10,ACHIEVEMENT_MOMMA_SAID_KNOCK_YOU_OUT_25));
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            if (doDelayFrenzy && !me->HasAura(RAID_MODE(SPELL_WIDOWS_EMBRACE, H_SPELL_WIDOWS_EMBRACE)))
-            {
-                doDelayFrenzy = false;
-                DoCast(me, RAID_MODE(SPELL_FRENZY, H_SPELL_FRENZY), true);
-            }
-
-            events.Update(diff);
-
-            if (me->hasUnitState(UNIT_STAT_CASTING))
-                return;
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_POISON:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            if (!me->HasAura(RAID_MODE(SPELL_WIDOWS_EMBRACE,H_SPELL_WIDOWS_EMBRACE)))
-                                DoCastAOE(RAID_MODE(SPELL_POISON_BOLT_VOLLEY,H_SPELL_POISON_BOLT_VOLLEY));
-                            events.ScheduleEvent(EVENT_POISON, urand(8000,15000));
-                        }
-                        break;
-                    case EVENT_FIRE:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
-                                DoCast(pTarget, RAID_MODE(SPELL_RAIN_OF_FIRE, H_SPELL_RAIN_OF_FIRE));
-                            events.ScheduleEvent(EVENT_FIRE, urand(6000,18000));
-                        }
-                        break;
-                    case EVENT_FRENZY:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            // TODO : Add Text
-                            if (!me->HasAura(RAID_MODE(SPELL_WIDOWS_EMBRACE,H_SPELL_WIDOWS_EMBRACE)))
-                                DoCast(me, RAID_MODE(SPELL_FRENZY, H_SPELL_FRENZY));
-                            else
-                                doDelayFrenzy = true;
-
-                            events.ScheduleEvent(EVENT_FRENZY, urand(60000,80000));
-                        }
-                        break;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-
-        void SpellHit(Unit* caster, const SpellEntry *spell)
-        {
-            if (spell->Id == SPELL_WIDOWS_EMBRACE || spell->Id == H_SPELL_WIDOWS_EMBRACE)
-            {
-                 // TODO : Add Text
-                 bAchievement = false;
-                 doDelayFrenzy = false;
-                 me->RemoveAurasDueToSpell(SPELL_FRENZY);
-                 me->RemoveAurasDueToSpell(H_SPELL_FRENZY);
-                 me->Kill(caster);
-            }
-        }
-    };
-
+    }
 };
 
+CreatureAI* GetAI_boss_faerlina(Creature* pCreature)
+{
+    return new boss_faerlinaAI (pCreature);
+}
 
-class mob_faerlina_add : public CreatureScript
+struct mob_faerlina_addAI : public ScriptedAI
 {
-public:
-    mob_faerlina_add() : CreatureScript("mob_faerlina_add") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
+    mob_faerlina_addAI(Creature* pCreature) : ScriptedAI(pCreature)
     {
-        return new mob_faerlina_addAI (pCreature);
+        pInstance = pCreature->GetInstanceData();
     }
 
-    struct mob_faerlina_addAI : public ScriptedAI
+    ScriptedInstance *pInstance;
+
+    void Reset()
     {
-        mob_faerlina_addAI(Creature* pCreature) : ScriptedAI(pCreature)
+        if (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL) {
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, SPELL_EFFECT_BIND, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
+        }
+    }
+
+    void JustDied(Unit * /*killer*/)
+    {
+        if (pInstance && getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL)
         {
-            pInstance = pCreature->GetInstanceScript();
+            if (Creature *pFaerlina = pInstance->instance->GetCreature(pInstance->GetData64(DATA_FAERLINA)))
+                DoCast(pFaerlina, SPELL_WIDOWS_EMBRACE);
         }
-
-        InstanceScript *pInstance;
-        uint32 uiFireBallTimer;
-
-        void Reset()
-        {
-            if (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL)
-            {
-                me->ApplySpellImmune(0, IMMUNITY_MECHANIC, SPELL_EFFECT_BIND, true);
-                me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_CHARM, true);
-            }
-
-            uiFireBallTimer = urand(10000,15000);
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            if(uiFireBallTimer <= diff)
-            {
-                DoCast(me->getVictim(), DUNGEON_MODE(SPELL_FIREBALL,H_SPELL_FIREBALL));
-                uiFireBallTimer = urand(5000,10000);
-            }else uiFireBallTimer -= diff;
-
-            DoMeleeAttackIfReady();
-        }
-
-        void JustDied(Unit * /*killer*/)
-        {
-            if (pInstance && getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL)
-            {
-                if (Creature *pFaerlina = pInstance->instance->GetCreature(pInstance->GetData64(DATA_FAERLINA)))
-                {
-                    me->InterruptNonMeleeSpells(false);
-                    DoCast(pFaerlina, SPELL_WIDOWS_EMBRACE);
-                }
-            }
-        }
-    };
-
+    }
 };
 
+CreatureAI* GetAI_mob_faerlina_add(Creature* pCreature)
+{
+    return new mob_faerlina_addAI (pCreature);
+}
 
 void AddSC_boss_faerlina()
 {
-    new boss_faerlina();
-    new mob_faerlina_add();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_faerlina";
+    newscript->GetAI = &GetAI_boss_faerlina;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_faerlina_add";
+    newscript->GetAI = &GetAI_mob_faerlina_add;
+    newscript->RegisterSelf();
 }
+
+
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp b/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 #include "ScriptPCH.h"
 #include "naxxramas.h"
 
@@ -37,21 +37,21 @@
 const Position WaypointPositions[12] =
 {
     // Thane waypoints
-    {2542.3f, -2984.1f, 241.49f, 5.362f},
-    {2547.6f, -2999.4f, 241.34f, 5.049f},
-    {2542.9f, -3015.0f, 241.35f, 4.654f},
+    {2542.3, -2984.1, 241.49, 5.362},
+    {2547.6, -2999.4, 241.34, 5.049},
+    {2542.9, -3015.0, 241.35, 4.654},
     // Lady waypoints
-    {2498.3f, -2961.8f, 241.28f, 3.267f},
-    {2487.7f, -2959.2f, 241.28f, 2.890f},
-    {2469.4f, -2947.6f, 241.28f, 2.576f},
+    {2498.3, -2961.8, 241.28, 3.267},
+    {2487.7, -2959.2, 241.28, 2.890},
+    {2469.4, -2947.6, 241.28, 2.576},
     // Baron waypoints
-    {2553.8f, -2968.4f, 241.33f, 5.757f},
-    {2564.3f, -2972.5f, 241.33f, 5.890f},
-    {2583.9f, -2971.67f, 241.35f, 0.008f},
+    {2553.8, -2968.4, 241.33, 5.757},
+    {2564.3, -2972.5, 241.33, 5.890},
+    {2583.9, -2971.67, 241.35, 0.008},
     // Sir waypoints
-    {2534.5f, -2921.7f, 241.53f, 1.363f},
-    {2523.5f, -2902.8f, 241.28f, 2.095f},
-    {2517.8f, -2896.6f, 241.28f, 2.315f},
+    {2534.5, -2921.7, 241.53, 1.363},
+    {2523.5, -2902.8, 241.28, 2.095},
+    {2517.8, -2896.6, 241.28, 2.315},
 };
 
 const uint32 MOB_HORSEMEN[]     =   {16064, 16065, 30549, 16063};
@@ -77,342 +77,322 @@
 #define SAY_BARON_AGGRO     RAND(-1533065,-1533066,-1533067)
 #define SAY_BARON_SLAY      RAND(-1533068,-1533069)
 
-class boss_four_horsemen : public CreatureScript
+struct boss_four_horsemenAI : public BossAI
 {
-public:
-    boss_four_horsemen() : CreatureScript("boss_four_horsemen") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
+    boss_four_horsemenAI(Creature *c) : BossAI(c, BOSS_HORSEMEN)
     {
-        return new boss_four_horsemenAI (pCreature);
+        id = Horsemen(0);
+        for (uint8 i = 0; i < 4; ++i)
+            if (me->GetEntry() == MOB_HORSEMEN[i])
+                id = Horsemen(i);
+        caster = (id == HORSEMEN_LADY || id == HORSEMEN_SIR);
     }
 
-    struct boss_four_horsemenAI : public BossAI
+    Horsemen id;
+    uint64 uiEventStarterGUID;
+    uint8 nextWP;
+    uint32 punishTimer;
+    bool caster;
+    bool nextMovementStarted;
+    bool movementCompleted;
+    bool movementStarted;
+    bool encounterActionAttack;
+    bool encounterActionReset;
+    bool doDelayPunish;
+
+    void Reset()
     {
-        boss_four_horsemenAI(Creature *c) : BossAI(c, BOSS_HORSEMEN)
+        if (!encounterActionReset)
+            DoEncounterAction(NULL, false, true, false);
+
+        if (instance)
+            instance->SetData(DATA_HORSEMEN0 + id, NOT_STARTED);
+
+        me->SetReactState(REACT_AGGRESSIVE);
+        uiEventStarterGUID = 0;
+        nextWP = 0;
+        punishTimer = 2000;
+        nextMovementStarted = false;
+        movementCompleted = false;
+        movementStarted = false;
+        encounterActionAttack = false;
+        encounterActionReset = false;
+        doDelayPunish = false;
+        _Reset();
+    }
+
+    bool DoEncounterAction(Unit *who, bool attack, bool reset, bool checkAllDead)
+    {
+        if (!instance)
+            return false;
+
+        Creature *Thane = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_THANE)));
+        Creature *Lady = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_LADY)));
+        Creature *Baron = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_BARON)));
+        Creature *Sir = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_SIR)));
+
+        if (Thane && Lady && Baron && Sir)
         {
-            id = Horsemen(0);
-            for (uint8 i = 0; i < 4; ++i)
-                if (me->GetEntry() == MOB_HORSEMEN[i])
-                    id = Horsemen(i);
-            caster = (id == HORSEMEN_LADY || id == HORSEMEN_SIR);
+            if (attack && who)
+            {
+                CAST_AI(boss_four_horsemenAI, Thane->AI())->encounterActionAttack = true;
+                CAST_AI(boss_four_horsemenAI, Lady->AI())->encounterActionAttack = true;
+                CAST_AI(boss_four_horsemenAI, Baron->AI())->encounterActionAttack = true;
+                CAST_AI(boss_four_horsemenAI, Sir->AI())->encounterActionAttack = true;
+
+                CAST_AI(boss_four_horsemenAI, Thane->AI())->AttackStart(who);
+                CAST_AI(boss_four_horsemenAI, Lady->AI())->AttackStart(who);
+                CAST_AI(boss_four_horsemenAI, Baron->AI())->AttackStart(who);
+                CAST_AI(boss_four_horsemenAI, Sir->AI())->AttackStart(who);
+            }
+
+            if (reset)
+            {
+                if (instance->GetBossState(BOSS_HORSEMEN) != NOT_STARTED)
+                {
+                    if (!Thane->isAlive())
+                        Thane->Respawn();
+
+                    if (!Lady->isAlive())
+                        Lady->Respawn();
+
+                    if (!Baron->isAlive())
+                        Baron->Respawn();
+
+                    if (!Sir->isAlive())
+                        Sir->Respawn();
+
+                    CAST_AI(boss_four_horsemenAI, Thane->AI())->encounterActionReset = true;
+                    CAST_AI(boss_four_horsemenAI, Lady->AI())->encounterActionReset = true;
+                    CAST_AI(boss_four_horsemenAI, Baron->AI())->encounterActionReset = true;
+                    CAST_AI(boss_four_horsemenAI, Sir->AI())->encounterActionReset = true;
+
+                    CAST_AI(boss_four_horsemenAI, Thane->AI())->EnterEvadeMode();
+                    CAST_AI(boss_four_horsemenAI, Lady->AI())->EnterEvadeMode();
+                    CAST_AI(boss_four_horsemenAI, Baron->AI())->EnterEvadeMode();
+                    CAST_AI(boss_four_horsemenAI, Sir->AI())->EnterEvadeMode();
+                }
+            }
+
+            if (checkAllDead)
+                return !Thane->isAlive() && !Lady->isAlive() && !Baron->isAlive() && !Sir->isAlive();
+        }
+        return false;
+    }
+
+    void BeginFourHorsemenMovement()
+    {
+        movementStarted = true;
+        me->SetReactState(REACT_PASSIVE);
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
+        me->SetSpeed(MOVE_RUN, me->GetSpeedRate(MOVE_RUN), true);
+
+        switch(id)
+        {
+            case HORSEMEN_THANE:
+                me->GetMotionMaster()->MovePoint(0, WaypointPositions[0]);
+                break;
+            case HORSEMEN_LADY:
+                me->GetMotionMaster()->MovePoint(3, WaypointPositions[3]);
+                break;
+            case HORSEMEN_BARON:
+                me->GetMotionMaster()->MovePoint(6, WaypointPositions[6]);
+                break;
+            case HORSEMEN_SIR:
+                me->GetMotionMaster()->MovePoint(9, WaypointPositions[9]);
+                break;
+        }
+    }
+
+    void MovementInform(uint32 type, uint32 id)
+    {
+        if (type != POINT_MOTION_TYPE)
+            return;
+
+        if (id == 2 || id == 5 || id == 8 || id == 11)
+        {
+            movementCompleted = true;
+            me->SetReactState(REACT_AGGRESSIVE);
+
+            Unit *eventStarter = Unit::GetUnit(*me, uiEventStarterGUID);
+
+            if (eventStarter && me->canAttack(eventStarter))
+                AttackStart(eventStarter);
+            else if (!UpdateVictim())
+            {
+                EnterEvadeMode();
+                return;
+            }
+
+            if (caster)
+            {
+                me->GetMotionMaster()->Clear();
+                me->GetMotionMaster()->MoveIdle();
+            }
+
+            return;
         }
 
-        Horsemen id;
-        uint64 uiEventStarterGUID;
-        uint8 nextWP;
-        uint32 punishTimer;
-        bool caster;
-        bool nextMovementStarted;
-        bool movementCompleted;
-        bool movementStarted;
-        bool encounterActionAttack;
-        bool encounterActionReset;
-        bool doDelayPunish;
+        nextMovementStarted = false;
+        nextWP = id + 1;
+    }
 
-        void Reset()
+    // switch to "who" if nearer than current target.
+    void SelectNearestTarget(Unit *who)
+    {
+        if (me->getVictim() && me->GetDistanceOrder(who, me->getVictim()) && me->canAttack(who))
         {
-            if (!encounterActionReset)
-                DoEncounterAction(NULL, false, true, false);
+            me->getThreatManager().modifyThreatPercent(me->getVictim(), -100);
+            me->AddThreat(who, 1000000.0f);
+        }
+    }
 
-            if (instance)
-                instance->SetData(DATA_HORSEMEN0 + id, NOT_STARTED);
+    void MoveInLineOfSight(Unit *who)
+    {
+        BossAI::MoveInLineOfSight(who);
+        if (caster)
+            SelectNearestTarget(who);
+    }
 
-            me->SetReactState(REACT_AGGRESSIVE);
-            uiEventStarterGUID = 0;
-            nextWP = 0;
-            punishTimer = 2000;
-            nextMovementStarted = false;
-            movementCompleted = false;
-            movementStarted = false;
-            encounterActionAttack = false;
-            encounterActionReset = false;
-            doDelayPunish = false;
-            _Reset();
-             
+    void AttackStart(Unit *who)
+    {
+        if (!movementCompleted && !movementStarted)
+        {
+            uiEventStarterGUID = who->GetGUID();
+            BeginFourHorsemenMovement();
+
+            if (!encounterActionAttack)
+                DoEncounterAction(who, true, false, false);
+        }
+        else if (movementCompleted && movementStarted)
+        {
+            if (caster)
+                me->Attack(who, false);
+            else
+                BossAI::AttackStart(who);
+        }
+    }
+
+    void KilledUnit(Unit* /*victim*/)
+    {
+        if (!(rand()%5))
+        {
+            if (id == HORSEMEN_BARON)
+                DoScriptText(SAY_BARON_SLAY, me);
+            else
+                DoScriptText(SAY_SLAY[id], me);
+        }
+    }
+
+    void JustDied(Unit* /*killer*/)
+    {
+        events.Reset();
+        summons.DespawnAll();
+
+        if (instance)
+            instance->SetData(DATA_HORSEMEN0 + id, DONE);
+
+        if (instance && DoEncounterAction(NULL, false, false, true))
+        {
+            instance->SetBossState(BOSS_HORSEMEN, DONE);
+            instance->SaveToDB();
+
+            // Achievements related to the 4-horsemen are given through spell 59450 which does not exist.
+            // There is thus no way it can be given by casting the spell on the players.
+            instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, 59450);
         }
 
-        bool DoEncounterAction(Unit *who, bool attack, bool reset, bool checkAllDead)
+        DoScriptText(SAY_DEATH[id], me);
+    }
+
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+
+        if (id == HORSEMEN_BARON)
+            DoScriptText(SAY_BARON_AGGRO, me);
+        else
+            DoScriptText(SAY_AGGRO[id], me);
+
+        events.ScheduleEvent(EVENT_MARK, 15000);
+        events.ScheduleEvent(EVENT_CAST, 20000+rand()%5000);
+        events.ScheduleEvent(EVENT_BERSERK, 15*100*1000);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (nextWP && movementStarted && !movementCompleted && !nextMovementStarted)
         {
-            if (!instance)
-                return false;
-
-            Creature *Thane = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_THANE)));
-            Creature *Lady = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_LADY)));
-            Creature *Baron = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_BARON)));
-            Creature *Sir = CAST_CRE(Unit::GetUnit(*me, instance->GetData64(DATA_SIR)));
-
-            if (Thane && Lady && Baron && Sir)
-            {
-                if (attack && who)
-                {
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Thane->AI())->encounterActionAttack = true;
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Lady->AI())->encounterActionAttack = true;
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Baron->AI())->encounterActionAttack = true;
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Sir->AI())->encounterActionAttack = true;
-
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Thane->AI())->AttackStart(who);
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Lady->AI())->AttackStart(who);
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Baron->AI())->AttackStart(who);
-                    CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Sir->AI())->AttackStart(who);
-                }
-
-                if (reset)
-                {
-                    if (instance->GetBossState(BOSS_HORSEMEN) != NOT_STARTED)
-                    {
-                        if (!Thane->isAlive())
-                            Thane->Respawn();
-
-                        if (!Lady->isAlive())
-                            Lady->Respawn();
-
-                        if (!Baron->isAlive())
-                            Baron->Respawn();
-
-                        if (!Sir->isAlive())
-                            Sir->Respawn();
-
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Thane->AI())->encounterActionReset = true;
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Lady->AI())->encounterActionReset = true;
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Baron->AI())->encounterActionReset = true;
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Sir->AI())->encounterActionReset = true;
-
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Thane->AI())->EnterEvadeMode();
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Lady->AI())->EnterEvadeMode();
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Baron->AI())->EnterEvadeMode();
-                        CAST_AI(boss_four_horsemen::boss_four_horsemenAI, Sir->AI())->EnterEvadeMode();
-                    }
-                }
-
-                if (checkAllDead)
-                    return !Thane->isAlive() && !Lady->isAlive() && !Baron->isAlive() && !Sir->isAlive();
-            }
-            return false;
+            nextMovementStarted = true;
+            me->GetMotionMaster()->MovePoint(nextWP, WaypointPositions[nextWP]);
         }
 
-        void BeginFourHorsemenMovement()
+        if (!UpdateVictim() || !CheckInRoom() || !movementCompleted)
+            return;
+
+        events.Update(diff);
+
+        if (me->hasUnitState(UNIT_STAT_CASTING))
+            return;
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            movementStarted = true;
-            me->SetReactState(REACT_PASSIVE);
-            me->RemoveUnitMovementFlag(MOVEMENTFLAG_WALKING);
-            me->SetSpeed(MOVE_RUN, me->GetSpeedRate(MOVE_RUN), true);
+            switch(eventId)
+            {
+                case EVENT_MARK:
+                    if (!(rand()%5))
+                        DoScriptText(SAY_SPECIAL[id], me);
+                    DoCastAOE(SPELL_MARK[id]);
+                    events.ScheduleEvent(EVENT_MARK, 15000);
+                    break;
+                case EVENT_CAST:
+                    if (!(rand()%5))
+                        DoScriptText(SAY_TAUNT[rand()%3][id], me);
 
-            switch(id)
-            {
-                case HORSEMEN_THANE:
-                    me->GetMotionMaster()->MovePoint(0, WaypointPositions[0]);
+                    if (caster)
+                    {
+                        if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 45.0f))
+                            DoCast(pTarget, SPELL_PRIMARY(id));
+                    }
+                    else
+                        DoCast(me->getVictim(), SPELL_PRIMARY(id));
+
+                    events.ScheduleEvent(EVENT_CAST, 15000);
                     break;
-                case HORSEMEN_LADY:
-                    me->GetMotionMaster()->MovePoint(3, WaypointPositions[3]);
-                    break;
-                case HORSEMEN_BARON:
-                    me->GetMotionMaster()->MovePoint(6, WaypointPositions[6]);
-                    break;
-                case HORSEMEN_SIR:
-                    me->GetMotionMaster()->MovePoint(9, WaypointPositions[9]);
+                case EVENT_BERSERK:
+                    DoScriptText(SAY_SPECIAL[id], me);
+                    DoCast(me, EVENT_BERSERK);
                     break;
             }
         }
 
-        void MovementInform(uint32 type, uint32 id)
+        if (punishTimer <= diff)
         {
-            if (type != POINT_MOTION_TYPE)
-                return;
+            if (doDelayPunish)
+            {
+                DoCastAOE(SPELL_PUNISH[id], true);
+                doDelayPunish = false;
+            }
+            punishTimer = 2000;
+        } else punishTimer -= diff;
 
-            if (id == 2 || id == 5 || id == 8 || id == 11)
-            {
-                movementCompleted = true;
-                me->SetReactState(REACT_AGGRESSIVE);
+        if (!caster)
+            DoMeleeAttackIfReady();
+        else if ((!DoSpellAttackIfReady(SPELL_SECONDARY(id)) || !me->IsWithinLOSInMap(me->getVictim())) && movementCompleted && !doDelayPunish)
+            doDelayPunish = true;
+    }
+};
 
-                Unit *eventStarter = Unit::GetUnit(*me, uiEventStarterGUID);
-
-                if (eventStarter && me->canAttack(eventStarter))
-                    AttackStart(eventStarter);
-                else if (!UpdateVictim())
-                {
-                    EnterEvadeMode();
-                    return;
-                }
-
-                if (caster)
-                {
-                    me->GetMotionMaster()->Clear();
-                    me->GetMotionMaster()->MoveIdle();
-                }
-
-                return;
-            }
-
-            nextMovementStarted = false;
-            nextWP = id + 1;
-        }
-
-        // switch to "who" if nearer than current target.
-        void SelectNearestTarget(Unit *who)
-        {
-            if (me->getVictim() && me->GetDistanceOrder(who, me->getVictim()) && me->canAttack(who))
-            {
-                me->getThreatManager().modifyThreatPercent(me->getVictim(), -100);
-                me->AddThreat(who, 1000000.0f);
-            }
-        }
-
-        void MoveInLineOfSight(Unit *who)
-        {
-            BossAI::MoveInLineOfSight(who);
-            if (caster)
-                SelectNearestTarget(who);
-        }
-
-        void AttackStart(Unit *who)
-        {
-            if (!movementCompleted && !movementStarted)
-            {
-                uiEventStarterGUID = who->GetGUID();
-                BeginFourHorsemenMovement();
-
-                if (!encounterActionAttack)
-                    DoEncounterAction(who, true, false, false);
-            }
-            else if (movementCompleted && movementStarted)
-            {
-                if (caster)
-                    me->Attack(who, false);
-                else
-                    BossAI::AttackStart(who);
-            }
-        }
-
-        void KilledUnit(Unit* /*victim*/)
-        {
-            if (!(rand()%5))
-            {
-                if (id == HORSEMEN_BARON)
-                    DoScriptText(SAY_BARON_SLAY, me);
-                else
-                    DoScriptText(SAY_SLAY[id], me);
-            }
-        }
-
-        void JustDied(Unit* /*killer*/)
-        {
-            events.Reset();
-            summons.DespawnAll();
-
-            if (instance)
-                instance->SetData(DATA_HORSEMEN0 + id, DONE);
-
-            if (instance && DoEncounterAction(NULL, false, false, true))
-            {
-                instance->SetBossState(BOSS_HORSEMEN, DONE);
-                instance->SaveToDB();
-
-                // Achievements related to the 4-horsemen are given through spell 59450 which does not exist.
-                // There is thus no way it can be given by casting the spell on the players.
-                instance->DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, 59450);
-            }
-
-            DoScriptText(SAY_DEATH[id], me);
-        }
-
-        void EnterCombat(Unit * /*who*/)
-        {
-            _EnterCombat();
-
-            if (id == HORSEMEN_BARON)
-                DoScriptText(SAY_BARON_AGGRO, me);
-            else
-                DoScriptText(SAY_AGGRO[id], me);
-
-            events.ScheduleEvent(EVENT_MARK, 24000);
-            events.ScheduleEvent(EVENT_CAST, 20000+rand()%5000);
-            events.ScheduleEvent(EVENT_BERSERK, 15*100*1000);
-        }
-
-        void SpellHitTarget(Unit* target, const SpellEntry *spell)
-        {
-            if(target->GetTypeId() != TYPEID_PLAYER)
-                return;
-
-            if(spell->Id == SPELL_MARK[0] || spell->Id == SPELL_MARK[1] || spell->Id == SPELL_MARK[2] || spell->Id == SPELL_MARK[3])
-                me->getThreatManager().modifyThreatPercent(target,-50);
-
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (nextWP && movementStarted && !movementCompleted && !nextMovementStarted)
-            {
-                nextMovementStarted = true;
-                me->GetMotionMaster()->MovePoint(nextWP, WaypointPositions[nextWP]);
-            }
-
-            if (!UpdateVictim() || !CheckInRoom() || !movementCompleted)
-                return;
-
-            events.Update(diff);
-
-            if (me->hasUnitState(UNIT_STAT_CASTING))
-                return;
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_MARK:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            if (!(rand()%5))
-                                DoScriptText(SAY_SPECIAL[id], me);
-                            DoCastAOE(SPELL_MARK[id]);
-                            events.ScheduleEvent(EVENT_MARK, caster ? 15000 : 12000);
-                        }
-                        break;
-                    case EVENT_CAST:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            if (!(rand()%5))
-                                DoScriptText(SAY_TAUNT[rand()%3][id], me);
-
-                            if (caster)
-                            {
-                                if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 45.0f))
-                                    DoCast(pTarget, SPELL_PRIMARY(id));
-                            }
-                            else
-                                DoCast(me->getVictim(), SPELL_PRIMARY(id));
-
-                            events.ScheduleEvent(EVENT_CAST, 15000);
-                        }
-                        break;
-                    case EVENT_BERSERK:
-                        DoScriptText(SAY_SPECIAL[id], me);
-                        DoCast(me, SPELL_BERSERK, true);
-                        break;
-                }
-            }
-
-            if (punishTimer <= diff)
-            {
-                if (doDelayPunish)
-                {
-                    DoCastAOE(SPELL_PUNISH[id], true);
-                    doDelayPunish = false;
-                }
-                punishTimer = 2000;
-            } else punishTimer -= diff;
-
-            if (!caster)
-                DoMeleeAttackIfReady();
-            else if ((!DoSpellAttackIfReady(SPELL_SECONDARY(id)) || !me->IsWithinLOSInMap(me->getVictim())) && movementCompleted && !doDelayPunish)
-                doDelayPunish = true;
-        }
-    };
-
-};
+CreatureAI* GetAI_four_horsemen(Creature* pCreature)
+{
+    return new boss_four_horsemenAI (pCreature);
+}
 
 void AddSC_boss_four_horsemen()
 {
-    new boss_four_horsemen();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_four_horsemen";
+    newscript->GetAI = &GetAI_four_horsemen;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_gluth.cpp b/src/server/scripts/Northrend/Naxxramas/boss_gluth.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_gluth.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_gluth.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 #include "ScriptPCH.h"
 #include "naxxramas.h"
 
@@ -22,15 +22,15 @@
 #define SPELL_ENRAGE            RAID_MODE(28371,54427)
 #define SPELL_DECIMATE          RAID_MODE(28374,54426)
 #define SPELL_BERSERK           26662
-#define SPELL_INFECTED_WOUND    29307
+#define SPELL_INFECTED_WOUND    29306
 
 #define MOB_ZOMBIE  16360
 
 const Position PosSummon[3] =
 {
-    {3267.9f, -3172.1f, 297.42f, 0.94f},
-    {3253.2f, -3132.3f, 297.42f, 0},
-    {3308.3f, -3185.8f, 297.42f, 1.58f},
+    {3267.9, -3172.1, 297.42, 0.94},
+    {3253.2, -3132.3, 297.42, 0},
+    {3308.3, -3185.8, 297.42, 1.58},
 };
 
 enum Events
@@ -45,130 +45,104 @@
 
 #define EMOTE_NEARBY    " spots a nearby zombie to devour!"
 
-class boss_gluth : public CreatureScript
+struct boss_gluthAI : public BossAI
 {
-public:
-    boss_gluth() : CreatureScript("boss_gluth") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
+    boss_gluthAI(Creature *c) : BossAI(c, BOSS_GLUTH)
     {
-        return new boss_gluthAI (pCreature);
+        // Do not let Gluth be affected by zombies' debuff
+        me->ApplySpellImmune(0, IMMUNITY_ID, SPELL_INFECTED_WOUND, true);
     }
 
-    struct boss_gluthAI : public BossAI
+    void MoveInLineOfSight(Unit *who)
     {
-        boss_gluthAI(Creature *c) : BossAI(c, BOSS_GLUTH)
+        if (who->GetEntry() == MOB_ZOMBIE && me->IsWithinDistInMap(who, 7))
         {
-            // Do not let Gluth be affected by zombies' debuff
-            me->ApplySpellImmune(0, IMMUNITY_ID, SPELL_INFECTED_WOUND, true);
+            SetGazeOn(who);
+            // TODO: use a script text
+            me->MonsterTextEmote(EMOTE_NEARBY, 0, true);
+        }
+        else
+            BossAI::MoveInLineOfSight(who);
+    }
+
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+        events.ScheduleEvent(EVENT_WOUND, 10000);
+        events.ScheduleEvent(EVENT_ENRAGE, 15000);
+        events.ScheduleEvent(EVENT_DECIMATE, 105000);
+        events.ScheduleEvent(EVENT_BERSERK, 8*60000);
+        events.ScheduleEvent(EVENT_SUMMON, 15000);
+    }
+
+    void JustSummoned(Creature *summon)
+    {
+        if (summon->GetEntry() == MOB_ZOMBIE)
+            summon->AI()->AttackStart(me);
+        summons.Summon(summon);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictimWithGaze() || !CheckInRoom())
+            return;
+
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
+        {
+            switch(eventId)
+            {
+                case EVENT_WOUND:
+                    DoCast(me->getVictim(), SPELL_MORTAL_WOUND);
+                    events.ScheduleEvent(EVENT_WOUND, 10000);
+                    break;
+                case EVENT_ENRAGE:
+                    // TODO : Add missing text
+                    DoCast(me, SPELL_ENRAGE);
+                    events.ScheduleEvent(EVENT_ENRAGE, 15000);
+                    break;
+                case EVENT_DECIMATE:
+                    // TODO : Add missing text
+                    DoCastAOE(SPELL_DECIMATE);
+                    events.ScheduleEvent(EVENT_DECIMATE, 105000);
+                    break;
+                case EVENT_BERSERK:
+                    DoCast(me, SPELL_BERSERK);
+                    events.ScheduleEvent(EVENT_BERSERK, 5*60000);
+                    break;
+                case EVENT_SUMMON:
+                    for (uint32 i = 0; i < RAID_MODE(1,2); ++i)
+                        DoSummon(MOB_ZOMBIE, PosSummon[rand()%3]);
+                    events.ScheduleEvent(EVENT_SUMMON, 10000);
+                    break;
+            }
         }
 
-        void MoveInLineOfSight(Unit *who)
+        if (me->getVictim() && me->getVictim()->GetEntry() == MOB_ZOMBIE)
         {
-            if (who->GetEntry() == MOB_ZOMBIE && me->IsWithinDistInMap(who, 7))
+            if (me->IsWithinMeleeRange(me->getVictim()))
             {
-                SetGazeOn(who);
-                // TODO: use a script text
-                me->MonsterTextEmote(EMOTE_NEARBY, 0, true);
+                me->Kill(me->getVictim());
+                me->ModifyHealth(me->GetMaxHealth() * 0.05f);
             }
-            else
-                BossAI::MoveInLineOfSight(who);
         }
-
-        void EnterCombat(Unit * /*who*/)
-        {
-            _EnterCombat();
-            events.ScheduleEvent(EVENT_WOUND, 10000);
-            events.ScheduleEvent(EVENT_ENRAGE, 15000);
-            events.ScheduleEvent(EVENT_DECIMATE, RAID_MODE(120000,90000));
-            events.ScheduleEvent(EVENT_BERSERK, RAID_MODE(8*60000,7*60000));
-            events.ScheduleEvent(EVENT_SUMMON, 15000);
-        }
-
-        void JustSummoned(Creature *summon)
-        {
-            if (summon->GetEntry() == MOB_ZOMBIE)
-            {
-                summon->AI()->AttackStart(me);
-                summon->CastSpell(summon,SPELL_INFECTED_WOUND,true);
-            }
-
-            summons.Summon(summon);
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictimWithGaze() || !CheckInRoom())
-                return;
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_WOUND:
-                        DoCast(me->getVictim(), SPELL_MORTAL_WOUND);
-                        events.ScheduleEvent(EVENT_WOUND, 10000);
-                        break;
-                    case EVENT_ENRAGE:
-                        // TODO : Add missing text
-                        DoCast(me, SPELL_ENRAGE);
-                        events.ScheduleEvent(EVENT_ENRAGE, 15000);
-                        break;
-                    case EVENT_DECIMATE:
-                        // TODO : Add missing text
-                        DoCastAOE(SPELL_DECIMATE);
-                        events.ScheduleEvent(EVENT_DECIMATE, RAID_MODE(120000,90000));
-
-                        for (std::list<uint64>::const_iterator itr = summons.begin(); itr != summons.end(); ++itr)
-                        {
-                            Creature *minion = Unit::GetCreature(*me, *itr);
-                            if (minion && minion->isAlive() )
-                            {
-                                //hack
-                                int32 damage = int32(minion->GetHealth()) - int32(minion->CountPctFromMaxHealth(5));
-                                if (damage > 0)
-                                    me->CastCustomSpell(28375, SPELLVALUE_BASE_POINT0, damage, minion, true);
-
-                                if(minion->AI()) //is useless
-                                {
-                                    minion->GetMotionMaster()->MoveChase(me);
-                                    minion->AddThreat(me,9999999);
-                                }
-                            }
-                        }
-                        break;
-                    case EVENT_BERSERK:
-                        if(!me->HasAura(SPELL_BERSERK))
-                            DoCast(me, SPELL_BERSERK);
-                        events.ScheduleEvent(EVENT_BERSERK, 1*60000);
-                        break;
-                    case EVENT_SUMMON:
-                        for (int32 i = 0; i < RAID_MODE(1, 2); ++i)
-                            DoSummon(MOB_ZOMBIE, PosSummon[RAID_MODE(0,rand() % 3)]);
-                        events.ScheduleEvent(EVENT_SUMMON, 10000);
-                        break;
-                }
-            }
-
-            if (me->getVictim() && me->getVictim()->GetEntry() == MOB_ZOMBIE)
-            {
-                if (me->IsWithinMeleeRange(me->getVictim()))
-                {
-                    me->Kill(me->getVictim());
-                    me->ModifyHealth(int32(me->CountPctFromMaxHealth(5)));
-                }
-            }
-            else
-                DoMeleeAttackIfReady();
-        }
-    };
-
+        else
+            DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_boss_gluth(Creature* pCreature)
+{
+    return new boss_gluthAI (pCreature);
+}
 
 void AddSC_boss_gluth()
 {
-    new boss_gluth();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_gluth";
+    newscript->GetAI = &GetAI_boss_gluth;
+    newscript->RegisterSelf();
 }
+
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp b/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_gothik.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 #include "ScriptPCH.h"
 #include "naxxramas.h"
 
@@ -88,33 +88,6 @@
     {MOB_LIVE_TRAINEE, 25000, 0},
     {0, 0, 1},
 };
-//Orignal Waves
-const Waves hardwaves[] =
-{
-    {MOB_LIVE_TRAINEE, 20000, 1},
-    {MOB_LIVE_TRAINEE, 20000, 1},
-    {MOB_LIVE_TRAINEE, 20000, 1},
-    {MOB_LIVE_KNIGHT, 10000, 1},
-    {MOB_LIVE_TRAINEE, 10000, 1},
-    {MOB_LIVE_KNIGHT, 15000, 1},
-    {MOB_LIVE_TRAINEE, 5000, 1},
-    {MOB_LIVE_TRAINEE, 20000, 1},
-    {MOB_LIVE_KNIGHT, 0, 1},
-    {MOB_LIVE_RIDER, 10000, 1},
-    {MOB_LIVE_TRAINEE, 10000, 1},
-    {MOB_LIVE_KNIGHT, 5000, 1},
-    {MOB_LIVE_TRAINEE, 15000, 1},
-    {MOB_LIVE_RIDER, 0, 1},
-    {MOB_LIVE_KNIGHT, 10000, 1},
-    {MOB_LIVE_TRAINEE, 10000, 1},
-    {MOB_LIVE_RIDER, 10000, 1},
-    {MOB_LIVE_KNIGHT, 5000, 1},
-    {MOB_LIVE_TRAINEE, 5000, 1},
-    {MOB_LIVE_TRAINEE, 20000, 1},
-    {MOB_LIVE_RIDER, 0, 1},
-    {MOB_LIVE_KNIGHT, 0, 1},
-    {0, 0, 1},
-};
 
 #define POS_Y_GATE  -3360.78f
 #define POS_Y_WEST  -3285.0f
@@ -140,26 +113,26 @@
 
 const Position PosSummonLive[POS_LIVE] =
 {
-    {2669.7f, -3428.76f, 268.56f, 1.6f},
-    {2692.1f, -3428.76f, 268.56f, 1.6f},
-    {2714.4f, -3428.76f, 268.56f, 1.6f},
-    {2669.7f, -3431.67f, 268.56f, 1.6f},
-    {2692.1f, -3431.67f, 268.56f, 1.6f},
-    {2714.4f, -3431.67f, 268.56f, 1.6f},
+    {2669.7, -3428.76, 268.56, 1.6},
+    {2692.1, -3428.76, 268.56, 1.6},
+    {2714.4, -3428.76, 268.56, 1.6},
+    {2669.7, -3431.67, 268.56, 1.6},
+    {2692.1, -3431.67, 268.56, 1.6},
+    {2714.4, -3431.67, 268.56, 1.6},
 };
 
 const Position PosSummonDead[POS_DEAD] =
 {
-    {2725.1f, -3310.0f, 268.85f, 3.4f},
-    {2699.3f, -3322.8f, 268.60f, 3.3f},
-    {2733.1f, -3348.5f, 268.84f, 3.1f},
-    {2682.8f, -3304.2f, 268.85f, 3.9f},
-    {2664.8f, -3340.7f, 268.23f, 3.7f},
+    {2725.1, -3310.0, 268.85, 3.4},
+    {2699.3, -3322.8, 268.60, 3.3},
+    {2733.1, -3348.5, 268.84, 3.1},
+    {2682.8, -3304.2, 268.85, 3.9},
+    {2664.8, -3340.7, 268.23, 3.7},
 };
 
-const float PosGroundLiveSide[4] = {2691.2f, -3387.0f, 267.68f, 1.52f};
-const float PosGroundDeadSide[4] = {2693.5f, -3334.6f, 267.68f, 4.67f};
-const float PosPlatform[4] = {2640.5f, -3360.6f, 285.26f, 0.0f};
+const float PosGroundLiveSide[4] = {2691.2, -3387.0, 267.68, 1.52};
+const float PosGroundDeadSide[4] = {2693.5, -3334.6, 267.68, 4.67};
+const float PosPlatform[4] = {2640.5, -3360.6, 285.26, 0};
 
 // Predicate function to check that the r   efzr unit is NOT on the same side as the source.
 struct NotOnSameSide : public std::unary_function<Unit *, bool> {
@@ -170,456 +143,441 @@
     }
 };
 
-class boss_gothik : public CreatureScript
+struct boss_gothikAI : public BossAI
 {
-public:
-    boss_gothik() : CreatureScript("boss_gothik") { }
+    boss_gothikAI(Creature *c) : BossAI(c, BOSS_GOTHIK) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    uint32 waveCount;
+    typedef std::vector<Creature*> TriggerVct;
+    TriggerVct liveTrigger, deadTrigger;
+    bool mergedSides;
+    bool phaseTwo;
+    bool thirtyPercentReached;
+
+    std::vector<uint64> LiveTriggerGUID;
+    std::vector<uint64> DeadTriggerGUID;
+
+    void Reset()
     {
-        return new boss_gothikAI (pCreature);
+        LiveTriggerGUID.clear();
+        DeadTriggerGUID.clear();
+
+        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
+        me->SetReactState(REACT_PASSIVE);
+        if (instance)
+            instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
+        _Reset();
+        mergedSides = false;
+        phaseTwo = false;
+        thirtyPercentReached = false;
     }
 
-    struct boss_gothikAI : public BossAI
+    void EnterCombat(Unit * /*who*/)
     {
-        boss_gothikAI(Creature *c) : BossAI(c, BOSS_GOTHIK) {}
+        for (uint32 i = 0; i < POS_LIVE; ++i)
+            if (Creature *trigger = DoSummon(WORLD_TRIGGER, PosSummonLive[i]))
+                LiveTriggerGUID.push_back(trigger->GetGUID());
+        for (uint32 i = 0; i < POS_DEAD; ++i)
+            if (Creature *trigger = DoSummon(WORLD_TRIGGER, PosSummonDead[i]))
+                DeadTriggerGUID.push_back(trigger->GetGUID());
 
-        uint32 waveCount;
-        typedef std::vector<Creature*> TriggerVct;
-        TriggerVct liveTrigger, deadTrigger;
-        bool mergedSides;
-        bool phaseTwo;
-        bool thirtyPercentReached;
-
-        std::vector<uint64> LiveTriggerGUID;
-        std::vector<uint64> DeadTriggerGUID;
-
-        void Reset()
+        if (LiveTriggerGUID.size() < POS_LIVE || DeadTriggerGUID.size() < POS_DEAD)
         {
-            LiveTriggerGUID.clear();
-            DeadTriggerGUID.clear();
-
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
-            me->SetReactState(REACT_PASSIVE);
-            if (instance)
-                instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
-            _Reset();
-            mergedSides = false;
-            phaseTwo = false;
-            thirtyPercentReached = false;
-             
+            sLog.outError("Script Gothik: cannot summon triggers!");
+            EnterEvadeMode();
+            return;
         }
 
-        void EnterCombat(Unit * /*who*/)
+        _EnterCombat();
+        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
+        waveCount = 0;
+        events.ScheduleEvent(EVENT_SUMMON, 30000);
+        DoTeleportTo(PosPlatform);
+        DoScriptText(SAY_SPEECH, me);
+        if (instance)
+            instance->SetData(DATA_GOTHIK_GATE, GO_STATE_READY);
+    }
+
+    void JustSummoned(Creature *summon)
+    {
+        if (summon->GetEntry() == WORLD_TRIGGER)
+            summon->setActive(true);
+        else if (!mergedSides)
         {
-            for (uint32 i = 0; i < POS_LIVE; ++i)
-                if (Creature *trigger = DoSummon(WORLD_TRIGGER, PosSummonLive[i]))
-                    LiveTriggerGUID.push_back(trigger->GetGUID());
-            for (uint32 i = 0; i < POS_DEAD; ++i)
-                if (Creature *trigger = DoSummon(WORLD_TRIGGER, PosSummonDead[i]))
-                    DeadTriggerGUID.push_back(trigger->GetGUID());
+            summon->AI()->DoAction(me->HasReactState(REACT_PASSIVE) ? 1 : 0);
+            summon->AI()->EnterEvadeMode();
+        }
+        else
+        {
+            summon->AI()->DoAction(0);
+            summon->AI()->DoZoneInCombat();
+        }
+        summons.Summon(summon);
+    }
 
-            if (LiveTriggerGUID.size() < POS_LIVE || DeadTriggerGUID.size() < POS_DEAD)
+    void SummonedCreatureDespawn(Creature *summon)
+    {
+        summons.Despawn(summon);
+    }
+
+    void KilledUnit(Unit* /*victim*/)
+    {
+        if (!(rand()%5))
+            DoScriptText(SAY_KILL, me);
+    }
+
+    void JustDied(Unit* /*Killer*/)
+    {
+        LiveTriggerGUID.clear();
+        DeadTriggerGUID.clear();
+        _JustDied();
+        DoScriptText(SAY_DEATH, me);
+        if (instance)
+            instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
+    }
+
+    void DoGothikSummon(uint32 entry)
+    {
+        if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
+        {
+            switch(entry)
             {
-                sLog.outError("Script Gothik: cannot summon triggers!");
-                EnterEvadeMode();
-                return;
+                case MOB_LIVE_TRAINEE:
+                {
+                    if (Creature *LiveTrigger0 = Unit::GetCreature(*me, LiveTriggerGUID[0]))
+                        DoSummon(MOB_LIVE_TRAINEE, LiveTrigger0, 1);
+                    if (Creature *LiveTrigger1 = Unit::GetCreature(*me, LiveTriggerGUID[1]))
+                        DoSummon(MOB_LIVE_TRAINEE, LiveTrigger1, 1);
+                    if (Creature *LiveTrigger2 = Unit::GetCreature(*me, LiveTriggerGUID[2]))
+                        DoSummon(MOB_LIVE_TRAINEE, LiveTrigger2, 1);
+                    break;
+                }
+                case MOB_LIVE_KNIGHT:
+                {
+                    if (Creature *LiveTrigger3 = Unit::GetCreature(*me, LiveTriggerGUID[3]))
+                        DoSummon(MOB_LIVE_KNIGHT, LiveTrigger3, 1);
+                    if (Creature *LiveTrigger5 = Unit::GetCreature(*me, LiveTriggerGUID[5]))
+                        DoSummon(MOB_LIVE_KNIGHT, LiveTrigger5, 1);
+                    break;
+                }
+                case MOB_LIVE_RIDER:
+                {
+                    if (Creature *LiveTrigger4 = Unit::GetCreature(*me, LiveTriggerGUID[4]))
+                        DoSummon(MOB_LIVE_RIDER, LiveTrigger4, 1);
+                    break;
+                }
             }
+        }
+        else
+        {
+            switch(entry)
+            {
+                case MOB_LIVE_TRAINEE:
+                {
+                    if (Creature *LiveTrigger0 = Unit::GetCreature(*me, LiveTriggerGUID[4]))
+                        DoSummon(MOB_LIVE_TRAINEE, LiveTrigger0, 1);
+                    if (Creature *LiveTrigger1 = Unit::GetCreature(*me, LiveTriggerGUID[4]))
+                        DoSummon(MOB_LIVE_TRAINEE, LiveTrigger1, 1);
+                    break;
+                }
+                case MOB_LIVE_KNIGHT:
+                {
+                    if (Creature *LiveTrigger5 = Unit::GetCreature(*me, LiveTriggerGUID[4]))
+                        DoSummon(MOB_LIVE_KNIGHT, LiveTrigger5, 1);
+                    break;
+                }
+                case MOB_LIVE_RIDER:
+                {
+                    if (Creature *LiveTrigger4 = Unit::GetCreature(*me, LiveTriggerGUID[4]))
+                        DoSummon(MOB_LIVE_RIDER, LiveTrigger4, 1);
+                    break;
+                }
+            }
+        }
+    }
 
-            _EnterCombat();
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE|UNIT_FLAG_DISABLE_MOVE);
-            waveCount = 0;
-            events.ScheduleEvent(EVENT_SUMMON, 30000);
-            DoTeleportTo(PosPlatform);
-            DoScriptText(SAY_SPEECH, me);
-            if (instance)
-                instance->SetData(DATA_GOTHIK_GATE, GO_STATE_READY);
+    bool CheckGroupSplitted()
+    {
+        bool checklife = false;
+        bool checkdead = false;
+
+        Map* pMap = me->GetMap();
+        if (pMap && pMap->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = pMap->GetPlayers();
+            if (!PlayerList.isEmpty())
+            {
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource() && i->getSource()->isAlive() &&
+                        i->getSource()->GetPositionX() <= POS_X_NORTH &&
+                        i->getSource()->GetPositionX() >= POS_X_SOUTH &&
+                        i->getSource()->GetPositionY() <= POS_Y_GATE &&
+                        i->getSource()->GetPositionY() >= POS_Y_EAST)
+                    {
+                        checklife = true;
+                    }
+                    else if (i->getSource() && i->getSource()->isAlive() &&
+                        i->getSource()->GetPositionX() <= POS_X_NORTH &&
+                        i->getSource()->GetPositionX() >= POS_X_SOUTH &&
+                        i->getSource()->GetPositionY() >= POS_Y_GATE &&
+                        i->getSource()->GetPositionY() <= POS_Y_WEST)
+                    {
+                        checkdead = true;
+                    }
+
+                    if (checklife && checkdead)
+                        return true;
+                }
+            }
         }
 
-        void JustSummoned(Creature *summon)
+        return false;
+    }
+
+    void SpellHit(Unit * /*caster*/, const SpellEntry *spell)
+    {
+        uint32 spellId = 0;
+        switch(spell->Id)
         {
-            if (summon->GetEntry() == WORLD_TRIGGER)
-                summon->setActive(true);
-            else if (!mergedSides)
-            {
-                summon->AI()->DoAction(me->HasReactState(REACT_PASSIVE) ? 1 : 0);
-                summon->AI()->EnterEvadeMode();
-            }
-            else
-            {
-                summon->AI()->DoAction(0);
-                summon->AI()->DoZoneInCombat();
-            }
-            summons.Summon(summon);
+            case SPELL_INFORM_LIVE_TRAINEE: spellId = SPELL_INFORM_DEAD_TRAINEE;    break;
+            case SPELL_INFORM_LIVE_KNIGHT:  spellId = SPELL_INFORM_DEAD_KNIGHT;     break;
+            case SPELL_INFORM_LIVE_RIDER:   spellId = SPELL_INFORM_DEAD_RIDER;      break;
         }
+        if (spellId && me->isInCombat())
+        {
+            me->HandleEmoteCommand(EMOTE_ONESHOT_SPELLCAST);
+            if (Creature *pRandomDeadTrigger = Unit::GetCreature(*me, DeadTriggerGUID[rand() % POS_DEAD]))
+                me->CastSpell(pRandomDeadTrigger, spellId, true);
+        }
+    }
 
-        void SummonedCreatureDespawn(Creature *summon)
+    void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
+    {
+        if (!me->isInCombat())
+            return;
+
+        switch(spell->Id)
         {
-            summons.Despawn(summon);
+            case SPELL_INFORM_DEAD_TRAINEE:
+                DoSummon(MOB_DEAD_TRAINEE, pTarget, 0);
+                break;
+            case SPELL_INFORM_DEAD_KNIGHT:
+                DoSummon(MOB_DEAD_KNIGHT, pTarget, 0);
+                break;
+            case SPELL_INFORM_DEAD_RIDER:
+                DoSummon(MOB_DEAD_RIDER, pTarget, 1.0f);
+                DoSummon(MOB_DEAD_HORSE, pTarget, 1.0f);
+                break;
         }
+    }
 
-        void KilledUnit(Unit* /*victim*/)
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateCombatState() || !CheckInRoom())
+            return;
+
+        events.Update(diff);
+
+        if (!thirtyPercentReached && HealthBelowPct(30) && phaseTwo)
         {
-            if (!(rand()%5))
-                DoScriptText(SAY_KILL, me);
-        }
-
-        void JustDied(Unit* /*Killer*/)
-        {
-            LiveTriggerGUID.clear();
-            DeadTriggerGUID.clear();
-            _JustDied();
-            DoScriptText(SAY_DEATH, me);
+            thirtyPercentReached = true;
             if (instance)
                 instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
         }
 
-        void DoGothikSummon(uint32 entry)
+        if (me->hasUnitState(UNIT_STAT_CASTING))
+            return;
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
+            switch(eventId)
             {
-                switch(entry)
+                case EVENT_SUMMON:
+                    if (waves[waveCount].entry)
+                    {
+                        if ((waves[waveCount].mode == 2) && (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL))
+                           DoGothikSummon(waves[waveCount].entry);
+                        else if ((waves[waveCount].mode == 0) && (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL))
+                            DoGothikSummon(waves[waveCount].entry);
+                        else if (waves[waveCount].mode == 1)
+                            DoGothikSummon(waves[waveCount].entry);
+
+                        // if group is not splitted, open gate and merge both sides at ~ 2 minutes (wave 11)
+                        if (waveCount == 11)
+                        {
+                            if (!CheckGroupSplitted())
+                            {
+                                if (instance)
+                                    instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
+                                summons.DoAction(0, 0);
+                                summons.DoZoneInCombat();
+                                mergedSides = true;
+                            }
+                        }
+
+                        if (waves[waveCount].mode == 1)
+                            events.ScheduleEvent(EVENT_SUMMON,waves[waveCount].time);
+                        else if ((waves[waveCount].mode == 2) && (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL))
+                            events.ScheduleEvent(EVENT_SUMMON,waves[waveCount].time);
+                        else if ((waves[waveCount].mode == 0) && (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL))
+                            events.ScheduleEvent(EVENT_SUMMON,waves[waveCount].time);
+                        else
+                            events.ScheduleEvent(EVENT_SUMMON, 0);
+
+                        ++waveCount;
+                    }
+                    else
+                    {
+                        phaseTwo = true;
+                        DoScriptText(SAY_TELEPORT, me);
+                        DoTeleportTo(PosGroundLiveSide);
+                        me->SetReactState(REACT_AGGRESSIVE);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                        summons.DoAction(0, 0);
+                        summons.DoZoneInCombat();
+                        events.ScheduleEvent(EVENT_BOLT, 1000);
+                        events.ScheduleEvent(EVENT_HARVEST, urand(3000,15000));
+                        events.ScheduleEvent(EVENT_TELEPORT, 20000);
+                    }
+                    break;
+                case EVENT_BOLT:
+                    DoCast(me->getVictim(), RAID_MODE(SPELL_SHADOW_BOLT, H_SPELL_SHADOW_BOLT));
+                    events.ScheduleEvent(EVENT_BOLT, 1000);
+                    break;
+                case EVENT_HARVEST:
+                    DoCast(me->getVictim(), SPELL_HARVEST_SOUL, true);
+                    events.ScheduleEvent(EVENT_HARVEST, urand(20000,25000));
+                    break;
+                case EVENT_TELEPORT:
+                    if (!thirtyPercentReached)
+                    {
+                        me->AttackStop();
+                        if (IN_LIVE_SIDE(me))
+                        {
+                            DoTeleportTo(PosGroundDeadSide);
+                        }
+                        else
+                        {
+                            DoTeleportTo(PosGroundLiveSide);
+                        }
+
+                        me->getThreatManager().resetAggro(NotOnSameSide(me));
+                        if (Unit *pTarget = SelectTarget(SELECT_TARGET_NEAREST, 0))
+                        {
+                            me->getThreatManager().addThreat(pTarget, 100.0f);
+                            AttackStart(pTarget);
+                        }
+
+                        events.ScheduleEvent(EVENT_TELEPORT, 20000);
+                    }
+                    break;
+            }
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct mob_gothik_minionAI : public CombatAI
+{
+    mob_gothik_minionAI(Creature *c) : CombatAI(c)
+    {
+        liveSide = IN_LIVE_SIDE(me);
+    }
+
+    bool liveSide;
+    bool gateClose;
+
+    bool isOnSameSide(const Unit *pWho)
+    {
+        return (liveSide == IN_LIVE_SIDE(pWho));
+    }
+
+    void DoAction(const int32 param)
+    {
+        gateClose = param;
+    }
+
+    void DamageTaken(Unit *attacker, uint32 &damage)
+    {
+        if (gateClose && !isOnSameSide(attacker))
+            damage = 0;
+    }
+
+    void JustDied(Unit * /*killer*/)
+    {
+        if (me->isSummon())
+        {
+            if (Unit *owner = CAST_SUM(me)->GetSummoner())
+                CombatAI::JustDied(owner);
+        }
+    }
+
+    void EnterEvadeMode()
+    {
+        if (!gateClose)
+        {
+            CombatAI::EnterEvadeMode();
+            return;
+        }
+
+        if (!_EnterEvadeMode())
+            return;
+
+        Map* pMap = me->GetMap();
+        if (pMap->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = pMap->GetPlayers();
+            if (!PlayerList.isEmpty())
+            {
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
                 {
-                    case MOB_LIVE_TRAINEE:
+                    if (i->getSource() && i->getSource()->isAlive() && isOnSameSide(i->getSource()))
                     {
-                        if (Creature *LiveTrigger0 = Unit::GetCreature(*me, LiveTriggerGUID[0]))
-                            DoSummon(MOB_LIVE_TRAINEE, LiveTrigger0, 1);
-                        if (Creature *LiveTrigger1 = Unit::GetCreature(*me, LiveTriggerGUID[1]))
-                            DoSummon(MOB_LIVE_TRAINEE, LiveTrigger1, 1);
-                        if (Creature *LiveTrigger2 = Unit::GetCreature(*me, LiveTriggerGUID[2]))
-                            DoSummon(MOB_LIVE_TRAINEE, LiveTrigger2, 1);
-                        break;
-                    }
-                    case MOB_LIVE_KNIGHT:
-                    {
-                        if (Creature *LiveTrigger3 = Unit::GetCreature(*me, LiveTriggerGUID[3]))
-                            DoSummon(MOB_LIVE_KNIGHT, LiveTrigger3, 1);
-                        if (Creature *LiveTrigger5 = Unit::GetCreature(*me, LiveTriggerGUID[5]))
-                            DoSummon(MOB_LIVE_KNIGHT, LiveTrigger5, 1);
-                        break;
-                    }
-                    case MOB_LIVE_RIDER:
-                    {
-                        if (Creature *LiveTrigger4 = Unit::GetCreature(*me, LiveTriggerGUID[4]))
-                            DoSummon(MOB_LIVE_RIDER, LiveTrigger4, 1);
-                        break;
-                    }
-                }
-            }
-            else
-            {
-                switch(entry)
-                {
-                    case MOB_LIVE_TRAINEE:
-                    {
-                        if (Creature *LiveTrigger0 = Unit::GetCreature(*me, LiveTriggerGUID[1]))
-                            DoSummon(MOB_LIVE_TRAINEE, LiveTrigger0, 1);
-                        if (Creature *LiveTrigger1 = Unit::GetCreature(*me, LiveTriggerGUID[2]))
-                            DoSummon(MOB_LIVE_TRAINEE, LiveTrigger1, 1);
-                        break;
-                    }
-                    case MOB_LIVE_KNIGHT:
-                    {
-                        if (Creature *LiveTrigger5 = Unit::GetCreature(*me, LiveTriggerGUID[3]))
-                            DoSummon(MOB_LIVE_KNIGHT, LiveTrigger5, 1);
-                        break;
-                    }
-                    case MOB_LIVE_RIDER:
-                    {
-                        if (Creature *LiveTrigger4 = Unit::GetCreature(*me, LiveTriggerGUID[4]))
-                            DoSummon(MOB_LIVE_RIDER, LiveTrigger4, 1);
-                        break;
+                        AttackStart(i->getSource());
+                        return;
                     }
                 }
             }
         }
 
-        bool CheckGroupSplitted()
+        me->GetMotionMaster()->MoveIdle();
+        Reset();
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (gateClose && (!isOnSameSide(me) || me->getVictim() && !isOnSameSide(me->getVictim())))
         {
-            bool checklife = false;
-            bool checkdead = false;
-
-            Map* pMap = me->GetMap();
-            if (pMap && pMap->IsDungeon())
-            {
-                Map::PlayerList const &PlayerList = pMap->GetPlayers();
-                if (!PlayerList.isEmpty())
-                {
-                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
-                    {
-                        if (i->getSource() && i->getSource()->isAlive() &&
-                            i->getSource()->GetPositionX() <= POS_X_NORTH &&
-                            i->getSource()->GetPositionX() >= POS_X_SOUTH &&
-                            i->getSource()->GetPositionY() <= POS_Y_GATE &&
-                            i->getSource()->GetPositionY() >= POS_Y_EAST)
-                        {
-                            checklife = true;
-                        }
-                        else if (i->getSource() && i->getSource()->isAlive() &&
-                            i->getSource()->GetPositionX() <= POS_X_NORTH &&
-                            i->getSource()->GetPositionX() >= POS_X_SOUTH &&
-                            i->getSource()->GetPositionY() >= POS_Y_GATE &&
-                            i->getSource()->GetPositionY() <= POS_Y_WEST)
-                        {
-                            checkdead = true;
-                        }
-
-                        if (checklife && checkdead)
-                            return true;
-                    }
-                }
-            }
-
-            return false;
+            EnterEvadeMode();
+            return;
         }
 
-        void SpellHit(Unit * /*caster*/, const SpellEntry *spell)
-        {
-            if (!phaseTwo)
-            {
-                me->SetHealth(me->GetMaxHealth());
-                me->RemoveAllAuras();
-            }
-
-            uint32 spellId = 0;
-            switch(spell->Id)
-            {
-                case SPELL_INFORM_LIVE_TRAINEE: spellId = SPELL_INFORM_DEAD_TRAINEE;    break;
-                case SPELL_INFORM_LIVE_KNIGHT:  spellId = SPELL_INFORM_DEAD_KNIGHT;     break;
-                case SPELL_INFORM_LIVE_RIDER:   spellId = SPELL_INFORM_DEAD_RIDER;      break;
-            }
-            if (spellId && me->isInCombat())
-            {
-                me->HandleEmoteCommand(EMOTE_ONESHOT_SPELLCAST);
-                if (Creature *pRandomDeadTrigger = Unit::GetCreature(*me, DeadTriggerGUID[rand() % POS_DEAD]))
-                    me->CastSpell(pRandomDeadTrigger, spellId, true);
-            }
-        }
-
-        void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
-        {
-            if (!me->isInCombat())
-                return;
-
-            switch(spell->Id)
-            {
-                case SPELL_INFORM_DEAD_TRAINEE:
-                    DoSummon(MOB_DEAD_TRAINEE, pTarget, 0);
-                    break;
-                case SPELL_INFORM_DEAD_KNIGHT:
-                    DoSummon(MOB_DEAD_KNIGHT, pTarget, 0);
-                    break;
-                case SPELL_INFORM_DEAD_RIDER:
-                    DoSummon(MOB_DEAD_RIDER, pTarget, 1.0f);
-                    DoSummon(MOB_DEAD_HORSE, pTarget, 1.0f);
-                    break;
-            }
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateCombatState() || !CheckInRoom())
-                return;
-
-            events.Update(diff);
-
-            if (!thirtyPercentReached && HealthBelowPct(30) && phaseTwo)
-            {
-                thirtyPercentReached = true;
-                if (instance)
-                    instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
-            }
-
-            if (me->hasUnitState(UNIT_STAT_CASTING))
-                return;
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_SUMMON:
-                        if (waves[waveCount].entry)
-                        {
-                            if ((waves[waveCount].mode == 2) && (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL))
-                               DoGothikSummon(waves[waveCount].entry);
-                            else if ((waves[waveCount].mode == 0) && (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL))
-                                DoGothikSummon(waves[waveCount].entry);
-                            else if (waves[waveCount].mode == 1)
-                                DoGothikSummon(waves[waveCount].entry);
-
-                            // if group is not splitted, open gate and merge both sides at ~ 2 minutes (wave 11)
-                            if (waveCount == 11)
-                            {
-                                if (!CheckGroupSplitted())
-                                {
-                                    if (instance)
-                                        instance->SetData(DATA_GOTHIK_GATE, GO_STATE_ACTIVE);
-                                    summons.DoAction(0, 0);
-                                    summons.DoZoneInCombat();
-                                    mergedSides = true;
-                                }
-                            }
-
-                            if (waves[waveCount].mode == 1)
-                                events.ScheduleEvent(EVENT_SUMMON,waves[waveCount].time);
-                            else if ((waves[waveCount].mode == 2) && (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL))
-                                events.ScheduleEvent(EVENT_SUMMON,waves[waveCount].time);
-                            else if ((waves[waveCount].mode == 0) && (getDifficulty() == RAID_DIFFICULTY_10MAN_NORMAL))
-                                events.ScheduleEvent(EVENT_SUMMON,waves[waveCount].time);
-                            else
-                                events.ScheduleEvent(EVENT_SUMMON, 0);
-
-                            ++waveCount;
-                        }
-                        else
-                        {
-                            phaseTwo = true;
-                            DoScriptText(SAY_TELEPORT, me);
-                            DoTeleportTo(PosGroundLiveSide);
-                            me->SetReactState(REACT_AGGRESSIVE);
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
-                            summons.DoAction(0, 0);
-                            summons.DoZoneInCombat();
-                            events.ScheduleEvent(EVENT_BOLT, 1000);
-                            events.ScheduleEvent(EVENT_HARVEST, urand(3000,15000));
-                            events.ScheduleEvent(EVENT_TELEPORT, 20000);
-                        }
-                        break;
-                    case EVENT_BOLT:
-                        DoCast(me->getVictim(), RAID_MODE(SPELL_SHADOW_BOLT, H_SPELL_SHADOW_BOLT));
-                        events.ScheduleEvent(EVENT_BOLT, 1000);
-                        break;
-                    case EVENT_HARVEST:
-                        DoCast(me->getVictim(), SPELL_HARVEST_SOUL, true);
-                        events.ScheduleEvent(EVENT_HARVEST, urand(20000,25000));
-                        break;
-                    case EVENT_TELEPORT:
-                        if (!thirtyPercentReached)
-                        {
-                            me->AttackStop();
-                            if (IN_LIVE_SIDE(me))
-                            {
-                                DoTeleportTo(PosGroundDeadSide);
-                            }
-                            else
-                            {
-                                DoTeleportTo(PosGroundLiveSide);
-                            }
-
-                            me->getThreatManager().resetAggro(NotOnSameSide(me));
-                            if (Unit *pTarget = SelectTarget(SELECT_TARGET_NEAREST, 0))
-                            {
-                                me->getThreatManager().addThreat(pTarget, 100.0f);
-                                AttackStart(pTarget);
-                            }
-
-                            events.ScheduleEvent(EVENT_TELEPORT, 20000);
-                        }
-                        break;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        CombatAI::UpdateAI(diff);
+    }
 };
 
-class mob_gothik_minion : public CreatureScript
+CreatureAI* GetAI_boss_gothik(Creature* pCreature)
 {
-public:
-    mob_gothik_minion() : CreatureScript("mob_gothik_minion") { }
+    return new boss_gothikAI (pCreature);
+}
 
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new mob_gothik_minionAI (pCreature);
-    }
-
-    struct mob_gothik_minionAI : public CombatAI
-    {
-        mob_gothik_minionAI(Creature *c) : CombatAI(c)
-        {
-            liveSide = IN_LIVE_SIDE(me);
-        }
-
-        bool liveSide;
-        bool gateClose;
-
-        bool isOnSameSide(const Unit *pWho)
-        {
-            return (liveSide == IN_LIVE_SIDE(pWho));
-        }
-
-        void DoAction(const int32 param)
-        {
-            gateClose = param;
-        }
-
-        void DamageTaken(Unit *attacker, uint32 &damage)
-        {
-            if (gateClose && !isOnSameSide(attacker))
-                damage = 0;
-        }
-
-        void JustDied(Unit * /*killer*/)
-        {
-            if (me->isSummon())
-            {
-                if (Unit *owner = CAST_SUM(me)->GetSummoner())
-                    CombatAI::JustDied(owner);
-            }
-        }
-
-        void EnterEvadeMode()
-        {
-            if (!gateClose)
-            {
-                CombatAI::EnterEvadeMode();
-                return;
-            }
-
-            if (!_EnterEvadeMode())
-                return;
-
-            Map* pMap = me->GetMap();
-            if (pMap->IsDungeon())
-            {
-                Map::PlayerList const &PlayerList = pMap->GetPlayers();
-                if (!PlayerList.isEmpty())
-                {
-                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
-                    {
-                        if (i->getSource() && i->getSource()->isAlive() && isOnSameSide(i->getSource()))
-                        {
-                            AttackStart(i->getSource());
-                            return;
-                        }
-                    }
-                }
-            }
-
-            me->GetMotionMaster()->MoveIdle();
-            Reset();
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (gateClose && (!isOnSameSide(me) || (me->getVictim() && !isOnSameSide(me->getVictim()))))
-            {
-                EnterEvadeMode();
-                return;
-            }
-
-            CombatAI::UpdateAI(diff);
-        }
-    };
-
-};
-
-
+CreatureAI* GetAI_mob_gothik_minion(Creature* pCreature)
+{
+    return new mob_gothik_minionAI (pCreature);
+}
 
 void AddSC_boss_gothik()
 {
-    new boss_gothik();
-    new mob_gothik_minion();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_gothik";
+    newscript->GetAI = &GetAI_boss_gothik;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_gothik_minion";
+    newscript->GetAI = &GetAI_mob_gothik_minion;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_grobbulus.cpp b/src/server/scripts/Northrend/Naxxramas/boss_grobbulus.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_grobbulus.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_grobbulus.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 #include "ScriptPCH.h"
 #include "naxxramas.h"
 
@@ -24,8 +24,7 @@
 #define SPELL_MUTATING_INJECTION    28169
 #define SPELL_SLIME_SPRAY           RAID_MODE(28157,54364)
 #define SPELL_BERSERK               26662
-#define SPELL_POISON_CLOUD_ADD      28158  // not correct spell, correct spells: 28158, 54362 have no visuals
-#define SPELL_SLIME_STREAM          28137
+#define SPELL_POISON_CLOUD_ADD      59116
 
 #define EVENT_BERSERK   1
 #define EVENT_CLOUD     2
@@ -34,168 +33,111 @@
 
 #define MOB_FALLOUT_SLIME   16290
 
-class boss_grobbulus : public CreatureScript
+struct boss_grobbulusAI : public BossAI
 {
-public:
-    boss_grobbulus() : CreatureScript("boss_grobbulus") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
+    boss_grobbulusAI(Creature *c) : BossAI(c, BOSS_GROBBULUS)
     {
-        return new boss_grobbulusAI (pCreature);
+        me->ApplySpellImmune(0, IMMUNITY_ID, SPELL_POISON_CLOUD_ADD, true);
     }
 
-    struct boss_grobbulusAI : public BossAI
+    void EnterCombat(Unit * /*who*/)
     {
-        boss_grobbulusAI(Creature *c) : BossAI(c, BOSS_GROBBULUS)
+        _EnterCombat();
+        events.ScheduleEvent(EVENT_CLOUD, 15000);
+        events.ScheduleEvent(EVENT_INJECT, 20000);
+        events.ScheduleEvent(EVENT_SPRAY, 15000+rand()%15000); //not sure
+        events.ScheduleEvent(EVENT_BERSERK, 12*60000);
+    }
+
+    void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
+    {
+        if (spell->Id == uint32(SPELL_SLIME_SPRAY))
         {
-            me->ApplySpellImmune(0, IMMUNITY_ID, SPELL_POISON_CLOUD_ADD, true);
+            if (TempSummon *slime = me->SummonCreature(MOB_FALLOUT_SLIME, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 0))
+                DoZoneInCombat(slime);
         }
+    }
 
-        uint32 uiSlimeStreamTimer;
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictim())
+            return;
 
-        void Reset()
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            _Reset();
-            uiSlimeStreamTimer = 3*IN_MILLISECONDS;
-            
-        }
-
-        void EnterCombat(Unit *who)
-        {
-            _EnterCombat();
-            events.ScheduleEvent(EVENT_CLOUD, 15000);
-            events.ScheduleEvent(EVENT_INJECT, 20000);
-            events.ScheduleEvent(EVENT_SPRAY, 15000+rand()%15000); //not sure
-            events.ScheduleEvent(EVENT_BERSERK, RAID_MODE(12*60000,9*60000));
-        }
-
-        void EnterEvadeMode()
-        {
-            _EnterEvadeMode();
-            Reset();
-        }
-
-        void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
-        {
-            if (spell->Id == uint32(SPELL_SLIME_SPRAY))
+            switch(eventId)
             {
-                if (TempSummon *slime = me->SummonCreature(MOB_FALLOUT_SLIME, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 0))
-                    DoZoneInCombat(slime);
+                case EVENT_CLOUD:
+                    DoCastAOE(SPELL_POISON_CLOUD);
+                    events.ScheduleEvent(EVENT_CLOUD, 15000);
+                    return;
+                case EVENT_BERSERK:
+                    DoCastAOE(SPELL_BERSERK);
+                    return;
+                case EVENT_SPRAY:
+                    DoCastAOE(SPELL_SLIME_SPRAY);
+                    events.ScheduleEvent(EVENT_SPRAY, 15000+rand()%15000);
+                    return;
+                case EVENT_INJECT:
+                    if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 1))
+                        if (!pTarget->HasAura(SPELL_MUTATING_INJECTION))
+                            DoCast(pTarget, SPELL_MUTATING_INJECTION);
+                    events.ScheduleEvent(EVENT_INJECT, 8000 + 12000 * ((float)me->GetHealth() / me->GetMaxHealth()));
+                    return;
             }
         }
 
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            events.Update(diff);
-
-            if (!me->IsWithinMeleeRange(me->getVictim()))
-            {
-                if (uiSlimeStreamTimer <= diff)
-                {
-                    DoCast(SPELL_SLIME_STREAM);
-                    uiSlimeStreamTimer = 3*IN_MILLISECONDS;
-                }
-                else uiSlimeStreamTimer -= diff;
-            }
-            else uiSlimeStreamTimer = 3*IN_MILLISECONDS;
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_CLOUD:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            DoCastAOE(SPELL_POISON_CLOUD);
-                            events.ScheduleEvent(EVENT_CLOUD, 15000);
-                        }
-                        return;
-                    case EVENT_BERSERK:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                            DoCastAOE(SPELL_BERSERK);
-                        return;
-                    case EVENT_SPRAY:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            DoCastAOE(SPELL_SLIME_SPRAY);
-                            events.ScheduleEvent(EVENT_SPRAY, 15000+rand()%15000);
-                        }
-                        return;
-                    case EVENT_INJECT:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 200, true))
-                                if (!pTarget->HasAura(SPELL_MUTATING_INJECTION))
-                                {
-                                    DoCast(pTarget, SPELL_MUTATING_INJECTION);
-                                    events.ScheduleEvent(EVENT_INJECT, 8000 + uint32(120 * me->GetHealthPct()));
-                                }
-                        }
-                        return;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
-class npc_grobbulus_poison_cloud : public CreatureScript
+struct npc_grobbulus_poison_cloudAI : public Scripted_NoMovementAI
 {
-public:
-    npc_grobbulus_poison_cloud() : CreatureScript("npc_grobbulus_poison_cloud") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
+    npc_grobbulus_poison_cloudAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
     {
-        return new npc_grobbulus_poison_cloudAI(pCreature);
+        Reset();
     }
 
-    struct npc_grobbulus_poison_cloudAI : public Scripted_NoMovementAI
+    uint32 Cloud_Timer;
+
+    void Reset()
     {
-        npc_grobbulus_poison_cloudAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+        Cloud_Timer = 1000;
+        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (Cloud_Timer <= diff)
         {
-            Reset();
-        }
-
-        uint32 Cloud_Timer;
-        bool cloud_casted;
-
-        void Reset()
-        {
-            Cloud_Timer = 1000;
-            cloud_casted = false;
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-            me->setFaction(14);
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (Cloud_Timer <= diff)
-            {
-                if(!me->HasAura(SPELL_POISON_CLOUD_ADD))
-                    if(!cloud_casted)
-                    {
-                        DoCast(me, SPELL_POISON_CLOUD_ADD);
-                        cloud_casted = true;
-                    }
-                    else
-                        me->DealDamage(me,me->GetHealth());
-
-                Cloud_Timer = 10000;
-            } else Cloud_Timer -= diff;
-        }
-    };
-
+            DoCast(me, SPELL_POISON_CLOUD_ADD);
+            Cloud_Timer = 10000;
+        } else Cloud_Timer -= diff;
+    }
 };
 
+CreatureAI* GetAI_boss_grobbulus(Creature* pCreature)
+{
+    return new boss_grobbulusAI (pCreature);
+}
 
+CreatureAI* GetAI_npc_grobbulus_poison_cloud(Creature* pCreature)
+{
+    return new npc_grobbulus_poison_cloudAI(pCreature);
+}
 
 void AddSC_boss_grobbulus()
 {
-    new boss_grobbulus();
-    new npc_grobbulus_poison_cloud();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_grobbulus";
+    newscript->GetAI = &GetAI_boss_grobbulus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_grobbulus_poison_cloud";
+    newscript->GetAI = &GetAI_npc_grobbulus_poison_cloud;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp b/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -42,121 +42,109 @@
     PHASE_DANCE,
 };
 
-class boss_heigan : public CreatureScript
+struct boss_heiganAI : public BossAI
 {
-public:
-    boss_heigan() : CreatureScript("boss_heigan") { }
+    boss_heiganAI(Creature *c) : BossAI(c, BOSS_HEIGAN) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    uint32 eruptSection;
+    bool eruptDirection;
+    Phases phase;
+
+    void KilledUnit(Unit* /*Victim*/)
     {
-        return new boss_heiganAI (pCreature);
+        if (!(rand()%5))
+            DoScriptText(SAY_SLAY, me);
     }
 
-    struct boss_heiganAI : public BossAI
+    void JustDied(Unit* /*Killer*/)
     {
-        boss_heiganAI(Creature *c) : BossAI(c, BOSS_HEIGAN) {}
+        _JustDied();
+        DoScriptText(SAY_DEATH, me);
+    }
 
-        uint32 eruptSection;
-        bool eruptDirection;
-        Phases phase;
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+        DoScriptText(SAY_AGGRO, me);
+        EnterPhase(PHASE_FIGHT);
+    }
 
-        void Reset()
+    void EnterPhase(Phases newPhase)
+    {
+        phase = newPhase;
+        events.Reset();
+        eruptSection = 3;
+        if (phase == PHASE_FIGHT)
         {
-            _Reset();
+            events.ScheduleEvent(EVENT_DISRUPT, urand(10000, 25000));
+            events.ScheduleEvent(EVENT_FEVER, urand(15000, 20000));
+            events.ScheduleEvent(EVENT_PHASE, 90000);
+            events.ScheduleEvent(EVENT_ERUPT, 15000);
         }
+        else
+        {
+            float x, y, z, o;
+            me->GetHomePosition(x, y, z, o);
+            me->NearTeleportTo(x, y, z, o);
+            DoCastAOE(SPELL_PLAGUE_CLOUD);
+            events.ScheduleEvent(EVENT_PHASE, 45000);
+            events.ScheduleEvent(EVENT_ERUPT, 8000);
+        }
+    }
 
-        void KilledUnit(Unit* /*Victim*/)
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictim() || !CheckInRoom())
+            return;
+
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            if (!(rand()%5))
-                DoScriptText(SAY_SLAY, me);
-        }
+            switch(eventId)
+            {
+                case EVENT_DISRUPT:
+                    DoCastAOE(SPELL_SPELL_DISRUPTION);
+                    events.ScheduleEvent(EVENT_DISRUPT, urand(5000, 10000));
+                    break;
+                case EVENT_FEVER:
+                    DoCastAOE(SPELL_DECREPIT_FEVER);
+                    events.ScheduleEvent(EVENT_FEVER, urand(20000, 25000));
+                    break;
+                case EVENT_PHASE:
+                    // TODO : Add missing texts for both phase switches
+                    EnterPhase(phase == PHASE_FIGHT ? PHASE_DANCE : PHASE_FIGHT);
+                    break;
+                case EVENT_ERUPT:
+                    instance->SetData(DATA_HEIGAN_ERUPT, eruptSection);
+                    TeleportCheaters();
 
-        void JustDied(Unit* /*Killer*/)
-        {
-            _JustDied();
-            DoScriptText(SAY_DEATH, me);
-        }
+                    if (eruptSection == 0)
+                        eruptDirection = true;
+                    else if (eruptSection == 3)
+                        eruptDirection = false;
 
-        void EnterCombat(Unit * /*who*/)
-        {
-            _EnterCombat();
-            TeleportCheaters();
-            DoScriptText(SAY_AGGRO, me);
-            EnterPhase(PHASE_FIGHT);
-        }
+                    eruptDirection ? ++eruptSection : --eruptSection;
 
-        void EnterPhase(Phases newPhase)
-        {
-            phase = newPhase;
-            events.Reset();
-            eruptSection = 3;
-            if (phase == PHASE_FIGHT)
-            {
-                me->GetMotionMaster()->MoveChase(me->getVictim());
-                events.ScheduleEvent(EVENT_DISRUPT, urand(10000, 25000));
-                events.ScheduleEvent(EVENT_FEVER, urand(15000, 20000));
-                events.ScheduleEvent(EVENT_PHASE, 90000);
-                events.ScheduleEvent(EVENT_ERUPT, 15000);
-            }
-            else
-            {
-                float x, y, z, o;
-                me->GetHomePosition(x, y, z, o);
-                me->NearTeleportTo(x, y, z, o);
-                me->GetMotionMaster()->MoveIdle();
-                DoCastAOE(SPELL_PLAGUE_CLOUD);
-                events.ScheduleEvent(EVENT_PHASE, 45000);
-                events.ScheduleEvent(EVENT_ERUPT, 8000);
+                    events.ScheduleEvent(EVENT_ERUPT, phase == PHASE_FIGHT ? 10000 : 3000);
+                    break;
             }
         }
 
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim() || !CheckInRoom())
-                return;
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_DISRUPT:
-                        DoCastAOE(SPELL_SPELL_DISRUPTION);
-                        events.ScheduleEvent(EVENT_DISRUPT, urand(5000, 10000));
-                        break;
-                    case EVENT_FEVER:
-                        DoCastAOE(SPELL_DECREPIT_FEVER);
-                        events.ScheduleEvent(EVENT_FEVER, urand(20000, 25000));
-                        break;
-                    case EVENT_PHASE:
-                        // TODO : Add missing texts for both phase switches
-                        EnterPhase(phase == PHASE_FIGHT ? PHASE_DANCE : PHASE_FIGHT);
-                        break;
-                    case EVENT_ERUPT:
-                        instance->SetData(DATA_HEIGAN_ERUPT, eruptSection);
-                        TeleportCheaters();
-
-                        if (eruptSection == 0)
-                            eruptDirection = true;
-                        else if (eruptSection == 3)
-                            eruptDirection = false;
-
-                        eruptDirection ? ++eruptSection : --eruptSection;
-
-                        events.ScheduleEvent(EVENT_ERUPT, phase == PHASE_FIGHT ? 10000 : 4000);
-                        break;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_boss_heigan(Creature* pCreature)
+{
+    return new boss_heiganAI (pCreature);
+}
 
 void AddSC_boss_heigan()
 {
-    new boss_heigan();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_heigan";
+    newscript->GetAI = &GetAI_boss_heigan;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp b/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_kelthuzad.cpp
@@ -1,20 +1,21 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 /* ScriptData
 SDName: Boss_KelThuzad
 SD%Complete: 80%
@@ -132,18 +133,18 @@
 
 const Position Pos[12] =
 {
-    {3783.272705f, -5062.697266f, 143.711203f, 3.617599f},     //LEFT_FAR
-    {3730.291260f, -5027.239258f, 143.956909f, 4.461900f},     //LEFT_MIDDLE
-    {3757.6f, -5172.0f, 143.7f, 1.97f},                        //WINDOW_PORTAL05
-    {3759.355225f, -5174.128418f, 143.802383f, 2.170104f},     //RIGHT_FAR
-    {3700.724365f, -5185.123047f, 143.928024f, 1.309310f},     //RIGHT_MIDDLE
-    {3700.86f, -5181.29f, 143.928024f, 1.42f},                 //WINDOW_PORTAL04
-    {3754.431396f, -5080.727734f, 142.036316f, 3.736189f},     //LEFT_FAR
-    {3724.396484f, -5061.330566f, 142.032700f, 4.564785f},     //LEFT_MIDDLE
-    {3732.02f, -5028.53f, 143.92f, 4.49f},                     //WINDOW_PORTAL02
-    {3687.571777f, -5126.831055f, 142.017807f, 0.604023f},     //RIGHT_FAR
-    {3707.990733f, -5151.450195f, 142.032562f, 1.376855f},     //RIGHT_MIDDLE
-    {3782.76f, -5062.97f, 143.79f, 3.82f},                     //WINDOW_PORTAL03
+    {3783.272705, -5062.697266, 143.711203, 3.617599},     //LEFT_FAR
+    {3730.291260, -5027.239258, 143.956909, 4.461900},     //LEFT_MIDDLE
+    {3757.6, -5172.0, 143.7, 1.97},                        //WINDOW_PORTAL05
+    {3759.355225, -5174.128418, 143.802383, 2.170104},     //RIGHT_FAR
+    {3700.724365, -5185.123047, 143.928024, 1.309310},     //RIGHT_MIDDLE
+    {3700.86, -5181.29, 143.928024, 1.42},                 //WINDOW_PORTAL04
+    {3754.431396, -5080.727734, 142.036316, 3.736189},     //LEFT_FAR
+    {3724.396484, -5061.330566, 142.032700, 4.564785},     //LEFT_MIDDLE
+    {3732.02, -5028.53, 143.92, 4.49},                     //WINDOW_PORTAL02
+    {3687.571777, -5126.831055, 142.017807, 0.604023},     //RIGHT_FAR
+    {3707.990733, -5151.450195, 142.032562, 1.376855},     //RIGHT_MIDDLE
+    {3782.76, -5062.97, 143.79, 3.82},                     //WINDOW_PORTAL03
 };
 
 //creatures in corners
@@ -151,95 +152,95 @@
 #define MAX_ABOMINATIONS                        21
 const Position PosAbominations[MAX_ABOMINATIONS] =
 {
-    {3755.52f, -5155.22f, 143.480f, 2.0f},
-    {3744.35f, -5164.03f, 143.590f, 2.00f},
-    {3749.28f, -5159.04f, 143.190f, 2.0f},
-    {3774.47f, -5076.28f, 143.528f, 2.15912f},
-    {3765.94f, -5074.15f, 143.186f, 3.77233f},
-    {3763.15f, -5063.36f, 143.694f, 3.77233f},
-    {3737.81f, -5045.69f, 143.709f, 4.9033f},
-    {3728.13f, -5045.01f, 143.355f, 1.45069f},
-    {3721.56f, -5048.35f, 143.542f, 1.45069f},
-    {3689.55f, -5049.66f, 143.637f, 5.2104f},
-    {3681.71f, -5053.03f, 143.242f, 2.47957f},
-    {3677.64f, -5061.44f, 143.358f, 2.47957f},
-    {3654.2f, -5090.87f, 143.469f, 1.0313f},
-    {3650.39f, -5097.45f, 143.496f, 2.5047f},
-    {3658.7f, -5103.59f, 143.607f, 3.3278f},
-    {3659.02f, -5133.97f, 143.624f, 3.84538f},
-    {3666.33f, -5139.34f, 143.183f, 3.84538f},
-    {3669.74f, -5149.63f, 143.678f, 0.528643f},
-    {3695.53f, -5169.53f, 143.671f, 2.11908f},
-    {3701.98f, -5166.51f, 143.395f, 1.24257f},
-    {3709.62f, -5169.15f, 143.576f, 5.97695f},
+    {3755.52, -5155.22, 143.480, 2.0},
+    {3744.35, -5164.03, 143.590, 2.00},
+    {3749.28, -5159.04, 143.190, 2.0},
+    {3774.47, -5076.28, 143.528, 2.15912},
+    {3765.94, -5074.15, 143.186, 3.77233},
+    {3763.15, -5063.36, 143.694, 3.77233},
+    {3737.81, -5045.69, 143.709, 4.9033},
+    {3728.13, -5045.01, 143.355, 1.45069},
+    {3721.56, -5048.35, 143.542, 1.45069},
+    {3689.55, -5049.66, 143.637, 5.2104},
+    {3681.71, -5053.03, 143.242, 2.47957},
+    {3677.64, -5061.44, 143.358, 2.47957},
+    {3654.2, -5090.87, 143.469, 1.0313},
+    {3650.39, -5097.45, 143.496, 2.5047},
+    {3658.7, -5103.59, 143.607, 3.3278},
+    {3659.02, -5133.97, 143.624, 3.84538},
+    {3666.33, -5139.34, 143.183, 3.84538},
+    {3669.74, -5149.63, 143.678, 0.528643},
+    {3695.53, -5169.53, 143.671, 2.11908},
+    {3701.98, -5166.51, 143.395, 1.24257},
+    {3709.62, -5169.15, 143.576, 5.97695},
 };
 
 //Soldiers of the Frozen Wastes
 #define MAX_WASTES                              49
 const Position PosWastes[MAX_WASTES] =
 {
-    {3754.41f, -5147.24f, 143.204f, 2.0f},
-    {3754.68f, -5156.17f, 143.418f, 2.0f},
-    {3757.91f, -5160.12f, 143.503f, 2.0f},
-    {3752.67f, -5164.6f, 143.395f, 2.0f},
-    {3745.42f, -5164.47f, 143.565f, 2.74587f},
-    {3741.2f, -5155.92f, 143.17f, 5.29134f},
-    {3746.57f, -5148.82f, 143.176f, 5.07772f},
-    {3778.14f, -5070.1f, 143.568f, 3.16208f},
-    {3775.09f, -5078.97f, 143.65f, 2.81022f},
-    {3773.54f, -5083.47f, 143.758f, 3.21549f},
-    {3765, -5078.29f, 143.176f, 4.36688f},
-    {3766.94f, -5072.63f, 143.184f, 5.27951f},
-    {3762.68f, -5064.94f, 143.635f, 3.95297f},
-    {3769.9f, -5059.94f, 143.74f, 3.36549f},
-    {3736.33f, -5042.18f, 143.643f, 5.9471f},
-    {3727.51f, -5040.58f, 143.502f, 0.871859f},
-    {3719.89f, -5049.64f, 143.58f, 4.75172f},
-    {3720.69f, -5044.43f, 143.662f, 1.87245f},
-    {3725.69f, -5048.99f, 143.363f, 2.48271f},
-    {3732.33f, -5054.01f, 143.44f, 3.59405f},
-    {3738.09f, -5051.06f, 143.718f, 4.70931f},
-    {3682.76f, -5063.5f, 143.175f, 0.636238f},
-    {3686.7f, -5060.58f, 143.18f, 0.636238f},
-    {3682.45f, -5057.21f, 143.184f, 5.61252f},
-    {3677.57f, -5053.34f, 143.369f, 1.52531f},
-    {3677.3f, -5062.26f, 143.369f, 2.73482f},
-    {3691.21f, -5053.02f, 143.421f, 5.93218f},
-    {3685.22f, -5053.34f, 143.314f, 4.70303f},
-    {3652.11f, -5088.47f, 143.555f, 0.793317f},
-    {3648.23f, -5093.21f, 143.311f, 1.18837f},
-    {3648.14f, -5100.11f, 143.632f, 2.12221f},
-    {3653.88f, -5099.7f, 143.558f, 3.04348f},
-    {3661.23f, -5100.33f, 143.42f, 4.08335f},
-    {3663.49f, -5092.77f, 143.346f, 4.47134f},
-    {3661.85f, -5087.99f, 143.571f, 1.0148f},
-    {3664.56f, -5149.01f, 143.532f, 0.0762528f},
-    {3665.01f, -5142.04f, 143.201f, 1.72009f},
-    {3671.15f, -5142.92f, 143.174f, 4.81535f},
-    {3670.18f, -5134.38f, 143.177f, 5.37534f},
-    {3664.33f, -5131.69f, 143.262f, 5.39576f},
-    {3658.21f, -5133.63f, 143.662f, 1.3863f},
-    {3659.7f, -5144.49f, 143.363f, 2.32328f},
-    {3705.71f, -5179.63f, 143.746f, 1.06743f},
-    {3696.77f, -5177.45f, 143.759f, 5.36748f},
-    {3700.97f, -5173.13f, 143.52f, 3.26575f},
-    {3708.53f, -5172.19f, 143.573f, 3.26575f},
-    {3712.49f, -5167.62f, 143.657f, 5.63295f},
-    {3704.89f, -5161.84f, 143.239f, 5.63295f},
-    {3695.66f, -5164.63f, 143.674f, 1.54416f},
+    {3754.41, -5147.24, 143.204, 2.0},
+    {3754.68, -5156.17, 143.418, 2.0},
+    {3757.91, -5160.12, 143.503, 2.0},
+    {3752.67, -5164.6, 143.395, 2.0},
+    {3745.42, -5164.47, 143.565, 2.74587},
+    {3741.2, -5155.92, 143.17, 5.29134},
+    {3746.57, -5148.82, 143.176, 5.07772},
+    {3778.14, -5070.1, 143.568, 3.16208},
+    {3775.09, -5078.97, 143.65, 2.81022},
+    {3773.54, -5083.47, 143.758, 3.21549},
+    {3765, -5078.29, 143.176, 4.36688},
+    {3766.94, -5072.63, 143.184, 5.27951},
+    {3762.68, -5064.94, 143.635, 3.95297},
+    {3769.9, -5059.94, 143.74, 3.36549},
+    {3736.33, -5042.18, 143.643, 5.9471},
+    {3727.51, -5040.58, 143.502, 0.871859},
+    {3719.89, -5049.64, 143.58, 4.75172},
+    {3720.69, -5044.43, 143.662, 1.87245},
+    {3725.69, -5048.99, 143.363, 2.48271},
+    {3732.33, -5054.01, 143.44, 3.59405},
+    {3738.09, -5051.06, 143.718, 4.70931},
+    {3682.76, -5063.5, 143.175, 0.636238},
+    {3686.7, -5060.58, 143.18, 0.636238},
+    {3682.45, -5057.21, 143.184, 5.61252},
+    {3677.57, -5053.34, 143.369, 1.52531},
+    {3677.3, -5062.26, 143.369, 2.73482},
+    {3691.21, -5053.02, 143.421, 5.93218},
+    {3685.22, -5053.34, 143.314, 4.70303},
+    {3652.11, -5088.47, 143.555, 0.793317},
+    {3648.23, -5093.21, 143.311, 1.18837},
+    {3648.14, -5100.11, 143.632, 2.12221},
+    {3653.88, -5099.7, 143.558, 3.04348},
+    {3661.23, -5100.33, 143.42, 4.08335},
+    {3663.49, -5092.77, 143.346, 4.47134},
+    {3661.85, -5087.99, 143.571, 1.0148},
+    {3664.56, -5149.01, 143.532, 0.0762528},
+    {3665.01, -5142.04, 143.201, 1.72009},
+    {3671.15, -5142.92, 143.174, 4.81535},
+    {3670.18, -5134.38, 143.177, 5.37534},
+    {3664.33, -5131.69, 143.262, 5.39576},
+    {3658.21, -5133.63, 143.662, 1.3863},
+    {3659.7, -5144.49, 143.363, 2.32328},
+    {3705.71, -5179.63, 143.746, 1.06743},
+    {3696.77, -5177.45, 143.759, 5.36748},
+    {3700.97, -5173.13, 143.52, 3.26575},
+    {3708.53, -5172.19, 143.573, 3.26575},
+    {3712.49, -5167.62, 143.657, 5.63295},
+    {3704.89, -5161.84, 143.239, 5.63295},
+    {3695.66, -5164.63, 143.674, 1.54416},
 };
 
 //Soul Weavers
 #define MAX_WEAVERS                             7
 const Position PosWeavers[MAX_WEAVERS] =
 {
-    {3752.45f, -5168.35f, 143.562f, 1.6094f},
-    {3772.2f, -5070.04f, 143.329f, 1.93686f},
-    {3732.28f, -5032.88f, 143.771f, 3.08355f},
-    {3689.05f, -5055.7f, 143.172f, 6.09554f},
-    {3649.45f, -5093.17f, 143.299f, 2.51805f},
-    {3659.7f, -5144.49f, 143.363f, 4.08806f},
-    {3704.71f, -5175.96f, 143.597f, 3.36549f},
+    {3752.45, -5168.35, 143.562, 1.6094},
+    {3772.2, -5070.04, 143.329, 1.93686},
+    {3732.28, -5032.88, 143.771, 3.08355},
+    {3689.05, -5055.7, 143.172, 6.09554},
+    {3649.45, -5093.17, 143.299, 2.51805},
+    {3659.7, -5144.49, 143.363, 4.08806},
+    {3704.71, -5175.96, 143.597, 3.36549},
 };
 
 // predicate function to select not charmed target
@@ -251,464 +252,457 @@
     }
 };
 
-class boss_kelthuzad : public CreatureScript
+struct boss_kelthuzadAI : public BossAI
 {
-public:
-    boss_kelthuzad() : CreatureScript("boss_kelthuzad") { }
+    boss_kelthuzadAI(Creature* c) : BossAI(c, BOSS_KELTHUZAD), spawns(c)
+    {
+        uiFaction = me->getFaction();
+    }
 
-    struct boss_kelthuzadAI : public BossAI
+    uint32 Phase;
+    uint32 uiGuardiansOfIcecrownTimer;
+    uint32 uiFaction;
+
+    uint8  nGuardiansOfIcecrownCount;
+    uint8  nAbomination;
+    uint8  nWeaver;
+
+    std::map<uint64, float> chained;
+
+    uint64 PortalsGUID[4];
+    uint64 KTTriggerGUID;
+
+    SummonList spawns; // adds spawn by the trigger. kept in separated list (i.e. not in summons)
+
+    void Reset()
     {
-        boss_kelthuzadAI(Creature* c) : BossAI(c, BOSS_KELTHUZAD), spawns(c)
+        _Reset();
+
+        PortalsGUID[0] = PortalsGUID[1] = PortalsGUID[2] = PortalsGUID[3] = 0;
+        KTTriggerGUID = 0;
+
+        me->setFaction(35);
+        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_SELECTABLE);
+        std::map<uint64, float>::const_iterator itr;
+        for (itr = chained.begin(); itr != chained.end(); ++itr)
         {
-            uiFaction = me->getFaction();
+            if (Player* charmed = Unit::GetPlayer(*me, (*itr).first))
+                charmed->SetFloatValue(OBJECT_FIELD_SCALE_X, (*itr).second);
         }
 
-        uint32 Phase;
-        uint32 uiGuardiansOfIcecrownTimer;
-        uint32 uiFaction;
+        chained.clear();
+        spawns.DespawnAll();
 
-        uint8  nGuardiansOfIcecrownCount;
-        uint8  nAbomination;
-        uint8  nWeaver;
+        FindGameObjects();
 
-        std::map<uint64, float> chained;
+        if (GameObject *pKTTrigger = me->GetMap()->GetGameObject(KTTriggerGUID))
+        {
+            pKTTrigger->ResetDoorOrButton();
+            pKTTrigger->SetPhaseMask(1, true);
+        }
 
-        uint64 PortalsGUID[4];
-        uint64 KTTriggerGUID;
+        for (uint8 i = 0; i <= 3; ++i)
+        {
+            if (GameObject *pPortal = me->GetMap()->GetGameObject(PortalsGUID[i]))
+            {
+                if (!((pPortal->getLootState() == GO_READY) || (pPortal->getLootState() == GO_NOT_READY)))
+                    pPortal->ResetDoorOrButton();
+            }
+        }
 
-        SummonList spawns; // adds spawn by the trigger. kept in separated list (i.e. not in summons)
+        nGuardiansOfIcecrownCount = 0;
+        uiGuardiansOfIcecrownTimer = 5000;                   //5 seconds for summoning each Guardian of Icecrown in phase 3
 
-        void Reset()
+        Phase = 0;
+        nAbomination = 0;
+        nWeaver = 0;
+    }
+
+    void KilledUnit()
+    {
+        DoScriptText(RAND(SAY_SLAY_1,SAY_SLAY_2), me);
+    }
+
+    void JustDied(Unit* /*Killer*/)
+    {
+        _JustDied();
+        DoScriptText(SAY_DEATH, me);
+
+        std::map<uint64, float>::const_iterator itr;
+        for (itr = chained.begin(); itr != chained.end(); ++itr)
         {
-            _Reset();
+            if (Player* pPlayer = Unit::GetPlayer(*me, (*itr).first))
+                pPlayer->SetFloatValue(OBJECT_FIELD_SCALE_X, (*itr).second);
+        }
+        chained.clear();
+    }
 
-            PortalsGUID[0] = PortalsGUID[1] = PortalsGUID[2] = PortalsGUID[3] = 0;
-            KTTriggerGUID = 0;
+    void EnterCombat(Unit* /*who*/)
+    {
+        me->setFaction(uiFaction);
 
-            me->setFaction(35);
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_SELECTABLE);
-            std::map<uint64, float>::const_iterator itr;
-            for (itr = chained.begin(); itr != chained.end(); ++itr)
+        _EnterCombat();
+        FindGameObjects();
+        for (uint8 i = 0; i <= 3; ++i)
+        {
+            if (GameObject *pPortal = me->GetMap()->GetGameObject(PortalsGUID[i]))
+                pPortal->ResetDoorOrButton();
+        }
+        DoCast(me, SPELL_KELTHUZAD_CHANNEL, false);
+        DoScriptText(SAY_SUMMON_MINIONS, me);
+        Phase = 1;
+        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_SELECTABLE);
+        me->SetFloatValue(UNIT_FIELD_COMBATREACH, 4);
+        me->SetFloatValue(UNIT_FIELD_BOUNDINGRADIUS, 4);
+        events.ScheduleEvent(EVENT_TRIGGER, 5000);
+        events.ScheduleEvent(EVENT_WASTE, 15000);
+        events.ScheduleEvent(EVENT_ABOMIN, 30000);
+        events.ScheduleEvent(EVENT_WEAVER, 50000);
+        events.ScheduleEvent(EVENT_PHASE, 228000);
+    }
+
+    void FindGameObjects()
+    {
+        PortalsGUID[0] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL01) : 0;
+        PortalsGUID[1] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL02) : 0;
+        PortalsGUID[2] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL03) : 0;
+        PortalsGUID[3] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL04) : 0;
+        KTTriggerGUID = instance ? instance->GetData64(DATA_KELTHUZAD_TRIGGER) : 0;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateCombatState())
+            return;
+
+        events.Update(diff);
+
+        if (Phase == 1)
+        {
+            while (uint32 eventId = events.GetEvent())
             {
-                if (Player* charmed = Unit::GetPlayer(*me, (*itr).first))
-                    charmed->SetFloatValue(OBJECT_FIELD_SCALE_X, (*itr).second);
+                switch(eventId)
+                {
+                    case EVENT_WASTE:
+                        DoSummon(NPC_WASTE, Pos[RAND(0,3,6,9)]);
+                        events.RepeatEvent(urand(2000,5000));
+                        break;
+                    case EVENT_ABOMIN:
+                        if (nAbomination < 8)
+                        {
+                            DoSummon(NPC_ABOMINATION, Pos[RAND(1,4,7,10)]);
+                            nAbomination++;
+                            events.RepeatEvent(20000);
+                        }
+                        else
+                            events.PopEvent();
+                        break;
+                    case EVENT_WEAVER:
+                        if (nWeaver < 8)
+                        {
+                            DoSummon(NPC_WEAVER, Pos[RAND(0,3,6,9)]);
+                            nWeaver++;
+                            events.RepeatEvent(25000);
+                        }
+                        else
+                            events.PopEvent();
+                        break;
+                    case EVENT_TRIGGER:
+                        if (GameObject *pKTTrigger = me->GetMap()->GetGameObject(KTTriggerGUID))
+                            pKTTrigger->SetPhaseMask(2, true);
+                        events.PopEvent();
+                        break;
+                    case EVENT_PHASE:
+                        events.Reset();
+                        DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2,SAY_AGGRO_3), me);
+                        spawns.DespawnAll();
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_SELECTABLE);
+                        me->CastStop();
+
+                        DoStartMovement(me->getVictim());
+                        events.ScheduleEvent(EVENT_BOLT, urand(5000,10000));
+                        events.ScheduleEvent(EVENT_NOVA, 15000);
+                        events.ScheduleEvent(EVENT_DETONATE, urand(30000,40000));
+                        events.ScheduleEvent(EVENT_FISSURE, urand(10000,30000));
+                        events.ScheduleEvent(EVENT_BLAST, urand(60000,120000));
+                        if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
+                            events.ScheduleEvent(EVENT_CHAIN, urand(30000,60000));
+                        Phase = 2;
+                        break;
+                    default:
+                        events.PopEvent();
+                        break;
+                }
+            }
+        }
+        else
+        {
+            //start phase 3 when we are 45% health
+            if (Phase != 3)
+            {
+                if (HealthBelowPct(45))
+                {
+                    Phase = 3 ;
+                    DoScriptText(SAY_REQUEST_AID, me);
+                    //here Lich King should respond to KelThuzad but I don't know which Creature to make talk
+                    //so for now just make Kelthuzad says it.
+                    DoScriptText(SAY_ANSWER_REQUEST, me);
+
+                    for (uint8 i = 0; i <= 3; ++i)
+                    {
+                        if (GameObject *pPortal = me->GetMap()->GetGameObject(PortalsGUID[i]))
+                        {
+                            if (pPortal->getLootState() == GO_READY)
+                                pPortal->UseDoorOrButton();
+                        }
+                    }
+                }
+            }
+            else if (nGuardiansOfIcecrownCount < RAID_MODE(2,4))
+            {
+                if (uiGuardiansOfIcecrownTimer <= diff)
+                {
+                    // TODO : Add missing text
+                    if (Creature* pGuardian = DoSummon(NPC_ICECROWN, Pos[RAND(2,5,8,11)]))
+                        pGuardian->SetFloatValue(UNIT_FIELD_COMBATREACH, 2);
+                    ++nGuardiansOfIcecrownCount;
+                    uiGuardiansOfIcecrownTimer = 5000;
+                }
+                else uiGuardiansOfIcecrownTimer -= diff;
             }
 
-            chained.clear();
-            spawns.DespawnAll();
+            if (me->hasUnitState(UNIT_STAT_CASTING))
+                return;
 
-            FindGameObjects();
+            if (uint32 eventId = events.GetEvent())
+            {
+                switch(eventId)
+                {
+                    case EVENT_BOLT:
+                        DoCastVictim(RAID_MODE(SPELL_FROST_BOLT,H_SPELL_FROST_BOLT));
+                        events.RepeatEvent(urand(5000,10000));
+                        break;
+                    case EVENT_NOVA:
+                        DoCastAOE(RAID_MODE(SPELL_FROST_BOLT_AOE,H_SPELL_FROST_BOLT_AOE));
+                        events.RepeatEvent(urand(15000,30000));
+                        break;
+                    case EVENT_CHAIN:
+                    {
+                        uint32 count = urand(1,3);
+                        for (uint8 i = 1; i <= count; i++)
+                        {
+                            Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 200, true);
+                            if (pTarget && !pTarget->isCharmed() && (chained.find(pTarget->GetGUID()) == chained.end()))
+                            {
+                                DoCast(pTarget, SPELL_CHAINS_OF_KELTHUZAD);
+                                float scale = pTarget->GetFloatValue(OBJECT_FIELD_SCALE_X);
+                                chained.insert(std::make_pair(pTarget->GetGUID(), scale));
+                                pTarget->SetFloatValue(OBJECT_FIELD_SCALE_X, scale * 2);
+                                events.ScheduleEvent(EVENT_CHAINED_SPELL, 2000); //core has 2000ms to set unit flag charm
+                            }
+                        }
+                        if (!chained.empty())
+                            DoScriptText(RAND(SAY_CHAIN_1,SAY_CHAIN_2), me);
+                        events.RepeatEvent(urand(100000,180000));
+                        break;
+                    }
+                    case EVENT_CHAINED_SPELL:
+                    {
+                        std::map<uint64, float>::iterator itr;
+                        for (itr = chained.begin(); itr != chained.end();)
+                        {
+                            if (Unit* player = Unit::GetPlayer(*me, (*itr).first))
+                            {
+                                if (!player->isCharmed())
+                                {
+                                    player->SetFloatValue(OBJECT_FIELD_SCALE_X, (*itr).second);
+                                    std::map<uint64, float>::iterator next = itr;
+                                    ++next;
+                                    chained.erase(itr);
+                                    itr = next;
+                                    continue;
+                                }
 
-            if (GameObject *pKTTrigger = me->GetMap()->GetGameObject(KTTriggerGUID))
-            {
-                pKTTrigger->ResetDoorOrButton();
-                pKTTrigger->SetPhaseMask(1, true);
-            }
+                                if (Unit *pTarget = SelectTarget(SELECT_TARGET_TOPAGGRO, 0, NotCharmedTargetSelector()))
+                                {
+                                    switch(player->getClass())
+                                    {
+                                        case CLASS_DRUID:
+                                            if (urand(0,1))
+                                                player->CastSpell(pTarget, SPELL_MOONFIRE, false);
+                                            else
+                                                player->CastSpell(me, SPELL_LIFEBLOOM, false);
+                                            break;
+                                        case CLASS_HUNTER:
+                                            player->CastSpell(pTarget, RAND(SPELL_MULTI_SHOT, SPELL_VOLLEY), false);
+                                            break;
+                                        case CLASS_MAGE:
+                                            player->CastSpell(pTarget, RAND(SPELL_FROST_FIREBOLT, SPELL_ARCANE_MISSILES), false);
+                                            break;
+                                        case CLASS_WARLOCK:
+                                            player->CastSpell(pTarget, RAND(SPELL_CURSE_OF_AGONY, SPELL_SHADOW_BOLT), true);
+                                            break;
+                                        case CLASS_WARRIOR:
+                                            player->CastSpell(pTarget, RAND(SPELL_BLADESTORM, SPELL_CLEAVE), false);
+                                            break;
+                                        case CLASS_PALADIN:
+                                            if (urand(0,1))
+                                                player->CastSpell(pTarget, SPELL_HAMMER_OF_JUSTICE, false);
+                                            else
+                                                player->CastSpell(me, SPELL_HOLY_SHOCK, false);
+                                            break;
+                                        case CLASS_PRIEST:
+                                            if (urand(0,1))
+                                                player->CastSpell(pTarget, SPELL_VAMPIRIC_TOUCH, false);
+                                            else
+                                                player->CastSpell(me, SPELL_RENEW, false);
+                                            break;
+                                        case CLASS_SHAMAN:
+                                            if (urand(0,1))
+                                                player->CastSpell(pTarget, SPELL_EARTH_SHOCK, false);
+                                            else
+                                                player->CastSpell(me, SPELL_HEALING_WAVE, false);
+                                            break;
+                                        case CLASS_ROGUE:
+                                            player->CastSpell(pTarget, RAND(SPELL_HEMORRHAGE, SPELL_MUTILATE), false);
+                                            break;
+                                        case CLASS_DEATH_KNIGHT:
+                                            if (urand(0,1))
+                                                player->CastSpell(pTarget, SPELL_PLAGUE_STRIKE, true);
+                                            else
+                                                player->CastSpell(pTarget, SPELL_HOWLING_BLAST, true);
+                                            break;
+                                    }
+                                }
+                            }
+                            ++itr;
+                        }
 
-            for (uint8 i = 0; i <= 3; ++i)
-            {
-                if (GameObject *pPortal = me->GetMap()->GetGameObject(PortalsGUID[i]))
-                {
-                    if (!((pPortal->getLootState() == GO_READY) || (pPortal->getLootState() == GO_NOT_READY)))
-                        pPortal->ResetDoorOrButton();
+                        if (chained.empty())
+                            events.PopEvent();
+                        else
+                            events.RepeatEvent(5000);
+
+                        break;
+                    }
+                    case EVENT_DETONATE:
+                    {
+                        std::vector<Unit*> unitList;
+                        std::list<HostileReference*> *threatList = &me->getThreatManager().getThreatList();
+                        for (std::list<HostileReference*>::const_iterator itr = threatList->begin(); itr != threatList->end(); ++itr)
+                        {
+                            if ((*itr)->getTarget()->GetTypeId() == TYPEID_PLAYER
+                                && (*itr)->getTarget()->getPowerType() == POWER_MANA
+                                && (*itr)->getTarget()->GetPower(POWER_MANA))
+                                unitList.push_back((*itr)->getTarget());
+                        }
+
+                        if (!unitList.empty())
+                        {
+                            std::vector<Unit*>::const_iterator itr = unitList.begin();
+                            advance(itr, rand()%unitList.size());
+                            DoCast(*itr, SPELL_MANA_DETONATION);
+                            DoScriptText(RAND(SAY_SPECIAL_1,SAY_SPECIAL_2,SAY_SPECIAL_3), me);
+                        }
+
+                        events.RepeatEvent(urand(20000,50000));
+                        break;
+                    }
+                    case EVENT_FISSURE:
+                        if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            DoCast(pTarget, SPELL_SHADOW_FISURE);
+                        events.RepeatEvent(urand(10000,45000));
+                        break;
+                    case EVENT_BLAST:
+                        if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, RAID_MODE(1,0), 0, true))
+                            DoCast(pTarget, SPELL_FROST_BLAST);
+                        if (rand()%2)
+                            DoScriptText(SAY_FROST_BLAST, me);
+                        events.RepeatEvent(urand(30000,90000));
+                        break;
+                    default:
+                        events.PopEvent();
+                        break;
                 }
             }
 
-            nGuardiansOfIcecrownCount = 0;
-            uiGuardiansOfIcecrownTimer = 5000;                   //5 seconds for summoning each Guardian of Icecrown in phase 3
+            DoMeleeAttackIfReady();
+        }
+    }
+};
 
-            Phase = 0;
-            nAbomination = 0;
-            nWeaver = 0;
+CreatureAI* GetAI_boss_kelthuzadAI(Creature* pCreature)
+{
+    return new boss_kelthuzadAI (pCreature);
+}
 
-         }
+bool AreaTrigger_at_kelthuzad_center(Player* pPlayer, const AreaTriggerEntry * /*at*/)
+{
+    if (pPlayer->isGameMaster())
+        return false;
 
-        void KilledUnit()
+    ScriptedInstance* pInstance = pPlayer->GetInstanceData();
+    if (!pInstance || pInstance->IsEncounterInProgress() || pInstance->GetBossState(BOSS_KELTHUZAD) == DONE)
+        return false;
+
+    Creature* pKelthuzad = CAST_CRE(Unit::GetUnit(*pPlayer, pInstance->GetData64(DATA_KELTHUZAD)));
+    if (!pKelthuzad)
+        return false;
+
+    boss_kelthuzadAI* pKelthuzadAI = CAST_AI(boss_kelthuzadAI, pKelthuzad->AI());
+    if (!pKelthuzadAI)
+        return false;
+
+    pKelthuzadAI->AttackStart(pPlayer);
+    if (GameObject* trigger = pInstance->instance->GetGameObject(pInstance->GetData64(DATA_KELTHUZAD_TRIGGER)))
+    {
+        if (trigger->getLootState() == GO_READY)
+            trigger->UseDoorOrButton();
+
+        // Note: summon must be done by trigger and not by KT.
+        // Otherwise, they attack immediately as KT is in combat.
+        for (uint8 i = 0; i <= MAX_ABOMINATIONS; ++i)
         {
-            DoScriptText(RAND(SAY_SLAY_1,SAY_SLAY_2), me);
-        }
-
-        void JustDied(Unit* /*Killer*/)
-        {
-            _JustDied();
-            DoScriptText(SAY_DEATH, me);
-
-            std::map<uint64, float>::const_iterator itr;
-            for (itr = chained.begin(); itr != chained.end(); ++itr)
+            if (Creature* sum = trigger->SummonCreature(NPC_ABOMINATION, PosAbominations[i]))
             {
-                if (Player* pPlayer = Unit::GetPlayer(*me, (*itr).first))
-                    pPlayer->SetFloatValue(OBJECT_FIELD_SCALE_X, (*itr).second);
-            }
-            chained.clear();
-        }
-
-        void EnterCombat(Unit* /*who*/)
-        {
-            me->setFaction(uiFaction);
-
-            _EnterCombat();
-            FindGameObjects();
-            for (uint8 i = 0; i <= 3; ++i)
-            {
-                if (GameObject *pPortal = me->GetMap()->GetGameObject(PortalsGUID[i]))
-                    pPortal->ResetDoorOrButton();
-            }
-            DoCast(me, SPELL_KELTHUZAD_CHANNEL, false);
-            DoScriptText(SAY_SUMMON_MINIONS, me);
-            Phase = 1;
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_SELECTABLE);
-            me->SetFloatValue(UNIT_FIELD_COMBATREACH, 10);
-            me->SetFloatValue(UNIT_FIELD_BOUNDINGRADIUS, 10);
-            events.ScheduleEvent(EVENT_TRIGGER, 5000);
-            events.ScheduleEvent(EVENT_WASTE, 15000);
-            events.ScheduleEvent(EVENT_ABOMIN, 30000);
-            events.ScheduleEvent(EVENT_WEAVER, 50000);
-            events.ScheduleEvent(EVENT_PHASE, 228000);
-        }
-
-        void FindGameObjects()
-        {
-            PortalsGUID[0] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL01) : 0;
-            PortalsGUID[1] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL02) : 0;
-            PortalsGUID[2] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL03) : 0;
-            PortalsGUID[3] = instance ? instance->GetData64(DATA_KELTHUZAD_PORTAL04) : 0;
-            KTTriggerGUID = instance ? instance->GetData64(DATA_KELTHUZAD_TRIGGER) : 0;
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateCombatState())
-                return;
-
-            events.Update(diff);
-
-            if (Phase == 1)
-            {
-                while (uint32 eventId = events.GetEvent())
-                {
-                    switch(eventId)
-                    {
-                        case EVENT_WASTE:
-                            DoSummon(NPC_WASTE, Pos[RAND(0,3,6,9)]);
-                            events.RepeatEvent(urand(2000,5000));
-                            break;
-                        case EVENT_ABOMIN:
-                            if (nAbomination < 8)
-                            {
-                                DoSummon(NPC_ABOMINATION, Pos[RAND(1,4,7,10)]);
-                                nAbomination++;
-                                events.RepeatEvent(20000);
-                            }
-                            else
-                                events.PopEvent();
-                            break;
-                        case EVENT_WEAVER:
-                            if (nWeaver < 8)
-                            {
-                                DoSummon(NPC_WEAVER, Pos[RAND(0,3,6,9)]);
-                                nWeaver++;
-                                events.RepeatEvent(25000);
-                            }
-                            else
-                                events.PopEvent();
-                            break;
-                        case EVENT_TRIGGER:
-                            if (GameObject *pKTTrigger = me->GetMap()->GetGameObject(KTTriggerGUID))
-                                pKTTrigger->SetPhaseMask(2, true);
-                            events.PopEvent();
-                            break;
-                        case EVENT_PHASE:
-                            events.Reset();
-                            DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2,SAY_AGGRO_3), me);
-                            spawns.DespawnAll();
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_SELECTABLE);
-                            me->CastStop();
-
-                            DoStartMovement(me->getVictim());
-                            events.ScheduleEvent(EVENT_BOLT, urand(5000,10000));
-                            events.ScheduleEvent(EVENT_NOVA, 15000);
-                            events.ScheduleEvent(EVENT_DETONATE, urand(30000,40000));
-                            events.ScheduleEvent(EVENT_FISSURE, urand(10000,30000));
-                            events.ScheduleEvent(EVENT_BLAST, urand(60000,120000));
-                            if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
-                                events.ScheduleEvent(EVENT_CHAIN, urand(30000,60000));
-                            Phase = 2;
-                            break;
-                        default:
-                            events.PopEvent();
-                            break;
-                    }
-                }
-            }
-            else
-            {
-                //start phase 3 when we are 45% health
-                if (Phase != 3)
-                {
-                    if (HealthBelowPct(45))
-                    {
-                        Phase = 3 ;
-                        DoScriptText(SAY_REQUEST_AID, me);
-                        //here Lich King should respond to KelThuzad but I don't know which Creature to make talk
-                        //so for now just make Kelthuzad says it.
-                        DoScriptText(SAY_ANSWER_REQUEST, me);
-
-                        for (uint8 i = 0; i <= 3; ++i)
-                        {
-                            if (GameObject *pPortal = me->GetMap()->GetGameObject(PortalsGUID[i]))
-                            {
-                                if (pPortal->getLootState() == GO_READY)
-                                    pPortal->UseDoorOrButton();
-                            }
-                        }
-                    }
-                }
-                else if (nGuardiansOfIcecrownCount < RAID_MODE(2,4))
-                {
-                    if (uiGuardiansOfIcecrownTimer <= diff)
-                    {
-                        // TODO : Add missing text
-                        if (Creature* pGuardian = DoSummon(NPC_ICECROWN, Pos[RAND(2,5,8,11)]))
-                            pGuardian->SetFloatValue(UNIT_FIELD_COMBATREACH, 2);
-                        ++nGuardiansOfIcecrownCount;
-                        uiGuardiansOfIcecrownTimer = 5000;
-                    }
-                    else uiGuardiansOfIcecrownTimer -= diff;
-                }
-
-                if (me->hasUnitState(UNIT_STAT_CASTING))
-                    return;
-
-                if (uint32 eventId = events.GetEvent())
-                {
-                    switch(eventId)
-                    {
-                        case EVENT_BOLT:
-                            DoCastVictim(RAID_MODE(SPELL_FROST_BOLT,H_SPELL_FROST_BOLT));
-                            events.RepeatEvent(urand(5000,10000));
-                            break;
-                        case EVENT_NOVA:
-                            DoCastAOE(RAID_MODE(SPELL_FROST_BOLT_AOE,H_SPELL_FROST_BOLT_AOE));
-                            events.RepeatEvent(urand(15000,30000));
-                            break;
-                        case EVENT_CHAIN:
-                        {
-                            uint32 count = urand(1,3);
-                            for (uint8 i = 1; i <= count; i++)
-                            {
-                                Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 200, true);
-                                if (pTarget && !pTarget->isCharmed() && (chained.find(pTarget->GetGUID()) == chained.end()))
-                                {
-                                    DoCast(pTarget, SPELL_CHAINS_OF_KELTHUZAD);
-                                    float scale = pTarget->GetFloatValue(OBJECT_FIELD_SCALE_X);
-                                    chained.insert(std::make_pair(pTarget->GetGUID(), scale));
-                                    pTarget->SetFloatValue(OBJECT_FIELD_SCALE_X, scale * 2);
-                                    events.ScheduleEvent(EVENT_CHAINED_SPELL, 2000); //core has 2000ms to set unit flag charm
-                                }
-                            }
-                            if (!chained.empty())
-                                DoScriptText(RAND(SAY_CHAIN_1,SAY_CHAIN_2), me);
-                            events.RepeatEvent(urand(100000,180000));
-                            break;
-                        }
-                        case EVENT_CHAINED_SPELL:
-                        {
-                            std::map<uint64, float>::iterator itr;
-                            for (itr = chained.begin(); itr != chained.end();)
-                            {
-                                if (Unit* player = Unit::GetPlayer(*me, (*itr).first))
-                                {
-                                    if (!player->isCharmed())
-                                    {
-                                        player->SetFloatValue(OBJECT_FIELD_SCALE_X, (*itr).second);
-                                        std::map<uint64, float>::iterator next = itr;
-                                        ++next;
-                                        chained.erase(itr);
-                                        itr = next;
-                                        continue;
-                                    }
-
-                                    if (Unit *pTarget = SelectTarget(SELECT_TARGET_TOPAGGRO, 0, NotCharmedTargetSelector()))
-                                    {
-                                        switch(player->getClass())
-                                        {
-                                            case CLASS_DRUID:
-                                                if (urand(0,1))
-                                                    player->CastSpell(pTarget, SPELL_MOONFIRE, false);
-                                                else
-                                                    player->CastSpell(me, SPELL_LIFEBLOOM, false);
-                                                break;
-                                            case CLASS_HUNTER:
-                                                player->CastSpell(pTarget, RAND(SPELL_MULTI_SHOT, SPELL_VOLLEY), false);
-                                                break;
-                                            case CLASS_MAGE:
-                                                player->CastSpell(pTarget, RAND(SPELL_FROST_FIREBOLT, SPELL_ARCANE_MISSILES), false);
-                                                break;
-                                            case CLASS_WARLOCK:
-                                                player->CastSpell(pTarget, RAND(SPELL_CURSE_OF_AGONY, SPELL_SHADOW_BOLT), true);
-                                                break;
-                                            case CLASS_WARRIOR:
-                                                player->CastSpell(pTarget, RAND(SPELL_BLADESTORM, SPELL_CLEAVE), false);
-                                                break;
-                                            case CLASS_PALADIN:
-                                                if (urand(0,1))
-                                                    player->CastSpell(pTarget, SPELL_HAMMER_OF_JUSTICE, false);
-                                                else
-                                                    player->CastSpell(me, SPELL_HOLY_SHOCK, false);
-                                                break;
-                                            case CLASS_PRIEST:
-                                                if (urand(0,1))
-                                                    player->CastSpell(pTarget, SPELL_VAMPIRIC_TOUCH, false);
-                                                else
-                                                    player->CastSpell(me, SPELL_RENEW, false);
-                                                break;
-                                            case CLASS_SHAMAN:
-                                                if (urand(0,1))
-                                                    player->CastSpell(pTarget, SPELL_EARTH_SHOCK, false);
-                                                else
-                                                    player->CastSpell(me, SPELL_HEALING_WAVE, false);
-                                                break;
-                                            case CLASS_ROGUE:
-                                                player->CastSpell(pTarget, RAND(SPELL_HEMORRHAGE, SPELL_MUTILATE), false);
-                                                break;
-                                            case CLASS_DEATH_KNIGHT:
-                                                if (urand(0,1))
-                                                    player->CastSpell(pTarget, SPELL_PLAGUE_STRIKE, true);
-                                                else
-                                                    player->CastSpell(pTarget, SPELL_HOWLING_BLAST, true);
-                                                break;
-                                        }
-                                    }
-                                }
-                                ++itr;
-                            }
-
-                            if (chained.empty())
-                                events.PopEvent();
-                            else
-                                events.RepeatEvent(5000);
-
-                            break;
-                        }
-                        case EVENT_DETONATE:
-                        {
-                            std::vector<Unit*> unitList;
-                            std::list<HostileReference*> *threatList = &me->getThreatManager().getThreatList();
-                            for (std::list<HostileReference*>::const_iterator itr = threatList->begin(); itr != threatList->end(); ++itr)
-                            {
-                                if ((*itr)->getTarget()->GetTypeId() == TYPEID_PLAYER
-                                    && (*itr)->getTarget()->getPowerType() == POWER_MANA
-                                    && (*itr)->getTarget()->GetPower(POWER_MANA))
-                                    unitList.push_back((*itr)->getTarget());
-                            }
-
-                            if (!unitList.empty())
-                            {
-                                std::vector<Unit*>::const_iterator itr = unitList.begin();
-                                advance(itr, rand()%unitList.size());
-                                DoCast(*itr, SPELL_MANA_DETONATION);
-                                DoScriptText(RAND(SAY_SPECIAL_1,SAY_SPECIAL_2,SAY_SPECIAL_3), me);
-                            }
-
-                            events.RepeatEvent(urand(20000,50000));
-                            break;
-                        }
-                        case EVENT_FISSURE:
-                            if (Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
-                                DoCast(pTarget, SPELL_SHADOW_FISURE);
-                            events.RepeatEvent(urand(10000,45000));
-                            break;
-                        case EVENT_BLAST:
-                            if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, RAID_MODE(1,0), 0, true))
-                                DoCast(pTarget, SPELL_FROST_BLAST);
-                            if (rand()%2)
-                                DoScriptText(SAY_FROST_BLAST, me);
-                            events.RepeatEvent(urand(30000,90000));
-                            break;
-                        default:
-                            events.PopEvent();
-                            break;
-                    }
-                }
-
-                DoMeleeAttackIfReady();
+                pKelthuzadAI->spawns.Summon(sum);
+                sum->GetMotionMaster()->MoveRandom(9.0f);
+                sum->SetReactState(REACT_DEFENSIVE);
             }
         }
-    };
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new boss_kelthuzadAI (pCreature);
+        for (uint8 i = 0; i <= MAX_WASTES; ++i)
+        {
+            if (Creature* sum = trigger->SummonCreature(NPC_WASTE, PosWastes[i]))
+            {
+                pKelthuzadAI->spawns.Summon(sum);
+                sum->GetMotionMaster()->MoveRandom(5.0f);
+                sum->SetReactState(REACT_DEFENSIVE);
+            }
+        }
+        for (uint8 i = 0; i <= MAX_WEAVERS; ++i)
+        {
+            if (Creature* sum = trigger->SummonCreature(NPC_WEAVER, PosWeavers[i]))
+            {
+                pKelthuzadAI->spawns.Summon(sum);
+                sum->GetMotionMaster()->MoveRandom(9.0f);
+                sum->SetReactState(REACT_DEFENSIVE);
+            }
+        }
     }
 
-};
-
-class at_kelthuzad_center : public AreaTriggerScript
-{
-public:
-    at_kelthuzad_center() : AreaTriggerScript("at_kelthuzad_center") { }
-
-    bool OnTrigger(Player* pPlayer, const AreaTriggerEntry * /*at*/)
-    {
-        if (pPlayer->isGameMaster())
-            return false;
-
-        InstanceScript* pInstance = pPlayer->GetInstanceScript();
-        if (!pInstance || pInstance->IsEncounterInProgress() || pInstance->GetBossState(BOSS_KELTHUZAD) == DONE)
-            return false;
-
-        Creature* pKelthuzad = CAST_CRE(Unit::GetUnit(*pPlayer, pInstance->GetData64(DATA_KELTHUZAD)));
-        if (!pKelthuzad)
-            return false;
-
-        boss_kelthuzad::boss_kelthuzadAI* pKelthuzadAI = CAST_AI(boss_kelthuzad::boss_kelthuzadAI, pKelthuzad->AI());
-        if (!pKelthuzadAI)
-            return false;
-
-        pKelthuzadAI->AttackStart(pPlayer);
-        if (GameObject* trigger = pInstance->instance->GetGameObject(pInstance->GetData64(DATA_KELTHUZAD_TRIGGER)))
-        {
-            if (trigger->getLootState() == GO_READY)
-                trigger->UseDoorOrButton();
-
-            // Note: summon must be done by trigger and not by KT.
-            // Otherwise, they attack immediately as KT is in combat.
-            for (uint8 i = 0; i <= MAX_ABOMINATIONS; ++i)
-            {
-                if (Creature* sum = trigger->SummonCreature(NPC_ABOMINATION, PosAbominations[i]))
-                {
-                    pKelthuzadAI->spawns.Summon(sum);
-                    sum->GetMotionMaster()->MoveRandom(9.0f);
-                    sum->SetReactState(REACT_DEFENSIVE);
-                }
-            }
-            for (uint8 i = 0; i <= MAX_WASTES; ++i)
-            {
-                if (Creature* sum = trigger->SummonCreature(NPC_WASTE, PosWastes[i]))
-                {
-                    pKelthuzadAI->spawns.Summon(sum);
-                    sum->GetMotionMaster()->MoveRandom(5.0f);
-                    sum->SetReactState(REACT_DEFENSIVE);
-                }
-            }
-            for (uint8 i = 0; i <= MAX_WEAVERS; ++i)
-            {
-                if (Creature* sum = trigger->SummonCreature(NPC_WEAVER, PosWeavers[i]))
-                {
-                    pKelthuzadAI->spawns.Summon(sum);
-                    sum->GetMotionMaster()->MoveRandom(9.0f);
-                    sum->SetReactState(REACT_DEFENSIVE);
-                }
-            }
-        }
-
-        return true;
-    }
-
-};
+    return true;
+}
 
 void AddSC_boss_kelthuzad()
 {
-    new boss_kelthuzad();
-    new at_kelthuzad_center();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_kelthuzad";
+    newscript->GetAI = &GetAI_boss_kelthuzadAI;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "at_kelthuzad_center";
+    newscript->pAreaTrigger = &AreaTrigger_at_kelthuzad_center;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_loatheb.cpp b/src/server/scripts/Northrend/Naxxramas/boss_loatheb.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_loatheb.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_loatheb.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 #include "ScriptPCH.h"
 #include "naxxramas.h"
 
@@ -25,8 +25,7 @@
     SPELL_DEATHBLOOM                                       = 29865,
     H_SPELL_DEATHBLOOM                                     = 55053,
     SPELL_INEVITABLE_DOOM                                  = 29204,
-    H_SPELL_INEVITABLE_DOOM                                = 55052,
-    SPELL_BERSERK                                          = 27680
+    H_SPELL_INEVITABLE_DOOM                                = 55052
 };
 
 enum Events
@@ -35,105 +34,91 @@
     EVENT_AURA,
     EVENT_BLOOM,
     EVENT_DOOM,
-    EVENT_BERSERK
 };
 
-class boss_loatheb : public CreatureScript
+struct boss_loathebAI : public BossAI
 {
-public:
-    boss_loatheb() : CreatureScript("boss_loatheb") { }
+    boss_loathebAI(Creature *c) : BossAI(c, BOSS_LOATHEB) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    void EnterCombat(Unit * /*who*/)
     {
-        return new boss_loathebAI (pCreature);
+        _EnterCombat();
+        events.ScheduleEvent(EVENT_AURA, 10000);
+        events.ScheduleEvent(EVENT_BLOOM, 5000);
+        events.ScheduleEvent(EVENT_DOOM, 120000);
     }
 
-    struct boss_loathebAI : public BossAI
+    void UpdateAI(const uint32 diff)
     {
-        boss_loathebAI(Creature *c) : BossAI(c, BOSS_LOATHEB) {}
+        if (!UpdateVictim())
+            return;
 
-        void EnterCombat(Unit * /*who*/)
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            _EnterCombat();
-            events.ScheduleEvent(EVENT_AURA, 10000);
-            events.ScheduleEvent(EVENT_BLOOM, 5000);
-            events.ScheduleEvent(EVENT_DOOM, 120000);
-            events.ScheduleEvent(EVENT_BERSERK, 12*60000);
+            switch(eventId)
+            {
+                case EVENT_AURA:
+                    DoCastAOE(SPELL_NECROTIC_AURA);
+                    events.ScheduleEvent(EVENT_AURA, 20000);
+                    break;
+                case EVENT_BLOOM:
+                    // TODO : Add missing text
+                    DoCastAOE(SPELL_SUMMON_SPORE, true);
+                    DoCastAOE(RAID_MODE(SPELL_DEATHBLOOM,H_SPELL_DEATHBLOOM));
+                    events.ScheduleEvent(EVENT_BLOOM, 30000);
+                    break;
+                case EVENT_DOOM:
+                    DoCastAOE(RAID_MODE(SPELL_INEVITABLE_DOOM,H_SPELL_INEVITABLE_DOOM));
+                    events.ScheduleEvent(EVENT_DOOM, events.GetTimer() < 5*60000 ? 30000 : 15000);
+                    break;
+            }
         }
 
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_AURA:
-                        DoCastAOE(SPELL_NECROTIC_AURA);
-                        events.ScheduleEvent(EVENT_AURA, 20000);
-                        break;
-                    case EVENT_BLOOM:
-                        // TODO : Add missing text
-                        DoCastAOE(SPELL_SUMMON_SPORE, true);
-                        DoCastAOE(RAID_MODE(SPELL_DEATHBLOOM,H_SPELL_DEATHBLOOM));
-                        events.ScheduleEvent(EVENT_BLOOM, 30000);
-                        break;
-                    case EVENT_DOOM:
-                        DoCastAOE(RAID_MODE(SPELL_INEVITABLE_DOOM,H_SPELL_INEVITABLE_DOOM));
-                        events.ScheduleEvent(EVENT_DOOM, events.GetTimer() < 5*60000 ? 30000 : 15000);
-                        break;
-                    case EVENT_BERSERK:
-                        if(getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
-                        {
-                            if(!me->HasAura(SPELL_BERSERK))
-                                DoCast(me,SPELL_BERSERK,true);
-                        }
-                         events.ScheduleEvent(EVENT_BERSERK, 60000);
-                        break;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_boss_loatheb(Creature* pCreature)
+{
+    return new boss_loathebAI (pCreature);
+}
 
 enum SporeSpells
 {
     SPELL_FUNGAL_CREEP                                     = 29232
 };
 
-class mob_loatheb_spore : public CreatureScript
+struct mob_loatheb_sporeAI : public ScriptedAI
 {
-public:
-    mob_loatheb_spore() : CreatureScript("mob_loatheb_spore") { }
+    mob_loatheb_sporeAI(Creature *c) : ScriptedAI(c) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    void JustDied(Unit* killer)
     {
-        return new mob_loatheb_sporeAI (pCreature);
+        DoCast(killer, SPELL_FUNGAL_CREEP);
     }
-
-    struct mob_loatheb_sporeAI : public ScriptedAI
-    {
-        mob_loatheb_sporeAI(Creature *c) : ScriptedAI(c) {}
-
-        void JustDied(Unit* killer)
-        {
-            DoCastAOE(SPELL_FUNGAL_CREEP, true); //A Little bit hacky ... but it works now (without triggered no cast on death)
-        }
-    };
-
 };
 
+CreatureAI* GetAI_mob_loatheb_spore(Creature* pCreature)
+{
+    return new mob_loatheb_sporeAI (pCreature);
+}
 
 void AddSC_boss_loatheb()
 {
-    new boss_loatheb();
-    new mob_loatheb_spore();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_loatheb";
+    newscript->GetAI = &GetAI_boss_loatheb;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_loatheb_spore";
+    newscript->GetAI = &GetAI_mob_loatheb_spore;
+    newscript->RegisterSelf();
+
+    // Fungal Creep
+    //GetAISpellInfo(29232)->condition = AICOND_DIE;
 }
+
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_maexxna.cpp b/src/server/scripts/Northrend/Naxxramas/boss_maexxna.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_maexxna.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_maexxna.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -40,9 +40,9 @@
 #define MAX_POS_WRAP            3
 const Position PosWrap[MAX_POS_WRAP] =
 {
-    {3546.796f, -3869.082f, 296.450f, 0.0f},
-    {3531.271f, -3847.424f, 299.450f, 0.0f},
-    {3497.067f, -3843.384f, 302.384f, 0.0f},
+    {3546.796, -3869.082, 296.450, 0.0},
+    {3531.271, -3847.424, 299.450, 0.0},
+    {3497.067, -3843.384, 302.384, 0.0},
 };
 
 enum Events
@@ -56,144 +56,130 @@
     EVENT_FRENZY,
 };
 
-class boss_maexxna : public CreatureScript
+struct boss_maexxnaAI : public BossAI
 {
-public:
-    boss_maexxna() : CreatureScript("boss_maexxna") { }
+    boss_maexxnaAI(Creature *c) : BossAI(c, BOSS_MAEXXNA) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    bool enraged;
+
+    void EnterCombat(Unit * /*who*/)
     {
-        return new boss_maexxnaAI (pCreature);
+        _EnterCombat();
+        enraged = false;
+        events.ScheduleEvent(EVENT_WRAP, 20000);
+        events.ScheduleEvent(EVENT_SPRAY, 40000);
+        events.ScheduleEvent(EVENT_SHOCK, urand(5000,10000));
+        events.ScheduleEvent(EVENT_POISON, urand(10000,15000));
+        events.ScheduleEvent(EVENT_SUMMON, 30000);
     }
 
-    struct boss_maexxnaAI : public BossAI
+    void UpdateAI(const uint32 diff)
     {
-        boss_maexxnaAI(Creature *c) : BossAI(c, BOSS_MAEXXNA) {}
+        if (!UpdateVictim() || !CheckInRoom())
+            return;
 
-        bool enraged;
-
-        void EnterCombat(Unit * /*who*/)
+        if (!enraged && HealthBelowPct(30))
         {
-            _EnterCombat();
-            enraged = false;
-            events.ScheduleEvent(EVENT_WRAP, 20000);
-            events.ScheduleEvent(EVENT_SPRAY, 40000);
-            events.ScheduleEvent(EVENT_SHOCK, urand(5000,10000));
-            events.ScheduleEvent(EVENT_POISON, urand(10000,15000));
-            events.ScheduleEvent(EVENT_SUMMON, 30000);
+            enraged = true;
+            events.ScheduleEvent(EVENT_FRENZY, 0); // will be cast immediately
         }
 
-        void UpdateAI(const uint32 diff)
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            if (!UpdateVictim() || !CheckInRoom())
-                return;
+            switch(eventId)
+            {
+                case EVENT_WRAP:
+                    // TODO : Add missing text
+                    for (uint8 i = 0; i < RAID_MODE(1,2); ++i)
+                    {
+                        if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 0, true, -SPELL_WEB_WRAP))
+                        {
+                            pTarget->RemoveAura(RAID_MODE(SPELL_WEB_SPRAY_10,SPELL_WEB_SPRAY_25));
+                            uint8 pos = rand()%MAX_POS_WRAP;
+                            pTarget->GetMotionMaster()->MoveJump(PosWrap[pos].GetPositionX(), PosWrap[pos].GetPositionY(), PosWrap[pos].GetPositionZ(), 20, 20);
+                            if (Creature *wrap = DoSummon(MOB_WEB_WRAP, PosWrap[pos], 0, TEMPSUMMON_CORPSE_DESPAWN))
+                                wrap->AI()->SetGUID(pTarget->GetGUID());
+                        }
+                    }
+                    events.ScheduleEvent(EVENT_WRAP, 40000);
+                    break;
+                case EVENT_SPRAY:
+                    DoCastAOE(RAID_MODE(SPELL_WEB_SPRAY_10,SPELL_WEB_SPRAY_25));
+                    events.ScheduleEvent(EVENT_SPRAY, 40000);
+                    break;
+                case EVENT_SHOCK:
+                    DoCastAOE(RAID_MODE(SPELL_POISON_SHOCK_10,SPELL_POISON_SHOCK_25));
+                    events.ScheduleEvent(EVENT_SHOCK, urand(10000,20000));
+                    break;
+                case EVENT_POISON:
+                    DoCast(me->getVictim(), RAID_MODE(SPELL_NECROTIC_POISON_10,SPELL_NECROTIC_POISON_25));
+                    events.ScheduleEvent(EVENT_POISON, urand(10000, 20000));
+                    break;
+                case EVENT_FRENZY:
+                    DoCast(me, RAID_MODE(SPELL_FRENZY_10,SPELL_FRENZY_25), true);
+                    events.ScheduleEvent(EVENT_FRENZY, 600000);
+                    break;
+                case EVENT_SUMMON:
+                    // TODO : Add missing text
+                    uint8 amount = urand(8,10);
+                    for (uint8 i = 0; i < amount; ++i)
+                        DoSummon(MOB_SPIDERLING, me, 0, TEMPSUMMON_CORPSE_DESPAWN);
+                    events.ScheduleEvent(EVENT_SUMMON, 40000);
+                    break;
+            }
+        }
 
-            if (!enraged && HealthBelowPct(30))
-            {
-                enraged = true;
-                events.ScheduleEvent(EVENT_FRENZY, 0); // will be cast immediately
-            }
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_WRAP:
-                        // TODO : Add missing text
-                        for (uint8 i = 0; i < RAID_MODE(1,2); ++i)
-                        {
-                            if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 1, 0, true, -SPELL_WEB_WRAP))
-                            {
-                                pTarget->RemoveAura(RAID_MODE(SPELL_WEB_SPRAY_10,SPELL_WEB_SPRAY_25));
-                                uint8 pos = rand()%MAX_POS_WRAP;
-                                pTarget->GetMotionMaster()->MoveJump(PosWrap[pos].GetPositionX(), PosWrap[pos].GetPositionY(), PosWrap[pos].GetPositionZ(), 20, 20);
-                                if (Creature *wrap = DoSummon(MOB_WEB_WRAP, PosWrap[pos], 0, TEMPSUMMON_CORPSE_DESPAWN))
-                                    wrap->AI()->SetGUID(pTarget->GetGUID());
-                            }
-                        }
-                        events.ScheduleEvent(EVENT_WRAP, 40000);
-                        break;
-                    case EVENT_SPRAY:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            DoCastAOE(RAID_MODE(SPELL_WEB_SPRAY_10,SPELL_WEB_SPRAY_25));
-                            events.ScheduleEvent(EVENT_SPRAY, 40000);
-                        }
-                        break;
-                    case EVENT_SHOCK:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            DoCastAOE(RAID_MODE(SPELL_POISON_SHOCK_10,SPELL_POISON_SHOCK_25));
-                            events.ScheduleEvent(EVENT_SHOCK, urand(10000,20000));
-                        }
-                        break;
-                    case EVENT_POISON:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            DoCast(me->getVictim(), RAID_MODE(SPELL_NECROTIC_POISON_10,SPELL_NECROTIC_POISON_25));
-                            events.ScheduleEvent(EVENT_POISON, urand(10000, 20000));
-                        }
-                        break;
-                    case EVENT_FRENZY:
-                        DoCast(me, RAID_MODE(SPELL_FRENZY_10,SPELL_FRENZY_25), true);
-                        events.ScheduleEvent(EVENT_FRENZY, 600000);
-                        break;
-                    case EVENT_SUMMON:
-                        // TODO : Add missing text
-                        uint8 amount = urand(8,10);
-                        for (uint8 i = 0; i < amount; ++i)
-                            DoSummon(MOB_SPIDERLING, me, 0, TEMPSUMMON_CORPSE_DESPAWN);
-                        events.ScheduleEvent(EVENT_SUMMON, 40000);
-                        break;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
-class mob_webwrap : public CreatureScript
+struct mob_webwrapAI : public NullCreatureAI
 {
-public:
-    mob_webwrap() : CreatureScript("mob_webwrap") { }
+    mob_webwrapAI(Creature *c) : NullCreatureAI(c), victimGUID(0) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    uint64 victimGUID;
+
+    void SetGUID(const uint64 &guid, int32 /*param*/)
     {
-        return new mob_webwrapAI (pCreature);
+        victimGUID = guid;
+        if (me->m_spells[0] && victimGUID)
+            if (Unit *victim = Unit::GetUnit(*me, victimGUID))
+                victim->CastSpell(victim, me->m_spells[0], true, NULL, NULL, me->GetGUID());
     }
 
-    struct mob_webwrapAI : public NullCreatureAI
+    void JustDied(Unit * /*killer*/)
     {
-        mob_webwrapAI(Creature *c) : NullCreatureAI(c), victimGUID(0) {}
-
-        uint64 victimGUID;
-
-        void SetGUID(const uint64 &guid, int32 /*param*/)
-        {
-            victimGUID = guid;
-            if (me->m_spells[0] && victimGUID)
-                if (Unit *victim = Unit::GetUnit(*me, victimGUID))
-                    victim->CastSpell(victim, me->m_spells[0], true, NULL, NULL, me->GetGUID());
-        }
-
-        void JustDied(Unit * /*killer*/)
-        {
-            if (me->m_spells[0] && victimGUID)
-                if (Unit *victim = Unit::GetUnit(*me, victimGUID))
-                    victim->RemoveAurasDueToSpell(me->m_spells[0], me->GetGUID());
-        }
-    };
-
+        if (me->m_spells[0] && victimGUID)
+            if (Unit *victim = Unit::GetUnit(*me, victimGUID))
+                victim->RemoveAurasDueToSpell(me->m_spells[0], me->GetGUID());
+    }
 };
 
+CreatureAI* GetAI_boss_maexxna(Creature* pCreature)
+{
+    return new boss_maexxnaAI (pCreature);
+}
 
+CreatureAI* GetAI_mob_webwrap(Creature* pCreature)
+{
+    return new mob_webwrapAI (pCreature);
+}
 
 void AddSC_boss_maexxna()
 {
-    new boss_maexxna();
-    new mob_webwrap();
+    Script *newscript;
+
+    newscript = new Script;
+    newscript->Name = "boss_maexxna";
+    newscript->GetAI = &GetAI_boss_maexxna;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_webwrap";
+    newscript->GetAI = &GetAI_mob_webwrap;
+    newscript->RegisterSelf();
+
 }
+
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_noth.cpp b/src/server/scripts/Northrend/Naxxramas/boss_noth.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_noth.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_noth.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -29,27 +29,26 @@
 #define SPELL_BLINK                     RAND(29208,29209,29210,29211)
 #define SPELL_CRIPPLE                   RAID_MODE(29212,54814)
 #define SPELL_TELEPORT                  29216
-#define SPELL_BERSERK                   27680
 
 #define MOB_WARRIOR         16984
 #define MOB_CHAMPION        16983
 #define MOB_GUARDIAN        16981
 
 // Teleport position of Noth on his balcony
-#define TELE_X 2631.370f
-#define TELE_Y -3529.680f
-#define TELE_Z 274.040f
-#define TELE_O 6.277f
+#define TELE_X 2631.370
+#define TELE_Y -3529.680
+#define TELE_Z 274.040
+#define TELE_O 6.277
 
 #define MAX_SUMMON_POS 5
 
 const float SummonPos[MAX_SUMMON_POS][4] =
 {
-    {2728.12f, -3544.43f, 261.91f, 6.04f},
-    {2729.05f, -3544.47f, 261.91f, 5.58f},
-    {2728.24f, -3465.08f, 264.20f, 3.56f},
-    {2704.11f, -3456.81f, 265.53f, 4.51f},
-    {2663.56f, -3464.43f, 262.66f, 5.20f},
+    {2728.12, -3544.43, 261.91, 6.04},
+    {2729.05, -3544.47, 261.91, 5.58},
+    {2728.24, -3465.08, 264.20, 3.56},
+    {2704.11, -3456.81, 265.53, 4.51},
+    {2663.56, -3464.43, 262.66, 5.20},
 };
 
 enum Events
@@ -64,169 +63,151 @@
     EVENT_GROUND,
 };
 
-class boss_noth : public CreatureScript
+struct boss_nothAI : public BossAI
 {
-public:
-    boss_noth() : CreatureScript("boss_noth") { }
+    boss_nothAI(Creature *c) : BossAI(c, BOSS_NOTH) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    uint32 waveCount, balconyCount;
+
+    void Reset()
     {
-        return new boss_nothAI (pCreature);
+        me->SetReactState(REACT_AGGRESSIVE);
+        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        _Reset();
     }
 
-    struct boss_nothAI : public BossAI
+    void EnterCombat(Unit * /*who*/)
     {
-        boss_nothAI(Creature *c) : BossAI(c, BOSS_NOTH) {}
+        _EnterCombat();
+        DoScriptText(SAY_AGGRO, me);
+        balconyCount = 0;
+        EnterPhaseGround();
+    }
 
-        uint32 waveCount, balconyCount;
+    void EnterPhaseGround()
+    {
+        me->SetReactState(REACT_AGGRESSIVE);
+        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        DoZoneInCombat();
+        if (me->getThreatManager().isThreatListEmpty())
+            EnterEvadeMode();
+        else
+        {
+            events.ScheduleEvent(EVENT_BALCONY, 110000);
+            events.ScheduleEvent(EVENT_CURSE, 10000+rand()%15000);
+            events.ScheduleEvent(EVENT_WARRIOR, 30000);
+            if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
+                events.ScheduleEvent(EVENT_BLINK, 20000 + rand()%20000);
+        }
+    }
 
-        void Reset()
+    void KilledUnit(Unit* /*victim*/)
+    {
+        if (!(rand()%5))
+            DoScriptText(SAY_SLAY, me);
+    }
+
+    void JustSummoned(Creature *summon)
+    {
+        summons.Summon(summon);
+        summon->setActive(true);
+        summon->AI()->DoZoneInCombat();
+    }
+
+    void JustDied(Unit* /*Killer*/)
+    {
+        _JustDied();
+        DoScriptText(SAY_DEATH, me);
+    }
+
+    void SummonUndead(uint32 entry, uint32 num)
+    {
+        for (uint32 i = 0; i < num; ++i)
         {
-            me->SetReactState(REACT_AGGRESSIVE);
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-            _Reset();
+            uint32 pos = rand()%MAX_SUMMON_POS;
+            me->SummonCreature(entry, SummonPos[pos][0], SummonPos[pos][1], SummonPos[pos][2],
+                SummonPos[pos][3], TEMPSUMMON_CORPSE_DESPAWN, 60000);
         }
+    }
 
-        void EnterCombat(Unit * /*who*/)
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateCombatState() || !CheckInRoom())
+            return;
+
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            _EnterCombat();
-            DoScriptText(SAY_AGGRO, me);
-            balconyCount = 0;
-            EnterPhaseGround();
-        }
-
-        void EnterPhaseGround()
-        {
-            me->SetReactState(REACT_AGGRESSIVE);
-            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-            DoZoneInCombat();
-            if (me->getThreatManager().isThreatListEmpty())
-                EnterEvadeMode();
-            else
+            switch(eventId)
             {
-                me->getThreatManager().resetAllAggro();
-                events.ScheduleEvent(EVENT_BALCONY, 110000);
-                events.ScheduleEvent(EVENT_CURSE, 10000+rand()%15000);
-                events.ScheduleEvent(EVENT_WARRIOR, 30000);
-                if (getDifficulty() == RAID_DIFFICULTY_25MAN_NORMAL)
-                    events.ScheduleEvent(EVENT_BLINK, 20000 + rand()%20000);
+                case EVENT_CURSE:
+                    DoCastAOE(SPELL_CURSE_PLAGUEBRINGER);
+                    events.ScheduleEvent(EVENT_CURSE, 50000 + rand()%10000);
+                    return;
+                case EVENT_WARRIOR:
+                    DoScriptText(SAY_SUMMON, me);
+                    SummonUndead(MOB_WARRIOR, RAID_MODE(2,3));
+                    events.ScheduleEvent(EVENT_WARRIOR, 30000);
+                    return;
+                case EVENT_BLINK:
+                    DoCastAOE(SPELL_CRIPPLE, true);
+                    DoCastAOE(SPELL_BLINK);
+                    DoResetThreat();
+                    events.ScheduleEvent(EVENT_BLINK, 40000);
+                    return;
+                case EVENT_BALCONY:
+                    me->SetReactState(REACT_PASSIVE);
+                    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    me->AttackStop();
+                    me->RemoveAllAuras();
+                    me->NearTeleportTo(TELE_X, TELE_Y, TELE_Z, TELE_O);
+                    events.Reset();
+                    events.ScheduleEvent(EVENT_WAVE, 2000 + rand()%3000);
+                    waveCount = 0;
+                    return;
+                case EVENT_WAVE:
+                    DoScriptText(SAY_SUMMON, me);
+                    switch(balconyCount)
+                    {
+                        case 0: SummonUndead(MOB_CHAMPION, RAID_MODE(2,4)); break;
+                        case 1: SummonUndead(MOB_CHAMPION, RAID_MODE(1,2));
+                                SummonUndead(MOB_GUARDIAN, RAID_MODE(1,2)); break;
+                        case 2: SummonUndead(MOB_GUARDIAN, RAID_MODE(2,4)); break;
+                        default:SummonUndead(MOB_CHAMPION, RAID_MODE(5,10));
+                                SummonUndead(MOB_GUARDIAN, RAID_MODE(5,10));break;
+                    }
+                    ++waveCount;
+                    events.ScheduleEvent(waveCount < 2 ? EVENT_WAVE : EVENT_GROUND, 30000 + rand()%15000);
+                    return;
+                case EVENT_GROUND:
+                {
+                    ++balconyCount;
+                    float x, y, z, o;
+                    me->GetHomePosition(x, y, z, o);
+                    me->NearTeleportTo(x, y, z, o);
+                    events.ScheduleEvent(EVENT_BALCONY, 110000);
+                    EnterPhaseGround();
+                    return;
+                }
             }
         }
 
-        void KilledUnit(Unit* /*victim*/)
-        {
-            if (!(rand()%5))
-                DoScriptText(SAY_SLAY, me);
-        }
-
-        void JustSummoned(Creature *summon)
-        {
-            summons.Summon(summon);
-            summon->setActive(true);
-            summon->AI()->DoZoneInCombat();
-        }
-
-        void JustDied(Unit* /*Killer*/)
-        {
-            _JustDied();
-            DoScriptText(SAY_DEATH, me);
-        }
-
-        void SummonUndead(uint32 entry, uint32 num)
-        {
-            for (uint32 i = 0; i < num; ++i)
-            {
-                uint32 pos = RAID_MODE(RAND(2,3), rand()%MAX_SUMMON_POS);
-                me->SummonCreature(entry, SummonPos[pos][0], SummonPos[pos][1], SummonPos[pos][2],
-                    SummonPos[pos][3], TEMPSUMMON_CORPSE_DESPAWN, 60000);
-            }
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateCombatState() || !CheckInRoom())
-                return;
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_CURSE:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            DoCastAOE(SPELL_CURSE_PLAGUEBRINGER);
-                            events.ScheduleEvent(EVENT_CURSE, 50000 + rand()%10000);
-                        }
-                        return;
-                    case EVENT_WARRIOR:
-                        DoScriptText(SAY_SUMMON, me);
-                        SummonUndead(MOB_WARRIOR, RAID_MODE(2,3));
-                        events.ScheduleEvent(EVENT_WARRIOR, 30000);
-                        return;
-                    case EVENT_BLINK:
-                        if(!me->IsNonMeleeSpellCasted(false))
-                        {
-                            DoCastAOE(SPELL_CRIPPLE, true);
-                            DoCastAOE(SPELL_BLINK);
-                            DoResetThreat();
-                            events.ScheduleEvent(EVENT_BLINK, 20000);
-                        }
-                        return;
-                    case EVENT_BALCONY:
-                        me->SetReactState(REACT_PASSIVE);
-                        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-                        me->AttackStop();
-                        me->RemoveAllAuras();
-                        me->NearTeleportTo(TELE_X, TELE_Y, TELE_Z, TELE_O);
-                        me->getThreatManager().resetAllAggro();
-                        events.Reset();
-                        events.ScheduleEvent(EVENT_WAVE, 10000);
-                        waveCount = 0;
-                        return;
-                    case EVENT_WAVE:
-                        DoScriptText(SAY_SUMMON, me);
-                        switch(balconyCount)
-                        {
-                            case 0: SummonUndead(MOB_CHAMPION, RAID_MODE(2,4)); break;
-                            case 1: SummonUndead(MOB_CHAMPION, RAID_MODE(1,2));
-                                    SummonUndead(MOB_GUARDIAN, RAID_MODE(1,2)); break;
-                            case 2: SummonUndead(MOB_GUARDIAN, RAID_MODE(2,4)); break;
-                            default:SummonUndead(MOB_CHAMPION, RAID_MODE(5,10));
-                                    SummonUndead(MOB_GUARDIAN, RAID_MODE(5,10));break;
-                        }
-                        ++waveCount;
-                        events.ScheduleEvent(waveCount < 2 ? EVENT_WAVE : EVENT_GROUND, 30000);
-                        return;
-                    case EVENT_GROUND:
-                    {
-                        ++balconyCount;
-                        float x, y, z, o;
-                        me->GetHomePosition(x, y, z, o);
-                        me->NearTeleportTo(x, y, z, o);
-                        events.ScheduleEvent(EVENT_BALCONY, 110000);
-                        EnterPhaseGround();
-                        return;
-                    }
-                }
-            }
-
-            if(balconyCount > 3)
-            {
-                if(!me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE) && !me->HasAura(SPELL_BERSERK))
-                    DoCast(me,SPELL_BERSERK,true);
-            }
-
-            if (me->HasReactState(REACT_AGGRESSIVE))
-                DoMeleeAttackIfReady();
-        }
-    };
-
+        if (me->HasReactState(REACT_AGGRESSIVE))
+            DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_boss_noth(Creature* pCreature)
+{
+    return new boss_nothAI (pCreature);
+}
 
 void AddSC_boss_noth()
 {
-    new boss_noth();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_noth";
+    newscript->GetAI = &GetAI_boss_noth;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_patchwerk.cpp b/src/server/scripts/Northrend/Naxxramas/boss_patchwerk.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_patchwerk.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_patchwerk.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -45,195 +45,116 @@
     EVENT_SLIME
 };
 
-enum Achievements
+enum
 {
     ACHIEV_MAKE_QUICK_WERK_OF_HIM_STARTING_EVENT  = 10286,
 };
 
-#define ACHIEVEMENT_MAKE_QUICK_WERK_OF_HIM  RAID_MODE(1856, 1857)
-#define MAX_ENCOUNTER_TIME                    3 * 60 * 1000
+struct boss_patchwerkAI : public BossAI
+{
+    boss_patchwerkAI(Creature *c) : BossAI(c, BOSS_PATCHWERK) {}
 
-class boss_patchwerk : public CreatureScript
-{
-public:
-    boss_patchwerk() : CreatureScript("boss_patchwerk") { }
+    bool Enraged;
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    void Reset()
     {
-        return new boss_patchwerkAI (pCreature);
+        _Reset();
+
+        if (instance)
+            instance->DoStopTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_MAKE_QUICK_WERK_OF_HIM_STARTING_EVENT);
     }
 
-    struct boss_patchwerkAI : public BossAI
+    void KilledUnit(Unit* /*Victim*/)
     {
-        boss_patchwerkAI(Creature *c) : BossAI(c, BOSS_PATCHWERK) {}
+        if (!(rand()%5))
+            DoScriptText(SAY_SLAY, me);
+    }
 
-        bool Enraged;
+    void JustDied(Unit* /*Killer*/)
+    {
+        _JustDied();
+        DoScriptText(SAY_DEATH, me);
+    }
 
-        uint32 EncounterTime;
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+        Enraged = false;
+        DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2), me);
+        events.ScheduleEvent(EVENT_HATEFUL, 1200);
+        events.ScheduleEvent(EVENT_BERSERK, 360000);
 
-        void Reset()
+        if (instance)
+            instance->DoStartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_MAKE_QUICK_WERK_OF_HIM_STARTING_EVENT);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictim())
+            return;
+
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            _Reset();
-            if (instance)
-                instance->DoStopTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_MAKE_QUICK_WERK_OF_HIM_STARTING_EVENT);
-        }
+            switch(eventId)
+            {
+                case EVENT_HATEFUL:
+                {
+                    //Cast Hateful strike on the player with the highest
+                    //amount of HP within melee distance
+                    uint32 MostHP = 0;
+                    Unit* pMostHPTarget = NULL;
+                    std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
+                    for (; i != me->getThreatManager().getThreatList().end(); ++i)
+                    {
+                        Unit *pTarget = (*i)->getTarget();
+                        if (pTarget->isAlive() && pTarget->GetHealth() > MostHP && me->IsWithinMeleeRange(pTarget))
+                        {
+                            MostHP = pTarget->GetHealth();
+                            pMostHPTarget = pTarget;
+                        }
+                    }
 
-        void KilledUnit(Unit* /*Victim*/)
-        {
-            if (!(rand()%5))
-                DoScriptText(SAY_SLAY, me);
-        }
+                    if (pMostHPTarget)
+                        DoCast(pMostHPTarget, RAID_MODE(SPELL_HATEFUL_STRIKE,H_SPELL_HATEFUL_STRIKE), true);
 
-        void JustDied(Unit* /*Killer*/)
-        {
-            _JustDied();
-            DoScriptText(SAY_DEATH, me);
-
-            if (EncounterTime <= MAX_ENCOUNTER_TIME)
-            {
-                AchievementEntry const *AchievMakeQuickWerkOfHim = GetAchievementStore()->LookupEntry(ACHIEVEMENT_MAKE_QUICK_WERK_OF_HIM);
-                if (AchievMakeQuickWerkOfHim)
-                {
-                    Map *pMap = me->GetMap();
-                    if (pMap && pMap->IsDungeon())
-                    {
-                        Map::PlayerList const &players = pMap->GetPlayers();
-                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
-                            itr->getSource()->CompletedAchievement(AchievMakeQuickWerkOfHim);
-                    }
+                    events.ScheduleEvent(EVENT_HATEFUL, 1200);
+                    break;
                 }
+                case EVENT_BERSERK:
+                    DoCast(me, SPELL_BERSERK, true);
+                    DoScriptText(EMOTE_BERSERK, me);
+                    events.ScheduleEvent(EVENT_SLIME, 2000);
+                    break;
+                case EVENT_SLIME:
+                    DoCast(me->getVictim(), SPELL_SLIME_BOLT);
+                    events.ScheduleEvent(EVENT_SLIME, 2000);
+                    break;
             }
         }
 
-        void EnterCombat(Unit * /*who*/)
+        if (!Enraged && HealthBelowPct(5))
         {
-            _EnterCombat();
-            Enraged = false;
-            EncounterTime = 0;
-            DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2), me);
-            events.ScheduleEvent(EVENT_HATEFUL, 1200);
-            events.ScheduleEvent(EVENT_BERSERK, 360000);
-            if (instance)
-                instance->DoStartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_MAKE_QUICK_WERK_OF_HIM_STARTING_EVENT);
+            DoCast(me, SPELL_FRENZY, true);
+            DoScriptText(EMOTE_ENRAGE, me);
+            Enraged = true;
         }
 
-        Unit* GetHatefullStrikeTarget()
-        {
-            // Get all Targets in Meleerange
-            const std::list<HostileReference *> &threatlist = me->getThreatManager().getThreatList();
-            std::list<Unit*> targetList;
-
-            for (std::list<HostileReference*>::const_iterator itr = threatlist.begin(); itr != threatlist.end(); ++itr)
-            {
-                HostileReference* ref = (*itr);
-                if (ref->getTarget() && me->IsWithinMeleeRange(ref->getTarget()))
-                    targetList.push_back(ref->getTarget());
-            }
-
-            // Get Target with most HP and not getVictim()
-            uint32 MostHP = 0;
-            Unit* pMostHPTarget = NULL;
-            uint32 counter = 0;
-
-            for(std::list<Unit*>::const_iterator itr = targetList.begin(); itr != targetList.end(); ++itr)
-            {
-                counter++;
-
-                //Only first 3 Targets in Threadlist
-                if(counter > 3)
-                    break;
-
-                Unit *pTarget = (*itr);
-                if (pTarget->isAlive() && pTarget->GetHealth() > MostHP)
-                {
-                    MostHP = pTarget->GetHealth();
-                    pMostHPTarget = pTarget;
-                }
-            }
-
-            if(pMostHPTarget)
-                return pMostHPTarget;
-            else
-                return me->getVictim();
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            events.Update(diff);
-
-            EncounterTime += diff;
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_HATEFUL:
-                    {
-                        //Cast Hateful strike on the player with the highest
-                        //amount of HP within melee distance
-                        //uint32 MostHP = 0;
-                        //Unit* pMostHPTarget = NULL;
-                        //uint32 counter = 1;
-                        //std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
-                        //++i;
-                        //for (; i != me->getThreatManager().getThreatList().end(); ++i)
-                        //{
-                        //    Unit *pTarget = (*i)->getTarget();
-
-                        //    if(!me->IsWithinMeleeRange(pTarget))
-                        //        continue;
-
-                        //    counter++;
-
-                        //    if(counter > 3)
-                        //        break;
-
-                        //    if (pTarget->isAlive() && pTarget->GetHealth() > MostHP)
-                        //    {
-                        //        MostHP = pTarget->GetHealth();
-                        //        pMostHPTarget = pTarget;
-                        //    }
-                        //}
-
-                        //if (pMostHPTarget) pMostHPTarget = me->getVictim();
-                        //if (pMostHPTarget)
-
-                        if(Unit* StrikeTarget = GetHatefullStrikeTarget())
-                            DoCast(StrikeTarget, RAID_MODE(SPELL_HATEFUL_STRIKE,H_SPELL_HATEFUL_STRIKE), true);
-
-                        events.ScheduleEvent(EVENT_HATEFUL, 1200);
-                        break;
-                    }
-                    case EVENT_BERSERK:
-                        DoCast(me, SPELL_BERSERK, true);
-                        DoScriptText(EMOTE_BERSERK, me);
-                        events.ScheduleEvent(EVENT_SLIME, 2000);
-                        break;
-                    case EVENT_SLIME:
-                        DoCast(me->getVictim(), SPELL_SLIME_BOLT);
-                        events.ScheduleEvent(EVENT_SLIME, 2000);
-                        break;
-                }
-            }
-
-            if (!Enraged && HealthBelowPct(5))
-            {
-                DoCast(me, SPELL_FRENZY, true);
-                DoScriptText(EMOTE_ENRAGE, me);
-                Enraged = true;
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_boss_patchwerk(Creature* pCreature)
+{
+    return new boss_patchwerkAI (pCreature);
+}
 
 void AddSC_boss_patchwerk()
 {
-    new boss_patchwerk();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_patchwerk";
+    newscript->GetAI = &GetAI_boss_patchwerk;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_razuvious.cpp b/src/server/scripts/Northrend/Naxxramas/boss_razuvious.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_razuvious.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_razuvious.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -52,100 +52,87 @@
     EVENT_COMMAND,
 };
 
-class boss_razuvious : public CreatureScript
+struct boss_razuviousAI : public BossAI
 {
-public:
-    boss_razuvious() : CreatureScript("boss_razuvious") { }
+    boss_razuviousAI(Creature *c) : BossAI(c, BOSS_RAZUVIOUS) {}
 
-    CreatureAI* GetAI(Creature* pCreature) const
+    void KilledUnit(Unit* /*victim*/)
     {
-        return new boss_razuviousAI (pCreature);
+        if (!(rand()%3))
+            DoPlaySoundToSet(me, SOUND_SLAY);
     }
 
-    struct boss_razuviousAI : public BossAI
+    void DamageTaken(Unit* pDone_by, uint32& uiDamage)
     {
-        boss_razuviousAI(Creature *c) : BossAI(c, BOSS_RAZUVIOUS) {}
+        // Damage done by the controlled Death Knight understudies should also count toward damage done by players
+        if (pDone_by->GetTypeId() == TYPEID_UNIT && (pDone_by->GetEntry() == 16803 || pDone_by->GetEntry() == 29941))
+        {
+            me->LowerPlayerDamageReq(uiDamage);
+        }
+    }
 
-        void KilledUnit(Unit* /*victim*/)
+    void JustDied(Unit* /*killer*/)
+    {
+        _JustDied();
+        DoPlaySoundToSet(me, SOUND_DEATH);
+        me->CastSpell(me, SPELL_HOPELESS, true); // TODO: this may affect other creatures
+    }
+
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+        DoPlaySoundToSet(me, SOUND_AGGRO);
+        events.ScheduleEvent(EVENT_STRIKE, 30000);
+        events.ScheduleEvent(EVENT_SHOUT, 25000);
+        events.ScheduleEvent(EVENT_COMMAND, 40000);
+        events.ScheduleEvent(EVENT_KNIFE, 10000);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictim())
+            return;
+
+        events.Update(diff);
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            if (!(rand()%3))
-                DoPlaySoundToSet(me, SOUND_SLAY);
-        }
-
-        void DamageTaken(Unit* pDone_by, uint32& uiDamage)
-        {
-            // Damage done by the controlled Death Knight understudies should also count toward damage done by players
-            if (pDone_by->GetTypeId() == TYPEID_UNIT && (pDone_by->GetEntry() == 16803 || pDone_by->GetEntry() == 29941))
+            switch(eventId)
             {
-                me->LowerPlayerDamageReq(uiDamage);
+                case EVENT_STRIKE:
+                    DoCast(me->getVictim(), SPELL_UNBALANCING_STRIKE);
+                    events.ScheduleEvent(EVENT_STRIKE, 30000);
+                    return;
+                case EVENT_SHOUT:
+                    DoCastAOE(SPELL_DISRUPTING_SHOUT);
+                    events.ScheduleEvent(EVENT_SHOUT, 25000);
+                    return;
+                case EVENT_KNIFE:
+                    if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 45.0f))
+                        DoCast(pTarget, SPELL_JAGGED_KNIFE);
+                    events.ScheduleEvent(EVENT_KNIFE, 10000);
+                    return;
+                case EVENT_COMMAND:
+                    DoPlaySoundToSet(me, SOUND_COMMND);
+                    events.ScheduleEvent(EVENT_COMMAND, 40000);
+                    return;
             }
         }
 
-        void JustDied(Unit* /*killer*/)
-        {
-            _JustDied();
-            DoPlaySoundToSet(me, SOUND_DEATH);
-            me->CastSpell(me, SPELL_HOPELESS, true); // TODO: this may affect other creatures
-
-            std::list<Creature*> lList;
-            me->GetCreatureListWithEntryInGrid(lList , 29912, 200);
-
-            if (!lList.size())
-                return;
-
-            for (std::list<Creature*>::const_iterator i = lList.begin(); i != lList.end(); ++i)
-                (*i)->DealDamage((*i),(*i)->GetHealth());
-        }
-
-        void EnterCombat(Unit * /*who*/)
-        {
-            _EnterCombat();
-            DoPlaySoundToSet(me, SOUND_AGGRO);
-            events.ScheduleEvent(EVENT_STRIKE, 30000);
-            events.ScheduleEvent(EVENT_SHOUT, 25000);
-            events.ScheduleEvent(EVENT_COMMAND, 40000);
-            events.ScheduleEvent(EVENT_KNIFE, 10000);
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            events.Update(diff);
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_STRIKE:
-                        DoCast(me->getVictim(), SPELL_UNBALANCING_STRIKE);
-                        events.ScheduleEvent(EVENT_STRIKE, 30000);
-                        return;
-                    case EVENT_SHOUT:
-                        DoCastAOE(SPELL_DISRUPTING_SHOUT);
-                        events.ScheduleEvent(EVENT_SHOUT, 25000);
-                        return;
-                    case EVENT_KNIFE:
-                        if (Unit *pTarget = SelectTarget(SELECT_TARGET_RANDOM, 0, 45.0f))
-                            DoCast(pTarget, SPELL_JAGGED_KNIFE);
-                        events.ScheduleEvent(EVENT_KNIFE, 10000);
-                        return;
-                    case EVENT_COMMAND:
-                        DoPlaySoundToSet(me, SOUND_COMMND);
-                        events.ScheduleEvent(EVENT_COMMAND, 40000);
-                        return;
-                }
-            }
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_boss_razuvious(Creature* pCreature)
+{
+    return new boss_razuviousAI (pCreature);
+}
 
 void AddSC_boss_razuvious()
 {
-    new boss_razuvious();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_razuvious";
+    newscript->GetAI = &GetAI_boss_razuvious;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_sapphiron.cpp b/src/server/scripts/Northrend/Naxxramas/boss_sapphiron.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_sapphiron.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_sapphiron.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -69,336 +69,334 @@
 
 typedef std::map<uint64, uint64> IceBlockMap;
 
-class boss_sapphiron : public CreatureScript
+struct boss_sapphironAI : public BossAI
 {
-public:
-    boss_sapphiron() : CreatureScript("boss_sapphiron") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
+    boss_sapphironAI(Creature* c) : BossAI(c, BOSS_SAPPHIRON)
+        , phase(PHASE_NULL)
     {
-        return new boss_sapphironAI (pCreature);
+        pMap = me->GetMap();
     }
 
-    struct boss_sapphironAI : public BossAI
+    Phases phase;
+    uint32 iceboltCount;
+    IceBlockMap iceblocks;
+
+    bool CanTheHundredClub; // needed for achievement: The Hundred Club(2146, 2147)
+    uint32 CheckFrostResistTimer;
+    Map* pMap;
+
+    void InitializeAI()
     {
-        boss_sapphironAI(Creature* c) : BossAI(c, BOSS_SAPPHIRON)
-            , phase(PHASE_NULL)
+        float x, y, z;
+        me->GetPosition(x, y, z);
+        me->SummonGameObject(GO_BIRTH, x, y, z, 0, 0, 0, 0, 0, 0);
+        me->SetVisibility(VISIBILITY_OFF);
+        me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        me->SetReactState(REACT_PASSIVE);
+
+        ScriptedAI::InitializeAI();
+    }
+
+    void Reset()
+    {
+        _Reset();
+
+        if (phase == PHASE_FLIGHT)
+            ClearIceBlock();
+
+        phase = PHASE_NULL;
+
+        CanTheHundredClub = true;
+        CheckFrostResistTimer = 5000;
+    }
+
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+
+        me->CastSpell(me, SPELL_FROST_AURA, true);
+
+        events.ScheduleEvent(EVENT_BERSERK, 15*60000);
+        EnterPhaseGround();
+
+        CheckPlayersFrostResist();
+    }
+
+    void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
+    {
+        if (spell->Id == SPELL_ICEBOLT)
         {
-            pMap = me->GetMap();
+            IceBlockMap::iterator itr = iceblocks.find(pTarget->GetGUID());
+            if (itr != iceblocks.end() && !itr->second)
+            {
+                if (GameObject *iceblock = me->SummonGameObject(GO_ICEBLOCK, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, 0, 0, 0, 0, 25000))
+                    itr->second = iceblock->GetGUID();
+            }
         }
+    }
 
-        Phases phase;
-        uint32 iceboltCount;
-        IceBlockMap iceblocks;
+    void JustDied(Unit* /*who*/)
+    {
+        _JustDied();
+        me->CastSpell(me, SPELL_DIES, true);
 
-        bool CanTheHundredClub; // needed for achievement: The Hundred Club(2146, 2147)
-        uint32 CheckFrostResistTimer;
-        Map* pMap;
-
-        void InitializeAI()
+        CheckPlayersFrostResist();
+        if (CanTheHundredClub)
         {
-            float x, y, z;
-            me->GetPosition(x, y, z);
-            me->SummonGameObject(GO_BIRTH, x, y, z, 0, 0, 0, 0, 0, 0);
-            me->SetVisibility(VISIBILITY_OFF);
-            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-            me->SetReactState(REACT_PASSIVE);
-
-            ScriptedAI::InitializeAI();
-        }
-
-        void Reset()
-        {
-            _Reset();
-
-            if (phase == PHASE_FLIGHT)
-                ClearIceBlock();
-
-            phase = PHASE_NULL;
-
-            CanTheHundredClub = true;
-            CheckFrostResistTimer = 5000;
-        }
-
-        void EnterCombat(Unit * /*who*/)
-        {
-            _EnterCombat();
-
-            me->CastSpell(me, SPELL_FROST_AURA, true);
-
-            events.ScheduleEvent(EVENT_BERSERK, 15*60000);
-            EnterPhaseGround();
-
-            CheckPlayersFrostResist();
-        }
-
-        void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
-        {
-            if (spell->Id == SPELL_ICEBOLT)
+            AchievementEntry const *AchievTheHundredClub = GetAchievementStore()->LookupEntry(ACHIEVEMENT_THE_HUNDRED_CLUB);
+            if (AchievTheHundredClub)
             {
-                IceBlockMap::iterator itr = iceblocks.find(pTarget->GetGUID());
-                if (itr != iceblocks.end() && !itr->second)
+                if (pMap && pMap->IsDungeon())
                 {
-                    if (GameObject *iceblock = me->SummonGameObject(GO_ICEBLOCK, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, 0, 0, 0, 0, 25000))
-                        itr->second = iceblock->GetGUID();
+                    Map::PlayerList const &players = pMap->GetPlayers();
+                    for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                        itr->getSource()->CompletedAchievement(AchievTheHundredClub);
                 }
             }
         }
+    }
 
-        void JustDied(Unit* /*who*/)
+    void MovementInform(uint32, uint32 id)
+    {
+        if (id == 1)
+            events.ScheduleEvent(EVENT_LIFTOFF, 0);
+    }
+
+    void DoAction(const int32 param)
+    {
+        if (param == DATA_SAPPHIRON_BIRTH)
         {
-            _JustDied();
-            me->CastSpell(me, SPELL_DIES, true);
+            phase = PHASE_BIRTH;
+            events.ScheduleEvent(EVENT_BIRTH, 23000);
+        }
+    }
 
-            CheckPlayersFrostResist();
-            if (CanTheHundredClub)
+    void CheckPlayersFrostResist()
+    {
+        if (CanTheHundredClub && pMap && pMap->IsDungeon())
+        {
+            Map::PlayerList const &players = pMap->GetPlayers();
+            for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
             {
-                AchievementEntry const *AchievTheHundredClub = GetAchievementStore()->LookupEntry(ACHIEVEMENT_THE_HUNDRED_CLUB);
-                if (AchievTheHundredClub)
+                if (itr->getSource()->GetResistance(SPELL_SCHOOL_FROST) > MAX_FROST_RESISTANCE)
                 {
-                    if (pMap && pMap->IsDungeon())
-                    {
-                        Map::PlayerList const &players = pMap->GetPlayers();
-                        for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
-                            itr->getSource()->CompletedAchievement(AchievTheHundredClub);
-                    }
+                    CanTheHundredClub = false;
+                    break;
                 }
             }
         }
+    }
 
-        void MovementInform(uint32, uint32 id)
+    void EnterPhaseGround()
+    {
+        phase = PHASE_GROUND;
+        me->SetReactState(REACT_AGGRESSIVE);
+        events.SetPhase(PHASE_GROUND);
+        events.ScheduleEvent(EVENT_CLEAVE, 5000+rand()%10000, 0, PHASE_GROUND);
+        events.ScheduleEvent(EVENT_TAIL, 5000+rand()%10000, 0, PHASE_GROUND);
+        events.ScheduleEvent(EVENT_DRAIN, 24000, 0, PHASE_GROUND);
+        events.ScheduleEvent(EVENT_BLIZZARD, 5000+rand()%5000, 0, PHASE_GROUND);
+        events.ScheduleEvent(EVENT_FLIGHT, 45000);
+    }
+
+    void ClearIceBlock()
+    {
+        for (IceBlockMap::const_iterator itr = iceblocks.begin(); itr != iceblocks.end(); ++itr)
         {
-            if (id == 1)
-                events.ScheduleEvent(EVENT_LIFTOFF, 0);
+            if (Player* pPlayer = Unit::GetPlayer(*me, itr->first))
+                pPlayer->RemoveAura(SPELL_ICEBOLT);
+            if (GameObject* pGo = GameObject::GetGameObject(*me, itr->second))
+                pGo->Delete();
+        }
+        iceblocks.clear();
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!phase)
+            return;
+
+        events.Update(diff);
+
+        if (phase != PHASE_BIRTH && !UpdateCombatState() || !CheckInRoom())
+            return;
+
+        if (CanTheHundredClub)
+        {
+            if (CheckFrostResistTimer <= diff)
+            {
+                CheckPlayersFrostResist();
+                CheckFrostResistTimer = (rand() % 5 + 5) * 1000;
+            } else CheckFrostResistTimer -= diff;
         }
 
-        void DoAction(const int32 param)
+        if (phase == PHASE_GROUND)
         {
-            if (param == DATA_SAPPHIRON_BIRTH)
+            while (uint32 eventId = events.ExecuteEvent())
             {
-                phase = PHASE_BIRTH;
-                events.ScheduleEvent(EVENT_BIRTH, 23000);
+                switch(eventId)
+                {
+                    case EVENT_BERSERK:
+                        DoScriptText(EMOTE_ENRAGE, me);
+                        DoCast(me, SPELL_BERSERK);
+                        return;
+                    case EVENT_CLEAVE:
+                        DoCast(me->getVictim(), SPELL_CLEAVE);
+                        events.ScheduleEvent(EVENT_CLEAVE, 5000+rand()%10000, 0, PHASE_GROUND);
+                        return;
+                    case EVENT_TAIL:
+                        DoCastAOE(SPELL_TAIL_SWEEP);
+                        events.ScheduleEvent(EVENT_TAIL, 5000+rand()%10000, 0, PHASE_GROUND);
+                        return;
+                    case EVENT_DRAIN:
+                        DoCastAOE(SPELL_LIFE_DRAIN);
+                        events.ScheduleEvent(EVENT_DRAIN, 24000, 0, PHASE_GROUND);
+                        return;
+                    case EVENT_BLIZZARD:
+                    {
+                        //DoCastAOE(SPELL_SUMMON_BLIZZARD);
+                        if (Creature *pSummon = DoSummon(MOB_BLIZZARD, me, 0.0f, urand(25000,30000), TEMPSUMMON_TIMED_DESPAWN))
+                            pSummon->GetMotionMaster()->MoveRandom(40);
+                        events.ScheduleEvent(EVENT_BLIZZARD, RAID_MODE(20000,7000), 0, PHASE_GROUND);
+                        break;
+                    }
+                    case EVENT_FLIGHT:
+                        phase = PHASE_FLIGHT;
+                        events.SetPhase(PHASE_FLIGHT);
+                        me->SetReactState(REACT_PASSIVE);
+                        me->AttackStop();
+                        float x, y, z, o;
+                        me->GetHomePosition(x, y, z, o);
+                        me->GetMotionMaster()->MovePoint(1, x, y, z);
+                        return;
+                }
             }
+
+            DoMeleeAttackIfReady();
         }
+        else
+        {
+            if (uint32 eventId = events.ExecuteEvent())
+            {
+                switch(eventId)
+                {
+                    case EVENT_LIFTOFF:
+                        me->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+                        me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
+                        me->SendMovementFlagUpdate();
+                        events.ScheduleEvent(EVENT_ICEBOLT, 1500);
+                        iceboltCount = RAID_MODE(2,3);
+                        return;
+                    case EVENT_ICEBOLT:
+                    {
+                        std::vector<Unit*> targets;
+                        std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
+                        for (; i != me->getThreatManager().getThreatList().end(); ++i)
+                            if ((*i)->getTarget()->GetTypeId() == TYPEID_PLAYER && !(*i)->getTarget()->HasAura(SPELL_ICEBOLT))
+                                targets.push_back((*i)->getTarget());
 
-        void CheckPlayersFrostResist()
+                        if (targets.empty())
+                            iceboltCount = 0;
+                        else
+                        {
+                            std::vector<Unit*>::const_iterator itr = targets.begin();
+                            advance(itr, rand()%targets.size());
+                            iceblocks.insert(std::make_pair((*itr)->GetGUID(), 0));
+                            DoCast(*itr, SPELL_ICEBOLT);
+                            --iceboltCount;
+                        }
+
+                        if (iceboltCount)
+                            events.ScheduleEvent(EVENT_ICEBOLT, 1000);
+                        else
+                            events.ScheduleEvent(EVENT_BREATH, 1000);
+                        return;
+                    }
+                    case EVENT_BREATH:
+                    {
+                        DoScriptText(EMOTE_BREATH, me);
+                        DoCastAOE(SPELL_FROST_MISSILE);
+                        events.ScheduleEvent(EVENT_EXPLOSION, 8000);
+                        return;
+                    }
+                    case EVENT_EXPLOSION:
+                        CastExplosion();
+                        ClearIceBlock();
+                        events.ScheduleEvent(EVENT_LAND, 3000);
+                        return;
+                    case EVENT_LAND:
+                        me->HandleEmoteCommand(EMOTE_ONESHOT_LAND);
+                        me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
+                        me->SendMovementFlagUpdate();
+                        events.ScheduleEvent(EVENT_GROUND, 1500);
+                        return;
+                    case EVENT_GROUND:
+                        EnterPhaseGround();
+                        return;
+                    case EVENT_BIRTH:
+                        me->SetVisibility(VISIBILITY_ON);
+                        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        me->SetReactState(REACT_AGGRESSIVE);
+                        return;
+                }
+            }//if (uint32 eventId = events.ExecuteEvent())
+        }//if (phase == PHASE_GROUND)
+    }
+
+    void CastExplosion()
+    {
+        DoZoneInCombat(); // make sure everyone is in threatlist
+        std::vector<Unit*> targets;
+        std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
+        for (; i != me->getThreatManager().getThreatList().end(); ++i)
         {
-            if (CanTheHundredClub && pMap && pMap->IsDungeon())
+            Unit *pTarget = (*i)->getTarget();
+            if (pTarget->GetTypeId() != TYPEID_PLAYER)
+                continue;
+
+            if (pTarget->HasAura(SPELL_ICEBOLT))
             {
-                Map::PlayerList const &players = pMap->GetPlayers();
-                for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                pTarget->ApplySpellImmune(0, IMMUNITY_ID, SPELL_FROST_EXPLOSION, true);
+                targets.push_back(pTarget);
+                continue;
+            }
+
+            for (IceBlockMap::const_iterator itr = iceblocks.begin(); itr != iceblocks.end(); ++itr)
+            {
+                if (GameObject* pGo = GameObject::GetGameObject(*me, itr->second))
                 {
-                    if (itr->getSource()->GetResistance(SPELL_SCHOOL_FROST) > MAX_FROST_RESISTANCE)
+                    if (pGo->IsInBetween(me, pTarget, 2.0f)
+                        && me->GetExactDist2d(pTarget->GetPositionX(), pTarget->GetPositionY()) - me->GetExactDist2d(pGo->GetPositionX(), pGo->GetPositionY()) < 5.0f)
                     {
-                        CanTheHundredClub = false;
+                        pTarget->ApplySpellImmune(0, IMMUNITY_ID, SPELL_FROST_EXPLOSION, true);
+                        targets.push_back(pTarget);
                         break;
                     }
                 }
             }
         }
 
-        void EnterPhaseGround()
-        {
-            phase = PHASE_GROUND;
-            me->SetReactState(REACT_AGGRESSIVE);
-            events.SetPhase(PHASE_GROUND);
-            events.ScheduleEvent(EVENT_CLEAVE, 5000+rand()%10000, 0, PHASE_GROUND);
-            events.ScheduleEvent(EVENT_TAIL, 5000+rand()%10000, 0, PHASE_GROUND);
-            events.ScheduleEvent(EVENT_DRAIN, 24000, 0, PHASE_GROUND);
-            events.ScheduleEvent(EVENT_BLIZZARD, 5000+rand()%5000, 0, PHASE_GROUND);
-            events.ScheduleEvent(EVENT_FLIGHT, 45000);
-        }
+        me->CastSpell(me, SPELL_FROST_EXPLOSION, true);
 
-        void ClearIceBlock()
-        {
-            for (IceBlockMap::const_iterator itr = iceblocks.begin(); itr != iceblocks.end(); ++itr)
-            {
-                if (Player* pPlayer = Unit::GetPlayer(*me, itr->first))
-                    pPlayer->RemoveAura(SPELL_ICEBOLT);
-                if (GameObject* pGo = GameObject::GetGameObject(*me, itr->second))
-                    pGo->Delete();
-            }
-            iceblocks.clear();
-        }
-
-        void UpdateAI(const uint32 diff)
-        {
-            if (!phase)
-                return;
-
-            events.Update(diff);
-
-            if ((phase != PHASE_BIRTH && !UpdateCombatState()) || !CheckInRoom())
-                return;
-
-            if (CanTheHundredClub)
-            {
-                if (CheckFrostResistTimer <= diff)
-                {
-                    CheckPlayersFrostResist();
-                    CheckFrostResistTimer = (rand() % 5 + 5) * 1000;
-                } else CheckFrostResistTimer -= diff;
-            }
-
-            if (phase == PHASE_GROUND)
-            {
-                while (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch(eventId)
-                    {
-                        case EVENT_BERSERK:
-                            DoScriptText(EMOTE_ENRAGE, me);
-                            DoCast(me, SPELL_BERSERK);
-                            return;
-                        case EVENT_CLEAVE:
-                            DoCast(me->getVictim(), SPELL_CLEAVE);
-                            events.ScheduleEvent(EVENT_CLEAVE, 5000+rand()%10000, 0, PHASE_GROUND);
-                            return;
-                        case EVENT_TAIL:
-                            DoCastAOE(SPELL_TAIL_SWEEP);
-                            events.ScheduleEvent(EVENT_TAIL, 5000+rand()%10000, 0, PHASE_GROUND);
-                            return;
-                        case EVENT_DRAIN:
-                            DoCastAOE(SPELL_LIFE_DRAIN);
-                            events.ScheduleEvent(EVENT_DRAIN, 24000, 0, PHASE_GROUND);
-                            return;
-                        case EVENT_BLIZZARD:
-                        {
-                            //DoCastAOE(SPELL_SUMMON_BLIZZARD);
-                            Unit *target = SelectTarget(SELECT_TARGET_RANDOM,1);
-                            if (!target) target = me->getVictim();
-                            if (Creature *pSummon = DoSummon(MOB_BLIZZARD, target, 0.0f, urand(25000,30000), TEMPSUMMON_TIMED_DESPAWN))
-                                pSummon->GetMotionMaster()->MoveRandom(40);
-                            events.ScheduleEvent(EVENT_BLIZZARD, RAID_MODE(20000,7000), 0, PHASE_GROUND);
-                            break;
-                        }
-                        case EVENT_FLIGHT:
-                            phase = PHASE_FLIGHT;
-                            events.SetPhase(PHASE_FLIGHT);
-                            me->SetReactState(REACT_PASSIVE);
-                            me->AttackStop();
-                            float x, y, z, o;
-                            me->GetHomePosition(x, y, z, o);
-                            me->GetMotionMaster()->MovePoint(1, x, y, z);
-                            return;
-                    }
-                }
-
-                DoMeleeAttackIfReady();
-            }
-            else
-            {
-                if (uint32 eventId = events.ExecuteEvent())
-                {
-                    switch(eventId)
-                    {
-                        case EVENT_LIFTOFF:
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
-                            me->AddUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                            me->SendMovementFlagUpdate();
-                            events.ScheduleEvent(EVENT_ICEBOLT, 1500);
-                            iceboltCount = RAID_MODE(2,3);
-                            return;
-                        case EVENT_ICEBOLT:
-                        {
-                            std::vector<Unit*> targets;
-                            std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
-                            for (; i != me->getThreatManager().getThreatList().end(); ++i)
-                                if ((*i)->getTarget()->GetTypeId() == TYPEID_PLAYER && !(*i)->getTarget()->HasAura(SPELL_ICEBOLT))
-                                    targets.push_back((*i)->getTarget());
-
-                            if (targets.empty())
-                                iceboltCount = 0;
-                            else
-                            {
-                                std::vector<Unit*>::const_iterator itr = targets.begin();
-                                advance(itr, rand()%targets.size());
-                                iceblocks.insert(std::make_pair((*itr)->GetGUID(), 0));
-                                DoCast(*itr, SPELL_ICEBOLT);
-                                --iceboltCount;
-                            }
-
-                            if (iceboltCount)
-                                events.ScheduleEvent(EVENT_ICEBOLT, 1000);
-                            else
-                                events.ScheduleEvent(EVENT_BREATH, 1000);
-                            return;
-                        }
-                        case EVENT_BREATH:
-                        {
-                            DoScriptText(EMOTE_BREATH, me);
-                            DoCastAOE(SPELL_FROST_MISSILE);
-                            events.ScheduleEvent(EVENT_EXPLOSION, 8000);
-                            return;
-                        }
-                        case EVENT_EXPLOSION:
-                            CastExplosion();
-                            ClearIceBlock();
-                            events.ScheduleEvent(EVENT_LAND, 3000);
-                            return;
-                        case EVENT_LAND:
-                            me->HandleEmoteCommand(EMOTE_ONESHOT_LAND);
-                            me->RemoveUnitMovementFlag(MOVEMENTFLAG_LEVITATING);
-                            me->SendMovementFlagUpdate();
-                            events.ScheduleEvent(EVENT_GROUND, 1500);
-                            return;
-                        case EVENT_GROUND:
-                            EnterPhaseGround();
-                            return;
-                        case EVENT_BIRTH:
-                            me->SetVisibility(VISIBILITY_ON);
-                            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                            me->SetReactState(REACT_AGGRESSIVE);
-                            return;
-                    }
-                }//if (uint32 eventId = events.ExecuteEvent())
-            }//if (phase == PHASE_GROUND)
-        }
-
-        void CastExplosion()
-        {
-            DoZoneInCombat(); // make sure everyone is in threatlist
-            std::vector<Unit*> targets;
-            std::list<HostileReference*>::const_iterator i = me->getThreatManager().getThreatList().begin();
-            for (; i != me->getThreatManager().getThreatList().end(); ++i)
-            {
-                Unit *pTarget = (*i)->getTarget();
-                if (pTarget->GetTypeId() != TYPEID_PLAYER)
-                    continue;
-
-                if (pTarget->HasAura(SPELL_ICEBOLT))
-                {
-                    pTarget->ApplySpellImmune(0, IMMUNITY_ID, SPELL_FROST_EXPLOSION, true);
-                    targets.push_back(pTarget);
-                    continue;
-                }
-
-                for (IceBlockMap::const_iterator itr = iceblocks.begin(); itr != iceblocks.end(); ++itr)
-                {
-                    if (GameObject* pGo = GameObject::GetGameObject(*me, itr->second))
-                    {
-                        if (pGo->IsInBetween(me, pTarget, 2.0f)
-                            && me->GetExactDist2d(pTarget->GetPositionX(), pTarget->GetPositionY()) - me->GetExactDist2d(pGo->GetPositionX(), pGo->GetPositionY()) < 5.0f)
-                        {
-                            pTarget->ApplySpellImmune(0, IMMUNITY_ID, SPELL_FROST_EXPLOSION, true);
-                            targets.push_back(pTarget);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            me->CastSpell(me, SPELL_FROST_EXPLOSION, true);
-
-            for (std::vector<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
-                (*itr)->ApplySpellImmune(0, IMMUNITY_ID, SPELL_FROST_EXPLOSION, false);
-        }
-    };
-
+        for (std::vector<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+            (*itr)->ApplySpellImmune(0, IMMUNITY_ID, SPELL_FROST_EXPLOSION, false);
+    }
 };
 
+CreatureAI* GetAI_boss_sapphiron(Creature* pCreature)
+{
+    return new boss_sapphironAI (pCreature);
+}
 
 void AddSC_boss_sapphiron()
 {
-    new boss_sapphiron();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_sapphiron";
+    newscript->GetAI = &GetAI_boss_sapphiron;
+    newscript->RegisterSelf();
+
+    // Chill
+    GetAISpellInfo(28547)->cooldown = 1000;
+    GetAISpellInfo(55699)->cooldown = 1000;
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp b/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_thaddius.cpp
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "ScriptPCH.h"
@@ -94,350 +94,306 @@
     EVENT_BERSERK,
 };
 
-class boss_thaddius : public CreatureScript
+struct boss_thaddiusAI : public BossAI
 {
-public:
-    boss_thaddius() : CreatureScript("boss_thaddius") { }
+    boss_thaddiusAI(Creature *c) : BossAI(c, BOSS_THADDIUS)
+    {
+        // init is a bit tricky because thaddius shall track the life of both adds, but not if there was a wipe
+        // and, in particular, if there was a crash after both adds were killed (should not respawn)
 
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new boss_thaddiusAI (pCreature);
+        // Moreover, the adds may not yet be spawn. So just track down the status if mob is spawn
+        // and each mob will send its status at reset (meaning that it is alive)
+        checkFeugenAlive = false;
+        if (Creature *pFeugen = me->GetCreature(*me, instance->GetData64(DATA_FEUGEN)))
+            checkFeugenAlive = pFeugen->isAlive();
+
+        checkStalaggAlive = false;
+        if (Creature *pStalagg = me->GetCreature(*me, instance->GetData64(DATA_STALAGG)))
+            checkStalaggAlive = pStalagg->isAlive();
+
+        if (!checkFeugenAlive && !checkStalaggAlive)
+        {
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+            me->SetReactState(REACT_AGGRESSIVE);
+        }
+        else
+        {
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+            me->SetReactState(REACT_PASSIVE);
+        }
     }
 
-    struct boss_thaddiusAI : public BossAI
+    bool checkStalaggAlive;
+    bool checkFeugenAlive;
+    uint32 uiAddsTimer;
+
+    void KilledUnit(Unit* /*victim*/)
     {
-        boss_thaddiusAI(Creature *c) : BossAI(c, BOSS_THADDIUS)
+        if (!(rand()%5))
+            DoScriptText(SAY_SLAY, me);
+    }
+
+    void JustDied(Unit* /*Killer*/)
+    {
+        _JustDied();
+        DoScriptText(SAY_DEATH, me);
+    }
+
+    void DoAction(const int32 action)
+    {
+        switch(action)
         {
-            // init is a bit tricky because thaddius shall track the life of both adds, but not if there was a wipe
-            // and, in particular, if there was a crash after both adds were killed (should not respawn)
+            case ACTION_FEUGEN_RESET:
+                checkFeugenAlive = true;
+                break;
+            case ACTION_FEUGEN_DIED:
+                checkFeugenAlive = false;
+                break;
+            case ACTION_STALAGG_RESET:
+                checkStalaggAlive = true;
+                break;
+            case ACTION_STALAGG_DIED:
+                checkStalaggAlive = false;
+                break;
+        }
 
-            // Moreover, the adds may not yet be spawn. So just track down the status if mob is spawn
-            // and each mob will send its status at reset (meaning that it is alive)
-            checkFeugenAlive = false;
-            if (Creature *pFeugen = me->GetCreature(*me, instance->GetData64(DATA_FEUGEN)))
-                checkFeugenAlive = pFeugen->isAlive();
+        if (!checkFeugenAlive && !checkStalaggAlive)
+        {
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+            // REACT_AGGRESSIVE only reset when he takes damage.
+            DoZoneInCombat();
+        }
+        else
+        {
+            me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
+            me->SetReactState(REACT_PASSIVE);
+        }
+    }
 
-            checkStalaggAlive = false;
-            if (Creature *pStalagg = me->GetCreature(*me, instance->GetData64(DATA_STALAGG)))
-                checkStalaggAlive = pStalagg->isAlive();
+    void EnterCombat(Unit * /*who*/)
+    {
+        _EnterCombat();
+        DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2,SAY_AGGRO_3), me);
+        events.ScheduleEvent(EVENT_SHIFT, 30000);
+        events.ScheduleEvent(EVENT_CHAIN, urand(10000,20000));
+        events.ScheduleEvent(EVENT_BERSERK, 360000);
+    }
 
-            if (!checkFeugenAlive && !checkStalaggAlive)
+    void DamageTaken(Unit * /*pDoneBy*/, uint32 & /*uiDamage*/)
+    {
+        me->SetReactState(REACT_AGGRESSIVE);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (checkFeugenAlive && checkStalaggAlive)
+            uiAddsTimer = 0;
+
+        if (checkStalaggAlive != checkFeugenAlive)
+        {
+            uiAddsTimer += diff;
+            if (uiAddsTimer > 5000)
             {
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
-                me->SetReactState(REACT_AGGRESSIVE);
-            }
-            else
-            {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
-                me->SetReactState(REACT_PASSIVE);
+                if (!checkStalaggAlive)
+                {
+                    if (instance)
+                        if (Creature *pStalagg = me->GetCreature(*me, instance->GetData64(DATA_STALAGG)))
+                            pStalagg->Respawn();
+                }
+                else
+                {
+                    if (instance)
+                        if (Creature *pFeugen = me->GetCreature(*me, instance->GetData64(DATA_FEUGEN)))
+                            pFeugen->Respawn();
+                }
             }
         }
 
-        bool checkStalaggAlive;
-        bool checkFeugenAlive;
-        uint32 uiAddsTimer;
+        if (!UpdateVictim())
+            return;
 
-        void Reset()
+        events.Update(diff);
+
+        if (me->hasUnitState(UNIT_STAT_CASTING))
+            return;
+
+        while (uint32 eventId = events.ExecuteEvent())
         {
-            _Reset();
-
-            if (Creature *pFeugen = me->GetCreature(*me, instance->GetData64(DATA_FEUGEN)))
+            switch(eventId)
             {
-                pFeugen->Respawn(true);
-                checkFeugenAlive = pFeugen->isAlive();
-            }
-
-            if (Creature *pStalagg = me->GetCreature(*me, instance->GetData64(DATA_STALAGG)))
-            {
-                pStalagg->Respawn(true);
-                checkStalaggAlive = pStalagg->isAlive();
-            }
-
-            if (!checkFeugenAlive && !checkStalaggAlive)
-            {
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
-                me->SetReactState(REACT_AGGRESSIVE);
-            }
-            else
-            {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
-                me->SetReactState(REACT_PASSIVE);
-            }
-
-        }
-
-        void KilledUnit(Unit* /*victim*/)
-        {
-            if (!(rand()%5))
-                DoScriptText(SAY_SLAY, me);
-        }
-
-        void JustDied(Unit* /*Killer*/)
-        {
-            _JustDied();
-            DoScriptText(SAY_DEATH, me);
-        }
-
-        void DoAction(const int32 action)
-        {
-            switch(action)
-            {
-                case ACTION_FEUGEN_RESET:
-                    checkFeugenAlive = true;
-                    break;
-                case ACTION_FEUGEN_DIED:
-                    checkFeugenAlive = false;
-                    break;
-                case ACTION_STALAGG_RESET:
-                    checkStalaggAlive = true;
-                    break;
-                case ACTION_STALAGG_DIED:
-                    checkStalaggAlive = false;
-                    break;
-            }
-
-            if (!checkFeugenAlive && !checkStalaggAlive)
-            {
-                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
-                // REACT_AGGRESSIVE only reset when he takes damage.
-                DoZoneInCombat();
-            }
-            else
-            {
-                me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE | UNIT_FLAG_NOT_SELECTABLE | UNIT_FLAG_STUNNED);
-                me->SetReactState(REACT_PASSIVE);
+                case EVENT_SHIFT:
+                    DoCastAOE(SPELL_POLARITY_SHIFT);
+                    events.ScheduleEvent(EVENT_SHIFT, 30000);
+                    return;
+                case EVENT_CHAIN:
+                    DoCast(me->getVictim(), RAID_MODE(SPELL_CHAIN_LIGHTNING, H_SPELL_CHAIN_LIGHTNING));
+                    events.ScheduleEvent(EVENT_CHAIN, urand(10000,20000));
+                    return;
+                case EVENT_BERSERK:
+                    DoCast(me, SPELL_BERSERK);
+                    return;
             }
         }
 
-        void EnterCombat(Unit * /*who*/)
+        if (events.GetTimer() > 15000 && !me->IsWithinMeleeRange(me->getVictim()))
+            DoCast(me->getVictim(), SPELL_BALL_LIGHTNING);
+        else
+            DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_thaddius(Creature* pCreature)
+{
+    return new boss_thaddiusAI (pCreature);
+}
+
+struct mob_stalaggAI : public ScriptedAI
+{
+    mob_stalaggAI(Creature *c) : ScriptedAI(c)
+    {
+        pInstance = c->GetInstanceData();
+    }
+
+    ScriptedInstance* pInstance;
+
+    uint32 powerSurgeTimer;
+    uint32 magneticPullTimer;
+
+    void Reset()
+    {
+        if (pInstance)
+            if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
+                if (pThaddius->AI())
+                    pThaddius->AI()->DoAction(ACTION_STALAGG_RESET);
+        powerSurgeTimer = urand(20000,25000);
+        magneticPullTimer = 20000;
+    }
+
+    void EnterCombat(Unit * /*pWho*/)
+    {
+        DoCast(SPELL_STALAGG_TESLA);
+    }
+
+    void JustDied(Unit * /*killer*/)
+    {
+        if (pInstance)
+            if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
+                if (pThaddius->AI())
+                    pThaddius->AI()->DoAction(ACTION_STALAGG_DIED);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!UpdateVictim())
+            return;
+
+        if (magneticPullTimer <= uiDiff)
         {
-            _EnterCombat();
-            DoScriptText(RAND(SAY_AGGRO_1,SAY_AGGRO_2,SAY_AGGRO_3), me);
-            events.ScheduleEvent(EVENT_SHIFT, 30000);
-            events.ScheduleEvent(EVENT_CHAIN, urand(10000,20000));
-            events.ScheduleEvent(EVENT_BERSERK, 360000);
-        }
+            if (Creature *pFeugen = me->GetCreature(*me, pInstance->GetData64(DATA_FEUGEN)))
+            {
+                Unit* pStalaggVictim = me->getVictim();
+                Unit* pFeugenVictim = pFeugen->getVictim();
 
-        void DamageTaken(Unit * /*pDoneBy*/, uint32 & /*uiDamage*/)
-        {
-            me->SetReactState(REACT_AGGRESSIVE);
-        }
+                if (pFeugenVictim && pStalaggVictim)
+                {
+                    // magnetic pull is not working. So just jump.
 
-        void UpdateAI(const uint32 diff)
-        {
-            if (checkFeugenAlive && checkStalaggAlive)
-                uiAddsTimer = 0;
+                    // reset aggro to be sure that feugen will not follow the jump
+                    pFeugen->getThreatManager().modifyThreatPercent(pFeugenVictim, -100);
+                    pFeugenVictim->JumpTo(me, 0.3f);
 
-            if (checkStalaggAlive != checkFeugenAlive)
-            {
-                uiAddsTimer += diff;
-                if (uiAddsTimer > 5000)
-                {
-                    if (!checkStalaggAlive)
-                    {
-                        if (instance)
-                            if (Creature *pStalagg = me->GetCreature(*me, instance->GetData64(DATA_STALAGG)))
-                                pStalagg->Respawn();
-                    }
-                    else
-                    {
-                        if (instance)
-                            if (Creature *pFeugen = me->GetCreature(*me, instance->GetData64(DATA_FEUGEN)))
-                                pFeugen->Respawn();
-                    }
+                    me->getThreatManager().modifyThreatPercent(pStalaggVictim, -100);
+                    pStalaggVictim->JumpTo(pFeugen, 0.3f);
                 }
             }
 
-            if (!UpdateVictim())
-                return;
+            magneticPullTimer = 20000;
+        }
+        else magneticPullTimer -= uiDiff;
 
-            events.Update(diff);
+        if (powerSurgeTimer <= uiDiff)
+        {
+            DoCast(me, RAID_MODE(SPELL_POWERSURGE, H_SPELL_POWERSURGE));
+            powerSurgeTimer = urand(15000,20000);
+        } else powerSurgeTimer -= uiDiff;
 
-            if (me->hasUnitState(UNIT_STAT_CASTING))
-                return;
-
-            while (uint32 eventId = events.ExecuteEvent())
-            {
-                switch(eventId)
-                {
-                    case EVENT_SHIFT:
-                        DoCastAOE(SPELL_POLARITY_SHIFT);
-                        events.ScheduleEvent(EVENT_SHIFT, 30000);
-                        return;
-                    case EVENT_CHAIN:
-                        DoCast(me->getVictim(), RAID_MODE(SPELL_CHAIN_LIGHTNING, H_SPELL_CHAIN_LIGHTNING));
-                        events.ScheduleEvent(EVENT_CHAIN, urand(10000,20000));
-                        return;
-                    case EVENT_BERSERK:
-                        me->InterruptNonMeleeSpells(false);
-                        DoCast(me, SPELL_BERSERK);
-                        return;
-                }
-            }
-
-            if (events.GetTimer() > 15000 && !me->IsWithinMeleeRange(me->getVictim()))
-                DoCast(me->getVictim(), SPELL_BALL_LIGHTNING);
-            else
-                DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
+CreatureAI* GetAI_mob_stalagg(Creature* pCreature)
+{
+    return new mob_stalaggAI(pCreature);
+}
 
-class mob_stalagg : public CreatureScript
+struct mob_feugenAI : public ScriptedAI
 {
-public:
-    mob_stalagg() : CreatureScript("mob_stalagg") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
+    mob_feugenAI(Creature *c) : ScriptedAI(c)
     {
-        return new mob_stalaggAI(pCreature);
+        pInstance = c->GetInstanceData();
     }
 
-    struct mob_stalaggAI : public ScriptedAI
+    ScriptedInstance* pInstance;
+
+    uint32 staticFieldTimer;
+
+    void Reset()
     {
-        mob_stalaggAI(Creature *c) : ScriptedAI(c)
+        if (pInstance)
+            if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
+                if (pThaddius->AI())
+                    pThaddius->AI()->DoAction(ACTION_FEUGEN_RESET);
+        staticFieldTimer = 5000;
+    }
+
+    void EnterCombat(Unit * /*pWho*/)
+    {
+        DoCast(SPELL_FEUGEN_TESLA);
+    }
+
+    void JustDied(Unit * /*killer*/)
+    {
+        if (pInstance)
+            if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
+                if (pThaddius->AI())
+                    pThaddius->AI()->DoAction(ACTION_FEUGEN_DIED);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!UpdateVictim())
+            return;
+
+        if (staticFieldTimer <= uiDiff)
         {
-            pInstance = c->GetInstanceScript();
-        }
+            DoCast(me, RAID_MODE(SPELL_STATICFIELD, H_SPELL_STATICFIELD));
+            staticFieldTimer = 5000;
+        } else staticFieldTimer -= uiDiff;
 
-        InstanceScript* pInstance;
-
-        uint32 powerSurgeTimer;
-        uint32 magneticPullTimer;
-
-        void Reset()
-        {
-            if (pInstance)
-                if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
-                    if (pThaddius->AI())
-                        pThaddius->AI()->DoAction(ACTION_STALAGG_RESET);
-            powerSurgeTimer = urand(20000,25000);
-            magneticPullTimer = 20000;
-        }
-
-        void EnterCombat(Unit * /*pWho*/)
-        {
-            DoCast(SPELL_STALAGG_TESLA);
-        }
-
-        void JustDied(Unit * /*killer*/)
-        {
-            if (pInstance)
-                if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
-                    if (pThaddius->AI())
-                        pThaddius->AI()->DoAction(ACTION_STALAGG_DIED);
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            if (magneticPullTimer <= uiDiff)
-            {
-                if (Creature *pFeugen = me->GetCreature(*me, pInstance->GetData64(DATA_FEUGEN)))
-                {
-                    Unit* pStalaggVictim = me->getVictim();
-                    Unit* pFeugenVictim = pFeugen->getVictim();
-
-                    if (pFeugenVictim && pStalaggVictim)
-                    {
-                        // magnetic pull is not working. So just jump.
-
-                        // reset aggro to be sure that feugen will not follow the jump
-                        pFeugen->getThreatManager().modifyThreatPercent(pFeugenVictim, -100);
-                        pFeugen->getThreatManager().modifyThreatPercent(pStalaggVictim, 100);
-                        pFeugenVictim->JumpTo(me, 0.3f);
-
-                        me->getThreatManager().modifyThreatPercent(pStalaggVictim, -100);
-                        me->getThreatManager().modifyThreatPercent(pFeugenVictim, 100);
-                        pStalaggVictim->JumpTo(pFeugen, 0.3f);
-                    }
-                }
-
-                magneticPullTimer = 20000;
-            }
-            else magneticPullTimer -= uiDiff;
-
-            if (powerSurgeTimer <= uiDiff)
-            {
-                DoCast(me, RAID_MODE(SPELL_POWERSURGE, H_SPELL_POWERSURGE));
-                powerSurgeTimer = urand(15000,20000);
-            } else powerSurgeTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
+        DoMeleeAttackIfReady();
+    }
 };
 
-
-class mob_feugen : public CreatureScript
+CreatureAI* GetAI_mob_feugen(Creature* pCreature)
 {
-public:
-    mob_feugen() : CreatureScript("mob_feugen") { }
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
-        return new mob_feugenAI(pCreature);
-    }
-
-    struct mob_feugenAI : public ScriptedAI
-    {
-        mob_feugenAI(Creature *c) : ScriptedAI(c)
-        {
-            pInstance = c->GetInstanceScript();
-        }
-
-        InstanceScript* pInstance;
-
-        uint32 staticFieldTimer;
-
-        void Reset()
-        {
-            if (pInstance)
-                if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
-                    if (pThaddius->AI())
-                        pThaddius->AI()->DoAction(ACTION_FEUGEN_RESET);
-            staticFieldTimer = 5000;
-        }
-
-        void EnterCombat(Unit * /*pWho*/)
-        {
-            DoCast(SPELL_FEUGEN_TESLA);
-        }
-
-        void JustDied(Unit * /*killer*/)
-        {
-            if (pInstance)
-                if (Creature *pThaddius = me->GetCreature(*me, pInstance->GetData64(DATA_THADDIUS)))
-                    if (pThaddius->AI())
-                        pThaddius->AI()->DoAction(ACTION_FEUGEN_DIED);
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            if (staticFieldTimer <= uiDiff)
-            {
-                DoCast(me, RAID_MODE(SPELL_STATICFIELD, H_SPELL_STATICFIELD));
-                staticFieldTimer = 5000;
-            } else staticFieldTimer -= uiDiff;
-
-            DoMeleeAttackIfReady();
-        }
-    };
-
-};
-
+    return new mob_feugenAI(pCreature);
+}
 
 void AddSC_boss_thaddius()
 {
-    new boss_thaddius();
-    new mob_stalagg();
-    new mob_feugen();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_thaddius";
+    newscript->GetAI = &GetAI_boss_thaddius;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_stalagg";
+    newscript->GetAI = &GetAI_mob_stalagg;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_feugen";
+    newscript->GetAI = &GetAI_mob_feugen;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/instance_naxxramas.cpp b/src/server/scripts/Northrend/Naxxramas/instance_naxxramas.cpp
--- a/src/server/scripts/Northrend/Naxxramas/instance_naxxramas.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/instance_naxxramas.cpp
@@ -1,20 +1,20 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
- 
+
 #include "ScriptPCH.h"
 #include "naxxramas.h"
 
@@ -51,7 +51,6 @@
 {
     //{16573,     BOSS_ANUBREKHAN},     there is no spawn point in db, so we do not add them here
     {16506,     BOSS_FAERLINA},
-    {16505,     BOSS_FAERLINA},
     {16803,     BOSS_RAZUVIOUS},
     {16063,     BOSS_HORSEMEN},
     {16064,     BOSS_HORSEMEN},
@@ -71,48 +70,7 @@
     GO_KELTHUZAD_PORTAL04   = 181405,
     GO_KELTHUZAD_TRIGGER    = 181444,
 
-    GO_ROOM_ANUBREKHAN      = 181126,
-    GO_PASSAGE_ANUBREKHAN   = 181195,
-    GO_PASSAGE_FAERLINA     = 194022,
-    GO_ROOM_MAEXXNA         = 181209,
-    GO_ROOM_NOTH            = 181200,
-    GO_PASSAGE_NOTH         = 181201,
-    GO_ROOM_HEIGAN          = 181202,
-    GO_PASSAGE_HEIGAN       = 181203,
-    GO_ROOM_LOATHEB         = 181241,
-    GO_ROOM_GROBBULUS       = 181123,
-    GO_PASSAGE_GLUTH        = 181120,
-    GO_ROOM_THADDIUS        = 181121,
-    GO_ROOM_GOTHIK          = 181124,
-    GO_PASSAGE_GOTHIK       = 181125,
-    GO_ROOM_HORSEMEN        = 181119,
-    GO_PASSAGE_SAPPHIRON    = 181225,
-    GO_ROOM_KELTHUZAD       = 181228,
-
-    SPELL_ERUPTION          = 29371,
-    SPELL_SLIME             = 28801
-};
-
-enum eDoors
-{
-    DOOR_ROOM_ANUBREKHAN      = 0,
-    DOOR_PASSAGE_ANUBREKHAN,
-    DOOR_PASSAGE_FAERLINA,
-    DOOR_ROOM_MAEXXNA,
-    DOOR_ROOM_NOTH,
-    DOOR_PASSAGE_NOTH,
-    DOOR_ROOM_HEIGAN,
-    DOOR_PASSAGE_HEIGAN,
-    DOOR_ROOM_LOATHEB,
-    DOOR_ROOM_GROBBULUS,
-    DOOR_PASSAGE_GLUTH,
-    DOOR_ROOM_THADDIUS,
-    DOOR_ROOM_GOTHIK,
-    DOOR_PASSAGE_GOTHIK,
-    DOOR_ROOM_HORSEMEN,
-    DOOR_PASSAGE_SAPPHIRON,
-    DOOR_ROOM_KELTHUZAD,
-    MAX_DOOR_NAXX
+    SPELL_ERUPTION          = 29371
 };
 
 const float HeiganPos[2] = {2796, -3707};
@@ -144,529 +102,245 @@
     return 3;
 }
 
-class instance_naxxramas : public InstanceMapScript
+struct instance_naxxramas : public InstanceData
 {
-public:
-    instance_naxxramas() : InstanceMapScript("instance_naxxramas", 533) { }
-
-    InstanceScript* GetInstanceScript(InstanceMap* pMap) const
+    instance_naxxramas(Map* pMap) : InstanceData(pMap)
     {
-        return new instance_naxxramas_InstanceMapScript(pMap);
+        SetBossNumber(MAX_BOSS_NUMBER);
+        LoadDoorData(doorData);
+        LoadMinionData(minionData);
     }
 
-    struct instance_naxxramas_InstanceMapScript : public InstanceScript
+    std::set<uint64> HeiganEruptionGUID[4];
+    uint64 GothikGateGUID;
+    uint64 HorsemenChestGUID;
+    uint64 SapphironGUID;
+    uint64 uiFaerlina;
+    uint64 uiThane;
+    uint64 uiLady;
+    uint64 uiBaron;
+    uint64 uiSir;
+
+    uint64 uiThaddius;
+    uint64 uiFeugen;
+    uint64 uiStalagg;
+
+    uint64 uiKelthuzad;
+    uint64 uiKelthuzadTrigger;
+    uint64 uiPortals[4];
+
+    GOState gothikDoorState;
+
+    time_t minHorsemenDiedTime;
+    time_t maxHorsemenDiedTime;
+
+    void OnCreatureCreate(Creature* pCreature, bool add)
     {
-        instance_naxxramas_InstanceMapScript(Map* pMap) : InstanceScript(pMap)
+        switch(pCreature->GetEntry())
         {
-            //SetBossNumber(MAX_BOSS_NUMBER);
-            //LoadDoorData(doorData);
-            //LoadMinionData(minionData);
-
-            Initialize();
+            case 15989: SapphironGUID = add ? pCreature->GetGUID() : 0; return;
+            case 15953: uiFaerlina = pCreature->GetGUID(); return;
+            case 16064: uiThane = pCreature->GetGUID(); return;
+            case 16065: uiLady = pCreature->GetGUID(); return;
+            case 30549: uiBaron = pCreature->GetGUID(); return;
+            case 16063: uiSir = pCreature->GetGUID(); return;
+            case 15928: uiThaddius = pCreature->GetGUID(); return;
+            case 15930: uiFeugen = pCreature->GetGUID(); return;
+            case 15929: uiStalagg = pCreature->GetGUID(); return;
+            case 15990: uiKelthuzad = pCreature->GetGUID(); return;
         }
 
-        std::set<uint64> HeiganEruptionGUID[4];
+        AddMinion(pCreature, add);
+    }
 
-        std::set<uint64> FaerlinaMinion;
-        std::set<uint64> RazuviousMinion;
-        std::set<uint64> Horsemen;
-
-        uint32 m_auiEncounter[MAX_BOSS_NUMBER];
-
-        uint32 SlimeCheckTimer;
-
-        uint64 GothikGateGUID;
-        uint64 HorsemenChestGUID;
-        uint64 SapphironGUID;
-        uint64 uiFaerlina;
-        uint64 uiThane;
-        uint64 uiLady;
-        uint64 uiBaron;
-        uint64 uiSir;
-
-        uint64 uiThaddius;
-        uint64 uiFeugen;
-        uint64 uiStalagg;
-
-        uint64 uiKelthuzad;
-        uint64 uiKelthuzadTrigger;
-        uint64 uiPortals[4];
-        uint64 uiNaxxDoors[MAX_DOOR_NAXX];
-
-        GOState gothikDoorState;
-
-        time_t minHorsemenDiedTime;
-        time_t maxHorsemenDiedTime;
-
-        void Initialize()
+    void OnGameObjectCreate(GameObject* pGo, bool add)
+    {
+        if (pGo->GetGOInfo()->displayId == 6785 || pGo->GetGOInfo()->displayId == 1287)
         {
-            memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
-            gothikDoorState = GO_STATE_READY;
-            SlimeCheckTimer = 1000;
+            uint32 section = GetEruptionSection(pGo->GetPositionX(), pGo->GetPositionY());
+            if (add)
+                HeiganEruptionGUID[section].insert(pGo->GetGUID());
+            else
+                HeiganEruptionGUID[section].erase(pGo->GetGUID());
+            return;
         }
 
-        void OnCreatureCreate(Creature* pCreature, bool add)
+        switch(pGo->GetEntry())
         {
-            switch(pCreature->GetEntry())
+            case GO_BIRTH:
+            if (!add && SapphironGUID)
             {
-                case 15989: SapphironGUID = add ? pCreature->GetGUID() : 0; return;
-                case 15953: uiFaerlina = pCreature->GetGUID(); return;
-                case 16064: uiThane = pCreature->GetGUID(); return;
-                case 16065: uiLady = pCreature->GetGUID(); return;
-                case 30549: uiBaron = pCreature->GetGUID(); return;
-                case 16063: uiSir = pCreature->GetGUID(); return;
-                case 15928: uiThaddius = pCreature->GetGUID(); return;
-                case 15930: uiFeugen = pCreature->GetGUID(); return;
-                case 15929: uiStalagg = pCreature->GetGUID(); return;
-                case 15990: uiKelthuzad = pCreature->GetGUID(); return;
+                if (Creature *pSapphiron = instance->GetCreature(SapphironGUID))
+                    pSapphiron->AI()->DoAction(DATA_SAPPHIRON_BIRTH);
+                return;
             }
-            switch(pCreature->GetEntry())
-            {
-                case 16506:
-                case 16505:
-                    FaerlinaMinion.insert(pCreature->GetGUID());
-                    break;
-                case 16803:
-                    RazuviousMinion.insert(pCreature->GetGUID());
-                    break;
-                case 16063:
-                case 16064:
-                case 16065:
-                case 30549:
-                    Horsemen.insert(pCreature->GetGUID());
-                    break;
-            }
-
-            //AddMinion(pCreature, add);
+            case GO_GOTHIK_GATE:
+                GothikGateGUID = add ? pGo->GetGUID() : 0;
+                pGo->SetGoState(gothikDoorState);
+                break;
+            case GO_HORSEMEN_CHEST: HorsemenChestGUID = add ? pGo->GetGUID() : 0; break;
+            case GO_HORSEMEN_CHEST_HERO: HorsemenChestGUID = add ? pGo->GetGUID() : 0; break;
+            case GO_KELTHUZAD_PORTAL01: uiPortals[0] = pGo->GetGUID(); break;
+            case GO_KELTHUZAD_PORTAL02: uiPortals[1] = pGo->GetGUID(); break;
+            case GO_KELTHUZAD_PORTAL03: uiPortals[2] = pGo->GetGUID(); break;
+            case GO_KELTHUZAD_PORTAL04: uiPortals[3] = pGo->GetGUID(); break;
+            case GO_KELTHUZAD_TRIGGER: uiKelthuzadTrigger = pGo->GetGUID(); break;
         }
 
-        void OnGameObjectCreate(GameObject* pGo, bool add)
+        AddDoor(pGo, add);
+    }
+
+    void SetData(uint32 id, uint32 value)
+    {
+        switch(id)
         {
-            if (pGo->GetGOInfo()->displayId == 6785 || pGo->GetGOInfo()->displayId == 1287)
-            {
-                uint32 section = GetEruptionSection(pGo->GetPositionX(), pGo->GetPositionY());
-                if (add)
-                    HeiganEruptionGUID[section].insert(pGo->GetGUID());
-                else
-                    HeiganEruptionGUID[section].erase(pGo->GetGUID());
-                return;
-            }
+            case DATA_HEIGAN_ERUPT:
+                HeiganErupt(value);
+                break;
+            case DATA_GOTHIK_GATE:
+                if (GameObject *pGothikGate = instance->GetGameObject(GothikGateGUID))
+                    pGothikGate->SetGoState(GOState(value));
+                gothikDoorState = GOState(value);
+                break;
 
-            switch(pGo->GetEntry())
-            {
-                case GO_BIRTH:
-                if (!add && SapphironGUID)
+            case DATA_HORSEMEN0:
+            case DATA_HORSEMEN1:
+            case DATA_HORSEMEN2:
+            case DATA_HORSEMEN3:
+                if (value == NOT_STARTED)
                 {
-                    if (Creature *pSapphiron = instance->GetCreature(SapphironGUID))
-                        pSapphiron->AI()->DoAction(DATA_SAPPHIRON_BIRTH);
-                    return;
+                    minHorsemenDiedTime = 0;
+                    maxHorsemenDiedTime = 0;
                 }
-                case GO_GOTHIK_GATE:
-                    GothikGateGUID = add ? pGo->GetGUID() : 0;
-                    pGo->SetGoState(gothikDoorState);
-                    break;
-                case GO_HORSEMEN_CHEST: HorsemenChestGUID = add ? pGo->GetGUID() : 0; break;
-                case GO_HORSEMEN_CHEST_HERO: HorsemenChestGUID = add ? pGo->GetGUID() : 0; break;
-                case GO_KELTHUZAD_PORTAL01: uiPortals[0] = pGo->GetGUID(); break;
-                case GO_KELTHUZAD_PORTAL02: uiPortals[1] = pGo->GetGUID(); break;
-                case GO_KELTHUZAD_PORTAL03: uiPortals[2] = pGo->GetGUID(); break;
-                case GO_KELTHUZAD_PORTAL04: uiPortals[3] = pGo->GetGUID(); break;
-                case GO_KELTHUZAD_TRIGGER: uiKelthuzadTrigger = pGo->GetGUID(); break;
+                else if (value == DONE)
+                {
+                    time_t now = time(NULL);
 
-                case GO_ROOM_ANUBREKHAN:
-                    uiNaxxDoors[DOOR_ROOM_ANUBREKHAN] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_ANUBREKHAN] != IN_PROGRESS ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_PASSAGE_ANUBREKHAN:
-                    uiNaxxDoors[DOOR_PASSAGE_ANUBREKHAN] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_ANUBREKHAN] == DONE ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_PASSAGE_FAERLINA:
-                    uiNaxxDoors[DOOR_PASSAGE_FAERLINA] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_FAERLINA] == DONE ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_MAEXXNA:
-                    uiNaxxDoors[DOOR_ROOM_MAEXXNA] = pGo->GetGUID();
-                    pGo->SetGoState((m_auiEncounter[BOSS_FAERLINA] == DONE && m_auiEncounter[BOSS_MAEXXNA] != IN_PROGRESS) ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_NOTH:
-                    uiNaxxDoors[DOOR_ROOM_NOTH] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_FAERLINA] != IN_PROGRESS ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_PASSAGE_NOTH:
-                    uiNaxxDoors[DOOR_PASSAGE_NOTH] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_NOTH] == DONE ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_HEIGAN:
-                    uiNaxxDoors[DOOR_ROOM_HEIGAN] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_HEIGAN] != IN_PROGRESS ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_PASSAGE_HEIGAN:
-                    uiNaxxDoors[DOOR_PASSAGE_HEIGAN] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_HEIGAN] == DONE ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_LOATHEB:
-                    uiNaxxDoors[DOOR_ROOM_LOATHEB] = pGo->GetGUID();
-                    pGo->SetGoState((m_auiEncounter[BOSS_HEIGAN] == DONE && m_auiEncounter[BOSS_LOATHEB] != IN_PROGRESS) ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_GROBBULUS:
-                    uiNaxxDoors[DOOR_ROOM_GROBBULUS] = pGo->GetGUID();
-                    pGo->SetGoState((m_auiEncounter[BOSS_PATCHWERK] == DONE && m_auiEncounter[BOSS_GROBBULUS] != IN_PROGRESS) ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_PASSAGE_GLUTH:
-                    uiNaxxDoors[DOOR_PASSAGE_GLUTH] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_GLUTH] == DONE ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_THADDIUS:
-                    uiNaxxDoors[DOOR_ROOM_THADDIUS] = pGo->GetGUID();
-                    pGo->SetGoState((m_auiEncounter[BOSS_GLUTH] == DONE && m_auiEncounter[BOSS_THADDIUS] != IN_PROGRESS) ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_GOTHIK:
-                    uiNaxxDoors[DOOR_ROOM_GOTHIK] = pGo->GetGUID();
-                    pGo->SetGoState((m_auiEncounter[BOSS_RAZUVIOUS] == DONE && m_auiEncounter[BOSS_GOTHIK] != IN_PROGRESS) ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_PASSAGE_GOTHIK:
-                    uiNaxxDoors[DOOR_PASSAGE_GOTHIK] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_GOTHIK] == DONE ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_HORSEMEN:
-                    uiNaxxDoors[DOOR_ROOM_HORSEMEN] = pGo->GetGUID();
-                    pGo->SetGoState((m_auiEncounter[BOSS_GOTHIK] == DONE && m_auiEncounter[BOSS_HORSEMEN] != IN_PROGRESS) ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_PASSAGE_SAPPHIRON:
-                    uiNaxxDoors[DOOR_PASSAGE_SAPPHIRON] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_SAPPHIRON] == DONE ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
-                case GO_ROOM_KELTHUZAD:
-                    uiNaxxDoors[DOOR_ROOM_KELTHUZAD] = pGo->GetGUID();
-                    pGo->SetGoState(m_auiEncounter[BOSS_KELTHUZAD] != IN_PROGRESS ? GO_STATE_ACTIVE : GO_STATE_READY);
-                    break;
+                    if (minHorsemenDiedTime == 0)
+                        minHorsemenDiedTime = now;
 
-            }
+                    maxHorsemenDiedTime = now;
+                }
+                break;
+        }
+    }
 
-            //AddDoor(pGo, add);
+    uint64 GetData64(uint32 id)
+    {
+        switch(id)
+        {
+        case DATA_FAERLINA:
+            return uiFaerlina;
+        case DATA_THANE:
+            return uiThane;
+        case DATA_LADY:
+            return uiLady;
+        case DATA_BARON:
+            return uiBaron;
+        case DATA_SIR:
+            return uiSir;
+        case DATA_THADDIUS:
+            return uiThaddius;
+        case DATA_FEUGEN:
+            return uiFeugen;
+        case DATA_STALAGG:
+            return uiStalagg;
+        case DATA_KELTHUZAD:
+            return uiKelthuzad;
+        case DATA_KELTHUZAD_PORTAL01:
+            return uiPortals[0];
+        case DATA_KELTHUZAD_PORTAL02:
+            return uiPortals[1];
+        case DATA_KELTHUZAD_PORTAL03:
+            return uiPortals[2];
+        case DATA_KELTHUZAD_PORTAL04:
+            return uiPortals[3];
+        case DATA_KELTHUZAD_TRIGGER:
+            return uiKelthuzadTrigger;
+        }
+        return 0;
+    }
+
+    bool SetBossState(uint32 id, EncounterState state)
+    {
+        if (!InstanceData::SetBossState(id, state))
+            return false;
+
+        if (id == BOSS_HORSEMEN && state == DONE)
+        {
+            if (GameObject *pHorsemenChest = instance->GetGameObject(HorsemenChestGUID))
+                pHorsemenChest->SetRespawnTime(pHorsemenChest->GetRespawnDelay());
         }
 
-        void SetData(uint32 id, uint32 value)
+        return true;
+    }
+
+    void HeiganErupt(uint32 section)
+    {
+        for (uint32 i = 0; i < 4; ++i)
         {
-            switch(id)
+            if (i == section)
+                continue;
+
+            for (std::set<uint64>::const_iterator itr = HeiganEruptionGUID[i].begin(); itr != HeiganEruptionGUID[i].end(); ++itr)
             {
-                case DATA_HEIGAN_ERUPT:
-                    HeiganErupt(value);
-                    break;
-                case DATA_GOTHIK_GATE:
-                    if (GameObject *pGothikGate = instance->GetGameObject(GothikGateGUID))
-                        pGothikGate->SetGoState(GOState(value));
-                    gothikDoorState = GOState(value);
-                    break;
-
-                case DATA_HORSEMEN0:
-                case DATA_HORSEMEN1:
-                case DATA_HORSEMEN2:
-                case DATA_HORSEMEN3:
-                    if (value == NOT_STARTED)
-                    {
-                        minHorsemenDiedTime = 0;
-                        maxHorsemenDiedTime = 0;
-                    }
-                    else if (value == DONE)
-                    {
-                        time_t now = time(NULL);
-
-                        if (minHorsemenDiedTime == 0)
-                            minHorsemenDiedTime = now;
-
-                        maxHorsemenDiedTime = now;
-                    }
-                    break;
-            }
-        }
-
-        uint64 GetData64(uint32 id)
-        {
-            switch(id)
-            {
-            case DATA_FAERLINA:
-                return uiFaerlina;
-            case DATA_THANE:
-                return uiThane;
-            case DATA_LADY:
-                return uiLady;
-            case DATA_BARON:
-                return uiBaron;
-            case DATA_SIR:
-                return uiSir;
-            case DATA_THADDIUS:
-                return uiThaddius;
-            case DATA_FEUGEN:
-                return uiFeugen;
-            case DATA_STALAGG:
-                return uiStalagg;
-            case DATA_KELTHUZAD:
-                return uiKelthuzad;
-            case DATA_KELTHUZAD_PORTAL01:
-                return uiPortals[0];
-            case DATA_KELTHUZAD_PORTAL02:
-                return uiPortals[1];
-            case DATA_KELTHUZAD_PORTAL03:
-                return uiPortals[2];
-            case DATA_KELTHUZAD_PORTAL04:
-                return uiPortals[3];
-            case DATA_KELTHUZAD_TRIGGER:
-                return uiKelthuzadTrigger;
-            }
-            return 0;
-        }
-
-        uint32 GetData(uint32 id)
-        {
-            return GetNaxxBossState(id);
-        }
-
-        bool SetBossState(uint32 id, EncounterState state)
-        {
-            //if (!InstanceScript::SetBossState(id, state))
-            //    return false;
-
-            if(m_auiEncounter[id] != state)
-            {
-                UpdateNaxxMinionState(id,state);
-                UpdateNaxxDoorState(id,state);
-            }
-
-            if(m_auiEncounter[id] != DONE)
-                m_auiEncounter[id] = state;
-
-            if (id == BOSS_HORSEMEN && state == DONE)
-            {
-                if (GameObject *pHorsemenChest = instance->GetGameObject(HorsemenChestGUID))
-                    pHorsemenChest->SetRespawnTime(pHorsemenChest->GetRespawnDelay());
-            }
-
-            return true;
-        }
-
-        EncounterState GetNaxxBossState(uint32 id)
-        {
-            if(id < MAX_BOSS_NUMBER)
-                return ((EncounterState)m_auiEncounter[id]);
-            else return NOT_STARTED;
-        }
-
-        void UpdateNaxxDoorState(uint32 id, EncounterState state)
-        {
-            switch(id)
-            {
-            case BOSS_ANUBREKHAN:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_ANUBREKHAN], state != IN_PROGRESS);
-                HandleGameObject(uiNaxxDoors[DOOR_PASSAGE_ANUBREKHAN], state == DONE);
-                break;
-            case BOSS_FAERLINA:
-                HandleGameObject(uiNaxxDoors[DOOR_PASSAGE_FAERLINA],state == DONE);
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_MAEXXNA],state == DONE);
-                break;
-            case BOSS_MAEXXNA:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_MAEXXNA],state != IN_PROGRESS);
-                break;
-            case BOSS_NOTH:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_NOTH],state != IN_PROGRESS);
-                HandleGameObject(uiNaxxDoors[DOOR_PASSAGE_NOTH],state == DONE);
-                break;
-            case BOSS_HEIGAN:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_HEIGAN], state != IN_PROGRESS);
-                HandleGameObject(uiNaxxDoors[DOOR_PASSAGE_HEIGAN], state == DONE);
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_LOATHEB], state == DONE);
-                break;
-            case BOSS_LOATHEB:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_LOATHEB], state != IN_PROGRESS);
-                break;
-            case BOSS_PATCHWERK:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_GROBBULUS], state == DONE);
-                break;
-            case BOSS_GROBBULUS:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_GROBBULUS], state != IN_PROGRESS);
-                break;
-            case BOSS_GLUTH:
-                HandleGameObject(uiNaxxDoors[DOOR_PASSAGE_GLUTH], state == DONE);
-                HandleGameObject(uiNaxxDoors[BOSS_THADDIUS], state == DONE);
-                break;
-            case BOSS_THADDIUS:
-                HandleGameObject(uiNaxxDoors[BOSS_THADDIUS], state != IN_PROGRESS);
-                break;
-            case BOSS_RAZUVIOUS:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_GOTHIK], state == DONE);
-                break;
-            case BOSS_GOTHIK:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_GOTHIK], state != IN_PROGRESS);
-                HandleGameObject(uiNaxxDoors[DOOR_PASSAGE_GOTHIK], state == DONE);
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_HORSEMEN], state == DONE);
-                break;
-            case BOSS_HORSEMEN:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_HORSEMEN], state != IN_PROGRESS);
-                break;
-            case BOSS_SAPPHIRON:
-                HandleGameObject(uiNaxxDoors[DOOR_PASSAGE_SAPPHIRON],state == DONE);
-                break;
-            case BOSS_KELTHUZAD:
-                HandleGameObject(uiNaxxDoors[DOOR_ROOM_KELTHUZAD],state != IN_PROGRESS);
-                break;
-            }
-        }
-
-        void UpdateNaxxMinionState(uint32 id, EncounterState state)
-        {
-            switch(id)
-            {
-            case BOSS_FAERLINA:
-                for (std::set<uint64>::const_iterator i =  FaerlinaMinion.begin(); i != FaerlinaMinion.end(); ++i)
-                    if(Creature* minion = instance->GetCreature((*i)))
-                        UpdateMinionState(minion,state);
-                break;
-            case BOSS_RAZUVIOUS:
-                for (std::set<uint64>::const_iterator i =  RazuviousMinion.begin(); i != RazuviousMinion.end(); ++i)
-                    if(Creature* minion = instance->GetCreature((*i)))
-                        UpdateMinionState(minion,state);
-                break;
-            case BOSS_HORSEMEN:
-                for (std::set<uint64>::const_iterator i =  Horsemen.begin(); i != Horsemen.end(); ++i)
-                    if(Creature* minion = instance->GetCreature((*i)))
-                        UpdateMinionState(minion,state);
-                break;
-            }
-        }
-
-        void HeiganErupt(uint32 section)
-        {
-            for (uint32 i = 0; i < 4; ++i)
-            {
-                if (i == section)
-                    continue;
-
-                for (std::set<uint64>::const_iterator itr = HeiganEruptionGUID[i].begin(); itr != HeiganEruptionGUID[i].end(); ++itr)
+                if (GameObject *pHeiganEruption = instance->GetGameObject(*itr))
                 {
-                    if (GameObject *pHeiganEruption = instance->GetGameObject(*itr))
-                    {
-                        pHeiganEruption->SendCustomAnim();
-                        pHeiganEruption->CastSpell(NULL, SPELL_ERUPTION);
-                    }
+                    pHeiganEruption->SendCustomAnim();
+                    pHeiganEruption->CastSpell(NULL, SPELL_ERUPTION);
                 }
             }
         }
+    }
 
-        bool CheckAchievementCriteriaMeet(uint32 criteria_id, Player const* /*source*/, Unit const* /*target = NULL*/, uint32 /*miscvalue1 = 0*/)
+    bool CheckAchievementCriteriaMeet(uint32 criteria_id, Player const* /*source*/, Unit const* /*target = NULL*/, uint32 /*miscvalue1 = 0*/)
+    {
+        switch(criteria_id)
         {
-            switch(criteria_id)
-            {
-                case 7600:  // Criteria for achievement 2176: And They Would All Go Down Together 15sec of each other 10-man
-                    if (Difficulty(instance->GetSpawnMode()) == RAID_DIFFICULTY_10MAN_NORMAL && (maxHorsemenDiedTime - minHorsemenDiedTime) < 15)
-                        return true;
-                    return false;
-                case 7601:  // Criteria for achievement 2177: And They Would All Go Down Together 15sec of each other 25-man
-                    if (Difficulty(instance->GetSpawnMode()) == RAID_DIFFICULTY_25MAN_NORMAL && (maxHorsemenDiedTime - minHorsemenDiedTime) < 15)
-                        return true;
-                    return false;
-                case 13233: // Criteria for achievement 2186: The Immortal (25-man)
-                    // TODO.
-                    break;
-                case 13237: // Criteria for achievement 2187: The Undying (10-man)
-                    // TODO.
-                    break;
-            }
-            return false;
+            case 7600:  // Criteria for achievement 2176: And They Would All Go Down Together 15sec of each other 10-man
+                if (Difficulty(instance->GetSpawnMode()) == RAID_DIFFICULTY_10MAN_NORMAL && (maxHorsemenDiedTime - minHorsemenDiedTime) < 15)
+                    return true;
+                return false;
+            case 7601:  // Criteria for achievement 2177: And They Would All Go Down Together 15sec of each other 25-man
+                if (Difficulty(instance->GetSpawnMode()) == RAID_DIFFICULTY_25MAN_NORMAL && (maxHorsemenDiedTime - minHorsemenDiedTime) < 15)
+                    return true;
+                return false;
+            case 13233: // Criteria for achievement 2186: The Immortal (25-man)
+                // TODO.
+                break;
+            case 13237: // Criteria for achievement 2187: The Undying (10-man)
+                // TODO.
+                break;
         }
+        return false;
+    }
 
-        std::string GetSaveData()
-        {
-            std::ostringstream saveStream;
-            saveStream << "N X ";
-            for(int i = 0; i < MAX_BOSS_NUMBER; ++i)
-                saveStream << m_auiEncounter[i] << " ";
+    std::string GetSaveData()
+    {
+        std::ostringstream saveStream;
+        saveStream << GetBossSaveData() << " " << gothikDoorState;
+        return saveStream.str();
+    }
 
-            saveStream << gothikDoorState;
-            return saveStream.str();
-        }
-
-        void Load(const char * data)
-        {
-            std::istringstream loadStream(data);
-            char dataHead1, dataHead2;
-            loadStream >> dataHead1 >> dataHead2;
-            std::string newdata = loadStream.str();
-
-            uint32 buff;
-            if(dataHead1 == 'N' && dataHead2 == 'X')
-            {
-                for(int i = 0; i < MAX_BOSS_NUMBER; ++i)
-                {
-                    loadStream >> buff;
-                    m_auiEncounter[i]= buff;
-                }
-                //std::istringstream loadStream(LoadBossState(data));
-
-
-
-                loadStream >> buff;
-                gothikDoorState = GOState(buff);
-            }
-        }
-
-        void Update (uint32 diff)
-        {
-            //Water checks
-            if (SlimeCheckTimer <= diff)
-            {
-                Map::PlayerList const &PlayerList = instance->GetPlayers();
-                if (PlayerList.isEmpty())
-                    return;
-
-                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
-                {
-                    if (Player* pPlayer = i->getSource())
-                    {
-                        if (pPlayer->isAlive() && /*i->getSource()->GetPositionZ() <= -21.434931f*/pPlayer->IsInWater())
-                        {
-                            if (!pPlayer->HasAura(SPELL_SLIME))
-                            {
-                                pPlayer->CastSpell(pPlayer, SPELL_SLIME,true);
-                            }
-                        }
-                        if (!pPlayer->IsInWater())
-                            pPlayer->RemoveAurasDueToSpell(SPELL_SLIME);
-                    }
-                }
-                SlimeCheckTimer = 1000;//remove stress from core
-            } else SlimeCheckTimer -= diff;
-        }
-    };
-
+    void Load(const char * data)
+    {
+        std::istringstream loadStream(LoadBossState(data));
+        uint32 buff;
+        loadStream >> buff;
+        gothikDoorState = GOState(buff);
+    }
 };
 
-class AreaTrigger_at_naxxramas_frostwyrm_wing : public AreaTriggerScript
+InstanceData* GetInstanceData_instance_naxxramas(Map* pMap)
 {
-    public:
-
-        AreaTrigger_at_naxxramas_frostwyrm_wing()
-            : AreaTriggerScript("at_naxxramas_frostwyrm_wing")
-        {
-        }
-
-        bool OnTrigger(Player* player, AreaTriggerEntry const* trigger)
-        {
-            if (player->isGameMaster())
-                return false;
-
-            InstanceScript *data = player->GetInstanceScript();
-            if (data)
-                for (uint32 i = BOSS_ANUBREKHAN; i < BOSS_SAPPHIRON; ++i)
-                    if (data->GetBossState(i) != DONE)
-                        return true;
-
-            return false;
-        }
-};
+    return new instance_naxxramas(pMap);
+}
 
 void AddSC_instance_naxxramas()
 {
-    new instance_naxxramas();
-    new AreaTrigger_at_naxxramas_frostwyrm_wing();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "instance_naxxramas";
+    newscript->GetInstanceData = &GetInstanceData_instance_naxxramas;
+    newscript->RegisterSelf();
 }
diff --git a/src/server/scripts/Northrend/Naxxramas/naxxramas.h b/src/server/scripts/Northrend/Naxxramas/naxxramas.h
--- a/src/server/scripts/Northrend/Naxxramas/naxxramas.h
+++ b/src/server/scripts/Northrend/Naxxramas/naxxramas.h
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2008 - 2010 Trinity <http://www.trinitycore.org/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
  *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef DEF_NAXXRAMAS_H
