# HG changeset patch
# User asniker
# Date 1288534496 -18000
# Node ID fbdbf66b64d6f04d3a30a941056d38534dfd6b16
# Parent  d43d682d476c39573cd851c53b944fed3be12edc
big fix spells

diff --git a/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp b/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp
--- a/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp
+++ b/src/server/game/AI/ScriptedAI/ScriptedCreature.cpp
@@ -568,35 +568,35 @@
         switch (itr->first)
         {
             case BOUNDARY_N:
-                if (me->GetPositionX() > itr->second)
+                if (who->GetPositionX() > itr->second)
                     return false;
                 break;
             case BOUNDARY_S:
-                if (me->GetPositionX() < itr->second)
+                if (who->GetPositionX() < itr->second)
                     return false;
                 break;
             case BOUNDARY_E:
-                if (me->GetPositionY() < itr->second)
+                if (who->GetPositionY() < itr->second)
                     return false;
                 break;
             case BOUNDARY_W:
-                if (me->GetPositionY() > itr->second)
+                if (who->GetPositionY() > itr->second)
                     return false;
                 break;
             case BOUNDARY_NW:
-                if (me->GetPositionX() + me->GetPositionY() > itr->second)
+                if (who->GetPositionX() + who->GetPositionY() > itr->second)
                     return false;
                 break;
             case BOUNDARY_SE:
-                if (me->GetPositionX() + me->GetPositionY() < itr->second)
+                if (who->GetPositionX() + who->GetPositionY() < itr->second)
                     return false;
                 break;
             case BOUNDARY_NE:
-                if (me->GetPositionX() - me->GetPositionY() > itr->second)
+                if (who->GetPositionX() - who->GetPositionY() > itr->second)
                     return false;
                 break;
             case BOUNDARY_SW:
-                if (me->GetPositionX() - me->GetPositionY() < itr->second)
+                if (who->GetPositionX() - who->GetPositionY() < itr->second)
                     return false;
                 break;
             default:
diff --git a/src/server/game/Achievements/AchievementMgr.cpp b/src/server/game/Achievements/AchievementMgr.cpp
--- a/src/server/game/Achievements/AchievementMgr.cpp
+++ b/src/server/game/Achievements/AchievementMgr.cpp
@@ -781,6 +781,14 @@
 
             // specialized cases
 
+            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA:
+            {
+                if (achievementCriteria->honorable_kill_at_area.areaID != GetPlayer()->GetAreaId())
+                    continue;
+
+                SetCriteriaProgress(achievementCriteria, 1, PROGRESS_ACCUMULATE);
+                break;
+            }
             case ACHIEVEMENT_CRITERIA_TYPE_WIN_BG:
             {
                 // AchievementMgr::UpdateAchievementCriteria might also be called on login - skip in this case
@@ -1466,7 +1474,6 @@
                 break;
             // FIXME: not triggered in code as result, need to implement
             case ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_RAID:
-            case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA:
             case ACHIEVEMENT_CRITERIA_TYPE_WIN_ARENA:
             case ACHIEVEMENT_CRITERIA_TYPE_PLAY_ARENA:
             case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL:
@@ -1631,6 +1638,8 @@
             return progress->counter >= 9000;
         case ACHIEVEMENT_CRITERIA_TYPE_USE_LFD_TO_GROUP_WITH_PLAYERS:
             return progress->counter >= achievementCriteria->use_lfg.dungeonsComplete;
+        case ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA:
+            return progress->counter >= achievementCriteria->honorable_kill_at_area.killCount;
         // handle all statistic-only criteria here
         case ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_BATTLEGROUND:
         case ACHIEVEMENT_CRITERIA_TYPE_DEATH_AT_MAP:
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -742,8 +742,8 @@
             if (sWorld.getBoolConfig(CONFIG_ARENA_LOG_EXTENDED_INFO))
                 for (Battleground::BattlegroundScoreMap::const_iterator itr = GetPlayerScoresBegin(); itr != GetPlayerScoresEnd(); itr++)
                     if (Player* player = sObjectMgr.GetPlayer(itr->first))
-                        sLog.outArena("Statistics for %s (GUID: " UI64FMTD ", Team: %d, IP: %s): %u damage, %u healing, %u killing blows", player->GetName(), itr->first, player->GetArenaTeamId(m_ArenaType == 5 ? 2 : m_ArenaType == 3), player->GetSession()->GetRemoteAddress().c_str(), itr->second->DamageDone, itr->second->HealingDone, itr->second->KillingBlows);
-        }
+         sLog.outArena("Statistics for %s (GUID: " UI64FMTD ", Team: %d, IP: %s): %u damage, %u healing, %u killing blows", player->GetName(), itr->first, player->GetArenaTeamId(m_ArenaType == 5 ? 2 : m_ArenaType == 3), player->GetSession()->GetRemoteAddress().c_str(), itr->second->DamageDone, itr->second->HealingDone, itr->second->KillingBlows);
+		}
         else
         {
             SetArenaTeamRatingChangeForTeam(ALLIANCE, 0);
@@ -1021,6 +1021,7 @@
 
         sLog.outDetail("BATTLEGROUND: Removed player %s from Battleground.", plr->GetName());
         plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, ACHIEVEMENT_CRITERIA_CONDITION_MAP, GetMapId(), true);
+        plr->GetAchievementMgr().ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, ACHIEVEMENT_CRITERIA_CONDITION_MAP, GetMapId(), true);
     }
 
     //battleground object will be deleted next Battleground::Update() call
@@ -1059,6 +1060,7 @@
 {
     SetStartTime(0);
     SetLastResurrectTime(0);
+  
     // add BG to free slot queue
     AddToBGFreeSlotQueue();
 
@@ -1173,7 +1175,9 @@
         }
         else
         {
-            group->AddMember(plr_guid, plr->GetName());
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            group->AddMember(plr_guid, plr->GetName(),trans);
+            CharacterDatabase.CommitTransaction(trans);
             if (Group* originalGroup = plr->GetOriginalGroup())
                 if (originalGroup->IsLeader(plr_guid))
                     group->ChangeLeader(plr_guid);
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -342,6 +342,7 @@
                         *data << uint32(0);
                         break;
                 }
+                break;
             case BATTLEGROUND_AV:
                 *data << uint32(0x00000005);                    // count of next fields
                 *data << uint32(((BattlegroundAVScore*)itr2->second)->GraveyardsAssaulted); // GraveyardsAssaulted
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
@@ -174,6 +174,17 @@
     }
 }
 
+void BattlegroundAB::HandleKillPlayer(Player *player, Player *killer)
+{
+    if (GetStatus() != STATUS_IN_PROGRESS)
+        return;
+
+    if (killer->GetAreaId() == player->GetAreaId()) 
+        killer->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA);
+    
+    Battleground::HandleKillPlayer(player, killer);
+}
+
 void BattlegroundAB::StartingEventCloseDoors()
 {
     // despawn banners, auras and buffs
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.h b/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.h
@@ -254,6 +254,7 @@
         virtual void StartingEventCloseDoors();
         virtual void StartingEventOpenDoors();
         void RemovePlayer(Player *plr,uint64 guid);
+        void HandleKillPlayer(Player* player, Player *killer);
         void HandleAreaTrigger(Player *Source, uint32 Trigger);
         virtual bool SetupBattleground();
         virtual void Reset();
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
@@ -54,6 +54,9 @@
     if (GetStatus() != STATUS_IN_PROGRESS)
         return;
 
+    if (killer->GetAreaId() == player->GetAreaId()) 
+        killer->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA);
+    
     Battleground::HandleKillPlayer(player, killer);
     UpdateScore(player->GetTeam(),-1);
 }
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
--- a/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundEY.cpp
@@ -581,6 +581,9 @@
     if (GetStatus() != STATUS_IN_PROGRESS)
         return;
 
+    if (killer->GetAreaId() == player->GetAreaId()) 
+        killer->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA);
+
     Battleground::HandleKillPlayer(player, killer);
     EventPlayerDroppedFlag(player);
 }
diff --git a/src/server/game/Chat/Commands/Level0.cpp b/src/server/game/Chat/Commands/Level0.cpp
--- a/src/server/game/Chat/Commands/Level0.cpp
+++ b/src/server/game/Chat/Commands/Level0.cpp
@@ -1,303 +1,303 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- */
-
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "World.h"
-#include "Player.h"
-#include "Opcodes.h"
-#include "Chat.h"
-#include "ObjectAccessor.h"
-#include "Language.h"
-#include "AccountMgr.h"
-#include "SystemConfig.h"
-#include "revision.h"
-#include "Util.h"
-
-bool ChatHandler::HandleHelpCommand(const char* args)
-{
-    char* cmd = strtok((char*)args, " ");
-    if (!cmd)
-    {
-        ShowHelpForCommand(getCommandTable(), "help");
-        ShowHelpForCommand(getCommandTable(), "");
-    }
-    else
-    {
-        if (!ShowHelpForCommand(getCommandTable(), cmd))
-            SendSysMessage(LANG_NO_HELP_CMD);
-    }
-
-    return true;
-}
-
-bool ChatHandler::HandleCommandsCommand(const char* /*args*/)
-{
-    ShowHelpForCommand(getCommandTable(), "");
-    return true;
-}
-
-bool ChatHandler::HandleAccountCommand(const char* /*args*/)
-{
-    AccountTypes gmlevel = m_session->GetSecurity();
-    PSendSysMessage(LANG_ACCOUNT_LEVEL, uint32(gmlevel));
-    return true;
-}
-
-bool ChatHandler::HandleStartCommand(const char* /*args*/)
-{
-    Player *chr = m_session->GetPlayer();
-
-    if (chr->isInFlight())
-    {
-        SendSysMessage(LANG_YOU_IN_FLIGHT);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    if (chr->isInCombat())
-    {
-        SendSysMessage(LANG_YOU_IN_COMBAT);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    if ((chr->isDead()) || (chr->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST)))
-    {
-    // if player is dead and stuck, send ghost to graveyard
-    chr->RepopAtGraveyard();
-    return true;
-    }
-
-    // cast spell Stuck
-    chr->CastSpell(chr, 7355, false);
-    return true;
-}
-
-bool ChatHandler::HandleServerInfoCommand(const char* /*args*/)
-{
-    uint32 PlayersNum = sWorld.GetPlayerCount();
-    uint32 MaxPlayersNum = sWorld.GetMaxPlayerCount();
-    uint32 activeClientsNum = sWorld.GetActiveSessionCount();
-    uint32 queuedClientsNum = sWorld.GetQueuedSessionCount();
-    uint32 maxActiveClientsNum = sWorld.GetMaxActiveSessionCount();
-    uint32 maxQueuedClientsNum = sWorld.GetMaxQueuedSessionCount();
-    std::string uptime = secsToTimeString(sWorld.GetUptime());
-    uint32 updateTime = sWorld.GetUpdateTime();
-
-    PSendSysMessage(_FULLVERSION);
-    PSendSysMessage(LANG_CONNECTED_PLAYERS, PlayersNum, MaxPlayersNum);
-    PSendSysMessage(LANG_CONNECTED_USERS, activeClientsNum, maxActiveClientsNum, queuedClientsNum, maxQueuedClientsNum);
-    PSendSysMessage(LANG_UPTIME, uptime.c_str());
-    PSendSysMessage("Update time diff: %u.", updateTime);
-
-    return true;
-}
-
-bool ChatHandler::HandleDismountCommand(const char* /*args*/)
-{
-    //If player is not mounted, so go out :)
-    if (!m_session->GetPlayer()->IsMounted())
-    {
-        SendSysMessage(LANG_CHAR_NON_MOUNTED);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    if (m_session->GetPlayer()->isInFlight())
-    {
-        SendSysMessage(LANG_YOU_IN_FLIGHT);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    m_session->GetPlayer()->Unmount();
-    m_session->GetPlayer()->RemoveAurasByType(SPELL_AURA_MOUNTED);
-    return true;
-}
-
-bool ChatHandler::HandleSaveCommand(const char* /*args*/)
-{
-    Player *player = m_session->GetPlayer();
-
-    // save GM account without delay and output message
-    if (m_session->GetSecurity() > SEC_PLAYER)
-    {
-        player->SaveToDB();
-        SendSysMessage(LANG_PLAYER_SAVED);
-        return true;
-    }
-
-    // save if the player has last been saved over 20 seconds ago
-    uint32 save_interval = sWorld.getIntConfig(CONFIG_INTERVAL_SAVE);
-    if (save_interval == 0 || (save_interval > 20*IN_MILLISECONDS && player->GetSaveTimer() <= save_interval - 20*IN_MILLISECONDS))
-        player->SaveToDB();
-
-    return true;
-}
-
-bool ChatHandler::HandleGMListIngameCommand(const char* /*args*/)
-{
-    bool first = true;
-
-    ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, *HashMapHolder<Player>::GetLock(), true);
-    HashMapHolder<Player>::MapType &m = sObjectAccessor.GetPlayers();
-    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
-    {
-        AccountTypes itr_sec = itr->second->GetSession()->GetSecurity();
-        if ((itr->second->isGameMaster() || (itr_sec > SEC_PLAYER && itr_sec <= AccountTypes(sWorld.getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
-            (!m_session || itr->second->IsVisibleGloballyFor(m_session->GetPlayer())))
-        {
-            if (first)
-            {
-                SendSysMessage(LANG_GMS_ON_SRV);
-                first = false;
-            }
-
-            SendSysMessage(GetNameLink(itr->second).c_str());
-        }
-    }
-
-    if (first)
-        SendSysMessage(LANG_GMS_NOT_LOGGED);
-
-    return true;
-}
-
-bool ChatHandler::HandleAccountPasswordCommand(const char* args)
-{
-    if (!*args)
-    {
-        SendSysMessage(LANG_CMD_SYNTAX);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    char *old_pass = strtok((char*)args, " ");
-    char *new_pass = strtok(NULL, " ");
-    char *new_pass_c  = strtok(NULL, " ");
-
-    if (!old_pass || !new_pass || !new_pass_c)
-    {
-        SendSysMessage(LANG_CMD_SYNTAX);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    std::string password_old = old_pass;
-    std::string password_new = new_pass;
-    std::string password_new_c = new_pass_c;
-
-    if (!sAccountMgr.CheckPassword(m_session->GetAccountId(), password_old))
-    {
-        SendSysMessage(LANG_COMMAND_WRONGOLDPASSWORD);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    if (strcmp(new_pass, new_pass_c) != 0)
-    {
-        SendSysMessage(LANG_NEW_PASSWORDS_NOT_MATCH);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    AccountOpResult result = sAccountMgr.ChangePassword(m_session->GetAccountId(), password_new);
-    switch(result)
-    {
-        case AOR_OK:
-            SendSysMessage(LANG_COMMAND_PASSWORD);
-            break;
-        case AOR_PASS_TOO_LONG:
-            SendSysMessage(LANG_PASSWORD_TOO_LONG);
-            SetSentErrorMessage(true);
-            return false;
-        default:
-            SendSysMessage(LANG_COMMAND_NOTCHANGEPASSWORD);
-            SetSentErrorMessage(true);
-            return false;
-    }
-
-    return true;
-}
-
-bool ChatHandler::HandleAccountAddonCommand(const char* args)
-{
-    if (!*args)
-    {
-        SendSysMessage(LANG_CMD_SYNTAX);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    char *szExp = strtok((char*)args, " ");
-
-    uint32 account_id = m_session->GetAccountId();
-
-    int expansion = atoi(szExp);                                    //get int anyway (0 if error)
-    if (expansion < 0 || uint8(expansion) > sWorld.getIntConfig(CONFIG_EXPANSION))
-    {
-        SendSysMessage(LANG_IMPROPER_VALUE);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    // No SQL injection
-    LoginDatabase.PExecute("UPDATE account SET expansion = '%d' WHERE id = '%u'", expansion, account_id);
-    PSendSysMessage(LANG_ACCOUNT_ADDON, expansion);
-    return true;
-}
-
-bool ChatHandler::HandleAccountLockCommand(const char* args)
-{
-    if (!*args)
-    {
-        SendSysMessage(LANG_USE_BOL);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    std::string argstr = (char*)args;
-    if (argstr == "on")
-    {
-        LoginDatabase.PExecute("UPDATE account SET locked = '1' WHERE id = '%d'",m_session->GetAccountId());
-        PSendSysMessage(LANG_COMMAND_ACCLOCKLOCKED);
-        return true;
-    }
-
-    if (argstr == "off")
-    {
-        LoginDatabase.PExecute("UPDATE account SET locked = '0' WHERE id = '%d'",m_session->GetAccountId());
-        PSendSysMessage(LANG_COMMAND_ACCLOCKUNLOCKED);
-        return true;
-    }
-
-    SendSysMessage(LANG_USE_BOL);
-    SetSentErrorMessage(true);
-    return false;
-}
-
-/// Display the 'Message of the day' for the realm
-bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
-{
-    PSendSysMessage(LANG_MOTD_CURRENT, sWorld.GetMotd());
-    return true;
-}
-
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "Common.h"
+#include "DatabaseEnv.h"
+#include "World.h"
+#include "Player.h"
+#include "Opcodes.h"
+#include "Chat.h"
+#include "ObjectAccessor.h"
+#include "Language.h"
+#include "AccountMgr.h"
+#include "SystemConfig.h"
+#include "revision.h"
+#include "Util.h"
+
+bool ChatHandler::HandleHelpCommand(const char* args)
+{
+    char* cmd = strtok((char*)args, " ");
+    if (!cmd)
+    {
+        ShowHelpForCommand(getCommandTable(), "help");
+        ShowHelpForCommand(getCommandTable(), "");
+    }
+    else
+    {
+        if (!ShowHelpForCommand(getCommandTable(), cmd))
+            SendSysMessage(LANG_NO_HELP_CMD);
+    }
+
+    return true;
+}
+
+bool ChatHandler::HandleCommandsCommand(const char* /*args*/)
+{
+    ShowHelpForCommand(getCommandTable(), "");
+    return true;
+}
+
+bool ChatHandler::HandleAccountCommand(const char* /*args*/)
+{
+    AccountTypes gmlevel = m_session->GetSecurity();
+    PSendSysMessage(LANG_ACCOUNT_LEVEL, uint32(gmlevel));
+    return true;
+}
+
+bool ChatHandler::HandleStartCommand(const char* /*args*/)
+{
+    Player *chr = m_session->GetPlayer();
+
+    if (chr->isInFlight())
+    {
+        SendSysMessage(LANG_YOU_IN_FLIGHT);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (chr->isInCombat())
+    {
+        SendSysMessage(LANG_YOU_IN_COMBAT);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if ((chr->isDead()) || (chr->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST)))
+    {
+    // if player is dead and stuck, send ghost to graveyard
+    chr->RepopAtGraveyard();
+    return true;
+    }
+
+    // cast spell Stuck
+    chr->CastSpell(chr, 7355, false);
+    return true;
+}
+
+bool ChatHandler::HandleServerInfoCommand(const char* /*args*/)
+{
+    uint32 PlayersNum = sWorld.GetPlayerCount();
+    uint32 MaxPlayersNum = sWorld.GetMaxPlayerCount();
+    uint32 activeClientsNum = sWorld.GetActiveSessionCount();
+    uint32 queuedClientsNum = sWorld.GetQueuedSessionCount();
+    uint32 maxActiveClientsNum = sWorld.GetMaxActiveSessionCount();
+    uint32 maxQueuedClientsNum = sWorld.GetMaxQueuedSessionCount();
+    std::string uptime = secsToTimeString(sWorld.GetUptime());
+    uint32 updateTime = sWorld.GetUpdateTime();
+
+    PSendSysMessage(_FULLVERSION);
+    PSendSysMessage(LANG_CONNECTED_PLAYERS, PlayersNum, MaxPlayersNum);
+    PSendSysMessage(LANG_CONNECTED_USERS, activeClientsNum, maxActiveClientsNum, queuedClientsNum, maxQueuedClientsNum);
+    PSendSysMessage(LANG_UPTIME, uptime.c_str());
+    PSendSysMessage("Update time diff: %u.", updateTime);
+
+    return true;
+}
+
+bool ChatHandler::HandleDismountCommand(const char* /*args*/)
+{
+    //If player is not mounted, so go out :)
+    if (!m_session->GetPlayer()->IsMounted())
+    {
+        SendSysMessage(LANG_CHAR_NON_MOUNTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (m_session->GetPlayer()->isInFlight())
+    {
+        SendSysMessage(LANG_YOU_IN_FLIGHT);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    m_session->GetPlayer()->Unmount();
+    m_session->GetPlayer()->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    return true;
+}
+
+bool ChatHandler::HandleSaveCommand(const char* /*args*/)
+{
+    Player *player = m_session->GetPlayer();
+
+    // save GM account without delay and output message
+    if (m_session->GetSecurity() > SEC_PLAYER)
+    {
+        player->SaveToDB();
+        SendSysMessage(LANG_PLAYER_SAVED);
+        return true;
+    }
+
+    // save if the player has last been saved over 20 seconds ago
+    uint32 save_interval = sWorld.getIntConfig(CONFIG_INTERVAL_SAVE);
+    if (save_interval == 0 || (save_interval > 20*IN_MILLISECONDS && player->GetSaveTimer() <= save_interval - 20*IN_MILLISECONDS))
+        player->SaveToDB();
+
+    return true;
+}
+
+bool ChatHandler::HandleGMListIngameCommand(const char* /*args*/)
+{
+    bool first = true;
+
+    ACE_GUARD_RETURN(ACE_Thread_Mutex, guard, *HashMapHolder<Player>::GetLock(), true);
+    HashMapHolder<Player>::MapType &m = sObjectAccessor.GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        AccountTypes itr_sec = itr->second->GetSession()->GetSecurity();
+        if ((itr->second->isGameMaster() || (itr_sec > SEC_PLAYER && itr_sec <= AccountTypes(sWorld.getIntConfig(CONFIG_GM_LEVEL_IN_GM_LIST)))) &&
+            (!m_session || itr->second->IsVisibleGloballyFor(m_session->GetPlayer())))
+        {
+            if (first)
+            {
+                SendSysMessage(LANG_GMS_ON_SRV);
+                first = false;
+            }
+
+            SendSysMessage(GetNameLink(itr->second).c_str());
+        }
+    }
+
+    if (first)
+        SendSysMessage(LANG_GMS_NOT_LOGGED);
+
+    return true;
+}
+
+bool ChatHandler::HandleAccountPasswordCommand(const char* args)
+{
+    if (!*args)
+    {
+        SendSysMessage(LANG_CMD_SYNTAX);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *old_pass = strtok((char*)args, " ");
+    char *new_pass = strtok(NULL, " ");
+    char *new_pass_c  = strtok(NULL, " ");
+
+    if (!old_pass || !new_pass || !new_pass_c)
+    {
+        SendSysMessage(LANG_CMD_SYNTAX);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string password_old = old_pass;
+    std::string password_new = new_pass;
+    std::string password_new_c = new_pass_c;
+
+    if (!sAccountMgr.CheckPassword(m_session->GetAccountId(), password_old))
+    {
+        SendSysMessage(LANG_COMMAND_WRONGOLDPASSWORD);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (strcmp(new_pass, new_pass_c) != 0)
+    {
+        SendSysMessage(LANG_NEW_PASSWORDS_NOT_MATCH);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    AccountOpResult result = sAccountMgr.ChangePassword(m_session->GetAccountId(), password_new);
+    switch(result)
+    {
+        case AOR_OK:
+            SendSysMessage(LANG_COMMAND_PASSWORD);
+            break;
+        case AOR_PASS_TOO_LONG:
+            SendSysMessage(LANG_PASSWORD_TOO_LONG);
+            SetSentErrorMessage(true);
+            return false;
+        default:
+            SendSysMessage(LANG_COMMAND_NOTCHANGEPASSWORD);
+            SetSentErrorMessage(true);
+            return false;
+    }
+
+    return true;
+}
+
+bool ChatHandler::HandleAccountAddonCommand(const char* args)
+{
+    if (!*args)
+    {
+        SendSysMessage(LANG_CMD_SYNTAX);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *szExp = strtok((char*)args, " ");
+
+    uint32 account_id = m_session->GetAccountId();
+
+    int expansion = atoi(szExp);                                    //get int anyway (0 if error)
+    if (expansion < 0 || uint8(expansion) > sWorld.getIntConfig(CONFIG_EXPANSION))
+    {
+        SendSysMessage(LANG_IMPROPER_VALUE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // No SQL injection
+    LoginDatabase.PExecute("UPDATE account SET expansion = '%d' WHERE id = '%u'", expansion, account_id);
+    PSendSysMessage(LANG_ACCOUNT_ADDON, expansion);
+    return true;
+}
+
+bool ChatHandler::HandleAccountLockCommand(const char* args)
+{
+    if (!*args)
+    {
+        SendSysMessage(LANG_USE_BOL);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string argstr = (char*)args;
+    if (argstr == "on")
+    {
+        LoginDatabase.PExecute("UPDATE account SET locked = '1' WHERE id = '%d'",m_session->GetAccountId());
+        PSendSysMessage(LANG_COMMAND_ACCLOCKLOCKED);
+        return true;
+    }
+
+    if (argstr == "off")
+    {
+        LoginDatabase.PExecute("UPDATE account SET locked = '0' WHERE id = '%d'",m_session->GetAccountId());
+        PSendSysMessage(LANG_COMMAND_ACCLOCKUNLOCKED);
+        return true;
+    }
+
+    SendSysMessage(LANG_USE_BOL);
+    SetSentErrorMessage(true);
+    return false;
+}
+
+/// Display the 'Message of the day' for the realm
+bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
+{
+    PSendSysMessage(LANG_MOTD_CURRENT, sWorld.GetMotd());
+    return true;
+}
+
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -1573,7 +1573,9 @@
             else if (plr->GetGroup() != grp)
             {
                 grp->SetLfgQueued(false);
-                grp->AddMember(plr->GetGUID(), plr->GetName());
+                SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                grp->AddMember(plr->GetGUID(), plr->GetName(),trans);
+                CharacterDatabase.CommitTransaction(trans);
             }
             plr->SetLfgUpdate(true);
 
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -766,6 +766,7 @@
                 break;
             case CREATURE_ELITE_WORLDBOSS:
                 m_corpseDelay = sWorld.getIntConfig(CONFIG_CORPSE_DECAY_WORLDBOSS);
+                ApplySpellImmune(0,IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
                 break;
             default:
                 m_corpseDelay = sWorld.getIntConfig(CONFIG_CORPSE_DECAY_NORMAL);
@@ -2455,21 +2456,21 @@
     }
 
     return 0;
-}
-
- 	void Creature::FarTeleportTo(Map* map, float X, float Y, float Z, float O)
- 	{
- 	    InterruptNonMeleeSpells(true);
- 	    CombatStop();
- 	    ClearComboPointHolders();
- 	    DeleteThreatList();
- 	    GetMotionMaster()->Clear(false);
- 	    DestroyForNearbyPlayers();
-
- 	    RemoveFromWorld();
- 	    ResetMap();
- 	    SetMap(map);
- 	    AddToWorld();
-
- 	    SetPosition(X, Y, Z, O, true);
+}
+
+ 	void Creature::FarTeleportTo(Map* map, float X, float Y, float Z, float O)
+ 	{
+ 	    InterruptNonMeleeSpells(true);
+ 	    CombatStop();
+ 	    ClearComboPointHolders();
+ 	    DeleteThreatList();
+ 	    GetMotionMaster()->Clear(false);
+ 	    DestroyForNearbyPlayers();
+
+ 	    RemoveFromWorld();
+ 	    ResetMap();
+ 	    SetMap(map);
+ 	    AddToWorld();
+
+ 	    SetPosition(X, Y, Z, O, true);
  	}
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -1694,7 +1694,8 @@
                 if (Battleground* bg = pwho->GetBattleground())
                     bg->DestroyGate(pwho, this, m_goInfo->building.destroyedEvent);
             hitType = BG_OBJECT_DMG_HIT_TYPE_JUST_DESTROYED;
-            sScriptMgr.OnGameObjectDestroyed(pwho, this, m_goInfo->building.destroyedEvent);
+            if(pwho)
+                sScriptMgr.OnGameObjectDestroyed(pwho, this, m_goInfo->building.destroyedEvent);
         }
         if (pwho)
             if (Battleground* bg = pwho->GetBattleground())
diff --git a/src/server/game/Entities/Pet/Pet.cpp b/src/server/game/Entities/Pet/Pet.cpp
--- a/src/server/game/Entities/Pet/Pet.cpp
+++ b/src/server/game/Entities/Pet/Pet.cpp
@@ -1254,6 +1254,9 @@
             else
                 remaincharges = 0;
 
+            if (maxduration == -1 && caster_guid != GetGUID())
+                caster_guid = GetGUID();
+
             if (Aura * aura = Aura::TryCreate(spellproto, effmask, this, NULL, &baseDamage[0], NULL, caster_guid))
             {
                 if (!aura->CanBeSaved())
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -56,7 +56,7 @@
 #include "BattlegroundAV.h"
 #include "BattlegroundMgr.h"
 #include "OutdoorPvP.h"
-#include "OutdoorPvPMgr.h""
+#include "OutdoorPvPMgr.h"
 #include "ArenaTeam.h"
 #include "Chat.h"
 #include "Spell.h"
@@ -1186,7 +1186,7 @@
                     EnvironmentalDamage(DAMAGE_LAVA, damage);
                 // need to skip Slime damage in Undercity,
                 // maybe someone can find better way to handle environmental damage
-                else if (m_zoneUpdateId != 1497)
+                else if (m_zoneUpdateId != 1497 || m_zoneUpdateId != 3968)
                     EnvironmentalDamage(DAMAGE_SLIME, damage);
             }
         }
@@ -3928,10 +3928,11 @@
         next = itr;
         ++next;
         SpellEntry const * entry = sSpellStore.LookupEntry(itr->first);
-        // check if spellentry is present and if the cooldown is less or equal to 10 min
+         // check if spellentry is present and if the cooldown is less than 15 mins
         if (entry &&
-            entry->RecoveryTime <= 10 * MINUTE * IN_MILLISECONDS &&
-            entry->CategoryRecoveryTime <= 10 * MINUTE * IN_MILLISECONDS)
+			entry->RecoveryTime <= 15 * MINUTE * IN_MILLISECONDS &&
+            entry->CategoryRecoveryTime <= 15 * MINUTE * IN_MILLISECONDS &&
+            itr->second.end - time(NULL) <= 15 * MINUTE)
         {
             // remove & notify
             RemoveSpellCooldown(itr->first, true);
@@ -7570,6 +7571,9 @@
             case ITEM_MOD_SPELL_PENETRATION:
                 ApplySpellPenetrationBonus(int32(val), apply);
                 break;
+            case ITEM_MOD_BLOCK_VALUE:
+                HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(val), apply);
+                break;
             // depricated item mods
             case ITEM_MOD_SPELL_HEALING_DONE:
             case ITEM_MOD_SPELL_DAMAGE_DONE:
@@ -8029,7 +8033,20 @@
                 if (IsPositiveSpell(pEnchant->spellid[s]))
                     CastSpell(this, pEnchant->spellid[s], true, item);
                 else
+                {
                     CastSpell(target, pEnchant->spellid[s], true, item);
+                    // Deadly Poison
+                    if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] == 0x10000 && spellInfo->SpellFamilyFlags[1] == 0x80000) {
+                        if (Aura * aur = target->GetAura(pEnchant->spellid[s], GetGUID()))
+                            if (aur->GetStackAmount() == 5)
+                                if (Item* Weapon = GetWeaponForAttack(attType == BASE_ATTACK ? OFF_ATTACK : BASE_ATTACK, true))
+                                    if (SpellItemEnchantmentEntry const *Poison = sSpellItemEnchantmentStore.LookupEntry(Weapon->GetEnchantmentId(EnchantmentSlot(TEMP_ENCHANTMENT_SLOT)))) {
+                                        SpellEntry const* poisonEntry = sSpellStore.LookupEntry(Poison->spellid[s]);
+                                        if(poisonEntry && poisonEntry->Dispel == DISPEL_POISON)
+                                            CastSpell(target, poisonEntry, true, Weapon);
+                                    }
+                    }
+                }
             }
         }
     }
@@ -18201,6 +18218,7 @@
                   // also THIS item should be somewhere else, cheat attempt
                   item->FSetState(ITEM_REMOVED); // we are IN updateQueue right now, can't use SetState which modifies the queue
                   DeleteRefundReference(item->GetGUIDLow());
+				  sWorld.BanAccount(BAN_CHARACTER, this->GetName(),secsToTimeString(TimeStringToSecs("-1"),true).c_str(),"Duplication WPE hack.","Server core");
                   // don't skip, let the switch delete it
                   //continue;
               }
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -2244,7 +2244,7 @@
         float m_homebindZ;
 
         WorldLocation GetStartPosition() const;
-
+        
         // currently visible objects at player client
         typedef std::set<uint64> ClientGUIDs;
         ClientGUIDs m_clientGUIDs;
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -147,7 +147,7 @@
     // Magic damage modifiers implemented in Unit::SpellDamageBonus
     // This information for client side use only
     // Get healing bonus for all schools
-    SetStatInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, SpellBaseHealingBonus(SPELL_SCHOOL_MASK_ALL));
+    SetStatInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, SpellBaseHealingBonus(SPELL_SCHOOL_MASK_ALL, NULL));
     // Get damage bonus for all schools
     for (int i = SPELL_SCHOOL_HOLY; i < MAX_SPELL_SCHOOL; ++i)
         SetStatInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i, SpellBaseDamageBonus(SpellSchoolMask(1 << i)));
@@ -941,6 +941,8 @@
 #define ENTRY_TREANT            1964
 #define ENTRY_FIRE_ELEMENTAL    15438
 #define ENTRY_GHOUL             26125
+#define ENTRY_VIPER             19921
+#define ENTRY_VEN_SNAKE         19833
 
 bool Guardian::UpdateStats(Stats stat)
 {
@@ -1073,7 +1075,7 @@
     UnitMods unitMod = UNIT_MOD_ARMOR;
 
     // hunter and warlock pets gain 35% of owner's armor value
-    if (isPet())
+    if(isPet()&&!IsPetGhoul())
         bonus_armor = 0.35f * float(m_owner->GetArmor());
 
     value  = GetModifierValue(unitMod, BASE_VALUE);
@@ -1098,12 +1100,17 @@
         case ENTRY_SUCCUBUS:    multiplicator = 9.1f;   break;
         case ENTRY_FELHUNTER:   multiplicator = 9.5f;   break;
         case ENTRY_FELGUARD:    multiplicator = 11.0f;  break;
-        case ENTRY_GHOUL:       multiplicator = 5.4f;   break;
+        case ENTRY_GHOUL:       multiplicator = 10.0f;   break;
+        case ENTRY_VIPER:       multiplicator = 0.0f;   break;
+        case ENTRY_VEN_SNAKE:   multiplicator = 0.0f;   break;
         default:                multiplicator = 10.0f;  break;
     }
 
     float value   = GetModifierValue(unitMod, BASE_VALUE) + GetCreateHealth();
     value  *= GetModifierValue(unitMod, BASE_PCT);
+	if (GetEntry()==ENTRY_GHOUL)
+    value  += GetModifierValue(unitMod, TOTAL_VALUE) + (stamina+GetCreateStat(STAT_STAMINA)) * multiplicator;
+	else
     value  += GetModifierValue(unitMod, TOTAL_VALUE) + stamina * multiplicator;
     value  *= GetModifierValue(unitMod, TOTAL_PCT);
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -228,6 +228,9 @@
 
 void Unit::Update(uint32 p_time)
 {
+    if (!IsInWorld())
+        return;
+
     // WARNING! Order of execution here is important, do not change.
     // Spells must be processed with event system BEFORE they go to _UpdateSpells.
     // Or else we may have some SPELL_STATE_FINISHED spells stalled in pointers, that is bad.
@@ -647,7 +650,6 @@
         if (pVictim->GetTypeId() == TYPEID_PLAYER)
             if (Battleground *bg = killer->GetBattleground())
                 bg->UpdatePlayerScore(killer, SCORE_DAMAGE_DONE, damage);
-
         killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DAMAGE_DONE, damage, 0, pVictim);
         killer->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_HIT_DEALT, damage);
     }
@@ -676,6 +678,23 @@
                 killer->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 0, 0, pVictim);
         }
 
+        // Heirloom trinkets on "kill a target that yields experience or honor" effect
+        if (this->ToPlayer() && this->isAlive()) 
+            if (this->ToPlayer()->isHonorOrXPTarget(pVictim))
+            {
+                AuraEffectList const& heirloom = GetAuraEffectsByType(SPELL_AURA_DUMMY);
+                for (AuraEffectList::const_iterator j = heirloom.begin(); j != heirloom.end(); ++j)
+                {
+                    if ((*j)->GetId() == 59915 && this->getPowerType() == POWER_MANA)
+                        this->CastSpell(this,59914,true);
+                    if ((*j)->GetId() == 59906)
+                    {
+                        int32 bonushealth = this->GetMaxHealth() * this->GetAura(59906)->GetEffect(0)->GetAmount() / 100;
+                        this->CastCustomSpell(this,59913,&bonushealth,0,0,true);
+                    }
+                }
+            }
+
         Kill(pVictim, durabilityLoss);
     }
     else
@@ -2793,74 +2812,74 @@
     return SPELL_MISS_NONE;
 }
 
-uint32 Unit::CalcMagicSpellHitChance(Unit * pVictim, SpellSchoolMask schoolMask, SpellEntry const * spellProto)
-{
-    // PvP - PvE spell misschances per leveldif > 2
-    int32 levelChance = pVictim->ToPlayer() ? 7 : 11;
-    int32 levelDiff = int32(pVictim->getLevelForTarget(this)) - int32(getLevelForTarget(pVictim));
-
-    // Base hit chance from attacker and victim levels
-    int32 modHitChance = 0;
-    if (levelDiff < 3)
-        modHitChance = 96 - levelDiff;
-    else
-        modHitChance = 94 - (levelDiff - 2) * levelChance;
-
-    Unit * source = ToPlayer();
-    if (!source)
-    {
-        source = ToCreature();
-        if (source)
-        {
-            source = source->ToCreature()->GetOwner();
-            if (source)
-                source = source->ToPlayer();
-        }
-    }
-    if (source && !isTotem())
-        source->ToPlayer()->ApplySpellMod(spellProto->Id, SPELLMOD_RESIST_MISS_CHANCE, modHitChance);
-    else
-        source = this;
-
-    // Increase from attacker SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT auras
-    modHitChance += source->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, schoolMask);
-    // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
-    modHitChance += pVictim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, schoolMask);
-    // Reduce spell hit chance for Area of effect spells from victim SPELL_AURA_MOD_AOE_AVOIDANCE aura
-    if (IsAreaOfEffectSpell(spellProto))
-        modHitChance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_AOE_AVOIDANCE);
-    // Chance resist mechanic (select max value from every mechanic spell effect)
-    modHitChance -= pVictim->GetMechanicResistChance(spellProto);
-    // Chance resist debuff
-    if (!IsPositiveSpell(spellProto->Id))
-    {
-        bool bNegativeAura = false;
-        for (uint8 i = 0; i < 3; ++i)
-            if (spellProto->EffectApplyAuraName[i] != 0)
-            {
-                bNegativeAura = true;
-                break;
-            }
-        if (bNegativeAura)
-        {
-            modHitChance -= pVictim->GetMaxPositiveAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spellProto->Dispel));
-            modHitChance -= pVictim->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spellProto->Dispel));
-        }
-    }
-
-    int32 hit = modHitChance * 100;
-    // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
-    hit += int32(source->m_modSpellHitChance * 100.0f);
-
-    // Decrease hit chance from victim rating bonus
-    if (pVictim->ToPlayer())
-        hit -= int32(pVictim->ToPlayer()->GetRatingBonusValue(CR_HIT_TAKEN_SPELL) * 100.0f);
-
-    hit = std::min<int32>(std::max<int32>(hit, 100), 10000);
-
-    return uint32(hit);
-}
-
+uint32 Unit::CalcMagicSpellHitChance(Unit * pVictim, SpellSchoolMask schoolMask, SpellEntry const * spellProto)
+{
+    // PvP - PvE spell misschances per leveldif > 2
+    int32 levelChance = pVictim->ToPlayer() ? 7 : 11;
+    int32 levelDiff = int32(pVictim->getLevelForTarget(this)) - int32(getLevelForTarget(pVictim));
+
+    // Base hit chance from attacker and victim levels
+    int32 modHitChance = 0;
+    if (levelDiff < 3)
+        modHitChance = 96 - levelDiff;
+    else
+        modHitChance = 94 - (levelDiff - 2) * levelChance;
+
+    Unit * source = ToPlayer();
+    if (!source)
+    {
+        source = ToCreature();
+        if (source)
+        {
+            source = source->ToCreature()->GetOwner();
+            if (source)
+                source = source->ToPlayer();
+        }
+    }
+    if (source && !isTotem())
+        source->ToPlayer()->ApplySpellMod(spellProto->Id, SPELLMOD_RESIST_MISS_CHANCE, modHitChance);
+    else
+        source = this;
+
+    // Increase from attacker SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT auras
+    modHitChance += source->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, schoolMask);
+    // Chance hit from victim SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE auras
+    modHitChance += pVictim->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE, schoolMask);
+    // Reduce spell hit chance for Area of effect spells from victim SPELL_AURA_MOD_AOE_AVOIDANCE aura
+    if (IsAreaOfEffectSpell(spellProto))
+        modHitChance -= pVictim->GetTotalAuraModifier(SPELL_AURA_MOD_AOE_AVOIDANCE);
+    // Chance resist mechanic (select max value from every mechanic spell effect)
+    modHitChance -= pVictim->GetMechanicResistChance(spellProto);
+    // Chance resist debuff
+    if (!IsPositiveSpell(spellProto->Id))
+    {
+        bool bNegativeAura = false;
+        for (uint8 i = 0; i < 3; ++i)
+            if (spellProto->EffectApplyAuraName[i] != 0)
+            {
+                bNegativeAura = true;
+                break;
+            }
+        if (bNegativeAura)
+        {
+            modHitChance -= pVictim->GetMaxPositiveAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spellProto->Dispel));
+            modHitChance -= pVictim->GetMaxNegativeAuraModifierByMiscValue(SPELL_AURA_MOD_DEBUFF_RESISTANCE, int32(spellProto->Dispel));
+        }
+    }
+
+    int32 hit = modHitChance * 100;
+    // Increase hit chance from attacker SPELL_AURA_MOD_SPELL_HIT_CHANCE and attacker ratings
+    hit += int32(source->m_modSpellHitChance * 100.0f);
+
+    // Decrease hit chance from victim rating bonus
+    if (pVictim->ToPlayer())
+        hit -= int32(pVictim->ToPlayer()->GetRatingBonusValue(CR_HIT_TAKEN_SPELL) * 100.0f);
+
+    hit = std::min<int32>(std::max<int32>(hit, 100), 10000);
+
+    return uint32(hit);
+}
+
 SpellMissInfo Unit::MagicSpellHitResult(Unit * pVictim, SpellEntry const * spell)
 {
     // Can`t miss on dead target (on skinning for example)
@@ -2869,31 +2888,31 @@
 
     SpellSchoolMask schoolMask = GetSpellSchoolMask(spell);
  
-	 int32 ignoredResistance = 0;
-    AuraEffectList const & aurasA = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);
-    for (AuraEffectList::const_iterator itr = aurasA.begin(); itr != aurasA.end(); ++itr)
-        if (((*itr)->GetMiscValue() & schoolMask) && (*itr)->IsAffectedOnSpell(spell))
-            ignoredResistance += (*itr)->GetAmount();
-
-    AuraEffectList const & aurasB = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
-    for (AuraEffectList::const_iterator itr = aurasB.begin(); itr != aurasB.end(); ++itr)
-        if ((*itr)->GetMiscValue() & schoolMask)
-            ignoredResistance += (*itr)->GetAmount();
+	 int32 ignoredResistance = 0;
+    AuraEffectList const & aurasA = GetAuraEffectsByType(SPELL_AURA_MOD_ABILITY_IGNORE_TARGET_RESIST);
+    for (AuraEffectList::const_iterator itr = aurasA.begin(); itr != aurasA.end(); ++itr)
+        if (((*itr)->GetMiscValue() & schoolMask) && (*itr)->IsAffectedOnSpell(spell))
+            ignoredResistance += (*itr)->GetAmount();
+
+    AuraEffectList const & aurasB = GetAuraEffectsByType(SPELL_AURA_MOD_IGNORE_TARGET_RESIST);
+    for (AuraEffectList::const_iterator itr = aurasB.begin(); itr != aurasB.end(); ++itr)
+        if ((*itr)->GetMiscValue() & schoolMask)
+            ignoredResistance += (*itr)->GetAmount();
     ignoredResistance = std::min<int32>(ignoredResistance, 100);
 
     // cast by caster in front of victim
     if (pVictim->HasInArc(M_PI, this) || pVictim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
     {
-        int32 deflect_chance = (pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * (100 - ignoredResistance) / 100) * 100;
-        int32 rand = irand(0, 10000);
+        int32 deflect_chance = (pVictim->GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) * (100 - ignoredResistance) / 100) * 100;
+        int32 rand = irand(0, 10000);
         if (rand < deflect_chance)
             return SPELL_MISS_DEFLECT;
     }
 
-	 // Hit
-    int32 miss = (10000 - CalcMagicSpellHitChance(pVictim, schoolMask, spell)) * (100 - ignoredResistance) / 100;
-    int32 rand = irand(0, 10000);
-    if (rand < miss)
+	 // Hit
+    int32 miss = (10000 - CalcMagicSpellHitChance(pVictim, schoolMask, spell)) * (100 - ignoredResistance) / 100;
+    int32 rand = irand(0, 10000);
+    if (rand < miss)
         return SPELL_MISS_MISS;
 
     return SPELL_MISS_NONE;
@@ -3992,6 +4011,28 @@
 {
     if (iter->second->ModStackAmount(-1))
         RemoveOwnedAura(iter, removeMode);
+    else
+    {
+        // Lifebloom hack
+        Aura * aura = iter->second;
+        
+        if (aura->GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID &&
+            aura->GetSpellProto()->SpellFamilyFlags[1] == 0x10 &&
+            removeMode == AURA_REMOVE_BY_ENEMY_SPELL)
+        {
+            // final heal
+            int32 amount = aura->GetEffect(1)->GetAmount() / aura->GetStackAmount();
+            int32 stack = 1;
+            CastCustomSpell(this, 33778, &amount, &stack, NULL, true, NULL, aura->GetEffect(1), aura->GetCasterGUID());
+
+            // restore mana
+            if (aura->GetCaster())
+            {
+                int32 returnmana = (aura->GetSpellProto()->ManaCostPercentage * aura->GetCaster()->GetCreateMana() / 100) * stack / 2;
+                aura->GetCaster()->CastCustomSpell(aura->GetCaster(), 64372, &returnmana, NULL, NULL, true, NULL, aura->GetEffect(1), aura->GetCasterGUID());
+            }    
+        }
+    }
 }
 
 void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint64 casterGUID, Unit *dispeller)
@@ -5395,6 +5436,8 @@
                 case 18765:
                 case 35429:
                 {
+                    if (HasAura(46924))
+                        return false;
                     target = SelectNearbyTarget();
                     if (!target)
                         return false;
@@ -6027,6 +6070,8 @@
                 // Sweeping Strikes
                 case 12328:
                 {
+                    if (HasAura(46924))
+                        return false;
                     target = SelectNearbyTarget();
                     if (!target)
                         return false;
@@ -6308,6 +6353,10 @@
                 // Vampiric Embrace
                 case 15286:
                 {
+                    for (int j = 0; j < 3; j++)
+                        if (procSpell->EffectRadiusIndex[j] > 0)
+                            return false;
+
                     if (!pVictim || !pVictim->isAlive())
                         return false;
 
@@ -6801,7 +6850,7 @@
                     return false;
                 triggered_spell_id = 25742;
                 float ap = GetTotalAttackPowerValue(BASE_ATTACK);
-                int32 holy = SpellBaseDamageBonus(SPELL_SCHOOL_MASK_HOLY) +
+                int32 holy = SpellBaseDamageBonus(SPELL_SCHOOL_MASK_HOLY, dummySpell) +
                              SpellBaseDamageBonusForVictim(SPELL_SCHOOL_MASK_HOLY, pVictim);
                 basepoints0 = (int32)GetAttackTime(BASE_ATTACK) * int32(ap*0.022f + 0.044f * holy) / 1000;
                 break;
@@ -8381,6 +8430,8 @@
                     basepoints0 = damage * triggerAmount / 100 / 3;
                     target = this;
                 }
+                else if (auraSpellInfo->Id == 55681)
+                    basepoints0 = triggerAmount * GetCreateMana() / 100;
                 break;
             }
             case SPELLFAMILY_DRUID:
@@ -8759,24 +8810,24 @@
             break;
         }
         // Blessing of Ancient Kings (Val'anyr, Hammer of Ancient Kings)
-        case 64411: 
-                 { 
-                     if (!IsPositiveSpell(procSpell->Id)) 
-                         return false; 
-
-                     if (!pVictim || !pVictim->isAlive()) 
-                        return false; 
-
-                     basepoints0 = damage * 15 / 100; 
-
-                    if (AuraEffect* aurae = pVictim->GetAuraEffect(64413, 0))
-                       basepoints0 += aurae->GetAmount(); 
-
-                    if (basepoints0 > 20000) 
-                        basepoints0 = 20000; 
-
-                     trigger_spell_id = 64413;
-                     break; 
+        case 64411: 
+                 { 
+                     if (!IsPositiveSpell(procSpell->Id)) 
+                         return false; 
+
+                     if (!pVictim || !pVictim->isAlive()) 
+                        return false; 
+
+                     basepoints0 = damage * 15 / 100; 
+
+                    if (AuraEffect* aurae = pVictim->GetAuraEffect(64413, 0))
+                       basepoints0 += aurae->GetAmount(); 
+
+                    if (basepoints0 > 20000) 
+                        basepoints0 = 20000; 
+
+                     trigger_spell_id = 64413;
+                     break; 
                  }
         // Decimation
         case 63156:
@@ -8868,12 +8919,6 @@
             // Need add combopoint AFTER finish movie (or they dropped in finish phase)
             break;
         }
-        // Bloodthirst (($m/100)% of max health)
-        case 23880:
-        {
-            basepoints0 = int32(CountPctFromMaxHealth(triggerAmount));
-            break;
-        }
         // Shamanistic Rage triggered spell
         case 30824:
         {
@@ -8896,7 +8941,7 @@
                 {
                     if (AuraEffect * aurEff = owner->GetDummyAuraEffect(SPELLFAMILY_WARLOCK, 3220, 0))
                     {
-                        basepoints0 = int32((aurEff->GetAmount() * owner->SpellBaseDamageBonus(SpellSchoolMask(SPELL_SCHOOL_MASK_MAGIC)) + 100.0f) / 100.0f);
+                        basepoints0 = int32((aurEff->GetAmount() * owner->SpellBaseDamageBonus(SpellSchoolMask(SPELL_SCHOOL_MASK_MAGIC), triggerEntry) + 100.0f) / 100.0f);
                         CastCustomSpell(this,trigger_spell_id,&basepoints0,&basepoints0,NULL,true,castItem,triggeredByAura);
                         return true;
                     }
@@ -10290,7 +10335,7 @@
 
 uint32 Unit::SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint32 pdamage, DamageEffectType damagetype, uint32 stack)
 {
-    if (!spellProto || !pVictim || damagetype == DIRECT_DAMAGE)
+    if (!spellProto || !pVictim || damagetype == DIRECT_DAMAGE || spellProto->AttributesEx6 & SPELL_ATTR_EX6_NO_DMG_MODS)
         return pdamage;
 
     // For totems get damage bonus from owner
@@ -10314,7 +10359,14 @@
         if (((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto)) &&
             (*i)->GetSpellProto()->EquippedItemClass == -1 &&          // -1 == any item class (not wand)
             (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0) // 0 == any inventory type (not wand)
+        {
             DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+            if ((*i)->GetId() == 36032) // Arcane Blast debuff should not be removed here
+                continue;
+            if (spellProto->EffectApplyAuraName[0] != SPELL_AURA_PERIODIC_DAMAGE && !(spellProto->AttributesEx3 & SPELL_ATTR_EX3_UNK30) && (*i)->GetBase()->DropCharge())
+                i = mModDamagePercentDone.begin();
+
+        }
 
     uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
     // Add flat bonus from spell damage versus
@@ -10637,7 +10689,7 @@
     float TakenTotalMod = (sumNegativeMod+maxPositiveMod+100.0f)/100.0f;
 
     // Taken/Done fixed damage bonus auras
-    int32 DoneAdvertisedBenefit  = SpellBaseDamageBonus(GetSpellSchoolMask(spellProto));
+    int32 DoneAdvertisedBenefit  = SpellBaseDamageBonus(GetSpellSchoolMask(spellProto), spellProto);
     int32 TakenAdvertisedBenefit = SpellBaseDamageBonusForVictim(GetSpellSchoolMask(spellProto), pVictim);
     // Pets just add their bonus damage to their spell damage
     // note that their spell damage is just gain of their own auras
@@ -10760,7 +10812,7 @@
     return uint32(std::max(tmpDamage, 0.0f));
 }
 
-int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask)
+int32 Unit::SpellBaseDamageBonus(SpellSchoolMask schoolMask, SpellEntry const *spellInfo)
 {
     int32 DoneAdvertisedBenefit = 0;
 
@@ -10772,12 +10824,14 @@
                                                             // -1 == any item class (not wand then)
         (*i)->GetSpellProto()->EquippedItemInventoryTypeMask == 0)
                                                             // 0 == any inventory type (not wand then)
-            DoneAdvertisedBenefit += (*i)->GetAmount();
+            if (!spellInfo || spellInfo->powerType == POWER_MANA)
+                DoneAdvertisedBenefit += (*i)->GetAmount();
 
     if (GetTypeId() == TYPEID_PLAYER)
     {
         // Base value
-        DoneAdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
+        if (!spellInfo || spellInfo->powerType == POWER_MANA)
+            DoneAdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
 
         // Damage bonus from stats
         AuraEffectList const& mDamageDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT);
@@ -11146,7 +11200,7 @@
     }
 
     // Taken/Done fixed damage bonus auras
-    int32 DoneAdvertisedBenefit  = SpellBaseHealingBonus(GetSpellSchoolMask(spellProto));
+    int32 DoneAdvertisedBenefit  = SpellBaseHealingBonus(GetSpellSchoolMask(spellProto), spellProto);
     int32 TakenAdvertisedBenefit = SpellBaseHealingBonusForVictim(GetSpellSchoolMask(spellProto), pVictim);
 
     bool scripted = false;
@@ -11276,8 +11330,13 @@
     // use float as more appropriate for negative values and percent applying
     float heal = (int32(healamount) + DoneTotal) * DoneTotalMod;
     // apply spellmod to Done amount
-    if (Player* modOwner = GetSpellModOwner())
-        modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
+
+    if (!(spellProto->SpellFamilyName == SPELLFAMILY_PRIEST && 
+        spellProto->SpellFamilyFlags[0] & 0x2000000 &&
+        spellProto->SpellFamilyFlags[1] & 0x1000 &&
+        spellProto->SpellFamilyFlags[2] & 0x400))
+        if (Player* modOwner = GetSpellModOwner())
+            modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
 
     // Nourish cast
     if (spellProto->SpellFamilyName == SPELLFAMILY_DRUID && spellProto->SpellFamilyFlags[1] & 0x2000000)
@@ -11334,20 +11393,22 @@
     return uint32(std::max(heal, 0.0f));
 }
 
-int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask)
+int32 Unit::SpellBaseHealingBonus(SpellSchoolMask schoolMask, SpellEntry const *spellInfo)
 {
     int32 AdvertisedBenefit = 0;
 
     AuraEffectList const& mHealingDone = GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_DONE);
     for (AuraEffectList::const_iterator i = mHealingDone.begin(); i != mHealingDone.end(); ++i)
         if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
-            AdvertisedBenefit += (*i)->GetAmount();
+            if (!spellInfo || spellInfo->powerType == POWER_MANA)
+                AdvertisedBenefit += (*i)->GetAmount();
 
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
         // Base value
-        AdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
+        if (!spellInfo || spellInfo->powerType == POWER_MANA)
+            AdvertisedBenefit +=this->ToPlayer()->GetBaseSpellPowerBonus();
 
         // Healing bonus from stats
         AuraEffectList const& mHealingDoneOfStatPercent = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT);
@@ -11539,6 +11600,9 @@
     if (*pdamage == 0)
         return;
 
+    if (spellProto && (spellProto->AttributesEx6 & SPELL_ATTR_EX6_NO_DMG_MODS))
+        return;
+
     uint32 creatureTypeMask = pVictim->GetCreatureTypeMask();
 
     // Taken/Done fixed damage bonus auras
@@ -11616,8 +11680,12 @@
         {
             AuraEffectList const &mModDamagePercentDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE);
             for (AuraEffectList::const_iterator i = mModDamagePercentDone.begin(); i != mModDamagePercentDone.end(); ++i)
-                if (((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto)) && !((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL))
+                if (((*i)->GetMiscValue() & GetSpellSchoolMask(spellProto)) && !((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL)) {
                     DoneTotalMod *= ((*i)->GetAmount()+100.0f)/100.0f;
+                    if (spellProto->EffectApplyAuraName[0] != SPELL_AURA_PERIODIC_DAMAGE && !(spellProto->AttributesEx3 & SPELL_ATTR_EX3_UNK30) && (*i)->GetBase()->DropCharge())
+                        i = mModDamagePercentDone.begin();
+                }
+
         }
 
     AuraEffectList const &mDamageDoneVersus = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE_VERSUS);
@@ -12331,14 +12399,17 @@
             return true;
 
     //Visible distance based on stealth value (stealth rank 4 300MOD, 10.5 - 3 = 7.5)
-    float visibleDistance = 10.5f - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH) / 100.0f;
+    float visibleDistance = 26.0f;
     //Visible distance is modified by -Level Diff (every level diff = 1.0f in visible distance)
-    visibleDistance += int32(getLevelForTarget(target)) - int32(target->getLevelForTarget(this));
+    visibleDistance += float(getLevel() - getLevelForTarget(target)) * 2.5f - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH) / 5.0f;
     //-Stealth Mod(positive like Master of Deception) and Stealth Detection(negative like paranoia)
     //based on wowwiki every 5 mod we have 1 more level diff in calculation
-    visibleDistance += (float)(GetTotalAuraModifier(SPELL_AURA_MOD_DETECT) - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH_LEVEL)) / 5.0f;
+    visibleDistance += GetTotalAuraModifier(SPELL_AURA_MOD_DETECT) / 2.0f - target->GetTotalAuraModifier(SPELL_AURA_MOD_STEALTH_LEVEL) / 2.0f;
     visibleDistance = visibleDistance > MAX_PLAYER_STEALTH_DETECT_RANGE ? MAX_PLAYER_STEALTH_DETECT_RANGE : visibleDistance;
 
+if (!HasInArc(M_PI, target)) //behind
+        visibleDistance /= 3.0f;
+
 if (!HasInArc(M_PI/6, target))          // (M_PI/3 - M_PI/6) -75% detection distance
       {
 		  if (!HasInArc(M_PI/3, target))      // (M_PI - M_PI/3) -50% detection distance
@@ -13120,7 +13191,7 @@
 
 float Unit::ApplyDiminishingToDuration(DiminishingGroup group, int32 &duration,Unit* caster,DiminishingLevels Level, int32 limitduration)
 {
-    if (duration == -1 || group == DIMINISHING_NONE || caster->IsFriendlyTo(this))
+    if (duration == -1 || group == DIMINISHING_NONE || ((caster != this) && (caster->IsFriendlyTo(this))))
         return 1.0f;
 
     // test pet/charm masters instead pets/charmeds
@@ -13278,6 +13349,8 @@
         return false;
     }
 
+    float val = 1.0f;
+
     switch (modifierType)
     {
         case BASE_VALUE:
@@ -13286,8 +13359,10 @@
             break;
         case BASE_PCT:
         case TOTAL_PCT:
-            m_auraModifiersGroup[unitMod][modifierType] += (apply ? amount : -amount) / 100.0f;
-            break;
+             if(amount <= -100.0f)                           //small hack-fix for -100% modifiers
+                 amount = -200.0f;
+             val = (100.0f + amount) / 100.0f;
+             m_auraModifiersGroup[unitMod][modifierType] *= apply ? val : (1.0f/val);            break;
         default:
             break;
     }
@@ -14275,6 +14350,12 @@
         if (i->aura->IsRemoved())
             continue;
 
+        // Prayer of Mending
+        if ((i->aura->GetId() == 41635 
+            || i->aura->GetId() == 48110 
+            || i->aura->GetId() == 48111) && !damage)
+            continue;
+
         bool useCharges= i->aura->GetCharges()>0;
         bool takeCharges = false;
         SpellEntry const *spellInfo = i->aura->GetSpellProto();
@@ -14463,6 +14544,10 @@
                     break;
             }
         }
+        // Stealth shouldn't break if damage is absorbed
+        if ((procFlag & PROC_FLAG_TAKEN_DAMAGE) && !damage)
+           takeCharges = false;
+
         // Remove charge (aura can be removed by triggers)
         if (useCharges && takeCharges)
             i->aura->DropCharge();
@@ -15420,8 +15505,8 @@
             {
                 if (m->IsRaidOrHeroicDungeon())
                 {
-                    if (creature->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
-                        ((InstanceMap *)m)->PermBindAllPlayers(creditedPlayer);
+                    if (creature->GetCreatureInfo()->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)                
+                        ((InstanceMap *)m)->PermBindAllPlayers(creditedPlayer);         
                 }
                 else
                 {
@@ -17160,6 +17245,16 @@
     return amount;
 }
 
+Totem* Unit::GetTotem(TotemSlot slot ) const
+{
+    if(slot > TOTEM_SLOT_AIR || !IsInWorld())
+        return NULL;
+
+    Creature *totem = GetMap()->GetCreature(m_SummonSlot[SUMMON_SLOT_TOTEM + slot]);
+    return totem ? totem->ToTotem() : NULL;
+}
+
+
 void CharmInfo::SetIsCommandAttack(bool val)
 {
     m_isCommandAttack = val;
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -1083,6 +1083,15 @@
     SUMMON_TYPE_TOTEM_AIR   = 83,
 };
 
+// Stored in SummonProperties.dbc with slot+1 values
+enum TotemSlot
+{
+    TOTEM_SLOT_FIRE   = 0,
+    TOTEM_SLOT_EARTH  = 1,
+    TOTEM_SLOT_WATER  = 2,
+    TOTEM_SLOT_AIR    = 3,
+};
+
 // delay time next attack to prevent client attack animation problems
 #define ATTACK_DISPLAY_DELAY 200
 #define MAX_PLAYER_STEALTH_DETECT_RANGE 45.0f               // max distance for detection targets by player
@@ -1720,6 +1729,9 @@
         uint32 m_detectInvisibilityMask;
         uint32 m_invisibilityMask;
 
+        uint64 const& GetTotemGUID(TotemSlot slot) const { return m_SummonSlot[SUMMON_SLOT_TOTEM + slot]; }
+        Totem* GetTotem(TotemSlot slot) const;
+
         uint32 m_ShapeShiftFormSpellId;
         ShapeshiftForm m_form;
         bool IsInFeralForm() const { return m_form == FORM_CAT || m_form == FORM_BEAR || m_form == FORM_DIREBEAR; }
@@ -1839,8 +1851,8 @@
         bool HasAuraState(AuraState flag, SpellEntry const *spellProto = NULL, Unit const * Caster = NULL) const ;
         void UnsummonAllTotems();
         Unit* SelectMagnetTarget(Unit *victim, SpellEntry const *spellInfo = NULL);
-        int32 SpellBaseDamageBonus(SpellSchoolMask schoolMask);
-        int32 SpellBaseHealingBonus(SpellSchoolMask schoolMask);
+        int32 SpellBaseDamageBonus(SpellSchoolMask schoolMask, SpellEntry const *spellInfo = NULL);
+        int32 SpellBaseHealingBonus(SpellSchoolMask schoolMask, SpellEntry const *spellInfo = NULL);
         int32 SpellBaseDamageBonusForVictim(SpellSchoolMask schoolMask, Unit *pVictim);
         int32 SpellBaseHealingBonusForVictim(SpellSchoolMask schoolMask, Unit *pVictim);
         uint32 SpellDamageBonus(Unit *pVictim, SpellEntry const *spellProto, uint32 damage, DamageEffectType damagetype, uint32 stack = 1);
diff --git a/src/server/game/Globals/ObjectAccessor.cpp b/src/server/game/Globals/ObjectAccessor.cpp
--- a/src/server/game/Globals/ObjectAccessor.cpp
+++ b/src/server/game/Globals/ObjectAccessor.cpp
@@ -1,409 +1,407 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "ObjectAccessor.h"
-#include "ObjectMgr.h"
-
-#include "Player.h"
-#include "Creature.h"
-#include "GameObject.h"
-#include "DynamicObject.h"
-#include "Vehicle.h"
-#include "WorldPacket.h"
-#include "Item.h"
-#include "Corpse.h"
-#include "GridNotifiers.h"
-#include "MapManager.h"
-#include "Map.h"
-#include "CellImpl.h"
-#include "GridNotifiersImpl.h"
-#include "Opcodes.h"
-#include "ObjectDefines.h"
-#include "MapInstanced.h"
-#include "World.h"
-
-#include <cmath>
-
-ObjectAccessor::ObjectAccessor()
-{
-}
-
-ObjectAccessor::~ObjectAccessor()
-{
-    for (Player2CorpsesMapType::const_iterator itr = i_player2corpse.begin(); itr != i_player2corpse.end(); ++itr)
-    {
-        itr->second->RemoveFromWorld();
-        delete itr->second;
-    }
-}
-
-WorldObject* ObjectAccessor::GetWorldObject(WorldObject const& p, uint64 guid)
-{
-    switch (GUID_HIPART(guid))
-    {
-        case HIGHGUID_PLAYER:        return GetPlayer(p, guid);
-        case HIGHGUID_TRANSPORT:
-        case HIGHGUID_MO_TRANSPORT:
-        case HIGHGUID_GAMEOBJECT:    return GetGameObject(p, guid);
-        case HIGHGUID_VEHICLE:
-        case HIGHGUID_UNIT:          return GetCreature(p, guid);
-        case HIGHGUID_PET:           return GetPet(p, guid);
-        case HIGHGUID_DYNAMICOBJECT: return GetDynamicObject(p, guid);
-        case HIGHGUID_CORPSE:        return GetCorpse(p,guid);
-        default:                     return NULL;
-    }
-}
-
-Object* ObjectAccessor::GetObjectByTypeMask(WorldObject const& p, uint64 guid, uint32 typemask)
-{
-    switch (GUID_HIPART(guid))
-    {
-        case HIGHGUID_ITEM:
-            if (typemask & TYPEMASK_ITEM && p.GetTypeId() == TYPEID_PLAYER)
-                return ((Player const&)p).GetItemByGuid(guid);
-            break;
-        case HIGHGUID_PLAYER:
-            if (typemask & TYPEMASK_PLAYER)
-                return GetPlayer(p, guid);
-            break;
-        case HIGHGUID_TRANSPORT:
-        case HIGHGUID_MO_TRANSPORT:
-        case HIGHGUID_GAMEOBJECT:
-            if (typemask & TYPEMASK_GAMEOBJECT)
-                return GetGameObject(p, guid);
-            break;
-        case HIGHGUID_UNIT:
-        case HIGHGUID_VEHICLE:
-            if (typemask & TYPEMASK_UNIT)
-                return GetCreature(p, guid);
-            break;
-        case HIGHGUID_PET:
-            if (typemask & TYPEMASK_UNIT)
-                return GetPet(p, guid);
-            break;
-        case HIGHGUID_DYNAMICOBJECT:
-            if (typemask & TYPEMASK_DYNAMICOBJECT)
-                return GetDynamicObject(p, guid);
-            break;
-        case HIGHGUID_CORPSE:
-            break;
-    }
-
-    return NULL;
-}
-
-Corpse* ObjectAccessor::GetCorpse(WorldObject const& u, uint64 guid)
-{
-    return GetObjectInMap(guid, u.GetMap(), (Corpse*)NULL);
-}
-
-GameObject* ObjectAccessor::GetGameObject(WorldObject const& u, uint64 guid)
-{
-    return GetObjectInMap(guid, u.GetMap(), (GameObject*)NULL);
-}
-
-DynamicObject* ObjectAccessor::GetDynamicObject(WorldObject const& u, uint64 guid)
-{
-    return GetObjectInMap(guid, u.GetMap(), (DynamicObject*)NULL);
-}
-
-Unit* ObjectAccessor::GetUnit(WorldObject const& u, uint64 guid)
-{
-    return GetObjectInMap(guid, u.GetMap(), (Unit*)NULL);
-}
-
-Creature* ObjectAccessor::GetCreature(WorldObject const& u, uint64 guid)
-{
-    return GetObjectInMap(guid, u.GetMap(), (Creature*)NULL);
-}
-
-Pet* ObjectAccessor::GetPet(WorldObject const& u, uint64 guid)
-{
-    return GetObjectInMap(guid, u.GetMap(), (Pet*)NULL);
-}
-
-Player* ObjectAccessor::GetPlayer(WorldObject const& u, uint64 guid)
-{
-    return GetObjectInMap(guid, u.GetMap(), (Player*)NULL);
-}
-
-Creature* ObjectAccessor::GetCreatureOrPetOrVehicle(WorldObject const& u, uint64 guid)
-{
-    if (IS_PET_GUID(guid))
-        return GetPet(u, guid);
-
-    if (IS_CRE_OR_VEH_GUID(guid))
-        return GetCreature(u, guid);
-
-    return NULL;
-}
-
-Pet* ObjectAccessor::FindPet(uint64 guid)
-{
-    return GetObjectInWorld(guid, (Pet*)NULL);
-}
-
-Player* ObjectAccessor::FindPlayer(uint64 guid)
-{
-    return GetObjectInWorld(guid, (Player*)NULL);
-}
-
-Unit* ObjectAccessor::FindUnit(uint64 guid)
-{
-    return GetObjectInWorld(guid, (Unit*)NULL);
-}
-
-Player* ObjectAccessor::FindPlayerByName(const char* name)
-{
-    ACE_GUARD_RETURN(LockType, g, *HashMapHolder<Player>::GetLock(), NULL);
-    HashMapHolder<Player>::MapType& m = HashMapHolder<Player>::GetContainer();
-    for (HashMapHolder<Player>::MapType::iterator iter = m.begin(); iter != m.end(); ++iter)
-        if (iter->second->IsInWorld() && strcmp(name, iter->second->GetName()) == 0)
-            return iter->second;
-
-    return NULL;
-}
-
-void ObjectAccessor::SaveAllPlayers()
-{
-    ACE_GUARD(LockType, g, *HashMapHolder<Player>::GetLock());
-    HashMapHolder<Player>::MapType& m = HashMapHolder<Player>::GetContainer();
-    for (HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
-        itr->second->SaveToDB();
-}
-
-Corpse* ObjectAccessor::GetCorpseForPlayerGUID(uint64 guid)
-{
-    ACE_GUARD_RETURN(LockType, guard, i_corpseGuard, NULL);
-
-    Player2CorpsesMapType::iterator iter = i_player2corpse.find(guid);
-    if (iter == i_player2corpse.end())
-        return NULL;
-
-    ASSERT(iter->second->GetType() != CORPSE_BONES);
-
-    return iter->second;
-}
-
-void ObjectAccessor::RemoveCorpse(Corpse* corpse)
-{
-    ASSERT(corpse && corpse->GetType() != CORPSE_BONES);
-
-    if (corpse->FindMap())
-        corpse->FindMap()->Remove(corpse, false);
-    else
-        corpse->RemoveFromWorld();
-
-    // Critical section
-    {
-        ACE_GUARD(LockType, g, i_corpseGuard);
-
-        Player2CorpsesMapType::iterator iter = i_player2corpse.find(corpse->GetOwnerGUID());
-        if (iter == i_player2corpse.end()) // TODO: Fix this
-            return;
-
-        // build mapid*cellid -> guid_set map
-        CellPair cell_pair = Trinity::ComputeCellPair(corpse->GetPositionX(), corpse->GetPositionY());
-        uint32 cell_id = (cell_pair.y_coord * TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
-
-        sObjectMgr.DeleteCorpseCellData(corpse->GetMapId(), cell_id, GUID_LOPART(corpse->GetOwnerGUID()));
-
-        i_player2corpse.erase(iter);
-    }
-}
-
-void ObjectAccessor::AddCorpse(Corpse* corpse)
-{
-    ASSERT(corpse && corpse->GetType() != CORPSE_BONES);
-
-    // Critical section
-    {
-        ACE_GUARD(LockType, g, i_corpseGuard);
-
-        ASSERT(i_player2corpse.find(corpse->GetOwnerGUID()) == i_player2corpse.end());
-        i_player2corpse[corpse->GetOwnerGUID()] = corpse;
-
-        // build mapid*cellid -> guid_set map
-        CellPair cell_pair = Trinity::ComputeCellPair(corpse->GetPositionX(), corpse->GetPositionY());
-        uint32 cell_id = (cell_pair.y_coord * TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
-
-        sObjectMgr.AddCorpseCellData(corpse->GetMapId(), cell_id, GUID_LOPART(corpse->GetOwnerGUID()), corpse->GetInstanceId());
-    }
-}
-
-void ObjectAccessor::AddCorpsesToGrid(GridPair const& gridpair, GridType& grid, Map* map)
-{
-    ACE_GUARD(LockType, g, i_corpseGuard);
-
-    for (Player2CorpsesMapType::iterator iter = i_player2corpse.begin(); iter != i_player2corpse.end(); ++iter)
-    {
-        if (iter->second->GetGrid() == gridpair)
-        {
-            // verify, if the corpse in our instance (add only corpses which are)
-            if (map->Instanceable())
-            {
-                if (iter->second->GetInstanceId() == map->GetInstanceId())
-                    grid.AddWorldObject(iter->second);
-            }
-            else
-                grid.AddWorldObject(iter->second);
-        }
-    }
-}
-
-Corpse* ObjectAccessor::ConvertCorpseForPlayer(uint64 player_guid, bool /*insignia*/)
-{
-    Corpse* corpse = GetCorpseForPlayerGUID(player_guid);
-    if (!corpse)
-    {
-        //in fact this function is called from several places
-        //even when player doesn't have a corpse, not an error
-        // TODO: really, now...
-        //sLog.outError("Try remove corpse that not in map for GUID %ul", player_guid);
-        return NULL;
-    }
-
-    sLog.outStaticDebug("Deleting Corpse and spawned bones.");
-
-    //Map* map = corpse->FindMap();
-
-    // remove corpse from player_guid -> corpse map
-    RemoveCorpse(corpse);
-
-    // done in removecorpse
-    // remove resurrectable corpse from grid object registry (loaded state checked into call)
-    // do not load the map if it's not loaded
-    //Map *map = sMapMgr.FindMap(corpse->GetMapId(), corpse->GetInstanceId());
-    //if (map)
-    //    map->Remove(corpse, false);
-
-    // remove corpse from DB
-    SQLTransaction trans = CharacterDatabase.BeginTransaction();
-    corpse->DeleteFromDB(trans);
-    CharacterDatabase.CommitTransaction(trans);
-
-    // we don't want bones to save some cpu.. :)
-    delete corpse;
-    return NULL;
-
-    /*
-    Corpse* bones = NULL;
-    // create the bones only if the map and the grid is loaded at the corpse's location
-    // ignore bones creating option in case insignia
-    if (map && (insignia ||
-        (map->IsBattlegroundOrArena() ? sWorld.getIntConfig(CONFIG_DEATH_BONES_BG_OR_ARENA) : sWorld.getIntConfig(CONFIG_DEATH_BONES_WORLD))) &&
-        !map->IsRemovalGrid(corpse->GetPositionX(), corpse->GetPositionY()))
-    {
-        // Create bones, don't change Corpse
-        bones = new Corpse;
-        bones->Create(corpse->GetGUIDLow(), map);
-
-        for (int i = 3; i < CORPSE_END; ++i)                    // don't overwrite guid and object type
-            bones->SetUInt32Value(i, corpse->GetUInt32Value(i));
-
-        bones->SetGrid(corpse->GetGrid());
-        // bones->m_time = m_time;                              // don't overwrite time
-        // bones->m_inWorld = m_inWorld;                        // don't overwrite in-world state
-        // bones->m_type = m_type;                              // don't overwrite type
-        bones->Relocate(corpse->GetPositionX(), corpse->GetPositionY(), corpse->GetPositionZ(), corpse->GetOrientation());
-        bones->SetPhaseMask(corpse->GetPhaseMask(), false);
-
-        bones->SetUInt32Value(CORPSE_FIELD_FLAGS, CORPSE_FLAG_UNK2 | CORPSE_FLAG_BONES);
-        bones->SetUInt64Value(CORPSE_FIELD_OWNER, 0);
-
-        for (int i = 0; i < EQUIPMENT_SLOT_END; ++i)
-        {
-            if (corpse->GetUInt32Value(CORPSE_FIELD_ITEM + i))
-                bones->SetUInt32Value(CORPSE_FIELD_ITEM + i, 0);
-        }
-
-        // add bones in grid store if grid loaded where corpse placed
-        map->Add(bones);
-    }
-
-    // all references to the corpse should be removed at this point
-    delete corpse;
-
-    return bones;
-    */
-}
-
-void ObjectAccessor::RemoveOldCorpses()
-{
-    time_t now = time(NULL);
-    Player2CorpsesMapType::iterator next;
-    for (Player2CorpsesMapType::iterator itr = i_player2corpse.begin(); itr != i_player2corpse.end(); itr = next)
-    {
-        next = itr;
-        ++next;
-
-        if (!itr->second->IsExpired(now))
-            continue;
-
-        ConvertCorpseForPlayer(itr->first);
-    }
-}
-
-void ObjectAccessor::Update(uint32 /*diff*/)
-{
-    UpdateDataMapType update_players;
-
-    // Critical section
-    {
-        ACE_GUARD(LockType, g, i_updateGuard);
-
-        while (!i_objects.empty())
-        {
-            Object* obj = *i_objects.begin();
-            ASSERT(obj && obj->IsInWorld());
-            i_objects.erase(i_objects.begin());
-            obj->BuildUpdate(update_players);
-        }
-    }
-
-    WorldPacket packet;                                     // here we allocate a std::vector with a size of 0x10000
-    for (UpdateDataMapType::iterator iter = update_players.begin(); iter != update_players.end(); ++iter)
-    {
-        iter->second.BuildPacket(&packet);
-        iter->first->GetSession()->SendPacket(&packet);
-        packet.clear();                                     // clean the string
-    }
-}
-
-/// Define the static members of HashMapHolder
-
-template <class T> UNORDERED_MAP< uint64, T* > HashMapHolder<T>::m_objectMap;
-template <class T> ACE_Thread_Mutex HashMapHolder<T>::i_lock;
-
-/// Global definitions for the hashmap storage
-
-template class HashMapHolder<Player>;
-template class HashMapHolder<Pet>;
-template class HashMapHolder<GameObject>;
-template class HashMapHolder<DynamicObject>;
-template class HashMapHolder<Creature>;
-template class HashMapHolder<Corpse>;
-
-template Player* ObjectAccessor::GetObjectInWorld<Player>(uint32 mapid, float x, float y, uint64 guid, Player* /*fake*/);
-template Pet* ObjectAccessor::GetObjectInWorld<Pet>(uint32 mapid, float x, float y, uint64 guid, Pet* /*fake*/);
-template Creature* ObjectAccessor::GetObjectInWorld<Creature>(uint32 mapid, float x, float y, uint64 guid, Creature* /*fake*/);
-template Corpse* ObjectAccessor::GetObjectInWorld<Corpse>(uint32 mapid, float x, float y, uint64 guid, Corpse* /*fake*/);
-template GameObject* ObjectAccessor::GetObjectInWorld<GameObject>(uint32 mapid, float x, float y, uint64 guid, GameObject* /*fake*/);
-template DynamicObject* ObjectAccessor::GetObjectInWorld<DynamicObject>(uint32 mapid, float x, float y, uint64 guid, DynamicObject* /*fake*/);
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+
+#include "Player.h"
+#include "Creature.h"
+#include "GameObject.h"
+#include "DynamicObject.h"
+#include "Vehicle.h"
+#include "WorldPacket.h"
+#include "Item.h"
+#include "Corpse.h"
+#include "GridNotifiers.h"
+#include "MapManager.h"
+#include "Map.h"
+#include "CellImpl.h"
+#include "GridNotifiersImpl.h"
+#include "Opcodes.h"
+#include "ObjectDefines.h"
+#include "MapInstanced.h"
+#include "World.h"
+
+#include <cmath>
+
+ObjectAccessor::ObjectAccessor()
+{
+}
+
+ObjectAccessor::~ObjectAccessor()
+{
+    for (Player2CorpsesMapType::const_iterator itr = i_player2corpse.begin(); itr != i_player2corpse.end(); ++itr)
+    {
+        itr->second->RemoveFromWorld();
+        delete itr->second;
+    }
+}
+
+WorldObject* ObjectAccessor::GetWorldObject(WorldObject const& p, uint64 guid)
+{
+    switch (GUID_HIPART(guid))
+    {
+        case HIGHGUID_PLAYER:        return GetPlayer(p, guid);
+        case HIGHGUID_TRANSPORT:
+        case HIGHGUID_MO_TRANSPORT:
+        case HIGHGUID_GAMEOBJECT:    return GetGameObject(p, guid);
+        case HIGHGUID_VEHICLE:
+        case HIGHGUID_UNIT:          return GetCreature(p, guid);
+        case HIGHGUID_PET:           return GetPet(p, guid);
+        case HIGHGUID_DYNAMICOBJECT: return GetDynamicObject(p, guid);
+        case HIGHGUID_CORPSE:        return GetCorpse(p,guid);
+        default:                     return NULL;
+    }
+}
+
+Object* ObjectAccessor::GetObjectByTypeMask(WorldObject const& p, uint64 guid, uint32 typemask)
+{
+    switch (GUID_HIPART(guid))
+    {
+        case HIGHGUID_ITEM:
+            if (typemask & TYPEMASK_ITEM && p.GetTypeId() == TYPEID_PLAYER)
+                return ((Player const&)p).GetItemByGuid(guid);
+            break;
+        case HIGHGUID_PLAYER:
+            if (typemask & TYPEMASK_PLAYER)
+                return GetPlayer(p, guid);
+            break;
+        case HIGHGUID_TRANSPORT:
+        case HIGHGUID_MO_TRANSPORT:
+        case HIGHGUID_GAMEOBJECT:
+            if (typemask & TYPEMASK_GAMEOBJECT)
+                return GetGameObject(p, guid);
+            break;
+        case HIGHGUID_UNIT:
+        case HIGHGUID_VEHICLE:
+            if (typemask & TYPEMASK_UNIT)
+                return GetCreature(p, guid);
+            break;
+        case HIGHGUID_PET:
+            if (typemask & TYPEMASK_UNIT)
+                return GetPet(p, guid);
+            break;
+        case HIGHGUID_DYNAMICOBJECT:
+            if (typemask & TYPEMASK_DYNAMICOBJECT)
+                return GetDynamicObject(p, guid);
+            break;
+        case HIGHGUID_CORPSE:
+            break;
+    }
+
+    return NULL;
+}
+
+Corpse* ObjectAccessor::GetCorpse(WorldObject const& u, uint64 guid)
+{
+    return GetObjectInMap(guid, u.GetMap(), (Corpse*)NULL);
+}
+
+GameObject* ObjectAccessor::GetGameObject(WorldObject const& u, uint64 guid)
+{
+    return GetObjectInMap(guid, u.GetMap(), (GameObject*)NULL);
+}
+
+DynamicObject* ObjectAccessor::GetDynamicObject(WorldObject const& u, uint64 guid)
+{
+    return GetObjectInMap(guid, u.GetMap(), (DynamicObject*)NULL);
+}
+
+Unit* ObjectAccessor::GetUnit(WorldObject const& u, uint64 guid)
+{
+    return GetObjectInMap(guid, u.GetMap(), (Unit*)NULL);
+}
+
+Creature* ObjectAccessor::GetCreature(WorldObject const& u, uint64 guid)
+{
+    return GetObjectInMap(guid, u.GetMap(), (Creature*)NULL);
+}
+
+Pet* ObjectAccessor::GetPet(WorldObject const& u, uint64 guid)
+{
+    return GetObjectInMap(guid, u.GetMap(), (Pet*)NULL);
+}
+
+Player* ObjectAccessor::GetPlayer(WorldObject const& u, uint64 guid)
+{
+    return GetObjectInMap(guid, u.GetMap(), (Player*)NULL);
+}
+
+Creature* ObjectAccessor::GetCreatureOrPetOrVehicle(WorldObject const& u, uint64 guid)
+{
+    if (IS_PET_GUID(guid))
+        return GetPet(u, guid);
+
+    if (IS_CRE_OR_VEH_GUID(guid))
+        return GetCreature(u, guid);
+
+    return NULL;
+}
+
+Pet* ObjectAccessor::FindPet(uint64 guid)
+{
+    return GetObjectInWorld(guid, (Pet*)NULL);
+}
+
+Player* ObjectAccessor::FindPlayer(uint64 guid)
+{
+    return GetObjectInWorld(guid, (Player*)NULL);
+}
+
+Unit* ObjectAccessor::FindUnit(uint64 guid)
+{
+    return GetObjectInWorld(guid, (Unit*)NULL);
+}
+
+Player* ObjectAccessor::FindPlayerByName(const char* name)
+{
+    ACE_GUARD_RETURN(LockType, g, *HashMapHolder<Player>::GetLock(), NULL);
+    HashMapHolder<Player>::MapType& m = HashMapHolder<Player>::GetContainer();
+    for (HashMapHolder<Player>::MapType::iterator iter = m.begin(); iter != m.end(); ++iter)
+        if (iter->second->IsInWorld() && strcmp(name, iter->second->GetName()) == 0)
+            return iter->second;
+
+    return NULL;
+}
+
+void ObjectAccessor::SaveAllPlayers()
+{
+    ACE_GUARD(LockType, g, *HashMapHolder<Player>::GetLock());
+    HashMapHolder<Player>::MapType& m = HashMapHolder<Player>::GetContainer();
+    for (HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+        itr->second->SaveToDB();
+}
+
+Corpse* ObjectAccessor::GetCorpseForPlayerGUID(uint64 guid)
+{
+    ACE_GUARD_RETURN(LockType, guard, i_corpseGuard, NULL);
+
+    Player2CorpsesMapType::iterator iter = i_player2corpse.find(guid);
+    if (iter == i_player2corpse.end())
+        return NULL;
+
+    ASSERT(iter->second->GetType() != CORPSE_BONES);
+
+    return iter->second;
+}
+
+void ObjectAccessor::RemoveCorpse(Corpse* corpse)
+{
+    ASSERT(corpse && corpse->GetType() != CORPSE_BONES);
+
+    if (corpse->FindMap())
+        corpse->FindMap()->Remove(corpse, false);
+    else
+        corpse->RemoveFromWorld();
+
+    // Critical section
+    {
+        ACE_GUARD(LockType, g, i_corpseGuard);
+
+        Player2CorpsesMapType::iterator iter = i_player2corpse.find(corpse->GetOwnerGUID());
+        if (iter == i_player2corpse.end()) // TODO: Fix this
+            return;
+
+        // build mapid*cellid -> guid_set map
+        CellPair cell_pair = Trinity::ComputeCellPair(corpse->GetPositionX(), corpse->GetPositionY());
+        uint32 cell_id = (cell_pair.y_coord * TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
+
+        sObjectMgr.DeleteCorpseCellData(corpse->GetMapId(), cell_id, GUID_LOPART(corpse->GetOwnerGUID()));
+
+        i_player2corpse.erase(iter);
+    }
+}
+
+void ObjectAccessor::AddCorpse(Corpse* corpse)
+{
+    ASSERT(corpse && corpse->GetType() != CORPSE_BONES);
+
+    // Critical section
+    {
+        ACE_GUARD(LockType, g, i_corpseGuard);
+
+        ASSERT(i_player2corpse.find(corpse->GetOwnerGUID()) == i_player2corpse.end());
+        i_player2corpse[corpse->GetOwnerGUID()] = corpse;
+
+        // build mapid*cellid -> guid_set map
+        CellPair cell_pair = Trinity::ComputeCellPair(corpse->GetPositionX(), corpse->GetPositionY());
+        uint32 cell_id = (cell_pair.y_coord * TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
+
+        sObjectMgr.AddCorpseCellData(corpse->GetMapId(), cell_id, GUID_LOPART(corpse->GetOwnerGUID()), corpse->GetInstanceId());
+    }
+}
+
+void ObjectAccessor::AddCorpsesToGrid(GridPair const& gridpair, GridType& grid, Map* map)
+{
+    ACE_GUARD(LockType, g, i_corpseGuard);
+
+    for (Player2CorpsesMapType::iterator iter = i_player2corpse.begin(); iter != i_player2corpse.end(); ++iter)
+    {
+        if (iter->second->GetGrid() == gridpair)
+        {
+            // verify, if the corpse in our instance (add only corpses which are)
+            if (map->Instanceable())
+            {
+                if (iter->second->GetInstanceId() == map->GetInstanceId())
+                    grid.AddWorldObject(iter->second);
+            }
+            else
+                grid.AddWorldObject(iter->second);
+        }
+    }
+}
+
+Corpse* ObjectAccessor::ConvertCorpseForPlayer(uint64 player_guid, bool /*insignia*/)
+{
+    Corpse* corpse = GetCorpseForPlayerGUID(player_guid);
+    if (!corpse)
+    {
+        //in fact this function is called from several places
+        //even when player doesn't have a corpse, not an error
+        // TODO: really, now...
+        //sLog.outError("Try remove corpse that not in map for GUID %ul", player_guid);
+        return NULL;
+    }
+
+    sLog.outStaticDebug("Deleting Corpse and spawned bones.");
+
+    //Map* map = corpse->FindMap();
+
+    // remove corpse from player_guid -> corpse map
+    RemoveCorpse(corpse);
+
+    // done in removecorpse
+    // remove resurrectable corpse from grid object registry (loaded state checked into call)
+    // do not load the map if it's not loaded
+    //Map *map = sMapMgr.FindMap(corpse->GetMapId(), corpse->GetInstanceId());
+    //if (map)
+    //    map->Remove(corpse, false);
+
+    // remove corpse from DB
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    corpse->DeleteFromDB(trans);
+    CharacterDatabase.CommitTransaction(trans);
+
+    // we don't want bones to save some cpu.. :)
+    delete corpse;
+    return NULL;
+
+    /*
+    Corpse* bones = NULL;
+    // create the bones only if the map and the grid is loaded at the corpse's location
+    // ignore bones creating option in case insignia
+    if (map && (insignia ||
+        (map->IsBattlegroundOrArena() ? sWorld.getIntConfig(CONFIG_DEATH_BONES_BG_OR_ARENA) : sWorld.getIntConfig(CONFIG_DEATH_BONES_WORLD))) &&
+        !map->IsRemovalGrid(corpse->GetPositionX(), corpse->GetPositionY()))
+    {
+        // Create bones, don't change Corpse
+        bones = new Corpse;
+        bones->Create(corpse->GetGUIDLow(), map);
+
+        for (int i = 3; i < CORPSE_END; ++i)                    // don't overwrite guid and object type
+            bones->SetUInt32Value(i, corpse->GetUInt32Value(i));
+
+        bones->SetGrid(corpse->GetGrid());
+        // bones->m_time = m_time;                              // don't overwrite time
+        // bones->m_inWorld = m_inWorld;                        // don't overwrite in-world state
+        // bones->m_type = m_type;                              // don't overwrite type
+        bones->Relocate(corpse->GetPositionX(), corpse->GetPositionY(), corpse->GetPositionZ(), corpse->GetOrientation());
+        bones->SetPhaseMask(corpse->GetPhaseMask(), false);
+
+        bones->SetUInt32Value(CORPSE_FIELD_FLAGS, CORPSE_FLAG_UNK2 | CORPSE_FLAG_BONES);
+        bones->SetUInt64Value(CORPSE_FIELD_OWNER, 0);
+
+        for (int i = 0; i < EQUIPMENT_SLOT_END; ++i)
+        {
+            if (corpse->GetUInt32Value(CORPSE_FIELD_ITEM + i))
+                bones->SetUInt32Value(CORPSE_FIELD_ITEM + i, 0);
+        }
+
+        // add bones in grid store if grid loaded where corpse placed
+        map->Add(bones);
+    }
+
+    // all references to the corpse should be removed at this point
+    delete corpse;
+
+    return bones;
+    */
+}
+
+void ObjectAccessor::RemoveOldCorpses()
+{
+    time_t now = time(NULL);
+    Player2CorpsesMapType::iterator next;
+    for (Player2CorpsesMapType::iterator itr = i_player2corpse.begin(); itr != i_player2corpse.end(); itr = next)
+    {
+        next = itr;
+        ++next;
+
+        if (!itr->second->IsExpired(now))
+            continue;
+
+        ConvertCorpseForPlayer(itr->first);
+    }
+}
+
+void ObjectAccessor::Update(uint32 /*diff*/)
+{
+    UpdateDataMapType update_players;
+
+    // Critical section
+    {
+        ACE_GUARD(LockType, g, i_updateGuard);
+
+        while (!i_objects.empty())
+        {
+            Object* obj = *i_objects.begin();
+            ASSERT(obj && obj->IsInWorld());
+            i_objects.erase(i_objects.begin());
+            obj->BuildUpdate(update_players);
+        }
+    }
+
+    WorldPacket packet;                                     // here we allocate a std::vector with a size of 0x10000
+    for (UpdateDataMapType::iterator iter = update_players.begin(); iter != update_players.end(); ++iter)
+    {
+        iter->second.BuildPacket(&packet);
+        iter->first->GetSession()->SendPacket(&packet);
+        packet.clear();                                     // clean the string
+    }
+}
+
+/// Define the static members of HashMapHolder
+
+template <class T> UNORDERED_MAP< uint64, T* > HashMapHolder<T>::m_objectMap;
+template <class T> ACE_Thread_Mutex HashMapHolder<T>::i_lock;
+
+/// Global definitions for the hashmap storage
+
+template class HashMapHolder<Player>;
+template class HashMapHolder<Pet>;
+template class HashMapHolder<GameObject>;
+template class HashMapHolder<DynamicObject>;
+template class HashMapHolder<Creature>;
+template class HashMapHolder<Corpse>;
+
+template Player* ObjectAccessor::GetObjectInWorld<Player>(uint32 mapid, float x, float y, uint64 guid, Player* /*fake*/);
+template Pet* ObjectAccessor::GetObjectInWorld<Pet>(uint32 mapid, float x, float y, uint64 guid, Pet* /*fake*/);
+template Creature* ObjectAccessor::GetObjectInWorld<Creature>(uint32 mapid, float x, float y, uint64 guid, Creature* /*fake*/);
+template Corpse* ObjectAccessor::GetObjectInWorld<Corpse>(uint32 mapid, float x, float y, uint64 guid, Corpse* /*fake*/);
+template GameObject* ObjectAccessor::GetObjectInWorld<GameObject>(uint32 mapid, float x, float y, uint64 guid, GameObject* /*fake*/);
+template DynamicObject* ObjectAccessor::GetObjectInWorld<DynamicObject>(uint32 mapid, float x, float y, uint64 guid, DynamicObject* /*fake*/);
diff --git a/src/server/game/Globals/ObjectAccessor.h b/src/server/game/Globals/ObjectAccessor.h
--- a/src/server/game/Globals/ObjectAccessor.h
+++ b/src/server/game/Globals/ObjectAccessor.h
@@ -1,274 +1,272 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef TRINITY_OBJECTACCESSOR_H
-#define TRINITY_OBJECTACCESSOR_H
-
-#include "Define.h"
-#include <ace/Singleton.h>
-#include <ace/Thread_Mutex.h>
-#include "UnorderedMap.h"
-
-#include "UpdateData.h"
-
-#include "GridDefines.h"
-#include "Object.h"
-#include "Player.h"
-
-#include <set>
-
-class Creature;
-class Corpse;
-class Unit;
-class GameObject;
-class DynamicObject;
-class WorldObject;
-class Vehicle;
-class Map;
-
-template <class T>
-class HashMapHolder
-{
-    public:
-
-        typedef UNORDERED_MAP<uint64, T*> MapType;
-        typedef ACE_Thread_Mutex LockType;
-
-        static void Insert(T* o)
-        {
-            ACE_GUARD(LockType, Guard, i_lock);
-            m_objectMap[o->GetGUID()] = o;
-        }
-
-        static void Remove(T* o)
-        {
-            ACE_GUARD(LockType, Guard, i_lock);
-            m_objectMap.erase(o->GetGUID());
-        }
-
-        static T* Find(uint64 guid)
-        {
-            ACE_GUARD_RETURN(LockType, Guard, i_lock, NULL);
-            typename MapType::iterator itr = m_objectMap.find(guid);
-            return (itr != m_objectMap.end()) ? itr->second : NULL;
-        }
-
-        static MapType& GetContainer() { return m_objectMap; }
-
-        static LockType* GetLock() { return &i_lock; }
-
-    private:
-
-        //Non instanceable only static
-        HashMapHolder() {}
-
-        static LockType i_lock;
-        static MapType  m_objectMap;
-};
-
-class ObjectAccessor
-{
-    friend class ACE_Singleton<ObjectAccessor, ACE_Thread_Mutex>;
-    ObjectAccessor();
-    ~ObjectAccessor();
-    ObjectAccessor(const ObjectAccessor&);
-    ObjectAccessor& operator=(const ObjectAccessor&);
-
-    public:
-
-        typedef UNORDERED_MAP<uint64, Corpse*> Player2CorpsesMapType;
-        typedef UNORDERED_MAP<Player*, UpdateData>::value_type UpdateDataValueType;
-
-        // TODO: override these template functions for each holder type and add assertions
-
-        template<class T> static T* GetObjectInOrOutOfWorld(uint64 guid, T* /*typeSpecifier*/)
-        {
-            return HashMapHolder<T>::Find(guid);
-        }
-        static Unit* GetObjectInOrOutOfWorld(uint64 guid, Unit* /*typeSpecifier*/)
-        {
-            if (IS_PLAYER_GUID(guid))
-                return (Unit*)GetObjectInOrOutOfWorld(guid, (Player*)NULL);
-
-            if (IS_PET_GUID(guid))
-                return (Unit*)GetObjectInOrOutOfWorld(guid, (Pet*)NULL);
-
-            return (Unit*)GetObjectInOrOutOfWorld(guid, (Creature*)NULL);
-        }
-
-        // returns object if is in world
-        template<class T> static T* GetObjectInWorld(uint64 guid, T* /*typeSpecifier*/)
-        {
-            return HashMapHolder<T>::Find(guid);
-        }
-
-        // Player may be not in world while in ObjectAccessor
-        static Player* GetObjectInWorld(uint64 guid, Player* /*typeSpecifier*/)
-        {
-            Player * player = HashMapHolder<Player>::Find(guid);
-            if (player && player->IsInWorld())
-                return player;
-            return NULL;
-        }
-
-        static Unit* GetObjectInWorld(uint64 guid, Unit* /*typeSpecifier*/)
-        {
-            if (IS_PLAYER_GUID(guid))
-                return (Unit*)GetObjectInWorld(guid, (Player*)NULL);
-
-            if (IS_PET_GUID(guid))
-                return (Unit*)GetObjectInWorld(guid, (Pet*)NULL);
-
-            return (Unit*)GetObjectInWorld(guid, (Creature*)NULL);
-        }
-
-        // returns object if is in map
-        template<class T> static T* GetObjectInMap(uint64 guid, Map * map, T* /*typeSpecifier*/)
-        {
-            ASSERT(map);
-            if (T * obj = GetObjectInWorld(guid, (T*)NULL))
-                if (obj->GetMap() == map)
-                    return obj;
-            return NULL;
-        }
-
-        template<class T> static T* GetObjectInWorld(uint32 mapid, float x, float y, uint64 guid, T* /*fake*/)
-        {
-            T* obj = HashMapHolder<T>::Find(guid);
-            if (!obj || obj->GetMapId() != mapid)
-                return NULL;
-
-            CellPair p = Trinity::ComputeCellPair(x, y);
-            if (p.x_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP || p.y_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP)
-            {
-                sLog.outError("ObjectAccessor::GetObjectInWorld: invalid coordinates supplied X:%f Y:%f grid cell [%u:%u]", x, y, p.x_coord, p.y_coord);
-                return NULL;
-            }
-
-            CellPair q = Trinity::ComputeCellPair(obj->GetPositionX(), obj->GetPositionY());
-            if (q.x_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP || q.y_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP)
-            {
-                sLog.outError("ObjectAccessor::GetObjecInWorld: object (GUID: %u TypeId: %u) has invalid coordinates X:%f Y:%f grid cell [%u:%u]", obj->GetGUIDLow(), obj->GetTypeId(), obj->GetPositionX(), obj->GetPositionY(), q.x_coord, q.y_coord);
-                return NULL;
-            }
-
-            int32 dx = int32(p.x_coord) - int32(q.x_coord);
-            int32 dy = int32(p.y_coord) - int32(q.y_coord);
-
-            if (dx > -2 && dx < 2 && dy > -2 && dy < 2)
-                return obj;
-            else
-                return NULL;
-        }
-
-        // these functions return objects only if in map of specified object
-        static WorldObject* GetWorldObject(WorldObject const&, uint64);
-        static Object* GetObjectByTypeMask(WorldObject const&, uint64, uint32 typemask);
-        static Corpse* GetCorpse(WorldObject const& u, uint64 guid);
-        static GameObject* GetGameObject(WorldObject const& u, uint64 guid);
-        static DynamicObject* GetDynamicObject(WorldObject const& u, uint64 guid);
-        static Unit* GetUnit(WorldObject const&, uint64 guid);
-        static Creature* GetCreature(WorldObject const& u, uint64 guid);
-        static Pet* GetPet(WorldObject const&, uint64 guid);
-        static Player* GetPlayer(WorldObject const&, uint64 guid);
-        static Creature* GetCreatureOrPetOrVehicle(WorldObject const&, uint64);
-
-        // these functions return objects if found in whole world
-        // ACCESS LIKE THAT IS NOT THREAD SAFE
-        static Pet * FindPet(uint64);
-        static Player* FindPlayer(uint64);
-        static Unit* FindUnit(uint64);
-        Player* FindPlayerByName(const char* name);
-
-        // when using this, you must use the hashmapholder's lock
-        HashMapHolder<Player>::MapType& GetPlayers()
-        {
-            return HashMapHolder<Player>::GetContainer();
-        }
-
-        // when using this, you must use the hashmapholder's lock
-        HashMapHolder<Creature>::MapType& GetCreatures()
-        {
-            return HashMapHolder<Creature>::GetContainer();
-        }
-
-        // when using this, you must use the hashmapholder's lock
-        HashMapHolder<GameObject>::MapType& GetGameObjects()
-        {
-            return HashMapHolder<GameObject>::GetContainer();
-        }
-
-        template<class T> void AddObject(T* object)
-        {
-            HashMapHolder<T>::Insert(object);
-        }
-
-        template<class T> void RemoveObject(T* object)
-        {
-            HashMapHolder<T>::Remove(object);
-        }
-
-        void RemoveObject(Player* pl)
-        {
-            HashMapHolder<Player>::Remove(pl);
-            RemoveUpdateObject((Object*)pl);
-        }
-
-        void SaveAllPlayers();
-
-        void AddUpdateObject(Object* obj)
-        {
-            ACE_GUARD(LockType, Guard, i_updateGuard);
-            i_objects.insert(obj);
-        }
-
-        void RemoveUpdateObject(Object* obj)
-        {
-            ACE_GUARD(LockType, Guard, i_updateGuard);
-            i_objects.erase(obj);
-        }
-
-        void Update(uint32 diff);
-
-        Corpse* GetCorpseForPlayerGUID(uint64 guid);
-        void RemoveCorpse(Corpse* corpse);
-        void AddCorpse(Corpse* corpse);
-        void AddCorpsesToGrid(GridPair const& gridpair, GridType& grid, Map* map);
-        Corpse* ConvertCorpseForPlayer(uint64 player_guid, bool insignia = false);
-        void RemoveOldCorpses();
-
-        typedef ACE_Thread_Mutex LockType;
-
-    private:
-
-        Player2CorpsesMapType i_player2corpse;
-
-        static void _buildChangeObjectForPlayer(WorldObject*, UpdateDataMapType&);
-        static void _buildPacket(Player*, Object*, UpdateDataMapType&);
-        void _update();
-
-        std::set<Object*> i_objects;
-
-        LockType i_updateGuard;
-        LockType i_corpseGuard;
-};
-
-#define sObjectAccessor (*ACE_Singleton<ObjectAccessor, ACE_Thread_Mutex>::instance())
-#endif
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TRINITY_OBJECTACCESSOR_H
+#define TRINITY_OBJECTACCESSOR_H
+
+#include "Define.h"
+#include <ace/Singleton.h>
+#include <ace/Thread_Mutex.h>
+#include "UnorderedMap.h"
+
+#include "UpdateData.h"
+
+#include "GridDefines.h"
+#include "Object.h"
+#include "Player.h"
+
+#include <set>
+
+class Creature;
+class Corpse;
+class Unit;
+class GameObject;
+class DynamicObject;
+class WorldObject;
+class Vehicle;
+class Map;
+
+template <class T>
+class HashMapHolder
+{
+    public:
+
+        typedef UNORDERED_MAP<uint64, T*> MapType;
+        typedef ACE_Thread_Mutex LockType;
+
+        static void Insert(T* o)
+        {
+            ACE_GUARD(LockType, Guard, i_lock);
+            m_objectMap[o->GetGUID()] = o;
+        }
+
+        static void Remove(T* o)
+        {
+            ACE_GUARD(LockType, Guard, i_lock);
+            m_objectMap.erase(o->GetGUID());
+        }
+
+        static T* Find(uint64 guid)
+        {
+            ACE_GUARD_RETURN(LockType, Guard, i_lock, NULL);
+            typename MapType::iterator itr = m_objectMap.find(guid);
+            return (itr != m_objectMap.end()) ? itr->second : NULL;
+        }
+
+        static MapType& GetContainer() { return m_objectMap; }
+
+        static LockType* GetLock() { return &i_lock; }
+
+    private:
+
+        //Non instanceable only static
+        HashMapHolder() {}
+
+        static LockType i_lock;
+        static MapType  m_objectMap;
+};
+
+class ObjectAccessor
+{
+    friend class ACE_Singleton<ObjectAccessor, ACE_Thread_Mutex>;
+    ObjectAccessor();
+    ~ObjectAccessor();
+    ObjectAccessor(const ObjectAccessor&);
+    ObjectAccessor& operator=(const ObjectAccessor&);
+
+    public:
+
+        typedef UNORDERED_MAP<uint64, Corpse*> Player2CorpsesMapType;
+        typedef UNORDERED_MAP<Player*, UpdateData>::value_type UpdateDataValueType;
+
+        // TODO: override these template functions for each holder type and add assertions
+
+        template<class T> static T* GetObjectInOrOutOfWorld(uint64 guid, T* /*typeSpecifier*/)
+        {
+            return HashMapHolder<T>::Find(guid);
+        }
+        static Unit* GetObjectInOrOutOfWorld(uint64 guid, Unit* /*typeSpecifier*/)
+        {
+            if (IS_PLAYER_GUID(guid))
+                return (Unit*)GetObjectInOrOutOfWorld(guid, (Player*)NULL);
+
+            if (IS_PET_GUID(guid))
+                return (Unit*)GetObjectInOrOutOfWorld(guid, (Pet*)NULL);
+
+            return (Unit*)GetObjectInOrOutOfWorld(guid, (Creature*)NULL);
+        }
+
+        // returns object if is in world
+        template<class T> static T* GetObjectInWorld(uint64 guid, T* /*typeSpecifier*/)
+        {
+            return HashMapHolder<T>::Find(guid);
+        }
+
+        // Player may be not in world while in ObjectAccessor
+        static Player* GetObjectInWorld(uint64 guid, Player* /*typeSpecifier*/)
+        {
+            Player * player = HashMapHolder<Player>::Find(guid);
+            if (player && player->IsInWorld())
+                return player;
+            return NULL;
+        }
+
+        static Unit* GetObjectInWorld(uint64 guid, Unit* /*typeSpecifier*/)
+        {
+            if (IS_PLAYER_GUID(guid))
+                return (Unit*)GetObjectInWorld(guid, (Player*)NULL);
+
+            if (IS_PET_GUID(guid))
+                return (Unit*)GetObjectInWorld(guid, (Pet*)NULL);
+
+            return (Unit*)GetObjectInWorld(guid, (Creature*)NULL);
+        }
+
+        // returns object if is in map
+        template<class T> static T* GetObjectInMap(uint64 guid, Map * map, T* /*typeSpecifier*/)
+        {
+            ASSERT(map);
+            if (T * obj = GetObjectInWorld(guid, (T*)NULL))
+                if (obj->GetMap() == map)
+                    return obj;
+            return NULL;
+        }
+
+        template<class T> static T* GetObjectInWorld(uint32 mapid, float x, float y, uint64 guid, T* /*fake*/)
+        {
+            T* obj = HashMapHolder<T>::Find(guid);
+            if (!obj || obj->GetMapId() != mapid)
+                return NULL;
+
+            CellPair p = Trinity::ComputeCellPair(x, y);
+            if (p.x_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP || p.y_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP)
+            {
+                sLog.outError("ObjectAccessor::GetObjectInWorld: invalid coordinates supplied X:%f Y:%f grid cell [%u:%u]", x, y, p.x_coord, p.y_coord);
+                return NULL;
+            }
+
+            CellPair q = Trinity::ComputeCellPair(obj->GetPositionX(), obj->GetPositionY());
+            if (q.x_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP || q.y_coord >= TOTAL_NUMBER_OF_CELLS_PER_MAP)
+            {
+                sLog.outError("ObjectAccessor::GetObjecInWorld: object (GUID: %u TypeId: %u) has invalid coordinates X:%f Y:%f grid cell [%u:%u]", obj->GetGUIDLow(), obj->GetTypeId(), obj->GetPositionX(), obj->GetPositionY(), q.x_coord, q.y_coord);
+                return NULL;
+            }
+
+            int32 dx = int32(p.x_coord) - int32(q.x_coord);
+            int32 dy = int32(p.y_coord) - int32(q.y_coord);
+
+            if (dx > -2 && dx < 2 && dy > -2 && dy < 2)
+                return obj;
+            else
+                return NULL;
+        }
+
+        // these functions return objects only if in map of specified object
+        static WorldObject* GetWorldObject(WorldObject const&, uint64);
+        static Object* GetObjectByTypeMask(WorldObject const&, uint64, uint32 typemask);
+        static Corpse* GetCorpse(WorldObject const& u, uint64 guid);
+        static GameObject* GetGameObject(WorldObject const& u, uint64 guid);
+        static DynamicObject* GetDynamicObject(WorldObject const& u, uint64 guid);
+        static Unit* GetUnit(WorldObject const&, uint64 guid);
+        static Creature* GetCreature(WorldObject const& u, uint64 guid);
+        static Pet* GetPet(WorldObject const&, uint64 guid);
+        static Player* GetPlayer(WorldObject const&, uint64 guid);
+        static Creature* GetCreatureOrPetOrVehicle(WorldObject const&, uint64);
+
+        // these functions return objects if found in whole world
+        // ACCESS LIKE THAT IS NOT THREAD SAFE
+        static Pet * FindPet(uint64);
+        static Player* FindPlayer(uint64);
+        static Unit* FindUnit(uint64);
+        Player* FindPlayerByName(const char* name);
+
+        // when using this, you must use the hashmapholder's lock
+        HashMapHolder<Player>::MapType& GetPlayers()
+        {
+            return HashMapHolder<Player>::GetContainer();
+        }
+
+        // when using this, you must use the hashmapholder's lock
+        HashMapHolder<Creature>::MapType& GetCreatures()
+        {
+            return HashMapHolder<Creature>::GetContainer();
+        }
+
+        // when using this, you must use the hashmapholder's lock
+        HashMapHolder<GameObject>::MapType& GetGameObjects()
+        {
+            return HashMapHolder<GameObject>::GetContainer();
+        }
+
+        template<class T> void AddObject(T* object)
+        {
+            HashMapHolder<T>::Insert(object);
+        }
+
+        template<class T> void RemoveObject(T* object)
+        {
+            HashMapHolder<T>::Remove(object);
+        }
+
+        void RemoveObject(Player* pl)
+        {
+            HashMapHolder<Player>::Remove(pl);
+            RemoveUpdateObject((Object*)pl);
+        }
+
+        void SaveAllPlayers();
+
+        void AddUpdateObject(Object* obj)
+        {
+            ACE_GUARD(LockType, Guard, i_updateGuard);
+            i_objects.insert(obj);
+        }
+
+        void RemoveUpdateObject(Object* obj)
+        {
+            ACE_GUARD(LockType, Guard, i_updateGuard);
+            i_objects.erase(obj);
+        }
+
+        void Update(uint32 diff);
+
+        Corpse* GetCorpseForPlayerGUID(uint64 guid);
+        void RemoveCorpse(Corpse* corpse);
+        void AddCorpse(Corpse* corpse);
+        void AddCorpsesToGrid(GridPair const& gridpair, GridType& grid, Map* map);
+        Corpse* ConvertCorpseForPlayer(uint64 player_guid, bool insignia = false);
+        void RemoveOldCorpses();
+
+        typedef ACE_Thread_Mutex LockType;
+
+    private:
+
+        Player2CorpsesMapType i_player2corpse;
+
+        static void _buildChangeObjectForPlayer(WorldObject*, UpdateDataMapType&);
+        static void _buildPacket(Player*, Object*, UpdateDataMapType&);
+        void _update();
+
+        std::set<Object*> i_objects;
+
+        LockType i_updateGuard;
+        LockType i_corpseGuard;
+};
+
+#define sObjectAccessor (*ACE_Singleton<ObjectAccessor, ACE_Thread_Mutex>::instance())
+#endif
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -1,9335 +1,9337 @@
-/*
-* Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
-* Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
-*
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* This program is distributed in the hope that it will be useful, but WITHOUT
-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
-* more details.
-*
-* You should have received a copy of the GNU General Public License along
-* with this program. If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "Common.h"
-#include "DatabaseEnv.h"
-#include "SQLStorage.h"
-#include "SQLStorageImpl.h"
-#include "Log.h"
-#include "MapManager.h"
-#include "ObjectMgr.h"
-#include "SpellMgr.h"
-#include "UpdateMask.h"
-#include "World.h"
-#include "Group.h"
-#include "Guild.h"
-#include "ArenaTeam.h"
-#include "Transport.h"
-#include "ProgressBar.h"
-#include "Language.h"
-#include "GameEventMgr.h"
-#include "Spell.h"
-#include "Chat.h"
-#include "AccountMgr.h"
-#include "InstanceSaveMgr.h"
-#include "SpellAuras.h"
-#include "Util.h"
-#include "WaypointManager.h"
-#include "GossipDef.h"
-#include "Vehicle.h"
-#include "AchievementMgr.h"
-#include "DisableMgr.h"
-#include "ScriptMgr.h"
-#include "SpellScript.h"
-#include "PoolMgr.h"
-
-ScriptMapMap sQuestEndScripts;
-ScriptMapMap sQuestStartScripts;
-ScriptMapMap sSpellScripts;
-ScriptMapMap sGameObjectScripts;
-ScriptMapMap sEventScripts;
-ScriptMapMap sGossipScripts;
-ScriptMapMap sWaypointScripts;
-
-std::string GetScriptsTableNameByType(ScriptsType type)
-{
-std::string res = "";
-switch (type)
-{
-case SCRIPTS_QUEST_END: res = "quest_end_scripts"; break;
-case SCRIPTS_QUEST_START: res = "quest_start_scripts";break;
-case SCRIPTS_SPELL: res = "spell_scripts"; break;
-case SCRIPTS_GAMEOBJECT: res = "gameobject_scripts"; break;
-case SCRIPTS_EVENT: res = "event_scripts"; break;
-case SCRIPTS_WAYPOINT: res = "waypoint_scripts"; break;
-case SCRIPTS_GOSSIP: res = "gossip_scripts"; break;
-default: break;
-}
-return res;
-}
-
-ScriptMapMap* GetScriptsMapByType(ScriptsType type)
-{
-ScriptMapMap* res = NULL;
-switch (type)
-{
-case SCRIPTS_QUEST_END: res = &sQuestEndScripts; break;
-case SCRIPTS_QUEST_START: res = &sQuestStartScripts; break;
-case SCRIPTS_SPELL: res = &sSpellScripts; break;
-case SCRIPTS_GAMEOBJECT: res = &sGameObjectScripts; break;
-case SCRIPTS_EVENT: res = &sEventScripts; break;
-case SCRIPTS_WAYPOINT: res = &sWaypointScripts; break;
-case SCRIPTS_GOSSIP: res = &sGossipScripts; break;
-default: break;
-}
-return res;
-}
-
-std::string GetScriptCommandName(ScriptCommands command)
-{
-std::string res = "";
-switch (command)
-{
-case SCRIPT_COMMAND_TALK: res = "SCRIPT_COMMAND_TALK"; break;
-case SCRIPT_COMMAND_EMOTE: res = "SCRIPT_COMMAND_EMOTE"; break;
-case SCRIPT_COMMAND_FIELD_SET: res = "SCRIPT_COMMAND_FIELD_SET"; break;
-case SCRIPT_COMMAND_MOVE_TO: res = "SCRIPT_COMMAND_MOVE_TO"; break;
-case SCRIPT_COMMAND_FLAG_SET: res = "SCRIPT_COMMAND_FLAG_SET"; break;
-case SCRIPT_COMMAND_FLAG_REMOVE: res = "SCRIPT_COMMAND_FLAG_REMOVE"; break;
-case SCRIPT_COMMAND_TELEPORT_TO: res = "SCRIPT_COMMAND_TELEPORT_TO"; break;
-case SCRIPT_COMMAND_QUEST_EXPLORED: res = "SCRIPT_COMMAND_QUEST_EXPLORED"; break;
-case SCRIPT_COMMAND_KILL_CREDIT: res = "SCRIPT_COMMAND_KILL_CREDIT"; break;
-case SCRIPT_COMMAND_RESPAWN_GAMEOBJECT: res = "SCRIPT_COMMAND_RESPAWN_GAMEOBJECT"; break;
-case SCRIPT_COMMAND_TEMP_SUMMON_CREATURE: res = "SCRIPT_COMMAND_TEMP_SUMMON_CREATURE"; break;
-case SCRIPT_COMMAND_OPEN_DOOR: res = "SCRIPT_COMMAND_OPEN_DOOR"; break;
-case SCRIPT_COMMAND_CLOSE_DOOR: res = "SCRIPT_COMMAND_CLOSE_DOOR"; break;
-case SCRIPT_COMMAND_ACTIVATE_OBJECT: res = "SCRIPT_COMMAND_ACTIVATE_OBJECT"; break;
-case SCRIPT_COMMAND_REMOVE_AURA: res = "SCRIPT_COMMAND_REMOVE_AURA"; break;
-case SCRIPT_COMMAND_CAST_SPELL: res = "SCRIPT_COMMAND_CAST_SPELL"; break;
-case SCRIPT_COMMAND_PLAY_SOUND: res = "SCRIPT_COMMAND_PLAY_SOUND"; break;
-case SCRIPT_COMMAND_CREATE_ITEM: res = "SCRIPT_COMMAND_CREATE_ITEM"; break;
-case SCRIPT_COMMAND_DESPAWN_SELF: res = "SCRIPT_COMMAND_DESPAWN_SELF"; break;
-case SCRIPT_COMMAND_LOAD_PATH: res = "SCRIPT_COMMAND_LOAD_PATH"; break;
-case SCRIPT_COMMAND_CALLSCRIPT_TO_UNIT: res = "SCRIPT_COMMAND_CALLSCRIPT_TO_UNIT"; break;
-case SCRIPT_COMMAND_KILL: res = "SCRIPT_COMMAND_KILL"; break;
-// TrinityCore only
-case SCRIPT_COMMAND_ORIENTATION: res = "SCRIPT_COMMAND_ORIENTATION"; break;
-case SCRIPT_COMMAND_EQUIP: res = "SCRIPT_COMMAND_EQUIP"; break;
-case SCRIPT_COMMAND_MODEL: res = "SCRIPT_COMMAND_MODEL"; break;
-case SCRIPT_COMMAND_CLOSE_GOSSIP: res = "SCRIPT_COMMAND_CLOSE_GOSSIP"; break;
-case SCRIPT_COMMAND_PLAYMOVIE: res = "SCRIPT_COMMAND_PLAYMOVIE"; break;
-default:
-{
-char sz[32];
-sprintf(sz, "Unknown command: %u", command);
-res = sz;
-break;
-}
-}
-return res;
-}
-
-std::string ScriptInfo::GetDebugInfo() const
-{
-char sz[256];
-sprintf(sz, "%s ('%s' script id: %u)", GetScriptCommandName(command).c_str(), GetScriptsTableNameByType(type).c_str(), id);
-return std::string(sz);
-}
-
-bool normalizePlayerName(std::string& name)
-{
-if (name.empty())
-return false;
-
-wchar_t wstr_buf[MAX_INTERNAL_PLAYER_NAME+1];
-size_t wstr_len = MAX_INTERNAL_PLAYER_NAME;
-
-if (!Utf8toWStr(name,&wstr_buf[0],wstr_len))
-return false;
-
-wstr_buf[0] = wcharToUpper(wstr_buf[0]);
-for (size_t i = 1; i < wstr_len; ++i)
-wstr_buf[i] = wcharToLower(wstr_buf[i]);
-
-if (!WStrToUtf8(wstr_buf,wstr_len,name))
-return false;
-
-return true;
-}
-
-LanguageDesc lang_description[LANGUAGES_COUNT] =
-{
-{ LANG_ADDON, 0, 0 },
-{ LANG_UNIVERSAL, 0, 0 },
-{ LANG_ORCISH, 669, SKILL_LANG_ORCISH },
-{ LANG_DARNASSIAN, 671, SKILL_LANG_DARNASSIAN },
-{ LANG_TAURAHE, 670, SKILL_LANG_TAURAHE },
-{ LANG_DWARVISH, 672, SKILL_LANG_DWARVEN },
-{ LANG_COMMON, 668, SKILL_LANG_COMMON },
-{ LANG_DEMONIC, 815, SKILL_LANG_DEMON_TONGUE },
-{ LANG_TITAN, 816, SKILL_LANG_TITAN },
-{ LANG_THALASSIAN, 813, SKILL_LANG_THALASSIAN },
-{ LANG_DRACONIC, 814, SKILL_LANG_DRACONIC },
-{ LANG_KALIMAG, 817, SKILL_LANG_OLD_TONGUE },
-{ LANG_GNOMISH, 7340, SKILL_LANG_GNOMISH },
-{ LANG_TROLL, 7341, SKILL_LANG_TROLL },
-{ LANG_GUTTERSPEAK, 17737, SKILL_LANG_GUTTERSPEAK },
-{ LANG_DRAENEI, 29932, SKILL_LANG_DRAENEI },
-{ LANG_ZOMBIE, 0, 0 },
-{ LANG_GNOMISH_BINARY, 0, 0 },
-{ LANG_GOBLIN_BINARY, 0, 0 }
-};
-
-LanguageDesc const* GetLanguageDescByID(uint32 lang)
-{
-for (uint8 i = 0; i < LANGUAGES_COUNT; ++i)
-{
-if (uint32(lang_description[i].lang_id) == lang)
-return &lang_description[i];
-}
-
-return NULL;
-}
-
-bool SpellClickInfo::IsFitToRequirements(Player const* player, Creature const * clickNpc) const
-{
-if (questStart)
-{
-// not in expected required quest state
-if (!player || ((!questStartCanActive || !player->IsActiveQuest(questStart)) && !player->GetQuestRewardStatus(questStart)))
-return false;
-}
-
-if (questEnd)
-{
-// not in expected forbidden quest state
-if (!player || player->GetQuestRewardStatus(questEnd))
-return false;
-}
-
-if (auraRequired)
-if (!player->HasAura(auraRequired))
-return false;
-
-if (auraForbidden)
-if (player->HasAura(auraForbidden))
-return false;
-
-Unit const * summoner = NULL;
-// Check summoners for party
-if (clickNpc->isSummon())
-summoner = clickNpc->ToTempSummon()->GetSummoner();
-if (!summoner)
-summoner = clickNpc;
-
-switch (userType)
-{
-case SPELL_CLICK_USER_FRIEND:
-if (!player->IsFriendlyTo(summoner))
-return false;
-break;
-case SPELL_CLICK_USER_RAID:
-if (!player->IsInRaidWith(summoner))
-return false;
-break;
-case SPELL_CLICK_USER_PARTY:
-if (!player->IsInPartyWith(summoner))
-return false;
-break;
-default:
-break;
-}
-
-return true;
-}
-
-ObjectMgr::ObjectMgr()
-{
-m_hiCharGuid = 1;
-m_hiCreatureGuid = 1;
-m_hiPetGuid = 1;
-m_hiVehicleGuid = 1;
-m_hiItemGuid = 1;
-m_hiGoGuid = 1;
-m_hiDoGuid = 1;
-m_hiCorpseGuid = 1;
-m_hiPetNumber = 1;
-m_hiGroupGuid = 1;
-m_hiMoTransGuid = 1;
-m_ItemTextId = 1;
-m_mailid = 1;
-m_equipmentSetGuid = 1;
-m_guildId = 1;
-m_arenaTeamId = 1;
-m_auctionid = 1;
-}
-
-ObjectMgr::~ObjectMgr()
-{
-for (QuestMap::iterator i = mQuestTemplates.begin(); i != mQuestTemplates.end(); ++i)
-delete i->second;
-
-for (PetLevelInfoMap::iterator i = petInfo.begin(); i != petInfo.end(); ++i)
-delete[] i->second;
-
-// free only if loaded
-for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
-delete[] playerClassInfo[class_].levelInfo;
-
-for (int race = 0; race < MAX_RACES; ++race)
-for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
-delete[] playerInfo[race][class_].levelInfo;
-
-// free group and guild objects
-for (GroupSet::iterator itr = mGroupSet.begin(); itr != mGroupSet.end(); ++itr)
-delete *itr;
-
-for (GuildMap::iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
-if (*itr)
-delete *itr;
-
-for (ArenaTeamMap::iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
-delete itr->second;
-
-for (CacheVendorItemMap::iterator itr = m_mCacheVendorItemMap.begin(); itr != m_mCacheVendorItemMap.end(); ++itr)
-itr->second.Clear();
-
-for (CacheTrainerSpellMap::iterator itr = m_mCacheTrainerSpellMap.begin(); itr != m_mCacheTrainerSpellMap.end(); ++itr)
-itr->second.Clear();
-}
-
-Group * ObjectMgr::GetGroupByGUID(uint32 guid) const
-{
-for (GroupSet::const_iterator itr = mGroupSet.begin(); itr != mGroupSet.end(); ++itr)
-if ((*itr)->GetLowGUID() == guid)
-return *itr;
-
-return NULL;
-}
-
-// Guild collection
-Guild* ObjectMgr::GetGuildById(uint32 guildId) const
-{
-// Make sure given index exists in collection
-if (guildId < uint32(mGuildMap.size()))
-return mGuildMap[guildId];
-return NULL;
-}
-
-Guild* ObjectMgr::GetGuildByName(const std::string& guildname) const
-{
-std::string search = guildname;
-std::transform(search.begin(), search.end(), search.begin(), ::toupper);
-for (GuildMap::const_iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
-{
-if (*itr)
-{
-std::string gname = (*itr)->GetName();
-std::transform(gname.begin(), gname.end(), gname.begin(), ::toupper);
-if (search == gname)
-return *itr;
-}
-}
-return NULL;
-}
-
-std::string ObjectMgr::GetGuildNameById(uint32 guildId) const
-{
-if (Guild* pGuild = GetGuildById(guildId))
-return pGuild->GetName();
-return "";
-}
-
-Guild* ObjectMgr::GetGuildByLeader(const uint64 &guid) const
-{
-for (GuildMap::const_iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
-if ((*itr) && (*itr)->GetLeaderGUID() == guid)
-return *itr;
-
-return NULL;
-}
-
-void ObjectMgr::AddGuild(Guild* pGuild)
-{
-uint32 guildId = pGuild->GetId();
-// Allocate space if necessary
-if (guildId >= uint32(mGuildMap.size()))
-// Reserve a bit more space than necessary.
-// 16 is intentional and it will allow creation of next 16 guilds happen
-// without reallocation.
-mGuildMap.resize(guildId + 16);
-mGuildMap[guildId] = pGuild;
-}
-
-void ObjectMgr::RemoveGuild(uint32 guildId)
-{
-// Make sure given index exists
-if (guildId < uint32(mGuildMap.size()))
-mGuildMap[guildId] = NULL;
-}
-
-// Arena teams collection
-ArenaTeam* ObjectMgr::GetArenaTeamById(uint32 arenateamid) const
-{
-ArenaTeamMap::const_iterator itr = mArenaTeamMap.find(arenateamid);
-if (itr != mArenaTeamMap.end())
-return itr->second;
-
-return NULL;
-}
-
-ArenaTeam* ObjectMgr::GetArenaTeamByName(const std::string& arenateamname) const
-{
-std::string search = arenateamname;
-std::transform(search.begin(), search.end(), search.begin(), ::toupper);
-for (ArenaTeamMap::const_iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
-{
-std::string teamname = itr->second->GetName();
-std::transform(teamname.begin(), teamname.end(), teamname.begin(), ::toupper);
-if (search == teamname)
-return itr->second;
-}
-return NULL;
-}
-
-ArenaTeam* ObjectMgr::GetArenaTeamByCaptain(uint64 const& guid) const
-{
-for (ArenaTeamMap::const_iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
-if (itr->second->GetCaptain() == guid)
-return itr->second;
-
-return NULL;
-}
-
-void ObjectMgr::AddArenaTeam(ArenaTeam* arenaTeam)
-{
-mArenaTeamMap[arenaTeam->GetId()] = arenaTeam;
-}
-
-void ObjectMgr::RemoveArenaTeam(uint32 Id)
-{
-mArenaTeamMap.erase(Id);
-}
-
-CreatureInfo const* ObjectMgr::GetCreatureTemplate(uint32 id)
-{
-return sCreatureStorage.LookupEntry<CreatureInfo>(id);
-}
-
-void ObjectMgr::AddLocaleString(std::string& s, LocaleConstant locale, StringVector& data)
-{
-if (!s.empty())
-{
-if (data.size() <= size_t(locale))
-data.resize(locale + 1);
-
-data[locale] = s;
-}
-}
-
-void ObjectMgr::LoadCreatureLocales()
-{
-mCreatureLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT entry,name_loc1,subname_loc1,name_loc2,subname_loc2,name_loc3,subname_loc3,name_loc4,subname_loc4,name_loc5,subname_loc5,name_loc6,subname_loc6,name_loc7,subname_loc7,name_loc8,subname_loc8 FROM locales_creature");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-CreatureLocale& data = mCreatureLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-LocaleConstant locale = (LocaleConstant) i;
-std::string str = fields[1 + 2 * (i - 1)].GetString();
-AddLocaleString(str, locale, data.Name);
-
-str = fields[1 + 2 * (i - 1) + 1].GetString();
-AddLocaleString(str, locale, data.SubName);
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu creature locale strings", (unsigned long)mCreatureLocaleMap.size());
-}
-
-void ObjectMgr::LoadGossipMenuItemsLocales()
-{
-mGossipMenuItemsLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT menu_id,id,"
-"option_text_loc1,box_text_loc1,option_text_loc2,box_text_loc2,"
-"option_text_loc3,box_text_loc3,option_text_loc4,box_text_loc4,"
-"option_text_loc5,box_text_loc5,option_text_loc6,box_text_loc6,"
-"option_text_loc7,box_text_loc7,option_text_loc8,box_text_loc8 "
-"FROM locales_gossip_menu_option");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint16 menuId = fields[0].GetUInt16();
-uint16 id = fields[1].GetUInt16();
-
-GossipMenuItemsLocale& data = mGossipMenuItemsLocaleMap[MAKE_PAIR32(menuId,id)];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-LocaleConstant locale = (LocaleConstant) i;
-std::string str = fields[2 + 2 * (i - 1)].GetString();
-AddLocaleString(str, locale, data.OptionText);
-
-str = fields[2 + 2 * (i - 1) + 1].GetString();
-AddLocaleString(str, locale, data.BoxText);
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu gossip_menu_option locale strings", (unsigned long)mGossipMenuItemsLocaleMap.size());
-}
-
-void ObjectMgr::LoadPointOfInterestLocales()
-{
-mPointOfInterestLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT entry,icon_name_loc1,icon_name_loc2,icon_name_loc3,icon_name_loc4,icon_name_loc5,icon_name_loc6,icon_name_loc7,icon_name_loc8 FROM locales_points_of_interest");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-PointOfInterestLocale& data = mPointOfInterestLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-std::string str = fields[i].GetString();
-AddLocaleString(str, LocaleConstant(i), data.IconName);
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu points_of_interest locale strings", (unsigned long)mPointOfInterestLocaleMap.size());
-}
-
-struct SQLCreatureLoader : public SQLStorageLoaderBase<SQLCreatureLoader>
-{
-template<class D>
-void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
-{
-dst = D(sObjectMgr.GetScriptId(src));
-}
-};
-
-void ObjectMgr::LoadCreatureTemplates()
-{
-SQLCreatureLoader loader;
-loader.Load(sCreatureStorage);
-
-sLog.outString(">> Loaded %u creature definitions", sCreatureStorage.RecordCount);
-sLog.outString();
-
-// check data correctness
-for (uint32 i = 1; i < sCreatureStorage.MaxEntry; ++i)
-{
-CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i);
-CheckCreatureTemplate(cInfo);
-}
-}
-
-void ObjectMgr::CheckCreatureTemplate(CreatureInfo const* cInfo)
-{
-if (!cInfo)
-return;
-
-bool ok = true; // bool to allow continue outside this loop
-for (uint32 diff = 0; diff < MAX_DIFFICULTY - 1 && ok; ++diff)
-{
-if (!cInfo->DifficultyEntry[diff])
-continue;
-ok = false; // will be set to true at the end of this loop again
-
-CreatureInfo const* difficultyInfo = GetCreatureTemplate(cInfo->DifficultyEntry[diff]);
-if (!difficultyInfo)
-{
-sLog.outErrorDb("Creature (Entry: %u) has `difficulty_entry_%u`=%u but creature entry %u does not exist.",
-cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff], cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-bool ok2 = true;
-for (uint32 diff2 = 0; diff2 < MAX_DIFFICULTY - 1 && ok2; ++diff2)
-{
-ok2 = false;
-if (difficultyEntries[diff2].find(cInfo->Entry) != difficultyEntries[diff2].end())
-{
-sLog.outErrorDb("Creature (Entry: %u) is listed as `difficulty_entry_%u` of another creature, but itself lists %u in `difficulty_entry_%u`.",
-cInfo->Entry, diff2 + 1, cInfo->DifficultyEntry[diff], diff + 1);
-continue;
-}
-
-if (difficultyEntries[diff2].find(cInfo->DifficultyEntry[diff]) != difficultyEntries[diff2].end())
-{
-sLog.outErrorDb("Creature (Entry: %u) already listed as `difficulty_entry_%u` for another entry.", cInfo->DifficultyEntry[diff], diff2 + 1);
-continue;
-}
-
-if (hasDifficultyEntries[diff2].find(cInfo->DifficultyEntry[diff]) != hasDifficultyEntries[diff2].end())
-{
-sLog.outErrorDb("Creature (Entry: %u) has `difficulty_entry_%u`=%u but creature entry %u has itself a value in `difficulty_entry_%u`.",
-cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff], cInfo->DifficultyEntry[diff], diff2 + 1);
-continue;
-}
-ok2 = true;
-}
-if (!ok2)
-continue;
-
-if (cInfo->unit_class != difficultyInfo->unit_class)
-{
-sLog.outErrorDb("Creature (Entry: %u, class %u) has different `unit_class` in difficulty %u mode (Entry: %u, class %u).",
-cInfo->Entry, cInfo->unit_class, diff + 1, cInfo->DifficultyEntry[diff], difficultyInfo->unit_class);
-continue;
-}
-
-if (cInfo->npcflag != difficultyInfo->npcflag)
-{
-sLog.outErrorDb("Creature (Entry: %u) has different `npcflag` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-if (cInfo->trainer_class != difficultyInfo->trainer_class)
-{
-sLog.outErrorDb("Creature (Entry: %u) has different `trainer_class` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-if (cInfo->trainer_race != difficultyInfo->trainer_race)
-{
-sLog.outErrorDb("Creature (Entry: %u) has different `trainer_race` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-if (cInfo->trainer_type != difficultyInfo->trainer_type)
-{
-sLog.outErrorDb("Creature (Entry: %u) has different `trainer_type` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-if (cInfo->trainer_spell != difficultyInfo->trainer_spell)
-{
-sLog.outErrorDb("Creature (Entry: %u) has different `trainer_spell` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-if (difficultyInfo->AIName && *difficultyInfo->AIName)
-{
-sLog.outErrorDb("Creature (Entry: %u) lists difficulty %u mode entry %u with `AIName` filled in. `AIName` of difficulty 0 mode creature is always used instead.",
-cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-if (difficultyInfo->ScriptID)
-{
-sLog.outErrorDb("Creature (Entry: %u) lists difficulty %u mode entry %u with `ScriptName` filled in. `ScriptName` of difficulty 0 mode creature is always used instead.",
-cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
-continue;
-}
-
-hasDifficultyEntries[diff].insert(cInfo->Entry);
-difficultyEntries[diff].insert(cInfo->DifficultyEntry[diff]);
-ok = true;
-}
-
-FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(cInfo->faction_A);
-if (!factionTemplate)
-sLog.outErrorDb("Creature (Entry: %u) has non-existing faction_A template (%u).", cInfo->Entry, cInfo->faction_A);
-
-factionTemplate = sFactionTemplateStore.LookupEntry(cInfo->faction_H);
-if (!factionTemplate)
-sLog.outErrorDb("Creature (Entry: %u) has non-existing faction_H template (%u).", cInfo->Entry, cInfo->faction_H);
-
-// used later for scale
-CreatureDisplayInfoEntry const* displayScaleEntry = NULL;
-
-if (cInfo->Modelid1)
-{
-CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid1);
-if (!displayEntry)
-{
-sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid1 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid1);
-const_cast<CreatureInfo*>(cInfo)->Modelid1 = 0;
-}
-else if (!displayScaleEntry)
-displayScaleEntry = displayEntry;
-
-CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid1);
-if (!minfo)
-sLog.outErrorDb("No model data exist for `Modelid1` = %u listed by creature (Entry: %u).", cInfo->Modelid1, cInfo->Entry);
-}
-
-if (cInfo->Modelid2)
-{
-CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid2);
-if (!displayEntry)
-{
-sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid2 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid2);
-const_cast<CreatureInfo*>(cInfo)->Modelid2 = 0;
-}
-else if (!displayScaleEntry)
-displayScaleEntry = displayEntry;
-
-CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid2);
-if (!minfo)
-sLog.outErrorDb("No model data exist for `Modelid2` = %u listed by creature (Entry: %u).", cInfo->Modelid2, cInfo->Entry);
-}
-
-if (cInfo->Modelid3)
-{
-CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid3);
-if (!displayEntry)
-{
-sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid3 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid3);
-const_cast<CreatureInfo*>(cInfo)->Modelid3 = 0;
-}
-else if (!displayScaleEntry)
-displayScaleEntry = displayEntry;
-
-CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid3);
-if (!minfo)
-sLog.outErrorDb("No model data exist for `Modelid3` = %u listed by creature (Entry: %u).", cInfo->Modelid3, cInfo->Entry);
-}
-
-if (cInfo->Modelid4)
-{
-CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid4);
-if (!displayEntry)
-{
-sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid4 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid4);
-const_cast<CreatureInfo*>(cInfo)->Modelid4 = 0;
-}
-else if (!displayScaleEntry)
-displayScaleEntry = displayEntry;
-
-CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid4);
-if (!minfo)
-sLog.outErrorDb("No model data exist for `Modelid4` = %u listed by creature (Entry: %u).", cInfo->Modelid4, cInfo->Entry);
-}
-
-if (!displayScaleEntry)
-sLog.outErrorDb("Creature (Entry: %u) does not have any existing display id in Modelid1/Modelid2/Modelid3/Modelid4.", cInfo->Entry);
-
-for (int k = 0; k < MAX_KILL_CREDIT; ++k)
-{
-if (cInfo->KillCredit[k])
-{
-if (!GetCreatureTemplate(cInfo->KillCredit[k]))
-{
-sLog.outErrorDb("Creature (Entry: %u) lists non-existing creature entry %u in `KillCredit%d`.", cInfo->Entry, cInfo->KillCredit[k], k + 1);
-const_cast<CreatureInfo*>(cInfo)->KillCredit[k] = 0;
-}
-}
-}
-
-if (!cInfo->unit_class || ((1 << (cInfo->unit_class-1)) & CLASSMASK_ALL_CREATURES) == 0)
-{
-sLog.outErrorDb("Creature (Entry: %u) has invalid unit_class (%u) in creature_template. Set to 1 (UNIT_CLASS_WARRIOR).", cInfo->Entry, cInfo->unit_class);
-const_cast<CreatureInfo*>(cInfo)->unit_class = UNIT_CLASS_WARRIOR;
-}
-
-if (cInfo->dmgschool >= MAX_SPELL_SCHOOL)
-{
-sLog.outErrorDb("Creature (Entry: %u) has invalid spell school value (%u) in `dmgschool`.", cInfo->Entry, cInfo->dmgschool);
-const_cast<CreatureInfo*>(cInfo)->dmgschool = SPELL_SCHOOL_NORMAL;
-}
-
-if (cInfo->baseattacktime == 0)
-const_cast<CreatureInfo*>(cInfo)->baseattacktime = BASE_ATTACK_TIME;
-
-if (cInfo->rangeattacktime == 0)
-const_cast<CreatureInfo*>(cInfo)->rangeattacktime = BASE_ATTACK_TIME;
-
-if (cInfo->npcflag & UNIT_NPC_FLAG_SPELLCLICK)
-{
-sLog.outErrorDb("Creature (Entry: %u) has dynamic flag UNIT_NPC_FLAG_SPELLCLICK (%u) set, it is expected to be set by code handling `npc_spellclick_spells` content.", cInfo->Entry, UNIT_NPC_FLAG_SPELLCLICK);
-const_cast<CreatureInfo*>(cInfo)->npcflag &= ~UNIT_NPC_FLAG_SPELLCLICK;
-}
-
-if ((cInfo->npcflag & UNIT_NPC_FLAG_TRAINER) && cInfo->trainer_type >= MAX_TRAINER_TYPE)
-sLog.outErrorDb("Creature (Entry: %u) has wrong trainer type %u.", cInfo->Entry, cInfo->trainer_type);
-
-if (cInfo->type && !sCreatureTypeStore.LookupEntry(cInfo->type))
-{
-sLog.outErrorDb("Creature (Entry: %u) has invalid creature type (%u) in `type`.", cInfo->Entry, cInfo->type);
-const_cast<CreatureInfo*>(cInfo)->type = CREATURE_TYPE_HUMANOID;
-}
-
-// must exist or used hidden but used in data horse case
-if (cInfo->family && !sCreatureFamilyStore.LookupEntry(cInfo->family) && cInfo->family != CREATURE_FAMILY_HORSE_CUSTOM)
-{
-sLog.outErrorDb("Creature (Entry: %u) has invalid creature family (%u) in `family`.", cInfo->Entry, cInfo->family);
-const_cast<CreatureInfo*>(cInfo)->family = 0;
-}
-
-if (cInfo->InhabitType <= 0 || cInfo->InhabitType > INHABIT_ANYWHERE)
-{
-sLog.outErrorDb("Creature (Entry: %u) has wrong value (%u) in `InhabitType`, creature will not correctly walk/swim/fly.", cInfo->Entry, cInfo->InhabitType);
-const_cast<CreatureInfo*>(cInfo)->InhabitType = INHABIT_ANYWHERE;
-}
-
-if (cInfo->VehicleId)
-{
-VehicleEntry const* vehId = sVehicleStore.LookupEntry(cInfo->VehicleId);
-if (!vehId)
-{
-sLog.outErrorDb("Creature (Entry: %u) has a non-existing VehicleId (%u). This *WILL* cause the client to freeze!", cInfo->Entry, cInfo->VehicleId);
-const_cast<CreatureInfo*>(cInfo)->VehicleId = 0;
-}
-}
-
-if (cInfo->PetSpellDataId)
-{
-CreatureSpellDataEntry const* spellDataId = sCreatureSpellDataStore.LookupEntry(cInfo->PetSpellDataId);
-if (!spellDataId)
-sLog.outErrorDb("Creature (Entry: %u) has non-existing PetSpellDataId (%u).", cInfo->Entry, cInfo->PetSpellDataId);
-}
-
-for (uint8 j = 0; j < CREATURE_MAX_SPELLS; ++j)
-{
-if (cInfo->spells[j] && !sSpellStore.LookupEntry(cInfo->spells[j]))
-{
-sLog.outErrorDb("Creature (Entry: %u) has non-existing Spell%d (%u), set to 0.", cInfo->Entry, j+1, cInfo->spells[j]);
-const_cast<CreatureInfo*>(cInfo)->spells[j] = 0;
-}
-}
-
-if (cInfo->MovementType >= MAX_DB_MOTION_TYPE)
-{
-sLog.outErrorDb("Creature (Entry: %u) has wrong movement generator type (%u), ignored and set to IDLE.", cInfo->Entry, cInfo->MovementType);
-const_cast<CreatureInfo*>(cInfo)->MovementType = IDLE_MOTION_TYPE;
-}
-
-if (cInfo->equipmentId > 0) // 0 no equipment
-{
-if (!GetEquipmentInfo(cInfo->equipmentId))
-{
-sLog.outErrorDb("Table `creature_template` lists creature (Entry: %u) with `equipment_id` %u not found in table `creature_equip_template`, set to no equipment.", cInfo->Entry, cInfo->equipmentId);
-const_cast<CreatureInfo*>(cInfo)->equipmentId = 0;
-}
-}
-
-/// if not set custom creature scale then load scale from CreatureDisplayInfo.dbc
-if (cInfo->scale <= 0.0f)
-{
-if (displayScaleEntry)
-const_cast<CreatureInfo*>(cInfo)->scale = displayScaleEntry->scale;
-else
-const_cast<CreatureInfo*>(cInfo)->scale = 1.0f;
-}
-
-if (cInfo->expansion > (MAX_CREATURE_BASE_HP - 1))
-{
-sLog.outErrorDb("Table `creature_template` lists creature (Entry: %u) with expansion %u. Ignored and set to 0.", cInfo->Entry, cInfo->expansion);
-const_cast<CreatureInfo*>(cInfo)->expansion = 0;
-}
-
-const_cast<CreatureInfo*>(cInfo)->dmg_multiplier *= Creature::_GetDamageMod(cInfo->rank);
-}
-
-void ObjectMgr::ConvertCreatureAddonAuras(CreatureDataAddon* addon, char const* table, char const* guidEntryStr)
-{
-// Now add the auras, format "spellid effectindex spellid effectindex..."
-char *p,*s;
-std::map<uint32, uint32> val;
-s=p=(char*)reinterpret_cast<char const*>(addon->auras);
-if (p)
-{
-uint32 currSpellId = 0;
-bool spell = true;
-while (p[0] != 0)
-{
-++p;
-if (p[0] == ' ' || p[0] == 0)
-{
-if (spell)
-currSpellId = atoi(s);
-else
-{
-uint8 eff = atoi(s);
-if (eff >=3)
-{
-sLog.outErrorDb("Creature (%s: %u) has wrong `auras` data in `%s`(too high aura effect: %d for spell: %d)",guidEntryStr,addon->guidOrEntry,table,eff,currSpellId);
-}
-val[currSpellId] |= 1<<eff;
-}
-spell = !spell;
-if (p[0] == 0)
-break;
-s=++p;
-}
-}
-
-// free char* loaded memory
-delete[] (char*)reinterpret_cast<char const*>(addon->auras);
-
-// wrong list
-if (!spell)
-{
-addon->auras = NULL;
-sLog.outErrorDb("Creature (%s: %u) has wrong `auras` data in `%s`.",guidEntryStr,addon->guidOrEntry,table);
-return;
-}
-}
-
-// empty list
-if (val.empty())
-{
-addon->auras = NULL;
-return;
-}
-
-// replace by new structures array
-const_cast<CreatureDataAddonAura*&>(addon->auras) = new CreatureDataAddonAura[val.size()+1];
-
-uint32 i=0;
-for (std::map<uint32, uint32>::iterator itr = val.begin(); itr != val.end();++itr)
-{
-CreatureDataAddonAura& cAura = const_cast<CreatureDataAddonAura&>(addon->auras[i]);
-cAura.spell_id = itr->first;
-cAura.effectMask = itr->second;
-if (cAura.effectMask > 7 || !cAura.effectMask)
-{
-sLog.outErrorDb("Creature (%s: %u) has wrong effect for spell %u in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,cAura.spell_id,table);
-continue;
-}
-SpellEntry const *AdditionalSpellInfo = sSpellStore.LookupEntry(cAura.spell_id);
-if (!AdditionalSpellInfo)
-{
-sLog.outErrorDb("Creature (%s: %u) has wrong spell %u defined in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,cAura.spell_id,table);
-continue;
-}
-for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
-{
-if ((1<<eff) & cAura.effectMask)
-{
-if (!AdditionalSpellInfo->Effect[eff] || !AdditionalSpellInfo->EffectApplyAuraName[eff])
-{
-sLog.outErrorDb("Creature (%s: %u) has not aura effect %u of spell %u defined in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,eff,cAura.spell_id,table);
-continue;
-}
-else if (AdditionalSpellInfo->Effect[eff] == SPELL_EFFECT_PERSISTENT_AREA_AURA)
-{
-sLog.outErrorDb("Creature (%s: %u) has persistent area aura effect %u of spell %u defined in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,eff,cAura.spell_id,table);
-continue;
-}
-}
-}
-
-++i;
-}
-
-// fill terminator element (after last added)
-CreatureDataAddonAura& endAura = const_cast<CreatureDataAddonAura&>(addon->auras[i]);
-endAura.spell_id = 0;
-endAura.effectMask = 0;
-}
-
-void ObjectMgr::LoadCreatureAddons(SQLStorage& creatureaddons, char const* entryName, char const* comment)
-{
-creatureaddons.Load();
-
-sLog.outString(">> Loaded %u %s", creatureaddons.RecordCount, comment);
-sLog.outString();
-
-// check data correctness and convert 'auras'
-for (uint32 i = 1; i < creatureaddons.MaxEntry; ++i)
-{
-CreatureDataAddon const* addon = creatureaddons.LookupEntry<CreatureDataAddon>(i);
-if (!addon)
-continue;
-
-if (addon->mount)
-{
-if (!sCreatureDisplayInfoStore.LookupEntry(addon->mount))
-{
-sLog.outErrorDb("Creature (%s %u) have invalid displayInfoId for mount (%u) defined in `%s`.", entryName, addon->guidOrEntry, addon->mount, creatureaddons.GetTableName());
-const_cast<CreatureDataAddon*>(addon)->mount = 0;
-}
-}
-
-if (!sEmotesStore.LookupEntry(addon->emote))
-sLog.outErrorDb("Creature (%s %u) have invalid emote (%u) defined in `%s`.", entryName, addon->guidOrEntry, addon->emote, creatureaddons.GetTableName());
-
-/*if (addon->move_flags & (MONSTER_MOVE_UNK1|MONSTER_MOVE_UNK4))
-{
-sLog.outErrorDb("Creature (%s %u) movement flags mask defined in `%s` include forbidden flags (" I32FMT ") that can crash client, cleanup at load.", entryName, addon->guidOrEntry, creatureaddons.GetTableName(), (MONSTER_MOVE_UNK1|MONSTER_MOVE_UNK4));
-const_cast<CreatureDataAddon*>(addon)->move_flags &= ~(MONSTER_MOVE_UNK1|MONSTER_MOVE_UNK4);
-}*/
-
-ConvertCreatureAddonAuras(const_cast<CreatureDataAddon*>(addon), creatureaddons.GetTableName(), entryName);
-}
-}
-
-void ObjectMgr::LoadCreatureAddons()
-{
-LoadCreatureAddons(sCreatureInfoAddonStorage,"Entry","creature template addons");
-
-// check entry ids
-for (uint32 i = 1; i < sCreatureInfoAddonStorage.MaxEntry; ++i)
-if (CreatureDataAddon const* addon = sCreatureInfoAddonStorage.LookupEntry<CreatureDataAddon>(i))
-if (!sCreatureStorage.LookupEntry<CreatureInfo>(addon->guidOrEntry))
-sLog.outErrorDb("Creature (Entry: %u) does not exist but has a record in `%s`",addon->guidOrEntry, sCreatureInfoAddonStorage.GetTableName());
-
-sLog.outString("Loading Creature Addon Data...");
-LoadCreatureAddons(sCreatureDataAddonStorage,"GUID","creature addons");
-
-// check entry ids
-for (uint32 i = 1; i < sCreatureDataAddonStorage.MaxEntry; ++i)
-if (CreatureDataAddon const* addon = sCreatureDataAddonStorage.LookupEntry<CreatureDataAddon>(i))
-if (mCreatureDataMap.find(addon->guidOrEntry) == mCreatureDataMap.end())
-sLog.outErrorDb("Creature (GUID: %u) does not exist but has a record in `creature_addon`",addon->guidOrEntry);
-}
-
-EquipmentInfo const* ObjectMgr::GetEquipmentInfo(uint32 entry)
-{
-return sEquipmentStorage.LookupEntry<EquipmentInfo>(entry);
-}
-
-void ObjectMgr::LoadEquipmentTemplates()
-{
-sEquipmentStorage.Load();
-
-for (uint32 i = 0; i < sEquipmentStorage.MaxEntry; ++i)
-{
-EquipmentInfo const* eqInfo = sEquipmentStorage.LookupEntry<EquipmentInfo>(i);
-
-if (!eqInfo)
-continue;
-
-for (uint8 j = 0; j < 3; ++j)
-{
-if (!eqInfo->equipentry[j])
-continue;
-
-ItemEntry const *dbcitem = sItemStore.LookupEntry(eqInfo->equipentry[j]);
-
-if (!dbcitem)
-{
-sLog.outErrorDb("Unknown item (entry=%u) in creature_equip_template.equipentry%u for entry = %u, forced to 0.", eqInfo->equipentry[j], j+1, i);
-const_cast<EquipmentInfo*>(eqInfo)->equipentry[j] = 0;
-continue;
-}
-
-if (dbcitem->InventoryType != INVTYPE_WEAPON &&
-dbcitem->InventoryType != INVTYPE_SHIELD &&
-dbcitem->InventoryType != INVTYPE_RANGED &&
-dbcitem->InventoryType != INVTYPE_2HWEAPON &&
-dbcitem->InventoryType != INVTYPE_WEAPONMAINHAND &&
-dbcitem->InventoryType != INVTYPE_WEAPONOFFHAND &&
-dbcitem->InventoryType != INVTYPE_HOLDABLE &&
-dbcitem->InventoryType != INVTYPE_THROWN &&
-dbcitem->InventoryType != INVTYPE_RANGEDRIGHT)
-{
-sLog.outErrorDb("Item (entry=%u) in creature_equip_template.equipentry%u for entry = %u is not equipable in a hand, forced to 0.", eqInfo->equipentry[j], j+1, i);
-const_cast<EquipmentInfo*>(eqInfo)->equipentry[j] = 0;
-}
-}
-}
-sLog.outString(">> Loaded %u equipment template", sEquipmentStorage.RecordCount);
-sLog.outString();
-}
-
-CreatureModelInfo const* ObjectMgr::GetCreatureModelInfo(uint32 modelid)
-{
-return sCreatureModelStorage.LookupEntry<CreatureModelInfo>(modelid);
-}
-
-uint32 ObjectMgr::ChooseDisplayId(uint32 /*team*/, const CreatureInfo *cinfo, const CreatureData *data /*= NULL*/)
-{
-// Load creature model (display id)
-uint32 display_id = 0;
-
-if (!data || data->displayid == 0)
-{
-display_id = cinfo->GetRandomValidModelId();
-}
-else
-return data->displayid;
-
-return display_id;
-}
-
-void ObjectMgr::ChooseCreatureFlags(const CreatureInfo *cinfo, uint32& npcflag, uint32& unit_flags, uint32& dynamicflags, const CreatureData *data /*= NULL*/)
-{
-npcflag = cinfo->npcflag;
-unit_flags = cinfo->unit_flags;
-dynamicflags = cinfo->dynamicflags;
-
-if (data)
-{
-if (data->npcflag)
-npcflag = data->npcflag;
-
-if (data->unit_flags)
-unit_flags = data->unit_flags;
-
-if (data->dynamicflags)
-dynamicflags = data->dynamicflags;
-}
-}
-
-CreatureModelInfo const* ObjectMgr::GetCreatureModelRandomGender(uint32 display_id)
-{
-CreatureModelInfo const *minfo = GetCreatureModelInfo(display_id);
-if (!minfo)
-return NULL;
-
-// If a model for another gender exists, 50% chance to use it
-if (minfo->modelid_other_gender != 0 && urand(0,1) == 0)
-{
-CreatureModelInfo const *minfo_tmp = GetCreatureModelInfo(minfo->modelid_other_gender);
-if (!minfo_tmp)
-{
-sLog.outErrorDb("Model (Entry: %u) has modelid_other_gender %u not found in table `creature_model_info`. ", minfo->modelid, minfo->modelid_other_gender);
-return minfo; // not fatal, just use the previous one
-}
-else
-return minfo_tmp;
-}
-else
-return minfo;
-}
-
-void ObjectMgr::LoadCreatureModelInfo()
-{
-sCreatureModelStorage.Load();
-
-// post processing
-for (uint32 i = 1; i < sCreatureModelStorage.MaxEntry; ++i)
-{
-CreatureModelInfo const *minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(i);
-if (!minfo)
-continue;
-
-if (!sCreatureDisplayInfoStore.LookupEntry(minfo->modelid))
-sLog.outErrorDb("Table `creature_model_info` has model for not existed display id (%u).", minfo->modelid);
-
-if (minfo->gender > GENDER_NONE)
-{
-sLog.outErrorDb("Table `creature_model_info` has wrong gender (%u) for display id (%u).", uint32(minfo->gender), minfo->modelid);
-const_cast<CreatureModelInfo*>(minfo)->gender = GENDER_MALE;
-}
-
-if (minfo->modelid_other_gender && !sCreatureDisplayInfoStore.LookupEntry(minfo->modelid_other_gender))
-{
-sLog.outErrorDb("Table `creature_model_info` has not existed alt.gender model (%u) for existed display id (%u).", minfo->modelid_other_gender, minfo->modelid);
-const_cast<CreatureModelInfo*>(minfo)->modelid_other_gender = 0;
-}
-}
-
-sLog.outString(">> Loaded %u creature model based info", sCreatureModelStorage.RecordCount);
-sLog.outString();
-
-// check if combat_reach is valid
-for (uint32 i = 1; i < sCreatureModelStorage.MaxEntry; ++i)
-{
-CreatureModelInfo const* mInfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(i);
-if (!mInfo)
-continue;
-
-if (mInfo->combat_reach < 0.1f)
-{
-//sLog.outErrorDb("Creature model (Entry: %u) has invalid combat reach (%f), setting it to 0.5", mInfo->modelid, mInfo->combat_reach);
-const_cast<CreatureModelInfo*>(mInfo)->combat_reach = DEFAULT_COMBAT_REACH;
-}
-}
-}
-
-bool ObjectMgr::CheckCreatureLinkedRespawn(uint32 guid, uint32 linkedGuid) const
-{
-const CreatureData* const slave = GetCreatureData(guid);
-const CreatureData* const master = GetCreatureData(linkedGuid);
-
-if (!slave || !master) // they must have a corresponding entry in db
-{
-sLog.outError("LinkedRespawn: Creature '%u' linking to '%u' which doesn't exist",guid,linkedGuid);
-return false;
-}
-
-const MapEntry* const map = sMapStore.LookupEntry(master->mapid);
-
-if (master->mapid != slave->mapid // link only to same map
-&& (!map || map->Instanceable())) // or to unistanced world
-{
-sLog.outError("LinkedRespawn: Creature '%u' linking to '%u' on an unpermitted map",guid,linkedGuid);
-return false;
-}
-
-if (!(master->spawnMask & slave->spawnMask) // they must have a possibility to meet (normal/heroic difficulty)
-&& (!map || map->Instanceable()))
-{
-sLog.outError("LinkedRespawn: Creature '%u' linking to '%u' with not corresponding spawnMask",guid,linkedGuid);
-return false;
-}
-
-return true;
-}
-
-void ObjectMgr::LoadCreatureLinkedRespawn()
-{
-mCreatureLinkedRespawnMap.clear();
-QueryResult result = WorldDatabase.Query("SELECT guid, linkedGuid FROM creature_linked_respawn ORDER BY guid ASC");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 linked respawns. DB table `creature_linked_respawn` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 guid = fields[0].GetUInt32();
-uint32 linkedGuid = fields[1].GetUInt32();
-
-if (CheckCreatureLinkedRespawn(guid,linkedGuid))
-mCreatureLinkedRespawnMap[guid] = linkedGuid;
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded " UI64FMTD " linked respawns", uint64(mCreatureLinkedRespawnMap.size()));
-}
-
-bool ObjectMgr::SetCreatureLinkedRespawn(uint32 guid, uint32 linkedGuid)
-{
-if (!guid)
-return false;
-
-if (!linkedGuid) // we're removing the linking
-{
-mCreatureLinkedRespawnMap.erase(guid);
-PreparedStatement *stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_CRELINKED_RESPAWN);
-stmt->setUInt32(0, guid);
-WorldDatabase.Execute(stmt);
-return true;
-}
-
-if (CheckCreatureLinkedRespawn(guid,linkedGuid)) // we add/change linking
-{
-mCreatureLinkedRespawnMap[guid] = linkedGuid;
-PreparedStatement *stmt = WorldDatabase.GetPreparedStatement(WORLD_REP_CRELINKED_RESPAWN);
-stmt->setUInt32(0, guid);
-stmt->setUInt32(1, linkedGuid);
-WorldDatabase.Execute(stmt);
-return true;
-}
-
-return false;
-}
-
-void ObjectMgr::LoadCreatures()
-{
-uint32 count = 0;
-// 0 1 2 3
-QueryResult result = WorldDatabase.Query("SELECT creature.guid, id, map, modelid,"
-// 4 5 6 7 8 9 10 11
-"equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint,"
-// 12 13 14 15 16 17 18 19
-"curhealth, curmana, DeathState, MovementType, spawnMask, phaseMask, event, pool_entry,"
-// 20 21 22
-"creature.npcflag, creature.unit_flags, creature.dynamicflags "
-"FROM creature LEFT OUTER JOIN game_event_creature ON creature.guid = game_event_creature.guid "
-"LEFT OUTER JOIN pool_creature ON creature.guid = pool_creature.guid");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 creature. DB table `creature` is empty.");
-return;
-}
-
-// build single time for check creature data
-std::set<uint32> difficultyCreatures[MAX_DIFFICULTY - 1];
-for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
-if (CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i))
-for (uint32 diff = 0; diff < MAX_DIFFICULTY - 1; ++diff)
-if (cInfo->DifficultyEntry[diff])
-difficultyCreatures[diff].insert(cInfo->DifficultyEntry[diff]);
-
-// build single time for check spawnmask
-std::map<uint32,uint32> spawnMasks;
-for (uint32 i = 0; i < sMapStore.GetNumRows(); ++i)
-if (sMapStore.LookupEntry(i))
-for (int k = 0; k < MAX_DIFFICULTY; ++k)
-if (GetMapDifficultyData(i,Difficulty(k)))
-spawnMasks[i] |= (1 << k);
-
-//TODO: remove this
-//sGameEventMgr.mGameEventCreatureGuids.resize(52*2-1);
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 guid = fields[ 0].GetUInt32();
-uint32 entry = fields[ 1].GetUInt32();
-
-CreatureInfo const* cInfo = GetCreatureTemplate(entry);
-if (!cInfo)
-{
-sLog.outErrorDb("Table `creature` has creature (GUID: %u) with non existing creature entry %u, skipped.", guid, entry);
-continue;
-}
-
-CreatureData& data = mCreatureDataMap[guid];
-
-data.id = entry;
-data.mapid = fields[ 2].GetUInt32();
-data.displayid = fields[ 3].GetUInt32();
-data.equipmentId = fields[ 4].GetUInt32();
-data.posX = fields[ 5].GetFloat();
-data.posY = fields[ 6].GetFloat();
-data.posZ = fields[ 7].GetFloat();
-data.orientation = fields[ 8].GetFloat();
-data.spawntimesecs = fields[ 9].GetUInt32();
-data.spawndist = fields[10].GetFloat();
-data.currentwaypoint= fields[11].GetUInt32();
-data.curhealth = fields[12].GetUInt32();
-data.curmana = fields[13].GetUInt32();
-data.is_dead = fields[14].GetBool();
-data.movementType = fields[15].GetUInt8();
-data.spawnMask = fields[16].GetUInt8();
-data.phaseMask = fields[17].GetUInt16();
-int16 gameEvent = fields[18].GetInt16();
-uint32 PoolId = fields[19].GetUInt32();
-data.npcflag = fields[20].GetUInt32();
-data.unit_flags = fields[21].GetUInt32();
-data.dynamicflags = fields[22].GetUInt32();
-
-MapEntry const* mapEntry = sMapStore.LookupEntry(data.mapid);
-if (!mapEntry)
-{
-sLog.outErrorDb("Table `creature` have creature (GUID: %u) that spawned at not existed map (Id: %u), skipped.",guid, data.mapid);
-continue;
-}
-
-if (data.spawnMask & ~spawnMasks[data.mapid])
-sLog.outErrorDb("Table `creature` have creature (GUID: %u) that have wrong spawn mask %u including not supported difficulty modes for map (Id: %u).",guid, data.spawnMask, data.mapid);
-
-bool ok = true;
-for (uint32 diff = 0; diff < MAX_DIFFICULTY - 1 && ok; ++diff)
-{
-if (difficultyCreatures[diff].find(data.id) != difficultyCreatures[diff].end())
-{
-sLog.outErrorDb("Table `creature` have creature (GUID: %u) that listed as difficulty %u template (entry: %u) in `creature_template`, skipped.",
-guid, diff + 1, data.id);
-ok = false;
-}
-}
-if (!ok)
-continue;
-
-// I do not know why but in db most display id are not zero
-/*if (data.displayid == 11686 || data.displayid == 24719)
-{
-(const_cast<CreatureInfo*>(cInfo))->flags_extra |= CREATURE_FLAG_EXTRA_TRIGGER;
-}
-else if (data.displayid == cInfo->DisplayID_A || data.displayid == cInfo->DisplayID_A2
-|| data.displayid == cInfo->DisplayID_H || data.displayid == cInfo->DisplayID_H2)
-data.displayid = 0;
-*/
-
-if (data.equipmentId > 0) // -1 no equipment, 0 use default
-{
-if (!GetEquipmentInfo(data.equipmentId))
-{
-sLog.outErrorDb("Table `creature` have creature (Entry: %u) with equipment_id %u not found in table `creature_equip_template`, set to no equipment.", data.id, data.equipmentId);
-data.equipmentId = -1;
-}
-}
-
-if (cInfo->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
-{
-if (!mapEntry || !mapEntry->IsDungeon())
-sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `creature_template`.`flags_extra` including CREATURE_FLAG_EXTRA_INSTANCE_BIND but creature are not in instance.", guid, data.id);
-}
-
-if (data.spawndist < 0.0f)
-{
-sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `spawndist`< 0, set to 0.", guid, data.id);
-data.spawndist = 0.0f;
-}
-else if (data.movementType == RANDOM_MOTION_TYPE)
-{
-if (data.spawndist == 0.0f)
-{
-sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `MovementType`=1 (random movement) but with `spawndist`=0, replace by idle movement type (0).", guid, data.id);
-data.movementType = IDLE_MOTION_TYPE;
-}
-else if (cInfo->flags_extra & CREATURE_FLAG_EXTRA_TRIGGER)
-data.movementType = IDLE_MOTION_TYPE;
-}
-else if (data.movementType == IDLE_MOTION_TYPE)
-{
-if (data.spawndist != 0.0f)
-{
-sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `MovementType`=0 (idle) have `spawndist`<>0, set to 0.", guid, data.id);
-data.spawndist = 0.0f;
-}
-}
-
-if (data.phaseMask == 0)
-{
-sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `phaseMask`=0 (not visible for anyone), set to 1.", guid, data.id);
-data.phaseMask = 1;
-}
-
-if (data.npcflag & UNIT_NPC_FLAG_SPELLCLICK)
-{
-sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with npcflag UNIT_NPC_FLAG_SPELLCLICK (%u) set, it is expected to be set by code handling `npc_spellclick_spells` content.", guid, data.id, UNIT_NPC_FLAG_SPELLCLICK);
-data.npcflag &= ~UNIT_NPC_FLAG_SPELLCLICK;
-}
-
-//if (entry == 32307 || entry == 32308)
-/*if (entry == 30739 || entry == 30740)
-{
-gameEvent = 51;
-uint32 guid2 = sObjectMgr.GenerateLowGuid(HIGHGUID_UNIT);
-CreatureData& data2 = mCreatureDataMap[guid2];
-data2 = data;
-// data2.id = (entry == 32307 ? 32308 : 32307);
-data2.id = (entry == 30739 ? 30740 : 30739);
-data2.displayid = 0;
-sGameEventMgr.mGameEventCreatureGuids[51+51].push_back(guid);
-sGameEventMgr.mGameEventCreatureGuids[51+50].push_back(guid2);
-}*/
-
-if (gameEvent == 0 && PoolId == 0) // if not this is to be managed by GameEvent System or Pool system
-AddCreatureToGrid(guid, &data);
-
-++count;
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u creatures", (uint32)mCreatureDataMap.size());
-}
-
-void ObjectMgr::AddCreatureToGrid(uint32 guid, CreatureData const* data)
-{
-uint8 mask = data->spawnMask;
-for (uint8 i = 0; mask != 0; i++, mask >>= 1)
-{
-if (mask & 1)
-{
-CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
-uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
-
-CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
-cell_guids.creatures.insert(guid);
-}
-}
-}
-
-void ObjectMgr::RemoveCreatureFromGrid(uint32 guid, CreatureData const* data)
-{
-uint8 mask = data->spawnMask;
-for (uint8 i = 0; mask != 0; i++, mask >>= 1)
-{
-if (mask & 1)
-{
-CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
-uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
-
-CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
-cell_guids.creatures.erase(guid);
-}
-}
-}
-
-uint32 ObjectMgr::AddGOData(uint32 entry, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay, float rotation0, float rotation1, float rotation2, float rotation3)
-{
-GameObjectInfo const* goinfo = GetGameObjectInfo(entry);
-if (!goinfo)
-return 0;
-
-Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId));
-if (!map)
-return 0;
-
-uint32 guid = GenerateLowGuid(HIGHGUID_GAMEOBJECT);
-GameObjectData& data = NewGOData(guid);
-data.id = entry;
-data.mapid = mapId;
-data.posX = x;
-data.posY = y;
-data.posZ = z;
-data.orientation = o;
-data.rotation0 = rotation0;
-data.rotation1 = rotation1;
-data.rotation2 = rotation2;
-data.rotation3 = rotation3;
-data.spawntimesecs = spawntimedelay;
-data.animprogress = 100;
-data.spawnMask = 1;
-data.go_state = GO_STATE_READY;
-data.phaseMask = PHASEMASK_NORMAL;
-data.artKit = goinfo->type == GAMEOBJECT_TYPE_CAPTURE_POINT ? 21 : 0;
-data.dbData = false;
-
-AddGameobjectToGrid(guid, &data);
-
-// Spawn if necessary (loaded grids only)
-// We use spawn coords to spawn
-if (!map->Instanceable() && map->IsLoaded(x, y))
-{
-GameObject *go = new GameObject;
-if (!go->LoadFromDB(guid, map))
-{
-sLog.outError("AddGOData: cannot add gameobject entry %u to map", entry);
-delete go;
-return 0;
-}
-map->Add(go);
-}
-
-sLog.outDebug("AddGOData: dbguid %u entry %u map %u x %f y %f z %f o %f", guid, entry, mapId, x, y, z, o);
-
-return guid;
-}
-
-bool ObjectMgr::MoveCreData(uint32 guid, uint32 mapId, Position pos)
-{
-CreatureData& data = NewOrExistCreatureData(guid);
-if (!data.id)
-return false;
-
-RemoveCreatureFromGrid(guid, &data);
-if (data.posX == pos.GetPositionX() && data.posY == pos.GetPositionY() && data.posZ == pos.GetPositionZ())
-return true;
-data.posX = pos.GetPositionX();
-data.posY = pos.GetPositionY();
-data.posZ = pos.GetPositionZ();
-data.orientation = pos.GetOrientation();
-AddCreatureToGrid(guid, &data);
-
-// Spawn if necessary (loaded grids only)
-if (Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId)))
-{
-// We use spawn coords to spawn
-if (!map->Instanceable() && map->IsLoaded(data.posX, data.posY))
-{
-Creature *creature = new Creature;
-if (!creature->LoadFromDB(guid, map))
-{
-sLog.outError("AddCreature: cannot add creature entry %u to map", guid);
-delete creature;
-return false;
-}
-map->Add(creature);
-}
-}
-return true;
-}
-
-uint32 ObjectMgr::AddCreData(uint32 entry, uint32 /*team*/, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay)
-{
-CreatureInfo const *cInfo = GetCreatureTemplate(entry);
-if (!cInfo)
-return 0;
-
-uint32 level = cInfo->minlevel == cInfo->maxlevel ? cInfo->minlevel : urand(cInfo->minlevel, cInfo->maxlevel); // Only used for extracting creature base stats
-CreatureBaseStats const* stats = sObjectMgr.GetCreatureBaseStats(level, cInfo->unit_class);
-
-uint32 guid = GenerateLowGuid(HIGHGUID_UNIT);
-CreatureData& data = NewOrExistCreatureData(guid);
-data.id = entry;
-data.mapid = mapId;
-data.displayid = 0;
-data.equipmentId = cInfo->equipmentId;
-data.posX = x;
-data.posY = y;
-data.posZ = z;
-data.orientation = o;
-data.spawntimesecs = spawntimedelay;
-data.spawndist = 0;
-data.currentwaypoint = 0;
-data.curhealth = stats->GenerateHealth(cInfo);
-data.curmana = stats->GenerateMana(cInfo);
-data.is_dead = false;
-data.movementType = cInfo->MovementType;
-data.spawnMask = 1;
-data.phaseMask = PHASEMASK_NORMAL;
-data.dbData = false;
-data.npcflag = cInfo->npcflag;
-data.unit_flags = cInfo->unit_flags;
-data.dynamicflags = cInfo->dynamicflags;
-
-
-AddCreatureToGrid(guid, &data);
-
-// Spawn if necessary (loaded grids only)
-if (Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId)))
-{
-// We use spawn coords to spawn
-if (!map->Instanceable() && !map->IsRemovalGrid(x, y))
-{
-Creature* creature = new Creature;
-if (!creature->LoadFromDB(guid, map))
-{
-sLog.outError("AddCreature: cannot add creature entry %u to map", entry);
-delete creature;
-return 0;
-}
-map->Add(creature);
-}
-}
-
-return guid;
-}
-
-void ObjectMgr::LoadGameobjects()
-{
-uint32 count = 0;
-
-// 0 1 2 3 4 5 6
-QueryResult result = WorldDatabase.Query("SELECT gameobject.guid, id, map, position_x, position_y, position_z, orientation,"
-// 7 8 9 10 11 12 13 14 15 16 17
-"rotation0, rotation1, rotation2, rotation3, spawntimesecs, animprogress, state, spawnMask, phaseMask, event, pool_entry "
-"FROM gameobject LEFT OUTER JOIN game_event_gameobject ON gameobject.guid = game_event_gameobject.guid "
-"LEFT OUTER JOIN pool_gameobject ON gameobject.guid = pool_gameobject.guid");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 gameobjects. DB table `gameobject` is empty.");
-return;
-}
-
-// build single time for check spawnmask
-std::map<uint32,uint32> spawnMasks;
-for (uint32 i = 0; i < sMapStore.GetNumRows(); ++i)
-if (sMapStore.LookupEntry(i))
-for (int k = 0; k < MAX_DIFFICULTY; ++k)
-if (GetMapDifficultyData(i,Difficulty(k)))
-spawnMasks[i] |= (1 << k);
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 guid = fields[ 0].GetUInt32();
-uint32 entry = fields[ 1].GetUInt32();
-
-GameObjectInfo const* gInfo = GetGameObjectInfo(entry);
-if (!gInfo)
-{
-sLog.outErrorDb("Table `gameobject` has gameobject (GUID: %u) with non existing gameobject entry %u, skipped.", guid, entry);
-continue;
-}
-
-if (!gInfo->displayId)
-{
-switch (gInfo->type)
-{
-case GAMEOBJECT_TYPE_TRAP:
-case GAMEOBJECT_TYPE_SPELL_FOCUS:
-break;
-default:
-sLog.outErrorDb("Gameobject (GUID: %u Entry %u GoType: %u) doesn't have displayId (%u), not loaded.", guid, entry, gInfo->type, gInfo->displayId);
-break;
-}
-}
-
-if (gInfo->displayId && !sGameObjectDisplayInfoStore.LookupEntry(gInfo->displayId))
-{
-sLog.outErrorDb("Gameobject (GUID: %u Entry %u GoType: %u) have invalid displayId (%u), not loaded.",guid, entry, gInfo->type, gInfo->displayId);
-continue;
-}
-
-GameObjectData& data = mGameObjectDataMap[guid];
-
-data.id = entry;
-data.mapid = fields[ 2].GetUInt32();
-data.posX = fields[ 3].GetFloat();
-data.posY = fields[ 4].GetFloat();
-data.posZ = fields[ 5].GetFloat();
-data.orientation = fields[ 6].GetFloat();
-data.rotation0 = fields[ 7].GetFloat();
-data.rotation1 = fields[ 8].GetFloat();
-data.rotation2 = fields[ 9].GetFloat();
-data.rotation3 = fields[10].GetFloat();
-data.spawntimesecs = fields[11].GetInt32();
-
-MapEntry const* mapEntry = sMapStore.LookupEntry(data.mapid);
-if (!mapEntry)
-{
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) that spawned at not existed map (Id: %u), skip", guid, data.id, data.mapid);
-continue;
-}
-
-if (data.spawntimesecs == 0 && gInfo->IsDespawnAtAction())
-{
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with `spawntimesecs` (0) value, but gameobejct marked as despawnable at action.",guid,data.id);
-}
-
-data.animprogress = fields[12].GetUInt32();
-data.artKit = 0;
-
-uint32 go_state = fields[13].GetUInt32();
-if (go_state >= MAX_GO_STATE)
-{
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid `state` (%u) value, skip",guid,data.id,go_state);
-continue;
-}
-data.go_state = GOState(go_state);
-
-data.spawnMask = fields[14].GetUInt8();
-
-if (data.spawnMask & ~spawnMasks[data.mapid])
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) that have wrong spawn mask %u including not supported difficulty modes for map (Id: %u), skip", guid, data.id, data.spawnMask, data.mapid);
-
-data.phaseMask = fields[15].GetUInt16();
-int16 gameEvent = fields[16].GetInt16();
-uint32 PoolId = fields[17].GetUInt32();
-
-if (data.rotation2 < -1.0f || data.rotation2 > 1.0f)
-{
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid rotation2 (%f) value, skip",guid,data.id,data.rotation2);
-continue;
-}
-
-if (data.rotation3 < -1.0f || data.rotation3 > 1.0f)
-{
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid rotation3 (%f) value, skip",guid,data.id,data.rotation3);
-continue;
-}
-
-if (!MapManager::IsValidMapCoord(data.mapid,data.posX,data.posY,data.posZ,data.orientation))
-{
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid coordinates, skip",guid,data.id);
-continue;
-}
-
-if (data.phaseMask == 0)
-{
-sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with `phaseMask`=0 (not visible for anyone), set to 1.",guid,data.id);
-data.phaseMask = 1;
-}
-
-if (gameEvent == 0 && PoolId == 0) // if not this is to be managed by GameEvent System or Pool system
-AddGameobjectToGrid(guid, &data);
-++count;
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu gameobjects", (unsigned long)mGameObjectDataMap.size());
-}
-
-void ObjectMgr::AddGameobjectToGrid(uint32 guid, GameObjectData const* data)
-{
-uint8 mask = data->spawnMask;
-for (uint8 i = 0; mask != 0; i++, mask >>= 1)
-{
-if (mask & 1)
-{
-CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
-uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
-
-CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
-cell_guids.gameobjects.insert(guid);
-}
-}
-}
-
-void ObjectMgr::RemoveGameobjectFromGrid(uint32 guid, GameObjectData const* data)
-{
-uint8 mask = data->spawnMask;
-for (uint8 i = 0; mask != 0; i++, mask >>= 1)
-{
-if (mask & 1)
-{
-CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
-uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
-
-CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
-cell_guids.gameobjects.erase(guid);
-}
-}
-}
-
-void ObjectMgr::LoadCreatureRespawnTimes()
-{
-uint32 count = 0;
-
-QueryResult result = WorldDatabase.Query("SELECT guid,respawntime,instance FROM creature_respawn");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded 0 creature respawn time.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 loguid = fields[0].GetUInt32();
-uint64 respawn_time = fields[1].GetUInt64();
-uint32 instance = fields[2].GetUInt32();
-
-mCreatureRespawnTimes[MAKE_PAIR64(loguid,instance)] = time_t(respawn_time);
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu creature respawn times", (unsigned long)mCreatureRespawnTimes.size());
-}
-
-void ObjectMgr::LoadGameobjectRespawnTimes()
-{
-// remove outdated data
-PreparedStatement *stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_GAMEOBJECT_RESPAWN_TIMES);
-WorldDatabase.Execute(stmt);
-
-uint32 count = 0;
-
-QueryResult result = WorldDatabase.Query("SELECT guid,respawntime,instance FROM gameobject_respawn");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded 0 gameobject respawn time.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 loguid = fields[0].GetUInt32();
-uint64 respawn_time = fields[1].GetUInt64();
-uint32 instance = fields[2].GetUInt32();
-
-mGORespawnTimes[MAKE_PAIR64(loguid,instance)] = time_t(respawn_time);
-
-++count;
-} while (result->NextRow());
-
-sLog.outString(">> Loaded %lu gameobject respawn times", (unsigned long)mGORespawnTimes.size());
-sLog.outString();
-}
-
-Player* ObjectMgr::GetPlayerByLowGUID(uint32 lowguid) const
-{
-uint64 guid = MAKE_NEW_GUID(lowguid, 0, HIGHGUID_PLAYER);
-return ObjectAccessor::FindPlayer(guid);
-}
-
-// name must be checked to correctness (if received) before call this function
-uint64 ObjectMgr::GetPlayerGUIDByName(std::string name) const
-{
-uint64 guid = 0;
-
-CharacterDatabase.escape_string(name);
-
-// Player name safe to sending to DB (checked at login) and this function using
-QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE name = '%s'", name.c_str());
-if (result)
-guid = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_PLAYER);
-
-return guid;
-}
-
-bool ObjectMgr::GetPlayerNameByGUID(const uint64 &guid, std::string &name) const
-{
-// prevent DB access for online player
-if (Player* player = GetPlayer(guid))
-{
-name = player->GetName();
-return true;
-}
-
-QueryResult result = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
-
-if (result)
-{
-name = (*result)[0].GetString();
-return true;
-}
-
-return false;
-}
-
-uint32 ObjectMgr::GetPlayerTeamByGUID(const uint64 &guid) const
-{
-// prevent DB access for online player
-if (Player* player = GetPlayer(guid))
-{
-return Player::TeamForRace(player->getRace());
-}
-
-QueryResult result = CharacterDatabase.PQuery("SELECT race FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
-
-if (result)
-{
-uint8 race = (*result)[0].GetUInt8();
-return Player::TeamForRace(race);
-}
-
-return 0;
-}
-
-uint32 ObjectMgr::GetPlayerAccountIdByGUID(const uint64 &guid) const
-{
-// prevent DB access for online player
-if (Player* player = GetPlayer(guid))
-{
-return player->GetSession()->GetAccountId();
-}
-
-QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
-if (result)
-{
-uint32 acc = (*result)[0].GetUInt32();
-return acc;
-}
-
-return 0;
-}
-
-uint32 ObjectMgr::GetPlayerAccountIdByPlayerName(const std::string& name) const
-{
-QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", name.c_str());
-if (result)
-{
-uint32 acc = (*result)[0].GetUInt32();
-return acc;
-}
-
-return 0;
-}
-
-void ObjectMgr::LoadItemLocales()
-{
-mItemLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT entry,name_loc1,description_loc1,name_loc2,description_loc2,name_loc3,description_loc3,name_loc4,description_loc4,name_loc5,description_loc5,name_loc6,description_loc6,name_loc7,description_loc7,name_loc8,description_loc8 FROM locales_item");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-ItemLocale& data = mItemLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-LocaleConstant locale = (LocaleConstant) i;
-std::string str = fields[1 + 2 * (i - 1)].GetString();
-AddLocaleString(str, locale, data.Name);
-
-str = fields[1 + 2 * (i - 1) + 1].GetString();
-AddLocaleString(str, locale, data.Description);
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu Item locale strings", (unsigned long)mItemLocaleMap.size());
-}
-
-struct SQLItemLoader : public SQLStorageLoaderBase<SQLItemLoader>
-{
-template<class D>
-void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
-{
-dst = D(sObjectMgr.GetScriptId(src));
-}
-};
-
-void ObjectMgr::LoadItemPrototypes()
-{
-SQLItemLoader loader;
-loader.Load(sItemStorage);
-sLog.outString(">> Loaded %u item prototypes", sItemStorage.RecordCount);
-sLog.outString();
-
-// check data correctness
-for (uint32 i = 1; i < sItemStorage.MaxEntry; ++i)
-{
-ItemPrototype const* proto = sItemStorage.LookupEntry<ItemPrototype >(i);
-ItemEntry const *dbcitem = sItemStore.LookupEntry(i);
-if (!proto)
-{
-/* to many errors, and possible not all items really used in game
-if (dbcitem)
-sLog.outErrorDb("Item (Entry: %u) doesn't exists in DB, but must exist.",i);
-*/
-continue;
-}
-
-if (dbcitem)
-{
-if (proto->Class != dbcitem->Class)
-{
-sLog.outErrorDb("Item (Entry: %u) not correct class %u, must be %u (still using DB value).",i,proto->Class,dbcitem->Class);
-// It safe let use Class from DB
-}
-/* disabled: have some strange wrong cases for Subclass values.
-for enable also uncomment Subclass field in ItemEntry structure and in Itemfmt[]
-if (proto->SubClass != dbcitem->SubClass)
-{
-sLog.outErrorDb("Item (Entry: %u) not correct (Class: %u, Sub: %u) pair, must be (Class: %u, Sub: %u) (still using DB value).",i,proto->Class,proto->SubClass,dbcitem->Class,dbcitem->SubClass);
-// It safe let use Subclass from DB
-}
-*/
-
-if (proto->Unk0 != dbcitem->Unk0)
-{
-sLog.outErrorDb("Item (Entry: %u) not correct %i Unk0, must be %i (still using DB value).",i,proto->Unk0,dbcitem->Unk0);
-// It safe let use Unk0 from DB
-}
-
-if (proto->Material != dbcitem->Material)
-{
-sLog.outErrorDb("Item (Entry: %u) not correct %i material, must be %i (still using DB value).",i,proto->Material,dbcitem->Material);
-// It safe let use Material from DB
-}
-
-if (proto->InventoryType != dbcitem->InventoryType)
-{
-sLog.outErrorDb("Item (Entry: %u) not correct %u inventory type, must be %u (still using DB value).",i,proto->InventoryType,dbcitem->InventoryType);
-// It safe let use InventoryType from DB
-}
-
-if (proto->DisplayInfoID != dbcitem->DisplayId)
-{
-sLog.outErrorDb("Item (Entry: %u) not correct %u display id, must be %u (using it).",i,proto->DisplayInfoID,dbcitem->DisplayId);
-const_cast<ItemPrototype*>(proto)->DisplayInfoID = dbcitem->DisplayId;
-}
-if (proto->Sheath != dbcitem->Sheath)
-{
-sLog.outErrorDb("Item (Entry: %u) not correct %u sheath, must be %u (using it).",i,proto->Sheath,dbcitem->Sheath);
-const_cast<ItemPrototype*>(proto)->Sheath = dbcitem->Sheath;
-}
-}
-else
-sLog.outErrorDb("Item (Entry: %u) not correct (not listed in list of existed items).",i);
-
-if (proto->Class >= MAX_ITEM_CLASS)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong Class value (%u)",i,proto->Class);
-const_cast<ItemPrototype*>(proto)->Class = ITEM_CLASS_MISC;
-}
-
-if (proto->SubClass >= MaxItemSubclassValues[proto->Class])
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong Subclass value (%u) for class %u",i,proto->SubClass,proto->Class);
-const_cast<ItemPrototype*>(proto)->SubClass = 0;// exist for all item classes
-}
-
-if (proto->Quality >= MAX_ITEM_QUALITY)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong Quality value (%u)",i,proto->Quality);
-const_cast<ItemPrototype*>(proto)->Quality = ITEM_QUALITY_NORMAL;
-}
-
-if (proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY)
-{
-if (FactionEntry const* faction = sFactionStore.LookupEntry(HORDE))
-if ((proto->AllowableRace & faction->BaseRepRaceMask[0]) == 0)
-sLog.outErrorDb("Item (Entry: %u) have in `AllowableRace` races (%u) only not compatible with ITEM_FLAGS_EXTRA_HORDE_ONLY (%u) in Flags field, item any way will can't be equipped or use by this races.",
-i, proto->AllowableRace, ITEM_FLAGS_EXTRA_HORDE_ONLY);
-
-if (proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY)
-sLog.outErrorDb("Item (Entry: %u) have in `Flags2` flags ITEM_FLAGS_EXTRA_ALLIANCE_ONLY (%u) and ITEM_FLAGS_EXTRA_HORDE_ONLY (%u) in Flags field, this is wrong combination.",
-i, ITEM_FLAGS_EXTRA_ALLIANCE_ONLY, ITEM_FLAGS_EXTRA_HORDE_ONLY);
-}
-else if (proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY)
-{
-if (FactionEntry const* faction = sFactionStore.LookupEntry(ALLIANCE))
-if ((proto->AllowableRace & faction->BaseRepRaceMask[0]) == 0)
-sLog.outErrorDb("Item (Entry: %u) have in `AllowableRace` races (%u) only not compatible with ITEM_FLAGS_EXTRA_ALLIANCE_ONLY (%u) in Flags field, item any way will can't be equipped or use by this races.",
-i, proto->AllowableRace, ITEM_FLAGS_EXTRA_ALLIANCE_ONLY);
-}
-
-if (proto->BuyCount <= 0)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong BuyCount value (%u), set to default(1).",i,proto->BuyCount);
-const_cast<ItemPrototype*>(proto)->BuyCount = 1;
-}
-
-if (proto->InventoryType >= MAX_INVTYPE)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong InventoryType value (%u)",i,proto->InventoryType);
-const_cast<ItemPrototype*>(proto)->InventoryType = INVTYPE_NON_EQUIP;
-}
-
-if (proto->RequiredSkill >= MAX_SKILL_TYPE)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong RequiredSkill value (%u)",i,proto->RequiredSkill);
-const_cast<ItemPrototype*>(proto)->RequiredSkill = 0;
-}
-
-{
-// can be used in equip slot, as page read use in inventory, or spell casting at use
-bool req = proto->InventoryType != INVTYPE_NON_EQUIP || proto->PageText;
-if (!req)
-for (uint8 j = 0; j < MAX_ITEM_PROTO_SPELLS; ++j)
-{
-if (proto->Spells[j].SpellId)
-{
-req = true;
-break;
-}
-}
-
-if (req)
-{
-if (!(proto->AllowableClass & CLASSMASK_ALL_PLAYABLE))
-sLog.outErrorDb("Item (Entry: %u) not have in `AllowableClass` any playable classes (%u) and can't be equipped or use.",i,proto->AllowableClass);
-
-if (!(proto->AllowableRace & RACEMASK_ALL_PLAYABLE))
-sLog.outErrorDb("Item (Entry: %u) not have in `AllowableRace` any playable races (%u) and can't be equipped or use.",i,proto->AllowableRace);
-}
-}
-
-if (proto->RequiredSpell && !sSpellStore.LookupEntry(proto->RequiredSpell))
-{
-sLog.outErrorDb("Item (Entry: %u) have wrong (non-existed) spell in RequiredSpell (%u)",i,proto->RequiredSpell);
-const_cast<ItemPrototype*>(proto)->RequiredSpell = 0;
-}
-
-if (proto->RequiredReputationRank >= MAX_REPUTATION_RANK)
-sLog.outErrorDb("Item (Entry: %u) has wrong reputation rank in RequiredReputationRank (%u), item can't be used.",i,proto->RequiredReputationRank);
-
-if (proto->RequiredReputationFaction)
-{
-if (!sFactionStore.LookupEntry(proto->RequiredReputationFaction))
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) faction in RequiredReputationFaction (%u)",i,proto->RequiredReputationFaction);
-const_cast<ItemPrototype*>(proto)->RequiredReputationFaction = 0;
-}
-
-if (proto->RequiredReputationRank == MIN_REPUTATION_RANK)
-sLog.outErrorDb("Item (Entry: %u) has min. reputation rank in RequiredReputationRank (0) but RequiredReputationFaction > 0, faction setting is useless.",i);
-}
-
-if (proto->MaxCount < -1)
-{
-sLog.outErrorDb("Item (Entry: %u) has too large negative in maxcount (%i), replace by value (-1) no storing limits.",i,proto->MaxCount);
-const_cast<ItemPrototype*>(proto)->MaxCount = -1;
-}
-
-if (proto->Stackable == 0)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong value in stackable (%i), replace by default 1.",i,proto->Stackable);
-const_cast<ItemPrototype*>(proto)->Stackable = 1;
-}
-else if (proto->Stackable < -1)
-{
-sLog.outErrorDb("Item (Entry: %u) has too large negative in stackable (%i), replace by value (-1) no stacking limits.",i,proto->Stackable);
-const_cast<ItemPrototype*>(proto)->Stackable = -1;
-}
-
-if (proto->ContainerSlots > MAX_BAG_SIZE)
-{
-sLog.outErrorDb("Item (Entry: %u) has too large value in ContainerSlots (%u), replace by hardcoded limit (%u).",i,proto->ContainerSlots,MAX_BAG_SIZE);
-const_cast<ItemPrototype*>(proto)->ContainerSlots = MAX_BAG_SIZE;
-}
-
-if (proto->StatsCount > MAX_ITEM_PROTO_STATS)
-{
-sLog.outErrorDb("Item (Entry: %u) has too large value in statscount (%u), replace by hardcoded limit (%u).",i,proto->StatsCount,MAX_ITEM_PROTO_STATS);
-const_cast<ItemPrototype*>(proto)->StatsCount = MAX_ITEM_PROTO_STATS;
-}
-
-for (uint8 j = 0; j < MAX_ITEM_PROTO_STATS; ++j)
-{
-// for ItemStatValue != 0
-if (proto->ItemStat[j].ItemStatValue && proto->ItemStat[j].ItemStatType >= MAX_ITEM_MOD)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong stat_type%d (%u)",i,j+1,proto->ItemStat[j].ItemStatType);
-const_cast<ItemPrototype*>(proto)->ItemStat[j].ItemStatType = 0;
-}
-
-switch (proto->ItemStat[j].ItemStatType)
-{
-case ITEM_MOD_SPELL_HEALING_DONE:
-case ITEM_MOD_SPELL_DAMAGE_DONE:
-sLog.outErrorDb("Item (Entry: %u) has deprecated stat_type%d (%u)",i,j+1,proto->ItemStat[j].ItemStatType);
-break;
-default:
-break;
-}
-}
-
-for (uint8 j = 0; j < MAX_ITEM_PROTO_DAMAGES; ++j)
-{
-if (proto->Damage[j].DamageType >= MAX_SPELL_SCHOOL)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong dmg_type%d (%u)",i,j+1,proto->Damage[j].DamageType);
-const_cast<ItemPrototype*>(proto)->Damage[j].DamageType = 0;
-}
-}
-
-// special format
-if ((proto->Spells[0].SpellId == 483) || (proto->Spells[0].SpellId == 55884))
-{
-// spell_1
-if (proto->Spells[0].SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u) for special learning format",i,0+1,proto->Spells[0].SpellTrigger);
-const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[0].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-}
-
-// spell_2 have learning spell
-if (proto->Spells[1].SpellTrigger != ITEM_SPELLTRIGGER_LEARN_SPELL_ID)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u) for special learning format.",i,1+1,proto->Spells[1].SpellTrigger);
-const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-}
-else if (!proto->Spells[1].SpellId)
-{
-sLog.outErrorDb("Item (Entry: %u) not has expected spell in spellid_%d in special learning format.",i,1+1);
-const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-}
-else if (proto->Spells[1].SpellId != -1)
-{
-SpellEntry const* spellInfo = sSpellStore.LookupEntry(proto->Spells[1].SpellId);
-if (!spellInfo && !sDisableMgr.IsDisabledFor(DISABLE_TYPE_SPELL, proto->Spells[1].SpellId, NULL))
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) spell in spellid_%d (%d)",i,1+1,proto->Spells[1].SpellId);
-const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-}
-// allowed only in special format
-else if ((proto->Spells[1].SpellId == 483) || (proto->Spells[1].SpellId == 55884))
-{
-sLog.outErrorDb("Item (Entry: %u) has broken spell in spellid_%d (%d)",i,1+1,proto->Spells[1].SpellId);
-const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-}
-}
-
-// spell_3*,spell_4*,spell_5* is empty
-for (uint8 j = 2; j < MAX_ITEM_PROTO_SPELLS; ++j)
-{
-if (proto->Spells[j].SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u)",i,j+1,proto->Spells[j].SpellTrigger);
-const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[j].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-}
-else if (proto->Spells[j].SpellId != 0)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong spell in spellid_%d (%d) for learning special format",i,j+1,proto->Spells[j].SpellId);
-const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-}
-}
-}
-// normal spell list
-else
-{
-for (uint8 j = 0; j < MAX_ITEM_PROTO_SPELLS; ++j)
-{
-if (proto->Spells[j].SpellTrigger >= MAX_ITEM_SPELLTRIGGER || proto->Spells[j].SpellTrigger == ITEM_SPELLTRIGGER_LEARN_SPELL_ID)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u)",i,j+1,proto->Spells[j].SpellTrigger);
-const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-const_cast<ItemPrototype*>(proto)->Spells[j].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-}
-
-if (proto->Spells[j].SpellId && proto->Spells[j].SpellId != -1)
-{
-SpellEntry const* spellInfo = sSpellStore.LookupEntry(proto->Spells[j].SpellId);
-if (!spellInfo && !sDisableMgr.IsDisabledFor(DISABLE_TYPE_SPELL, proto->Spells[j].SpellId, NULL))
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) spell in spellid_%d (%d)",i,j+1,proto->Spells[j].SpellId);
-const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-}
-// allowed only in special format
-else if ((proto->Spells[j].SpellId == 483) || (proto->Spells[j].SpellId == 55884))
-{
-sLog.outErrorDb("Item (Entry: %u) has broken spell in spellid_%d (%d)",i,j+1,proto->Spells[j].SpellId);
-const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-}
-}
-}
-}
-
-if (proto->Bonding >= MAX_BIND_TYPE)
-sLog.outErrorDb("Item (Entry: %u) has wrong Bonding value (%u)",i,proto->Bonding);
-
-if (proto->PageText && !sPageTextStore.LookupEntry<PageText>(proto->PageText))
-sLog.outErrorDb("Item (Entry: %u) has non existing first page (Id:%u)", i,proto->PageText);
-
-if (proto->LockID && !sLockStore.LookupEntry(proto->LockID))
-sLog.outErrorDb("Item (Entry: %u) has wrong LockID (%u)",i,proto->LockID);
-
-if (proto->Sheath >= MAX_SHEATHETYPE)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong Sheath (%u)",i,proto->Sheath);
-const_cast<ItemPrototype*>(proto)->Sheath = SHEATHETYPE_NONE;
-}
-
-if (proto->RandomProperty)
-{
-// To be implemented later
-if (proto->RandomProperty == -1)
-const_cast<ItemPrototype*>(proto)->RandomProperty = 0;
-
-else if (!sItemRandomPropertiesStore.LookupEntry(GetItemEnchantMod(proto->RandomProperty)))
-{
-sLog.outErrorDb("Item (Entry: %u) has unknown (wrong or not listed in `item_enchantment_template`) RandomProperty (%u)",i,proto->RandomProperty);
-const_cast<ItemPrototype*>(proto)->RandomProperty = 0;
-}
-}
-
-if (proto->RandomSuffix && !sItemRandomSuffixStore.LookupEntry(GetItemEnchantMod(proto->RandomSuffix)))
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong RandomSuffix (%u)",i,proto->RandomSuffix);
-const_cast<ItemPrototype*>(proto)->RandomSuffix = 0;
-}
-
-if (proto->ItemSet && !sItemSetStore.LookupEntry(proto->ItemSet))
-{
-sLog.outErrorDb("Item (Entry: %u) have wrong ItemSet (%u)",i,proto->ItemSet);
-const_cast<ItemPrototype*>(proto)->ItemSet = 0;
-}
-
-if (proto->Area && !GetAreaEntryByAreaID(proto->Area))
-sLog.outErrorDb("Item (Entry: %u) has wrong Area (%u)",i,proto->Area);
-
-if (proto->Map && !sMapStore.LookupEntry(proto->Map))
-sLog.outErrorDb("Item (Entry: %u) has wrong Map (%u)",i,proto->Map);
-
-if (proto->BagFamily)
-{
-// check bits
-for (uint32 j = 0; j < sizeof(proto->BagFamily)*8; ++j)
-{
-uint32 mask = 1 << j;
-if ((proto->BagFamily & mask) == 0)
-continue;
-
-ItemBagFamilyEntry const* bf = sItemBagFamilyStore.LookupEntry(j+1);
-if (!bf)
-{
-sLog.outErrorDb("Item (Entry: %u) has bag family bit set not listed in ItemBagFamily.dbc, remove bit",i);
-const_cast<ItemPrototype*>(proto)->BagFamily &= ~mask;
-continue;
-}
-
-if (BAG_FAMILY_MASK_CURRENCY_TOKENS & mask)
-{
-CurrencyTypesEntry const* ctEntry = sCurrencyTypesStore.LookupEntry(proto->ItemId);
-if (!ctEntry)
-{
-sLog.outErrorDb("Item (Entry: %u) has currency bag family bit set in BagFamily but not listed in CurrencyTypes.dbc, remove bit",i);
-const_cast<ItemPrototype*>(proto)->BagFamily &= ~mask;
-}
-}
-}
-}
-
-if (proto->TotemCategory && !sTotemCategoryStore.LookupEntry(proto->TotemCategory))
-sLog.outErrorDb("Item (Entry: %u) has wrong TotemCategory (%u)",i,proto->TotemCategory);
-
-for (uint8 j = 0; j < MAX_ITEM_PROTO_SOCKETS; ++j)
-{
-if (proto->Socket[j].Color && (proto->Socket[j].Color & SOCKET_COLOR_ALL) != proto->Socket[j].Color)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong socketColor_%d (%u)",i,j+1,proto->Socket[j].Color);
-const_cast<ItemPrototype*>(proto)->Socket[j].Color = 0;
-}
-}
-
-if (proto->GemProperties && !sGemPropertiesStore.LookupEntry(proto->GemProperties))
-sLog.outErrorDb("Item (Entry: %u) has wrong GemProperties (%u)",i,proto->GemProperties);
-
-if (proto->FoodType >= MAX_PET_DIET)
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong FoodType value (%u)",i,proto->FoodType);
-const_cast<ItemPrototype*>(proto)->FoodType = 0;
-}
-
-if (proto->ItemLimitCategory && !sItemLimitCategoryStore.LookupEntry(proto->ItemLimitCategory))
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong LimitCategory value (%u)",i,proto->ItemLimitCategory);
-const_cast<ItemPrototype*>(proto)->ItemLimitCategory = 0;
-}
-
-if (proto->HolidayId && !sHolidaysStore.LookupEntry(proto->HolidayId))
-{
-sLog.outErrorDb("Item (Entry: %u) has wrong HolidayId value (%u)", i, proto->HolidayId);
-const_cast<ItemPrototype*>(proto)->HolidayId = 0;
-}
-}
-
-// check some dbc referecned items (avoid duplicate reports)
-std::set<uint32> notFoundOutfit;
-for (uint32 i = 1; i < sCharStartOutfitStore.GetNumRows(); ++i)
-{
-CharStartOutfitEntry const* entry = sCharStartOutfitStore.LookupEntry(i);
-if (!entry)
-continue;
-
-for (int j = 0; j < MAX_OUTFIT_ITEMS; ++j)
-{
-if (entry->ItemId[j] <= 0)
-continue;
-
-uint32 item_id = entry->ItemId[j];
-
-if (!GetItemPrototype(item_id))
-notFoundOutfit.insert(item_id);
-}
-}
-
-for (std::set<uint32>::const_iterator itr = notFoundOutfit.begin(); itr != notFoundOutfit.end(); ++itr)
-sLog.outErrorDb("Item (Entry: %u) not exist in `item_template` but referenced in `CharStartOutfit.dbc`", *itr);
-}
-
-void ObjectMgr::LoadItemSetNameLocales()
-{
-mItemSetNameLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT `entry`,`name_loc1`,`name_loc2`,`name_loc3`,`name_loc4`,`name_loc5`,`name_loc6`,`name_loc7`,`name_loc8` FROM `locales_item_set_names`");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-ItemSetNameLocale& data = mItemSetNameLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-std::string str = fields[i].GetString();
-AddLocaleString(str, LocaleConstant(i), data.Name);
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded " UI64FMTD " Item set name locale strings", uint64(mItemSetNameLocaleMap.size()));
-}
-
-void ObjectMgr::LoadItemSetNames()
-{
-mItemSetNameMap.clear(); // needed for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT `entry`,`name`,`InventoryType` FROM `item_set_names`");
-
-uint32 count = 0;
-std::set<uint32> itemSetItems;
-
-// fill item set member ids
-for (uint32 entryId = 0; entryId < sItemSetStore.GetNumRows(); ++entryId)
-{
-ItemSetEntry const* setEntry = sItemSetStore.LookupEntry(entryId);
-if (!setEntry)
-continue;
-
-for (uint32 i = 0; i < MAX_ITEM_SET_ITEMS; ++i)
-if (setEntry->itemId[i])
-itemSetItems.insert(setEntry->itemId[i]);
-}
-
-if (result)
-{
-barGoLink bar(result->GetRowCount());
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-if (itemSetItems.find(entry) == itemSetItems.end())
-{
-sLog.outErrorDb("Item set name (Entry: %u) not found in ItemSet.dbc, data useless.", entry);
-continue;
-}
-
-ItemSetNameEntry &data = mItemSetNameMap[entry];
-data.name = fields[1].GetString();
-
-uint32 invType = fields[2].GetUInt32();
-if (invType >= MAX_INVTYPE)
-{
-sLog.outErrorDb("Item set name (Entry: %u) has wrong InventoryType value (%u)", entry, invType);
-invType = INVTYPE_NON_EQUIP;
-}
-
-data.InventoryType = invType;
-itemSetItems.erase(entry);
-++count;
-} while (result->NextRow());
-}
-else
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 item set names. DB table `item_set_names` is empty.");
-}
-
-if (!itemSetItems.empty())
-{
-ItemPrototype const* pProto;
-for (std::set<uint32>::iterator itr = itemSetItems.begin(); itr != itemSetItems.end(); ++itr)
-{
-uint32 entry = *itr;
-// add data from item_template if available
-pProto = GetItemPrototype(entry);
-if (pProto)
-{
-sLog.outErrorDb("Item set part (Entry: %u) does not have entry in `item_set_names`, adding data from `item_template`.", entry);
-ItemSetNameEntry &data = mItemSetNameMap[entry];
-data.name = pProto->Name1;
-data.InventoryType = pProto->InventoryType;
-++count;
-}
-else
-sLog.outErrorDb("Item set part (Entry: %u) does not have entry in `item_set_names`, set will not display properly.", entry);
-}
-}
-
-sLog.outString();
-sLog.outString(">> Loaded %u item set names", count);
-}
-
-void ObjectMgr::LoadVehicleAccessories()
-{
-m_VehicleAccessoryMap.clear(); // needed for reload case
-
-uint32 count = 0;
-
-QueryResult result = WorldDatabase.Query("SELECT `entry`,`accessory_entry`,`seat_id`,`minion` FROM `vehicle_accessory`");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 LoadVehicleAccessor. DB table `vehicle_accessory` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 uiEntry = fields[0].GetUInt32();
-uint32 uiAccessory = fields[1].GetUInt32();
-int8 uiSeat = int8(fields[2].GetInt16());
-bool bMinion = fields[3].GetBool();
-
-if (!sCreatureStorage.LookupEntry<CreatureInfo>(uiEntry))
-{
-sLog.outErrorDb("Table `vehicle_accessory`: creature template entry %u does not exist.", uiEntry);
-continue;
-}
-
-if (!sCreatureStorage.LookupEntry<CreatureInfo>(uiAccessory))
-{
-sLog.outErrorDb("Table `vehicle_accessory`: Accessory %u does not exist.", uiAccessory);
-continue;
-}
-
-m_VehicleAccessoryMap[uiEntry].push_back(VehicleAccessory(uiAccessory, uiSeat, bMinion));
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u Vehicle Accessories", count);
-}
-
-void ObjectMgr::LoadVehicleScaling()
-{
-m_VehicleScalingMap.clear(); // needed for reload case
-
-uint32 count = 0;
-
-QueryResult result = WorldDatabase.Query("SELECT `entry`,`baseItemLevel`,`scalingFactor` FROM `vehicle_scaling_info`");
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 vehicle scaling entries. DB table `vehicle_scaling_info` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 vehicleEntry = fields[0].GetUInt32();
-float baseItemLevel = fields[1].GetFloat();
-float scalingFactor = fields[2].GetFloat();
-
-if (!sVehicleStore.LookupEntry(vehicleEntry))
-{
-sLog.outErrorDb("Table `vehicle_scaling_info`: vehicle entry %u does not exist.", vehicleEntry);
-continue;
-}
-
-m_VehicleScalingMap[vehicleEntry].ID = vehicleEntry;
-m_VehicleScalingMap[vehicleEntry].baseItemLevel = baseItemLevel;
-m_VehicleScalingMap[vehicleEntry].scalingFactor = scalingFactor;
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u vehicle scaling entries.", count);
-}
-
-void ObjectMgr::LoadPetLevelInfo()
-{
-// Loading levels data
-{
-// 0 1 2 3 4 5 6 7 8 9
-QueryResult result = WorldDatabase.Query("SELECT creature_entry, level, hp, mana, str, agi, sta, inte, spi, armor FROM pet_levelstats");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-sLog.outString();
-sLog.outString(">> Loaded %u level pet stats definitions", count);
-sLog.outErrorDb("Error loading `pet_levelstats` table or empty table.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 creature_id = fields[0].GetUInt32();
-if (!sCreatureStorage.LookupEntry<CreatureInfo>(creature_id))
-{
-sLog.outErrorDb("Wrong creature id %u in `pet_levelstats` table, ignoring.",creature_id);
-continue;
-}
-
-uint32 current_level = fields[1].GetUInt32();
-if (current_level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-{
-if (current_level > STRONG_MAX_LEVEL) // hardcoded level maximum
-sLog.outErrorDb("Wrong (> %u) level %u in `pet_levelstats` table, ignoring.",STRONG_MAX_LEVEL,current_level);
-else
-{
-sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `pet_levelstats` table, ignoring.",current_level);
-++count; // make result loading percent "expected" correct in case disabled detail mode for example.
-}
-continue;
-}
-else if (current_level < 1)
-{
-sLog.outErrorDb("Wrong (<1) level %u in `pet_levelstats` table, ignoring.",current_level);
-continue;
-}
-
-PetLevelInfo*& pInfoMapEntry = petInfo[creature_id];
-
-if (pInfoMapEntry == NULL)
-pInfoMapEntry = new PetLevelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
-
-// data for level 1 stored in [0] array element, ...
-PetLevelInfo* pLevelInfo = &pInfoMapEntry[current_level-1];
-
-pLevelInfo->health = fields[2].GetUInt16();
-pLevelInfo->mana = fields[3].GetUInt16();
-pLevelInfo->armor = fields[9].GetUInt16();
-
-for (int i = 0; i < MAX_STATS; i++)
-{
-pLevelInfo->stats[i] = fields[i+4].GetUInt16();
-}
-
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u level pet stats definitions", count);
-}
-
-// Fill gaps and check integrity
-for (PetLevelInfoMap::iterator itr = petInfo.begin(); itr != petInfo.end(); ++itr)
-{
-PetLevelInfo* pInfo = itr->second;
-
-// fatal error if no level 1 data
-if (!pInfo || pInfo[0].health == 0)
-{
-sLog.outErrorDb("Creature %u does not have pet stats data for Level 1!",itr->first);
-exit(1);
-}
-
-// fill level gaps
-for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
-{
-if (pInfo[level].health == 0)
-{
-sLog.outErrorDb("Creature %u has no data for Level %i pet stats data, using data of Level %i.",itr->first,level+1, level);
-pInfo[level] = pInfo[level-1];
-}
-}
-}
-}
-
-PetLevelInfo const* ObjectMgr::GetPetLevelInfo(uint32 creature_id, uint8 level) const
-{
-if (level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-level = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
-
-PetLevelInfoMap::const_iterator itr = petInfo.find(creature_id);
-if (itr == petInfo.end())
-return NULL;
-
-return &itr->second[level-1]; // data for level 1 stored in [0] array element, ...
-}
-
-void ObjectMgr::PlayerCreateInfoAddItemHelper(uint32 race_, uint32 class_, uint32 itemId, int32 count)
-{
-if (count > 0)
-playerInfo[race_][class_].item.push_back(PlayerCreateInfoItem(itemId, count));
-else
-{
-if (count < -1)
-sLog.outErrorDb("Invalid count %i specified on item %u be removed from original player create info (use -1)!", count, itemId);
-
-uint32 RaceClass = (race_) | (class_ << 8);
-bool doneOne = false;
-for (uint32 i = 1; i < sCharStartOutfitStore.GetNumRows(); ++i)
-{
-if (CharStartOutfitEntry const* entry = sCharStartOutfitStore.LookupEntry(i))
-{
-if (entry->RaceClassGender == RaceClass || entry->RaceClassGender == (RaceClass | (1 << 16)))
-{
-bool found = false;
-for (uint8 x = 0; x < MAX_OUTFIT_ITEMS; ++x)
-{
-if (entry->ItemId[x] > 0 && uint32(entry->ItemId[x]) == itemId)
-{
-found = true;
-const_cast<CharStartOutfitEntry*>(entry)->ItemId[x] = 0;
-break;
-}
-}
-
-if (!found)
-sLog.outErrorDb("Item %u specified to be removed from original create info not found in dbc!", itemId);
-
-if (!doneOne)
-doneOne = true;
-else
-break;
-}
-}
-}
-}
-}
-
-void ObjectMgr::LoadPlayerInfo()
-{
-// Load playercreate
-{
-// 0 1 2 3 4 5 6
-QueryResult result = WorldDatabase.Query("SELECT race, class, map, zone, position_x, position_y, position_z, orientation FROM playercreateinfo");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-sLog.outString();
-sLog.outString(">> Loaded %u player create definitions", count);
-sLog.outErrorDb("Error loading `playercreateinfo` table or empty table.");
-exit(1);
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 current_race = fields[0].GetUInt32();
-uint32 current_class = fields[1].GetUInt32();
-uint32 mapId = fields[2].GetUInt32();
-uint32 areaId = fields[3].GetUInt32();
-float positionX = fields[4].GetFloat();
-float positionY = fields[5].GetFloat();
-float positionZ = fields[6].GetFloat();
-float orientation = fields[7].GetFloat();
-
-if (current_race >= MAX_RACES)
-{
-sLog.outErrorDb("Wrong race %u in `playercreateinfo` table, ignoring.",current_race);
-continue;
-}
-
-ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(current_race);
-if (!rEntry)
-{
-sLog.outErrorDb("Wrong race %u in `playercreateinfo` table, ignoring.",current_race);
-continue;
-}
-
-if (current_class >= MAX_CLASSES)
-{
-sLog.outErrorDb("Wrong class %u in `playercreateinfo` table, ignoring.",current_class);
-continue;
-}
-
-if (!sChrClassesStore.LookupEntry(current_class))
-{
-sLog.outErrorDb("Wrong class %u in `playercreateinfo` table, ignoring.",current_class);
-continue;
-}
-
-// accept DB data only for valid position (and non instanceable)
-if (!MapManager::IsValidMapCoord(mapId,positionX,positionY,positionZ,orientation))
-{
-sLog.outErrorDb("Wrong home position for class %u race %u pair in `playercreateinfo` table, ignoring.",current_class,current_race);
-continue;
-}
-
-if (sMapStore.LookupEntry(mapId)->Instanceable())
-{
-sLog.outErrorDb("Home position in instanceable map for class %u race %u pair in `playercreateinfo` table, ignoring.",current_class,current_race);
-continue;
-}
-
-PlayerInfo* pInfo = &playerInfo[current_race][current_class];
-
-pInfo->mapId = mapId;
-pInfo->areaId = areaId;
-pInfo->positionX = positionX;
-pInfo->positionY = positionY;
-pInfo->positionZ = positionZ;
-pInfo->orientation = orientation;
-
-pInfo->displayId_m = rEntry->model_m;
-pInfo->displayId_f = rEntry->model_f;
-
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u player create definitions", count);
-}
-
-// Load playercreate items
-sLog.outString("Loading Player Create Items Data...");
-{
-// 0 1 2 3
-QueryResult result = WorldDatabase.Query("SELECT race, class, itemid, amount FROM playercreateinfo_item");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u custom player create items", count);
-}
-else
-{
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 current_race = fields[0].GetUInt32();
-if (current_race >= MAX_RACES)
-{
-sLog.outErrorDb("Wrong race %u in `playercreateinfo_item` table, ignoring.",current_race);
-continue;
-}
-
-uint32 current_class = fields[1].GetUInt32();
-if (current_class >= MAX_CLASSES)
-{
-sLog.outErrorDb("Wrong class %u in `playercreateinfo_item` table, ignoring.",current_class);
-continue;
-}
-
-uint32 item_id = fields[2].GetUInt32();
-
-if (!GetItemPrototype(item_id))
-{
-sLog.outErrorDb("Item id %u (race %u class %u) in `playercreateinfo_item` table but not listed in `item_template`, ignoring.",item_id,current_race,current_class);
-continue;
-}
-
-int32 amount = fields[3].GetInt32();
-
-if (!amount)
-{
-sLog.outErrorDb("Item id %u (class %u race %u) have amount == 0 in `playercreateinfo_item` table, ignoring.",item_id,current_race,current_class);
-continue;
-}
-
-if (!current_race || !current_class)
-{
-uint32 min_race = current_race ? current_race : 1;
-uint32 max_race = current_race ? current_race + 1 : MAX_RACES;
-uint32 min_class = current_class ? current_class : 1;
-uint32 max_class = current_class ? current_class + 1 : MAX_CLASSES;
-for (uint32 r = min_race; r < max_race; ++r)
-for (uint32 c = min_class; c < max_class; ++c)
-PlayerCreateInfoAddItemHelper(r, c, item_id, amount);
-}
-else
-PlayerCreateInfoAddItemHelper(current_race, current_class, item_id, amount);
-
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u custom player create items", count);
-}
-}
-
-// Load playercreate spells
-sLog.outString("Loading Player Create Spell Data...");
-{
-
-QueryResult result = QueryResult(NULL);
-if (sWorld.getBoolConfig(CONFIG_START_ALL_SPELLS))
-result = WorldDatabase.Query("SELECT race, class, Spell, Active FROM playercreateinfo_spell_custom");
-else
-result = WorldDatabase.Query("SELECT race, class, Spell FROM playercreateinfo_spell");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-sLog.outString();
-sLog.outString(">> Loaded %u player create spells", count);
-sLog.outErrorDb("Error loading player starting spells or empty table.");
-}
-else
-{
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 current_race = fields[0].GetUInt32();
-if (current_race >= MAX_RACES)
-{
-sLog.outErrorDb("Wrong race %u in `playercreateinfo_spell` table, ignoring.",current_race);
-continue;
-}
-
-uint32 current_class = fields[1].GetUInt32();
-if (current_class >= MAX_CLASSES)
-{
-sLog.outErrorDb("Wrong class %u in `playercreateinfo_spell` table, ignoring.",current_class);
-continue;
-}
-
-if (!current_race || !current_class)
-{
-uint32 min_race = current_race ? current_race : 1;
-uint32 max_race = current_race ? current_race + 1 : MAX_RACES;
-uint32 min_class = current_class ? current_class : 1;
-uint32 max_class = current_class ? current_class + 1 : MAX_CLASSES;
-for (uint32 r = min_race; r < max_race; ++r)
-for (uint32 c = min_class; c < max_class; ++c)
-playerInfo[r][c].spell.push_back(fields[2].GetUInt32());
-}
-else
-playerInfo[current_race][current_class].spell.push_back(fields[2].GetUInt32());
-
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u player create spells", count);
-}
-}
-
-// Load playercreate actions
-sLog.outString("Loading Player Create Action Data...");
-{
-// 0 1 2 3 4
-QueryResult result = WorldDatabase.Query("SELECT race, class, button, action, type FROM playercreateinfo_action");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-sLog.outString();
-sLog.outString(">> Loaded %u player create actions", count);
-sLog.outErrorDb("Error loading `playercreateinfo_action` table or empty table.");
-}
-else
-{
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 current_race = fields[0].GetUInt32();
-if (current_race >= MAX_RACES)
-{
-sLog.outErrorDb("Wrong race %u in `playercreateinfo_action` table, ignoring.",current_race);
-continue;
-}
-
-uint32 current_class = fields[1].GetUInt32();
-if (current_class >= MAX_CLASSES)
-{
-sLog.outErrorDb("Wrong class %u in `playercreateinfo_action` table, ignoring.",current_class);
-continue;
-}
-
-PlayerInfo* pInfo = &playerInfo[current_race][current_class];
-pInfo->action.push_back(PlayerCreateInfoAction(fields[2].GetUInt8(),fields[3].GetUInt32(),fields[4].GetUInt8()));
-
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u player create actions", count);
-}
-}
-
-// Loading levels data (class only dependent)
-sLog.outString("Loading Player Create Level HP/Mana Data...");
-{
-// 0 1 2 3
-QueryResult result = WorldDatabase.Query("SELECT class, level, basehp, basemana FROM player_classlevelstats");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-sLog.outString();
-sLog.outString(">> Loaded %u level health/mana definitions", count);
-sLog.outErrorDb("Error loading `player_classlevelstats` table or empty table.");
-exit(1);
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 current_class = fields[0].GetUInt32();
-if (current_class >= MAX_CLASSES)
-{
-sLog.outErrorDb("Wrong class %u in `player_classlevelstats` table, ignoring.",current_class);
-continue;
-}
-
-uint8 current_level = fields[1].GetUInt8(); // Can't be > than STRONG_MAX_LEVEL (hardcoded level maximum) due to var type
-if (current_level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-{
-sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `player_classlevelstats` table, ignoring.",current_level);
-++count; // make result loading percent "expected" correct in case disabled detail mode for example.
-continue;
-}
-
-PlayerClassInfo* pClassInfo = &playerClassInfo[current_class];
-
-if (!pClassInfo->levelInfo)
-pClassInfo->levelInfo = new PlayerClassLevelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
-
-PlayerClassLevelInfo* pClassLevelInfo = &pClassInfo->levelInfo[current_level-1];
-
-pClassLevelInfo->basehealth = fields[2].GetUInt16();
-pClassLevelInfo->basemana = fields[3].GetUInt16();
-
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u level health/mana definitions", count);
-}
-
-// Fill gaps and check integrity
-for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
-{
-// skip non existed classes
-if (!sChrClassesStore.LookupEntry(class_))
-continue;
-
-PlayerClassInfo* pClassInfo = &playerClassInfo[class_];
-
-// fatal error if no level 1 data
-if (!pClassInfo->levelInfo || pClassInfo->levelInfo[0].basehealth == 0)
-{
-sLog.outErrorDb("Class %i Level 1 does not have health/mana data!",class_);
-exit(1);
-}
-
-// fill level gaps
-for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
-{
-if (pClassInfo->levelInfo[level].basehealth == 0)
-{
-sLog.outErrorDb("Class %i Level %i does not have health/mana data. Using stats data of level %i.",class_,level+1, level);
-pClassInfo->levelInfo[level] = pClassInfo->levelInfo[level-1];
-}
-}
-}
-
-// Loading levels data (class/race dependent)
-sLog.outString("Loading Player Create Level Stats Data...");
-{
-// 0 1 2 3 4 5 6 7
-QueryResult result = WorldDatabase.Query("SELECT race, class, level, str, agi, sta, inte, spi FROM player_levelstats");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-sLog.outString();
-sLog.outString(">> Loaded %u level stats definitions", count);
-sLog.outErrorDb("Error loading `player_levelstats` table or empty table.");
-exit(1);
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 current_race = fields[0].GetUInt32();
-if (current_race >= MAX_RACES)
-{
-sLog.outErrorDb("Wrong race %u in `player_levelstats` table, ignoring.",current_race);
-continue;
-}
-
-uint32 current_class = fields[1].GetUInt32();
-if (current_class >= MAX_CLASSES)
-{
-sLog.outErrorDb("Wrong class %u in `player_levelstats` table, ignoring.",current_class);
-continue;
-}
-
-uint32 current_level = fields[2].GetUInt32();
-if (current_level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-{
-if (current_level > STRONG_MAX_LEVEL) // hardcoded level maximum
-sLog.outErrorDb("Wrong (> %u) level %u in `player_levelstats` table, ignoring.",STRONG_MAX_LEVEL,current_level);
-else
-{
-sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `player_levelstats` table, ignoring.",current_level);
-++count; // make result loading percent "expected" correct in case disabled detail mode for example.
-}
-continue;
-}
-
-PlayerInfo* pInfo = &playerInfo[current_race][current_class];
-
-if (!pInfo->levelInfo)
-pInfo->levelInfo = new PlayerLevelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
-
-PlayerLevelInfo* pLevelInfo = &pInfo->levelInfo[current_level-1];
-
-for (int i = 0; i < MAX_STATS; i++)
-{
-pLevelInfo->stats[i] = fields[i+3].GetUInt8();
-}
-
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u level stats definitions", count);
-}
-
-// Fill gaps and check integrity
-for (int race = 0; race < MAX_RACES; ++race)
-{
-// skip non existed races
-if (!sChrRacesStore.LookupEntry(race))
-continue;
-
-for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
-{
-// skip non existed classes
-if (!sChrClassesStore.LookupEntry(class_))
-continue;
-
-PlayerInfo* pInfo = &playerInfo[race][class_];
-
-// skip non loaded combinations
-if (!pInfo->displayId_m || !pInfo->displayId_f)
-continue;
-
-// skip expansion races if not playing with expansion
-if (sWorld.getIntConfig(CONFIG_EXPANSION) < 1 && (race == RACE_BLOODELF || race == RACE_DRAENEI))
-continue;
-
-// skip expansion classes if not playing with expansion
-if (sWorld.getIntConfig(CONFIG_EXPANSION) < 2 && class_ == CLASS_DEATH_KNIGHT)
-continue;
-
-// fatal error if no level 1 data
-if (!pInfo->levelInfo || pInfo->levelInfo[0].stats[0] == 0)
-{
-sLog.outErrorDb("Race %i Class %i Level 1 does not have stats data!",race,class_);
-exit(1);
-}
-
-// fill level gaps
-for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
-{
-if (pInfo->levelInfo[level].stats[0] == 0)
-{
-sLog.outErrorDb("Race %i Class %i Level %i does not have stats data. Using stats data of level %i.",race,class_,level+1, level);
-pInfo->levelInfo[level] = pInfo->levelInfo[level-1];
-}
-}
-}
-}
-
-// Loading xp per level data
-sLog.outString("Loading Player Create XP Data...");
-{
-mPlayerXPperLevel.resize(sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
-for (uint8 level = 0; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
-mPlayerXPperLevel[level] = 0;
-
-// 0 1
-QueryResult result = WorldDatabase.Query("SELECT lvl, xp_for_next_level FROM player_xp_for_level");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-
-sLog.outString();
-sLog.outString(">> Loaded %u xp for level definitions", count);
-sLog.outErrorDb("Error loading `player_xp_for_level` table or empty table.");
-exit(1);
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field* fields = result->Fetch();
-
-uint32 current_level = fields[0].GetUInt32();
-uint32 current_xp = fields[1].GetUInt32();
-
-if (current_level >= sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-{
-if (current_level > STRONG_MAX_LEVEL) // hardcoded level maximum
-sLog.outErrorDb("Wrong (> %u) level %u in `player_xp_for_level` table, ignoring.", STRONG_MAX_LEVEL,current_level);
-else
-{
-sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `player_xp_for_levels` table, ignoring.",current_level);
-++count; // make result loading percent "expected" correct in case disabled detail mode for example.
-}
-continue;
-}
-//PlayerXPperLevel
-mPlayerXPperLevel[current_level] = current_xp;
-bar.step();
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u xp for level definitions", count);
-}
-
-// fill level gaps
-for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
-{
-if (mPlayerXPperLevel[level] == 0)
-{
-sLog.outErrorDb("Level %i does not have XP for level data. Using data of level [%i] + 100.",level+1, level);
-mPlayerXPperLevel[level] = mPlayerXPperLevel[level-1]+100;
-}
-}
-}
-
-void ObjectMgr::GetPlayerClassLevelInfo(uint32 class_, uint8 level, PlayerClassLevelInfo* info) const
-{
-if (level < 1 || class_ >= MAX_CLASSES)
-return;
-
-PlayerClassInfo const* pInfo = &playerClassInfo[class_];
-
-if (level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-level = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
-
-*info = pInfo->levelInfo[level-1];
-}
-
-void ObjectMgr::GetPlayerLevelInfo(uint32 race, uint32 class_, uint8 level, PlayerLevelInfo* info) const
-{
-if (level < 1 || race >= MAX_RACES || class_ >= MAX_CLASSES)
-return;
-
-PlayerInfo const* pInfo = &playerInfo[race][class_];
-if (pInfo->displayId_m == 0 || pInfo->displayId_f == 0)
-return;
-
-if (level <= sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
-*info = pInfo->levelInfo[level-1];
-else
-BuildPlayerLevelInfo(race,class_,level,info);
-}
-
-void ObjectMgr::BuildPlayerLevelInfo(uint8 race, uint8 _class, uint8 level, PlayerLevelInfo* info) const
-{
-// base data (last known level)
-*info = playerInfo[race][_class].levelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)-1];
-
-// if conversion from uint32 to uint8 causes unexpected behaviour, change lvl to uint32
-for (uint8 lvl = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)-1; lvl < level; ++lvl)
-{
-switch(_class)
-{
-case CLASS_WARRIOR:
-info->stats[STAT_STRENGTH] += (lvl > 23 ? 2: (lvl > 1 ? 1: 0));
-info->stats[STAT_STAMINA] += (lvl > 23 ? 2: (lvl > 1 ? 1: 0));
-info->stats[STAT_AGILITY] += (lvl > 36 ? 1: (lvl > 6 && (lvl%2) ? 1: 0));
-info->stats[STAT_INTELLECT] += (lvl > 9 && !(lvl%2) ? 1: 0);
-info->stats[STAT_SPIRIT] += (lvl > 9 && !(lvl%2) ? 1: 0);
-break;
-case CLASS_PALADIN:
-info->stats[STAT_STRENGTH] += (lvl > 3 ? 1: 0);
-info->stats[STAT_STAMINA] += (lvl > 33 ? 2: (lvl > 1 ? 1: 0));
-info->stats[STAT_AGILITY] += (lvl > 38 ? 1: (lvl > 7 && !(lvl%2) ? 1: 0));
-info->stats[STAT_INTELLECT] += (lvl > 6 && (lvl%2) ? 1: 0);
-info->stats[STAT_SPIRIT] += (lvl > 7 ? 1: 0);
-break;
-case CLASS_HUNTER:
-info->stats[STAT_STRENGTH] += (lvl > 4 ? 1: 0);
-info->stats[STAT_STAMINA] += (lvl > 4 ? 1: 0);
-info->stats[STAT_AGILITY] += (lvl > 33 ? 2: (lvl > 1 ? 1: 0));
-info->stats[STAT_INTELLECT] += (lvl > 8 && (lvl%2) ? 1: 0);
-info->stats[STAT_SPIRIT] += (lvl > 38 ? 1: (lvl > 9 && !(lvl%2) ? 1: 0));
-break;
-case CLASS_ROGUE:
-info->stats[STAT_STRENGTH] += (lvl > 5 ? 1: 0);
-info->stats[STAT_STAMINA] += (lvl > 4 ? 1: 0);
-info->stats[STAT_AGILITY] += (lvl > 16 ? 2: (lvl > 1 ? 1: 0));
-info->stats[STAT_INTELLECT] += (lvl > 8 && !(lvl%2) ? 1: 0);
-info->stats[STAT_SPIRIT] += (lvl > 38 ? 1: (lvl > 9 && !(lvl%2) ? 1: 0));
-break;
-case CLASS_PRIEST:
-info->stats[STAT_STRENGTH] += (lvl > 9 && !(lvl%2) ? 1: 0);
-info->stats[STAT_STAMINA] += (lvl > 5 ? 1: 0);
-info->stats[STAT_AGILITY] += (lvl > 38 ? 1: (lvl > 8 && (lvl%2) ? 1: 0));
-info->stats[STAT_INTELLECT] += (lvl > 22 ? 2: (lvl > 1 ? 1: 0));
-info->stats[STAT_SPIRIT] += (lvl > 3 ? 1: 0);
-break;
-case CLASS_SHAMAN:
-info->stats[STAT_STRENGTH] += (lvl > 34 ? 1: (lvl > 6 && (lvl%2) ? 1: 0));
-info->stats[STAT_STAMINA] += (lvl > 4 ? 1: 0);
-info->stats[STAT_AGILITY] += (lvl > 7 && !(lvl%2) ? 1: 0);
-info->stats[STAT_INTELLECT] += (lvl > 5 ? 1: 0);
-info->stats[STAT_SPIRIT] += (lvl > 4 ? 1: 0);
-break;
-case CLASS_MAGE:
-info->stats[STAT_STRENGTH] += (lvl > 9 && !(lvl%2) ? 1: 0);
-info->stats[STAT_STAMINA] += (lvl > 5 ? 1: 0);
-info->stats[STAT_AGILITY] += (lvl > 9 && !(lvl%2) ? 1: 0);
-info->stats[STAT_INTELLECT] += (lvl > 24 ? 2: (lvl > 1 ? 1: 0));
-info->stats[STAT_SPIRIT] += (lvl > 33 ? 2: (lvl > 2 ? 1: 0));
-break;
-case CLASS_WARLOCK:
-info->stats[STAT_STRENGTH] += (lvl > 9 && !(lvl%2) ? 1: 0);
-info->stats[STAT_STAMINA] += (lvl > 38 ? 2: (lvl > 3 ? 1: 0));
-info->stats[STAT_AGILITY] += (lvl > 9 && !(lvl%2) ? 1: 0);
-info->stats[STAT_INTELLECT] += (lvl > 33 ? 2: (lvl > 2 ? 1: 0));
-info->stats[STAT_SPIRIT] += (lvl > 38 ? 2: (lvl > 3 ? 1: 0));
-break;
-case CLASS_DRUID:
-info->stats[STAT_STRENGTH] += (lvl > 38 ? 2: (lvl > 6 && (lvl%2) ? 1: 0));
-info->stats[STAT_STAMINA] += (lvl > 32 ? 2: (lvl > 4 ? 1: 0));
-info->stats[STAT_AGILITY] += (lvl > 38 ? 2: (lvl > 8 && (lvl%2) ? 1: 0));
-info->stats[STAT_INTELLECT] += (lvl > 38 ? 3: (lvl > 4 ? 1: 0));
-info->stats[STAT_SPIRIT] += (lvl > 38 ? 3: (lvl > 5 ? 1: 0));
-}
-}
-}
-
-void ObjectMgr::LoadGuilds()
-{
-PreparedStatement* stmt = NULL;
-PreparedQueryResult result;
-
-sLog.outString("Loading Guilds...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILDS);
-result = CharacterDatabase.Query(stmt);
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString(">> Loaded 0 guild definitions");
-sLog.outString();
-return;
-}
-mGuildMap.resize(m_guildId, NULL);         // Reserve space and initialize storage for loading guilds
-// 1. Load all guilds
-uint64 rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-Guild* pNewGuild = new Guild();
-if (!pNewGuild->LoadFromDB(fields))
-{
-delete pNewGuild;
-continue;
-}
-AddGuild(pNewGuild);
-}
-while (result->NextRow());
-sLog.outString();
-sLog.outString(">> Loaded " UI64FMTD " guilds definitions", rowCount);
-sLog.outString();
-
-// 2. Load all guild ranks
-sLog.outString("Loading guild ranks...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_RANKS);
-result = CharacterDatabase.Query(stmt);
-if (result)
-{
-rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-uint32 guildId = fields[0].GetUInt32();
-if (Guild* pGuild = GetGuildById(guildId))
-pGuild->LoadRankFromDB(fields);
-}
-while (result->NextRow());
-}
-else
-{
-rowCount = 0;
-barGoLink bar(1);
-bar.step();
-}
-sLog.outString(">> Loaded " UI64FMTD " ranks for all the guilds", rowCount);
-sLog.outString();
-
-// 3. Load all guild members
-sLog.outString("Loading guild members...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_MEMBERS);
-result = CharacterDatabase.Query(stmt);
-if (result)
-{
-rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-uint32 guildId = fields[0].GetUInt32();
-if (Guild* pGuild = GetGuildById(guildId))
-pGuild->LoadMemberFromDB(fields);
-}
-while (result->NextRow());
-}
-else
-{
-rowCount = 0;
-barGoLink bar(1);
-bar.step();
-}
-sLog.outString(">> Loaded " UI64FMTD " members from all the guilds", rowCount);
-sLog.outString();
-
-// 4. Load all guild bank tab rights
-sLog.outString("Loading bank tab rights...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_RIGHTS);
-result = CharacterDatabase.Query(stmt);
-if (result)
-{
-rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-uint32 guildId = fields[0].GetUInt32();
-if (Guild* pGuild = GetGuildById(guildId))
-pGuild->LoadBankRightFromDB(fields);
-}
-while (result->NextRow());
-}
-else
-{
-rowCount = 0;
-barGoLink bar(1);
-bar.step();
-}
-sLog.outString(">> Loaded " UI64FMTD " bank tab rights for all the guilds", rowCount);
-sLog.outString();
-
-// 5. Load all event logs
-sLog.outString("Loading guild event logs...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_EVENTLOGS);
-result = CharacterDatabase.Query(stmt);
-if (result)
-{
-rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-uint32 guildId = fields[0].GetUInt32();
-if (Guild* pGuild = GetGuildById(guildId))
-pGuild->LoadEventLogFromDB(fields);
-}
-while (result->NextRow());
-}
-else
-{
-rowCount = 0;
-barGoLink bar(1);
-bar.step();
-}
-sLog.outString(">> Loaded " UI64FMTD " event logs for all the guilds", rowCount);
-sLog.outString();
-
-// 6. Load all bank event logs
-sLog.outString("Loading guild bank event logs...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_EVENTLOGS);
-result = CharacterDatabase.Query(stmt);
-if (result)
-{
-rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-uint32 guildId = fields[0].GetUInt32();
-if (Guild* pGuild = GetGuildById(guildId))
-pGuild->LoadBankEventLogFromDB(fields);
-}
-while (result->NextRow());
-}
-else
-{
-rowCount = 0;
-barGoLink bar(1);
-bar.step();
-}
-sLog.outString(">> Loaded " UI64FMTD " bank event logs for all the guilds", rowCount);
-sLog.outString();
-
-// 7. Load all guild bank tabs
-sLog.outString("Loading guild bank tabs...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_TABS);
-result = CharacterDatabase.Query(stmt);
-if (result)
-{
-rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-uint32 guildId = fields[0].GetUInt32();
-if (Guild* pGuild = GetGuildById(guildId))
-pGuild->LoadBankTabFromDB(fields);
-}
-while (result->NextRow());
-}
-else
-{
-rowCount = 0;
-barGoLink bar(1);
-bar.step();
-}
-sLog.outString(">> Loaded " UI64FMTD " bank tabs for all the guilds", rowCount);
-sLog.outString();
-
-// 8. Fill all guild bank tabs
-sLog.outString("Filling bank tabs with items...");
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_ITEMS);
-result = CharacterDatabase.Query(stmt);
-if (result)
-{
-rowCount = result->GetRowCount();
-barGoLink bar(rowCount);
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-uint32 guildId = fields[11].GetUInt32();
-if (Guild* pGuild = GetGuildById(guildId))
-pGuild->LoadBankItemFromDB(fields);
-}
-while (result->NextRow());
-}
-else
-{
-rowCount = 0;
-barGoLink bar(1);
-bar.step();
-}
-sLog.outString(">> Filled bank tabs with " UI64FMTD " items for all the guilds", rowCount);
-sLog.outString();
-
-// 9. Validate loaded guild data
-uint32 totalGuilds = 0;
-sLog.outString("Validating data of loaded guilds...");
-barGoLink barGuilds(mGuildMap.size());
-for (GuildMap::iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
-{
-barGuilds.step();
-Guild* pGuild = *itr;
-if (pGuild)
-{
-if (!pGuild->Validate())
-{
-RemoveGuild(pGuild->GetId());
-delete pGuild;
-}
-else
-++totalGuilds;
-}
-}
-// Cleanup
-// Delete orphan guild ranks
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_RANKS);
-CharacterDatabase.Execute(stmt);
-// Delete orphan guild members
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_MEMBERS);
-CharacterDatabase.Execute(stmt);
-// Delete orphan guild bank rights
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_BANK_RIGHTS);
-CharacterDatabase.Execute(stmt);
-// Delete orphan guild bank tabs
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_BANK_TABS);
-CharacterDatabase.Execute(stmt);
-// Delete orphan guild bank items
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_BANK_ITEMS);
-CharacterDatabase.Execute(stmt);
-
-// Delete unused LogGuid records in guild_eventlog and guild_bank_eventlog table.
-// You can comment these lines if you don't plan to change CONFIG_GUILD_EVENT_LOG_COUNT and CONFIG_GUILD_BANK_EVENT_LOG_COUNT
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_OLD_GUILD_EVENT_LOGS);
-stmt->setUInt32(0, sWorld.getIntConfig(CONFIG_GUILD_EVENT_LOG_COUNT));
-CharacterDatabase.Execute(stmt);
-
-stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_OLD_GUILD_BANK_EVENT_LOGS);
-stmt->setUInt32(0, sWorld.getIntConfig(CONFIG_GUILD_BANK_EVENT_LOG_COUNT));
-CharacterDatabase.Execute(stmt);
-
-sLog.outString();
-sLog.outString(">> Successfully loaded %u guilds", totalGuilds);
-}
-
-void ObjectMgr::LoadArenaTeams()
-{
-uint32 count = 0;
-
-// 0 1 2 3 4 5
-QueryResult result = CharacterDatabase.Query("SELECT arena_team.arenateamid,name,captainguid,type,BackgroundColor,EmblemStyle,"
-// 6 7 8 9 10 11 12 13 14
-"EmblemColor,BorderStyle,BorderColor, rating,games,wins,played,wins2,rank "
-"FROM arena_team LEFT JOIN arena_team_stats ON arena_team.arenateamid = arena_team_stats.arenateamid ORDER BY arena_team.arenateamid ASC");
-
-if (!result)
-{
-
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u arenateam definitions", count);
-return;
-}
-
-// load arena_team members
-QueryResult arenaTeamMembersResult = CharacterDatabase.Query(
-// 0 1 2 3 4 5 6 7 8
-"SELECT arenateamid,member.guid,played_week,wons_week,played_season,wons_season,name,class "
-"FROM arena_team_member member LEFT JOIN characters chars on member.guid = chars.guid ORDER BY member.arenateamid ASC");
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-//Field *fields = result->Fetch();
-
-bar.step();
-++count;
-
-ArenaTeam *newArenaTeam = new ArenaTeam;
-if (!newArenaTeam->LoadArenaTeamFromDB(result) ||
-!newArenaTeam->LoadMembersFromDB(arenaTeamMembersResult))
-{
-newArenaTeam->Disband(NULL);
-delete newArenaTeam;
-continue;
-}
-AddArenaTeam(newArenaTeam);
-}while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u arenateam definitions", count);
-}
-
-void ObjectMgr::LoadGroups()
-{
-Group *group = NULL;
-Field *fields = NULL;
-uint32 count = 0;
-
-// Consistency cleaning before load to avoid having to do some checks later
-// Delete all members that does not exist
-CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_NONEXISTENT_CHARACTER_GROUP_MEMBERS));
-// Delete all groups whose leader does not exist
-CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_LEADERLESS_GROUPS));
-// Delete all groups with less than 2 members
-CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_TINY_GROUPS));
-// Delete all rows from group_member or group_instance with no group
-CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_NONEXISTENT_GROUP_MEMBERS));
-CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_NONEXISTENT_GROUP_INSTANCES));
-
-// ----------------------- Load Group definitions
-// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
-QueryResult result = CharacterDatabase.PQuery("SELECT leaderGuid, lootMethod, looterGuid, lootThreshold, icon1, icon2, icon3, icon4, icon5, icon6, icon7, icon8, groupType, difficulty, raiddifficulty, guid FROM groups");
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded 0 group definitions");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-do
-{
-bar.step();
-fields = result->Fetch();
-++count;
-group = new Group;
-group->LoadGroupFromDB(fields[15].GetUInt32(), result, false);
-// group load will never be false (we have run consistency sql's before loading)
-AddGroup(group);
-}while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u group definitions", count);
-
-// ----------------------- Load member
-// 0 1 2 3 4
-result = CharacterDatabase.Query("SELECT guid, memberGuid, memberFlags, subgroup, roles FROM group_member ORDER BY guid");
-if (!result)
-{
-barGoLink bar2(1);
-bar2.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 group members");
-return;
-}
-
-barGoLink bar2(result->GetRowCount());
-uint32 groupLowGuid = 0;
-count = 0;
-do
-{
-bar2.step();
-fields = result->Fetch();
-
-if (groupLowGuid != fields[0].GetUInt32())
-{
-groupLowGuid = fields[0].GetUInt32();
-group = GetGroupByGUID(groupLowGuid);
-}
-if (group) // Should never be null
-group->LoadMemberFromDB(fields[1].GetUInt32(), fields[2].GetUInt8(), fields[3].GetUInt8(), fields[4].GetUInt8());
-else
-sLog.outError("ObjectMgr::LoadGroups: Consistency failed, can't find group (lowguid %u)", groupLowGuid);
-++count;
-}while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u group members", count);
-
-
-// ----------------------- Load instance save
-// 0 1 2 3 4 5
-result = CharacterDatabase.Query("SELECT guid, map, instance, permanent, difficulty, resettime, "
-// 6
-"(SELECT COUNT(1) FROM groups JOIN character_instance ON leaderGuid = groups.guid WHERE instance = group_instance.instance AND permanent = 1 LIMIT 1) "
-"FROM group_instance LEFT JOIN instance ON instance = id ORDER BY guid");
-
-if (!result)
-{
-barGoLink bar2(1);
-bar2.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 group-instance saves");
-return;
-}
-
-barGoLink bar3(result->GetRowCount());
-count = 0;
-do
-{
-bar3.step();
-fields = result->Fetch();
-group = GetGroupByGUID(fields[0].GetUInt32());
-// group will never be NULL (we have run consistency sql's before loading)
-
-MapEntry const* mapEntry = sMapStore.LookupEntry(fields[1].GetUInt32());
-if (!mapEntry || !mapEntry->IsDungeon())
-{
-sLog.outErrorDb("Incorrect entry in group_instance table : no dungeon map %d", fields[1].GetUInt32());
-continue;
-}
-
-uint32 diff = fields[4].GetUInt8();
-if (diff >= uint32(mapEntry->IsRaid() ? MAX_RAID_DIFFICULTY : MAX_DUNGEON_DIFFICULTY))
-{
-sLog.outErrorDb("Wrong dungeon difficulty use in group_instance table: %d", diff + 1);
-diff = 0; // default for both difficaly types
-}
-
-InstanceSave *save = sInstanceSaveMgr.AddInstanceSave(mapEntry->MapID, fields[2].GetUInt32(), Difficulty(diff), time_t(fields[5].GetUInt64()), fields[6].GetBool(), true);
-group->BindToInstance(save, fields[3].GetBool(), true);
-++count;
-}while (result->NextRow());
-sLog.outString();
-sLog.outString(">> Loaded %u group-instance saves", count);
-}
-
-void ObjectMgr::LoadQuests()
-{
-// For reload case
-for (QuestMap::const_iterator itr=mQuestTemplates.begin(); itr != mQuestTemplates.end(); ++itr)
-delete itr->second;
-mQuestTemplates.clear();
-
-mExclusiveQuestGroups.clear();
-
-// 0 1 2 3 4 5 6 7 8 9
-QueryResult result = WorldDatabase.Query("SELECT entry, Method, ZoneOrSort, SkillOrClassMask, MinLevel, MaxLevel, QuestLevel, Type, RequiredRaces, RequiredSkillValue,"
-// 10 11 12 13 14 15 16 17 18 19
-"RepObjectiveFaction, RepObjectiveValue, RepObjectiveFaction2, RepObjectiveValue2, RequiredMinRepFaction, RequiredMinRepValue, RequiredMaxRepFaction, RequiredMaxRepValue, SuggestedPlayers, LimitTime,"
-// 20 21 22 23 24 25 26 27 28 29 30 31 32 33
-"QuestFlags, SpecialFlags, CharTitleId, PlayersSlain, BonusTalents, RewardArenaPoints, PrevQuestId, NextQuestId, ExclusiveGroup, NextQuestInChain, RewXPId, SrcItemId, SrcItemCount, SrcSpell,"
-// 34 35 36 37 38 39 40 41 42 43 44
-"Title, Details, Objectives, OfferRewardText, RequestItemsText, EndText, CompletedText, ObjectiveText1, ObjectiveText2, ObjectiveText3, ObjectiveText4,"
-// 45 46 47 48 49 50 51 52 53 54 55 56
-"ReqItemId1, ReqItemId2, ReqItemId3, ReqItemId4, ReqItemId5, ReqItemId6, ReqItemCount1, ReqItemCount2, ReqItemCount3, ReqItemCount4, ReqItemCount5, ReqItemCount6,"
-// 57 58 59 60 61 62 63 64
-"ReqSourceId1, ReqSourceId2, ReqSourceId3, ReqSourceId4, ReqSourceCount1, ReqSourceCount2, ReqSourceCount3, ReqSourceCount4,"
-// 65 66 67 68 69 70 71 72
-"ReqCreatureOrGOId1, ReqCreatureOrGOId2, ReqCreatureOrGOId3, ReqCreatureOrGOId4, ReqCreatureOrGOCount1, ReqCreatureOrGOCount2, ReqCreatureOrGOCount3, ReqCreatureOrGOCount4,"
-// 73 74 75 76
-"ReqSpellCast1, ReqSpellCast2, ReqSpellCast3, ReqSpellCast4,"
-// 77 78 79 80 81 82
-"RewChoiceItemId1, RewChoiceItemId2, RewChoiceItemId3, RewChoiceItemId4, RewChoiceItemId5, RewChoiceItemId6,"
-// 83 84 85 86 87 88
-"RewChoiceItemCount1, RewChoiceItemCount2, RewChoiceItemCount3, RewChoiceItemCount4, RewChoiceItemCount5, RewChoiceItemCount6,"
-// 89 90 91 92 93 94 95 96
-"RewItemId1, RewItemId2, RewItemId3, RewItemId4, RewItemCount1, RewItemCount2, RewItemCount3, RewItemCount4,"
-// 97 98 99 100 101 102 103 104 105 106
-"RewRepFaction1, RewRepFaction2, RewRepFaction3, RewRepFaction4, RewRepFaction5, RewRepValueId1, RewRepValueId2, RewRepValueId3, RewRepValueId4, RewRepValueId5,"
-// 107 108 109 110 111
-"RewRepValue1, RewRepValue2, RewRepValue3, RewRepValue4, RewRepValue5,"
-// 112 113 114 115 116 117 118 119 120 121 122 123
-"RewHonorAddition, RewHonorMultiplier, RewOrReqMoney, RewMoneyMaxLevel, RewSpell, RewSpellCast, RewMailTemplateId, RewMailDelaySecs, PointMapId, PointX, PointY, PointOpt,"
-// 124 125 126 127 128 129 130 131
-"DetailsEmote1, DetailsEmote2, DetailsEmote3, DetailsEmote4, DetailsEmoteDelay1, DetailsEmoteDelay2, DetailsEmoteDelay3, DetailsEmoteDelay4,"
-// 132 133 134 135 136 137
-"IncompleteEmote, CompleteEmote, OfferRewardEmote1, OfferRewardEmote2, OfferRewardEmote3, OfferRewardEmote4,"
-// 138 139 140 141
-"OfferRewardEmoteDelay1, OfferRewardEmoteDelay2, OfferRewardEmoteDelay3, OfferRewardEmoteDelay4,"
-// 142 143
-"StartScript, CompleteScript"
-" FROM quest_template");
-if (result == NULL)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded 0 quests definitions");
-sLog.outErrorDb("`quest_template` table is empty!");
-return;
-}
-
-// create multimap previous quest for each existed quest
-// some quests can have many previous maps set by NextQuestId in previous quest
-// for example set of race quests can lead to single not race specific quest
-barGoLink bar(result->GetRowCount());
-do
-{
-bar.step();
-Field *fields = result->Fetch();
-
-Quest * newQuest = new Quest(fields);
-mQuestTemplates[newQuest->GetQuestId()] = newQuest;
-} while (result->NextRow());
-
-std::map<uint32,uint32> usedMailTemplates;
-
-// Post processing
-for (QuestMap::iterator iter = mQuestTemplates.begin(); iter != mQuestTemplates.end(); ++iter)
-{
-// skip post-loading checks for disabled quests
-if (sDisableMgr.IsDisabledFor(DISABLE_TYPE_QUEST, iter->first, NULL))
-continue;
-
-Quest * qinfo = iter->second;
-
-// additional quest integrity checks (GO, creature_template and item_template must be loaded already)
-
-if (qinfo->GetQuestMethod() >= 3)
-{
-sLog.outErrorDb("Quest %u has `Method` = %u, expected values are 0, 1 or 2.",qinfo->GetQuestId(),qinfo->GetQuestMethod());
-}
-
-if (qinfo->QuestFlags & ~QUEST_TRINITY_FLAGS_DB_ALLOWED)
-{
-sLog.outErrorDb("Quest %u has `SpecialFlags` = %u > max allowed value. Correct `SpecialFlags` to value <= %u",
-qinfo->GetQuestId(),qinfo->QuestFlags >> 20, QUEST_TRINITY_FLAGS_DB_ALLOWED >> 20);
-qinfo->QuestFlags &= QUEST_TRINITY_FLAGS_DB_ALLOWED;
-}
-
-if (qinfo->QuestFlags & QUEST_FLAGS_DAILY && qinfo->QuestFlags & QUEST_FLAGS_WEEKLY)
-{
-sLog.outErrorDb("Weekly Quest %u is marked as daily quest in `QuestFlags`, removed daily flag.",qinfo->GetQuestId());
-qinfo->QuestFlags &= ~QUEST_FLAGS_DAILY;
-}
-
-if (qinfo->QuestFlags & QUEST_FLAGS_DAILY)
-{
-if (!(qinfo->QuestFlags & QUEST_TRINITY_FLAGS_REPEATABLE))
-{
-sLog.outErrorDb("Daily Quest %u not marked as repeatable in `SpecialFlags`, added.",qinfo->GetQuestId());
-qinfo->QuestFlags |= QUEST_TRINITY_FLAGS_REPEATABLE;
-}
-}
-
-if (qinfo->QuestFlags & QUEST_FLAGS_WEEKLY)
-{
-if (!(qinfo->QuestFlags & QUEST_TRINITY_FLAGS_REPEATABLE))
-{
-sLog.outErrorDb("Weekly Quest %u not marked as repeatable in `SpecialFlags`, added.",qinfo->GetQuestId());
-qinfo->QuestFlags |= QUEST_TRINITY_FLAGS_REPEATABLE;
-}
-}
-
-if (qinfo->QuestFlags & QUEST_FLAGS_AUTO_REWARDED)
-{
-// at auto-reward can be rewarded only RewChoiceItemId[0]
-for (int j = 1; j < QUEST_REWARD_CHOICES_COUNT; ++j )
-{
-if (uint32 id = qinfo->RewChoiceItemId[j])
-{
-sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = %u but item from `RewChoiceItemId%d` can't be rewarded with quest flag QUEST_FLAGS_AUTO_REWARDED.",
-qinfo->GetQuestId(),j+1,id,j+1);
-// no changes, quest ignore this data
-}
-}
-}
-
-// client quest log visual (area case)
-if (qinfo->ZoneOrSort > 0)
-{
-if (!GetAreaEntryByAreaID(qinfo->ZoneOrSort))
-{
-sLog.outErrorDb("Quest %u has `ZoneOrSort` = %u (zone case) but zone with this id does not exist.",
-qinfo->GetQuestId(),qinfo->ZoneOrSort);
-// no changes, quest not dependent from this value but can have problems at client
-}
-}
-// client quest log visual (sort case)
-if (qinfo->ZoneOrSort < 0)
-{
-QuestSortEntry const* qSort = sQuestSortStore.LookupEntry(-int32(qinfo->ZoneOrSort));
-if (!qSort)
-{
-sLog.outErrorDb("Quest %u has `ZoneOrSort` = %i (sort case) but quest sort with this id does not exist.",
-qinfo->GetQuestId(),qinfo->ZoneOrSort);
-// no changes, quest not dependent from this value but can have problems at client (note some may be 0, we must allow this so no check)
-}
-//check SkillOrClass value (class case).
-if (ClassByQuestSort(-int32(qinfo->ZoneOrSort)))
-{
-// SkillOrClass should not have class case when class case already set in ZoneOrSort.
-if (qinfo->SkillOrClassMask < 0)
-{
-sLog.outErrorDb("Quest %u has `ZoneOrSort` = %i (class sort case) and `SkillOrClassMask` = %i (class case), redundant.",
-qinfo->GetQuestId(),qinfo->ZoneOrSort,qinfo->SkillOrClassMask);
-}
-}
-//check for proper SkillOrClass value (skill case)
-if (int32 skill_id = SkillByQuestSort(-int32(qinfo->ZoneOrSort)))
-{
-// skill is positive value in SkillOrClass
-if (qinfo->SkillOrClassMask != skill_id)
-{
-sLog.outErrorDb("Quest %u has `ZoneOrSort` = %i (skill sort case) but `SkillOrClassMask` does not have a corresponding value (%i).",
-qinfo->GetQuestId(),qinfo->ZoneOrSort,skill_id);
-//override, and force proper value here?
-}
-}
-}
-
-// SkillOrClassMask (class case)
-if (qinfo->SkillOrClassMask < 0)
-{
-if (!(-int32(qinfo->SkillOrClassMask) & CLASSMASK_ALL_PLAYABLE))
-{
-sLog.outErrorDb("Quest %u has `SkillOrClassMask` = %i (class case) but classmask does not have valid class",
-qinfo->GetQuestId(),qinfo->SkillOrClassMask);
-}
-}
-// SkillOrClassMask (skill case)
-if (qinfo->SkillOrClassMask > 0)
-{
-if (!sSkillLineStore.LookupEntry(qinfo->SkillOrClassMask))
-{
-sLog.outErrorDb("Quest %u has `SkillOrClass` = %u (skill case) but skill (%i) does not exist",
-qinfo->GetQuestId(),qinfo->SkillOrClassMask,qinfo->SkillOrClassMask);
-}
-}
-
-if (qinfo->RequiredSkillValue)
-{
-if (qinfo->RequiredSkillValue > sWorld.GetConfigMaxSkillValue())
-{
-sLog.outErrorDb("Quest %u has `RequiredSkillValue` = %u but max possible skill is %u, quest can't be done.",
-qinfo->GetQuestId(),qinfo->RequiredSkillValue,sWorld.GetConfigMaxSkillValue());
-// no changes, quest can't be done for this requirement
-}
-
-if (qinfo->SkillOrClassMask <= 0)
-{
-sLog.outErrorDb("Quest %u has `RequiredSkillValue` = %u but `SkillOrClass` = %i (class case), value ignored.",
-qinfo->GetQuestId(),qinfo->RequiredSkillValue,qinfo->SkillOrClassMask);
-// no changes, quest can't be done for this requirement (fail at wrong skill id)
-}
-}
-// else Skill quests can have 0 skill level, this is ok
-
-if (qinfo->RepObjectiveFaction2 && !sFactionStore.LookupEntry(qinfo->RepObjectiveFaction2))
-{
-sLog.outErrorDb("Quest %u has `RepObjectiveFaction2` = %u but faction template %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),qinfo->RepObjectiveFaction2,qinfo->RepObjectiveFaction2);
-// no changes, quest can't be done for this requirement
-}
-
-if (qinfo->RepObjectiveFaction && !sFactionStore.LookupEntry(qinfo->RepObjectiveFaction))
-{
-sLog.outErrorDb("Quest %u has `RepObjectiveFaction` = %u but faction template %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),qinfo->RepObjectiveFaction,qinfo->RepObjectiveFaction);
-// no changes, quest can't be done for this requirement
-}
-
-if (qinfo->RequiredMinRepFaction && !sFactionStore.LookupEntry(qinfo->RequiredMinRepFaction))
-{
-sLog.outErrorDb("Quest %u has `RequiredMinRepFaction` = %u but faction template %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),qinfo->RequiredMinRepFaction,qinfo->RequiredMinRepFaction);
-// no changes, quest can't be done for this requirement
-}
-
-if (qinfo->RequiredMaxRepFaction && !sFactionStore.LookupEntry(qinfo->RequiredMaxRepFaction))
-{
-sLog.outErrorDb("Quest %u has `RequiredMaxRepFaction` = %u but faction template %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),qinfo->RequiredMaxRepFaction,qinfo->RequiredMaxRepFaction);
-// no changes, quest can't be done for this requirement
-}
-
-if (qinfo->RequiredMinRepValue && qinfo->RequiredMinRepValue > ReputationMgr::Reputation_Cap)
-{
-sLog.outErrorDb("Quest %u has `RequiredMinRepValue` = %d but max reputation is %u, quest can't be done.",
-qinfo->GetQuestId(),qinfo->RequiredMinRepValue,ReputationMgr::Reputation_Cap);
-// no changes, quest can't be done for this requirement
-}
-
-if (qinfo->RequiredMinRepValue && qinfo->RequiredMaxRepValue && qinfo->RequiredMaxRepValue <= qinfo->RequiredMinRepValue)
-{
-sLog.outErrorDb("Quest %u has `RequiredMaxRepValue` = %d and `RequiredMinRepValue` = %d, quest can't be done.",
-qinfo->GetQuestId(),qinfo->RequiredMaxRepValue,qinfo->RequiredMinRepValue);
-// no changes, quest can't be done for this requirement
-}
-
-if (!qinfo->RepObjectiveFaction && qinfo->RepObjectiveValue > 0)
-{
-sLog.outErrorDb("Quest %u has `RepObjectiveValue` = %d but `RepObjectiveFaction` is 0, value has no effect",
-qinfo->GetQuestId(),qinfo->RepObjectiveValue);
-// warning
-}
-
-if (!qinfo->RepObjectiveFaction2 && qinfo->RepObjectiveValue2 > 0)
-{
-sLog.outErrorDb("Quest %u has `RepObjectiveValue2` = %d but `RepObjectiveFaction2` is 0, value has no effect",
-qinfo->GetQuestId(),qinfo->RepObjectiveValue2);
-// warning
-}
-
-if (!qinfo->RequiredMinRepFaction && qinfo->RequiredMinRepValue > 0)
-{
-sLog.outErrorDb("Quest %u has `RequiredMinRepValue` = %d but `RequiredMinRepFaction` is 0, value has no effect",
-qinfo->GetQuestId(),qinfo->RequiredMinRepValue);
-// warning
-}
-
-if (!qinfo->RequiredMaxRepFaction && qinfo->RequiredMaxRepValue > 0)
-{
-sLog.outErrorDb("Quest %u has `RequiredMaxRepValue` = %d but `RequiredMaxRepFaction` is 0, value has no effect",
-qinfo->GetQuestId(),qinfo->RequiredMaxRepValue);
-// warning
-}
-
-if (qinfo->CharTitleId && !sCharTitlesStore.LookupEntry(qinfo->CharTitleId))
-{
-sLog.outErrorDb("Quest %u has `CharTitleId` = %u but CharTitle Id %u does not exist, quest can't be rewarded with title.",
-qinfo->GetQuestId(),qinfo->GetCharTitleId(),qinfo->GetCharTitleId());
-qinfo->CharTitleId = 0;
-// quest can't reward this title
-}
-
-if (qinfo->SrcItemId)
-{
-if (!sItemStorage.LookupEntry<ItemPrototype>(qinfo->SrcItemId))
-{
-sLog.outErrorDb("Quest %u has `SrcItemId` = %u but item with entry %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),qinfo->SrcItemId,qinfo->SrcItemId);
-qinfo->SrcItemId = 0; // quest can't be done for this requirement
-}
-else if (qinfo->SrcItemCount == 0)
-{
-sLog.outErrorDb("Quest %u has `SrcItemId` = %u but `SrcItemCount` = 0, set to 1 but need fix in DB.",
-qinfo->GetQuestId(),qinfo->SrcItemId);
-qinfo->SrcItemCount = 1; // update to 1 for allow quest work for backward compatibility with DB
-}
-}
-else if (qinfo->SrcItemCount>0)
-{
-sLog.outErrorDb("Quest %u has `SrcItemId` = 0 but `SrcItemCount` = %u, useless value.",
-qinfo->GetQuestId(),qinfo->SrcItemCount);
-qinfo->SrcItemCount=0; // no quest work changes in fact
-}
-
-if (qinfo->SrcSpell)
-{
-SpellEntry const* spellInfo = sSpellStore.LookupEntry(qinfo->SrcSpell);
-if (!spellInfo)
-{
-sLog.outErrorDb("Quest %u has `SrcSpell` = %u but spell %u doesn't exist, quest can't be done.",
-qinfo->GetQuestId(),qinfo->SrcSpell,qinfo->SrcSpell);
-qinfo->SrcSpell = 0; // quest can't be done for this requirement
-}
-else if (!SpellMgr::IsSpellValid(spellInfo))
-{
-sLog.outErrorDb("Quest %u has `SrcSpell` = %u but spell %u is broken, quest can't be done.",
-qinfo->GetQuestId(),qinfo->SrcSpell,qinfo->SrcSpell);
-qinfo->SrcSpell = 0; // quest can't be done for this requirement
-}
-}
-
-for (uint8 j = 0; j < QUEST_ITEM_OBJECTIVES_COUNT; ++j)
-{
-uint32 id = qinfo->ReqItemId[j];
-if (id)
-{
-if (qinfo->ReqItemCount[j] == 0)
-{
-sLog.outErrorDb("Quest %u has `ReqItemId%d` = %u but `ReqItemCount%d` = 0, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,j+1);
-// no changes, quest can't be done for this requirement
-}
-
-qinfo->SetFlag(QUEST_TRINITY_FLAGS_DELIVER);
-
-if (!sItemStorage.LookupEntry<ItemPrototype>(id))
-{
-sLog.outErrorDb("Quest %u has `ReqItemId%d` = %u but item with entry %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,id);
-qinfo->ReqItemCount[j] = 0; // prevent incorrect work of quest
-}
-}
-else if (qinfo->ReqItemCount[j]>0)
-{
-sLog.outErrorDb("Quest %u has `ReqItemId%d` = 0 but `ReqItemCount%d` = %u, quest can't be done.",
-qinfo->GetQuestId(),j+1,j+1,qinfo->ReqItemCount[j]);
-qinfo->ReqItemCount[j] = 0; // prevent incorrect work of quest
-}
-}
-
-for (uint8 j = 0; j < QUEST_SOURCE_ITEM_IDS_COUNT; ++j)
-{
-uint32 id = qinfo->ReqSourceId[j];
-if (id)
-{
-if (!sItemStorage.LookupEntry<ItemPrototype>(id))
-{
-sLog.outErrorDb("Quest %u has `ReqSourceId%d` = %u but item with entry %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,id);
-// no changes, quest can't be done for this requirement
-}
-}
-else
-{
-if (qinfo->ReqSourceCount[j]>0)
-{
-sLog.outErrorDb("Quest %u has `ReqSourceId%d` = 0 but `ReqSourceCount%d` = %u.",
-qinfo->GetQuestId(),j+1,j+1,qinfo->ReqSourceCount[j]);
-// no changes, quest ignore this data
-}
-}
-}
-
-for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
-{
-uint32 id = qinfo->ReqSpell[j];
-if (id)
-{
-SpellEntry const* spellInfo = sSpellStore.LookupEntry(id);
-if (!spellInfo)
-{
-sLog.outErrorDb("Quest %u has `ReqSpellCast%d` = %u but spell %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,id);
-continue;
-}
-
-if (!qinfo->ReqCreatureOrGOId[j])
-{
-bool found = false;
-for (uint8 k = 0; k < MAX_SPELL_EFFECTS; ++k)
-{
-if ((spellInfo->Effect[k] == SPELL_EFFECT_QUEST_COMPLETE && uint32(spellInfo->EffectMiscValue[k]) == qinfo->QuestId) ||
-spellInfo->Effect[k] == SPELL_EFFECT_SEND_EVENT)
-{
-found = true;
-break;
-}
-}
-
-if (found)
-{
-if (!qinfo->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
-{
-sLog.outErrorDb("Spell (id: %u) have SPELL_EFFECT_QUEST_COMPLETE or SPELL_EFFECT_SEND_EVENT for quest %u and ReqCreatureOrGOId%d = 0, but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT. Quest flags or ReqCreatureOrGOId%d must be fixed, quest modified to enable objective.",spellInfo->Id,qinfo->QuestId,j+1,j+1);
-
-// this will prevent quest completing without objective
-const_cast<Quest*>(qinfo)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
-}
-}
-else
-{
-sLog.outErrorDb("Quest %u has `ReqSpellCast%d` = %u and ReqCreatureOrGOId%d = 0 but spell %u does not have SPELL_EFFECT_QUEST_COMPLETE or SPELL_EFFECT_SEND_EVENT effect for this quest, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,j+1,id);
-// no changes, quest can't be done for this requirement
-}
-}
-}
-}
-
-for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
-{
-int32 id = qinfo->ReqCreatureOrGOId[j];
-if (id < 0 && !sGOStorage.LookupEntry<GameObjectInfo>(-id))
-{
-sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = %i but gameobject %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,uint32(-id));
-qinfo->ReqCreatureOrGOId[j] = 0; // quest can't be done for this requirement
-}
-
-if (id > 0 && !sCreatureStorage.LookupEntry<CreatureInfo>(id))
-{
-sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = %i but creature with entry %u does not exist, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,uint32(id));
-qinfo->ReqCreatureOrGOId[j] = 0; // quest can't be done for this requirement
-}
-
-if (id)
-{
-// In fact SpeakTo and Kill are quite same: either you can speak to mob:SpeakTo or you can't:Kill/Cast
-
-qinfo->SetFlag(QUEST_TRINITY_FLAGS_KILL_OR_CAST | QUEST_TRINITY_FLAGS_SPEAKTO);
-
-if (!qinfo->ReqCreatureOrGOCount[j])
-{
-sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = %u but `ReqCreatureOrGOCount%d` = 0, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,j+1);
-// no changes, quest can be incorrectly done, but we already report this
-}
-}
-else if (qinfo->ReqCreatureOrGOCount[j]>0)
-{
-sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = 0 but `ReqCreatureOrGOCount%d` = %u.",
-qinfo->GetQuestId(),j+1,j+1,qinfo->ReqCreatureOrGOCount[j]);
-// no changes, quest ignore this data
-}
-}
-
-for (uint8 j = 0; j < QUEST_REWARD_CHOICES_COUNT; ++j)
-{
-uint32 id = qinfo->RewChoiceItemId[j];
-if (id)
-{
-if (!sItemStorage.LookupEntry<ItemPrototype>(id))
-{
-sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = %u but item with entry %u does not exist, quest will not reward this item.",
-qinfo->GetQuestId(),j+1,id,id);
-qinfo->RewChoiceItemId[j] = 0; // no changes, quest will not reward this
-}
-
-if (!qinfo->RewChoiceItemCount[j])
-{
-sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = %u but `RewChoiceItemCount%d` = 0, quest can't be done.",
-qinfo->GetQuestId(),j+1,id,j+1);
-// no changes, quest can't be done
-}
-}
-else if (qinfo->RewChoiceItemCount[j]>0)
-{
-sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = 0 but `RewChoiceItemCount%d` = %u.",
-qinfo->GetQuestId(),j+1,j+1,qinfo->RewChoiceItemCount[j]);
-// no changes, quest ignore this data
-}
-}
-
-for (uint8 j = 0; j < QUEST_REWARDS_COUNT; ++j)
-{
-uint32 id = qinfo->RewItemId[j];
-if (id)
-{
-if (!sItemStorage.LookupEntry<ItemPrototype>(id))
-{
-sLog.outErrorDb("Quest %u has `RewItemId%d` = %u but item with entry %u does not exist, quest will not reward this item.",
-qinfo->GetQuestId(),j+1,id,id);
-qinfo->RewItemId[j] = 0; // no changes, quest will not reward this item
-}
-
-if (!qinfo->RewItemCount[j])
-{
-sLog.outErrorDb("Quest %u has `RewItemId%d` = %u but `RewItemCount%d` = 0, quest will not reward this item.",
-qinfo->GetQuestId(),j+1,id,j+1);
-// no changes
-}
-}
-else if (qinfo->RewItemCount[j]>0)
-{
-sLog.outErrorDb("Quest %u has `RewItemId%d` = 0 but `RewItemCount%d` = %u.",
-qinfo->GetQuestId(),j+1,j+1,qinfo->RewItemCount[j]);
-// no changes, quest ignore this data
-}
-}
-
-for (uint8 j = 0; j < QUEST_REPUTATIONS_COUNT; ++j)
-{
-if (qinfo->RewRepFaction[j])
-{
-if (abs(qinfo->RewRepValueId[j]) > 9)
-{
-sLog.outErrorDb("Quest %u has RewRepValueId%d = %i. That is outside the range of valid values (-9 to 9).", qinfo->GetQuestId(), j+1, qinfo->RewRepValueId[j]);
-}
-if (!sFactionStore.LookupEntry(qinfo->RewRepFaction[j]))
-{
-sLog.outErrorDb("Quest %u has `RewRepFaction%d` = %u but raw faction (faction.dbc) %u does not exist, quest will not reward reputation for this faction.", qinfo->GetQuestId(),j+1,qinfo->RewRepFaction[j] ,qinfo->RewRepFaction[j]);
-qinfo->RewRepFaction[j] = 0; // quest will not reward this
-}
-}
-
-
-else if (qinfo->RewRepValue[j] != 0)
-{
-sLog.outErrorDb("Quest %u has `RewRepFaction%d` = 0 but `RewRepValue%d` = %i.",
-qinfo->GetQuestId(),j+1,j+1,qinfo->RewRepValue[j]);
-// no changes, quest ignore this data
-}
-}
-
-
-if (qinfo->RewSpell)
-{
-SpellEntry const* spellInfo = sSpellStore.LookupEntry(qinfo->RewSpell);
-
-if (!spellInfo)
-{
-sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u does not exist, spell removed as display reward.",
-qinfo->GetQuestId(),qinfo->RewSpell,qinfo->RewSpell);
-qinfo->RewSpell = 0; // no spell reward will display for this quest
-}
-
-else if (!SpellMgr::IsSpellValid(spellInfo))
-{
-sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u is broken, quest will not have a spell reward.",
-qinfo->GetQuestId(),qinfo->RewSpell,qinfo->RewSpell);
-qinfo->RewSpell = 0; // no spell reward will display for this quest
-}
-
-else if (GetTalentSpellCost(qinfo->RewSpell))
-{
-sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u is talent, quest will not have a spell reward.",
-qinfo->GetQuestId(),qinfo->RewSpell,qinfo->RewSpell);
-qinfo->RewSpell = 0; // no spell reward will display for this quest
-}
-}
-
-if (qinfo->RewSpellCast > 0)
-{
-SpellEntry const* spellInfo = sSpellStore.LookupEntry(qinfo->RewSpellCast);
-
-if (!spellInfo)
-{
-sLog.outErrorDb("Quest %u has `RewSpellCast` = %u but spell %u does not exist, quest will not have a spell reward.",
-qinfo->GetQuestId(),qinfo->RewSpellCast,qinfo->RewSpellCast);
-qinfo->RewSpellCast = 0; // no spell will be casted on player
-}
-
-else if (!SpellMgr::IsSpellValid(spellInfo))
-{
-sLog.outErrorDb("Quest %u has `RewSpellCast` = %u but spell %u is broken, quest will not have a spell reward.",
-qinfo->GetQuestId(),qinfo->RewSpellCast,qinfo->RewSpellCast);
-qinfo->RewSpellCast = 0; // no spell will be casted on player
-}
-
-else if (GetTalentSpellCost(qinfo->RewSpellCast))
-{
-sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u is talent, quest will not have a spell reward.",
-qinfo->GetQuestId(),qinfo->RewSpellCast,qinfo->RewSpellCast);
-qinfo->RewSpellCast = 0; // no spell will be casted on player
-}
-}
-
-if (qinfo->RewMailTemplateId)
-{
-if (!sMailTemplateStore.LookupEntry(qinfo->RewMailTemplateId))
-{
-sLog.outErrorDb("Quest %u has `RewMailTemplateId` = %u but mail template %u does not exist, quest will not have a mail reward.",
-qinfo->GetQuestId(),qinfo->RewMailTemplateId,qinfo->RewMailTemplateId);
-qinfo->RewMailTemplateId = 0; // no mail will send to player
-qinfo->RewMailDelaySecs = 0; // no mail will send to player
-}
-else if (usedMailTemplates.find(qinfo->RewMailTemplateId) != usedMailTemplates.end())
-{
-std::map<uint32,uint32>::const_iterator used_mt_itr = usedMailTemplates.find(qinfo->RewMailTemplateId);
-sLog.outErrorDb("Quest %u has `RewMailTemplateId` = %u but mail template %u already used for quest %u, quest will not have a mail reward.",
-qinfo->GetQuestId(),qinfo->RewMailTemplateId,qinfo->RewMailTemplateId,used_mt_itr->second);
-qinfo->RewMailTemplateId = 0; // no mail will send to player
-qinfo->RewMailDelaySecs = 0; // no mail will send to player
-}
-else
-usedMailTemplates[qinfo->RewMailTemplateId] = qinfo->GetQuestId();
-}
-
-if (qinfo->NextQuestInChain)
-{
-QuestMap::iterator qNextItr = mQuestTemplates.find(qinfo->NextQuestInChain);
-if (qNextItr == mQuestTemplates.end())
-{
-sLog.outErrorDb("Quest %u has `NextQuestInChain` = %u but quest %u does not exist, quest chain will not work.",
-qinfo->GetQuestId(),qinfo->NextQuestInChain ,qinfo->NextQuestInChain);
-qinfo->NextQuestInChain = 0;
-}
-else
-qNextItr->second->prevChainQuests.push_back(qinfo->GetQuestId());
-}
-
-// fill additional data stores
-if (qinfo->PrevQuestId)
-{
-if (mQuestTemplates.find(abs(qinfo->GetPrevQuestId())) == mQuestTemplates.end())
-{
-sLog.outErrorDb("Quest %d has PrevQuestId %i, but no such quest", qinfo->GetQuestId(), qinfo->GetPrevQuestId());
-}
-else
-{
-qinfo->prevQuests.push_back(qinfo->PrevQuestId);
-}
-}
-
-if (qinfo->NextQuestId)
-{
-QuestMap::iterator qNextItr = mQuestTemplates.find(abs(qinfo->GetNextQuestId()));
-if (qNextItr == mQuestTemplates.end())
-{
-sLog.outErrorDb("Quest %d has NextQuestId %i, but no such quest", qinfo->GetQuestId(), qinfo->GetNextQuestId());
-}
-else
-{
-int32 signedQuestId = qinfo->NextQuestId < 0 ? -int32(qinfo->GetQuestId()) : int32(qinfo->GetQuestId());
-qNextItr->second->prevQuests.push_back(signedQuestId);
-}
-}
-
-if (qinfo->ExclusiveGroup)
-mExclusiveQuestGroups.insert(std::pair<int32, uint32>(qinfo->ExclusiveGroup, qinfo->GetQuestId()));
-if (qinfo->LimitTime)
-qinfo->SetFlag(QUEST_TRINITY_FLAGS_TIMED);
-}
-
-// check QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT for spell with SPELL_EFFECT_QUEST_COMPLETE
-for (uint32 i = 0; i < sSpellStore.GetNumRows(); ++i)
-{
-SpellEntry const *spellInfo = sSpellStore.LookupEntry(i);
-if (!spellInfo)
-continue;
-
-for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-{
-if (spellInfo->Effect[j] != SPELL_EFFECT_QUEST_COMPLETE)
-continue;
-
-uint32 quest_id = spellInfo->EffectMiscValue[j];
-
-Quest const* quest = GetQuestTemplate(quest_id);
-
-// some quest referenced in spells not exist (outdated spells)
-if (!quest)
-continue;
-
-if (!quest->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
-{
-sLog.outErrorDb("Spell (id: %u) have SPELL_EFFECT_QUEST_COMPLETE for quest %u , but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT. Quest flags must be fixed, quest modified to enable objective.",spellInfo->Id,quest_id);
-
-// this will prevent quest completing without objective
-const_cast<Quest*>(quest)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
-}
-}
-}
-
-sLog.outString();
-sLog.outString(">> Loaded %lu quests definitions", (unsigned long)mQuestTemplates.size());
-}
-
-void ObjectMgr::LoadQuestLocales()
-{
-mQuestLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT entry,"
-"Title_loc1,Details_loc1,Objectives_loc1,OfferRewardText_loc1,RequestItemsText_loc1,EndText_loc1,CompletedText_loc1,ObjectiveText1_loc1,ObjectiveText2_loc1,ObjectiveText3_loc1,ObjectiveText4_loc1,"
-"Title_loc2,Details_loc2,Objectives_loc2,OfferRewardText_loc2,RequestItemsText_loc2,EndText_loc2,CompletedText_loc2,ObjectiveText1_loc2,ObjectiveText2_loc2,ObjectiveText3_loc2,ObjectiveText4_loc2,"
-"Title_loc3,Details_loc3,Objectives_loc3,OfferRewardText_loc3,RequestItemsText_loc3,EndText_loc3,CompletedText_loc3,ObjectiveText1_loc3,ObjectiveText2_loc3,ObjectiveText3_loc3,ObjectiveText4_loc3,"
-"Title_loc4,Details_loc4,Objectives_loc4,OfferRewardText_loc4,RequestItemsText_loc4,EndText_loc4,CompletedText_loc4,ObjectiveText1_loc4,ObjectiveText2_loc4,ObjectiveText3_loc4,ObjectiveText4_loc4,"
-"Title_loc5,Details_loc5,Objectives_loc5,OfferRewardText_loc5,RequestItemsText_loc5,EndText_loc5,CompletedText_loc5,ObjectiveText1_loc5,ObjectiveText2_loc5,ObjectiveText3_loc5,ObjectiveText4_loc5,"
-"Title_loc6,Details_loc6,Objectives_loc6,OfferRewardText_loc6,RequestItemsText_loc6,EndText_loc6,CompletedText_loc6,ObjectiveText1_loc6,ObjectiveText2_loc6,ObjectiveText3_loc6,ObjectiveText4_loc6,"
-"Title_loc7,Details_loc7,Objectives_loc7,OfferRewardText_loc7,RequestItemsText_loc7,EndText_loc7,CompletedText_loc7,ObjectiveText1_loc7,ObjectiveText2_loc7,ObjectiveText3_loc7,ObjectiveText4_loc7,"
-"Title_loc8,Details_loc8,Objectives_loc8,OfferRewardText_loc8,RequestItemsText_loc8,EndText_loc8,CompletedText_loc8,ObjectiveText1_loc8,ObjectiveText2_loc8,ObjectiveText3_loc8,ObjectiveText4_loc8"
-" FROM locales_quest"
-);
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-QuestLocale& data = mQuestLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-LocaleConstant locale = (LocaleConstant) i;
-std::string str = fields[1 + 11 * (i - 1)].GetString();
-AddLocaleString(str, locale, data.Title);
-
-str = fields[1 + 11 * (i - 1) + 1].GetString();
-AddLocaleString(str, locale, data.Details);
-
-str = fields[1 + 11 * (i - 1) + 2].GetString();
-AddLocaleString(str, locale, data.Objectives);
-
-str = fields[1 + 11 * (i - 1) + 3].GetString();
-AddLocaleString(str, locale, data.OfferRewardText);
-
-str = fields[1 + 11 * (i - 1) + 4].GetString();
-AddLocaleString(str, locale, data.RequestItemsText);
-
-str = fields[1 + 11 * (i - 1) + 5].GetString();
-AddLocaleString(str, locale, data.EndText);
-
-str = fields[1 + 11 * (i - 1) + 6].GetString();
-AddLocaleString(str, locale, data.CompletedText);
-
-for (uint8 k = 0; k < 4; ++k)
-{
-str = fields[1 + 11 * (i - 1) + 7 + k].GetString();
-AddLocaleString(str, locale, data.ObjectiveText[k]);
-}
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu Quest locale strings", (unsigned long)mQuestLocaleMap.size());
-}
-
-void ObjectMgr::LoadScripts(ScriptsType type)
-{
-ScriptMapMap *scripts = GetScriptsMapByType(type);
-if (!scripts)
-return;
-
-std::string tableName = GetScriptsTableNameByType(type);
-if (tableName.empty())
-return;
-
-if (sWorld.IsScriptScheduled()) // function don't must be called in time scripts use.
-return;
-
-sLog.outString("%s :", tableName.c_str());
-
-scripts->clear(); // need for reload support
-
-bool isSpellScriptTable = (type == SCRIPTS_SPELL);
-char buff[125];
-sprintf(buff, "SELECT id,delay,command,datalong,datalong2,dataint,x,y,z,o%s FROM %s", isSpellScriptTable ? ",effIndex" : "", tableName.c_str());
-QueryResult result = WorldDatabase.Query(buff);
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u script definitions", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-ScriptInfo tmp;
-tmp.type = type;
-tmp.id = fields[0].GetUInt32();
-if (isSpellScriptTable)
-tmp.id |= fields[10].GetUInt8() << 24;
-tmp.delay = fields[1].GetUInt32();
-tmp.command = ScriptCommands(fields[2].GetUInt32());
-tmp.Raw.nData[0] = fields[3].GetUInt32();
-tmp.Raw.nData[1] = fields[4].GetUInt32();
-tmp.Raw.nData[2] = fields[5].GetInt32();
-tmp.Raw.fData[0] = fields[6].GetFloat();
-tmp.Raw.fData[1] = fields[7].GetFloat();
-tmp.Raw.fData[2] = fields[8].GetFloat();
-tmp.Raw.fData[3] = fields[9].GetFloat();
-
-// generic command args check
-switch (tmp.command)
-{
-case SCRIPT_COMMAND_TALK:
-{
-if (tmp.Talk.ChatType > CHAT_TYPE_WHISPER && tmp.Talk.ChatType != CHAT_MSG_RAID_BOSS_WHISPER)
-{
-sLog.outErrorDb("Table `%s` has invalid talk type (datalong = %u) in SCRIPT_COMMAND_TALK for script id %u",
-tableName.c_str(), tmp.Talk.ChatType, tmp.id);
-continue;
-}
-if (!tmp.Talk.TextID)
-{
-sLog.outErrorDb("Table `%s` has invalid talk text id (dataint = %i) in SCRIPT_COMMAND_TALK for script id %u",
-tableName.c_str(), tmp.Talk.TextID, tmp.id);
-continue;
-}
-if (tmp.Talk.TextID < MIN_DB_SCRIPT_STRING_ID || tmp.Talk.TextID >= MAX_DB_SCRIPT_STRING_ID)
-{
-sLog.outErrorDb("Table `%s` has out of range text id (dataint = %i expected %u-%u) in SCRIPT_COMMAND_TALK for script id %u",
-tableName.c_str(), tmp.Talk.TextID, MIN_DB_SCRIPT_STRING_ID, MAX_DB_SCRIPT_STRING_ID, tmp.id);
-continue;
-}
-
-break;
-}
-
-case SCRIPT_COMMAND_EMOTE:
-{
-if (!sEmotesStore.LookupEntry(tmp.Emote.EmoteID))
-{
-sLog.outErrorDb("Table `%s` has invalid emote id (datalong = %u) in SCRIPT_COMMAND_EMOTE for script id %u",
-tableName.c_str(), tmp.Emote.EmoteID, tmp.id);
-continue;
-}
-break;
-}
-
-case SCRIPT_COMMAND_TELEPORT_TO:
-{
-if (!sMapStore.LookupEntry(tmp.TeleportTo.MapID))
-{
-sLog.outErrorDb("Table `%s` has invalid map (Id: %u) in SCRIPT_COMMAND_TELEPORT_TO for script id %u",
-tableName.c_str(), tmp.TeleportTo.MapID, tmp.id);
-continue;
-}
-
-if (!Trinity::IsValidMapCoord(tmp.TeleportTo.DestX, tmp.TeleportTo.DestY, tmp.TeleportTo.DestZ, tmp.TeleportTo.Orientation))
-{
-sLog.outErrorDb("Table `%s` has invalid coordinates (X: %f Y: %f Z: %f O: %f) in SCRIPT_COMMAND_TELEPORT_TO for script id %u",
-tableName.c_str(), tmp.TeleportTo.DestX, tmp.TeleportTo.DestY, tmp.TeleportTo.DestZ, tmp.TeleportTo.Orientation, tmp.id);
-continue;
-}
-break;
-}
-
-case SCRIPT_COMMAND_QUEST_EXPLORED:
-{
-Quest const* quest = GetQuestTemplate(tmp.QuestExplored.QuestID);
-if (!quest)
-{
-sLog.outErrorDb("Table `%s` has invalid quest (ID: %u) in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u",
-tableName.c_str(), tmp.QuestExplored.QuestID, tmp.id);
-continue;
-}
-
-if (!quest->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
-{
-sLog.outErrorDb("Table `%s` has quest (ID: %u) in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u, but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT in quest flags. Script command or quest flags wrong. Quest modified to require objective.",
-tableName.c_str(), tmp.QuestExplored.QuestID, tmp.id);
-
-// this will prevent quest completing without objective
-const_cast<Quest*>(quest)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
-
-// continue; - quest objective requirement set and command can be allowed
-}
-
-if (float(tmp.QuestExplored.Distance) > DEFAULT_VISIBILITY_DISTANCE)
-{
-sLog.outErrorDb("Table `%s` has too large distance (%u) for exploring objective complete in `datalong2` in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u",
-tableName.c_str(), tmp.QuestExplored.Distance, tmp.id);
-continue;
-}
-
-if (tmp.QuestExplored.Distance && float(tmp.QuestExplored.Distance) > DEFAULT_VISIBILITY_DISTANCE)
-{
-sLog.outErrorDb("Table `%s` has too large distance (%u) for exploring objective complete in `datalong2` in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u, max distance is %f or 0 for disable distance check",
-tableName.c_str(), tmp.QuestExplored.Distance, tmp.id, DEFAULT_VISIBILITY_DISTANCE);
-continue;
-}
-
-if (tmp.QuestExplored.Distance && float(tmp.QuestExplored.Distance) < INTERACTION_DISTANCE)
-{
-sLog.outErrorDb("Table `%s` has too small distance (%u) for exploring objective complete in `datalong2` in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u, min distance is %f or 0 for disable distance check",
-tableName.c_str(), tmp.QuestExplored.Distance, tmp.id, INTERACTION_DISTANCE);
-continue;
-}
-
-break;
-}
-
-case SCRIPT_COMMAND_KILL_CREDIT:
-{
-if (!GetCreatureTemplate(tmp.KillCredit.CreatureEntry))
-{
-sLog.outErrorDb("Table `%s` has invalid creature (Entry: %u) in SCRIPT_COMMAND_KILL_CREDIT for script id %u",
-tableName.c_str(), tmp.KillCredit.CreatureEntry, tmp.id);
-continue;
-}
-break;
-}
-
-case SCRIPT_COMMAND_RESPAWN_GAMEOBJECT:
-{
-GameObjectData const* data = GetGOData(tmp.RespawnGameobject.GOGuid);
-if (!data)
-{
-sLog.outErrorDb("Table `%s` has invalid gameobject (GUID: %u) in SCRIPT_COMMAND_RESPAWN_GAMEOBJECT for script id %u",
-tableName.c_str(), tmp.RespawnGameobject.GOGuid, tmp.id);
-continue;
-}
-
-GameObjectInfo const* info = GetGameObjectInfo(data->id);
-if (!info)
-{
-sLog.outErrorDb("Table `%s` has gameobject with invalid entry (GUID: %u Entry: %u) in SCRIPT_COMMAND_RESPAWN_GAMEOBJECT for script id %u",
-tableName.c_str(), tmp.RespawnGameobject.GOGuid, data->id, tmp.id);
-continue;
-}
-
-if (info->type == GAMEOBJECT_TYPE_FISHINGNODE ||
-info->type == GAMEOBJECT_TYPE_FISHINGHOLE ||
-info->type == GAMEOBJECT_TYPE_DOOR ||
-info->type == GAMEOBJECT_TYPE_BUTTON ||
-info->type == GAMEOBJECT_TYPE_TRAP)
-{
-sLog.outErrorDb("Table `%s` have gameobject type (%u) unsupported by command SCRIPT_COMMAND_RESPAWN_GAMEOBJECT for script id %u",
-tableName.c_str(), info->id, tmp.id);
-continue;
-}
-break;
-}
-
-case SCRIPT_COMMAND_TEMP_SUMMON_CREATURE:
-{
-if (!Trinity::IsValidMapCoord(tmp.TempSummonCreature.PosX, tmp.TempSummonCreature.PosY, tmp.TempSummonCreature.PosZ, tmp.TempSummonCreature.Orientation))
-{
-sLog.outErrorDb("Table `%s` has invalid coordinates (X: %f Y: %f Z: %f O: %f) in SCRIPT_COMMAND_TEMP_SUMMON_CREATURE for script id %u",
-tableName.c_str(), tmp.TempSummonCreature.PosX, tmp.TempSummonCreature.PosY, tmp.TempSummonCreature.PosZ, tmp.TempSummonCreature.Orientation, tmp.id);
-continue;
-}
-
-if (!GetCreatureTemplate(tmp.TempSummonCreature.CreatureEntry))
-{
-sLog.outErrorDb("Table `%s` has invalid creature (Entry: %u) in SCRIPT_COMMAND_TEMP_SUMMON_CREATURE for script id %u",
-tableName.c_str(), tmp.TempSummonCreature.CreatureEntry, tmp.id);
-continue;
-}
-break;
-}
-
-case SCRIPT_COMMAND_OPEN_DOOR:
-case SCRIPT_COMMAND_CLOSE_DOOR:
-{
-GameObjectData const* data = GetGOData(tmp.ToggleDoor.GOGuid);
-if (!data)
-{
-sLog.outErrorDb("Table `%s` has invalid gameobject (GUID: %u) in %s for script id %u",
-tableName.c_str(), tmp.ToggleDoor.GOGuid, GetScriptCommandName(tmp.command).c_str(), tmp.id);
-continue;
-}
-
-GameObjectInfo const* info = GetGameObjectInfo(data->id);
-if (!info)
-{
-sLog.outErrorDb("Table `%s` has gameobject with invalid entry (GUID: %u Entry: %u) in %s for script id %u",
-tableName.c_str(), tmp.ToggleDoor.GOGuid, data->id, GetScriptCommandName(tmp.command).c_str(), tmp.id);
-continue;
-}
-
-if (info->type != GAMEOBJECT_TYPE_DOOR)
-{
-sLog.outErrorDb("Table `%s` has gameobject type (%u) non supported by command %s for script id %u",
-tableName.c_str(), info->id, GetScriptCommandName(tmp.command).c_str(), tmp.id);
-continue;
-}
-
-break;
-}
-
-case SCRIPT_COMMAND_REMOVE_AURA:
-{
-if (!sSpellStore.LookupEntry(tmp.RemoveAura.SpellID))
-{
-sLog.outErrorDb("Table `%s` using non-existent spell (id: %u) in SCRIPT_COMMAND_REMOVE_AURA for script id %u",
-tableName.c_str(), tmp.RemoveAura.SpellID, tmp.id);
-continue;
-}
-if (tmp.RemoveAura.Flags & ~0x1) // 1 bits (0,1)
-{
-sLog.outErrorDb("Table `%s` using unknown flags in datalong2 (%u) in SCRIPT_COMMAND_REMOVE_AURA for script id %u",
-tableName.c_str(), tmp.RemoveAura.Flags, tmp.id);
-continue;
-}
-break;
-}
-
-case SCRIPT_COMMAND_CAST_SPELL:
-{
-if (!sSpellStore.LookupEntry(tmp.CastSpell.SpellID))
-{
-sLog.outErrorDb("Table `%s` using non-existent spell (id: %u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
-tableName.c_str(), tmp.CastSpell.SpellID, tmp.id);
-continue;
-}
-if (tmp.CastSpell.Flags > 4) // targeting type
-{
-sLog.outErrorDb("Table `%s` using unknown target in datalong2 (%u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
-tableName.c_str(), tmp.CastSpell.Flags, tmp.id);
-continue;
-}
-if (tmp.CastSpell.Flags != 4 && tmp.CastSpell.CreatureEntry & ~0x1) // 1 bit (0,1)
-{
-sLog.outErrorDb("Table `%s` using unknown flags in dataint (%u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
-tableName.c_str(), tmp.CastSpell.CreatureEntry, tmp.id);
-continue;
-}
-else if (tmp.CastSpell.Flags == 4 && !GetCreatureTemplate(tmp.CastSpell.CreatureEntry))
-{
-sLog.outErrorDb("Table `%s` using invalid creature entry in dataint (%u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
-tableName.c_str(), tmp.CastSpell.CreatureEntry, tmp.id);
-continue;
-}
-break;
-}
-
-case SCRIPT_COMMAND_CREATE_ITEM:
-{
-if (!GetItemPrototype(tmp.CreateItem.ItemEntry))
-{
-sLog.outErrorDb("Table `%s` has nonexistent item (entry: %u) in SCRIPT_COMMAND_CREATE_ITEM for script id %u",
-tableName.c_str(), tmp.CreateItem.ItemEntry, tmp.id);
-continue;
-}
-if (!tmp.CreateItem.Amount)
-{
-sLog.outErrorDb("Table `%s` SCRIPT_COMMAND_CREATE_ITEM but amount is %u for script id %u",
-tableName.c_str(), tmp.CreateItem.Amount, tmp.id);
-continue;
-}
-break;
-}
-default:
-break;
-}
-
-if (scripts->find(tmp.id) == scripts->end())
-{
-ScriptMap emptyMap;
-(*scripts)[tmp.id] = emptyMap;
-}
-(*scripts)[tmp.id].insert(std::pair<uint32, ScriptInfo>(tmp.delay, tmp));
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u script definitions", count);
-}
-
-void ObjectMgr::LoadGameObjectScripts()
-{
-LoadScripts(SCRIPTS_GAMEOBJECT);
-
-// check ids
-for (ScriptMapMap::const_iterator itr = sGameObjectScripts.begin(); itr != sGameObjectScripts.end(); ++itr)
-{
-if (!GetGOData(itr->first))
-sLog.outErrorDb("Table `gameobject_scripts` has not existing gameobject (GUID: %u) as script id",itr->first);
-}
-}
-
-void ObjectMgr::LoadQuestEndScripts()
-{
-LoadScripts(SCRIPTS_QUEST_END);
-
-// check ids
-for (ScriptMapMap::const_iterator itr = sQuestEndScripts.begin(); itr != sQuestEndScripts.end(); ++itr)
-{
-if (!GetQuestTemplate(itr->first))
-sLog.outErrorDb("Table `quest_end_scripts` has not existing quest (Id: %u) as script id",itr->first);
-}
-}
-
-void ObjectMgr::LoadQuestStartScripts()
-{
-LoadScripts(SCRIPTS_QUEST_START);
-
-// check ids
-for (ScriptMapMap::const_iterator itr = sQuestStartScripts.begin(); itr != sQuestStartScripts.end(); ++itr)
-{
-if (!GetQuestTemplate(itr->first))
-sLog.outErrorDb("Table `quest_start_scripts` has not existing quest (Id: %u) as script id",itr->first);
-}
-}
-
-void ObjectMgr::LoadSpellScripts()
-{
-LoadScripts(SCRIPTS_SPELL);
-
-// check ids
-for (ScriptMapMap::const_iterator itr = sSpellScripts.begin(); itr != sSpellScripts.end(); ++itr)
-{
-uint32 spellId = uint32(itr->first) & 0x00FFFFFF;
-SpellEntry const* spellInfo = sSpellStore.LookupEntry(spellId);
-
-if (!spellInfo)
-{
-sLog.outErrorDb("Table `spell_scripts` has not existing spell (Id: %u) as script id", spellId);
-continue;
-}
-
-uint8 i = (uint8)((uint32(itr->first) >> 24) & 0x000000FF);
-//check for correct spellEffect
-if (!spellInfo->Effect[i] || (spellInfo->Effect[i] != SPELL_EFFECT_SCRIPT_EFFECT && spellInfo->Effect[i] != SPELL_EFFECT_DUMMY))
-sLog.outErrorDb("Table `spell_scripts` - spell %u effect %u is not SPELL_EFFECT_SCRIPT_EFFECT or SPELL_EFFECT_DUMMY", spellId, i);
-}
-}
-
-void ObjectMgr::LoadEventScripts()
-{
-LoadScripts(SCRIPTS_EVENT);
-
-std::set<uint32> evt_scripts;
-// Load all possible script entries from gameobjects
-for (uint32 i = 1; i < sGOStorage.MaxEntry; ++i)
-{
-if (GameObjectInfo const * goInfo = sGOStorage.LookupEntry<GameObjectInfo>(i))
-if (uint32 eventId = goInfo->GetEventScriptId())
-evt_scripts.insert(eventId);
-}
-// Load all possible script entries from spells
-for (uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
-{
-SpellEntry const * spell = sSpellStore.LookupEntry(i);
-if (spell)
-{
-for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-{
-if (spell->Effect[j] == SPELL_EFFECT_SEND_EVENT)
-{
-if (spell->EffectMiscValue[j])
-evt_scripts.insert(spell->EffectMiscValue[j]);
-}
-}
-}
-}
-
-for(size_t path_idx = 0; path_idx < sTaxiPathNodesByPath.size(); ++path_idx)
-{
-for(size_t node_idx = 0; node_idx < sTaxiPathNodesByPath[path_idx].size(); ++node_idx)
-{
-TaxiPathNodeEntry const& node = sTaxiPathNodesByPath[path_idx][node_idx];
-
-if (node.arrivalEventID)
-evt_scripts.insert(node.arrivalEventID);
-
-if (node.departureEventID)
-evt_scripts.insert(node.departureEventID);
-}
-}
-
-// Then check if all scripts are in above list of possible script entries
-for (ScriptMapMap::const_iterator itr = sEventScripts.begin(); itr != sEventScripts.end(); ++itr)
-{
-std::set<uint32>::const_iterator itr2 = evt_scripts.find(itr->first);
-if (itr2 == evt_scripts.end())
-sLog.outErrorDb("Table `event_scripts` has script (Id: %u) not referring to any gameobject_template type 10 data2 field, type 3 data6 field, type 13 data 2 field or any spell effect %u",
-itr->first, SPELL_EFFECT_SEND_EVENT);
-}
-}
-
-//Load WP Scripts
-void ObjectMgr::LoadWaypointScripts()
-{
-LoadScripts(SCRIPTS_WAYPOINT);
-
-std::set<uint32> actionSet;
-
-for (ScriptMapMap::const_iterator itr = sWaypointScripts.begin(); itr != sWaypointScripts.end(); ++itr)
-actionSet.insert(itr->first);
-
-QueryResult result = WorldDatabase.PQuery("SELECT DISTINCT(`action`) FROM waypoint_data");
-if (result)
-{
-do
-{
-Field *fields = result->Fetch();
-uint32 action = fields[0].GetUInt32();
-
-actionSet.erase(action);
-
-} while (result->NextRow());
-}
-
-for (std::set<uint32>::iterator itr = actionSet.begin(); itr != actionSet.end(); ++itr)
-sLog.outErrorDb("There is no waypoint which links to the waypoint script %u", *itr);
-}
-
-void ObjectMgr::LoadSpellScriptNames()
-{
-mSpellScripts.clear(); // need for reload case
-QueryResult result = WorldDatabase.Query("SELECT spell_id, ScriptName FROM spell_script_names");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u spell script names", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-++count;
-bar.step();
-
-Field *fields = result->Fetch();
-
-int32 spellId = fields[0].GetInt32();
-const char *scriptName = fields[1].GetCString();
-
-bool allRanks = false;
-if (spellId <=0)
-{
-allRanks = true;
-spellId = -spellId;
-}
-
-SpellEntry const* spellEntry = sSpellStore.LookupEntry(spellId);
-if (!spellEntry)
-{
-sLog.outErrorDb("Scriptname:`%s` spell (spell_id:%d) does not exist in `Spell.dbc`.",scriptName,fields[0].GetInt32());
-continue;
-}
-
-if (allRanks)
-{
-if (sSpellMgr.GetFirstSpellInChain(spellId) != uint32(spellId))
-{
-sLog.outErrorDb("Scriptname:`%s` spell (spell_id:%d) is not first rank of spell.",scriptName,fields[0].GetInt32());
-continue;
-}
-while(spellId)
-{
-mSpellScripts.insert(SpellScriptsMap::value_type(spellId, GetScriptId(scriptName)));
-spellId = sSpellMgr.GetNextSpellInChain(spellId);
-}
-}
-else
-mSpellScripts.insert(SpellScriptsMap::value_type(spellId, GetScriptId(scriptName)));
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u spell script names", count);
-}
-
-void ObjectMgr::ValidateSpellScripts()
-{
-if (mSpellScripts.empty())
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Validation done");
-return;
-}
-
-barGoLink bar(mSpellScripts.size());
-for (SpellScriptsMap::iterator itr = mSpellScripts.begin(); itr != mSpellScripts.end();)
-{
-SpellEntry const * spellEntry = sSpellStore.LookupEntry(itr->first);
-std::vector<std::pair<SpellScriptLoader *, SpellScriptsMap::iterator> > SpellScriptLoaders;
-sScriptMgr.CreateSpellScriptLoaders(itr->first, SpellScriptLoaders);
-itr = mSpellScripts.upper_bound(itr->first);
-
-for (std::vector<std::pair<SpellScriptLoader *, SpellScriptsMap::iterator> >::iterator sitr = SpellScriptLoaders.begin(); sitr != SpellScriptLoaders.end(); ++sitr)
-{
-bar.step();
-SpellScript * spellScript = sitr->first->GetSpellScript();
-AuraScript * auraScript = sitr->first->GetAuraScript();
-bool valid = true;
-if (!spellScript && !auraScript)
-{
-sLog.outError("TSCR: Functions GetSpellScript() and GetAuraScript() of script `%s` do not return objects - script skipped", GetScriptName(sitr->second->second));
-valid = false;
-}
-if (spellScript)
-{
-spellScript->_Init(&sitr->first->GetName(), spellEntry->Id);
-spellScript->_Register();
-if (!spellScript->_Validate(spellEntry))
-valid = false;
-delete spellScript;
-}
-if (auraScript)
-{
-auraScript->_Init(&sitr->first->GetName(), spellEntry->Id);
-auraScript->_Register();
-if (!auraScript->_Validate(spellEntry))
-valid = false;
-delete auraScript;
-}
-if (!valid)
-mSpellScripts.erase(sitr->second);
-}
-}
-
-sLog.outString();
-sLog.outString(">> Validation done");
-}
-
-void ObjectMgr::LoadGossipScripts()
-{
-LoadScripts(SCRIPTS_GOSSIP);
-
-// checks are done in LoadGossipMenuItems
-}
-
-void ObjectMgr::LoadPageTexts()
-{
-sPageTextStore.Free(); // for reload case
-
-sPageTextStore.Load();
-sLog.outString(">> Loaded %u page texts", sPageTextStore.RecordCount);
-sLog.outString();
-
-for (uint32 i = 1; i < sPageTextStore.MaxEntry; ++i)
-{
-// check data correctness
-PageText const* page = sPageTextStore.LookupEntry<PageText>(i);
-if (!page)
-continue;
-
-if (page->Next_Page && !sPageTextStore.LookupEntry<PageText>(page->Next_Page))
-{
-sLog.outErrorDb("Page text (Id: %u) has not existing next page (Id:%u)", i,page->Next_Page);
-continue;
-}
-
-// detect circular reference
-std::set<uint32> checkedPages;
-for (PageText const* pageItr = page; pageItr; pageItr = sPageTextStore.LookupEntry<PageText>(pageItr->Next_Page))
-{
-if (!pageItr->Next_Page)
-break;
-checkedPages.insert(pageItr->Page_ID);
-if (checkedPages.find(pageItr->Next_Page)!= checkedPages.end())
-{
-std::ostringstream ss;
-ss << "The text page(s) ";
-for (std::set<uint32>::iterator itr= checkedPages.begin(); itr != checkedPages.end(); ++itr)
-ss << *itr << " ";
-ss << "create(s) a circular reference, which can cause the server to freeze. Changing Next_Page of page "
-<< pageItr->Page_ID <<" to 0";
-sLog.outErrorDb("%s", ss.str().c_str());
-const_cast<PageText*>(pageItr)->Next_Page = 0;
-break;
-}
-}
-}
-}
-
-void ObjectMgr::LoadPageTextLocales()
-{
-mPageTextLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT entry,text_loc1,text_loc2,text_loc3,text_loc4,text_loc5,text_loc6,text_loc7,text_loc8 FROM locales_page_text");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-PageTextLocale& data = mPageTextLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-std::string str = fields[i].GetString();
-AddLocaleString(str, LocaleConstant(i), data.Text);
-}
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu PageText locale strings", (unsigned long)mPageTextLocaleMap.size());
-}
-
-struct SQLInstanceLoader : public SQLStorageLoaderBase<SQLInstanceLoader>
-{
-template<class D>
-void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
-{
-dst = D(sObjectMgr.GetScriptId(src));
-}
-};
-
-void ObjectMgr::LoadInstanceTemplate()
-{
-SQLInstanceLoader loader;
-loader.Load(sInstanceTemplate);
-
-for (uint32 i = 0; i < sInstanceTemplate.MaxEntry; i++)
-{
-InstanceTemplate* temp = const_cast<InstanceTemplate*>(GetInstanceTemplate(i));
-if (!temp)
-continue;
-
-if (!MapManager::IsValidMAP(temp->map))
-sLog.outErrorDb("ObjectMgr::LoadInstanceTemplate: bad mapid %d for template!", temp->map);
-
-if (!MapManager::IsValidMapCoord(temp->parent,temp->startLocX,temp->startLocY,temp->startLocZ,temp->startLocO))
-{
-sLog.outErrorDb("ObjectMgr::LoadInstanceTemplate: bad parent entrance coordinates for map id %d template!", temp->map);
-temp->parent = 0; // will have wrong continent 0 parent, at least existed
-}
-}
-
-sLog.outString(">> Loaded %u Instance Template definitions", sInstanceTemplate.RecordCount);
-sLog.outString();
-}
-
-GossipText const *ObjectMgr::GetGossipText(uint32 Text_ID) const
-{
-GossipTextMap::const_iterator itr = mGossipText.find(Text_ID);
-if (itr != mGossipText.end())
-return &itr->second;
-return NULL;
-}
-
-void ObjectMgr::LoadGossipText()
-{
-QueryResult result = WorldDatabase.Query("SELECT * FROM npc_text");
-
-int count = 0;
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u npc texts", count);
-return;
-}
-
-int cic;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-++count;
-cic = 0;
-
-Field *fields = result->Fetch();
-
-bar.step();
-
-uint32 Text_ID = fields[cic++].GetUInt32();
-if (!Text_ID)
-{
-sLog.outErrorDb("Table `npc_text` has record wit reserved id 0, ignore.");
-continue;
-}
-
-GossipText& gText = mGossipText[Text_ID];
-
-for (int i = 0; i < MAX_GOSSIP_TEXT_OPTIONS; i++)
-{
-gText.Options[i].Text_0 = fields[cic++].GetString();
-gText.Options[i].Text_1 = fields[cic++].GetString();
-
-gText.Options[i].Language = fields[cic++].GetUInt32();
-gText.Options[i].Probability = fields[cic++].GetFloat();
-
-for (uint8 j=0; j < MAX_GOSSIP_TEXT_EMOTES; ++j)
-{
-gText.Options[i].Emotes[j]._Delay = fields[cic++].GetUInt32();
-gText.Options[i].Emotes[j]._Emote = fields[cic++].GetUInt32();
-}
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u npc texts", count);
-}
-
-void ObjectMgr::LoadNpcTextLocales()
-{
-mNpcTextLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT entry,"
-"Text0_0_loc1,Text0_1_loc1,Text1_0_loc1,Text1_1_loc1,Text2_0_loc1,Text2_1_loc1,Text3_0_loc1,Text3_1_loc1,Text4_0_loc1,Text4_1_loc1,Text5_0_loc1,Text5_1_loc1,Text6_0_loc1,Text6_1_loc1,Text7_0_loc1,Text7_1_loc1,"
-"Text0_0_loc2,Text0_1_loc2,Text1_0_loc2,Text1_1_loc2,Text2_0_loc2,Text2_1_loc2,Text3_0_loc2,Text3_1_loc1,Text4_0_loc2,Text4_1_loc2,Text5_0_loc2,Text5_1_loc2,Text6_0_loc2,Text6_1_loc2,Text7_0_loc2,Text7_1_loc2,"
-"Text0_0_loc3,Text0_1_loc3,Text1_0_loc3,Text1_1_loc3,Text2_0_loc3,Text2_1_loc3,Text3_0_loc3,Text3_1_loc1,Text4_0_loc3,Text4_1_loc3,Text5_0_loc3,Text5_1_loc3,Text6_0_loc3,Text6_1_loc3,Text7_0_loc3,Text7_1_loc3,"
-"Text0_0_loc4,Text0_1_loc4,Text1_0_loc4,Text1_1_loc4,Text2_0_loc4,Text2_1_loc4,Text3_0_loc4,Text3_1_loc1,Text4_0_loc4,Text4_1_loc4,Text5_0_loc4,Text5_1_loc4,Text6_0_loc4,Text6_1_loc4,Text7_0_loc4,Text7_1_loc4,"
-"Text0_0_loc5,Text0_1_loc5,Text1_0_loc5,Text1_1_loc5,Text2_0_loc5,Text2_1_loc5,Text3_0_loc5,Text3_1_loc1,Text4_0_loc5,Text4_1_loc5,Text5_0_loc5,Text5_1_loc5,Text6_0_loc5,Text6_1_loc5,Text7_0_loc5,Text7_1_loc5,"
-"Text0_0_loc6,Text0_1_loc6,Text1_0_loc6,Text1_1_loc6,Text2_0_loc6,Text2_1_loc6,Text3_0_loc6,Text3_1_loc1,Text4_0_loc6,Text4_1_loc6,Text5_0_loc6,Text5_1_loc6,Text6_0_loc6,Text6_1_loc6,Text7_0_loc6,Text7_1_loc6,"
-"Text0_0_loc7,Text0_1_loc7,Text1_0_loc7,Text1_1_loc7,Text2_0_loc7,Text2_1_loc7,Text3_0_loc7,Text3_1_loc1,Text4_0_loc7,Text4_1_loc7,Text5_0_loc7,Text5_1_loc7,Text6_0_loc7,Text6_1_loc7,Text7_0_loc7,Text7_1_loc7, "
-"Text0_0_loc8,Text0_1_loc8,Text1_0_loc8,Text1_1_loc8,Text2_0_loc8,Text2_1_loc8,Text3_0_loc8,Text3_1_loc1,Text4_0_loc8,Text4_1_loc8,Text5_0_loc8,Text5_1_loc8,Text6_0_loc8,Text6_1_loc8,Text7_0_loc8,Text7_1_loc8 "
-" FROM locales_npc_text");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-NpcTextLocale& data = mNpcTextLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-LocaleConstant locale = (LocaleConstant) i;
-for (uint8 j = 0; j < MAX_LOCALES; ++j)
-{
-std::string str0 = fields[1 + 8 * 2 * (i - 1) + 2 * j].GetString();
-AddLocaleString(str0, locale, data.Text_0[j]);
-
-std::string str1 = fields[1 + 8 * 2 * (i - 1) + 2 * j + 1].GetString();
-AddLocaleString(str1, locale, data.Text_1[j]);
-}
-}
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu NpcText locale strings", (unsigned long)mNpcTextLocaleMap.size());
-}
-
-//not very fast function but it is called only once a day, or on starting-up
-void ObjectMgr::ReturnOrDeleteOldMails(bool serverUp)
-{
-time_t basetime = time(NULL);
-sLog.outDebug("Returning mails current time: hour: %d, minute: %d, second: %d ", localtime(&basetime)->tm_hour, localtime(&basetime)->tm_min, localtime(&basetime)->tm_sec);
-//delete all old mails without item and without body immediately, if starting server
-if (!serverUp)
-CharacterDatabase.PExecute("DELETE FROM mail WHERE expire_time < '" UI64FMTD "' AND has_items = '0' AND body = ''", (uint64)basetime);
-// 0 1 2 3 4 5 6 7 8 9
-QueryResult result = CharacterDatabase.PQuery("SELECT id,messageType,sender,receiver,has_items,expire_time,cod,checked,mailTemplateId FROM mail WHERE expire_time < '" UI64FMTD "'", (uint64)basetime);
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outString(">> Only expired mails (need to be return or delete) or DB table `mail` is empty.");
-return; // any mails need to be returned or deleted
-}
-
-barGoLink bar(result->GetRowCount());
-uint32 count = 0;
-Field *fields;
-
-do
-{
-bar.step();
-
-fields = result->Fetch();
-Mail *m = new Mail;
-m->messageID = fields[0].GetUInt32();
-m->messageType = fields[1].GetUInt8();
-m->sender = fields[2].GetUInt32();
-m->receiver = fields[3].GetUInt32();
-bool has_items = fields[4].GetBool();
-m->expire_time = (time_t)fields[5].GetUInt64();
-m->deliver_time = 0;
-m->COD = fields[6].GetUInt32();
-m->checked = fields[7].GetUInt32();
-m->mailTemplateId = fields[8].GetInt16();
-
-Player *pl = NULL;
-if (serverUp)
-pl = GetPlayer((uint64)m->receiver);
-
-if (pl && pl->m_mailsLoaded)
-{ //this code will run very improbably (the time is between 4 and 5 am, in game is online a player, who has old mail
-//his in mailbox and he has already listed his mails)
-delete m;
-continue;
-}
-
-//delete or return mail:
-if (has_items)
-{
-QueryResult resultItems = CharacterDatabase.PQuery("SELECT item_guid,item_template FROM mail_items WHERE mail_id='%u'", m->messageID);
-if (resultItems)
-{
-do
-{
-Field *fields2 = resultItems->Fetch();
-
-uint32 item_guid_low = fields2[0].GetUInt32();
-uint32 item_template = fields2[1].GetUInt32();
-
-m->AddItem(item_guid_low, item_template);
-}
-while (resultItems->NextRow());
-}
-//if it is mail from AH, it shouldn't be returned, but deleted
-if (m->messageType != MAIL_NORMAL || m->messageType == MAIL_AUCTION || (m->checked & (MAIL_CHECK_MASK_COD_PAYMENT | MAIL_CHECK_MASK_RETURNED)))
-{
-// mail open and then not returned
-for (std::vector<MailItemInfo>::iterator itr2 = m->items.begin(); itr2 != m->items.end(); ++itr2)
-{
-PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
-stmt->setUInt32(0, itr2->item_guid);
-CharacterDatabase.Execute(stmt);
-}
-}
-else
-{
-//mail will be returned:
-CharacterDatabase.PExecute("UPDATE mail SET sender = '%u', receiver = '%u', expire_time = '" UI64FMTD "', deliver_time = '" UI64FMTD "',cod = '0', checked = '%u' WHERE id = '%u'", m->receiver, m->sender, (uint64)(basetime + 30*DAY), (uint64)basetime, MAIL_CHECK_MASK_RETURNED, m->messageID);
-delete m;
-continue;
-}
-}
-
-CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", m->messageID);
-delete m;
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u mails", count);
-}
-
-void ObjectMgr::LoadQuestAreaTriggers()
-{
-mQuestAreaTriggerMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT id,quest FROM areatrigger_involvedrelation");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u quest trigger points", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-++count;
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 trigger_ID = fields[0].GetUInt32();
-uint32 quest_ID = fields[1].GetUInt32();
-
-AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(trigger_ID);
-if (!atEntry)
-{
-sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",trigger_ID);
-continue;
-}
-
-Quest const* quest = GetQuestTemplate(quest_ID);
-
-if (!quest)
-{
-sLog.outErrorDb("Table `areatrigger_involvedrelation` has record (id: %u) for not existing quest %u",trigger_ID,quest_ID);
-continue;
-}
-
-if (!quest->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
-{
-sLog.outErrorDb("Table `areatrigger_involvedrelation` has record (id: %u) for not quest %u, but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT. Trigger or quest flags must be fixed, quest modified to require objective.",trigger_ID,quest_ID);
-
-// this will prevent quest completing without objective
-const_cast<Quest*>(quest)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
-
-// continue; - quest modified to required objective and trigger can be allowed.
-}
-
-mQuestAreaTriggerMap[trigger_ID] = quest_ID;
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u quest trigger points", count);
-}
-
-void ObjectMgr::LoadTavernAreaTriggers()
-{
-mTavernAreaTriggerSet.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT id FROM areatrigger_tavern");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u tavern triggers", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-++count;
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 Trigger_ID = fields[0].GetUInt32();
-
-AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
-if (!atEntry)
-{
-sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",Trigger_ID);
-continue;
-}
-
-mTavernAreaTriggerSet.insert(Trigger_ID);
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u tavern triggers", count);
-}
-
-void ObjectMgr::LoadAreaTriggerScripts()
-{
-mAreaTriggerScripts.clear(); // need for reload case
-QueryResult result = WorldDatabase.Query("SELECT entry, ScriptName FROM areatrigger_scripts");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u areatrigger scripts", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-++count;
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 Trigger_ID = fields[0].GetUInt32();
-const char *scriptName = fields[1].GetCString();
-
-AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
-if (!atEntry)
-{
-sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",Trigger_ID);
-continue;
-}
-mAreaTriggerScripts[Trigger_ID] = GetScriptId(scriptName);
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u areatrigger scripts", count);
-}
-
-uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team)
-{
-bool found = false;
-float dist = 10000;
-uint32 id = 0;
-
-for (uint32 i = 1; i < sTaxiNodesStore.GetNumRows(); ++i)
-{
-TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(i);
-
-if (!node || node->map_id != mapid || (!node->MountCreatureID[team == ALLIANCE ? 1 : 0] && node->MountCreatureID[0] != 32981)) // dk flight
-continue;
-
-uint8 field = (uint8)((i - 1) / 32);
-uint32 submask = 1<<((i-1)%32);
-
-// skip not taxi network nodes
-if ((sTaxiNodesMask[field] & submask) == 0)
-continue;
-
-float dist2 = (node->x - x)*(node->x - x)+(node->y - y)*(node->y - y)+(node->z - z)*(node->z - z);
-if (found)
-{
-if (dist2 < dist)
-{
-dist = dist2;
-id = i;
-}
-}
-else
-{
-found = true;
-dist = dist2;
-id = i;
-}
-}
-
-return id;
-}
-
-void ObjectMgr::GetTaxiPath(uint32 source, uint32 destination, uint32 &path, uint32 &cost)
-{
-TaxiPathSetBySource::iterator src_i = sTaxiPathSetBySource.find(source);
-if (src_i == sTaxiPathSetBySource.end())
-{
-path = 0;
-cost = 0;
-return;
-}
-
-TaxiPathSetForSource& pathSet = src_i->second;
-
-TaxiPathSetForSource::iterator dest_i = pathSet.find(destination);
-if (dest_i == pathSet.end())
-{
-path = 0;
-cost = 0;
-return;
-}
-
-cost = dest_i->second.price;
-path = dest_i->second.ID;
-}
-
-uint32 ObjectMgr::GetTaxiMountDisplayId(uint32 id, uint32 team, bool allowed_alt_team /* = false */)
-{
-uint32 mount_entry = 0;
-uint32 mount_id = 0;
-
-// select mount creature id
-TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(id);
-if (node)
-{
-if (team == ALLIANCE)
-mount_entry = node->MountCreatureID[1];
-else
-mount_entry = node->MountCreatureID[0];
-
-// Fix for Alliance not being able to use Acherus taxi
-// only one mount type for both sides
-if (mount_entry == 0 && allowed_alt_team)
-{
-// Simply reverse the selection. At least one team in theory should have a valid mount ID to choose.
-mount_entry = team == ALLIANCE ? node->MountCreatureID[0] : node->MountCreatureID[1];
-}
-
-CreatureInfo const *mount_info = GetCreatureTemplate(mount_entry);
-if (mount_info)
-{
-mount_id = mount_info->GetRandomValidModelId();
-if (!mount_id)
-{
-sLog.outErrorDb("No displayid found for the taxi mount with the entry %u! Can't load it!", mount_entry);
-return false;
-}
-}
-}
-
-CreatureModelInfo const *minfo = sObjectMgr.GetCreatureModelRandomGender(mount_id);
-if (minfo)
-mount_id = minfo->modelid;
-
-return mount_id;
-}
-
-void ObjectMgr::LoadGraveyardZones()
-{
-mGraveYardMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT id,ghost_zone,faction FROM game_graveyard_zone");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u graveyard-zone links", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-++count;
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 safeLocId = fields[0].GetUInt32();
-uint32 zoneId = fields[1].GetUInt32();
-uint32 team = fields[2].GetUInt32();
-
-WorldSafeLocsEntry const* entry = sWorldSafeLocsStore.LookupEntry(safeLocId);
-if (!entry)
-{
-sLog.outErrorDb("Table `game_graveyard_zone` has record for not existing graveyard (WorldSafeLocs.dbc id) %u, skipped.",safeLocId);
-continue;
-}
-
-AreaTableEntry const *areaEntry = GetAreaEntryByAreaID(zoneId);
-if (!areaEntry)
-{
-sLog.outErrorDb("Table `game_graveyard_zone` has record for not existing zone id (%u), skipped.",zoneId);
-continue;
-}
-
-if (areaEntry->zone != 0)
-{
-sLog.outErrorDb("Table `game_graveyard_zone` has record subzone id (%u) instead of zone, skipped.",zoneId);
-continue;
-}
-
-if (team != 0 && team != HORDE && team != ALLIANCE)
-{
-sLog.outErrorDb("Table `game_graveyard_zone` has record for non player faction (%u), skipped.",team);
-continue;
-}
-
-if (!AddGraveYardLink(safeLocId,zoneId,team,false))
-sLog.outErrorDb("Table `game_graveyard_zone` has a duplicate record for Graveyard (ID: %u) and Zone (ID: %u), skipped.",safeLocId,zoneId);
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u graveyard-zone links", count);
-}
-
-WorldSafeLocsEntry const *ObjectMgr::GetClosestGraveYard(float x, float y, float z, uint32 MapId, uint32 team)
-{
-// search for zone associated closest graveyard
-uint32 zoneId = sMapMgr.GetZoneId(MapId,x,y,z);
-
-// Simulate std. algorithm:
-// found some graveyard associated to (ghost_zone,ghost_map)
-//
-// if mapId == graveyard.mapId (ghost in plain zone or city or battleground) and search graveyard at same map
-// then check faction
-// if mapId != graveyard.mapId (ghost in instance) and search any graveyard associated
-// then check faction
-GraveYardMap::const_iterator graveLow = mGraveYardMap.lower_bound(zoneId);
-GraveYardMap::const_iterator graveUp = mGraveYardMap.upper_bound(zoneId);
-MapEntry const* map = sMapStore.LookupEntry(MapId);
-// not need to check validity of map object; MapId _MUST_ be valid here
-
-if (graveLow == graveUp && !map->IsBattleArena())
-{
-//sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
-return NULL;
-}
-
-// at corpse map
-bool foundNear = false;
-float distNear = 10000;
-WorldSafeLocsEntry const* entryNear = NULL;
-
-// at entrance map for corpse map
-bool foundEntr = false;
-float distEntr = 10000;
-WorldSafeLocsEntry const* entryEntr = NULL;
-
-// some where other
-WorldSafeLocsEntry const* entryFar = NULL;
-
-MapEntry const* mapEntry = sMapStore.LookupEntry(MapId);
-
-for (GraveYardMap::const_iterator itr = graveLow; itr != graveUp; ++itr)
-{
-GraveYardData const& data = itr->second;
-
-WorldSafeLocsEntry const* entry = sWorldSafeLocsStore.LookupEntry(data.safeLocId);
-if (!entry)
-{
-sLog.outErrorDb("Table `game_graveyard_zone` has record for not existing graveyard (WorldSafeLocs.dbc id) %u, skipped.",data.safeLocId);
-continue;
-}
-
-// skip enemy faction graveyard
-// team == 0 case can be at call from .neargrave
-if (data.team != 0 && team != 0 && data.team != team)
-continue;
-
-// find now nearest graveyard at other map
-if (MapId != entry->map_id)
-{
-// if find graveyard at different map from where entrance placed (or no entrance data), use any first
-if (!mapEntry ||
-mapEntry->entrance_map < 0 ||
-uint32(mapEntry->entrance_map) != entry->map_id ||
-(mapEntry->entrance_x == 0 && mapEntry->entrance_y == 0))
-{
-// not have any corrdinates for check distance anyway
-entryFar = entry;
-continue;
-}
-
-// at entrance map calculate distance (2D);
-float dist2 = (entry->x - mapEntry->entrance_x)*(entry->x - mapEntry->entrance_x)
-+(entry->y - mapEntry->entrance_y)*(entry->y - mapEntry->entrance_y);
-if (foundEntr)
-{
-if (dist2 < distEntr)
-{
-distEntr = dist2;
-entryEntr = entry;
-}
-}
-else
-{
-foundEntr = true;
-distEntr = dist2;
-entryEntr = entry;
-}
-}
-// find now nearest graveyard at same map
-else
-{
-float dist2 = (entry->x - x)*(entry->x - x)+(entry->y - y)*(entry->y - y)+(entry->z - z)*(entry->z - z);
-if (foundNear)
-{
-if (dist2 < distNear)
-{
-distNear = dist2;
-entryNear = entry;
-}
-}
-else
-{
-foundNear = true;
-distNear = dist2;
-entryNear = entry;
-}
-}
-}
-
-if (entryNear)
-return entryNear;
-
-if (entryEntr)
-return entryEntr;
-
-return entryFar;
-}
-
-GraveYardData const* ObjectMgr::FindGraveYardData(uint32 id, uint32 zoneId)
-{
-GraveYardMap::const_iterator graveLow = mGraveYardMap.lower_bound(zoneId);
-GraveYardMap::const_iterator graveUp = mGraveYardMap.upper_bound(zoneId);
-
-for (GraveYardMap::const_iterator itr = graveLow; itr != graveUp; ++itr)
-{
-if (itr->second.safeLocId == id)
-return &itr->second;
-}
-
-return NULL;
-}
-
-bool ObjectMgr::AddGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
-{
-if (FindGraveYardData(id,zoneId))
-return false;
-
-// add link to loaded data
-GraveYardData data;
-data.safeLocId = id;
-data.team = team;
-
-mGraveYardMap.insert(GraveYardMap::value_type(zoneId,data));
-
-// add link to DB
-if (inDB)
-{
-WorldDatabase.PExecute("INSERT INTO game_graveyard_zone (id,ghost_zone,faction) "
-"VALUES ('%u', '%u','%u')",id,zoneId,team);
-}
-
-return true;
-}
-
-void ObjectMgr::RemoveGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
-{
-GraveYardMap::iterator graveLow = mGraveYardMap.lower_bound(zoneId);
-GraveYardMap::iterator graveUp = mGraveYardMap.upper_bound(zoneId);
-if (graveLow == graveUp)
-{
-//sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
-return;
-}
-
-bool found = false;
-
-GraveYardMap::iterator itr;
-
-for (itr = graveLow; itr != graveUp; ++itr)
-{
-GraveYardData & data = itr->second;
-
-// skip not matching safezone id
-if (data.safeLocId != id)
-continue;
-
-// skip enemy faction graveyard at same map (normal area, city, or battleground)
-// team == 0 case can be at call from .neargrave
-if (data.team != 0 && team != 0 && data.team != team)
-continue;
-
-found = true;
-break;
-}
-
-// no match, return
-if (!found)
-return;
-
-// remove from links
-mGraveYardMap.erase(itr);
-
-// remove link from DB
-if (inDB)
-{
-WorldDatabase.PExecute("DELETE FROM game_graveyard_zone WHERE id = '%u' AND ghost_zone = '%u' AND faction = '%u'",id,zoneId,team);
-}
-
-return;
-}
-
-void ObjectMgr::LoadAreaTriggerTeleports()
-{
-mAreaTriggers.clear(); // need for reload case
-
-uint32 count = 0;
-
-// 0 1 2 3 4 5
-QueryResult result = WorldDatabase.Query("SELECT id, target_map, target_position_x, target_position_y, target_position_z, target_orientation FROM areatrigger_teleport");
-if (!result)
-{
-
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u area trigger teleport definitions", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-
-bar.step();
-
-++count;
-
-uint32 Trigger_ID = fields[0].GetUInt32();
-
-AreaTrigger at;
-
-at.target_mapId = fields[1].GetUInt32();
-at.target_X = fields[2].GetFloat();
-at.target_Y = fields[3].GetFloat();
-at.target_Z = fields[4].GetFloat();
-at.target_Orientation = fields[5].GetFloat();
-
-AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
-if (!atEntry)
-{
-sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",Trigger_ID);
-continue;
-}
-
-MapEntry const* mapEntry = sMapStore.LookupEntry(at.target_mapId);
-if (!mapEntry)
-{
-sLog.outErrorDb("Area trigger (ID:%u) target map (ID: %u) does not exist in `Map.dbc`.",Trigger_ID,at.target_mapId);
-continue;
-}
-
-if (at.target_X == 0 && at.target_Y == 0 && at.target_Z == 0)
-{
-sLog.outErrorDb("Area trigger (ID:%u) target coordinates not provided.",Trigger_ID);
-continue;
-}
-
-mAreaTriggers[Trigger_ID] = at;
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u area trigger teleport definitions", count);
-}
-
-void ObjectMgr::LoadAccessRequirements()
-{
-mAccessRequirements.clear(); // need for reload case
-
-uint32 count = 0;
-
-// 0 1 2 3 4 5 6 7 8 9
-QueryResult result = WorldDatabase.Query("SELECT mapid, difficulty, level_min, level_max, item, item2, quest_done_A, quest_done_H, completed_achievement, quest_failed_text FROM access_requirement");
-if (!result)
-{
-
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u access requirement definitions", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-
-bar.step();
-
-++count;
-
-uint32 mapid = fields[0].GetUInt32();
-uint8 difficulty = fields[1].GetUInt8();
-uint32 requirement_ID = MAKE_PAIR32(mapid,difficulty);
-
-AccessRequirement ar;
-
-ar.levelMin = fields[2].GetUInt8();
-ar.levelMax = fields[3].GetUInt8();
-ar.item = fields[4].GetUInt32();
-ar.item2 = fields[5].GetUInt32();
-ar.quest_A = fields[6].GetUInt32();
-ar.quest_H = fields[7].GetUInt32();
-ar.achievement = fields[8].GetUInt32();
-ar.questFailedText = fields[9].GetString();
-
-if (ar.item)
-{
-ItemPrototype const *pProto = GetItemPrototype(ar.item);
-if (!pProto)
-{
-sLog.outError("Key item %u does not exist for map %u difficulty %u, removing key requirement.", ar.item, mapid, difficulty);
-ar.item = 0;
-}
-}
-
-if (ar.item2)
-{
-ItemPrototype const *pProto = GetItemPrototype(ar.item2);
-if (!pProto)
-{
-sLog.outError("Second item %u does not exist for map %u difficulty %u, removing key requirement.", ar.item2, mapid, difficulty);
-ar.item2 = 0;
-}
-}
-
-if (ar.quest_A)
-{
-if (!GetQuestTemplate(ar.quest_A))
-{
-sLog.outErrorDb("Required Alliance Quest %u not exist for map %u difficulty %u, remove quest done requirement.", ar.quest_A, mapid, difficulty);
-ar.quest_A = 0;
-}
-}
-
-if (ar.quest_H)
-{
-if (!GetQuestTemplate(ar.quest_H))
-{
-sLog.outErrorDb("Required Horde Quest %u not exist for map %u difficulty %u, remove quest done requirement.", ar.quest_H, mapid, difficulty);
-ar.quest_H = 0;
-}
-}
-
-if (ar.achievement)
-{
-if (!sAchievementStore.LookupEntry(ar.achievement))
-{
-sLog.outErrorDb("Required Achievement %u not exist for map %u difficulty %u, remove quest done requirement.", ar.achievement, mapid, difficulty);
-ar.achievement = 0;
-}
-}
-
-mAccessRequirements[requirement_ID] = ar;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u access requirement definitions", count);
-}
-
-/*
-* Searches for the areatrigger which teleports players out of the given map with instance_template.parent field support
-*/
-AreaTrigger const* ObjectMgr::GetGoBackTrigger(uint32 Map) const
-{
-bool useParentDbValue = false;
-uint32 parentId = 0;
-const MapEntry *mapEntry = sMapStore.LookupEntry(Map);
-if (!mapEntry || mapEntry->entrance_map < 0)
-return NULL;
-
-if (mapEntry->IsDungeon())
-{
-const InstanceTemplate *iTemplate = sObjectMgr.GetInstanceTemplate(Map);
-
-if (!iTemplate)
-return NULL;
-
-parentId = iTemplate->parent;
-useParentDbValue = true;
-}
-
-uint32 entrance_map = uint32(mapEntry->entrance_map);
-for (AreaTriggerMap::const_iterator itr = mAreaTriggers.begin(); itr != mAreaTriggers.end(); ++itr)
-if ((!useParentDbValue && itr->second.target_mapId == entrance_map) || (useParentDbValue && itr->second.target_mapId == parentId))
-{
-AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(itr->first);
-if (atEntry && atEntry->mapid == Map)
-return &itr->second;
-}
-return NULL;
-}
-
-/**
-* Searches for the areatrigger which teleports players to the given map
-*/
-AreaTrigger const* ObjectMgr::GetMapEntranceTrigger(uint32 Map) const
-{
-for (AreaTriggerMap::const_iterator itr = mAreaTriggers.begin(); itr != mAreaTriggers.end(); ++itr)
-{
-if (itr->second.target_mapId == Map)
-{
-AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(itr->first);
-if (atEntry)
-return &itr->second;
-}
-}
-return NULL;
-}
-
-void ObjectMgr::SetHighestGuids()
-{
-QueryResult result = CharacterDatabase.Query("SELECT MAX(guid) FROM characters");
-if (result)
-m_hiCharGuid = (*result)[0].GetUInt32()+1;
-
-result = WorldDatabase.Query("SELECT MAX(guid) FROM creature");
-if (result)
-m_hiCreatureGuid = (*result)[0].GetUInt32()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(guid) FROM item_instance");
-if (result)
-m_hiItemGuid = (*result)[0].GetUInt32()+1;
-
-// Cleanup other tables from not existed guids ( >= m_hiItemGuid)
-CharacterDatabase.PExecute("DELETE FROM character_inventory WHERE item >= '%u'", m_hiItemGuid);
-CharacterDatabase.PExecute("DELETE FROM mail_items WHERE item_guid >= '%u'", m_hiItemGuid);
-CharacterDatabase.PExecute("DELETE FROM auctionhouse WHERE itemguid >= '%u'", m_hiItemGuid);
-CharacterDatabase.PExecute("DELETE FROM guild_bank_item WHERE item_guid >= '%u'", m_hiItemGuid);
-
-result = WorldDatabase.Query("SELECT MAX(guid) FROM gameobject");
-if (result)
-m_hiGoGuid = (*result)[0].GetUInt32()+1;
-
-result = WorldDatabase.Query("SELECT MAX(guid) FROM transports");
-if (result)
-m_hiMoTransGuid = (*result)[0].GetUInt32()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(id) FROM auctionhouse");
-if (result)
-m_auctionid = (*result)[0].GetUInt32()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(id) FROM mail");
-if (result)
-m_mailid = (*result)[0].GetUInt32()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(guid) FROM corpse");
-if (result)
-m_hiCorpseGuid = (*result)[0].GetUInt32()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(arenateamid) FROM arena_team");
-if (result)
-m_arenaTeamId = (*result)[0].GetUInt32()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(setguid) FROM character_equipmentsets");
-if (result)
-m_equipmentSetGuid = (*result)[0].GetUInt64()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(guildid) FROM guild");
-if (result)
-m_guildId = (*result)[0].GetUInt32()+1;
-
-result = CharacterDatabase.Query("SELECT MAX(guid) FROM groups");
-if (result)
-m_hiGroupGuid = (*result)[0].GetUInt32()+1;
-}
-
-uint32 ObjectMgr::GenerateArenaTeamId()
-{
-if (m_arenaTeamId >= 0xFFFFFFFE)
-{
-sLog.outError("Arena team ids overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_arenaTeamId++;
-}
-
-uint32 ObjectMgr::GenerateAuctionID()
-{
-if (m_auctionid >= 0xFFFFFFFE)
-{
-sLog.outError("Auctions ids overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_auctionid++;
-}
-
-uint64 ObjectMgr::GenerateEquipmentSetGuid()
-{
-if (m_equipmentSetGuid >= 0xFFFFFFFFFFFFFFFEll)
-{
-sLog.outError("EquipmentSet guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_equipmentSetGuid++;
-}
-
-uint32 ObjectMgr::GenerateGuildId()
-{
-if (m_guildId >= 0xFFFFFFFE)
-{
-sLog.outError("Guild ids overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_guildId++;
-}
-
-uint32 ObjectMgr::GenerateMailID()
-{
-if (m_mailid >= 0xFFFFFFFE)
-{
-sLog.outError("Mail ids overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_mailid++;
-}
-
-uint32 ObjectMgr::GenerateLowGuid(HighGuid guidhigh)
-{
-switch(guidhigh)
-{
-case HIGHGUID_ITEM:
-if (m_hiItemGuid >= 0xFFFFFFFE)
-{
-sLog.outError("Item guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiItemGuid++;
-case HIGHGUID_UNIT:
-if (m_hiCreatureGuid >= 0x00FFFFFE)
-{
-sLog.outError("Creature guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiCreatureGuid++;
-case HIGHGUID_PET:
-if (m_hiPetGuid >= 0x00FFFFFE)
-{
-sLog.outError("Pet guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiPetGuid++;
-case HIGHGUID_VEHICLE:
-if (m_hiVehicleGuid >= 0x00FFFFFF)
-{
-sLog.outError("Vehicle guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiVehicleGuid++;
-case HIGHGUID_PLAYER:
-if (m_hiCharGuid >= 0xFFFFFFFE)
-{
-sLog.outError("Players guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiCharGuid++;
-case HIGHGUID_GAMEOBJECT:
-if (m_hiGoGuid >= 0x00FFFFFE)
-{
-sLog.outError("Gameobject guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiGoGuid++;
-case HIGHGUID_CORPSE:
-if (m_hiCorpseGuid >= 0xFFFFFFFE)
-{
-sLog.outError("Corpse guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiCorpseGuid++;
-case HIGHGUID_DYNAMICOBJECT:
-if (m_hiDoGuid >= 0xFFFFFFFE)
-{
-sLog.outError("DynamicObject guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiDoGuid++;
-case HIGHGUID_GROUP:
-if (m_hiGroupGuid >= 0xFFFFFFFE)
-{
-sLog.outError("Group guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiGroupGuid++;
-case HIGHGUID_MO_TRANSPORT:
-if (m_hiMoTransGuid >= 0xFFFFFFFE)
-{
-sLog.outError("MO Transport guid overflow!! Can't continue, shutting down server. ");
-World::StopNow(ERROR_EXIT_CODE);
-}
-return m_hiMoTransGuid++;
-default:
-ASSERT(0);
-}
-
-ASSERT(0);
-return 0;
-}
-
-void ObjectMgr::LoadGameObjectLocales()
-{
-mGameObjectLocaleMap.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT entry,"
-"name_loc1,name_loc2,name_loc3,name_loc4,name_loc5,name_loc6,name_loc7,name_loc8,"
-"castbarcaption_loc1,castbarcaption_loc2,castbarcaption_loc3,castbarcaption_loc4,"
-"castbarcaption_loc5,castbarcaption_loc6,castbarcaption_loc7,castbarcaption_loc8 FROM locales_gameobject");
-
-if (!result)
-return;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 entry = fields[0].GetUInt32();
-
-GameObjectLocale& data = mGameObjectLocaleMap[entry];
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-std::string str = fields[i].GetString();
-AddLocaleString(str, LocaleConstant(i), data.Name);
-}
-
-for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
-{
-std::string str = fields[i + (TOTAL_LOCALES - 1)].GetString();
-AddLocaleString(str, LocaleConstant(i), data.CastBarCaption);
-}
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %lu gameobject locale strings", (unsigned long)mGameObjectLocaleMap.size());
-}
-
-struct SQLGameObjectLoader : public SQLStorageLoaderBase<SQLGameObjectLoader>
-{
-template<class D>
-void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
-{
-dst = D(sObjectMgr.GetScriptId(src));
-}
-};
-
-inline void CheckGOLockId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
-{
-if (sLockStore.LookupEntry(dataN))
-return;
-
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but lock (Id: %u) not found.",
-goInfo->id,goInfo->type,N,goInfo->door.lockId,goInfo->door.lockId);
-}
-
-inline void CheckGOLinkedTrapId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
-{
-if (GameObjectInfo const* trapInfo = sGOStorage.LookupEntry<GameObjectInfo>(dataN))
-{
-if (trapInfo->type != GAMEOBJECT_TYPE_TRAP)
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but GO (Entry %u) have not GAMEOBJECT_TYPE_TRAP (%u) type.",
-goInfo->id,goInfo->type,N,dataN,dataN,GAMEOBJECT_TYPE_TRAP);
-}
-}
-
-inline void CheckGOSpellId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
-{
-if (sSpellStore.LookupEntry(dataN))
-return;
-
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but Spell (Entry %u) not exist.",
-goInfo->id,goInfo->type,N,dataN,dataN);
-}
-
-inline void CheckAndFixGOChairHeightId(GameObjectInfo const* goInfo,uint32 const& dataN,uint32 N)
-{
-if (dataN <= (UNIT_STAND_STATE_SIT_HIGH_CHAIR-UNIT_STAND_STATE_SIT_LOW_CHAIR))
-return;
-
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but correct chair height in range 0..%i.",
-goInfo->id,goInfo->type,N,dataN,UNIT_STAND_STATE_SIT_HIGH_CHAIR-UNIT_STAND_STATE_SIT_LOW_CHAIR);
-
-// prevent client and server unexpected work
-const_cast<uint32&>(dataN) = 0;
-}
-
-inline void CheckGONoDamageImmuneId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
-{
-// 0/1 correct values
-if (dataN <= 1)
-return;
-
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but expected boolean (0/1) noDamageImmune field value.",
-goInfo->id,goInfo->type,N,dataN);
-}
-
-inline void CheckGOConsumable(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
-{
-// 0/1 correct values
-if (dataN <= 1)
-return;
-
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but expected boolean (0/1) consumable field value.",
-goInfo->id,goInfo->type,N,dataN);
-}
-
-void ObjectMgr::LoadGameobjectInfo()
-{
-SQLGameObjectLoader loader;
-loader.Load(sGOStorage);
-
-// some checks
-for (uint32 id = 1; id < sGOStorage.MaxEntry; id++)
-{
-GameObjectInfo const* goInfo = sGOStorage.LookupEntry<GameObjectInfo>(id);
-if (!goInfo)
-continue;
-
-// some GO types have unused go template, check goInfo->displayId at GO spawn data loading or ignore
-
-switch(goInfo->type)
-{
-case GAMEOBJECT_TYPE_DOOR: //0
-{
-if (goInfo->door.lockId)
-CheckGOLockId(goInfo,goInfo->door.lockId,1);
-CheckGONoDamageImmuneId(goInfo,goInfo->door.noDamageImmune,3);
-break;
-}
-case GAMEOBJECT_TYPE_BUTTON: //1
-{
-if (goInfo->button.lockId)
-CheckGOLockId(goInfo,goInfo->button.lockId,1);
-CheckGONoDamageImmuneId(goInfo,goInfo->button.noDamageImmune,4);
-break;
-}
-case GAMEOBJECT_TYPE_QUESTGIVER: //2
-{
-if (goInfo->questgiver.lockId)
-CheckGOLockId(goInfo,goInfo->questgiver.lockId,0);
-CheckGONoDamageImmuneId(goInfo,goInfo->questgiver.noDamageImmune,5);
-break;
-}
-case GAMEOBJECT_TYPE_CHEST: //3
-{
-if (goInfo->chest.lockId)
-CheckGOLockId(goInfo,goInfo->chest.lockId,0);
-
-CheckGOConsumable(goInfo,goInfo->chest.consumable,3);
-
-if (goInfo->chest.linkedTrapId) // linked trap
-CheckGOLinkedTrapId(goInfo,goInfo->chest.linkedTrapId,7);
-break;
-}
-case GAMEOBJECT_TYPE_TRAP: //6
-{
-if (goInfo->trap.lockId)
-CheckGOLockId(goInfo,goInfo->trap.lockId,0);
-break;
-}
-case GAMEOBJECT_TYPE_CHAIR: //7
-CheckAndFixGOChairHeightId(goInfo,goInfo->chair.height,1);
-break;
-case GAMEOBJECT_TYPE_SPELL_FOCUS: //8
-{
-if (goInfo->spellFocus.focusId)
-{
-if (!sSpellFocusObjectStore.LookupEntry(goInfo->spellFocus.focusId))
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data0=%u but SpellFocus (Id: %u) not exist.",
-id,goInfo->type,goInfo->spellFocus.focusId,goInfo->spellFocus.focusId);
-}
-
-if (goInfo->spellFocus.linkedTrapId) // linked trap
-CheckGOLinkedTrapId(goInfo,goInfo->spellFocus.linkedTrapId,2);
-break;
-}
-case GAMEOBJECT_TYPE_GOOBER: //10
-{
-if (goInfo->goober.lockId)
-CheckGOLockId(goInfo,goInfo->goober.lockId,0);
-
-CheckGOConsumable(goInfo,goInfo->goober.consumable,3);
-
-if (goInfo->goober.pageId) // pageId
-{
-if (!sPageTextStore.LookupEntry<PageText>(goInfo->goober.pageId))
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data7=%u but PageText (Entry %u) not exist.",
-id,goInfo->type,goInfo->goober.pageId,goInfo->goober.pageId);
-}
-CheckGONoDamageImmuneId(goInfo,goInfo->goober.noDamageImmune,11);
-if (goInfo->goober.linkedTrapId) // linked trap
-CheckGOLinkedTrapId(goInfo,goInfo->goober.linkedTrapId,12);
-break;
-}
-case GAMEOBJECT_TYPE_AREADAMAGE: //12
-{
-if (goInfo->areadamage.lockId)
-CheckGOLockId(goInfo,goInfo->areadamage.lockId,0);
-break;
-}
-case GAMEOBJECT_TYPE_CAMERA: //13
-{
-if (goInfo->camera.lockId)
-CheckGOLockId(goInfo,goInfo->camera.lockId,0);
-break;
-}
-case GAMEOBJECT_TYPE_MO_TRANSPORT: //15
-{
-if (goInfo->moTransport.taxiPathId)
-{
-if (goInfo->moTransport.taxiPathId >= sTaxiPathNodesByPath.size() || sTaxiPathNodesByPath[goInfo->moTransport.taxiPathId].empty())
-sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data0=%u but TaxiPath (Id: %u) not exist.",
-id,goInfo->type,goInfo->moTransport.taxiPathId,goInfo->moTransport.taxiPathId);
-}
-break;
-}
-case GAMEOBJECT_TYPE_SUMMONING_RITUAL: //18
-break;
-case GAMEOBJECT_TYPE_SPELLCASTER: //22
-{
-// always must have spell
-CheckGOSpellId(goInfo,goInfo->spellcaster.spellId,0);
-break;
-}
-case GAMEOBJECT_TYPE_FLAGSTAND: //24
-{
-if (goInfo->flagstand.lockId)
-CheckGOLockId(goInfo,goInfo->flagstand.lockId,0);
-CheckGONoDamageImmuneId(goInfo,goInfo->flagstand.noDamageImmune,5);
-break;
-}
-case GAMEOBJECT_TYPE_FISHINGHOLE: //25
-{
-if (goInfo->fishinghole.lockId)
-CheckGOLockId(goInfo,goInfo->fishinghole.lockId,4);
-break;
-}
-case GAMEOBJECT_TYPE_FLAGDROP: //26
-{
-if (goInfo->flagdrop.lockId)
-CheckGOLockId(goInfo,goInfo->flagdrop.lockId,0);
-CheckGONoDamageImmuneId(goInfo,goInfo->flagdrop.noDamageImmune,3);
-break;
-}
-case GAMEOBJECT_TYPE_BARBER_CHAIR: //32
-CheckAndFixGOChairHeightId(goInfo,goInfo->barberChair.chairheight,0);
-break;
-}
-}
-
-sLog.outString(">> Loaded %u game object templates", sGOStorage.RecordCount);
-sLog.outString();
-}
-
-void ObjectMgr::LoadExplorationBaseXP()
-{
-uint32 count = 0;
-QueryResult result = WorldDatabase.Query("SELECT level,basexp FROM exploration_basexp");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u BaseXP definitions", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-uint8 level = fields[0].GetUInt8();
-uint32 basexp = fields[1].GetUInt32();
-mBaseXPTable[level] = basexp;
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u BaseXP definitions", count);
-}
-
-uint32 ObjectMgr::GetBaseXP(uint8 level)
-{
-return mBaseXPTable[level] ? mBaseXPTable[level] : 0;
-}
-
-uint32 ObjectMgr::GetXPForLevel(uint8 level)
-{
-if (level < mPlayerXPperLevel.size())
-return mPlayerXPperLevel[level];
-return 0;
-}
-
-void ObjectMgr::LoadPetNames()
-{
-uint32 count = 0;
-QueryResult result = WorldDatabase.Query("SELECT word,entry,half FROM pet_name_generation");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u pet name parts", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-std::string word = fields[0].GetString();
-uint32 entry = fields[1].GetUInt32();
-bool half = fields[2].GetBool();
-if (half)
-PetHalfName1[entry].push_back(word);
-else
-PetHalfName0[entry].push_back(word);
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u pet name parts", count);
-}
-
-void ObjectMgr::LoadPetNumber()
-{
-QueryResult result = CharacterDatabase.Query("SELECT MAX(id) FROM character_pet");
-if (result)
-{
-Field *fields = result->Fetch();
-m_hiPetNumber = fields[0].GetUInt32()+1;
-}
-
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded the max pet number: %d", m_hiPetNumber-1);
-}
-
-std::string ObjectMgr::GeneratePetName(uint32 entry)
-{
-StringVector & list0 = PetHalfName0[entry];
-StringVector & list1 = PetHalfName1[entry];
-
-if (list0.empty() || list1.empty())
-{
-CreatureInfo const *cinfo = GetCreatureTemplate(entry);
-char* petname = GetPetName(cinfo->family, sWorld.GetDefaultDbcLocale());
-if (!petname)
-petname = cinfo->Name;
-return std::string(petname);
-}
-
-return *(list0.begin()+urand(0, list0.size()-1)) + *(list1.begin()+urand(0, list1.size()-1));
-}
-
-uint32 ObjectMgr::GeneratePetNumber()
-{
-return ++m_hiPetNumber;
-}
-
-void ObjectMgr::LoadCorpses()
-{
-uint32 count = 0;
-// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
-QueryResult result = CharacterDatabase.Query("SELECT position_x, position_y, position_z, orientation, map, displayId, itemCache, bytes1, bytes2, guild, flags, dynFlags, time, corpse_type, instance, phaseMask, guid, player FROM corpse WHERE corpse_type <> 0");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u corpses", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 guid = fields[16].GetUInt32();
-
-Corpse *corpse = new Corpse;
-if (!corpse->LoadFromDB(guid, fields))
-{
-delete corpse;
-continue;
-}
-
-sObjectAccessor.AddCorpse(corpse);
-
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u corpses", count);
-}
-
-void ObjectMgr::LoadReputationRewardRate()
-{
-m_RepRewardRateMap.clear(); // for reload case
-
-uint32 count = 0;
-QueryResult result = WorldDatabase.Query("SELECT faction, quest_rate, creature_rate, spell_rate FROM reputation_reward_rate");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `reputation_reward_rate`, table is empty!");
-return;
-}
-
-barGoLink bar((int)result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 factionId = fields[0].GetUInt32();
-
-RepRewardRate repRate;
-
-repRate.quest_rate = fields[1].GetFloat();
-repRate.creature_rate = fields[2].GetFloat();
-repRate.spell_rate = fields[3].GetFloat();
-
-FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
-if (!factionEntry)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_reward_rate`", factionId);
-continue;
-}
-
-if (repRate.quest_rate < 0.0f)
-{
-sLog.outErrorDb("Table reputation_reward_rate has quest_rate with invalid rate %f, skipping data for faction %u", repRate.quest_rate, factionId);
-continue;
-}
-
-if (repRate.creature_rate < 0.0f)
-{
-sLog.outErrorDb("Table reputation_reward_rate has creature_rate with invalid rate %f, skipping data for faction %u", repRate.creature_rate, factionId);
-continue;
-}
-
-if (repRate.spell_rate < 0.0f)
-{
-sLog.outErrorDb("Table reputation_reward_rate has spell_rate with invalid rate %f, skipping data for faction %u", repRate.spell_rate, factionId);
-continue;
-}
-
-m_RepRewardRateMap[factionId] = repRate;
-
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u reputation_reward_rate", count);
-}
-
-void ObjectMgr::LoadReputationOnKill()
-{
-// For reload case
-mRepOnKill.clear();
-
-uint32 count = 0;
-
-// 0 1 2
-QueryResult result = WorldDatabase.Query("SELECT creature_id, RewOnKillRepFaction1, RewOnKillRepFaction2,"
-// 3 4 5 6 7 8 9
-"IsTeamAward1, MaxStanding1, RewOnKillRepValue1, IsTeamAward2, MaxStanding2, RewOnKillRepValue2, TeamDependent "
-"FROM creature_onkill_reputation");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 creature award reputation definitions. DB table `creature_onkill_reputation` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 creature_id = fields[0].GetUInt32();
-
-ReputationOnKillEntry repOnKill;
-repOnKill.repfaction1 = fields[1].GetUInt32();
-repOnKill.repfaction2 = fields[2].GetUInt32();
-repOnKill.is_teamaward1 = fields[3].GetBool();
-repOnKill.reputation_max_cap1 = fields[4].GetUInt32();
-repOnKill.repvalue1 = fields[5].GetInt32();
-repOnKill.is_teamaward2 = fields[6].GetBool();
-repOnKill.reputation_max_cap2 = fields[7].GetUInt32();
-repOnKill.repvalue2 = fields[8].GetInt32();
-repOnKill.team_dependent = fields[9].GetUInt8();
-
-if (!GetCreatureTemplate(creature_id))
-{
-sLog.outErrorDb("Table `creature_onkill_reputation` have data for not existed creature entry (%u), skipped", creature_id);
-continue;
-}
-
-if (repOnKill.repfaction1)
-{
-FactionEntry const *factionEntry1 = sFactionStore.LookupEntry(repOnKill.repfaction1);
-if (!factionEntry1)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `creature_onkill_reputation`", repOnKill.repfaction1);
-continue;
-}
-}
-
-if (repOnKill.repfaction2)
-{
-FactionEntry const *factionEntry2 = sFactionStore.LookupEntry(repOnKill.repfaction2);
-if (!factionEntry2)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `creature_onkill_reputation`", repOnKill.repfaction2);
-continue;
-}
-}
-
-mRepOnKill[creature_id] = repOnKill;
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u creature award reputation definitions", count);
-}
-
-void ObjectMgr::LoadReputationSpilloverTemplate()
-{
-m_RepSpilloverTemplateMap.clear(); // for reload case
-
-uint32 count = 0;
-QueryResult result = WorldDatabase.Query("SELECT faction, faction1, rate_1, rank_1, faction2, rate_2, rank_2, faction3, rate_3, rank_3, faction4, rate_4, rank_4 FROM reputation_spillover_template");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `reputation_spillover_template`, table is empty!");
-return;
-}
-
-barGoLink bar((int)result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 factionId = fields[0].GetUInt32();
-
-RepSpilloverTemplate repTemplate;
-
-repTemplate.faction[0] = fields[1].GetUInt32();
-repTemplate.faction_rate[0] = fields[2].GetFloat();
-repTemplate.faction_rank[0] = fields[3].GetUInt32();
-repTemplate.faction[1] = fields[4].GetUInt32();
-repTemplate.faction_rate[1] = fields[5].GetFloat();
-repTemplate.faction_rank[1] = fields[6].GetUInt32();
-repTemplate.faction[2] = fields[7].GetUInt32();
-repTemplate.faction_rate[2] = fields[8].GetFloat();
-repTemplate.faction_rank[2] = fields[9].GetUInt32();
-repTemplate.faction[3] = fields[10].GetUInt32();
-repTemplate.faction_rate[3] = fields[11].GetFloat();
-repTemplate.faction_rank[3] = fields[12].GetUInt32();
-
-FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
-
-if (!factionEntry)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", factionId);
-continue;
-}
-
-if (factionEntry->team == 0)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u in `reputation_spillover_template` does not belong to any team, skipping", factionId);
-continue;
-}
-
-for (uint32 i = 0; i < MAX_SPILLOVER_FACTIONS; ++i)
-{
-if (repTemplate.faction[i])
-{
-FactionEntry const *factionSpillover = sFactionStore.LookupEntry(repTemplate.faction[i]);
-
-if (!factionSpillover)
-{
-sLog.outErrorDb("Spillover faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template` for faction %u, skipping", repTemplate.faction[i], factionId);
-continue;
-}
-
-if (factionSpillover->reputationListID < 0)
-{
-sLog.outErrorDb("Spillover faction (faction.dbc) %u for faction %u in `reputation_spillover_template` can not be listed for client, and then useless, skipping", repTemplate.faction[i], factionId);
-continue;
-}
-
-if (repTemplate.faction_rank[i] >= MAX_REPUTATION_RANK)
-{
-sLog.outErrorDb("Rank %u used in `reputation_spillover_template` for spillover faction %u is not valid, skipping", repTemplate.faction_rank[i], repTemplate.faction[i]);
-continue;
-}
-}
-}
-
-FactionEntry const *factionEntry0 = sFactionStore.LookupEntry(repTemplate.faction[0]);
-if (repTemplate.faction[0] && !factionEntry0)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[0]);
-continue;
-}
-FactionEntry const *factionEntry1 = sFactionStore.LookupEntry(repTemplate.faction[1]);
-if (repTemplate.faction[1] && !factionEntry1)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[1]);
-continue;
-}
-FactionEntry const *factionEntry2 = sFactionStore.LookupEntry(repTemplate.faction[2]);
-if (repTemplate.faction[2] && !factionEntry2)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[2]);
-continue;
-}
-FactionEntry const *factionEntry3 = sFactionStore.LookupEntry(repTemplate.faction[3]);
-if (repTemplate.faction[3] && !factionEntry3)
-{
-sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[3]);
-continue;
-}
-
-m_RepSpilloverTemplateMap[factionId] = repTemplate;
-
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u reputation_spillover_template", count);
-}
-
-void ObjectMgr::LoadPointsOfInterest()
-{
-mPointsOfInterest.clear(); // need for reload case
-
-uint32 count = 0;
-
-// 0 1 2 3 4 5 6
-QueryResult result = WorldDatabase.Query("SELECT entry, x, y, icon, flags, data, icon_name FROM points_of_interest");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 Points of Interest definitions. DB table `points_of_interest` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 point_id = fields[0].GetUInt32();
-
-PointOfInterest POI;
-POI.x = fields[1].GetFloat();
-POI.y = fields[2].GetFloat();
-POI.icon = fields[3].GetUInt32();
-POI.flags = fields[4].GetUInt32();
-POI.data = fields[5].GetUInt32();
-POI.icon_name = fields[6].GetString();
-
-if (!Trinity::IsValidMapCoord(POI.x,POI.y))
-{
-sLog.outErrorDb("Table `points_of_interest` (Entry: %u) have invalid coordinates (X: %f Y: %f), ignored.",point_id,POI.x,POI.y);
-continue;
-}
-
-mPointsOfInterest[point_id] = POI;
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u Points of Interest definitions", count);
-}
-
-void ObjectMgr::LoadQuestPOI()
-{
-mQuestPOIMap.clear(); // need for reload case
-
-uint32 count = 0;
-
-// 0 1 2 3 4 5 6 7
-QueryResult result = WorldDatabase.Query("SELECT questId, id, objIndex, mapid, WorldMapAreaId, FloorId, unk3, unk4 FROM quest_poi order by questId");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 quest POI definitions. DB table `quest_poi` is empty.");
-return;
-}
-
-// 0 1 2 3
-QueryResult points = WorldDatabase.PQuery("SELECT questId, id, x, y FROM quest_poi_points ORDER BY questId DESC, idx");
-
-barGoLink bar(result->GetRowCount() + (points ? points->GetRowCount() : 0));
-
-std::vector<std::vector<std::vector<QuestPOIPoint> > > POIs;
-
-if (points)
-{
-// The first result should have the highest questId
-Field *fields = points->Fetch();
-uint32 questId = fields[0].GetUInt32();
-POIs.resize(questId + 1);
-
-do
-{
-bar.step();
-
-Field *fields = points->Fetch();
-
-uint32 questId = fields[0].GetUInt32();
-uint32 id = fields[1].GetUInt32();
-int32 x = fields[2].GetInt32();
-int32 y = fields[3].GetInt32();
-
-if(POIs[questId].size() <= id + 1)
-POIs[questId].resize(id + 10);
-
-QuestPOIPoint point(x, y);
-POIs[questId][id].push_back(point);
-} while (points->NextRow());
-}
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 questId = fields[0].GetUInt32();
-uint32 id = fields[1].GetUInt32();
-int32 objIndex = fields[2].GetInt32();
-uint32 mapId = fields[3].GetUInt32();
-uint32 WorldMapAreaId = fields[4].GetUInt32();
-uint32 FloorId = fields[5].GetUInt32();
-uint32 unk3 = fields[6].GetUInt32();
-uint32 unk4 = fields[7].GetUInt32();
-
-QuestPOI POI(id, objIndex, mapId, WorldMapAreaId, FloorId, unk3, unk4);
-POI.points = POIs[questId][id];
-
-mQuestPOIMap[questId].push_back(POI);
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u quest POI definitions", count);
-}
-
-void ObjectMgr::LoadNPCSpellClickSpells()
-{
-uint32 count = 0;
-
-mSpellClickInfoMap.clear();
-// 0 1 2 3 4 5 6 7 8
-QueryResult result = WorldDatabase.Query("SELECT npc_entry, spell_id, quest_start, quest_start_active, quest_end, cast_flags, aura_required, aura_forbidden, user_type FROM npc_spellclick_spells");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 spellclick spells. DB table `npc_spellclick_spells` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-uint32 npc_entry = fields[0].GetUInt32();
-CreatureInfo const* cInfo = GetCreatureTemplate(npc_entry);
-if (!cInfo)
-{
-sLog.outErrorDb("Table npc_spellclick_spells references unknown creature_template %u. Skipping entry.", npc_entry);
-continue;
-}
-
-if (!(cInfo->npcflag & UNIT_NPC_FLAG_SPELLCLICK))
-const_cast<CreatureInfo*>(cInfo)->npcflag |= UNIT_NPC_FLAG_SPELLCLICK;
-
-uint32 spellid = fields[1].GetUInt32();
-SpellEntry const *spellinfo = sSpellStore.LookupEntry(spellid);
-if (!spellinfo)
-{
-sLog.outErrorDb("Table npc_spellclick_spells references unknown spellid %u. Skipping entry.", spellid);
-continue;
-}
-
-uint32 auraRequired = fields[6].GetUInt32();
-if (auraRequired)
-{
-SpellEntry const *aurReqInfo = sSpellStore.LookupEntry(auraRequired);
-if (!aurReqInfo)
-{
-sLog.outErrorDb("Table npc_spellclick_spells references unknown aura required %u. Skipping entry.", auraRequired);
-continue;
-}
-}
-
-uint32 auraForbidden = fields[7].GetUInt32();
-if (auraForbidden)
-{
-SpellEntry const *aurForInfo = sSpellStore.LookupEntry(auraForbidden);
-if (!aurForInfo)
-{
-sLog.outErrorDb("Table npc_spellclick_spells references unknown aura forbidden %u. Skipping entry.", auraForbidden);
-continue;
-}
-}
-
-uint32 quest_start = fields[2].GetUInt32();
-
-// quest might be 0 to enable spellclick independent of any quest
-if (quest_start)
-{
-if (mQuestTemplates.find(quest_start) == mQuestTemplates.end())
-{
-sLog.outErrorDb("Table npc_spellclick_spells references unknown start quest %u. Skipping entry.", quest_start);
-continue;
-}
-}
-
-bool quest_start_active = fields[3].GetBool();
-
-uint32 quest_end = fields[4].GetUInt32();
-// quest might be 0 to enable spellclick active infinity after start quest
-if (quest_end)
-{
-if (mQuestTemplates.find(quest_end) == mQuestTemplates.end())
-{
-sLog.outErrorDb("Table npc_spellclick_spells references unknown end quest %u. Skipping entry.", quest_end);
-continue;
-}
-}
-
-uint8 userType = fields[8].GetUInt8();
-if (userType >= SPELL_CLICK_USER_MAX)
-sLog.outErrorDb("Table npc_spellclick_spells references unknown user type %u. Skipping entry.", uint32(userType));
-
-uint8 castFlags = fields[5].GetUInt8();
-SpellClickInfo info;
-info.spellId = spellid;
-info.questStart = quest_start;
-info.questStartCanActive = quest_start_active;
-info.questEnd = quest_end;
-info.castFlags = castFlags;
-info.auraRequired = auraRequired;
-info.auraForbidden = auraForbidden;
-info.userType = SpellClickUserTypes(userType);
-mSpellClickInfoMap.insert(SpellClickInfoMap::value_type(npc_entry, info));
-
-// mark creature template as spell clickable
-const_cast<CreatureInfo*>(cInfo)->npcflag |= UNIT_NPC_FLAG_SPELLCLICK;
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u spellclick definitions", count);
-}
-
-void ObjectMgr::SaveCreatureRespawnTime(uint32 loguid, uint32 instance, time_t t)
-{
-// This function can be Called from various map threads concurrently
-{
-ACE_GUARD(ACE_Thread_Mutex, guard, m_CreatureRespawnTimesMtx);
-mCreatureRespawnTimes[MAKE_PAIR64(loguid,instance)] = t;
-}
-
-PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_CRESPAWNTIME);
-stmt->setUInt32(0, loguid);
-stmt->setUInt32(1, instance);
-WorldDatabase.Execute(stmt);
-
-if (t)
-{
-stmt = WorldDatabase.GetPreparedStatement(WORLD_ADD_CRESPAWNTIME);
-stmt->setUInt32(0, loguid);
-stmt->setUInt64(1, uint64(t));
-stmt->setUInt32(2, instance);
-WorldDatabase.Execute(stmt);
-}
-}
-
-void ObjectMgr::DeleteCreatureData(uint32 guid)
-{
-// remove mapid*cellid -> guid_set map
-CreatureData const* data = GetCreatureData(guid);
-if (data)
-RemoveCreatureFromGrid(guid, data);
-
-mCreatureDataMap.erase(guid);
-}
-
-void ObjectMgr::SaveGORespawnTime(uint32 loguid, uint32 instance, time_t t)
-{
-// This function can be called from different map threads concurrently
-{
-ACE_GUARD(ACE_Thread_Mutex, guard, m_CreatureRespawnTimesMtx);
-mGORespawnTimes[MAKE_PAIR64(loguid,instance)] = t;
-}
-
-WorldDatabase.PExecute("DELETE FROM gameobject_respawn WHERE guid = '%u' AND instance = '%u'", loguid, instance);
-if (t)
-WorldDatabase.PExecute("INSERT INTO gameobject_respawn VALUES ('%u', '" UI64FMTD "', '%u')", loguid, uint64(t), instance);
-}
-
-void ObjectMgr::DeleteRespawnTimeForInstance(uint32 instance)
-{
-// This function can be called from different map threads concurrently
-RespawnTimes::iterator next;
-
-{
-ACE_GUARD(ACE_Thread_Mutex, guard, m_GORespawnTimesMtx);
-for (RespawnTimes::iterator itr = mGORespawnTimes.begin(); itr != mGORespawnTimes.end(); itr = next)
-{
-next = itr;
-++next;
-
-if (GUID_HIPART(itr->first) == instance)
-mGORespawnTimes.erase(itr);
-}
-}
-{
-ACE_GUARD(ACE_Thread_Mutex, guard, m_CreatureRespawnTimesMtx);
-for (RespawnTimes::iterator itr = mCreatureRespawnTimes.begin(); itr != mCreatureRespawnTimes.end(); itr = next)
-{
-next = itr;
-++next;
-
-if (GUID_HIPART(itr->first) == instance)
-mCreatureRespawnTimes.erase(itr);
-}
-}
-WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE instance = '%u'", instance);
-WorldDatabase.PExecute("DELETE FROM gameobject_respawn WHERE instance = '%u'", instance);
-}
-
-void ObjectMgr::DeleteGOData(uint32 guid)
-{
-// remove mapid*cellid -> guid_set map
-GameObjectData const* data = GetGOData(guid);
-if (data)
-RemoveGameobjectFromGrid(guid, data);
-
-mGameObjectDataMap.erase(guid);
-}
-
-void ObjectMgr::AddCorpseCellData(uint32 mapid, uint32 cellid, uint32 player_guid, uint32 instance)
-{
-// corpses are always added to spawn mode 0 and they are spawned by their instance id
-CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(mapid,0)][cellid];
-cell_guids.corpses[player_guid] = instance;
-}
-
-void ObjectMgr::DeleteCorpseCellData(uint32 mapid, uint32 cellid, uint32 player_guid)
-{
-// corpses are always added to spawn mode 0 and they are spawned by their instance id
-CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(mapid,0)][cellid];
-cell_guids.corpses.erase(player_guid);
-}
-
-void ObjectMgr::LoadQuestRelationsHelper(QuestRelations& map, std::string table, bool starter, bool go)
-{
-map.clear(); // need for reload case
-
-uint32 count = 0;
-
-QueryResult result = WorldDatabase.PQuery("SELECT id, quest, pool_entry FROM %s qr LEFT JOIN pool_quest pq ON qr.quest = pq.entry", table.c_str());
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded 0 quest relations from %s, table is empty.", table.c_str());
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-PooledQuestRelation* poolRelationMap = go ? &sPoolMgr.mQuestGORelation : &sPoolMgr.mQuestCreatureRelation;
-if (starter)
-poolRelationMap->clear();
-
-do
-{
-bar.step();
-
-uint32 id = result->Fetch()[0].GetUInt32();
-uint32 quest = result->Fetch()[1].GetUInt32();
-uint32 poolId = result->Fetch()[2].GetUInt32();
-
-if (mQuestTemplates.find(quest) == mQuestTemplates.end())
-{
-sLog.outErrorDb("Table `%s: Quest %u listed for entry %u does not exist.", table.c_str(), quest, id);
-continue;
-}
-
-if (!poolId || !starter)
-map.insert(QuestRelations::value_type(id, quest));
-else if (starter)
-poolRelationMap->insert(PooledQuestRelation::value_type(quest, id));
-
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u quest relations from %s", count, table.c_str());
-}
-
-void ObjectMgr::LoadGameobjectQuestRelations()
-{
-LoadQuestRelationsHelper(mGOQuestRelations, "gameobject_questrelation", true, true);
-
-for (QuestRelations::iterator itr = mGOQuestRelations.begin(); itr != mGOQuestRelations.end(); ++itr)
-{
-GameObjectInfo const* goInfo = GetGameObjectInfo(itr->first);
-if (!goInfo)
-sLog.outErrorDb("Table `gameobject_questrelation` have data for not existed gameobject entry (%u) and existed quest %u",itr->first,itr->second);
-else if (goInfo->type != GAMEOBJECT_TYPE_QUESTGIVER)
-sLog.outErrorDb("Table `gameobject_questrelation` have data gameobject entry (%u) for quest %u, but GO is not GAMEOBJECT_TYPE_QUESTGIVER",itr->first,itr->second);
-}
-}
-
-void ObjectMgr::LoadGameobjectInvolvedRelations()
-{
-LoadQuestRelationsHelper(mGOQuestInvolvedRelations, "gameobject_involvedrelation", false, true);
-
-for (QuestRelations::iterator itr = mGOQuestInvolvedRelations.begin(); itr != mGOQuestInvolvedRelations.end(); ++itr)
-{
-GameObjectInfo const* goInfo = GetGameObjectInfo(itr->first);
-if (!goInfo)
-sLog.outErrorDb("Table `gameobject_involvedrelation` have data for not existed gameobject entry (%u) and existed quest %u",itr->first,itr->second);
-else if (goInfo->type != GAMEOBJECT_TYPE_QUESTGIVER)
-sLog.outErrorDb("Table `gameobject_involvedrelation` have data gameobject entry (%u) for quest %u, but GO is not GAMEOBJECT_TYPE_QUESTGIVER",itr->first,itr->second);
-}
-}
-
-void ObjectMgr::LoadCreatureQuestRelations()
-{
-LoadQuestRelationsHelper(mCreatureQuestRelations, "creature_questrelation", true, false);
-
-for (QuestRelations::iterator itr = mCreatureQuestRelations.begin(); itr != mCreatureQuestRelations.end(); ++itr)
-{
-CreatureInfo const* cInfo = GetCreatureTemplate(itr->first);
-if (!cInfo)
-sLog.outErrorDb("Table `creature_questrelation` have data for not existed creature entry (%u) and existed quest %u",itr->first,itr->second);
-else if (!(cInfo->npcflag & UNIT_NPC_FLAG_QUESTGIVER))
-sLog.outErrorDb("Table `creature_questrelation` has creature entry (%u) for quest %u, but npcflag does not include UNIT_NPC_FLAG_QUESTGIVER",itr->first,itr->second);
-}
-}
-
-void ObjectMgr::LoadCreatureInvolvedRelations()
-{
-LoadQuestRelationsHelper(mCreatureQuestInvolvedRelations, "creature_involvedrelation", false, false);
-
-for (QuestRelations::iterator itr = mCreatureQuestInvolvedRelations.begin(); itr != mCreatureQuestInvolvedRelations.end(); ++itr)
-{
-CreatureInfo const* cInfo = GetCreatureTemplate(itr->first);
-if (!cInfo)
-sLog.outErrorDb("Table `creature_involvedrelation` have data for not existed creature entry (%u) and existed quest %u",itr->first,itr->second);
-else if (!(cInfo->npcflag & UNIT_NPC_FLAG_QUESTGIVER))
-sLog.outErrorDb("Table `creature_involvedrelation` has creature entry (%u) for quest %u, but npcflag does not include UNIT_NPC_FLAG_QUESTGIVER",itr->first,itr->second);
-}
-}
-
-void ObjectMgr::LoadReservedPlayersNames()
-{
-m_ReservedNames.clear(); // need for reload case
-
-QueryResult result = WorldDatabase.Query("SELECT name FROM reserved_name");
-
-uint32 count = 0;
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-
-sLog.outString();
-sLog.outString(">> Loaded %u reserved player names", count);
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-Field* fields;
-do
-{
-bar.step();
-fields = result->Fetch();
-std::string name= fields[0].GetString();
-
-std::wstring wstr;
-if (!Utf8toWStr (name,wstr))
-{
-sLog.outError("Table `reserved_name` have invalid name: %s", name.c_str());
-continue;
-}
-
-wstrToLower(wstr);
-
-m_ReservedNames.insert(wstr);
-++count;
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u reserved player names", count);
-}
-
-bool ObjectMgr::IsReservedName(const std::string& name) const
-{
-std::wstring wstr;
-if (!Utf8toWStr (name,wstr))
-return false;
-
-wstrToLower(wstr);
-
-return m_ReservedNames.find(wstr) != m_ReservedNames.end();
-}
-
-enum LanguageType
-{
-LT_BASIC_LATIN = 0x0000,
-LT_EXTENDEN_LATIN = 0x0001,
-LT_CYRILLIC = 0x0002,
-LT_EAST_ASIA = 0x0004,
-LT_ANY = 0xFFFF
-};
-
-static LanguageType GetRealmLanguageType(bool create)
-{
-switch(sWorld.getIntConfig(CONFIG_REALM_ZONE))
-{
-case REALM_ZONE_UNKNOWN: // any language
-case REALM_ZONE_DEVELOPMENT:
-case REALM_ZONE_TEST_SERVER:
-case REALM_ZONE_QA_SERVER:
-return LT_ANY;
-case REALM_ZONE_UNITED_STATES: // extended-Latin
-case REALM_ZONE_OCEANIC:
-case REALM_ZONE_LATIN_AMERICA:
-case REALM_ZONE_ENGLISH:
-case REALM_ZONE_GERMAN:
-case REALM_ZONE_FRENCH:
-case REALM_ZONE_SPANISH:
-return LT_EXTENDEN_LATIN;
-case REALM_ZONE_KOREA: // East-Asian
-case REALM_ZONE_TAIWAN:
-case REALM_ZONE_CHINA:
-return LT_EAST_ASIA;
-case REALM_ZONE_RUSSIAN: // Cyrillic
-return LT_CYRILLIC;
-default:
-return create ? LT_BASIC_LATIN : LT_ANY; // basic-Latin at create, any at login
-}
-}
-
-bool isValidString(std::wstring wstr, uint32 strictMask, bool numericOrSpace, bool create = false)
-{
-if (strictMask == 0) // any language, ignore realm
-{
-if (isExtendedLatinString(wstr,numericOrSpace))
-return true;
-if (isCyrillicString(wstr,numericOrSpace))
-return true;
-if (isEastAsianString(wstr,numericOrSpace))
-return true;
-return false;
-}
-
-if (strictMask & 0x2) // realm zone specific
-{
-LanguageType lt = GetRealmLanguageType(create);
-if (lt & LT_EXTENDEN_LATIN)
-if (isExtendedLatinString(wstr,numericOrSpace))
-return true;
-if (lt & LT_CYRILLIC)
-if (isCyrillicString(wstr,numericOrSpace))
-return true;
-if (lt & LT_EAST_ASIA)
-if (isEastAsianString(wstr,numericOrSpace))
-return true;
-}
-
-if (strictMask & 0x1) // basic Latin
-{
-if (isBasicLatinString(wstr,numericOrSpace))
-return true;
-}
-
-return false;
-}
-
-uint8 ObjectMgr::CheckPlayerName(const std::string& name, bool create)
-{
-std::wstring wname;
-if (!Utf8toWStr(name,wname))
-return CHAR_NAME_INVALID_CHARACTER;
-
-if (wname.size() > MAX_PLAYER_NAME)
-return CHAR_NAME_TOO_LONG;
-
-uint32 minName = sWorld.getIntConfig(CONFIG_MIN_PLAYER_NAME);
-if (wname.size() < minName)
-return CHAR_NAME_TOO_SHORT;
-
-uint32 strictMask = sWorld.getIntConfig(CONFIG_STRICT_PLAYER_NAMES);
-if (!isValidString(wname,strictMask,false,create))
-return CHAR_NAME_MIXED_LANGUAGES;
-
-return CHAR_NAME_SUCCESS;
-}
-
-bool ObjectMgr::IsValidCharterName(const std::string& name)
-{
-std::wstring wname;
-if (!Utf8toWStr(name,wname))
-return false;
-
-if (wname.size() > MAX_CHARTER_NAME)
-return false;
-
-uint32 minName = sWorld.getIntConfig(CONFIG_MIN_CHARTER_NAME);
-if (wname.size() < minName)
-return false;
-
-uint32 strictMask = sWorld.getIntConfig(CONFIG_STRICT_CHARTER_NAMES);
-
-return isValidString(wname,strictMask,true);
-}
-
-PetNameInvalidReason ObjectMgr::CheckPetName(const std::string& name)
-{
-std::wstring wname;
-if (!Utf8toWStr(name,wname))
-return PET_NAME_INVALID;
-
-if (wname.size() > MAX_PET_NAME)
-return PET_NAME_TOO_LONG;
-
-uint32 minName = sWorld.getIntConfig(CONFIG_MIN_PET_NAME);
-if (wname.size() < minName)
-return PET_NAME_TOO_SHORT;
-
-uint32 strictMask = sWorld.getIntConfig(CONFIG_STRICT_PET_NAMES);
-if (!isValidString(wname,strictMask,false))
-return PET_NAME_MIXED_LANGUAGES;
-
-return PET_NAME_SUCCESS;
-}
-
-void ObjectMgr::LoadGameObjectForQuests()
-{
-mGameObjectForQuestSet.clear(); // need for reload case
-
-if (!sGOStorage.MaxEntry)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 GameObjects for quests");
-return;
-}
-
-barGoLink bar(sGOStorage.MaxEntry - 1);
-uint32 count = 0;
-
-// collect GO entries for GO that must activated
-for (uint32 go_entry = 1; go_entry < sGOStorage.MaxEntry; ++go_entry)
-{
-bar.step();
-GameObjectInfo const* goInfo = sGOStorage.LookupEntry<GameObjectInfo>(go_entry);
-if (!goInfo)
-continue;
-
-switch(goInfo->type)
-{
-// scan GO chest with loot including quest items
-case GAMEOBJECT_TYPE_CHEST:
-{
-uint32 loot_id = goInfo->GetLootId();
-
-// find quest loot for GO
-if (goInfo->chest.questId || LootTemplates_Gameobject.HaveQuestLootFor(loot_id))
-{
-mGameObjectForQuestSet.insert(go_entry);
-++count;
-}
-break;
-}
-case GAMEOBJECT_TYPE_GENERIC:
-{
-if (goInfo->_generic.questID) //quests objects
-{
-mGameObjectForQuestSet.insert(go_entry);
-count++;
-}
-break;
-}
-case GAMEOBJECT_TYPE_GOOBER:
-{
-if (goInfo->goober.questId) //quests objects
-{
-mGameObjectForQuestSet.insert(go_entry);
-count++;
-}
-break;
-}
-default:
-break;
-}
-}
-
-sLog.outString();
-sLog.outString(">> Loaded %u GameObjects for quests", count);
-}
-
-bool ObjectMgr::LoadTrinityStrings(char const* table, int32 min_value, int32 max_value)
-{
-int32 start_value = min_value;
-int32 end_value = max_value;
-// some string can have negative indexes range
-if (start_value < 0)
-{
-if (end_value >= start_value)
-{
-sLog.outErrorDb("Table '%s' attempt loaded with invalid range (%d - %d), strings not loaded.",table,min_value,max_value);
-return false;
-}
-
-// real range (max+1,min+1) exaple: (-10,-1000) -> -999...-10+1
-std::swap(start_value,end_value);
-++start_value;
-++end_value;
-}
-else
-{
-if (start_value >= end_value)
-{
-sLog.outErrorDb("Table '%s' attempt loaded with invalid range (%d - %d), strings not loaded.",table,min_value,max_value);
-return false;
-}
-}
-
-// cleanup affected map part for reloading case
-for (TrinityStringLocaleMap::iterator itr = mTrinityStringLocaleMap.begin(); itr != mTrinityStringLocaleMap.end();)
-{
-if (itr->first >= start_value && itr->first < end_value)
-mTrinityStringLocaleMap.erase(itr++);
-else
-++itr;
-}
-
-QueryResult result = WorldDatabase.PQuery("SELECT entry,content_default,content_loc1,content_loc2,content_loc3,content_loc4,content_loc5,content_loc6,content_loc7,content_loc8 FROM %s",table);
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-if (min_value == MIN_TRINITY_STRING_ID) // error only in case internal strings
-sLog.outErrorDb(">> Loaded 0 trinity strings. DB table `%s` is empty. Cannot continue.",table);
-else
-sLog.outString(">> Loaded 0 string templates. DB table `%s` is empty.",table);
-return false;
-}
-
-uint32 count = 0;
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-Field *fields = result->Fetch();
-bar.step();
-
-int32 entry = fields[0].GetInt32();
-
-if (entry == 0)
-{
-sLog.outErrorDb("Table `%s` contain reserved entry 0, ignored.",table);
-continue;
-}
-else if (entry < start_value || entry >= end_value)
-{
-sLog.outErrorDb("Table `%s` contain entry %i out of allowed range (%d - %d), ignored.",table,entry,min_value,max_value);
-continue;
-}
-
-TrinityStringLocale& data = mTrinityStringLocaleMap[entry];
-
-if (data.Content.size() > 0)
-{
-sLog.outErrorDb("Table `%s` contain data for already loaded entry %i (from another table?), ignored.",table,entry);
-continue;
-}
-
-data.Content.resize(1);
-++count;
-
-for (uint8 i = 0; i < TOTAL_LOCALES; ++i)
-{
-std::string str = fields[i + 1].GetString();
-AddLocaleString(str, LocaleConstant(i), data.Content);
-}
-} while (result->NextRow());
-
-sLog.outString();
-if (min_value == MIN_TRINITY_STRING_ID)
-sLog.outString(">> Loaded %u Trinity strings from table %s", count,table);
-else
-sLog.outString(">> Loaded %u string templates from %s", count,table);
-
-return true;
-}
-
-const char *ObjectMgr::GetTrinityString(int32 entry, LocaleConstant locale_idx) const
-{
-if (TrinityStringLocale const *msl = GetTrinityStringLocale(entry))
-{
-if (msl->Content.size() > size_t(locale_idx) && !msl->Content[locale_idx].empty())
-return msl->Content[locale_idx].c_str();
-
-return msl->Content[DEFAULT_LOCALE].c_str();
-}
-
-if (entry > 0)
-sLog.outErrorDb("Entry %i not found in `trinity_string` table.",entry);
-else
-sLog.outErrorDb("Trinity string entry %i not found in DB.",entry);
-return "<error>";
-}
-
-void ObjectMgr::LoadFishingBaseSkillLevel()
-{
-mFishingBaseForArea.clear(); // for reload case
-
-uint32 count = 0;
-QueryResult result = WorldDatabase.Query("SELECT entry,skill FROM skill_fishing_base_level");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `skill_fishing_base_level`, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-uint32 entry = fields[0].GetUInt32();
-int32 skill = fields[1].GetInt32();
-
-AreaTableEntry const* fArea = GetAreaEntryByAreaID(entry);
-if (!fArea)
-{
-sLog.outErrorDb("AreaId %u defined in `skill_fishing_base_level` does not exist",entry);
-continue;
-}
-
-mFishingBaseForArea[entry] = skill;
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u areas for fishing base skill level", count);
-}
-
-bool ObjectMgr::CheckDeclinedNames(std::wstring mainpart, DeclinedName const& names)
-{
-for (uint8 i =0; i < MAX_DECLINED_NAME_CASES; ++i)
-{
-std::wstring wname;
-if (!Utf8toWStr(names.name[i],wname))
-return false;
-
-if (mainpart != GetMainPartOfName(wname,i+1))
-return false;
-}
-return true;
-}
-
-uint32 ObjectMgr::GetAreaTriggerScriptId(uint32 trigger_id)
-{
-AreaTriggerScriptMap::const_iterator i = mAreaTriggerScripts.find(trigger_id);
-if (i!= mAreaTriggerScripts.end())
-return i->second;
-return 0;
-}
-
-SpellScriptsBounds ObjectMgr::GetSpellScriptsBounds(uint32 spell_id)
-{
-return SpellScriptsBounds(mSpellScripts.lower_bound(spell_id),mSpellScripts.upper_bound(spell_id));
-}
-
-SkillRangeType GetSkillRangeType(SkillLineEntry const *pSkill, bool racial)
-{
-switch(pSkill->categoryId)
-{
-case SKILL_CATEGORY_LANGUAGES: return SKILL_RANGE_LANGUAGE;
-case SKILL_CATEGORY_WEAPON:
-if (pSkill->id != SKILL_FIST_WEAPONS)
-return SKILL_RANGE_LEVEL;
-else
-return SKILL_RANGE_MONO;
-case SKILL_CATEGORY_ARMOR:
-case SKILL_CATEGORY_CLASS:
-if (pSkill->id != SKILL_LOCKPICKING)
-return SKILL_RANGE_MONO;
-else
-return SKILL_RANGE_LEVEL;
-case SKILL_CATEGORY_SECONDARY:
-case SKILL_CATEGORY_PROFESSION:
-// not set skills for professions and racial abilities
-if (IsProfessionSkill(pSkill->id))
-return SKILL_RANGE_RANK;
-else if (racial)
-return SKILL_RANGE_NONE;
-else
-return SKILL_RANGE_MONO;
-default:
-case SKILL_CATEGORY_ATTRIBUTES: //not found in dbc
-case SKILL_CATEGORY_GENERIC: //only GENERIC(DND)
-return SKILL_RANGE_NONE;
-}
-}
-
-void ObjectMgr::LoadGameTele()
-{
-m_GameTeleMap.clear(); // for reload case
-
-uint32 count = 0;
-QueryResult result = WorldDatabase.Query("SELECT id, position_x, position_y, position_z, orientation, map, name FROM game_tele");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `game_tele`, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint32 id = fields[0].GetUInt32();
-
-GameTele gt;
-
-gt.position_x = fields[1].GetFloat();
-gt.position_y = fields[2].GetFloat();
-gt.position_z = fields[3].GetFloat();
-gt.orientation = fields[4].GetFloat();
-gt.mapId = fields[5].GetUInt32();
-gt.name = fields[6].GetString();
-
-if (!MapManager::IsValidMapCoord(gt.mapId,gt.position_x,gt.position_y,gt.position_z,gt.orientation))
-{
-sLog.outErrorDb("Wrong position for id %u (name: %s) in `game_tele` table, ignoring.",id,gt.name.c_str());
-continue;
-}
-
-if (!Utf8toWStr(gt.name,gt.wnameLow))
-{
-sLog.outErrorDb("Wrong UTF8 name for id %u in `game_tele` table, ignoring.",id);
-continue;
-}
-
-wstrToLower(gt.wnameLow);
-
-m_GameTeleMap[id] = gt;
-
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u GameTeleports", count);
-}
-
-GameTele const* ObjectMgr::GetGameTele(const std::string& name) const
-{
-// explicit name case
-std::wstring wname;
-if (!Utf8toWStr(name,wname))
-return false;
-
-// converting string that we try to find to lower case
-wstrToLower(wname);
-
-// Alternative first GameTele what contains wnameLow as substring in case no GameTele location found
-const GameTele* alt = NULL;
-for (GameTeleMap::const_iterator itr = m_GameTeleMap.begin(); itr != m_GameTeleMap.end(); ++itr)
-{
-if (itr->second.wnameLow == wname)
-return &itr->second;
-else if (alt == NULL && itr->second.wnameLow.find(wname) != std::wstring::npos)
-alt = &itr->second;
-}
-
-return alt;
-}
-
-bool ObjectMgr::AddGameTele(GameTele& tele)
-{
-// find max id
-uint32 new_id = 0;
-for (GameTeleMap::const_iterator itr = m_GameTeleMap.begin(); itr != m_GameTeleMap.end(); ++itr)
-if (itr->first > new_id)
-new_id = itr->first;
-
-// use next
-++new_id;
-
-if (!Utf8toWStr(tele.name,tele.wnameLow))
-return false;
-
-wstrToLower(tele.wnameLow);
-
-m_GameTeleMap[new_id] = tele;
-
-WorldDatabase.PExecute("INSERT INTO game_tele (id,position_x,position_y,position_z,orientation,map,name) VALUES (%u,%f,%f,%f,%f,%d,'%s')",
-new_id,tele.position_x,tele.position_y,tele.position_z,tele.orientation,tele.mapId,tele.name.c_str());
-return true;
-}
-
-bool ObjectMgr::DeleteGameTele(const std::string& name)
-{
-// explicit name case
-std::wstring wname;
-if (!Utf8toWStr(name,wname))
-return false;
-
-// converting string that we try to find to lower case
-wstrToLower(wname);
-
-for (GameTeleMap::iterator itr = m_GameTeleMap.begin(); itr != m_GameTeleMap.end(); ++itr)
-{
-if (itr->second.wnameLow == wname)
-{
-WorldDatabase.PExecute("DELETE FROM game_tele WHERE name = '%s'",itr->second.name.c_str());
-m_GameTeleMap.erase(itr);
-return true;
-}
-}
-
-return false;
-}
-
-void ObjectMgr::LoadMailLevelRewards()
-{
-m_mailLevelRewardMap.clear(); // for reload case
-
-uint32 count = 0;
-QueryResult result = WorldDatabase.Query("SELECT level, raceMask, mailTemplateId, senderEntry FROM mail_level_reward");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `mail_level_reward`, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-do
-{
-bar.step();
-
-Field *fields = result->Fetch();
-
-uint8 level = fields[0].GetUInt8();
-uint32 raceMask = fields[1].GetUInt32();
-uint32 mailTemplateId = fields[2].GetUInt32();
-uint32 senderEntry = fields[3].GetUInt32();
-
-if (level > MAX_LEVEL)
-{
-sLog.outErrorDb("Table `mail_level_reward` have data for level %u that more supported by client (%u), ignoring.",level,MAX_LEVEL);
-continue;
-}
-
-if (!(raceMask & RACEMASK_ALL_PLAYABLE))
-{
-sLog.outErrorDb("Table `mail_level_reward` have raceMask (%u) for level %u that not include any player races, ignoring.",raceMask,level);
-continue;
-}
-
-if (!sMailTemplateStore.LookupEntry(mailTemplateId))
-{
-sLog.outErrorDb("Table `mail_level_reward` have invalid mailTemplateId (%u) for level %u that invalid not include any player races, ignoring.",mailTemplateId,level);
-continue;
-}
-
-if (!GetCreatureTemplateStore(senderEntry))
-{
-sLog.outErrorDb("Table `mail_level_reward` have not existed sender creature entry (%u) for level %u that invalid not include any player races, ignoring.",senderEntry,level);
-continue;
-}
-
-m_mailLevelRewardMap[level].push_back(MailLevelReward(raceMask,mailTemplateId,senderEntry));
-
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u level dependent mail rewards,", count);
-}
-
-bool ObjectMgr::AddSpellToTrainer(uint32 entry, uint32 spell, Field *fields, std::set<uint32> *skip_trainers, std::set<uint32> *talentIds)
-{
-if (entry >= TRINITY_TRAINER_START_REF)
-return false;
-
-CreatureInfo const* cInfo = GetCreatureTemplate(entry);
-if (!cInfo)
-{
-sLog.outErrorDb("Table `npc_trainer` have entry for not existed creature template (Entry: %u), ignore", entry);
-return false;
-}
-
-if (!(cInfo->npcflag & UNIT_NPC_FLAG_TRAINER))
-{
-if (skip_trainers->find(entry) == skip_trainers->end())
-{
-sLog.outErrorDb("Table `npc_trainer` have data for not creature template (Entry: %u) without trainer flag, ignore", entry);
-skip_trainers->insert(entry);
-}
-return false;
-}
-
-SpellEntry const *spellinfo = sSpellStore.LookupEntry(spell);
-if (!spellinfo)
-{
-sLog.outErrorDb("Table `npc_trainer` for Trainer (Entry: %u) has non existing spell %u, ignore", entry,spell);
-return false;
-}
-
-if (!SpellMgr::IsSpellValid(spellinfo))
-{
-sLog.outErrorDb("Table `npc_trainer` for Trainer (Entry: %u) has broken learning spell %u, ignore", entry, spell);
-return false;
-}
-
-if (GetTalentSpellCost(spell))
-{
-if (talentIds->count(spell) == 0)
-{
-sLog.outErrorDb("Table `npc_trainer` has talent as learning spell %u, ignore", spell);
-talentIds->insert(spell);
-}
-return false;
-}
-
-TrainerSpellData& data = m_mCacheTrainerSpellMap[entry];
-
-TrainerSpell& trainerSpell = data.spellList[spell];
-trainerSpell.spell = spell;
-trainerSpell.spellCost = fields[2].GetUInt32();
-trainerSpell.reqSkill = fields[3].GetUInt32();
-trainerSpell.reqSkillValue = fields[4].GetUInt32();
-trainerSpell.reqLevel = fields[5].GetUInt32();
-
-if (!trainerSpell.reqLevel)
-trainerSpell.reqLevel = spellinfo->spellLevel;
-
-// calculate learned spell for profession case when stored cast-spell
-trainerSpell.learnedSpell[0] = spell;
-for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-{
-if (spellinfo->Effect[i] != SPELL_EFFECT_LEARN_SPELL)
-continue;
-if (trainerSpell.learnedSpell[0] == spell)
-trainerSpell.learnedSpell[0] = 0;
-// player must be able to cast spell on himself
-if (spellinfo->EffectImplicitTargetA[i] != 0 && spellinfo->EffectImplicitTargetA[i] != TARGET_UNIT_TARGET_ALLY
-&& spellinfo->EffectImplicitTargetA[i] != TARGET_UNIT_TARGET_ANY && spellinfo->EffectImplicitTargetA[i] != TARGET_UNIT_CASTER)
-{
-sLog.outErrorDb("Table `npc_trainer` has spell %u for trainer entry %u with learn effect which has incorrect target type, ignoring learn effect!", spell, entry);
-continue;
-}
-
-trainerSpell.learnedSpell[i] = spellinfo->EffectTriggerSpell[i];
-}
-
-for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-{
-if (!trainerSpell.learnedSpell[i])
-continue;
-if (SpellMgr::IsProfessionSpell(trainerSpell.learnedSpell[i]))
-{
-data.trainerType = 2;
-break;
-}
-}
-return true;
-}
-int ObjectMgr::LoadReferenceTrainer(uint32 trainer, int32 spell, std::set<uint32> *skip_trainers, std::set<uint32> *talentIds)
-{
-QueryResult result = WorldDatabase.PQuery("SELECT entry, spell,spellcost,reqskill,reqskillvalue,reqlevel FROM npc_trainer WHERE entry='%d'", spell);
-if (!result)
-return 0;
-
-uint32 count = 0;
-do
-{
-
-Field* fields = result->Fetch();
-
-int32 spell = fields[1].GetInt32();
-if (spell < 0)
-count += this->LoadReferenceTrainer(trainer, -spell, skip_trainers, talentIds);
-else if (this->AddSpellToTrainer(trainer, uint32(spell), fields, skip_trainers, talentIds))
-++count;
-} while (result->NextRow());
-
-return count;
-}
-
-void ObjectMgr::LoadTrainerSpell()
-{
-// For reload case
-for (CacheTrainerSpellMap::iterator itr = m_mCacheTrainerSpellMap.begin(); itr != m_mCacheTrainerSpellMap.end(); ++itr)
-itr->second.Clear();
-m_mCacheTrainerSpellMap.clear();
-
-std::set<uint32> skip_trainers;
-
-QueryResult result = WorldDatabase.Query("SELECT entry, spell,spellcost,reqskill,reqskillvalue,reqlevel FROM npc_trainer");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `npc_trainer`, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-std::set<uint32> talentIds;
-
-uint32 count = 0;
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-
-uint32 entry = fields[0].GetUInt32();
-int32 spell = fields[1].GetInt32();
-if (spell < 0)
-count += this->LoadReferenceTrainer(entry, -spell, &skip_trainers, &talentIds);
-else if (this->AddSpellToTrainer(entry, uint32(spell), fields, &skip_trainers, &talentIds))
-++count;
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %d Trainers", count);
-}
-
-int ObjectMgr::LoadReferenceVendor(int32 vendor, int32 item, std::set<uint32> *skip_vendors)
-{
-// find all items from the reference vendor
-QueryResult result = WorldDatabase.PQuery("SELECT item, maxcount, incrtime, ExtendedCost FROM npc_vendor WHERE entry='%d' ORDER BY slot ASC", item);
-if (!result)
-return 0;
-
-uint32 count = 0;
-do
-{
-Field* fields = result->Fetch();
-
-int32 item_id = fields[0].GetInt32();
-
-// if item is a negative, its a reference
-if (item_id < 0)
-count += LoadReferenceVendor(vendor, -item_id, skip_vendors);
-else
-{
-int32 maxcount = fields[1].GetInt32();
-uint32 incrtime = fields[2].GetUInt32();
-uint32 ExtendedCost = fields[3].GetUInt32();
-
-if (!IsVendorItemValid(vendor, item_id, maxcount, incrtime, ExtendedCost, NULL, skip_vendors))
-continue;
-
-VendorItemData& vList = m_mCacheVendorItemMap[vendor];
-
-vList.AddItem(item_id, maxcount, incrtime, ExtendedCost);
-++count;
-}
-
-} while (result->NextRow());
-
-return count;
-}
-
-void ObjectMgr::LoadVendors()
-{
-// For reload case
-for (CacheVendorItemMap::iterator itr = m_mCacheVendorItemMap.begin(); itr != m_mCacheVendorItemMap.end(); ++itr)
-itr->second.Clear();
-m_mCacheVendorItemMap.clear();
-
-std::set<uint32> skip_vendors;
-
-QueryResult result = WorldDatabase.Query("SELECT entry, item, maxcount, incrtime, ExtendedCost FROM npc_vendor ORDER BY entry, slot ASC");
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `npc_vendor`, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-uint32 count = 0;
-do
-{
-bar.step();
-Field* fields = result->Fetch();
-
-uint32 entry = fields[0].GetUInt32();
-int32 item_id = fields[1].GetInt32();
-
-// if item is a negative, its a reference
-if (item_id < 0)
-count += LoadReferenceVendor(entry, -item_id, &skip_vendors);
-else
-{
-int32 maxcount = fields[2].GetInt32();
-uint32 incrtime = fields[3].GetUInt32();
-uint32 ExtendedCost = fields[4].GetUInt32();
-
-if (!IsVendorItemValid(entry, item_id, maxcount, incrtime, ExtendedCost, NULL, &skip_vendors))
-continue;
-
-VendorItemData& vList = m_mCacheVendorItemMap[entry];
-
-vList.AddItem(item_id, maxcount, incrtime, ExtendedCost);
-++count;
-}
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %d Vendors ", count);
-}
-
-void ObjectMgr::LoadNpcTextId()
-{
-
-m_mCacheNpcTextIdMap.clear();
-
-QueryResult result = WorldDatabase.Query("SELECT npc_guid, textid FROM npc_gossip");
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `npc_gossip`, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-uint32 count = 0;
-uint32 guid,textid;
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-
-guid = fields[0].GetUInt32();
-textid = fields[1].GetUInt32();
-
-if (!GetCreatureData(guid))
-{
-sLog.outErrorDb("Table `npc_gossip` have not existed creature (GUID: %u) entry, ignore. ",guid);
-continue;
-}
-if (!GetGossipText(textid))
-{
-sLog.outErrorDb("Table `npc_gossip` for creature (GUID: %u) have wrong Textid (%u), ignore. ", guid, textid);
-continue;
-}
-
-m_mCacheNpcTextIdMap[guid] = textid ;
-++count;
-
-} while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %d NpcTextId ", count);
-}
-
-void ObjectMgr::LoadGossipMenu()
-{
-m_mGossipMenusMap.clear();
-
-QueryResult result = WorldDatabase.Query("SELECT entry, text_id FROM gossip_menu");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded `gossip_menu`, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-uint32 count = 0;
-
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-
-GossipMenus gMenu;
-
-gMenu.entry = fields[0].GetUInt32();
-gMenu.text_id = fields[1].GetUInt32();
-
-if (!GetGossipText(gMenu.text_id))
-{
-sLog.outErrorDb("Table gossip_menu entry %u are using non-existing text_id %u", gMenu.entry, gMenu.text_id);
-continue;
-}
-
-m_mGossipMenusMap.insert(GossipMenusMap::value_type(gMenu.entry, gMenu));
-
-++count;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u gossip_menu entries", count);
-}
-
-void ObjectMgr::LoadGossipMenuItems()
-{
-m_mGossipMenuItemsMap.clear();
-
-QueryResult result = WorldDatabase.Query(
-"SELECT menu_id, id, option_icon, option_text, option_id, npc_option_npcflag, "
-"action_menu_id, action_poi_id, action_script_id, box_coded, box_money, box_text "
-"FROM gossip_menu_option ORDER BY menu_id, id");
-
-if (!result)
-{
-barGoLink bar(1);
-
-bar.step();
-
-sLog.outString();
-sLog.outErrorDb(">> Loaded gossip_menu_option, table is empty!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-uint32 count = 0;
-
-std::set<uint32> gossipScriptSet;
-
-for (ScriptMapMap::const_iterator itr = sGossipScripts.begin(); itr != sGossipScripts.end(); ++itr)
-gossipScriptSet.insert(itr->first);
-
-do
-{
-bar.step();
-
-Field* fields = result->Fetch();
-
-GossipMenuItems gMenuItem;
-
-gMenuItem.menu_id = fields[0].GetUInt32();
-gMenuItem.id = fields[1].GetUInt32();
-gMenuItem.option_icon = fields[2].GetUInt8();
-gMenuItem.option_text = fields[3].GetString();
-gMenuItem.option_id = fields[4].GetUInt32();
-gMenuItem.npc_option_npcflag = fields[5].GetUInt32();
-gMenuItem.action_menu_id = fields[6].GetUInt32();
-gMenuItem.action_poi_id = fields[7].GetUInt32();
-gMenuItem.action_script_id = fields[8].GetUInt32();
-gMenuItem.box_coded = fields[9].GetUInt8() != 0;
-gMenuItem.box_money = fields[10].GetUInt32();
-gMenuItem.box_text = fields[11].GetString();
-
-if (gMenuItem.option_icon >= GOSSIP_ICON_MAX)
-{
-sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u has unknown icon id %u. Replacing with GOSSIP_ICON_CHAT", gMenuItem.menu_id, gMenuItem.id, gMenuItem.option_icon);
-gMenuItem.option_icon = GOSSIP_ICON_CHAT;
-}
-
-if (gMenuItem.option_id >= GOSSIP_OPTION_MAX)
-sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u has unknown option id %u. Option will not be used", gMenuItem.menu_id, gMenuItem.id, gMenuItem.option_id);
-
-if (gMenuItem.action_poi_id && !GetPointOfInterest(gMenuItem.action_poi_id))
-{
-sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u use non-existing action_poi_id %u, ignoring", gMenuItem.menu_id, gMenuItem.id, gMenuItem.action_poi_id);
-gMenuItem.action_poi_id = 0;
-}
-
-if (gMenuItem.action_script_id)
-{
-if (gMenuItem.option_id != GOSSIP_OPTION_GOSSIP)
-{
-sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u have action_script_id %u but option_id is not GOSSIP_OPTION_GOSSIP, ignoring", gMenuItem.menu_id, gMenuItem.id, gMenuItem.action_script_id);
-continue;
-}
-
-if (sGossipScripts.find(gMenuItem.action_script_id) == sGossipScripts.end())
-{
-sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u have action_script_id %u that does not exist in `gossip_scripts`, ignoring", gMenuItem.menu_id, gMenuItem.id, gMenuItem.action_script_id);
-continue;
-}
-
-gossipScriptSet.erase(gMenuItem.action_script_id);
-}
-
-m_mGossipMenuItemsMap.insert(GossipMenuItemsMap::value_type(gMenuItem.menu_id, gMenuItem));
-
-++count;
-
-}
-while (result->NextRow());
-
-if (!gossipScriptSet.empty())
-{
-for (std::set<uint32>::const_iterator itr = gossipScriptSet.begin(); itr != gossipScriptSet.end(); ++itr)
-sLog.outErrorDb("Table `gossip_scripts` contain unused script, id %u.", *itr);
-}
-
-sLog.outString();
-sLog.outString(">> Loaded %u gossip_menu_option entries", count);
-}
-
-void ObjectMgr::AddVendorItem(uint32 entry,uint32 item, int32 maxcount, uint32 incrtime, uint32 extendedcost, bool savetodb)
-{
-VendorItemData& vList = m_mCacheVendorItemMap[entry];
-vList.AddItem(item, maxcount, incrtime, extendedcost);
-
-if (savetodb)
-WorldDatabase.PExecute("INSERT INTO npc_vendor (entry,item,maxcount,incrtime,extendedcost) VALUES('%u','%u','%u','%u','%u')", entry, item, maxcount, incrtime, extendedcost);
-}
-
-bool ObjectMgr::RemoveVendorItem(uint32 entry,uint32 item, bool savetodb)
-{
-CacheVendorItemMap::iterator iter = m_mCacheVendorItemMap.find(entry);
-if (iter == m_mCacheVendorItemMap.end())
-return false;
-
-if(!iter->second.RemoveItem(item))
-return false;
-
-if (savetodb) WorldDatabase.PExecute("DELETE FROM npc_vendor WHERE entry='%u' AND item='%u'",entry, item);
-return true;
-}
-
-bool ObjectMgr::IsVendorItemValid(uint32 vendor_entry, uint32 item_id, int32 maxcount, uint32 incrtime, uint32 ExtendedCost, Player* pl, std::set<uint32>* skip_vendors, uint32 ORnpcflag) const
-{
-CreatureInfo const* cInfo = GetCreatureTemplate(vendor_entry);
-if (!cInfo)
-{
-if (pl)
-ChatHandler(pl).SendSysMessage(LANG_COMMAND_VENDORSELECTION);
-else
-sLog.outErrorDb("Table `(game_event_)npc_vendor` have data for not existed creature template (Entry: %u), ignore", vendor_entry);
-return false;
-}
-
-if (!((cInfo->npcflag | ORnpcflag) & UNIT_NPC_FLAG_VENDOR))
-{
-if (!skip_vendors || skip_vendors->count(vendor_entry) == 0)
-{
-if (pl)
-ChatHandler(pl).SendSysMessage(LANG_COMMAND_VENDORSELECTION);
-else
-sLog.outErrorDb("Table `(game_event_)npc_vendor` have data for not creature template (Entry: %u) without vendor flag, ignore", vendor_entry);
-
-if (skip_vendors)
-skip_vendors->insert(vendor_entry);
-}
-return false;
-}
-
-if (!GetItemPrototype(item_id))
-{
-if (pl)
-ChatHandler(pl).PSendSysMessage(LANG_ITEM_NOT_FOUND, item_id);
-else
-sLog.outErrorDb("Table `(game_event_)npc_vendor` for Vendor (Entry: %u) have in item list non-existed item (%u), ignore", vendor_entry, item_id);
-return false;
-}
-
-if (ExtendedCost && !sItemExtendedCostStore.LookupEntry(ExtendedCost))
-{
-if (pl)
-ChatHandler(pl).PSendSysMessage(LANG_EXTENDED_COST_NOT_EXIST, ExtendedCost);
-else
-sLog.outErrorDb("Table `(game_event_)npc_vendor` have Item (Entry: %u) with wrong ExtendedCost (%u) for vendor (%u), ignore", item_id, ExtendedCost, vendor_entry);
-return false;
-}
-
-if (maxcount > 0 && incrtime == 0)
-{
-if (pl)
-ChatHandler(pl).PSendSysMessage("MaxCount != 0 (%u) but IncrTime == 0", maxcount);
-else
-sLog.outErrorDb("Table `(game_event_)npc_vendor` has `maxcount` (%u) for item %u of vendor (Entry: %u) but `incrtime`=0, ignore", maxcount, item_id, vendor_entry);
-return false;
-}
-else if (maxcount == 0 && incrtime > 0)
-{
-if (pl)
-ChatHandler(pl).PSendSysMessage("MaxCount == 0 but IncrTime<>= 0");
-else
-sLog.outErrorDb("Table `(game_event_)npc_vendor` has `maxcount`=0 for item %u of vendor (Entry: %u) but `incrtime`<>0, ignore", item_id, vendor_entry);
-return false;
-}
-
-VendorItemData const* vItems = GetNpcVendorItemList(vendor_entry);
-if (!vItems)
-return true; // later checks for non-empty lists
-
-if (vItems->FindItemCostPair(item_id, ExtendedCost))
-{
-if (pl)
-ChatHandler(pl).PSendSysMessage(LANG_ITEM_ALREADY_IN_LIST, item_id, ExtendedCost);
-else
-sLog.outErrorDb( "Table `npc_vendor` has duplicate items %u (with extended cost %u) for vendor (Entry: %u), ignoring", item_id, ExtendedCost, vendor_entry);
-return false;
-}
-
-if (vItems->GetItemCount() >= MAX_VENDOR_ITEMS)
-{
-if (pl)
-ChatHandler(pl).SendSysMessage(LANG_COMMAND_ADDVENDORITEMITEMS);
-else
-sLog.outErrorDb("Table `npc_vendor` has too many items (%u >= %i) for vendor (Entry: %u), ignore", vItems->GetItemCount(), MAX_VENDOR_ITEMS, vendor_entry);
-return false;
-}
-
-return true;
-}
-
-void ObjectMgr::LoadScriptNames()
-{
-m_scriptNames.push_back("");
-QueryResult result = WorldDatabase.Query(
-"SELECT DISTINCT(ScriptName) FROM achievement_criteria_data WHERE ScriptName <> '' AND type = 11 "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM battleground_template WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM creature_template WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM gameobject_template WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM item_template WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM areatrigger_scripts WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM spell_script_names WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM transports WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM game_weather WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM conditions WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(ScriptName) FROM outdoorpvp_template WHERE ScriptName <> '' "
-"UNION "
-"SELECT DISTINCT(script) FROM instance_template WHERE script <> ''");
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outErrorDb(">> Loaded empty set of Script Names!");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-
-uint32 count = 1;
-
-do
-{
-bar.step();
-m_scriptNames.push_back((*result)[0].GetString());
-++count;
-}
-while (result->NextRow());
-
-std::sort(m_scriptNames.begin(), m_scriptNames.end());
-sLog.outString();
-sLog.outString(">> Loaded %d Script Names", count);
-}
-
-uint32 ObjectMgr::GetScriptId(const char *name)
-{
-// use binary search to find the script name in the sorted vector
-// assume "" is the first element
-if (!name) return 0;
-ScriptNameMap::const_iterator itr =
-std::lower_bound(m_scriptNames.begin(), m_scriptNames.end(), name);
-if (itr == m_scriptNames.end() || *itr != name) return 0;
-return itr - m_scriptNames.begin();
-}
-
-void ObjectMgr::CheckScripts(ScriptsType type, std::set<int32>& ids)
-{
-ScriptMapMap *scripts = GetScriptsMapByType(type);
-if (!scripts)
-return;
-for (ScriptMapMap::const_iterator itrMM = scripts->begin(); itrMM != scripts->end(); ++itrMM)
-{
-for (ScriptMap::const_iterator itrM = itrMM->second.begin(); itrM != itrMM->second.end(); ++itrM)
-{
-switch(itrM->second.command)
-{
-case SCRIPT_COMMAND_TALK:
-{
-if (!GetTrinityStringLocale (itrM->second.Talk.TextID))
-sLog.outErrorDb("Table `db_script_string` not has string id %u used db script (ID: %u)", itrM->second.Talk.TextID, itrMM->first);
-
-if (ids.find(itrM->second.Talk.TextID) != ids.end())
-ids.erase(itrM->second.Talk.TextID);
-}
-default:
-break;
-}
-}
-}
-}
-
-void ObjectMgr::LoadDbScriptStrings()
-{
-LoadTrinityStrings("db_script_string", MIN_DB_SCRIPT_STRING_ID, MAX_DB_SCRIPT_STRING_ID);
-
-std::set<int32> ids;
-
-for (int32 i = MIN_DB_SCRIPT_STRING_ID; i < MAX_DB_SCRIPT_STRING_ID; ++i)
-if (GetTrinityStringLocale(i))
-ids.insert(i);
-
-for (int type = SCRIPTS_FIRST; type < SCRIPTS_LAST; ++type)
-CheckScripts(ScriptsType(type), ids);
-
-for (std::set<int32>::const_iterator itr = ids.begin(); itr != ids.end(); ++itr)
-sLog.outErrorDb("Table `db_script_string` has unused string id %u", *itr);
-}
-
-// Functions for scripting access
-uint32 GetAreaTriggerScriptId(uint32 trigger_id)
-{
-return sObjectMgr.GetAreaTriggerScriptId(trigger_id);
-}
-
-bool LoadTrinityStrings(char const* table, int32 start_value, int32 end_value)
-{
-// MAX_DB_SCRIPT_STRING_ID is max allowed negative value for scripts (scrpts can use only more deep negative values
-// start/end reversed for negative values
-if (start_value > MAX_DB_SCRIPT_STRING_ID || end_value >= start_value)
-{
-sLog.outErrorDb("Table '%s' load attempted with range (%d - %d) reserved by Trinity, strings not loaded.",table,start_value,end_value+1);
-return false;
-}
-
-return sObjectMgr.LoadTrinityStrings(table, start_value, end_value);
-}
-
-uint32 GetScriptId(const char *name)
-{
-return sObjectMgr.GetScriptId(name);
-}
-
-ObjectMgr::ScriptNameMap & GetScriptNames()
-{
-return sObjectMgr.GetScriptNames();
-}
-
-GameObjectInfo const *GetGameObjectInfo(uint32 id)
-{
-return sObjectMgr.GetGameObjectInfo(id);
-}
-
-CreatureInfo const *GetCreatureInfo(uint32 id)
-{
-return sObjectMgr.GetCreatureTemplate(id);
-}
-
-CreatureInfo const* GetCreatureTemplateStore(uint32 entry)
-{
-return sCreatureStorage.LookupEntry<CreatureInfo>(entry);
-}
-
-Quest const* GetQuestTemplateStore(uint32 entry)
-{
-return sObjectMgr.GetQuestTemplate(entry);
-}
-
-CreatureBaseStats const* ObjectMgr::GetCreatureBaseStats(uint8 level, uint8 unitClass)
-{
-CreatureBaseStatsMap::const_iterator it = m_creatureBaseStatsMap.find(MAKE_PAIR16(level,unitClass));
-
-if (it != m_creatureBaseStatsMap.end())
-return &(it->second);
-
-struct DefaultCreatureBaseStats : public CreatureBaseStats
-{
-DefaultCreatureBaseStats()
-{
-BaseArmor = 1;
-for (uint8 j = 0; j < MAX_CREATURE_BASE_HP; ++j)
-BaseHealth[j] = 1;
-BaseMana = 0;
-}
-};
-static const DefaultCreatureBaseStats def_stats;
-return &def_stats;
-}
-
-void ObjectMgr::LoadCreatureClassLevelStats()
-{
-QueryResult result = WorldDatabase.Query("SELECT level, class, basehp0, basehp1, basehp2, basemana, basearmor FROM creature_classlevelstats");
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 creature base stats. DB table `creature_classlevelstats` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-uint32 counter = 0;
-
-do
-{
-Field *fields = result->Fetch();
-
-uint8 Level = fields[0].GetUInt8();
-uint8 Class = fields[1].GetUInt8();
-
-CreatureBaseStats stats;
-for (uint8 i = 0; i < MAX_CREATURE_BASE_HP; ++i)
-stats.BaseHealth[i] = fields[i + 2].GetUInt32();
-stats.BaseMana = fields[5].GetUInt32();
-stats.BaseArmor = fields[6].GetUInt32();
-
-if (!Class || ((1 << (Class - 1)) & CLASSMASK_ALL_CREATURES) == 0)
-sLog.outErrorDb("Creature base stats for level %u has invalid class %u",
-Level, Class);
-
-for (uint8 i = 0; i < MAX_CREATURE_BASE_HP; ++i)
-{
-if (stats.BaseHealth[i] < 1)
-{
-sLog.outErrorDb("Creature base stats for class %u, level %u has invalid zero base HP[%u] - set to 1",
-Class, Level, i);
-stats.BaseHealth[i] = 1;
-}
-}
-
-m_creatureBaseStatsMap[MAKE_PAIR16(Level, Class)] = stats;
-
-bar.step();
-++counter;
-}
-while (result->NextRow());
-
-for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
-{
-CreatureInfo const* info = sCreatureStorage.LookupEntry<CreatureInfo>(i);
-if (!info)
-continue;
-
-for (uint16 lvl = info->minlevel; lvl <= info->maxlevel; ++lvl)
-{
-if (m_creatureBaseStatsMap.find(MAKE_PAIR16(lvl, info->unit_class)) == m_creatureBaseStatsMap.end())
-sLog.outErrorDb("Missing base stats for creature class %u level %u", info->unit_class, lvl);
-}
-}
-
-sLog.outString();
-sLog.outString(">> Loaded %u creature base stats.", counter);
-}
-
-void ObjectMgr::LoadFactionChangeAchievements()
-{
-QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_achievement");
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 faction change achievement pairs. DB table `player_factionchange_achievement` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-uint32 counter = 0;
-
-do
-{
-Field *fields = result->Fetch();
-
-uint32 alliance = fields[0].GetUInt32();
-uint32 horde = fields[1].GetUInt32();
-
-if (!sAchievementStore.LookupEntry(alliance))
-sLog.outErrorDb("Achievement %u referenced in `player_factionchange_achievement` does not exist, pair skipped!", alliance);
-else if (!sAchievementStore.LookupEntry(horde))
-sLog.outErrorDb("Achievement %u referenced in `player_factionchange_achievement` does not exist, pair skipped!", horde);
-else
-factionchange_achievements[alliance] = horde;
-
-bar.step();
-++counter;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u faction change achievement pairs.", counter);
-}
-
-void ObjectMgr::LoadFactionChangeItems()
-{
-QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_items");
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 faction change item pairs. DB table `player_factionchange_items` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-uint32 counter = 0;
-
-do
-{
-Field *fields = result->Fetch();
-
-uint32 alliance = fields[0].GetUInt32();
-uint32 horde = fields[1].GetUInt32();
-
-if (!GetItemPrototype(alliance))
-sLog.outErrorDb("Item %u referenced in `player_factionchange_items` does not exist, pair skipped!", alliance);
-else if (!GetItemPrototype(horde))
-sLog.outErrorDb("Item %u referenced in `player_factionchange_items` does not exist, pair skipped!", horde);
-else
-factionchange_items[alliance] = horde;
-
-bar.step();
-++counter;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u faction change item pairs.", counter);
-}
-
-void ObjectMgr::LoadFactionChangeSpells()
-{
-QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_spells");
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 faction change spell pairs. DB table `player_factionchange_spells` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-uint32 counter = 0;
-
-do
-{
-Field *fields = result->Fetch();
-
-uint32 alliance = fields[0].GetUInt32();
-uint32 horde = fields[1].GetUInt32();
-
-if (!sSpellStore.LookupEntry(alliance))
-sLog.outErrorDb("Spell %u referenced in `player_factionchange_spells` does not exist, pair skipped!", alliance);
-else if (!sSpellStore.LookupEntry(horde))
-sLog.outErrorDb("Spell %u referenced in `player_factionchange_spells` does not exist, pair skipped!", horde);
-else
-factionchange_spells[alliance] = horde;
-
-bar.step();
-++counter;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u faction change spell pairs.", counter);
-}
-
-void ObjectMgr::LoadFactionChangeReputations()
-{
-QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_reputations");
-
-if (!result)
-{
-barGoLink bar(1);
-bar.step();
-sLog.outString();
-sLog.outString(">> Loaded 0 faction change reputation pairs. DB table `player_factionchange_reputations` is empty.");
-return;
-}
-
-barGoLink bar(result->GetRowCount());
-uint32 counter = 0;
-
-do
-{
-Field *fields = result->Fetch();
-
-uint32 alliance = fields[0].GetUInt32();
-uint32 horde = fields[1].GetUInt32();
-
-if (!sFactionStore.LookupEntry(alliance))
-sLog.outErrorDb("Reputation %u referenced in `player_factionchange_reputations` does not exist, pair skipped!", alliance);
-else if (!sFactionStore.LookupEntry(horde))
-sLog.outErrorDb("Reputation %u referenced in `player_factionchange_reputations` does not exist, pair skipped!", horde);
-else
-factionchange_reputations[alliance] = horde;
-
-bar.step();
-++counter;
-}
-while (result->NextRow());
-
-sLog.outString();
-sLog.outString(">> Loaded %u faction change reputation pairs.", counter);
-}
-
+/*
+* Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+* Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along
+* with this program. If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "Common.h"
+#include "DatabaseEnv.h"
+#include "SQLStorage.h"
+#include "SQLStorageImpl.h"
+#include "Log.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "SpellMgr.h"
+#include "UpdateMask.h"
+#include "World.h"
+#include "Group.h"
+#include "Guild.h"
+#include "ArenaTeam.h"
+#include "Transport.h"
+#include "ProgressBar.h"
+#include "Language.h"
+#include "GameEventMgr.h"
+#include "Spell.h"
+#include "Chat.h"
+#include "AccountMgr.h"
+#include "InstanceSaveMgr.h"
+#include "SpellAuras.h"
+#include "Util.h"
+#include "WaypointManager.h"
+#include "GossipDef.h"
+#include "Vehicle.h"
+#include "AchievementMgr.h"
+#include "DisableMgr.h"
+#include "ScriptMgr.h"
+#include "SpellScript.h"
+#include "PoolMgr.h"
+
+ScriptMapMap sQuestEndScripts;
+ScriptMapMap sQuestStartScripts;
+ScriptMapMap sSpellScripts;
+ScriptMapMap sGameObjectScripts;
+ScriptMapMap sEventScripts;
+ScriptMapMap sGossipScripts;
+ScriptMapMap sWaypointScripts;
+
+std::string GetScriptsTableNameByType(ScriptsType type)
+{
+std::string res = "";
+switch (type)
+{
+case SCRIPTS_QUEST_END: res = "quest_end_scripts"; break;
+case SCRIPTS_QUEST_START: res = "quest_start_scripts";break;
+case SCRIPTS_SPELL: res = "spell_scripts"; break;
+case SCRIPTS_GAMEOBJECT: res = "gameobject_scripts"; break;
+case SCRIPTS_EVENT: res = "event_scripts"; break;
+case SCRIPTS_WAYPOINT: res = "waypoint_scripts"; break;
+case SCRIPTS_GOSSIP: res = "gossip_scripts"; break;
+default: break;
+}
+return res;
+}
+
+ScriptMapMap* GetScriptsMapByType(ScriptsType type)
+{
+ScriptMapMap* res = NULL;
+switch (type)
+{
+case SCRIPTS_QUEST_END: res = &sQuestEndScripts; break;
+case SCRIPTS_QUEST_START: res = &sQuestStartScripts; break;
+case SCRIPTS_SPELL: res = &sSpellScripts; break;
+case SCRIPTS_GAMEOBJECT: res = &sGameObjectScripts; break;
+case SCRIPTS_EVENT: res = &sEventScripts; break;
+case SCRIPTS_WAYPOINT: res = &sWaypointScripts; break;
+case SCRIPTS_GOSSIP: res = &sGossipScripts; break;
+default: break;
+}
+return res;
+}
+
+std::string GetScriptCommandName(ScriptCommands command)
+{
+std::string res = "";
+switch (command)
+{
+case SCRIPT_COMMAND_TALK: res = "SCRIPT_COMMAND_TALK"; break;
+case SCRIPT_COMMAND_EMOTE: res = "SCRIPT_COMMAND_EMOTE"; break;
+case SCRIPT_COMMAND_FIELD_SET: res = "SCRIPT_COMMAND_FIELD_SET"; break;
+case SCRIPT_COMMAND_MOVE_TO: res = "SCRIPT_COMMAND_MOVE_TO"; break;
+case SCRIPT_COMMAND_FLAG_SET: res = "SCRIPT_COMMAND_FLAG_SET"; break;
+case SCRIPT_COMMAND_FLAG_REMOVE: res = "SCRIPT_COMMAND_FLAG_REMOVE"; break;
+case SCRIPT_COMMAND_TELEPORT_TO: res = "SCRIPT_COMMAND_TELEPORT_TO"; break;
+case SCRIPT_COMMAND_QUEST_EXPLORED: res = "SCRIPT_COMMAND_QUEST_EXPLORED"; break;
+case SCRIPT_COMMAND_KILL_CREDIT: res = "SCRIPT_COMMAND_KILL_CREDIT"; break;
+case SCRIPT_COMMAND_RESPAWN_GAMEOBJECT: res = "SCRIPT_COMMAND_RESPAWN_GAMEOBJECT"; break;
+case SCRIPT_COMMAND_TEMP_SUMMON_CREATURE: res = "SCRIPT_COMMAND_TEMP_SUMMON_CREATURE"; break;
+case SCRIPT_COMMAND_OPEN_DOOR: res = "SCRIPT_COMMAND_OPEN_DOOR"; break;
+case SCRIPT_COMMAND_CLOSE_DOOR: res = "SCRIPT_COMMAND_CLOSE_DOOR"; break;
+case SCRIPT_COMMAND_ACTIVATE_OBJECT: res = "SCRIPT_COMMAND_ACTIVATE_OBJECT"; break;
+case SCRIPT_COMMAND_REMOVE_AURA: res = "SCRIPT_COMMAND_REMOVE_AURA"; break;
+case SCRIPT_COMMAND_CAST_SPELL: res = "SCRIPT_COMMAND_CAST_SPELL"; break;
+case SCRIPT_COMMAND_PLAY_SOUND: res = "SCRIPT_COMMAND_PLAY_SOUND"; break;
+case SCRIPT_COMMAND_CREATE_ITEM: res = "SCRIPT_COMMAND_CREATE_ITEM"; break;
+case SCRIPT_COMMAND_DESPAWN_SELF: res = "SCRIPT_COMMAND_DESPAWN_SELF"; break;
+case SCRIPT_COMMAND_LOAD_PATH: res = "SCRIPT_COMMAND_LOAD_PATH"; break;
+case SCRIPT_COMMAND_CALLSCRIPT_TO_UNIT: res = "SCRIPT_COMMAND_CALLSCRIPT_TO_UNIT"; break;
+case SCRIPT_COMMAND_KILL: res = "SCRIPT_COMMAND_KILL"; break;
+// TrinityCore only
+case SCRIPT_COMMAND_ORIENTATION: res = "SCRIPT_COMMAND_ORIENTATION"; break;
+case SCRIPT_COMMAND_EQUIP: res = "SCRIPT_COMMAND_EQUIP"; break;
+case SCRIPT_COMMAND_MODEL: res = "SCRIPT_COMMAND_MODEL"; break;
+case SCRIPT_COMMAND_CLOSE_GOSSIP: res = "SCRIPT_COMMAND_CLOSE_GOSSIP"; break;
+case SCRIPT_COMMAND_PLAYMOVIE: res = "SCRIPT_COMMAND_PLAYMOVIE"; break;
+default:
+{
+char sz[32];
+sprintf(sz, "Unknown command: %u", command);
+res = sz;
+break;
+}
+}
+return res;
+}
+
+std::string ScriptInfo::GetDebugInfo() const
+{
+char sz[256];
+sprintf(sz, "%s ('%s' script id: %u)", GetScriptCommandName(command).c_str(), GetScriptsTableNameByType(type).c_str(), id);
+return std::string(sz);
+}
+
+bool normalizePlayerName(std::string& name)
+{
+if (name.empty())
+return false;
+
+wchar_t wstr_buf[MAX_INTERNAL_PLAYER_NAME+1];
+size_t wstr_len = MAX_INTERNAL_PLAYER_NAME;
+
+if (!Utf8toWStr(name,&wstr_buf[0],wstr_len))
+return false;
+
+wstr_buf[0] = wcharToUpper(wstr_buf[0]);
+for (size_t i = 1; i < wstr_len; ++i)
+wstr_buf[i] = wcharToLower(wstr_buf[i]);
+
+if (!WStrToUtf8(wstr_buf,wstr_len,name))
+return false;
+
+return true;
+}
+
+LanguageDesc lang_description[LANGUAGES_COUNT] =
+{
+{ LANG_ADDON, 0, 0 },
+{ LANG_UNIVERSAL, 0, 0 },
+{ LANG_ORCISH, 669, SKILL_LANG_ORCISH },
+{ LANG_DARNASSIAN, 671, SKILL_LANG_DARNASSIAN },
+{ LANG_TAURAHE, 670, SKILL_LANG_TAURAHE },
+{ LANG_DWARVISH, 672, SKILL_LANG_DWARVEN },
+{ LANG_COMMON, 668, SKILL_LANG_COMMON },
+{ LANG_DEMONIC, 815, SKILL_LANG_DEMON_TONGUE },
+{ LANG_TITAN, 816, SKILL_LANG_TITAN },
+{ LANG_THALASSIAN, 813, SKILL_LANG_THALASSIAN },
+{ LANG_DRACONIC, 814, SKILL_LANG_DRACONIC },
+{ LANG_KALIMAG, 817, SKILL_LANG_OLD_TONGUE },
+{ LANG_GNOMISH, 7340, SKILL_LANG_GNOMISH },
+{ LANG_TROLL, 7341, SKILL_LANG_TROLL },
+{ LANG_GUTTERSPEAK, 17737, SKILL_LANG_GUTTERSPEAK },
+{ LANG_DRAENEI, 29932, SKILL_LANG_DRAENEI },
+{ LANG_ZOMBIE, 0, 0 },
+{ LANG_GNOMISH_BINARY, 0, 0 },
+{ LANG_GOBLIN_BINARY, 0, 0 }
+};
+
+LanguageDesc const* GetLanguageDescByID(uint32 lang)
+{
+for (uint8 i = 0; i < LANGUAGES_COUNT; ++i)
+{
+if (uint32(lang_description[i].lang_id) == lang)
+return &lang_description[i];
+}
+
+return NULL;
+}
+
+bool SpellClickInfo::IsFitToRequirements(Player const* player, Creature const * clickNpc) const
+{
+if (questStart)
+{
+// not in expected required quest state
+if (!player || ((!questStartCanActive || !player->IsActiveQuest(questStart)) && !player->GetQuestRewardStatus(questStart)))
+return false;
+}
+
+if (questEnd)
+{
+// not in expected forbidden quest state
+if (!player || player->GetQuestRewardStatus(questEnd))
+return false;
+}
+
+if (auraRequired)
+if (!player->HasAura(auraRequired))
+return false;
+
+if (auraForbidden)
+if (player->HasAura(auraForbidden))
+return false;
+
+Unit const * summoner = NULL;
+// Check summoners for party
+if (clickNpc->isSummon())
+summoner = clickNpc->ToTempSummon()->GetSummoner();
+if (!summoner)
+summoner = clickNpc;
+
+switch (userType)
+{
+case SPELL_CLICK_USER_FRIEND:
+if (!player->IsFriendlyTo(summoner))
+return false;
+break;
+case SPELL_CLICK_USER_RAID:
+if (!player->IsInRaidWith(summoner))
+return false;
+break;
+case SPELL_CLICK_USER_PARTY:
+if (!player->IsInPartyWith(summoner))
+return false;
+break;
+default:
+break;
+}
+
+return true;
+}
+
+ObjectMgr::ObjectMgr()
+{
+m_hiCharGuid = 1;
+m_hiCreatureGuid = 1;
+m_hiPetGuid = 1;
+m_hiVehicleGuid = 1;
+m_hiItemGuid = 1;
+m_hiGoGuid = 1;
+m_hiDoGuid = 1;
+m_hiCorpseGuid = 1;
+m_hiPetNumber = 1;
+m_hiGroupGuid = 1;
+m_hiMoTransGuid = 1;
+m_ItemTextId = 1;
+m_mailid = 1;
+m_equipmentSetGuid = 1;
+m_guildId = 1;
+m_arenaTeamId = 1;
+m_auctionid = 1;
+}
+
+ObjectMgr::~ObjectMgr()
+{
+for (QuestMap::iterator i = mQuestTemplates.begin(); i != mQuestTemplates.end(); ++i)
+delete i->second;
+
+for (PetLevelInfoMap::iterator i = petInfo.begin(); i != petInfo.end(); ++i)
+delete[] i->second;
+
+// free only if loaded
+for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
+delete[] playerClassInfo[class_].levelInfo;
+
+for (int race = 0; race < MAX_RACES; ++race)
+for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
+delete[] playerInfo[race][class_].levelInfo;
+
+// free group and guild objects
+for (GroupSet::iterator itr = mGroupSet.begin(); itr != mGroupSet.end(); ++itr)
+delete *itr;
+
+for (GuildMap::iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
+if (*itr)
+delete *itr;
+
+for (ArenaTeamMap::iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
+delete itr->second;
+
+for (CacheVendorItemMap::iterator itr = m_mCacheVendorItemMap.begin(); itr != m_mCacheVendorItemMap.end(); ++itr)
+itr->second.Clear();
+
+for (CacheTrainerSpellMap::iterator itr = m_mCacheTrainerSpellMap.begin(); itr != m_mCacheTrainerSpellMap.end(); ++itr)
+itr->second.Clear();
+}
+
+Group * ObjectMgr::GetGroupByGUID(uint32 guid) const
+{
+for (GroupSet::const_iterator itr = mGroupSet.begin(); itr != mGroupSet.end(); ++itr)
+if ((*itr)->GetLowGUID() == guid)
+return *itr;
+
+return NULL;
+}
+
+// Guild collection
+Guild* ObjectMgr::GetGuildById(uint32 guildId) const
+{
+// Make sure given index exists in collection
+if (guildId < uint32(mGuildMap.size()))
+return mGuildMap[guildId];
+return NULL;
+}
+
+Guild* ObjectMgr::GetGuildByName(const std::string& guildname) const
+{
+std::string search = guildname;
+std::transform(search.begin(), search.end(), search.begin(), ::toupper);
+for (GuildMap::const_iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
+{
+if (*itr)
+{
+std::string gname = (*itr)->GetName();
+std::transform(gname.begin(), gname.end(), gname.begin(), ::toupper);
+if (search == gname)
+return *itr;
+}
+}
+return NULL;
+}
+
+std::string ObjectMgr::GetGuildNameById(uint32 guildId) const
+{
+if (Guild* pGuild = GetGuildById(guildId))
+return pGuild->GetName();
+return "";
+}
+
+Guild* ObjectMgr::GetGuildByLeader(const uint64 &guid) const
+{
+for (GuildMap::const_iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
+if ((*itr) && (*itr)->GetLeaderGUID() == guid)
+return *itr;
+
+return NULL;
+}
+
+void ObjectMgr::AddGuild(Guild* pGuild)
+{
+uint32 guildId = pGuild->GetId();
+// Allocate space if necessary
+if (guildId >= uint32(mGuildMap.size()))
+// Reserve a bit more space than necessary.
+// 16 is intentional and it will allow creation of next 16 guilds happen
+// without reallocation.
+mGuildMap.resize(guildId + 16);
+mGuildMap[guildId] = pGuild;
+}
+
+void ObjectMgr::RemoveGuild(uint32 guildId)
+{
+// Make sure given index exists
+if (guildId < uint32(mGuildMap.size()))
+mGuildMap[guildId] = NULL;
+}
+
+// Arena teams collection
+ArenaTeam* ObjectMgr::GetArenaTeamById(uint32 arenateamid) const
+{
+ArenaTeamMap::const_iterator itr = mArenaTeamMap.find(arenateamid);
+if (itr != mArenaTeamMap.end())
+return itr->second;
+
+return NULL;
+}
+
+ArenaTeam* ObjectMgr::GetArenaTeamByName(const std::string& arenateamname) const
+{
+std::string search = arenateamname;
+std::transform(search.begin(), search.end(), search.begin(), ::toupper);
+for (ArenaTeamMap::const_iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
+{
+std::string teamname = itr->second->GetName();
+std::transform(teamname.begin(), teamname.end(), teamname.begin(), ::toupper);
+if (search == teamname)
+return itr->second;
+}
+return NULL;
+}
+
+ArenaTeam* ObjectMgr::GetArenaTeamByCaptain(uint64 const& guid) const
+{
+for (ArenaTeamMap::const_iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
+if (itr->second->GetCaptain() == guid)
+return itr->second;
+
+return NULL;
+}
+
+void ObjectMgr::AddArenaTeam(ArenaTeam* arenaTeam)
+{
+mArenaTeamMap[arenaTeam->GetId()] = arenaTeam;
+}
+
+void ObjectMgr::RemoveArenaTeam(uint32 Id)
+{
+mArenaTeamMap.erase(Id);
+}
+
+CreatureInfo const* ObjectMgr::GetCreatureTemplate(uint32 id)
+{
+return sCreatureStorage.LookupEntry<CreatureInfo>(id);
+}
+
+void ObjectMgr::AddLocaleString(std::string& s, LocaleConstant locale, StringVector& data)
+{
+if (!s.empty())
+{
+if (data.size() <= size_t(locale))
+data.resize(locale + 1);
+
+data[locale] = s;
+}
+}
+
+void ObjectMgr::LoadCreatureLocales()
+{
+mCreatureLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT entry,name_loc1,subname_loc1,name_loc2,subname_loc2,name_loc3,subname_loc3,name_loc4,subname_loc4,name_loc5,subname_loc5,name_loc6,subname_loc6,name_loc7,subname_loc7,name_loc8,subname_loc8 FROM locales_creature");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+CreatureLocale& data = mCreatureLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+LocaleConstant locale = (LocaleConstant) i;
+std::string str = fields[1 + 2 * (i - 1)].GetString();
+AddLocaleString(str, locale, data.Name);
+
+str = fields[1 + 2 * (i - 1) + 1].GetString();
+AddLocaleString(str, locale, data.SubName);
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu creature locale strings", (unsigned long)mCreatureLocaleMap.size());
+}
+
+void ObjectMgr::LoadGossipMenuItemsLocales()
+{
+mGossipMenuItemsLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT menu_id,id,"
+"option_text_loc1,box_text_loc1,option_text_loc2,box_text_loc2,"
+"option_text_loc3,box_text_loc3,option_text_loc4,box_text_loc4,"
+"option_text_loc5,box_text_loc5,option_text_loc6,box_text_loc6,"
+"option_text_loc7,box_text_loc7,option_text_loc8,box_text_loc8 "
+"FROM locales_gossip_menu_option");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint16 menuId = fields[0].GetUInt16();
+uint16 id = fields[1].GetUInt16();
+
+GossipMenuItemsLocale& data = mGossipMenuItemsLocaleMap[MAKE_PAIR32(menuId,id)];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+LocaleConstant locale = (LocaleConstant) i;
+std::string str = fields[2 + 2 * (i - 1)].GetString();
+AddLocaleString(str, locale, data.OptionText);
+
+str = fields[2 + 2 * (i - 1) + 1].GetString();
+AddLocaleString(str, locale, data.BoxText);
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu gossip_menu_option locale strings", (unsigned long)mGossipMenuItemsLocaleMap.size());
+}
+
+void ObjectMgr::LoadPointOfInterestLocales()
+{
+mPointOfInterestLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT entry,icon_name_loc1,icon_name_loc2,icon_name_loc3,icon_name_loc4,icon_name_loc5,icon_name_loc6,icon_name_loc7,icon_name_loc8 FROM locales_points_of_interest");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+PointOfInterestLocale& data = mPointOfInterestLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+std::string str = fields[i].GetString();
+AddLocaleString(str, LocaleConstant(i), data.IconName);
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu points_of_interest locale strings", (unsigned long)mPointOfInterestLocaleMap.size());
+}
+
+struct SQLCreatureLoader : public SQLStorageLoaderBase<SQLCreatureLoader>
+{
+template<class D>
+void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
+{
+dst = D(sObjectMgr.GetScriptId(src));
+}
+};
+
+void ObjectMgr::LoadCreatureTemplates()
+{
+SQLCreatureLoader loader;
+loader.Load(sCreatureStorage);
+
+sLog.outString(">> Loaded %u creature definitions", sCreatureStorage.RecordCount);
+sLog.outString();
+
+// check data correctness
+for (uint32 i = 1; i < sCreatureStorage.MaxEntry; ++i)
+{
+CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i);
+CheckCreatureTemplate(cInfo);
+}
+}
+
+void ObjectMgr::CheckCreatureTemplate(CreatureInfo const* cInfo)
+{
+if (!cInfo)
+return;
+
+bool ok = true; // bool to allow continue outside this loop
+for (uint32 diff = 0; diff < MAX_DIFFICULTY - 1 && ok; ++diff)
+{
+if (!cInfo->DifficultyEntry[diff])
+continue;
+ok = false; // will be set to true at the end of this loop again
+
+CreatureInfo const* difficultyInfo = GetCreatureTemplate(cInfo->DifficultyEntry[diff]);
+if (!difficultyInfo)
+{
+sLog.outErrorDb("Creature (Entry: %u) has `difficulty_entry_%u`=%u but creature entry %u does not exist.",
+cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff], cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+bool ok2 = true;
+for (uint32 diff2 = 0; diff2 < MAX_DIFFICULTY - 1 && ok2; ++diff2)
+{
+ok2 = false;
+if (difficultyEntries[diff2].find(cInfo->Entry) != difficultyEntries[diff2].end())
+{
+sLog.outErrorDb("Creature (Entry: %u) is listed as `difficulty_entry_%u` of another creature, but itself lists %u in `difficulty_entry_%u`.",
+cInfo->Entry, diff2 + 1, cInfo->DifficultyEntry[diff], diff + 1);
+continue;
+}
+
+if (difficultyEntries[diff2].find(cInfo->DifficultyEntry[diff]) != difficultyEntries[diff2].end())
+{
+sLog.outErrorDb("Creature (Entry: %u) already listed as `difficulty_entry_%u` for another entry.", cInfo->DifficultyEntry[diff], diff2 + 1);
+continue;
+}
+
+if (hasDifficultyEntries[diff2].find(cInfo->DifficultyEntry[diff]) != hasDifficultyEntries[diff2].end())
+{
+sLog.outErrorDb("Creature (Entry: %u) has `difficulty_entry_%u`=%u but creature entry %u has itself a value in `difficulty_entry_%u`.",
+cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff], cInfo->DifficultyEntry[diff], diff2 + 1);
+continue;
+}
+ok2 = true;
+}
+if (!ok2)
+continue;
+
+if (cInfo->unit_class != difficultyInfo->unit_class)
+{
+sLog.outErrorDb("Creature (Entry: %u, class %u) has different `unit_class` in difficulty %u mode (Entry: %u, class %u).",
+cInfo->Entry, cInfo->unit_class, diff + 1, cInfo->DifficultyEntry[diff], difficultyInfo->unit_class);
+continue;
+}
+
+if (cInfo->npcflag != difficultyInfo->npcflag)
+{
+sLog.outErrorDb("Creature (Entry: %u) has different `npcflag` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+if (cInfo->trainer_class != difficultyInfo->trainer_class)
+{
+sLog.outErrorDb("Creature (Entry: %u) has different `trainer_class` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+if (cInfo->trainer_race != difficultyInfo->trainer_race)
+{
+sLog.outErrorDb("Creature (Entry: %u) has different `trainer_race` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+if (cInfo->trainer_type != difficultyInfo->trainer_type)
+{
+sLog.outErrorDb("Creature (Entry: %u) has different `trainer_type` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+if (cInfo->trainer_spell != difficultyInfo->trainer_spell)
+{
+sLog.outErrorDb("Creature (Entry: %u) has different `trainer_spell` in difficulty %u mode (Entry: %u).", cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+if (difficultyInfo->AIName && *difficultyInfo->AIName)
+{
+sLog.outErrorDb("Creature (Entry: %u) lists difficulty %u mode entry %u with `AIName` filled in. `AIName` of difficulty 0 mode creature is always used instead.",
+cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+if (difficultyInfo->ScriptID)
+{
+sLog.outErrorDb("Creature (Entry: %u) lists difficulty %u mode entry %u with `ScriptName` filled in. `ScriptName` of difficulty 0 mode creature is always used instead.",
+cInfo->Entry, diff + 1, cInfo->DifficultyEntry[diff]);
+continue;
+}
+
+hasDifficultyEntries[diff].insert(cInfo->Entry);
+difficultyEntries[diff].insert(cInfo->DifficultyEntry[diff]);
+ok = true;
+}
+
+FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(cInfo->faction_A);
+if (!factionTemplate)
+sLog.outErrorDb("Creature (Entry: %u) has non-existing faction_A template (%u).", cInfo->Entry, cInfo->faction_A);
+
+factionTemplate = sFactionTemplateStore.LookupEntry(cInfo->faction_H);
+if (!factionTemplate)
+sLog.outErrorDb("Creature (Entry: %u) has non-existing faction_H template (%u).", cInfo->Entry, cInfo->faction_H);
+
+// used later for scale
+CreatureDisplayInfoEntry const* displayScaleEntry = NULL;
+
+if (cInfo->Modelid1)
+{
+CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid1);
+if (!displayEntry)
+{
+sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid1 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid1);
+const_cast<CreatureInfo*>(cInfo)->Modelid1 = 0;
+}
+else if (!displayScaleEntry)
+displayScaleEntry = displayEntry;
+
+CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid1);
+if (!minfo)
+sLog.outErrorDb("No model data exist for `Modelid1` = %u listed by creature (Entry: %u).", cInfo->Modelid1, cInfo->Entry);
+}
+
+if (cInfo->Modelid2)
+{
+CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid2);
+if (!displayEntry)
+{
+sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid2 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid2);
+const_cast<CreatureInfo*>(cInfo)->Modelid2 = 0;
+}
+else if (!displayScaleEntry)
+displayScaleEntry = displayEntry;
+
+CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid2);
+if (!minfo)
+sLog.outErrorDb("No model data exist for `Modelid2` = %u listed by creature (Entry: %u).", cInfo->Modelid2, cInfo->Entry);
+}
+
+if (cInfo->Modelid3)
+{
+CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid3);
+if (!displayEntry)
+{
+sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid3 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid3);
+const_cast<CreatureInfo*>(cInfo)->Modelid3 = 0;
+}
+else if (!displayScaleEntry)
+displayScaleEntry = displayEntry;
+
+CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid3);
+if (!minfo)
+sLog.outErrorDb("No model data exist for `Modelid3` = %u listed by creature (Entry: %u).", cInfo->Modelid3, cInfo->Entry);
+}
+
+if (cInfo->Modelid4)
+{
+CreatureDisplayInfoEntry const* displayEntry = sCreatureDisplayInfoStore.LookupEntry(cInfo->Modelid4);
+if (!displayEntry)
+{
+sLog.outErrorDb("Creature (Entry: %u) lists non-existing Modelid4 id (%u), this can crash the client.", cInfo->Entry, cInfo->Modelid4);
+const_cast<CreatureInfo*>(cInfo)->Modelid4 = 0;
+}
+else if (!displayScaleEntry)
+displayScaleEntry = displayEntry;
+
+CreatureModelInfo const* minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(cInfo->Modelid4);
+if (!minfo)
+sLog.outErrorDb("No model data exist for `Modelid4` = %u listed by creature (Entry: %u).", cInfo->Modelid4, cInfo->Entry);
+}
+
+if (!displayScaleEntry)
+sLog.outErrorDb("Creature (Entry: %u) does not have any existing display id in Modelid1/Modelid2/Modelid3/Modelid4.", cInfo->Entry);
+
+for (int k = 0; k < MAX_KILL_CREDIT; ++k)
+{
+if (cInfo->KillCredit[k])
+{
+if (!GetCreatureTemplate(cInfo->KillCredit[k]))
+{
+sLog.outErrorDb("Creature (Entry: %u) lists non-existing creature entry %u in `KillCredit%d`.", cInfo->Entry, cInfo->KillCredit[k], k + 1);
+const_cast<CreatureInfo*>(cInfo)->KillCredit[k] = 0;
+}
+}
+}
+
+if (!cInfo->unit_class || ((1 << (cInfo->unit_class-1)) & CLASSMASK_ALL_CREATURES) == 0)
+{
+sLog.outErrorDb("Creature (Entry: %u) has invalid unit_class (%u) in creature_template. Set to 1 (UNIT_CLASS_WARRIOR).", cInfo->Entry, cInfo->unit_class);
+const_cast<CreatureInfo*>(cInfo)->unit_class = UNIT_CLASS_WARRIOR;
+}
+
+if (cInfo->dmgschool >= MAX_SPELL_SCHOOL)
+{
+sLog.outErrorDb("Creature (Entry: %u) has invalid spell school value (%u) in `dmgschool`.", cInfo->Entry, cInfo->dmgschool);
+const_cast<CreatureInfo*>(cInfo)->dmgschool = SPELL_SCHOOL_NORMAL;
+}
+
+if (cInfo->baseattacktime == 0)
+const_cast<CreatureInfo*>(cInfo)->baseattacktime = BASE_ATTACK_TIME;
+
+if (cInfo->rangeattacktime == 0)
+const_cast<CreatureInfo*>(cInfo)->rangeattacktime = BASE_ATTACK_TIME;
+
+if (cInfo->npcflag & UNIT_NPC_FLAG_SPELLCLICK)
+{
+sLog.outErrorDb("Creature (Entry: %u) has dynamic flag UNIT_NPC_FLAG_SPELLCLICK (%u) set, it is expected to be set by code handling `npc_spellclick_spells` content.", cInfo->Entry, UNIT_NPC_FLAG_SPELLCLICK);
+const_cast<CreatureInfo*>(cInfo)->npcflag &= ~UNIT_NPC_FLAG_SPELLCLICK;
+}
+
+if ((cInfo->npcflag & UNIT_NPC_FLAG_TRAINER) && cInfo->trainer_type >= MAX_TRAINER_TYPE)
+sLog.outErrorDb("Creature (Entry: %u) has wrong trainer type %u.", cInfo->Entry, cInfo->trainer_type);
+
+if (cInfo->type && !sCreatureTypeStore.LookupEntry(cInfo->type))
+{
+sLog.outErrorDb("Creature (Entry: %u) has invalid creature type (%u) in `type`.", cInfo->Entry, cInfo->type);
+const_cast<CreatureInfo*>(cInfo)->type = CREATURE_TYPE_HUMANOID;
+}
+
+// must exist or used hidden but used in data horse case
+if (cInfo->family && !sCreatureFamilyStore.LookupEntry(cInfo->family) && cInfo->family != CREATURE_FAMILY_HORSE_CUSTOM)
+{
+sLog.outErrorDb("Creature (Entry: %u) has invalid creature family (%u) in `family`.", cInfo->Entry, cInfo->family);
+const_cast<CreatureInfo*>(cInfo)->family = 0;
+}
+
+if (cInfo->InhabitType <= 0 || cInfo->InhabitType > INHABIT_ANYWHERE)
+{
+sLog.outErrorDb("Creature (Entry: %u) has wrong value (%u) in `InhabitType`, creature will not correctly walk/swim/fly.", cInfo->Entry, cInfo->InhabitType);
+const_cast<CreatureInfo*>(cInfo)->InhabitType = INHABIT_ANYWHERE;
+}
+
+if (cInfo->VehicleId)
+{
+VehicleEntry const* vehId = sVehicleStore.LookupEntry(cInfo->VehicleId);
+if (!vehId)
+{
+sLog.outErrorDb("Creature (Entry: %u) has a non-existing VehicleId (%u). This *WILL* cause the client to freeze!", cInfo->Entry, cInfo->VehicleId);
+const_cast<CreatureInfo*>(cInfo)->VehicleId = 0;
+}
+}
+
+if (cInfo->PetSpellDataId)
+{
+CreatureSpellDataEntry const* spellDataId = sCreatureSpellDataStore.LookupEntry(cInfo->PetSpellDataId);
+if (!spellDataId)
+sLog.outErrorDb("Creature (Entry: %u) has non-existing PetSpellDataId (%u).", cInfo->Entry, cInfo->PetSpellDataId);
+}
+
+for (uint8 j = 0; j < CREATURE_MAX_SPELLS; ++j)
+{
+if (cInfo->spells[j] && !sSpellStore.LookupEntry(cInfo->spells[j]))
+{
+sLog.outErrorDb("Creature (Entry: %u) has non-existing Spell%d (%u), set to 0.", cInfo->Entry, j+1, cInfo->spells[j]);
+const_cast<CreatureInfo*>(cInfo)->spells[j] = 0;
+}
+}
+
+if (cInfo->MovementType >= MAX_DB_MOTION_TYPE)
+{
+sLog.outErrorDb("Creature (Entry: %u) has wrong movement generator type (%u), ignored and set to IDLE.", cInfo->Entry, cInfo->MovementType);
+const_cast<CreatureInfo*>(cInfo)->MovementType = IDLE_MOTION_TYPE;
+}
+
+if (cInfo->equipmentId > 0) // 0 no equipment
+{
+if (!GetEquipmentInfo(cInfo->equipmentId))
+{
+sLog.outErrorDb("Table `creature_template` lists creature (Entry: %u) with `equipment_id` %u not found in table `creature_equip_template`, set to no equipment.", cInfo->Entry, cInfo->equipmentId);
+const_cast<CreatureInfo*>(cInfo)->equipmentId = 0;
+}
+}
+
+/// if not set custom creature scale then load scale from CreatureDisplayInfo.dbc
+if (cInfo->scale <= 0.0f)
+{
+if (displayScaleEntry)
+const_cast<CreatureInfo*>(cInfo)->scale = displayScaleEntry->scale;
+else
+const_cast<CreatureInfo*>(cInfo)->scale = 1.0f;
+}
+
+if (cInfo->expansion > (MAX_CREATURE_BASE_HP - 1))
+{
+sLog.outErrorDb("Table `creature_template` lists creature (Entry: %u) with expansion %u. Ignored and set to 0.", cInfo->Entry, cInfo->expansion);
+const_cast<CreatureInfo*>(cInfo)->expansion = 0;
+}
+
+const_cast<CreatureInfo*>(cInfo)->dmg_multiplier *= Creature::_GetDamageMod(cInfo->rank);
+}
+
+void ObjectMgr::ConvertCreatureAddonAuras(CreatureDataAddon* addon, char const* table, char const* guidEntryStr)
+{
+// Now add the auras, format "spellid effectindex spellid effectindex..."
+char *p,*s;
+std::map<uint32, uint32> val;
+s=p=(char*)reinterpret_cast<char const*>(addon->auras);
+if (p)
+{
+uint32 currSpellId = 0;
+bool spell = true;
+while (p[0] != 0)
+{
+++p;
+if (p[0] == ' ' || p[0] == 0)
+{
+if (spell)
+currSpellId = atoi(s);
+else
+{
+uint8 eff = atoi(s);
+if (eff >=3)
+{
+sLog.outErrorDb("Creature (%s: %u) has wrong `auras` data in `%s`(too high aura effect: %d for spell: %d)",guidEntryStr,addon->guidOrEntry,table,eff,currSpellId);
+}
+val[currSpellId] |= 1<<eff;
+}
+spell = !spell;
+if (p[0] == 0)
+break;
+s=++p;
+}
+}
+
+// free char* loaded memory
+delete[] (char*)reinterpret_cast<char const*>(addon->auras);
+
+// wrong list
+if (!spell)
+{
+addon->auras = NULL;
+sLog.outErrorDb("Creature (%s: %u) has wrong `auras` data in `%s`.",guidEntryStr,addon->guidOrEntry,table);
+return;
+}
+}
+
+// empty list
+if (val.empty())
+{
+addon->auras = NULL;
+return;
+}
+
+// replace by new structures array
+const_cast<CreatureDataAddonAura*&>(addon->auras) = new CreatureDataAddonAura[val.size()+1];
+
+uint32 i=0;
+for (std::map<uint32, uint32>::iterator itr = val.begin(); itr != val.end();++itr)
+{
+CreatureDataAddonAura& cAura = const_cast<CreatureDataAddonAura&>(addon->auras[i]);
+cAura.spell_id = itr->first;
+cAura.effectMask = itr->second;
+if (cAura.effectMask > 7 || !cAura.effectMask)
+{
+sLog.outErrorDb("Creature (%s: %u) has wrong effect for spell %u in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,cAura.spell_id,table);
+continue;
+}
+SpellEntry const *AdditionalSpellInfo = sSpellStore.LookupEntry(cAura.spell_id);
+if (!AdditionalSpellInfo)
+{
+sLog.outErrorDb("Creature (%s: %u) has wrong spell %u defined in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,cAura.spell_id,table);
+continue;
+}
+for (uint8 eff = 0; eff < MAX_SPELL_EFFECTS; ++eff)
+{
+if ((1<<eff) & cAura.effectMask)
+{
+if (!AdditionalSpellInfo->Effect[eff] || !AdditionalSpellInfo->EffectApplyAuraName[eff])
+{
+sLog.outErrorDb("Creature (%s: %u) has not aura effect %u of spell %u defined in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,eff,cAura.spell_id,table);
+continue;
+}
+else if (AdditionalSpellInfo->Effect[eff] == SPELL_EFFECT_PERSISTENT_AREA_AURA)
+{
+sLog.outErrorDb("Creature (%s: %u) has persistent area aura effect %u of spell %u defined in `auras` field in `%s`.",guidEntryStr,addon->guidOrEntry,eff,cAura.spell_id,table);
+continue;
+}
+}
+}
+
+++i;
+}
+
+// fill terminator element (after last added)
+CreatureDataAddonAura& endAura = const_cast<CreatureDataAddonAura&>(addon->auras[i]);
+endAura.spell_id = 0;
+endAura.effectMask = 0;
+}
+
+void ObjectMgr::LoadCreatureAddons(SQLStorage& creatureaddons, char const* entryName, char const* comment)
+{
+creatureaddons.Load();
+
+sLog.outString(">> Loaded %u %s", creatureaddons.RecordCount, comment);
+sLog.outString();
+
+// check data correctness and convert 'auras'
+for (uint32 i = 1; i < creatureaddons.MaxEntry; ++i)
+{
+CreatureDataAddon const* addon = creatureaddons.LookupEntry<CreatureDataAddon>(i);
+if (!addon)
+continue;
+
+if (addon->mount)
+{
+if (!sCreatureDisplayInfoStore.LookupEntry(addon->mount))
+{
+sLog.outErrorDb("Creature (%s %u) have invalid displayInfoId for mount (%u) defined in `%s`.", entryName, addon->guidOrEntry, addon->mount, creatureaddons.GetTableName());
+const_cast<CreatureDataAddon*>(addon)->mount = 0;
+}
+}
+
+if (!sEmotesStore.LookupEntry(addon->emote))
+sLog.outErrorDb("Creature (%s %u) have invalid emote (%u) defined in `%s`.", entryName, addon->guidOrEntry, addon->emote, creatureaddons.GetTableName());
+
+/*if (addon->move_flags & (MONSTER_MOVE_UNK1|MONSTER_MOVE_UNK4))
+{
+sLog.outErrorDb("Creature (%s %u) movement flags mask defined in `%s` include forbidden flags (" I32FMT ") that can crash client, cleanup at load.", entryName, addon->guidOrEntry, creatureaddons.GetTableName(), (MONSTER_MOVE_UNK1|MONSTER_MOVE_UNK4));
+const_cast<CreatureDataAddon*>(addon)->move_flags &= ~(MONSTER_MOVE_UNK1|MONSTER_MOVE_UNK4);
+}*/
+
+ConvertCreatureAddonAuras(const_cast<CreatureDataAddon*>(addon), creatureaddons.GetTableName(), entryName);
+}
+}
+
+void ObjectMgr::LoadCreatureAddons()
+{
+LoadCreatureAddons(sCreatureInfoAddonStorage,"Entry","creature template addons");
+
+// check entry ids
+for (uint32 i = 1; i < sCreatureInfoAddonStorage.MaxEntry; ++i)
+if (CreatureDataAddon const* addon = sCreatureInfoAddonStorage.LookupEntry<CreatureDataAddon>(i))
+if (!sCreatureStorage.LookupEntry<CreatureInfo>(addon->guidOrEntry))
+sLog.outErrorDb("Creature (Entry: %u) does not exist but has a record in `%s`",addon->guidOrEntry, sCreatureInfoAddonStorage.GetTableName());
+
+sLog.outString("Loading Creature Addon Data...");
+LoadCreatureAddons(sCreatureDataAddonStorage,"GUID","creature addons");
+
+// check entry ids
+for (uint32 i = 1; i < sCreatureDataAddonStorage.MaxEntry; ++i)
+if (CreatureDataAddon const* addon = sCreatureDataAddonStorage.LookupEntry<CreatureDataAddon>(i))
+if (mCreatureDataMap.find(addon->guidOrEntry) == mCreatureDataMap.end())
+sLog.outErrorDb("Creature (GUID: %u) does not exist but has a record in `creature_addon`",addon->guidOrEntry);
+}
+
+EquipmentInfo const* ObjectMgr::GetEquipmentInfo(uint32 entry)
+{
+return sEquipmentStorage.LookupEntry<EquipmentInfo>(entry);
+}
+
+void ObjectMgr::LoadEquipmentTemplates()
+{
+sEquipmentStorage.Load();
+
+for (uint32 i = 0; i < sEquipmentStorage.MaxEntry; ++i)
+{
+EquipmentInfo const* eqInfo = sEquipmentStorage.LookupEntry<EquipmentInfo>(i);
+
+if (!eqInfo)
+continue;
+
+for (uint8 j = 0; j < 3; ++j)
+{
+if (!eqInfo->equipentry[j])
+continue;
+
+ItemEntry const *dbcitem = sItemStore.LookupEntry(eqInfo->equipentry[j]);
+
+if (!dbcitem)
+{
+sLog.outErrorDb("Unknown item (entry=%u) in creature_equip_template.equipentry%u for entry = %u, forced to 0.", eqInfo->equipentry[j], j+1, i);
+const_cast<EquipmentInfo*>(eqInfo)->equipentry[j] = 0;
+continue;
+}
+
+if (dbcitem->InventoryType != INVTYPE_WEAPON &&
+dbcitem->InventoryType != INVTYPE_SHIELD &&
+dbcitem->InventoryType != INVTYPE_RANGED &&
+dbcitem->InventoryType != INVTYPE_2HWEAPON &&
+dbcitem->InventoryType != INVTYPE_WEAPONMAINHAND &&
+dbcitem->InventoryType != INVTYPE_WEAPONOFFHAND &&
+dbcitem->InventoryType != INVTYPE_HOLDABLE &&
+dbcitem->InventoryType != INVTYPE_THROWN &&
+dbcitem->InventoryType != INVTYPE_RANGEDRIGHT &&
+dbcitem->InventoryType != INVTYPE_RELIC)
+
+{
+sLog.outErrorDb("Item (entry=%u) in creature_equip_template.equipentry%u for entry = %u is not equipable in a hand, forced to 0.", eqInfo->equipentry[j], j+1, i);
+const_cast<EquipmentInfo*>(eqInfo)->equipentry[j] = 0;
+}
+}
+}
+sLog.outString(">> Loaded %u equipment template", sEquipmentStorage.RecordCount);
+sLog.outString();
+}
+
+CreatureModelInfo const* ObjectMgr::GetCreatureModelInfo(uint32 modelid)
+{
+return sCreatureModelStorage.LookupEntry<CreatureModelInfo>(modelid);
+}
+
+uint32 ObjectMgr::ChooseDisplayId(uint32 /*team*/, const CreatureInfo *cinfo, const CreatureData *data /*= NULL*/)
+{
+// Load creature model (display id)
+uint32 display_id = 0;
+
+if (!data || data->displayid == 0)
+{
+display_id = cinfo->GetRandomValidModelId();
+}
+else
+return data->displayid;
+
+return display_id;
+}
+
+void ObjectMgr::ChooseCreatureFlags(const CreatureInfo *cinfo, uint32& npcflag, uint32& unit_flags, uint32& dynamicflags, const CreatureData *data /*= NULL*/)
+{
+npcflag = cinfo->npcflag;
+unit_flags = cinfo->unit_flags;
+dynamicflags = cinfo->dynamicflags;
+
+if (data)
+{
+if (data->npcflag)
+npcflag = data->npcflag;
+
+if (data->unit_flags)
+unit_flags = data->unit_flags;
+
+if (data->dynamicflags)
+dynamicflags = data->dynamicflags;
+}
+}
+
+CreatureModelInfo const* ObjectMgr::GetCreatureModelRandomGender(uint32 display_id)
+{
+CreatureModelInfo const *minfo = GetCreatureModelInfo(display_id);
+if (!minfo)
+return NULL;
+
+// If a model for another gender exists, 50% chance to use it
+if (minfo->modelid_other_gender != 0 && urand(0,1) == 0)
+{
+CreatureModelInfo const *minfo_tmp = GetCreatureModelInfo(minfo->modelid_other_gender);
+if (!minfo_tmp)
+{
+sLog.outErrorDb("Model (Entry: %u) has modelid_other_gender %u not found in table `creature_model_info`. ", minfo->modelid, minfo->modelid_other_gender);
+return minfo; // not fatal, just use the previous one
+}
+else
+return minfo_tmp;
+}
+else
+return minfo;
+}
+
+void ObjectMgr::LoadCreatureModelInfo()
+{
+sCreatureModelStorage.Load();
+
+// post processing
+for (uint32 i = 1; i < sCreatureModelStorage.MaxEntry; ++i)
+{
+CreatureModelInfo const *minfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(i);
+if (!minfo)
+continue;
+
+if (!sCreatureDisplayInfoStore.LookupEntry(minfo->modelid))
+sLog.outErrorDb("Table `creature_model_info` has model for not existed display id (%u).", minfo->modelid);
+
+if (minfo->gender > GENDER_NONE)
+{
+sLog.outErrorDb("Table `creature_model_info` has wrong gender (%u) for display id (%u).", uint32(minfo->gender), minfo->modelid);
+const_cast<CreatureModelInfo*>(minfo)->gender = GENDER_MALE;
+}
+
+if (minfo->modelid_other_gender && !sCreatureDisplayInfoStore.LookupEntry(minfo->modelid_other_gender))
+{
+sLog.outErrorDb("Table `creature_model_info` has not existed alt.gender model (%u) for existed display id (%u).", minfo->modelid_other_gender, minfo->modelid);
+const_cast<CreatureModelInfo*>(minfo)->modelid_other_gender = 0;
+}
+}
+
+sLog.outString(">> Loaded %u creature model based info", sCreatureModelStorage.RecordCount);
+sLog.outString();
+
+// check if combat_reach is valid
+for (uint32 i = 1; i < sCreatureModelStorage.MaxEntry; ++i)
+{
+CreatureModelInfo const* mInfo = sCreatureModelStorage.LookupEntry<CreatureModelInfo>(i);
+if (!mInfo)
+continue;
+
+if (mInfo->combat_reach < 0.1f)
+{
+//sLog.outErrorDb("Creature model (Entry: %u) has invalid combat reach (%f), setting it to 0.5", mInfo->modelid, mInfo->combat_reach);
+const_cast<CreatureModelInfo*>(mInfo)->combat_reach = DEFAULT_COMBAT_REACH;
+}
+}
+}
+
+bool ObjectMgr::CheckCreatureLinkedRespawn(uint32 guid, uint32 linkedGuid) const
+{
+const CreatureData* const slave = GetCreatureData(guid);
+const CreatureData* const master = GetCreatureData(linkedGuid);
+
+if (!slave || !master) // they must have a corresponding entry in db
+{
+sLog.outError("LinkedRespawn: Creature '%u' linking to '%u' which doesn't exist",guid,linkedGuid);
+return false;
+}
+
+const MapEntry* const map = sMapStore.LookupEntry(master->mapid);
+
+if (master->mapid != slave->mapid // link only to same map
+&& (!map || map->Instanceable())) // or to unistanced world
+{
+sLog.outError("LinkedRespawn: Creature '%u' linking to '%u' on an unpermitted map",guid,linkedGuid);
+return false;
+}
+
+if (!(master->spawnMask & slave->spawnMask) // they must have a possibility to meet (normal/heroic difficulty)
+&& (!map || map->Instanceable()))
+{
+sLog.outError("LinkedRespawn: Creature '%u' linking to '%u' with not corresponding spawnMask",guid,linkedGuid);
+return false;
+}
+
+return true;
+}
+
+void ObjectMgr::LoadCreatureLinkedRespawn()
+{
+mCreatureLinkedRespawnMap.clear();
+QueryResult result = WorldDatabase.Query("SELECT guid, linkedGuid FROM creature_linked_respawn ORDER BY guid ASC");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 linked respawns. DB table `creature_linked_respawn` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 guid = fields[0].GetUInt32();
+uint32 linkedGuid = fields[1].GetUInt32();
+
+if (CheckCreatureLinkedRespawn(guid,linkedGuid))
+mCreatureLinkedRespawnMap[guid] = linkedGuid;
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded " UI64FMTD " linked respawns", uint64(mCreatureLinkedRespawnMap.size()));
+}
+
+bool ObjectMgr::SetCreatureLinkedRespawn(uint32 guid, uint32 linkedGuid)
+{
+if (!guid)
+return false;
+
+if (!linkedGuid) // we're removing the linking
+{
+mCreatureLinkedRespawnMap.erase(guid);
+PreparedStatement *stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_CRELINKED_RESPAWN);
+stmt->setUInt32(0, guid);
+WorldDatabase.Execute(stmt);
+return true;
+}
+
+if (CheckCreatureLinkedRespawn(guid,linkedGuid)) // we add/change linking
+{
+mCreatureLinkedRespawnMap[guid] = linkedGuid;
+PreparedStatement *stmt = WorldDatabase.GetPreparedStatement(WORLD_REP_CRELINKED_RESPAWN);
+stmt->setUInt32(0, guid);
+stmt->setUInt32(1, linkedGuid);
+WorldDatabase.Execute(stmt);
+return true;
+}
+
+return false;
+}
+
+void ObjectMgr::LoadCreatures()
+{
+uint32 count = 0;
+// 0 1 2 3
+QueryResult result = WorldDatabase.Query("SELECT creature.guid, id, map, modelid,"
+// 4 5 6 7 8 9 10 11
+"equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint,"
+// 12 13 14 15 16 17 18 19
+"curhealth, curmana, DeathState, MovementType, spawnMask, phaseMask, event, pool_entry,"
+// 20 21 22
+"creature.npcflag, creature.unit_flags, creature.dynamicflags "
+"FROM creature LEFT OUTER JOIN game_event_creature ON creature.guid = game_event_creature.guid "
+"LEFT OUTER JOIN pool_creature ON creature.guid = pool_creature.guid");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 creature. DB table `creature` is empty.");
+return;
+}
+
+// build single time for check creature data
+std::set<uint32> difficultyCreatures[MAX_DIFFICULTY - 1];
+for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
+if (CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i))
+for (uint32 diff = 0; diff < MAX_DIFFICULTY - 1; ++diff)
+if (cInfo->DifficultyEntry[diff])
+difficultyCreatures[diff].insert(cInfo->DifficultyEntry[diff]);
+
+// build single time for check spawnmask
+std::map<uint32,uint32> spawnMasks;
+for (uint32 i = 0; i < sMapStore.GetNumRows(); ++i)
+if (sMapStore.LookupEntry(i))
+for (int k = 0; k < MAX_DIFFICULTY; ++k)
+if (GetMapDifficultyData(i,Difficulty(k)))
+spawnMasks[i] |= (1 << k);
+
+//TODO: remove this
+//sGameEventMgr.mGameEventCreatureGuids.resize(52*2-1);
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 guid = fields[ 0].GetUInt32();
+uint32 entry = fields[ 1].GetUInt32();
+
+CreatureInfo const* cInfo = GetCreatureTemplate(entry);
+if (!cInfo)
+{
+sLog.outErrorDb("Table `creature` has creature (GUID: %u) with non existing creature entry %u, skipped.", guid, entry);
+continue;
+}
+
+CreatureData& data = mCreatureDataMap[guid];
+
+data.id = entry;
+data.mapid = fields[ 2].GetUInt32();
+data.displayid = fields[ 3].GetUInt32();
+data.equipmentId = fields[ 4].GetUInt32();
+data.posX = fields[ 5].GetFloat();
+data.posY = fields[ 6].GetFloat();
+data.posZ = fields[ 7].GetFloat();
+data.orientation = fields[ 8].GetFloat();
+data.spawntimesecs = fields[ 9].GetUInt32();
+data.spawndist = fields[10].GetFloat();
+data.currentwaypoint= fields[11].GetUInt32();
+data.curhealth = fields[12].GetUInt32();
+data.curmana = fields[13].GetUInt32();
+data.is_dead = fields[14].GetBool();
+data.movementType = fields[15].GetUInt8();
+data.spawnMask = fields[16].GetUInt8();
+data.phaseMask = fields[17].GetUInt16();
+int16 gameEvent = fields[18].GetInt16();
+uint32 PoolId = fields[19].GetUInt32();
+data.npcflag = fields[20].GetUInt32();
+data.unit_flags = fields[21].GetUInt32();
+data.dynamicflags = fields[22].GetUInt32();
+
+MapEntry const* mapEntry = sMapStore.LookupEntry(data.mapid);
+if (!mapEntry)
+{
+sLog.outErrorDb("Table `creature` have creature (GUID: %u) that spawned at not existed map (Id: %u), skipped.",guid, data.mapid);
+continue;
+}
+
+if (data.spawnMask & ~spawnMasks[data.mapid])
+sLog.outErrorDb("Table `creature` have creature (GUID: %u) that have wrong spawn mask %u including not supported difficulty modes for map (Id: %u).",guid, data.spawnMask, data.mapid);
+
+bool ok = true;
+for (uint32 diff = 0; diff < MAX_DIFFICULTY - 1 && ok; ++diff)
+{
+if (difficultyCreatures[diff].find(data.id) != difficultyCreatures[diff].end())
+{
+sLog.outErrorDb("Table `creature` have creature (GUID: %u) that listed as difficulty %u template (entry: %u) in `creature_template`, skipped.",
+guid, diff + 1, data.id);
+ok = false;
+}
+}
+if (!ok)
+continue;
+
+// I do not know why but in db most display id are not zero
+/*if (data.displayid == 11686 || data.displayid == 24719)
+{
+(const_cast<CreatureInfo*>(cInfo))->flags_extra |= CREATURE_FLAG_EXTRA_TRIGGER;
+}
+else if (data.displayid == cInfo->DisplayID_A || data.displayid == cInfo->DisplayID_A2
+|| data.displayid == cInfo->DisplayID_H || data.displayid == cInfo->DisplayID_H2)
+data.displayid = 0;
+*/
+
+if (data.equipmentId > 0) // -1 no equipment, 0 use default
+{
+if (!GetEquipmentInfo(data.equipmentId))
+{
+sLog.outErrorDb("Table `creature` have creature (Entry: %u) with equipment_id %u not found in table `creature_equip_template`, set to no equipment.", data.id, data.equipmentId);
+data.equipmentId = -1;
+}
+}
+
+if (cInfo->flags_extra & CREATURE_FLAG_EXTRA_INSTANCE_BIND)
+{
+if (!mapEntry || !mapEntry->IsDungeon())
+sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `creature_template`.`flags_extra` including CREATURE_FLAG_EXTRA_INSTANCE_BIND but creature are not in instance.", guid, data.id);
+}
+
+if (data.spawndist < 0.0f)
+{
+sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `spawndist`< 0, set to 0.", guid, data.id);
+data.spawndist = 0.0f;
+}
+else if (data.movementType == RANDOM_MOTION_TYPE)
+{
+if (data.spawndist == 0.0f)
+{
+sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `MovementType`=1 (random movement) but with `spawndist`=0, replace by idle movement type (0).", guid, data.id);
+data.movementType = IDLE_MOTION_TYPE;
+}
+else if (cInfo->flags_extra & CREATURE_FLAG_EXTRA_TRIGGER)
+data.movementType = IDLE_MOTION_TYPE;
+}
+else if (data.movementType == IDLE_MOTION_TYPE)
+{
+if (data.spawndist != 0.0f)
+{
+sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `MovementType`=0 (idle) have `spawndist`<>0, set to 0.", guid, data.id);
+data.spawndist = 0.0f;
+}
+}
+
+if (data.phaseMask == 0)
+{
+sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with `phaseMask`=0 (not visible for anyone), set to 1.", guid, data.id);
+data.phaseMask = 1;
+}
+
+if (data.npcflag & UNIT_NPC_FLAG_SPELLCLICK)
+{
+sLog.outErrorDb("Table `creature` have creature (GUID: %u Entry: %u) with npcflag UNIT_NPC_FLAG_SPELLCLICK (%u) set, it is expected to be set by code handling `npc_spellclick_spells` content.", guid, data.id, UNIT_NPC_FLAG_SPELLCLICK);
+data.npcflag &= ~UNIT_NPC_FLAG_SPELLCLICK;
+}
+
+//if (entry == 32307 || entry == 32308)
+/*if (entry == 30739 || entry == 30740)
+{
+gameEvent = 51;
+uint32 guid2 = sObjectMgr.GenerateLowGuid(HIGHGUID_UNIT);
+CreatureData& data2 = mCreatureDataMap[guid2];
+data2 = data;
+// data2.id = (entry == 32307 ? 32308 : 32307);
+data2.id = (entry == 30739 ? 30740 : 30739);
+data2.displayid = 0;
+sGameEventMgr.mGameEventCreatureGuids[51+51].push_back(guid);
+sGameEventMgr.mGameEventCreatureGuids[51+50].push_back(guid2);
+}*/
+
+if (gameEvent == 0 && PoolId == 0) // if not this is to be managed by GameEvent System or Pool system
+AddCreatureToGrid(guid, &data);
+
+++count;
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u creatures", (uint32)mCreatureDataMap.size());
+}
+
+void ObjectMgr::AddCreatureToGrid(uint32 guid, CreatureData const* data)
+{
+uint8 mask = data->spawnMask;
+for (uint8 i = 0; mask != 0; i++, mask >>= 1)
+{
+if (mask & 1)
+{
+CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
+uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
+
+CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
+cell_guids.creatures.insert(guid);
+}
+}
+}
+
+void ObjectMgr::RemoveCreatureFromGrid(uint32 guid, CreatureData const* data)
+{
+uint8 mask = data->spawnMask;
+for (uint8 i = 0; mask != 0; i++, mask >>= 1)
+{
+if (mask & 1)
+{
+CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
+uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
+
+CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
+cell_guids.creatures.erase(guid);
+}
+}
+}
+
+uint32 ObjectMgr::AddGOData(uint32 entry, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay, float rotation0, float rotation1, float rotation2, float rotation3)
+{
+GameObjectInfo const* goinfo = GetGameObjectInfo(entry);
+if (!goinfo)
+return 0;
+
+Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId));
+if (!map)
+return 0;
+
+uint32 guid = GenerateLowGuid(HIGHGUID_GAMEOBJECT);
+GameObjectData& data = NewGOData(guid);
+data.id = entry;
+data.mapid = mapId;
+data.posX = x;
+data.posY = y;
+data.posZ = z;
+data.orientation = o;
+data.rotation0 = rotation0;
+data.rotation1 = rotation1;
+data.rotation2 = rotation2;
+data.rotation3 = rotation3;
+data.spawntimesecs = spawntimedelay;
+data.animprogress = 100;
+data.spawnMask = 1;
+data.go_state = GO_STATE_READY;
+data.phaseMask = PHASEMASK_NORMAL;
+data.artKit = goinfo->type == GAMEOBJECT_TYPE_CAPTURE_POINT ? 21 : 0;
+data.dbData = false;
+
+AddGameobjectToGrid(guid, &data);
+
+// Spawn if necessary (loaded grids only)
+// We use spawn coords to spawn
+if (!map->Instanceable() && map->IsLoaded(x, y))
+{
+GameObject *go = new GameObject;
+if (!go->LoadFromDB(guid, map))
+{
+sLog.outError("AddGOData: cannot add gameobject entry %u to map", entry);
+delete go;
+return 0;
+}
+map->Add(go);
+}
+
+sLog.outDebug("AddGOData: dbguid %u entry %u map %u x %f y %f z %f o %f", guid, entry, mapId, x, y, z, o);
+
+return guid;
+}
+
+bool ObjectMgr::MoveCreData(uint32 guid, uint32 mapId, Position pos)
+{
+CreatureData& data = NewOrExistCreatureData(guid);
+if (!data.id)
+return false;
+
+RemoveCreatureFromGrid(guid, &data);
+if (data.posX == pos.GetPositionX() && data.posY == pos.GetPositionY() && data.posZ == pos.GetPositionZ())
+return true;
+data.posX = pos.GetPositionX();
+data.posY = pos.GetPositionY();
+data.posZ = pos.GetPositionZ();
+data.orientation = pos.GetOrientation();
+AddCreatureToGrid(guid, &data);
+
+// Spawn if necessary (loaded grids only)
+if (Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId)))
+{
+// We use spawn coords to spawn
+if (!map->Instanceable() && map->IsLoaded(data.posX, data.posY))
+{
+Creature *creature = new Creature;
+if (!creature->LoadFromDB(guid, map))
+{
+sLog.outError("AddCreature: cannot add creature entry %u to map", guid);
+delete creature;
+return false;
+}
+map->Add(creature);
+}
+}
+return true;
+}
+
+uint32 ObjectMgr::AddCreData(uint32 entry, uint32 /*team*/, uint32 mapId, float x, float y, float z, float o, uint32 spawntimedelay)
+{
+CreatureInfo const *cInfo = GetCreatureTemplate(entry);
+if (!cInfo)
+return 0;
+
+uint32 level = cInfo->minlevel == cInfo->maxlevel ? cInfo->minlevel : urand(cInfo->minlevel, cInfo->maxlevel); // Only used for extracting creature base stats
+CreatureBaseStats const* stats = sObjectMgr.GetCreatureBaseStats(level, cInfo->unit_class);
+
+uint32 guid = GenerateLowGuid(HIGHGUID_UNIT);
+CreatureData& data = NewOrExistCreatureData(guid);
+data.id = entry;
+data.mapid = mapId;
+data.displayid = 0;
+data.equipmentId = cInfo->equipmentId;
+data.posX = x;
+data.posY = y;
+data.posZ = z;
+data.orientation = o;
+data.spawntimesecs = spawntimedelay;
+data.spawndist = 0;
+data.currentwaypoint = 0;
+data.curhealth = stats->GenerateHealth(cInfo);
+data.curmana = stats->GenerateMana(cInfo);
+data.is_dead = false;
+data.movementType = cInfo->MovementType;
+data.spawnMask = 1;
+data.phaseMask = PHASEMASK_NORMAL;
+data.dbData = false;
+data.npcflag = cInfo->npcflag;
+data.unit_flags = cInfo->unit_flags;
+data.dynamicflags = cInfo->dynamicflags;
+
+
+AddCreatureToGrid(guid, &data);
+
+// Spawn if necessary (loaded grids only)
+if (Map* map = const_cast<Map*>(sMapMgr.CreateBaseMap(mapId)))
+{
+// We use spawn coords to spawn
+if (!map->Instanceable() && !map->IsRemovalGrid(x, y))
+{
+Creature* creature = new Creature;
+if (!creature->LoadFromDB(guid, map))
+{
+sLog.outError("AddCreature: cannot add creature entry %u to map", entry);
+delete creature;
+return 0;
+}
+map->Add(creature);
+}
+}
+
+return guid;
+}
+
+void ObjectMgr::LoadGameobjects()
+{
+uint32 count = 0;
+
+// 0 1 2 3 4 5 6
+QueryResult result = WorldDatabase.Query("SELECT gameobject.guid, id, map, position_x, position_y, position_z, orientation,"
+// 7 8 9 10 11 12 13 14 15 16 17
+"rotation0, rotation1, rotation2, rotation3, spawntimesecs, animprogress, state, spawnMask, phaseMask, event, pool_entry "
+"FROM gameobject LEFT OUTER JOIN game_event_gameobject ON gameobject.guid = game_event_gameobject.guid "
+"LEFT OUTER JOIN pool_gameobject ON gameobject.guid = pool_gameobject.guid");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 gameobjects. DB table `gameobject` is empty.");
+return;
+}
+
+// build single time for check spawnmask
+std::map<uint32,uint32> spawnMasks;
+for (uint32 i = 0; i < sMapStore.GetNumRows(); ++i)
+if (sMapStore.LookupEntry(i))
+for (int k = 0; k < MAX_DIFFICULTY; ++k)
+if (GetMapDifficultyData(i,Difficulty(k)))
+spawnMasks[i] |= (1 << k);
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 guid = fields[ 0].GetUInt32();
+uint32 entry = fields[ 1].GetUInt32();
+
+GameObjectInfo const* gInfo = GetGameObjectInfo(entry);
+if (!gInfo)
+{
+sLog.outErrorDb("Table `gameobject` has gameobject (GUID: %u) with non existing gameobject entry %u, skipped.", guid, entry);
+continue;
+}
+
+if (!gInfo->displayId)
+{
+switch (gInfo->type)
+{
+case GAMEOBJECT_TYPE_TRAP:
+case GAMEOBJECT_TYPE_SPELL_FOCUS:
+break;
+default:
+sLog.outErrorDb("Gameobject (GUID: %u Entry %u GoType: %u) doesn't have displayId (%u), not loaded.", guid, entry, gInfo->type, gInfo->displayId);
+break;
+}
+}
+
+if (gInfo->displayId && !sGameObjectDisplayInfoStore.LookupEntry(gInfo->displayId))
+{
+sLog.outErrorDb("Gameobject (GUID: %u Entry %u GoType: %u) have invalid displayId (%u), not loaded.",guid, entry, gInfo->type, gInfo->displayId);
+continue;
+}
+
+GameObjectData& data = mGameObjectDataMap[guid];
+
+data.id = entry;
+data.mapid = fields[ 2].GetUInt32();
+data.posX = fields[ 3].GetFloat();
+data.posY = fields[ 4].GetFloat();
+data.posZ = fields[ 5].GetFloat();
+data.orientation = fields[ 6].GetFloat();
+data.rotation0 = fields[ 7].GetFloat();
+data.rotation1 = fields[ 8].GetFloat();
+data.rotation2 = fields[ 9].GetFloat();
+data.rotation3 = fields[10].GetFloat();
+data.spawntimesecs = fields[11].GetInt32();
+
+MapEntry const* mapEntry = sMapStore.LookupEntry(data.mapid);
+if (!mapEntry)
+{
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) that spawned at not existed map (Id: %u), skip", guid, data.id, data.mapid);
+continue;
+}
+
+if (data.spawntimesecs == 0 && gInfo->IsDespawnAtAction())
+{
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with `spawntimesecs` (0) value, but gameobejct marked as despawnable at action.",guid,data.id);
+}
+
+data.animprogress = fields[12].GetUInt32();
+data.artKit = 0;
+
+uint32 go_state = fields[13].GetUInt32();
+if (go_state >= MAX_GO_STATE)
+{
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid `state` (%u) value, skip",guid,data.id,go_state);
+continue;
+}
+data.go_state = GOState(go_state);
+
+data.spawnMask = fields[14].GetUInt8();
+
+if (data.spawnMask & ~spawnMasks[data.mapid])
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) that have wrong spawn mask %u including not supported difficulty modes for map (Id: %u), skip", guid, data.id, data.spawnMask, data.mapid);
+
+data.phaseMask = fields[15].GetUInt16();
+int16 gameEvent = fields[16].GetInt16();
+uint32 PoolId = fields[17].GetUInt32();
+
+if (data.rotation2 < -1.0f || data.rotation2 > 1.0f)
+{
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid rotation2 (%f) value, skip",guid,data.id,data.rotation2);
+continue;
+}
+
+if (data.rotation3 < -1.0f || data.rotation3 > 1.0f)
+{
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid rotation3 (%f) value, skip",guid,data.id,data.rotation3);
+continue;
+}
+
+if (!MapManager::IsValidMapCoord(data.mapid,data.posX,data.posY,data.posZ,data.orientation))
+{
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with invalid coordinates, skip",guid,data.id);
+continue;
+}
+
+if (data.phaseMask == 0)
+{
+sLog.outErrorDb("Table `gameobject` have gameobject (GUID: %u Entry: %u) with `phaseMask`=0 (not visible for anyone), set to 1.",guid,data.id);
+data.phaseMask = 1;
+}
+
+if (gameEvent == 0 && PoolId == 0) // if not this is to be managed by GameEvent System or Pool system
+AddGameobjectToGrid(guid, &data);
+++count;
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu gameobjects", (unsigned long)mGameObjectDataMap.size());
+}
+
+void ObjectMgr::AddGameobjectToGrid(uint32 guid, GameObjectData const* data)
+{
+uint8 mask = data->spawnMask;
+for (uint8 i = 0; mask != 0; i++, mask >>= 1)
+{
+if (mask & 1)
+{
+CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
+uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
+
+CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
+cell_guids.gameobjects.insert(guid);
+}
+}
+}
+
+void ObjectMgr::RemoveGameobjectFromGrid(uint32 guid, GameObjectData const* data)
+{
+uint8 mask = data->spawnMask;
+for (uint8 i = 0; mask != 0; i++, mask >>= 1)
+{
+if (mask & 1)
+{
+CellPair cell_pair = Trinity::ComputeCellPair(data->posX, data->posY);
+uint32 cell_id = (cell_pair.y_coord*TOTAL_NUMBER_OF_CELLS_PER_MAP) + cell_pair.x_coord;
+
+CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(data->mapid,i)][cell_id];
+cell_guids.gameobjects.erase(guid);
+}
+}
+}
+
+void ObjectMgr::LoadCreatureRespawnTimes()
+{
+uint32 count = 0;
+
+QueryResult result = WorldDatabase.Query("SELECT guid,respawntime,instance FROM creature_respawn");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded 0 creature respawn time.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 loguid = fields[0].GetUInt32();
+uint64 respawn_time = fields[1].GetUInt64();
+uint32 instance = fields[2].GetUInt32();
+
+mCreatureRespawnTimes[MAKE_PAIR64(loguid,instance)] = time_t(respawn_time);
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu creature respawn times", (unsigned long)mCreatureRespawnTimes.size());
+}
+
+void ObjectMgr::LoadGameobjectRespawnTimes()
+{
+// remove outdated data
+PreparedStatement *stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_GAMEOBJECT_RESPAWN_TIMES);
+WorldDatabase.Execute(stmt);
+
+uint32 count = 0;
+
+QueryResult result = WorldDatabase.Query("SELECT guid,respawntime,instance FROM gameobject_respawn");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded 0 gameobject respawn time.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 loguid = fields[0].GetUInt32();
+uint64 respawn_time = fields[1].GetUInt64();
+uint32 instance = fields[2].GetUInt32();
+
+mGORespawnTimes[MAKE_PAIR64(loguid,instance)] = time_t(respawn_time);
+
+++count;
+} while (result->NextRow());
+
+sLog.outString(">> Loaded %lu gameobject respawn times", (unsigned long)mGORespawnTimes.size());
+sLog.outString();
+}
+
+Player* ObjectMgr::GetPlayerByLowGUID(uint32 lowguid) const
+{
+uint64 guid = MAKE_NEW_GUID(lowguid, 0, HIGHGUID_PLAYER);
+return ObjectAccessor::FindPlayer(guid);
+}
+
+// name must be checked to correctness (if received) before call this function
+uint64 ObjectMgr::GetPlayerGUIDByName(std::string name) const
+{
+uint64 guid = 0;
+
+CharacterDatabase.escape_string(name);
+
+// Player name safe to sending to DB (checked at login) and this function using
+QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE name = '%s'", name.c_str());
+if (result)
+guid = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+
+return guid;
+}
+
+bool ObjectMgr::GetPlayerNameByGUID(const uint64 &guid, std::string &name) const
+{
+// prevent DB access for online player
+if (Player* player = GetPlayer(guid))
+{
+name = player->GetName();
+return true;
+}
+
+QueryResult result = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+
+if (result)
+{
+name = (*result)[0].GetString();
+return true;
+}
+
+return false;
+}
+
+uint32 ObjectMgr::GetPlayerTeamByGUID(const uint64 &guid) const
+{
+// prevent DB access for online player
+if (Player* player = GetPlayer(guid))
+{
+return Player::TeamForRace(player->getRace());
+}
+
+QueryResult result = CharacterDatabase.PQuery("SELECT race FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+
+if (result)
+{
+uint8 race = (*result)[0].GetUInt8();
+return Player::TeamForRace(race);
+}
+
+return 0;
+}
+
+uint32 ObjectMgr::GetPlayerAccountIdByGUID(const uint64 &guid) const
+{
+// prevent DB access for online player
+if (Player* player = GetPlayer(guid))
+{
+return player->GetSession()->GetAccountId();
+}
+
+QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE guid = '%u'", GUID_LOPART(guid));
+if (result)
+{
+uint32 acc = (*result)[0].GetUInt32();
+return acc;
+}
+
+return 0;
+}
+
+uint32 ObjectMgr::GetPlayerAccountIdByPlayerName(const std::string& name) const
+{
+QueryResult result = CharacterDatabase.PQuery("SELECT account FROM characters WHERE name = '%s'", name.c_str());
+if (result)
+{
+uint32 acc = (*result)[0].GetUInt32();
+return acc;
+}
+
+return 0;
+}
+
+void ObjectMgr::LoadItemLocales()
+{
+mItemLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT entry,name_loc1,description_loc1,name_loc2,description_loc2,name_loc3,description_loc3,name_loc4,description_loc4,name_loc5,description_loc5,name_loc6,description_loc6,name_loc7,description_loc7,name_loc8,description_loc8 FROM locales_item");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+ItemLocale& data = mItemLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+LocaleConstant locale = (LocaleConstant) i;
+std::string str = fields[1 + 2 * (i - 1)].GetString();
+AddLocaleString(str, locale, data.Name);
+
+str = fields[1 + 2 * (i - 1) + 1].GetString();
+AddLocaleString(str, locale, data.Description);
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu Item locale strings", (unsigned long)mItemLocaleMap.size());
+}
+
+struct SQLItemLoader : public SQLStorageLoaderBase<SQLItemLoader>
+{
+template<class D>
+void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
+{
+dst = D(sObjectMgr.GetScriptId(src));
+}
+};
+
+void ObjectMgr::LoadItemPrototypes()
+{
+SQLItemLoader loader;
+loader.Load(sItemStorage);
+sLog.outString(">> Loaded %u item prototypes", sItemStorage.RecordCount);
+sLog.outString();
+
+// check data correctness
+for (uint32 i = 1; i < sItemStorage.MaxEntry; ++i)
+{
+ItemPrototype const* proto = sItemStorage.LookupEntry<ItemPrototype >(i);
+ItemEntry const *dbcitem = sItemStore.LookupEntry(i);
+if (!proto)
+{
+/* to many errors, and possible not all items really used in game
+if (dbcitem)
+sLog.outErrorDb("Item (Entry: %u) doesn't exists in DB, but must exist.",i);
+*/
+continue;
+}
+
+if (dbcitem)
+{
+if (proto->Class != dbcitem->Class)
+{
+sLog.outErrorDb("Item (Entry: %u) not correct class %u, must be %u (still using DB value).",i,proto->Class,dbcitem->Class);
+// It safe let use Class from DB
+}
+/* disabled: have some strange wrong cases for Subclass values.
+for enable also uncomment Subclass field in ItemEntry structure and in Itemfmt[]
+if (proto->SubClass != dbcitem->SubClass)
+{
+sLog.outErrorDb("Item (Entry: %u) not correct (Class: %u, Sub: %u) pair, must be (Class: %u, Sub: %u) (still using DB value).",i,proto->Class,proto->SubClass,dbcitem->Class,dbcitem->SubClass);
+// It safe let use Subclass from DB
+}
+*/
+
+if (proto->Unk0 != dbcitem->Unk0)
+{
+sLog.outErrorDb("Item (Entry: %u) not correct %i Unk0, must be %i (still using DB value).",i,proto->Unk0,dbcitem->Unk0);
+// It safe let use Unk0 from DB
+}
+
+if (proto->Material != dbcitem->Material)
+{
+sLog.outErrorDb("Item (Entry: %u) not correct %i material, must be %i (still using DB value).",i,proto->Material,dbcitem->Material);
+// It safe let use Material from DB
+}
+
+if (proto->InventoryType != dbcitem->InventoryType)
+{
+sLog.outErrorDb("Item (Entry: %u) not correct %u inventory type, must be %u (still using DB value).",i,proto->InventoryType,dbcitem->InventoryType);
+// It safe let use InventoryType from DB
+}
+
+if (proto->DisplayInfoID != dbcitem->DisplayId)
+{
+sLog.outErrorDb("Item (Entry: %u) not correct %u display id, must be %u (using it).",i,proto->DisplayInfoID,dbcitem->DisplayId);
+const_cast<ItemPrototype*>(proto)->DisplayInfoID = dbcitem->DisplayId;
+}
+if (proto->Sheath != dbcitem->Sheath)
+{
+sLog.outErrorDb("Item (Entry: %u) not correct %u sheath, must be %u (using it).",i,proto->Sheath,dbcitem->Sheath);
+const_cast<ItemPrototype*>(proto)->Sheath = dbcitem->Sheath;
+}
+}
+else
+sLog.outErrorDb("Item (Entry: %u) not correct (not listed in list of existed items).",i);
+
+if (proto->Class >= MAX_ITEM_CLASS)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong Class value (%u)",i,proto->Class);
+const_cast<ItemPrototype*>(proto)->Class = ITEM_CLASS_MISC;
+}
+
+if (proto->SubClass >= MaxItemSubclassValues[proto->Class])
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong Subclass value (%u) for class %u",i,proto->SubClass,proto->Class);
+const_cast<ItemPrototype*>(proto)->SubClass = 0;// exist for all item classes
+}
+
+if (proto->Quality >= MAX_ITEM_QUALITY)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong Quality value (%u)",i,proto->Quality);
+const_cast<ItemPrototype*>(proto)->Quality = ITEM_QUALITY_NORMAL;
+}
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY)
+{
+if (FactionEntry const* faction = sFactionStore.LookupEntry(HORDE))
+if ((proto->AllowableRace & faction->BaseRepRaceMask[0]) == 0)
+sLog.outErrorDb("Item (Entry: %u) have in `AllowableRace` races (%u) only not compatible with ITEM_FLAGS_EXTRA_HORDE_ONLY (%u) in Flags field, item any way will can't be equipped or use by this races.",
+i, proto->AllowableRace, ITEM_FLAGS_EXTRA_HORDE_ONLY);
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY)
+sLog.outErrorDb("Item (Entry: %u) have in `Flags2` flags ITEM_FLAGS_EXTRA_ALLIANCE_ONLY (%u) and ITEM_FLAGS_EXTRA_HORDE_ONLY (%u) in Flags field, this is wrong combination.",
+i, ITEM_FLAGS_EXTRA_ALLIANCE_ONLY, ITEM_FLAGS_EXTRA_HORDE_ONLY);
+}
+else if (proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY)
+{
+if (FactionEntry const* faction = sFactionStore.LookupEntry(ALLIANCE))
+if ((proto->AllowableRace & faction->BaseRepRaceMask[0]) == 0)
+sLog.outErrorDb("Item (Entry: %u) have in `AllowableRace` races (%u) only not compatible with ITEM_FLAGS_EXTRA_ALLIANCE_ONLY (%u) in Flags field, item any way will can't be equipped or use by this races.",
+i, proto->AllowableRace, ITEM_FLAGS_EXTRA_ALLIANCE_ONLY);
+}
+
+if (proto->BuyCount <= 0)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong BuyCount value (%u), set to default(1).",i,proto->BuyCount);
+const_cast<ItemPrototype*>(proto)->BuyCount = 1;
+}
+
+if (proto->InventoryType >= MAX_INVTYPE)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong InventoryType value (%u)",i,proto->InventoryType);
+const_cast<ItemPrototype*>(proto)->InventoryType = INVTYPE_NON_EQUIP;
+}
+
+if (proto->RequiredSkill >= MAX_SKILL_TYPE)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong RequiredSkill value (%u)",i,proto->RequiredSkill);
+const_cast<ItemPrototype*>(proto)->RequiredSkill = 0;
+}
+
+{
+// can be used in equip slot, as page read use in inventory, or spell casting at use
+bool req = proto->InventoryType != INVTYPE_NON_EQUIP || proto->PageText;
+if (!req)
+for (uint8 j = 0; j < MAX_ITEM_PROTO_SPELLS; ++j)
+{
+if (proto->Spells[j].SpellId)
+{
+req = true;
+break;
+}
+}
+
+if (req)
+{
+if (!(proto->AllowableClass & CLASSMASK_ALL_PLAYABLE))
+sLog.outErrorDb("Item (Entry: %u) not have in `AllowableClass` any playable classes (%u) and can't be equipped or use.",i,proto->AllowableClass);
+
+if (!(proto->AllowableRace & RACEMASK_ALL_PLAYABLE))
+sLog.outErrorDb("Item (Entry: %u) not have in `AllowableRace` any playable races (%u) and can't be equipped or use.",i,proto->AllowableRace);
+}
+}
+
+if (proto->RequiredSpell && !sSpellStore.LookupEntry(proto->RequiredSpell))
+{
+sLog.outErrorDb("Item (Entry: %u) have wrong (non-existed) spell in RequiredSpell (%u)",i,proto->RequiredSpell);
+const_cast<ItemPrototype*>(proto)->RequiredSpell = 0;
+}
+
+if (proto->RequiredReputationRank >= MAX_REPUTATION_RANK)
+sLog.outErrorDb("Item (Entry: %u) has wrong reputation rank in RequiredReputationRank (%u), item can't be used.",i,proto->RequiredReputationRank);
+
+if (proto->RequiredReputationFaction)
+{
+if (!sFactionStore.LookupEntry(proto->RequiredReputationFaction))
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) faction in RequiredReputationFaction (%u)",i,proto->RequiredReputationFaction);
+const_cast<ItemPrototype*>(proto)->RequiredReputationFaction = 0;
+}
+
+if (proto->RequiredReputationRank == MIN_REPUTATION_RANK)
+sLog.outErrorDb("Item (Entry: %u) has min. reputation rank in RequiredReputationRank (0) but RequiredReputationFaction > 0, faction setting is useless.",i);
+}
+
+if (proto->MaxCount < -1)
+{
+sLog.outErrorDb("Item (Entry: %u) has too large negative in maxcount (%i), replace by value (-1) no storing limits.",i,proto->MaxCount);
+const_cast<ItemPrototype*>(proto)->MaxCount = -1;
+}
+
+if (proto->Stackable == 0)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong value in stackable (%i), replace by default 1.",i,proto->Stackable);
+const_cast<ItemPrototype*>(proto)->Stackable = 1;
+}
+else if (proto->Stackable < -1)
+{
+sLog.outErrorDb("Item (Entry: %u) has too large negative in stackable (%i), replace by value (-1) no stacking limits.",i,proto->Stackable);
+const_cast<ItemPrototype*>(proto)->Stackable = -1;
+}
+
+if (proto->ContainerSlots > MAX_BAG_SIZE)
+{
+sLog.outErrorDb("Item (Entry: %u) has too large value in ContainerSlots (%u), replace by hardcoded limit (%u).",i,proto->ContainerSlots,MAX_BAG_SIZE);
+const_cast<ItemPrototype*>(proto)->ContainerSlots = MAX_BAG_SIZE;
+}
+
+if (proto->StatsCount > MAX_ITEM_PROTO_STATS)
+{
+sLog.outErrorDb("Item (Entry: %u) has too large value in statscount (%u), replace by hardcoded limit (%u).",i,proto->StatsCount,MAX_ITEM_PROTO_STATS);
+const_cast<ItemPrototype*>(proto)->StatsCount = MAX_ITEM_PROTO_STATS;
+}
+
+for (uint8 j = 0; j < MAX_ITEM_PROTO_STATS; ++j)
+{
+// for ItemStatValue != 0
+if (proto->ItemStat[j].ItemStatValue && proto->ItemStat[j].ItemStatType >= MAX_ITEM_MOD)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong stat_type%d (%u)",i,j+1,proto->ItemStat[j].ItemStatType);
+const_cast<ItemPrototype*>(proto)->ItemStat[j].ItemStatType = 0;
+}
+
+switch (proto->ItemStat[j].ItemStatType)
+{
+case ITEM_MOD_SPELL_HEALING_DONE:
+case ITEM_MOD_SPELL_DAMAGE_DONE:
+sLog.outErrorDb("Item (Entry: %u) has deprecated stat_type%d (%u)",i,j+1,proto->ItemStat[j].ItemStatType);
+break;
+default:
+break;
+}
+}
+
+for (uint8 j = 0; j < MAX_ITEM_PROTO_DAMAGES; ++j)
+{
+if (proto->Damage[j].DamageType >= MAX_SPELL_SCHOOL)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong dmg_type%d (%u)",i,j+1,proto->Damage[j].DamageType);
+const_cast<ItemPrototype*>(proto)->Damage[j].DamageType = 0;
+}
+}
+
+// special format
+if ((proto->Spells[0].SpellId == 483) || (proto->Spells[0].SpellId == 55884))
+{
+// spell_1
+if (proto->Spells[0].SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u) for special learning format",i,0+1,proto->Spells[0].SpellTrigger);
+const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[0].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+}
+
+// spell_2 have learning spell
+if (proto->Spells[1].SpellTrigger != ITEM_SPELLTRIGGER_LEARN_SPELL_ID)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u) for special learning format.",i,1+1,proto->Spells[1].SpellTrigger);
+const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+}
+else if (!proto->Spells[1].SpellId)
+{
+sLog.outErrorDb("Item (Entry: %u) not has expected spell in spellid_%d in special learning format.",i,1+1);
+const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+}
+else if (proto->Spells[1].SpellId != -1)
+{
+SpellEntry const* spellInfo = sSpellStore.LookupEntry(proto->Spells[1].SpellId);
+if (!spellInfo && !sDisableMgr.IsDisabledFor(DISABLE_TYPE_SPELL, proto->Spells[1].SpellId, NULL))
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) spell in spellid_%d (%d)",i,1+1,proto->Spells[1].SpellId);
+const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+}
+// allowed only in special format
+else if ((proto->Spells[1].SpellId == 483) || (proto->Spells[1].SpellId == 55884))
+{
+sLog.outErrorDb("Item (Entry: %u) has broken spell in spellid_%d (%d)",i,1+1,proto->Spells[1].SpellId);
+const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+}
+}
+
+// spell_3*,spell_4*,spell_5* is empty
+for (uint8 j = 2; j < MAX_ITEM_PROTO_SPELLS; ++j)
+{
+if (proto->Spells[j].SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u)",i,j+1,proto->Spells[j].SpellTrigger);
+const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[j].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+}
+else if (proto->Spells[j].SpellId != 0)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong spell in spellid_%d (%d) for learning special format",i,j+1,proto->Spells[j].SpellId);
+const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
+}
+}
+}
+// normal spell list
+else
+{
+for (uint8 j = 0; j < MAX_ITEM_PROTO_SPELLS; ++j)
+{
+if (proto->Spells[j].SpellTrigger >= MAX_ITEM_SPELLTRIGGER || proto->Spells[j].SpellTrigger == ITEM_SPELLTRIGGER_LEARN_SPELL_ID)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u)",i,j+1,proto->Spells[j].SpellTrigger);
+const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
+const_cast<ItemPrototype*>(proto)->Spells[j].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
+}
+
+if (proto->Spells[j].SpellId && proto->Spells[j].SpellId != -1)
+{
+SpellEntry const* spellInfo = sSpellStore.LookupEntry(proto->Spells[j].SpellId);
+if (!spellInfo && !sDisableMgr.IsDisabledFor(DISABLE_TYPE_SPELL, proto->Spells[j].SpellId, NULL))
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) spell in spellid_%d (%d)",i,j+1,proto->Spells[j].SpellId);
+const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
+}
+// allowed only in special format
+else if ((proto->Spells[j].SpellId == 483) || (proto->Spells[j].SpellId == 55884))
+{
+sLog.outErrorDb("Item (Entry: %u) has broken spell in spellid_%d (%d)",i,j+1,proto->Spells[j].SpellId);
+const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
+}
+}
+}
+}
+
+if (proto->Bonding >= MAX_BIND_TYPE)
+sLog.outErrorDb("Item (Entry: %u) has wrong Bonding value (%u)",i,proto->Bonding);
+
+if (proto->PageText && !sPageTextStore.LookupEntry<PageText>(proto->PageText))
+sLog.outErrorDb("Item (Entry: %u) has non existing first page (Id:%u)", i,proto->PageText);
+
+if (proto->LockID && !sLockStore.LookupEntry(proto->LockID))
+sLog.outErrorDb("Item (Entry: %u) has wrong LockID (%u)",i,proto->LockID);
+
+if (proto->Sheath >= MAX_SHEATHETYPE)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong Sheath (%u)",i,proto->Sheath);
+const_cast<ItemPrototype*>(proto)->Sheath = SHEATHETYPE_NONE;
+}
+
+if (proto->RandomProperty)
+{
+// To be implemented later
+if (proto->RandomProperty == -1)
+const_cast<ItemPrototype*>(proto)->RandomProperty = 0;
+
+else if (!sItemRandomPropertiesStore.LookupEntry(GetItemEnchantMod(proto->RandomProperty)))
+{
+sLog.outErrorDb("Item (Entry: %u) has unknown (wrong or not listed in `item_enchantment_template`) RandomProperty (%u)",i,proto->RandomProperty);
+const_cast<ItemPrototype*>(proto)->RandomProperty = 0;
+}
+}
+
+if (proto->RandomSuffix && !sItemRandomSuffixStore.LookupEntry(GetItemEnchantMod(proto->RandomSuffix)))
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong RandomSuffix (%u)",i,proto->RandomSuffix);
+const_cast<ItemPrototype*>(proto)->RandomSuffix = 0;
+}
+
+if (proto->ItemSet && !sItemSetStore.LookupEntry(proto->ItemSet))
+{
+sLog.outErrorDb("Item (Entry: %u) have wrong ItemSet (%u)",i,proto->ItemSet);
+const_cast<ItemPrototype*>(proto)->ItemSet = 0;
+}
+
+if (proto->Area && !GetAreaEntryByAreaID(proto->Area))
+sLog.outErrorDb("Item (Entry: %u) has wrong Area (%u)",i,proto->Area);
+
+if (proto->Map && !sMapStore.LookupEntry(proto->Map))
+sLog.outErrorDb("Item (Entry: %u) has wrong Map (%u)",i,proto->Map);
+
+if (proto->BagFamily)
+{
+// check bits
+for (uint32 j = 0; j < sizeof(proto->BagFamily)*8; ++j)
+{
+uint32 mask = 1 << j;
+if ((proto->BagFamily & mask) == 0)
+continue;
+
+ItemBagFamilyEntry const* bf = sItemBagFamilyStore.LookupEntry(j+1);
+if (!bf)
+{
+sLog.outErrorDb("Item (Entry: %u) has bag family bit set not listed in ItemBagFamily.dbc, remove bit",i);
+const_cast<ItemPrototype*>(proto)->BagFamily &= ~mask;
+continue;
+}
+
+if (BAG_FAMILY_MASK_CURRENCY_TOKENS & mask)
+{
+CurrencyTypesEntry const* ctEntry = sCurrencyTypesStore.LookupEntry(proto->ItemId);
+if (!ctEntry)
+{
+sLog.outErrorDb("Item (Entry: %u) has currency bag family bit set in BagFamily but not listed in CurrencyTypes.dbc, remove bit",i);
+const_cast<ItemPrototype*>(proto)->BagFamily &= ~mask;
+}
+}
+}
+}
+
+if (proto->TotemCategory && !sTotemCategoryStore.LookupEntry(proto->TotemCategory))
+sLog.outErrorDb("Item (Entry: %u) has wrong TotemCategory (%u)",i,proto->TotemCategory);
+
+for (uint8 j = 0; j < MAX_ITEM_PROTO_SOCKETS; ++j)
+{
+if (proto->Socket[j].Color && (proto->Socket[j].Color & SOCKET_COLOR_ALL) != proto->Socket[j].Color)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong socketColor_%d (%u)",i,j+1,proto->Socket[j].Color);
+const_cast<ItemPrototype*>(proto)->Socket[j].Color = 0;
+}
+}
+
+if (proto->GemProperties && !sGemPropertiesStore.LookupEntry(proto->GemProperties))
+sLog.outErrorDb("Item (Entry: %u) has wrong GemProperties (%u)",i,proto->GemProperties);
+
+if (proto->FoodType >= MAX_PET_DIET)
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong FoodType value (%u)",i,proto->FoodType);
+const_cast<ItemPrototype*>(proto)->FoodType = 0;
+}
+
+if (proto->ItemLimitCategory && !sItemLimitCategoryStore.LookupEntry(proto->ItemLimitCategory))
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong LimitCategory value (%u)",i,proto->ItemLimitCategory);
+const_cast<ItemPrototype*>(proto)->ItemLimitCategory = 0;
+}
+
+if (proto->HolidayId && !sHolidaysStore.LookupEntry(proto->HolidayId))
+{
+sLog.outErrorDb("Item (Entry: %u) has wrong HolidayId value (%u)", i, proto->HolidayId);
+const_cast<ItemPrototype*>(proto)->HolidayId = 0;
+}
+}
+
+// check some dbc referecned items (avoid duplicate reports)
+std::set<uint32> notFoundOutfit;
+for (uint32 i = 1; i < sCharStartOutfitStore.GetNumRows(); ++i)
+{
+CharStartOutfitEntry const* entry = sCharStartOutfitStore.LookupEntry(i);
+if (!entry)
+continue;
+
+for (int j = 0; j < MAX_OUTFIT_ITEMS; ++j)
+{
+if (entry->ItemId[j] <= 0)
+continue;
+
+uint32 item_id = entry->ItemId[j];
+
+if (!GetItemPrototype(item_id))
+notFoundOutfit.insert(item_id);
+}
+}
+
+for (std::set<uint32>::const_iterator itr = notFoundOutfit.begin(); itr != notFoundOutfit.end(); ++itr)
+sLog.outErrorDb("Item (Entry: %u) not exist in `item_template` but referenced in `CharStartOutfit.dbc`", *itr);
+}
+
+void ObjectMgr::LoadItemSetNameLocales()
+{
+mItemSetNameLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT `entry`,`name_loc1`,`name_loc2`,`name_loc3`,`name_loc4`,`name_loc5`,`name_loc6`,`name_loc7`,`name_loc8` FROM `locales_item_set_names`");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+ItemSetNameLocale& data = mItemSetNameLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+std::string str = fields[i].GetString();
+AddLocaleString(str, LocaleConstant(i), data.Name);
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded " UI64FMTD " Item set name locale strings", uint64(mItemSetNameLocaleMap.size()));
+}
+
+void ObjectMgr::LoadItemSetNames()
+{
+mItemSetNameMap.clear(); // needed for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT `entry`,`name`,`InventoryType` FROM `item_set_names`");
+
+uint32 count = 0;
+std::set<uint32> itemSetItems;
+
+// fill item set member ids
+for (uint32 entryId = 0; entryId < sItemSetStore.GetNumRows(); ++entryId)
+{
+ItemSetEntry const* setEntry = sItemSetStore.LookupEntry(entryId);
+if (!setEntry)
+continue;
+
+for (uint32 i = 0; i < MAX_ITEM_SET_ITEMS; ++i)
+if (setEntry->itemId[i])
+itemSetItems.insert(setEntry->itemId[i]);
+}
+
+if (result)
+{
+barGoLink bar(result->GetRowCount());
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+if (itemSetItems.find(entry) == itemSetItems.end())
+{
+sLog.outErrorDb("Item set name (Entry: %u) not found in ItemSet.dbc, data useless.", entry);
+continue;
+}
+
+ItemSetNameEntry &data = mItemSetNameMap[entry];
+data.name = fields[1].GetString();
+
+uint32 invType = fields[2].GetUInt32();
+if (invType >= MAX_INVTYPE)
+{
+sLog.outErrorDb("Item set name (Entry: %u) has wrong InventoryType value (%u)", entry, invType);
+invType = INVTYPE_NON_EQUIP;
+}
+
+data.InventoryType = invType;
+itemSetItems.erase(entry);
+++count;
+} while (result->NextRow());
+}
+else
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 item set names. DB table `item_set_names` is empty.");
+}
+
+if (!itemSetItems.empty())
+{
+ItemPrototype const* pProto;
+for (std::set<uint32>::iterator itr = itemSetItems.begin(); itr != itemSetItems.end(); ++itr)
+{
+uint32 entry = *itr;
+// add data from item_template if available
+pProto = GetItemPrototype(entry);
+if (pProto)
+{
+sLog.outErrorDb("Item set part (Entry: %u) does not have entry in `item_set_names`, adding data from `item_template`.", entry);
+ItemSetNameEntry &data = mItemSetNameMap[entry];
+data.name = pProto->Name1;
+data.InventoryType = pProto->InventoryType;
+++count;
+}
+else
+sLog.outErrorDb("Item set part (Entry: %u) does not have entry in `item_set_names`, set will not display properly.", entry);
+}
+}
+
+sLog.outString();
+sLog.outString(">> Loaded %u item set names", count);
+}
+
+void ObjectMgr::LoadVehicleAccessories()
+{
+m_VehicleAccessoryMap.clear(); // needed for reload case
+
+uint32 count = 0;
+
+QueryResult result = WorldDatabase.Query("SELECT `entry`,`accessory_entry`,`seat_id`,`minion` FROM `vehicle_accessory`");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 LoadVehicleAccessor. DB table `vehicle_accessory` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 uiEntry = fields[0].GetUInt32();
+uint32 uiAccessory = fields[1].GetUInt32();
+int8 uiSeat = int8(fields[2].GetInt16());
+bool bMinion = fields[3].GetBool();
+
+if (!sCreatureStorage.LookupEntry<CreatureInfo>(uiEntry))
+{
+sLog.outErrorDb("Table `vehicle_accessory`: creature template entry %u does not exist.", uiEntry);
+continue;
+}
+
+if (!sCreatureStorage.LookupEntry<CreatureInfo>(uiAccessory))
+{
+sLog.outErrorDb("Table `vehicle_accessory`: Accessory %u does not exist.", uiAccessory);
+continue;
+}
+
+m_VehicleAccessoryMap[uiEntry].push_back(VehicleAccessory(uiAccessory, uiSeat, bMinion));
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u Vehicle Accessories", count);
+}
+
+void ObjectMgr::LoadVehicleScaling()
+{
+m_VehicleScalingMap.clear(); // needed for reload case
+
+uint32 count = 0;
+
+QueryResult result = WorldDatabase.Query("SELECT `entry`,`baseItemLevel`,`scalingFactor` FROM `vehicle_scaling_info`");
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 vehicle scaling entries. DB table `vehicle_scaling_info` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 vehicleEntry = fields[0].GetUInt32();
+float baseItemLevel = fields[1].GetFloat();
+float scalingFactor = fields[2].GetFloat();
+
+if (!sVehicleStore.LookupEntry(vehicleEntry))
+{
+sLog.outErrorDb("Table `vehicle_scaling_info`: vehicle entry %u does not exist.", vehicleEntry);
+continue;
+}
+
+m_VehicleScalingMap[vehicleEntry].ID = vehicleEntry;
+m_VehicleScalingMap[vehicleEntry].baseItemLevel = baseItemLevel;
+m_VehicleScalingMap[vehicleEntry].scalingFactor = scalingFactor;
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u vehicle scaling entries.", count);
+}
+
+void ObjectMgr::LoadPetLevelInfo()
+{
+// Loading levels data
+{
+// 0 1 2 3 4 5 6 7 8 9
+QueryResult result = WorldDatabase.Query("SELECT creature_entry, level, hp, mana, str, agi, sta, inte, spi, armor FROM pet_levelstats");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+sLog.outString();
+sLog.outString(">> Loaded %u level pet stats definitions", count);
+sLog.outErrorDb("Error loading `pet_levelstats` table or empty table.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 creature_id = fields[0].GetUInt32();
+if (!sCreatureStorage.LookupEntry<CreatureInfo>(creature_id))
+{
+sLog.outErrorDb("Wrong creature id %u in `pet_levelstats` table, ignoring.",creature_id);
+continue;
+}
+
+uint32 current_level = fields[1].GetUInt32();
+if (current_level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+{
+if (current_level > STRONG_MAX_LEVEL) // hardcoded level maximum
+sLog.outErrorDb("Wrong (> %u) level %u in `pet_levelstats` table, ignoring.",STRONG_MAX_LEVEL,current_level);
+else
+{
+sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `pet_levelstats` table, ignoring.",current_level);
+++count; // make result loading percent "expected" correct in case disabled detail mode for example.
+}
+continue;
+}
+else if (current_level < 1)
+{
+sLog.outErrorDb("Wrong (<1) level %u in `pet_levelstats` table, ignoring.",current_level);
+continue;
+}
+
+PetLevelInfo*& pInfoMapEntry = petInfo[creature_id];
+
+if (pInfoMapEntry == NULL)
+pInfoMapEntry = new PetLevelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
+
+// data for level 1 stored in [0] array element, ...
+PetLevelInfo* pLevelInfo = &pInfoMapEntry[current_level-1];
+
+pLevelInfo->health = fields[2].GetUInt16();
+pLevelInfo->mana = fields[3].GetUInt16();
+pLevelInfo->armor = fields[9].GetUInt16();
+
+for (int i = 0; i < MAX_STATS; i++)
+{
+pLevelInfo->stats[i] = fields[i+4].GetUInt16();
+}
+
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u level pet stats definitions", count);
+}
+
+// Fill gaps and check integrity
+for (PetLevelInfoMap::iterator itr = petInfo.begin(); itr != petInfo.end(); ++itr)
+{
+PetLevelInfo* pInfo = itr->second;
+
+// fatal error if no level 1 data
+if (!pInfo || pInfo[0].health == 0)
+{
+sLog.outErrorDb("Creature %u does not have pet stats data for Level 1!",itr->first);
+exit(1);
+}
+
+// fill level gaps
+for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
+{
+if (pInfo[level].health == 0)
+{
+sLog.outErrorDb("Creature %u has no data for Level %i pet stats data, using data of Level %i.",itr->first,level+1, level);
+pInfo[level] = pInfo[level-1];
+}
+}
+}
+}
+
+PetLevelInfo const* ObjectMgr::GetPetLevelInfo(uint32 creature_id, uint8 level) const
+{
+if (level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+level = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+PetLevelInfoMap::const_iterator itr = petInfo.find(creature_id);
+if (itr == petInfo.end())
+return NULL;
+
+return &itr->second[level-1]; // data for level 1 stored in [0] array element, ...
+}
+
+void ObjectMgr::PlayerCreateInfoAddItemHelper(uint32 race_, uint32 class_, uint32 itemId, int32 count)
+{
+if (count > 0)
+playerInfo[race_][class_].item.push_back(PlayerCreateInfoItem(itemId, count));
+else
+{
+if (count < -1)
+sLog.outErrorDb("Invalid count %i specified on item %u be removed from original player create info (use -1)!", count, itemId);
+
+uint32 RaceClass = (race_) | (class_ << 8);
+bool doneOne = false;
+for (uint32 i = 1; i < sCharStartOutfitStore.GetNumRows(); ++i)
+{
+if (CharStartOutfitEntry const* entry = sCharStartOutfitStore.LookupEntry(i))
+{
+if (entry->RaceClassGender == RaceClass || entry->RaceClassGender == (RaceClass | (1 << 16)))
+{
+bool found = false;
+for (uint8 x = 0; x < MAX_OUTFIT_ITEMS; ++x)
+{
+if (entry->ItemId[x] > 0 && uint32(entry->ItemId[x]) == itemId)
+{
+found = true;
+const_cast<CharStartOutfitEntry*>(entry)->ItemId[x] = 0;
+break;
+}
+}
+
+if (!found)
+sLog.outErrorDb("Item %u specified to be removed from original create info not found in dbc!", itemId);
+
+if (!doneOne)
+doneOne = true;
+else
+break;
+}
+}
+}
+}
+}
+
+void ObjectMgr::LoadPlayerInfo()
+{
+// Load playercreate
+{
+// 0 1 2 3 4 5 6
+QueryResult result = WorldDatabase.Query("SELECT race, class, map, zone, position_x, position_y, position_z, orientation FROM playercreateinfo");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+sLog.outString();
+sLog.outString(">> Loaded %u player create definitions", count);
+sLog.outErrorDb("Error loading `playercreateinfo` table or empty table.");
+exit(1);
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 current_race = fields[0].GetUInt32();
+uint32 current_class = fields[1].GetUInt32();
+uint32 mapId = fields[2].GetUInt32();
+uint32 areaId = fields[3].GetUInt32();
+float positionX = fields[4].GetFloat();
+float positionY = fields[5].GetFloat();
+float positionZ = fields[6].GetFloat();
+float orientation = fields[7].GetFloat();
+
+if (current_race >= MAX_RACES)
+{
+sLog.outErrorDb("Wrong race %u in `playercreateinfo` table, ignoring.",current_race);
+continue;
+}
+
+ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(current_race);
+if (!rEntry)
+{
+sLog.outErrorDb("Wrong race %u in `playercreateinfo` table, ignoring.",current_race);
+continue;
+}
+
+if (current_class >= MAX_CLASSES)
+{
+sLog.outErrorDb("Wrong class %u in `playercreateinfo` table, ignoring.",current_class);
+continue;
+}
+
+if (!sChrClassesStore.LookupEntry(current_class))
+{
+sLog.outErrorDb("Wrong class %u in `playercreateinfo` table, ignoring.",current_class);
+continue;
+}
+
+// accept DB data only for valid position (and non instanceable)
+if (!MapManager::IsValidMapCoord(mapId,positionX,positionY,positionZ,orientation))
+{
+sLog.outErrorDb("Wrong home position for class %u race %u pair in `playercreateinfo` table, ignoring.",current_class,current_race);
+continue;
+}
+
+if (sMapStore.LookupEntry(mapId)->Instanceable())
+{
+sLog.outErrorDb("Home position in instanceable map for class %u race %u pair in `playercreateinfo` table, ignoring.",current_class,current_race);
+continue;
+}
+
+PlayerInfo* pInfo = &playerInfo[current_race][current_class];
+
+pInfo->mapId = mapId;
+pInfo->areaId = areaId;
+pInfo->positionX = positionX;
+pInfo->positionY = positionY;
+pInfo->positionZ = positionZ;
+pInfo->orientation = orientation;
+
+pInfo->displayId_m = rEntry->model_m;
+pInfo->displayId_f = rEntry->model_f;
+
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u player create definitions", count);
+}
+
+// Load playercreate items
+sLog.outString("Loading Player Create Items Data...");
+{
+// 0 1 2 3
+QueryResult result = WorldDatabase.Query("SELECT race, class, itemid, amount FROM playercreateinfo_item");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u custom player create items", count);
+}
+else
+{
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 current_race = fields[0].GetUInt32();
+if (current_race >= MAX_RACES)
+{
+sLog.outErrorDb("Wrong race %u in `playercreateinfo_item` table, ignoring.",current_race);
+continue;
+}
+
+uint32 current_class = fields[1].GetUInt32();
+if (current_class >= MAX_CLASSES)
+{
+sLog.outErrorDb("Wrong class %u in `playercreateinfo_item` table, ignoring.",current_class);
+continue;
+}
+
+uint32 item_id = fields[2].GetUInt32();
+
+if (!GetItemPrototype(item_id))
+{
+sLog.outErrorDb("Item id %u (race %u class %u) in `playercreateinfo_item` table but not listed in `item_template`, ignoring.",item_id,current_race,current_class);
+continue;
+}
+
+int32 amount = fields[3].GetInt32();
+
+if (!amount)
+{
+sLog.outErrorDb("Item id %u (class %u race %u) have amount == 0 in `playercreateinfo_item` table, ignoring.",item_id,current_race,current_class);
+continue;
+}
+
+if (!current_race || !current_class)
+{
+uint32 min_race = current_race ? current_race : 1;
+uint32 max_race = current_race ? current_race + 1 : MAX_RACES;
+uint32 min_class = current_class ? current_class : 1;
+uint32 max_class = current_class ? current_class + 1 : MAX_CLASSES;
+for (uint32 r = min_race; r < max_race; ++r)
+for (uint32 c = min_class; c < max_class; ++c)
+PlayerCreateInfoAddItemHelper(r, c, item_id, amount);
+}
+else
+PlayerCreateInfoAddItemHelper(current_race, current_class, item_id, amount);
+
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u custom player create items", count);
+}
+}
+
+// Load playercreate spells
+sLog.outString("Loading Player Create Spell Data...");
+{
+
+QueryResult result = QueryResult(NULL);
+if (sWorld.getBoolConfig(CONFIG_START_ALL_SPELLS))
+result = WorldDatabase.Query("SELECT race, class, Spell, Active FROM playercreateinfo_spell_custom");
+else
+result = WorldDatabase.Query("SELECT race, class, Spell FROM playercreateinfo_spell");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+sLog.outString();
+sLog.outString(">> Loaded %u player create spells", count);
+sLog.outErrorDb("Error loading player starting spells or empty table.");
+}
+else
+{
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 current_race = fields[0].GetUInt32();
+if (current_race >= MAX_RACES)
+{
+sLog.outErrorDb("Wrong race %u in `playercreateinfo_spell` table, ignoring.",current_race);
+continue;
+}
+
+uint32 current_class = fields[1].GetUInt32();
+if (current_class >= MAX_CLASSES)
+{
+sLog.outErrorDb("Wrong class %u in `playercreateinfo_spell` table, ignoring.",current_class);
+continue;
+}
+
+if (!current_race || !current_class)
+{
+uint32 min_race = current_race ? current_race : 1;
+uint32 max_race = current_race ? current_race + 1 : MAX_RACES;
+uint32 min_class = current_class ? current_class : 1;
+uint32 max_class = current_class ? current_class + 1 : MAX_CLASSES;
+for (uint32 r = min_race; r < max_race; ++r)
+for (uint32 c = min_class; c < max_class; ++c)
+playerInfo[r][c].spell.push_back(fields[2].GetUInt32());
+}
+else
+playerInfo[current_race][current_class].spell.push_back(fields[2].GetUInt32());
+
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u player create spells", count);
+}
+}
+
+// Load playercreate actions
+sLog.outString("Loading Player Create Action Data...");
+{
+// 0 1 2 3 4
+QueryResult result = WorldDatabase.Query("SELECT race, class, button, action, type FROM playercreateinfo_action");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+sLog.outString();
+sLog.outString(">> Loaded %u player create actions", count);
+sLog.outErrorDb("Error loading `playercreateinfo_action` table or empty table.");
+}
+else
+{
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 current_race = fields[0].GetUInt32();
+if (current_race >= MAX_RACES)
+{
+sLog.outErrorDb("Wrong race %u in `playercreateinfo_action` table, ignoring.",current_race);
+continue;
+}
+
+uint32 current_class = fields[1].GetUInt32();
+if (current_class >= MAX_CLASSES)
+{
+sLog.outErrorDb("Wrong class %u in `playercreateinfo_action` table, ignoring.",current_class);
+continue;
+}
+
+PlayerInfo* pInfo = &playerInfo[current_race][current_class];
+pInfo->action.push_back(PlayerCreateInfoAction(fields[2].GetUInt8(),fields[3].GetUInt32(),fields[4].GetUInt8()));
+
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u player create actions", count);
+}
+}
+
+// Loading levels data (class only dependent)
+sLog.outString("Loading Player Create Level HP/Mana Data...");
+{
+// 0 1 2 3
+QueryResult result = WorldDatabase.Query("SELECT class, level, basehp, basemana FROM player_classlevelstats");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+sLog.outString();
+sLog.outString(">> Loaded %u level health/mana definitions", count);
+sLog.outErrorDb("Error loading `player_classlevelstats` table or empty table.");
+exit(1);
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 current_class = fields[0].GetUInt32();
+if (current_class >= MAX_CLASSES)
+{
+sLog.outErrorDb("Wrong class %u in `player_classlevelstats` table, ignoring.",current_class);
+continue;
+}
+
+uint8 current_level = fields[1].GetUInt8(); // Can't be > than STRONG_MAX_LEVEL (hardcoded level maximum) due to var type
+if (current_level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+{
+sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `player_classlevelstats` table, ignoring.",current_level);
+++count; // make result loading percent "expected" correct in case disabled detail mode for example.
+continue;
+}
+
+PlayerClassInfo* pClassInfo = &playerClassInfo[current_class];
+
+if (!pClassInfo->levelInfo)
+pClassInfo->levelInfo = new PlayerClassLevelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
+
+PlayerClassLevelInfo* pClassLevelInfo = &pClassInfo->levelInfo[current_level-1];
+
+pClassLevelInfo->basehealth = fields[2].GetUInt16();
+pClassLevelInfo->basemana = fields[3].GetUInt16();
+
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u level health/mana definitions", count);
+}
+
+// Fill gaps and check integrity
+for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
+{
+// skip non existed classes
+if (!sChrClassesStore.LookupEntry(class_))
+continue;
+
+PlayerClassInfo* pClassInfo = &playerClassInfo[class_];
+
+// fatal error if no level 1 data
+if (!pClassInfo->levelInfo || pClassInfo->levelInfo[0].basehealth == 0)
+{
+sLog.outErrorDb("Class %i Level 1 does not have health/mana data!",class_);
+exit(1);
+}
+
+// fill level gaps
+for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
+{
+if (pClassInfo->levelInfo[level].basehealth == 0)
+{
+sLog.outErrorDb("Class %i Level %i does not have health/mana data. Using stats data of level %i.",class_,level+1, level);
+pClassInfo->levelInfo[level] = pClassInfo->levelInfo[level-1];
+}
+}
+}
+
+// Loading levels data (class/race dependent)
+sLog.outString("Loading Player Create Level Stats Data...");
+{
+// 0 1 2 3 4 5 6 7
+QueryResult result = WorldDatabase.Query("SELECT race, class, level, str, agi, sta, inte, spi FROM player_levelstats");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+sLog.outString();
+sLog.outString(">> Loaded %u level stats definitions", count);
+sLog.outErrorDb("Error loading `player_levelstats` table or empty table.");
+exit(1);
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 current_race = fields[0].GetUInt32();
+if (current_race >= MAX_RACES)
+{
+sLog.outErrorDb("Wrong race %u in `player_levelstats` table, ignoring.",current_race);
+continue;
+}
+
+uint32 current_class = fields[1].GetUInt32();
+if (current_class >= MAX_CLASSES)
+{
+sLog.outErrorDb("Wrong class %u in `player_levelstats` table, ignoring.",current_class);
+continue;
+}
+
+uint32 current_level = fields[2].GetUInt32();
+if (current_level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+{
+if (current_level > STRONG_MAX_LEVEL) // hardcoded level maximum
+sLog.outErrorDb("Wrong (> %u) level %u in `player_levelstats` table, ignoring.",STRONG_MAX_LEVEL,current_level);
+else
+{
+sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `player_levelstats` table, ignoring.",current_level);
+++count; // make result loading percent "expected" correct in case disabled detail mode for example.
+}
+continue;
+}
+
+PlayerInfo* pInfo = &playerInfo[current_race][current_class];
+
+if (!pInfo->levelInfo)
+pInfo->levelInfo = new PlayerLevelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)];
+
+PlayerLevelInfo* pLevelInfo = &pInfo->levelInfo[current_level-1];
+
+for (int i = 0; i < MAX_STATS; i++)
+{
+pLevelInfo->stats[i] = fields[i+3].GetUInt8();
+}
+
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u level stats definitions", count);
+}
+
+// Fill gaps and check integrity
+for (int race = 0; race < MAX_RACES; ++race)
+{
+// skip non existed races
+if (!sChrRacesStore.LookupEntry(race))
+continue;
+
+for (int class_ = 0; class_ < MAX_CLASSES; ++class_)
+{
+// skip non existed classes
+if (!sChrClassesStore.LookupEntry(class_))
+continue;
+
+PlayerInfo* pInfo = &playerInfo[race][class_];
+
+// skip non loaded combinations
+if (!pInfo->displayId_m || !pInfo->displayId_f)
+continue;
+
+// skip expansion races if not playing with expansion
+if (sWorld.getIntConfig(CONFIG_EXPANSION) < 1 && (race == RACE_BLOODELF || race == RACE_DRAENEI))
+continue;
+
+// skip expansion classes if not playing with expansion
+if (sWorld.getIntConfig(CONFIG_EXPANSION) < 2 && class_ == CLASS_DEATH_KNIGHT)
+continue;
+
+// fatal error if no level 1 data
+if (!pInfo->levelInfo || pInfo->levelInfo[0].stats[0] == 0)
+{
+sLog.outErrorDb("Race %i Class %i Level 1 does not have stats data!",race,class_);
+exit(1);
+}
+
+// fill level gaps
+for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
+{
+if (pInfo->levelInfo[level].stats[0] == 0)
+{
+sLog.outErrorDb("Race %i Class %i Level %i does not have stats data. Using stats data of level %i.",race,class_,level+1, level);
+pInfo->levelInfo[level] = pInfo->levelInfo[level-1];
+}
+}
+}
+}
+
+// Loading xp per level data
+sLog.outString("Loading Player Create XP Data...");
+{
+mPlayerXPperLevel.resize(sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
+for (uint8 level = 0; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
+mPlayerXPperLevel[level] = 0;
+
+// 0 1
+QueryResult result = WorldDatabase.Query("SELECT lvl, xp_for_next_level FROM player_xp_for_level");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+
+sLog.outString();
+sLog.outString(">> Loaded %u xp for level definitions", count);
+sLog.outErrorDb("Error loading `player_xp_for_level` table or empty table.");
+exit(1);
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field* fields = result->Fetch();
+
+uint32 current_level = fields[0].GetUInt32();
+uint32 current_xp = fields[1].GetUInt32();
+
+if (current_level >= sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+{
+if (current_level > STRONG_MAX_LEVEL) // hardcoded level maximum
+sLog.outErrorDb("Wrong (> %u) level %u in `player_xp_for_level` table, ignoring.", STRONG_MAX_LEVEL,current_level);
+else
+{
+sLog.outDetail("Unused (> MaxPlayerLevel in worldserver.conf) level %u in `player_xp_for_levels` table, ignoring.",current_level);
+++count; // make result loading percent "expected" correct in case disabled detail mode for example.
+}
+continue;
+}
+//PlayerXPperLevel
+mPlayerXPperLevel[current_level] = current_xp;
+bar.step();
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u xp for level definitions", count);
+}
+
+// fill level gaps
+for (uint8 level = 1; level < sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL); ++level)
+{
+if (mPlayerXPperLevel[level] == 0)
+{
+sLog.outErrorDb("Level %i does not have XP for level data. Using data of level [%i] + 100.",level+1, level);
+mPlayerXPperLevel[level] = mPlayerXPperLevel[level-1]+100;
+}
+}
+}
+
+void ObjectMgr::GetPlayerClassLevelInfo(uint32 class_, uint8 level, PlayerClassLevelInfo* info) const
+{
+if (level < 1 || class_ >= MAX_CLASSES)
+return;
+
+PlayerClassInfo const* pInfo = &playerClassInfo[class_];
+
+if (level > sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+level = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+*info = pInfo->levelInfo[level-1];
+}
+
+void ObjectMgr::GetPlayerLevelInfo(uint32 race, uint32 class_, uint8 level, PlayerLevelInfo* info) const
+{
+if (level < 1 || race >= MAX_RACES || class_ >= MAX_CLASSES)
+return;
+
+PlayerInfo const* pInfo = &playerInfo[race][class_];
+if (pInfo->displayId_m == 0 || pInfo->displayId_f == 0)
+return;
+
+if (level <= sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+*info = pInfo->levelInfo[level-1];
+else
+BuildPlayerLevelInfo(race,class_,level,info);
+}
+
+void ObjectMgr::BuildPlayerLevelInfo(uint8 race, uint8 _class, uint8 level, PlayerLevelInfo* info) const
+{
+// base data (last known level)
+*info = playerInfo[race][_class].levelInfo[sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)-1];
+
+// if conversion from uint32 to uint8 causes unexpected behaviour, change lvl to uint32
+for (uint8 lvl = sWorld.getIntConfig(CONFIG_MAX_PLAYER_LEVEL)-1; lvl < level; ++lvl)
+{
+switch(_class)
+{
+case CLASS_WARRIOR:
+info->stats[STAT_STRENGTH] += (lvl > 23 ? 2: (lvl > 1 ? 1: 0));
+info->stats[STAT_STAMINA] += (lvl > 23 ? 2: (lvl > 1 ? 1: 0));
+info->stats[STAT_AGILITY] += (lvl > 36 ? 1: (lvl > 6 && (lvl%2) ? 1: 0));
+info->stats[STAT_INTELLECT] += (lvl > 9 && !(lvl%2) ? 1: 0);
+info->stats[STAT_SPIRIT] += (lvl > 9 && !(lvl%2) ? 1: 0);
+break;
+case CLASS_PALADIN:
+info->stats[STAT_STRENGTH] += (lvl > 3 ? 1: 0);
+info->stats[STAT_STAMINA] += (lvl > 33 ? 2: (lvl > 1 ? 1: 0));
+info->stats[STAT_AGILITY] += (lvl > 38 ? 1: (lvl > 7 && !(lvl%2) ? 1: 0));
+info->stats[STAT_INTELLECT] += (lvl > 6 && (lvl%2) ? 1: 0);
+info->stats[STAT_SPIRIT] += (lvl > 7 ? 1: 0);
+break;
+case CLASS_HUNTER:
+info->stats[STAT_STRENGTH] += (lvl > 4 ? 1: 0);
+info->stats[STAT_STAMINA] += (lvl > 4 ? 1: 0);
+info->stats[STAT_AGILITY] += (lvl > 33 ? 2: (lvl > 1 ? 1: 0));
+info->stats[STAT_INTELLECT] += (lvl > 8 && (lvl%2) ? 1: 0);
+info->stats[STAT_SPIRIT] += (lvl > 38 ? 1: (lvl > 9 && !(lvl%2) ? 1: 0));
+break;
+case CLASS_ROGUE:
+info->stats[STAT_STRENGTH] += (lvl > 5 ? 1: 0);
+info->stats[STAT_STAMINA] += (lvl > 4 ? 1: 0);
+info->stats[STAT_AGILITY] += (lvl > 16 ? 2: (lvl > 1 ? 1: 0));
+info->stats[STAT_INTELLECT] += (lvl > 8 && !(lvl%2) ? 1: 0);
+info->stats[STAT_SPIRIT] += (lvl > 38 ? 1: (lvl > 9 && !(lvl%2) ? 1: 0));
+break;
+case CLASS_PRIEST:
+info->stats[STAT_STRENGTH] += (lvl > 9 && !(lvl%2) ? 1: 0);
+info->stats[STAT_STAMINA] += (lvl > 5 ? 1: 0);
+info->stats[STAT_AGILITY] += (lvl > 38 ? 1: (lvl > 8 && (lvl%2) ? 1: 0));
+info->stats[STAT_INTELLECT] += (lvl > 22 ? 2: (lvl > 1 ? 1: 0));
+info->stats[STAT_SPIRIT] += (lvl > 3 ? 1: 0);
+break;
+case CLASS_SHAMAN:
+info->stats[STAT_STRENGTH] += (lvl > 34 ? 1: (lvl > 6 && (lvl%2) ? 1: 0));
+info->stats[STAT_STAMINA] += (lvl > 4 ? 1: 0);
+info->stats[STAT_AGILITY] += (lvl > 7 && !(lvl%2) ? 1: 0);
+info->stats[STAT_INTELLECT] += (lvl > 5 ? 1: 0);
+info->stats[STAT_SPIRIT] += (lvl > 4 ? 1: 0);
+break;
+case CLASS_MAGE:
+info->stats[STAT_STRENGTH] += (lvl > 9 && !(lvl%2) ? 1: 0);
+info->stats[STAT_STAMINA] += (lvl > 5 ? 1: 0);
+info->stats[STAT_AGILITY] += (lvl > 9 && !(lvl%2) ? 1: 0);
+info->stats[STAT_INTELLECT] += (lvl > 24 ? 2: (lvl > 1 ? 1: 0));
+info->stats[STAT_SPIRIT] += (lvl > 33 ? 2: (lvl > 2 ? 1: 0));
+break;
+case CLASS_WARLOCK:
+info->stats[STAT_STRENGTH] += (lvl > 9 && !(lvl%2) ? 1: 0);
+info->stats[STAT_STAMINA] += (lvl > 38 ? 2: (lvl > 3 ? 1: 0));
+info->stats[STAT_AGILITY] += (lvl > 9 && !(lvl%2) ? 1: 0);
+info->stats[STAT_INTELLECT] += (lvl > 33 ? 2: (lvl > 2 ? 1: 0));
+info->stats[STAT_SPIRIT] += (lvl > 38 ? 2: (lvl > 3 ? 1: 0));
+break;
+case CLASS_DRUID:
+info->stats[STAT_STRENGTH] += (lvl > 38 ? 2: (lvl > 6 && (lvl%2) ? 1: 0));
+info->stats[STAT_STAMINA] += (lvl > 32 ? 2: (lvl > 4 ? 1: 0));
+info->stats[STAT_AGILITY] += (lvl > 38 ? 2: (lvl > 8 && (lvl%2) ? 1: 0));
+info->stats[STAT_INTELLECT] += (lvl > 38 ? 3: (lvl > 4 ? 1: 0));
+info->stats[STAT_SPIRIT] += (lvl > 38 ? 3: (lvl > 5 ? 1: 0));
+}
+}
+}
+
+void ObjectMgr::LoadGuilds()
+{
+PreparedStatement* stmt = NULL;
+PreparedQueryResult result;
+
+sLog.outString("Loading Guilds...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILDS);
+result = CharacterDatabase.Query(stmt);
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString(">> Loaded 0 guild definitions");
+sLog.outString();
+return;
+}
+mGuildMap.resize(m_guildId, NULL);         // Reserve space and initialize storage for loading guilds
+// 1. Load all guilds
+uint64 rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+Guild* pNewGuild = new Guild();
+if (!pNewGuild->LoadFromDB(fields))
+{
+delete pNewGuild;
+continue;
+}
+AddGuild(pNewGuild);
+}
+while (result->NextRow());
+sLog.outString();
+sLog.outString(">> Loaded " UI64FMTD " guilds definitions", rowCount);
+sLog.outString();
+
+// 2. Load all guild ranks
+sLog.outString("Loading guild ranks...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_RANKS);
+result = CharacterDatabase.Query(stmt);
+if (result)
+{
+rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+uint32 guildId = fields[0].GetUInt32();
+if (Guild* pGuild = GetGuildById(guildId))
+pGuild->LoadRankFromDB(fields);
+}
+while (result->NextRow());
+}
+else
+{
+rowCount = 0;
+barGoLink bar(1);
+bar.step();
+}
+sLog.outString(">> Loaded " UI64FMTD " ranks for all the guilds", rowCount);
+sLog.outString();
+
+// 3. Load all guild members
+sLog.outString("Loading guild members...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_MEMBERS);
+result = CharacterDatabase.Query(stmt);
+if (result)
+{
+rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+uint32 guildId = fields[0].GetUInt32();
+if (Guild* pGuild = GetGuildById(guildId))
+pGuild->LoadMemberFromDB(fields);
+}
+while (result->NextRow());
+}
+else
+{
+rowCount = 0;
+barGoLink bar(1);
+bar.step();
+}
+sLog.outString(">> Loaded " UI64FMTD " members from all the guilds", rowCount);
+sLog.outString();
+
+// 4. Load all guild bank tab rights
+sLog.outString("Loading bank tab rights...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_RIGHTS);
+result = CharacterDatabase.Query(stmt);
+if (result)
+{
+rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+uint32 guildId = fields[0].GetUInt32();
+if (Guild* pGuild = GetGuildById(guildId))
+pGuild->LoadBankRightFromDB(fields);
+}
+while (result->NextRow());
+}
+else
+{
+rowCount = 0;
+barGoLink bar(1);
+bar.step();
+}
+sLog.outString(">> Loaded " UI64FMTD " bank tab rights for all the guilds", rowCount);
+sLog.outString();
+
+// 5. Load all event logs
+sLog.outString("Loading guild event logs...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_EVENTLOGS);
+result = CharacterDatabase.Query(stmt);
+if (result)
+{
+rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+uint32 guildId = fields[0].GetUInt32();
+if (Guild* pGuild = GetGuildById(guildId))
+pGuild->LoadEventLogFromDB(fields);
+}
+while (result->NextRow());
+}
+else
+{
+rowCount = 0;
+barGoLink bar(1);
+bar.step();
+}
+sLog.outString(">> Loaded " UI64FMTD " event logs for all the guilds", rowCount);
+sLog.outString();
+
+// 6. Load all bank event logs
+sLog.outString("Loading guild bank event logs...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_EVENTLOGS);
+result = CharacterDatabase.Query(stmt);
+if (result)
+{
+rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+uint32 guildId = fields[0].GetUInt32();
+if (Guild* pGuild = GetGuildById(guildId))
+pGuild->LoadBankEventLogFromDB(fields);
+}
+while (result->NextRow());
+}
+else
+{
+rowCount = 0;
+barGoLink bar(1);
+bar.step();
+}
+sLog.outString(">> Loaded " UI64FMTD " bank event logs for all the guilds", rowCount);
+sLog.outString();
+
+// 7. Load all guild bank tabs
+sLog.outString("Loading guild bank tabs...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_TABS);
+result = CharacterDatabase.Query(stmt);
+if (result)
+{
+rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+uint32 guildId = fields[0].GetUInt32();
+if (Guild* pGuild = GetGuildById(guildId))
+pGuild->LoadBankTabFromDB(fields);
+}
+while (result->NextRow());
+}
+else
+{
+rowCount = 0;
+barGoLink bar(1);
+bar.step();
+}
+sLog.outString(">> Loaded " UI64FMTD " bank tabs for all the guilds", rowCount);
+sLog.outString();
+
+// 8. Fill all guild bank tabs
+sLog.outString("Filling bank tabs with items...");
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_LOAD_GUILD_BANK_ITEMS);
+result = CharacterDatabase.Query(stmt);
+if (result)
+{
+rowCount = result->GetRowCount();
+barGoLink bar(rowCount);
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+uint32 guildId = fields[11].GetUInt32();
+if (Guild* pGuild = GetGuildById(guildId))
+pGuild->LoadBankItemFromDB(fields);
+}
+while (result->NextRow());
+}
+else
+{
+rowCount = 0;
+barGoLink bar(1);
+bar.step();
+}
+sLog.outString(">> Filled bank tabs with " UI64FMTD " items for all the guilds", rowCount);
+sLog.outString();
+
+// 9. Validate loaded guild data
+uint32 totalGuilds = 0;
+sLog.outString("Validating data of loaded guilds...");
+barGoLink barGuilds(mGuildMap.size());
+for (GuildMap::iterator itr = mGuildMap.begin(); itr != mGuildMap.end(); ++itr)
+{
+barGuilds.step();
+Guild* pGuild = *itr;
+if (pGuild)
+{
+if (!pGuild->Validate())
+{
+RemoveGuild(pGuild->GetId());
+delete pGuild;
+}
+else
+++totalGuilds;
+}
+}
+// Cleanup
+// Delete orphan guild ranks
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_RANKS);
+CharacterDatabase.Execute(stmt);
+// Delete orphan guild members
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_MEMBERS);
+CharacterDatabase.Execute(stmt);
+// Delete orphan guild bank rights
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_BANK_RIGHTS);
+CharacterDatabase.Execute(stmt);
+// Delete orphan guild bank tabs
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_BANK_TABS);
+CharacterDatabase.Execute(stmt);
+// Delete orphan guild bank items
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_CLEAN_GUILD_BANK_ITEMS);
+CharacterDatabase.Execute(stmt);
+
+// Delete unused LogGuid records in guild_eventlog and guild_bank_eventlog table.
+// You can comment these lines if you don't plan to change CONFIG_GUILD_EVENT_LOG_COUNT and CONFIG_GUILD_BANK_EVENT_LOG_COUNT
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_OLD_GUILD_EVENT_LOGS);
+stmt->setUInt32(0, sWorld.getIntConfig(CONFIG_GUILD_EVENT_LOG_COUNT));
+CharacterDatabase.Execute(stmt);
+
+stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_OLD_GUILD_BANK_EVENT_LOGS);
+stmt->setUInt32(0, sWorld.getIntConfig(CONFIG_GUILD_BANK_EVENT_LOG_COUNT));
+CharacterDatabase.Execute(stmt);
+
+sLog.outString();
+sLog.outString(">> Successfully loaded %u guilds", totalGuilds);
+}
+
+void ObjectMgr::LoadArenaTeams()
+{
+uint32 count = 0;
+
+// 0 1 2 3 4 5
+QueryResult result = CharacterDatabase.Query("SELECT arena_team.arenateamid,name,captainguid,type,BackgroundColor,EmblemStyle,"
+// 6 7 8 9 10 11 12 13 14
+"EmblemColor,BorderStyle,BorderColor, rating,games,wins,played,wins2,rank "
+"FROM arena_team LEFT JOIN arena_team_stats ON arena_team.arenateamid = arena_team_stats.arenateamid ORDER BY arena_team.arenateamid ASC");
+
+if (!result)
+{
+
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u arenateam definitions", count);
+return;
+}
+
+// load arena_team members
+QueryResult arenaTeamMembersResult = CharacterDatabase.Query(
+// 0 1 2 3 4 5 6 7 8
+"SELECT arenateamid,member.guid,played_week,wons_week,played_season,wons_season,name,class "
+"FROM arena_team_member member LEFT JOIN characters chars on member.guid = chars.guid ORDER BY member.arenateamid ASC");
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+//Field *fields = result->Fetch();
+
+bar.step();
+++count;
+
+ArenaTeam *newArenaTeam = new ArenaTeam;
+if (!newArenaTeam->LoadArenaTeamFromDB(result) ||
+!newArenaTeam->LoadMembersFromDB(arenaTeamMembersResult))
+{
+newArenaTeam->Disband(NULL);
+delete newArenaTeam;
+continue;
+}
+AddArenaTeam(newArenaTeam);
+}while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u arenateam definitions", count);
+}
+
+void ObjectMgr::LoadGroups()
+{
+Group *group = NULL;
+Field *fields = NULL;
+uint32 count = 0;
+
+// Consistency cleaning before load to avoid having to do some checks later
+// Delete all members that does not exist
+CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_NONEXISTENT_CHARACTER_GROUP_MEMBERS));
+// Delete all groups whose leader does not exist
+CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_LEADERLESS_GROUPS));
+// Delete all groups with less than 2 members
+CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_TINY_GROUPS));
+// Delete all rows from group_member or group_instance with no group
+CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_NONEXISTENT_GROUP_MEMBERS));
+CharacterDatabase.Execute(CharacterDatabase.GetPreparedStatement(CHAR_DEL_NONEXISTENT_GROUP_INSTANCES));
+
+// ----------------------- Load Group definitions
+// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
+QueryResult result = CharacterDatabase.PQuery("SELECT leaderGuid, lootMethod, looterGuid, lootThreshold, icon1, icon2, icon3, icon4, icon5, icon6, icon7, icon8, groupType, difficulty, raiddifficulty, guid FROM groups");
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded 0 group definitions");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+do
+{
+bar.step();
+fields = result->Fetch();
+++count;
+group = new Group;
+group->LoadGroupFromDB(fields[15].GetUInt32(), result, false);
+// group load will never be false (we have run consistency sql's before loading)
+AddGroup(group);
+}while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u group definitions", count);
+
+// ----------------------- Load member
+// 0 1 2 3 4
+result = CharacterDatabase.Query("SELECT guid, memberGuid, memberFlags, subgroup, roles FROM group_member ORDER BY guid");
+if (!result)
+{
+barGoLink bar2(1);
+bar2.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 group members");
+return;
+}
+
+barGoLink bar2(result->GetRowCount());
+uint32 groupLowGuid = 0;
+count = 0;
+do
+{
+bar2.step();
+fields = result->Fetch();
+
+if (groupLowGuid != fields[0].GetUInt32())
+{
+groupLowGuid = fields[0].GetUInt32();
+group = GetGroupByGUID(groupLowGuid);
+}
+if (group) // Should never be null
+group->LoadMemberFromDB(fields[1].GetUInt32(), fields[2].GetUInt8(), fields[3].GetUInt8(), fields[4].GetUInt8());
+else
+sLog.outError("ObjectMgr::LoadGroups: Consistency failed, can't find group (lowguid %u)", groupLowGuid);
+++count;
+}while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u group members", count);
+
+
+// ----------------------- Load instance save
+// 0 1 2 3 4 5
+result = CharacterDatabase.Query("SELECT guid, map, instance, permanent, difficulty, resettime, "
+// 6
+"(SELECT COUNT(1) FROM groups JOIN character_instance ON leaderGuid = groups.guid WHERE instance = group_instance.instance AND permanent = 1 LIMIT 1) "
+"FROM group_instance LEFT JOIN instance ON instance = id ORDER BY guid");
+
+if (!result)
+{
+barGoLink bar2(1);
+bar2.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 group-instance saves");
+return;
+}
+
+barGoLink bar3(result->GetRowCount());
+count = 0;
+do
+{
+bar3.step();
+fields = result->Fetch();
+group = GetGroupByGUID(fields[0].GetUInt32());
+// group will never be NULL (we have run consistency sql's before loading)
+
+MapEntry const* mapEntry = sMapStore.LookupEntry(fields[1].GetUInt32());
+if (!mapEntry || !mapEntry->IsDungeon())
+{
+sLog.outErrorDb("Incorrect entry in group_instance table : no dungeon map %d", fields[1].GetUInt32());
+continue;
+}
+
+uint32 diff = fields[4].GetUInt8();
+if (diff >= uint32(mapEntry->IsRaid() ? MAX_RAID_DIFFICULTY : MAX_DUNGEON_DIFFICULTY))
+{
+sLog.outErrorDb("Wrong dungeon difficulty use in group_instance table: %d", diff + 1);
+diff = 0; // default for both difficaly types
+}
+
+InstanceSave *save = sInstanceSaveMgr.AddInstanceSave(mapEntry->MapID, fields[2].GetUInt32(), Difficulty(diff), time_t(fields[5].GetUInt64()), fields[6].GetBool(), true);
+group->BindToInstance(save, fields[3].GetBool(), true);
+++count;
+}while (result->NextRow());
+sLog.outString();
+sLog.outString(">> Loaded %u group-instance saves", count);
+}
+
+void ObjectMgr::LoadQuests()
+{
+// For reload case
+for (QuestMap::const_iterator itr=mQuestTemplates.begin(); itr != mQuestTemplates.end(); ++itr)
+delete itr->second;
+mQuestTemplates.clear();
+
+mExclusiveQuestGroups.clear();
+
+// 0 1 2 3 4 5 6 7 8 9
+QueryResult result = WorldDatabase.Query("SELECT entry, Method, ZoneOrSort, SkillOrClassMask, MinLevel, MaxLevel, QuestLevel, Type, RequiredRaces, RequiredSkillValue,"
+// 10 11 12 13 14 15 16 17 18 19
+"RepObjectiveFaction, RepObjectiveValue, RepObjectiveFaction2, RepObjectiveValue2, RequiredMinRepFaction, RequiredMinRepValue, RequiredMaxRepFaction, RequiredMaxRepValue, SuggestedPlayers, LimitTime,"
+// 20 21 22 23 24 25 26 27 28 29 30 31 32 33
+"QuestFlags, SpecialFlags, CharTitleId, PlayersSlain, BonusTalents, RewardArenaPoints, PrevQuestId, NextQuestId, ExclusiveGroup, NextQuestInChain, RewXPId, SrcItemId, SrcItemCount, SrcSpell,"
+// 34 35 36 37 38 39 40 41 42 43 44
+"Title, Details, Objectives, OfferRewardText, RequestItemsText, EndText, CompletedText, ObjectiveText1, ObjectiveText2, ObjectiveText3, ObjectiveText4,"
+// 45 46 47 48 49 50 51 52 53 54 55 56
+"ReqItemId1, ReqItemId2, ReqItemId3, ReqItemId4, ReqItemId5, ReqItemId6, ReqItemCount1, ReqItemCount2, ReqItemCount3, ReqItemCount4, ReqItemCount5, ReqItemCount6,"
+// 57 58 59 60 61 62 63 64
+"ReqSourceId1, ReqSourceId2, ReqSourceId3, ReqSourceId4, ReqSourceCount1, ReqSourceCount2, ReqSourceCount3, ReqSourceCount4,"
+// 65 66 67 68 69 70 71 72
+"ReqCreatureOrGOId1, ReqCreatureOrGOId2, ReqCreatureOrGOId3, ReqCreatureOrGOId4, ReqCreatureOrGOCount1, ReqCreatureOrGOCount2, ReqCreatureOrGOCount3, ReqCreatureOrGOCount4,"
+// 73 74 75 76
+"ReqSpellCast1, ReqSpellCast2, ReqSpellCast3, ReqSpellCast4,"
+// 77 78 79 80 81 82
+"RewChoiceItemId1, RewChoiceItemId2, RewChoiceItemId3, RewChoiceItemId4, RewChoiceItemId5, RewChoiceItemId6,"
+// 83 84 85 86 87 88
+"RewChoiceItemCount1, RewChoiceItemCount2, RewChoiceItemCount3, RewChoiceItemCount4, RewChoiceItemCount5, RewChoiceItemCount6,"
+// 89 90 91 92 93 94 95 96
+"RewItemId1, RewItemId2, RewItemId3, RewItemId4, RewItemCount1, RewItemCount2, RewItemCount3, RewItemCount4,"
+// 97 98 99 100 101 102 103 104 105 106
+"RewRepFaction1, RewRepFaction2, RewRepFaction3, RewRepFaction4, RewRepFaction5, RewRepValueId1, RewRepValueId2, RewRepValueId3, RewRepValueId4, RewRepValueId5,"
+// 107 108 109 110 111
+"RewRepValue1, RewRepValue2, RewRepValue3, RewRepValue4, RewRepValue5,"
+// 112 113 114 115 116 117 118 119 120 121 122 123
+"RewHonorAddition, RewHonorMultiplier, RewOrReqMoney, RewMoneyMaxLevel, RewSpell, RewSpellCast, RewMailTemplateId, RewMailDelaySecs, PointMapId, PointX, PointY, PointOpt,"
+// 124 125 126 127 128 129 130 131
+"DetailsEmote1, DetailsEmote2, DetailsEmote3, DetailsEmote4, DetailsEmoteDelay1, DetailsEmoteDelay2, DetailsEmoteDelay3, DetailsEmoteDelay4,"
+// 132 133 134 135 136 137
+"IncompleteEmote, CompleteEmote, OfferRewardEmote1, OfferRewardEmote2, OfferRewardEmote3, OfferRewardEmote4,"
+// 138 139 140 141
+"OfferRewardEmoteDelay1, OfferRewardEmoteDelay2, OfferRewardEmoteDelay3, OfferRewardEmoteDelay4,"
+// 142 143
+"StartScript, CompleteScript"
+" FROM quest_template");
+if (result == NULL)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded 0 quests definitions");
+sLog.outErrorDb("`quest_template` table is empty!");
+return;
+}
+
+// create multimap previous quest for each existed quest
+// some quests can have many previous maps set by NextQuestId in previous quest
+// for example set of race quests can lead to single not race specific quest
+barGoLink bar(result->GetRowCount());
+do
+{
+bar.step();
+Field *fields = result->Fetch();
+
+Quest * newQuest = new Quest(fields);
+mQuestTemplates[newQuest->GetQuestId()] = newQuest;
+} while (result->NextRow());
+
+std::map<uint32,uint32> usedMailTemplates;
+
+// Post processing
+for (QuestMap::iterator iter = mQuestTemplates.begin(); iter != mQuestTemplates.end(); ++iter)
+{
+// skip post-loading checks for disabled quests
+if (sDisableMgr.IsDisabledFor(DISABLE_TYPE_QUEST, iter->first, NULL))
+continue;
+
+Quest * qinfo = iter->second;
+
+// additional quest integrity checks (GO, creature_template and item_template must be loaded already)
+
+if (qinfo->GetQuestMethod() >= 3)
+{
+sLog.outErrorDb("Quest %u has `Method` = %u, expected values are 0, 1 or 2.",qinfo->GetQuestId(),qinfo->GetQuestMethod());
+}
+
+if (qinfo->QuestFlags & ~QUEST_TRINITY_FLAGS_DB_ALLOWED)
+{
+sLog.outErrorDb("Quest %u has `SpecialFlags` = %u > max allowed value. Correct `SpecialFlags` to value <= %u",
+qinfo->GetQuestId(),qinfo->QuestFlags >> 20, QUEST_TRINITY_FLAGS_DB_ALLOWED >> 20);
+qinfo->QuestFlags &= QUEST_TRINITY_FLAGS_DB_ALLOWED;
+}
+
+if (qinfo->QuestFlags & QUEST_FLAGS_DAILY && qinfo->QuestFlags & QUEST_FLAGS_WEEKLY)
+{
+sLog.outErrorDb("Weekly Quest %u is marked as daily quest in `QuestFlags`, removed daily flag.",qinfo->GetQuestId());
+qinfo->QuestFlags &= ~QUEST_FLAGS_DAILY;
+}
+
+if (qinfo->QuestFlags & QUEST_FLAGS_DAILY)
+{
+if (!(qinfo->QuestFlags & QUEST_TRINITY_FLAGS_REPEATABLE))
+{
+sLog.outErrorDb("Daily Quest %u not marked as repeatable in `SpecialFlags`, added.",qinfo->GetQuestId());
+qinfo->QuestFlags |= QUEST_TRINITY_FLAGS_REPEATABLE;
+}
+}
+
+if (qinfo->QuestFlags & QUEST_FLAGS_WEEKLY)
+{
+if (!(qinfo->QuestFlags & QUEST_TRINITY_FLAGS_REPEATABLE))
+{
+sLog.outErrorDb("Weekly Quest %u not marked as repeatable in `SpecialFlags`, added.",qinfo->GetQuestId());
+qinfo->QuestFlags |= QUEST_TRINITY_FLAGS_REPEATABLE;
+}
+}
+
+if (qinfo->QuestFlags & QUEST_FLAGS_AUTO_REWARDED)
+{
+// at auto-reward can be rewarded only RewChoiceItemId[0]
+for (int j = 1; j < QUEST_REWARD_CHOICES_COUNT; ++j )
+{
+if (uint32 id = qinfo->RewChoiceItemId[j])
+{
+sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = %u but item from `RewChoiceItemId%d` can't be rewarded with quest flag QUEST_FLAGS_AUTO_REWARDED.",
+qinfo->GetQuestId(),j+1,id,j+1);
+// no changes, quest ignore this data
+}
+}
+}
+
+// client quest log visual (area case)
+if (qinfo->ZoneOrSort > 0)
+{
+if (!GetAreaEntryByAreaID(qinfo->ZoneOrSort))
+{
+sLog.outErrorDb("Quest %u has `ZoneOrSort` = %u (zone case) but zone with this id does not exist.",
+qinfo->GetQuestId(),qinfo->ZoneOrSort);
+// no changes, quest not dependent from this value but can have problems at client
+}
+}
+// client quest log visual (sort case)
+if (qinfo->ZoneOrSort < 0)
+{
+QuestSortEntry const* qSort = sQuestSortStore.LookupEntry(-int32(qinfo->ZoneOrSort));
+if (!qSort)
+{
+sLog.outErrorDb("Quest %u has `ZoneOrSort` = %i (sort case) but quest sort with this id does not exist.",
+qinfo->GetQuestId(),qinfo->ZoneOrSort);
+// no changes, quest not dependent from this value but can have problems at client (note some may be 0, we must allow this so no check)
+}
+//check SkillOrClass value (class case).
+if (ClassByQuestSort(-int32(qinfo->ZoneOrSort)))
+{
+// SkillOrClass should not have class case when class case already set in ZoneOrSort.
+if (qinfo->SkillOrClassMask < 0)
+{
+sLog.outErrorDb("Quest %u has `ZoneOrSort` = %i (class sort case) and `SkillOrClassMask` = %i (class case), redundant.",
+qinfo->GetQuestId(),qinfo->ZoneOrSort,qinfo->SkillOrClassMask);
+}
+}
+//check for proper SkillOrClass value (skill case)
+if (int32 skill_id = SkillByQuestSort(-int32(qinfo->ZoneOrSort)))
+{
+// skill is positive value in SkillOrClass
+if (qinfo->SkillOrClassMask != skill_id)
+{
+sLog.outErrorDb("Quest %u has `ZoneOrSort` = %i (skill sort case) but `SkillOrClassMask` does not have a corresponding value (%i).",
+qinfo->GetQuestId(),qinfo->ZoneOrSort,skill_id);
+//override, and force proper value here?
+}
+}
+}
+
+// SkillOrClassMask (class case)
+if (qinfo->SkillOrClassMask < 0)
+{
+if (!(-int32(qinfo->SkillOrClassMask) & CLASSMASK_ALL_PLAYABLE))
+{
+sLog.outErrorDb("Quest %u has `SkillOrClassMask` = %i (class case) but classmask does not have valid class",
+qinfo->GetQuestId(),qinfo->SkillOrClassMask);
+}
+}
+// SkillOrClassMask (skill case)
+if (qinfo->SkillOrClassMask > 0)
+{
+if (!sSkillLineStore.LookupEntry(qinfo->SkillOrClassMask))
+{
+sLog.outErrorDb("Quest %u has `SkillOrClass` = %u (skill case) but skill (%i) does not exist",
+qinfo->GetQuestId(),qinfo->SkillOrClassMask,qinfo->SkillOrClassMask);
+}
+}
+
+if (qinfo->RequiredSkillValue)
+{
+if (qinfo->RequiredSkillValue > sWorld.GetConfigMaxSkillValue())
+{
+sLog.outErrorDb("Quest %u has `RequiredSkillValue` = %u but max possible skill is %u, quest can't be done.",
+qinfo->GetQuestId(),qinfo->RequiredSkillValue,sWorld.GetConfigMaxSkillValue());
+// no changes, quest can't be done for this requirement
+}
+
+if (qinfo->SkillOrClassMask <= 0)
+{
+sLog.outErrorDb("Quest %u has `RequiredSkillValue` = %u but `SkillOrClass` = %i (class case), value ignored.",
+qinfo->GetQuestId(),qinfo->RequiredSkillValue,qinfo->SkillOrClassMask);
+// no changes, quest can't be done for this requirement (fail at wrong skill id)
+}
+}
+// else Skill quests can have 0 skill level, this is ok
+
+if (qinfo->RepObjectiveFaction2 && !sFactionStore.LookupEntry(qinfo->RepObjectiveFaction2))
+{
+sLog.outErrorDb("Quest %u has `RepObjectiveFaction2` = %u but faction template %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),qinfo->RepObjectiveFaction2,qinfo->RepObjectiveFaction2);
+// no changes, quest can't be done for this requirement
+}
+
+if (qinfo->RepObjectiveFaction && !sFactionStore.LookupEntry(qinfo->RepObjectiveFaction))
+{
+sLog.outErrorDb("Quest %u has `RepObjectiveFaction` = %u but faction template %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),qinfo->RepObjectiveFaction,qinfo->RepObjectiveFaction);
+// no changes, quest can't be done for this requirement
+}
+
+if (qinfo->RequiredMinRepFaction && !sFactionStore.LookupEntry(qinfo->RequiredMinRepFaction))
+{
+sLog.outErrorDb("Quest %u has `RequiredMinRepFaction` = %u but faction template %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),qinfo->RequiredMinRepFaction,qinfo->RequiredMinRepFaction);
+// no changes, quest can't be done for this requirement
+}
+
+if (qinfo->RequiredMaxRepFaction && !sFactionStore.LookupEntry(qinfo->RequiredMaxRepFaction))
+{
+sLog.outErrorDb("Quest %u has `RequiredMaxRepFaction` = %u but faction template %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),qinfo->RequiredMaxRepFaction,qinfo->RequiredMaxRepFaction);
+// no changes, quest can't be done for this requirement
+}
+
+if (qinfo->RequiredMinRepValue && qinfo->RequiredMinRepValue > ReputationMgr::Reputation_Cap)
+{
+sLog.outErrorDb("Quest %u has `RequiredMinRepValue` = %d but max reputation is %u, quest can't be done.",
+qinfo->GetQuestId(),qinfo->RequiredMinRepValue,ReputationMgr::Reputation_Cap);
+// no changes, quest can't be done for this requirement
+}
+
+if (qinfo->RequiredMinRepValue && qinfo->RequiredMaxRepValue && qinfo->RequiredMaxRepValue <= qinfo->RequiredMinRepValue)
+{
+sLog.outErrorDb("Quest %u has `RequiredMaxRepValue` = %d and `RequiredMinRepValue` = %d, quest can't be done.",
+qinfo->GetQuestId(),qinfo->RequiredMaxRepValue,qinfo->RequiredMinRepValue);
+// no changes, quest can't be done for this requirement
+}
+
+if (!qinfo->RepObjectiveFaction && qinfo->RepObjectiveValue > 0)
+{
+sLog.outErrorDb("Quest %u has `RepObjectiveValue` = %d but `RepObjectiveFaction` is 0, value has no effect",
+qinfo->GetQuestId(),qinfo->RepObjectiveValue);
+// warning
+}
+
+if (!qinfo->RepObjectiveFaction2 && qinfo->RepObjectiveValue2 > 0)
+{
+sLog.outErrorDb("Quest %u has `RepObjectiveValue2` = %d but `RepObjectiveFaction2` is 0, value has no effect",
+qinfo->GetQuestId(),qinfo->RepObjectiveValue2);
+// warning
+}
+
+if (!qinfo->RequiredMinRepFaction && qinfo->RequiredMinRepValue > 0)
+{
+sLog.outErrorDb("Quest %u has `RequiredMinRepValue` = %d but `RequiredMinRepFaction` is 0, value has no effect",
+qinfo->GetQuestId(),qinfo->RequiredMinRepValue);
+// warning
+}
+
+if (!qinfo->RequiredMaxRepFaction && qinfo->RequiredMaxRepValue > 0)
+{
+sLog.outErrorDb("Quest %u has `RequiredMaxRepValue` = %d but `RequiredMaxRepFaction` is 0, value has no effect",
+qinfo->GetQuestId(),qinfo->RequiredMaxRepValue);
+// warning
+}
+
+if (qinfo->CharTitleId && !sCharTitlesStore.LookupEntry(qinfo->CharTitleId))
+{
+sLog.outErrorDb("Quest %u has `CharTitleId` = %u but CharTitle Id %u does not exist, quest can't be rewarded with title.",
+qinfo->GetQuestId(),qinfo->GetCharTitleId(),qinfo->GetCharTitleId());
+qinfo->CharTitleId = 0;
+// quest can't reward this title
+}
+
+if (qinfo->SrcItemId)
+{
+if (!sItemStorage.LookupEntry<ItemPrototype>(qinfo->SrcItemId))
+{
+sLog.outErrorDb("Quest %u has `SrcItemId` = %u but item with entry %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),qinfo->SrcItemId,qinfo->SrcItemId);
+qinfo->SrcItemId = 0; // quest can't be done for this requirement
+}
+else if (qinfo->SrcItemCount == 0)
+{
+sLog.outErrorDb("Quest %u has `SrcItemId` = %u but `SrcItemCount` = 0, set to 1 but need fix in DB.",
+qinfo->GetQuestId(),qinfo->SrcItemId);
+qinfo->SrcItemCount = 1; // update to 1 for allow quest work for backward compatibility with DB
+}
+}
+else if (qinfo->SrcItemCount>0)
+{
+sLog.outErrorDb("Quest %u has `SrcItemId` = 0 but `SrcItemCount` = %u, useless value.",
+qinfo->GetQuestId(),qinfo->SrcItemCount);
+qinfo->SrcItemCount=0; // no quest work changes in fact
+}
+
+if (qinfo->SrcSpell)
+{
+SpellEntry const* spellInfo = sSpellStore.LookupEntry(qinfo->SrcSpell);
+if (!spellInfo)
+{
+sLog.outErrorDb("Quest %u has `SrcSpell` = %u but spell %u doesn't exist, quest can't be done.",
+qinfo->GetQuestId(),qinfo->SrcSpell,qinfo->SrcSpell);
+qinfo->SrcSpell = 0; // quest can't be done for this requirement
+}
+else if (!SpellMgr::IsSpellValid(spellInfo))
+{
+sLog.outErrorDb("Quest %u has `SrcSpell` = %u but spell %u is broken, quest can't be done.",
+qinfo->GetQuestId(),qinfo->SrcSpell,qinfo->SrcSpell);
+qinfo->SrcSpell = 0; // quest can't be done for this requirement
+}
+}
+
+for (uint8 j = 0; j < QUEST_ITEM_OBJECTIVES_COUNT; ++j)
+{
+uint32 id = qinfo->ReqItemId[j];
+if (id)
+{
+if (qinfo->ReqItemCount[j] == 0)
+{
+sLog.outErrorDb("Quest %u has `ReqItemId%d` = %u but `ReqItemCount%d` = 0, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,j+1);
+// no changes, quest can't be done for this requirement
+}
+
+qinfo->SetFlag(QUEST_TRINITY_FLAGS_DELIVER);
+
+if (!sItemStorage.LookupEntry<ItemPrototype>(id))
+{
+sLog.outErrorDb("Quest %u has `ReqItemId%d` = %u but item with entry %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,id);
+qinfo->ReqItemCount[j] = 0; // prevent incorrect work of quest
+}
+}
+else if (qinfo->ReqItemCount[j]>0)
+{
+sLog.outErrorDb("Quest %u has `ReqItemId%d` = 0 but `ReqItemCount%d` = %u, quest can't be done.",
+qinfo->GetQuestId(),j+1,j+1,qinfo->ReqItemCount[j]);
+qinfo->ReqItemCount[j] = 0; // prevent incorrect work of quest
+}
+}
+
+for (uint8 j = 0; j < QUEST_SOURCE_ITEM_IDS_COUNT; ++j)
+{
+uint32 id = qinfo->ReqSourceId[j];
+if (id)
+{
+if (!sItemStorage.LookupEntry<ItemPrototype>(id))
+{
+sLog.outErrorDb("Quest %u has `ReqSourceId%d` = %u but item with entry %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,id);
+// no changes, quest can't be done for this requirement
+}
+}
+else
+{
+if (qinfo->ReqSourceCount[j]>0)
+{
+sLog.outErrorDb("Quest %u has `ReqSourceId%d` = 0 but `ReqSourceCount%d` = %u.",
+qinfo->GetQuestId(),j+1,j+1,qinfo->ReqSourceCount[j]);
+// no changes, quest ignore this data
+}
+}
+}
+
+for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
+{
+uint32 id = qinfo->ReqSpell[j];
+if (id)
+{
+SpellEntry const* spellInfo = sSpellStore.LookupEntry(id);
+if (!spellInfo)
+{
+sLog.outErrorDb("Quest %u has `ReqSpellCast%d` = %u but spell %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,id);
+continue;
+}
+
+if (!qinfo->ReqCreatureOrGOId[j])
+{
+bool found = false;
+for (uint8 k = 0; k < MAX_SPELL_EFFECTS; ++k)
+{
+if ((spellInfo->Effect[k] == SPELL_EFFECT_QUEST_COMPLETE && uint32(spellInfo->EffectMiscValue[k]) == qinfo->QuestId) ||
+spellInfo->Effect[k] == SPELL_EFFECT_SEND_EVENT)
+{
+found = true;
+break;
+}
+}
+
+if (found)
+{
+if (!qinfo->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
+{
+sLog.outErrorDb("Spell (id: %u) have SPELL_EFFECT_QUEST_COMPLETE or SPELL_EFFECT_SEND_EVENT for quest %u and ReqCreatureOrGOId%d = 0, but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT. Quest flags or ReqCreatureOrGOId%d must be fixed, quest modified to enable objective.",spellInfo->Id,qinfo->QuestId,j+1,j+1);
+
+// this will prevent quest completing without objective
+const_cast<Quest*>(qinfo)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
+}
+}
+else
+{
+sLog.outErrorDb("Quest %u has `ReqSpellCast%d` = %u and ReqCreatureOrGOId%d = 0 but spell %u does not have SPELL_EFFECT_QUEST_COMPLETE or SPELL_EFFECT_SEND_EVENT effect for this quest, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,j+1,id);
+// no changes, quest can't be done for this requirement
+}
+}
+}
+}
+
+for (uint8 j = 0; j < QUEST_OBJECTIVES_COUNT; ++j)
+{
+int32 id = qinfo->ReqCreatureOrGOId[j];
+if (id < 0 && !sGOStorage.LookupEntry<GameObjectInfo>(-id))
+{
+sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = %i but gameobject %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,uint32(-id));
+qinfo->ReqCreatureOrGOId[j] = 0; // quest can't be done for this requirement
+}
+
+if (id > 0 && !sCreatureStorage.LookupEntry<CreatureInfo>(id))
+{
+sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = %i but creature with entry %u does not exist, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,uint32(id));
+qinfo->ReqCreatureOrGOId[j] = 0; // quest can't be done for this requirement
+}
+
+if (id)
+{
+// In fact SpeakTo and Kill are quite same: either you can speak to mob:SpeakTo or you can't:Kill/Cast
+
+qinfo->SetFlag(QUEST_TRINITY_FLAGS_KILL_OR_CAST | QUEST_TRINITY_FLAGS_SPEAKTO);
+
+if (!qinfo->ReqCreatureOrGOCount[j])
+{
+sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = %u but `ReqCreatureOrGOCount%d` = 0, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,j+1);
+// no changes, quest can be incorrectly done, but we already report this
+}
+}
+else if (qinfo->ReqCreatureOrGOCount[j]>0)
+{
+sLog.outErrorDb("Quest %u has `ReqCreatureOrGOId%d` = 0 but `ReqCreatureOrGOCount%d` = %u.",
+qinfo->GetQuestId(),j+1,j+1,qinfo->ReqCreatureOrGOCount[j]);
+// no changes, quest ignore this data
+}
+}
+
+for (uint8 j = 0; j < QUEST_REWARD_CHOICES_COUNT; ++j)
+{
+uint32 id = qinfo->RewChoiceItemId[j];
+if (id)
+{
+if (!sItemStorage.LookupEntry<ItemPrototype>(id))
+{
+sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = %u but item with entry %u does not exist, quest will not reward this item.",
+qinfo->GetQuestId(),j+1,id,id);
+qinfo->RewChoiceItemId[j] = 0; // no changes, quest will not reward this
+}
+
+if (!qinfo->RewChoiceItemCount[j])
+{
+sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = %u but `RewChoiceItemCount%d` = 0, quest can't be done.",
+qinfo->GetQuestId(),j+1,id,j+1);
+// no changes, quest can't be done
+}
+}
+else if (qinfo->RewChoiceItemCount[j]>0)
+{
+sLog.outErrorDb("Quest %u has `RewChoiceItemId%d` = 0 but `RewChoiceItemCount%d` = %u.",
+qinfo->GetQuestId(),j+1,j+1,qinfo->RewChoiceItemCount[j]);
+// no changes, quest ignore this data
+}
+}
+
+for (uint8 j = 0; j < QUEST_REWARDS_COUNT; ++j)
+{
+uint32 id = qinfo->RewItemId[j];
+if (id)
+{
+if (!sItemStorage.LookupEntry<ItemPrototype>(id))
+{
+sLog.outErrorDb("Quest %u has `RewItemId%d` = %u but item with entry %u does not exist, quest will not reward this item.",
+qinfo->GetQuestId(),j+1,id,id);
+qinfo->RewItemId[j] = 0; // no changes, quest will not reward this item
+}
+
+if (!qinfo->RewItemCount[j])
+{
+sLog.outErrorDb("Quest %u has `RewItemId%d` = %u but `RewItemCount%d` = 0, quest will not reward this item.",
+qinfo->GetQuestId(),j+1,id,j+1);
+// no changes
+}
+}
+else if (qinfo->RewItemCount[j]>0)
+{
+sLog.outErrorDb("Quest %u has `RewItemId%d` = 0 but `RewItemCount%d` = %u.",
+qinfo->GetQuestId(),j+1,j+1,qinfo->RewItemCount[j]);
+// no changes, quest ignore this data
+}
+}
+
+for (uint8 j = 0; j < QUEST_REPUTATIONS_COUNT; ++j)
+{
+if (qinfo->RewRepFaction[j])
+{
+if (abs(qinfo->RewRepValueId[j]) > 9)
+{
+sLog.outErrorDb("Quest %u has RewRepValueId%d = %i. That is outside the range of valid values (-9 to 9).", qinfo->GetQuestId(), j+1, qinfo->RewRepValueId[j]);
+}
+if (!sFactionStore.LookupEntry(qinfo->RewRepFaction[j]))
+{
+sLog.outErrorDb("Quest %u has `RewRepFaction%d` = %u but raw faction (faction.dbc) %u does not exist, quest will not reward reputation for this faction.", qinfo->GetQuestId(),j+1,qinfo->RewRepFaction[j] ,qinfo->RewRepFaction[j]);
+qinfo->RewRepFaction[j] = 0; // quest will not reward this
+}
+}
+
+
+else if (qinfo->RewRepValue[j] != 0)
+{
+sLog.outErrorDb("Quest %u has `RewRepFaction%d` = 0 but `RewRepValue%d` = %i.",
+qinfo->GetQuestId(),j+1,j+1,qinfo->RewRepValue[j]);
+// no changes, quest ignore this data
+}
+}
+
+
+if (qinfo->RewSpell)
+{
+SpellEntry const* spellInfo = sSpellStore.LookupEntry(qinfo->RewSpell);
+
+if (!spellInfo)
+{
+sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u does not exist, spell removed as display reward.",
+qinfo->GetQuestId(),qinfo->RewSpell,qinfo->RewSpell);
+qinfo->RewSpell = 0; // no spell reward will display for this quest
+}
+
+else if (!SpellMgr::IsSpellValid(spellInfo))
+{
+sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u is broken, quest will not have a spell reward.",
+qinfo->GetQuestId(),qinfo->RewSpell,qinfo->RewSpell);
+qinfo->RewSpell = 0; // no spell reward will display for this quest
+}
+
+else if (GetTalentSpellCost(qinfo->RewSpell))
+{
+sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u is talent, quest will not have a spell reward.",
+qinfo->GetQuestId(),qinfo->RewSpell,qinfo->RewSpell);
+qinfo->RewSpell = 0; // no spell reward will display for this quest
+}
+}
+
+if (qinfo->RewSpellCast > 0)
+{
+SpellEntry const* spellInfo = sSpellStore.LookupEntry(qinfo->RewSpellCast);
+
+if (!spellInfo)
+{
+sLog.outErrorDb("Quest %u has `RewSpellCast` = %u but spell %u does not exist, quest will not have a spell reward.",
+qinfo->GetQuestId(),qinfo->RewSpellCast,qinfo->RewSpellCast);
+qinfo->RewSpellCast = 0; // no spell will be casted on player
+}
+
+else if (!SpellMgr::IsSpellValid(spellInfo))
+{
+sLog.outErrorDb("Quest %u has `RewSpellCast` = %u but spell %u is broken, quest will not have a spell reward.",
+qinfo->GetQuestId(),qinfo->RewSpellCast,qinfo->RewSpellCast);
+qinfo->RewSpellCast = 0; // no spell will be casted on player
+}
+
+else if (GetTalentSpellCost(qinfo->RewSpellCast))
+{
+sLog.outErrorDb("Quest %u has `RewSpell` = %u but spell %u is talent, quest will not have a spell reward.",
+qinfo->GetQuestId(),qinfo->RewSpellCast,qinfo->RewSpellCast);
+qinfo->RewSpellCast = 0; // no spell will be casted on player
+}
+}
+
+if (qinfo->RewMailTemplateId)
+{
+if (!sMailTemplateStore.LookupEntry(qinfo->RewMailTemplateId))
+{
+sLog.outErrorDb("Quest %u has `RewMailTemplateId` = %u but mail template %u does not exist, quest will not have a mail reward.",
+qinfo->GetQuestId(),qinfo->RewMailTemplateId,qinfo->RewMailTemplateId);
+qinfo->RewMailTemplateId = 0; // no mail will send to player
+qinfo->RewMailDelaySecs = 0; // no mail will send to player
+}
+else if (usedMailTemplates.find(qinfo->RewMailTemplateId) != usedMailTemplates.end())
+{
+std::map<uint32,uint32>::const_iterator used_mt_itr = usedMailTemplates.find(qinfo->RewMailTemplateId);
+sLog.outErrorDb("Quest %u has `RewMailTemplateId` = %u but mail template %u already used for quest %u, quest will not have a mail reward.",
+qinfo->GetQuestId(),qinfo->RewMailTemplateId,qinfo->RewMailTemplateId,used_mt_itr->second);
+qinfo->RewMailTemplateId = 0; // no mail will send to player
+qinfo->RewMailDelaySecs = 0; // no mail will send to player
+}
+else
+usedMailTemplates[qinfo->RewMailTemplateId] = qinfo->GetQuestId();
+}
+
+if (qinfo->NextQuestInChain)
+{
+QuestMap::iterator qNextItr = mQuestTemplates.find(qinfo->NextQuestInChain);
+if (qNextItr == mQuestTemplates.end())
+{
+sLog.outErrorDb("Quest %u has `NextQuestInChain` = %u but quest %u does not exist, quest chain will not work.",
+qinfo->GetQuestId(),qinfo->NextQuestInChain ,qinfo->NextQuestInChain);
+qinfo->NextQuestInChain = 0;
+}
+else
+qNextItr->second->prevChainQuests.push_back(qinfo->GetQuestId());
+}
+
+// fill additional data stores
+if (qinfo->PrevQuestId)
+{
+if (mQuestTemplates.find(abs(qinfo->GetPrevQuestId())) == mQuestTemplates.end())
+{
+sLog.outErrorDb("Quest %d has PrevQuestId %i, but no such quest", qinfo->GetQuestId(), qinfo->GetPrevQuestId());
+}
+else
+{
+qinfo->prevQuests.push_back(qinfo->PrevQuestId);
+}
+}
+
+if (qinfo->NextQuestId)
+{
+QuestMap::iterator qNextItr = mQuestTemplates.find(abs(qinfo->GetNextQuestId()));
+if (qNextItr == mQuestTemplates.end())
+{
+sLog.outErrorDb("Quest %d has NextQuestId %i, but no such quest", qinfo->GetQuestId(), qinfo->GetNextQuestId());
+}
+else
+{
+int32 signedQuestId = qinfo->NextQuestId < 0 ? -int32(qinfo->GetQuestId()) : int32(qinfo->GetQuestId());
+qNextItr->second->prevQuests.push_back(signedQuestId);
+}
+}
+
+if (qinfo->ExclusiveGroup)
+mExclusiveQuestGroups.insert(std::pair<int32, uint32>(qinfo->ExclusiveGroup, qinfo->GetQuestId()));
+if (qinfo->LimitTime)
+qinfo->SetFlag(QUEST_TRINITY_FLAGS_TIMED);
+}
+
+// check QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT for spell with SPELL_EFFECT_QUEST_COMPLETE
+for (uint32 i = 0; i < sSpellStore.GetNumRows(); ++i)
+{
+SpellEntry const *spellInfo = sSpellStore.LookupEntry(i);
+if (!spellInfo)
+continue;
+
+for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+{
+if (spellInfo->Effect[j] != SPELL_EFFECT_QUEST_COMPLETE)
+continue;
+
+uint32 quest_id = spellInfo->EffectMiscValue[j];
+
+Quest const* quest = GetQuestTemplate(quest_id);
+
+// some quest referenced in spells not exist (outdated spells)
+if (!quest)
+continue;
+
+if (!quest->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
+{
+sLog.outErrorDb("Spell (id: %u) have SPELL_EFFECT_QUEST_COMPLETE for quest %u , but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT. Quest flags must be fixed, quest modified to enable objective.",spellInfo->Id,quest_id);
+
+// this will prevent quest completing without objective
+const_cast<Quest*>(quest)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
+}
+}
+}
+
+sLog.outString();
+sLog.outString(">> Loaded %lu quests definitions", (unsigned long)mQuestTemplates.size());
+}
+
+void ObjectMgr::LoadQuestLocales()
+{
+mQuestLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT entry,"
+"Title_loc1,Details_loc1,Objectives_loc1,OfferRewardText_loc1,RequestItemsText_loc1,EndText_loc1,CompletedText_loc1,ObjectiveText1_loc1,ObjectiveText2_loc1,ObjectiveText3_loc1,ObjectiveText4_loc1,"
+"Title_loc2,Details_loc2,Objectives_loc2,OfferRewardText_loc2,RequestItemsText_loc2,EndText_loc2,CompletedText_loc2,ObjectiveText1_loc2,ObjectiveText2_loc2,ObjectiveText3_loc2,ObjectiveText4_loc2,"
+"Title_loc3,Details_loc3,Objectives_loc3,OfferRewardText_loc3,RequestItemsText_loc3,EndText_loc3,CompletedText_loc3,ObjectiveText1_loc3,ObjectiveText2_loc3,ObjectiveText3_loc3,ObjectiveText4_loc3,"
+"Title_loc4,Details_loc4,Objectives_loc4,OfferRewardText_loc4,RequestItemsText_loc4,EndText_loc4,CompletedText_loc4,ObjectiveText1_loc4,ObjectiveText2_loc4,ObjectiveText3_loc4,ObjectiveText4_loc4,"
+"Title_loc5,Details_loc5,Objectives_loc5,OfferRewardText_loc5,RequestItemsText_loc5,EndText_loc5,CompletedText_loc5,ObjectiveText1_loc5,ObjectiveText2_loc5,ObjectiveText3_loc5,ObjectiveText4_loc5,"
+"Title_loc6,Details_loc6,Objectives_loc6,OfferRewardText_loc6,RequestItemsText_loc6,EndText_loc6,CompletedText_loc6,ObjectiveText1_loc6,ObjectiveText2_loc6,ObjectiveText3_loc6,ObjectiveText4_loc6,"
+"Title_loc7,Details_loc7,Objectives_loc7,OfferRewardText_loc7,RequestItemsText_loc7,EndText_loc7,CompletedText_loc7,ObjectiveText1_loc7,ObjectiveText2_loc7,ObjectiveText3_loc7,ObjectiveText4_loc7,"
+"Title_loc8,Details_loc8,Objectives_loc8,OfferRewardText_loc8,RequestItemsText_loc8,EndText_loc8,CompletedText_loc8,ObjectiveText1_loc8,ObjectiveText2_loc8,ObjectiveText3_loc8,ObjectiveText4_loc8"
+" FROM locales_quest"
+);
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+QuestLocale& data = mQuestLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+LocaleConstant locale = (LocaleConstant) i;
+std::string str = fields[1 + 11 * (i - 1)].GetString();
+AddLocaleString(str, locale, data.Title);
+
+str = fields[1 + 11 * (i - 1) + 1].GetString();
+AddLocaleString(str, locale, data.Details);
+
+str = fields[1 + 11 * (i - 1) + 2].GetString();
+AddLocaleString(str, locale, data.Objectives);
+
+str = fields[1 + 11 * (i - 1) + 3].GetString();
+AddLocaleString(str, locale, data.OfferRewardText);
+
+str = fields[1 + 11 * (i - 1) + 4].GetString();
+AddLocaleString(str, locale, data.RequestItemsText);
+
+str = fields[1 + 11 * (i - 1) + 5].GetString();
+AddLocaleString(str, locale, data.EndText);
+
+str = fields[1 + 11 * (i - 1) + 6].GetString();
+AddLocaleString(str, locale, data.CompletedText);
+
+for (uint8 k = 0; k < 4; ++k)
+{
+str = fields[1 + 11 * (i - 1) + 7 + k].GetString();
+AddLocaleString(str, locale, data.ObjectiveText[k]);
+}
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu Quest locale strings", (unsigned long)mQuestLocaleMap.size());
+}
+
+void ObjectMgr::LoadScripts(ScriptsType type)
+{
+ScriptMapMap *scripts = GetScriptsMapByType(type);
+if (!scripts)
+return;
+
+std::string tableName = GetScriptsTableNameByType(type);
+if (tableName.empty())
+return;
+
+if (sWorld.IsScriptScheduled()) // function don't must be called in time scripts use.
+return;
+
+sLog.outString("%s :", tableName.c_str());
+
+scripts->clear(); // need for reload support
+
+bool isSpellScriptTable = (type == SCRIPTS_SPELL);
+char buff[125];
+sprintf(buff, "SELECT id,delay,command,datalong,datalong2,dataint,x,y,z,o%s FROM %s", isSpellScriptTable ? ",effIndex" : "", tableName.c_str());
+QueryResult result = WorldDatabase.Query(buff);
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u script definitions", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+ScriptInfo tmp;
+tmp.type = type;
+tmp.id = fields[0].GetUInt32();
+if (isSpellScriptTable)
+tmp.id |= fields[10].GetUInt8() << 24;
+tmp.delay = fields[1].GetUInt32();
+tmp.command = ScriptCommands(fields[2].GetUInt32());
+tmp.Raw.nData[0] = fields[3].GetUInt32();
+tmp.Raw.nData[1] = fields[4].GetUInt32();
+tmp.Raw.nData[2] = fields[5].GetInt32();
+tmp.Raw.fData[0] = fields[6].GetFloat();
+tmp.Raw.fData[1] = fields[7].GetFloat();
+tmp.Raw.fData[2] = fields[8].GetFloat();
+tmp.Raw.fData[3] = fields[9].GetFloat();
+
+// generic command args check
+switch (tmp.command)
+{
+case SCRIPT_COMMAND_TALK:
+{
+if (tmp.Talk.ChatType > CHAT_TYPE_WHISPER && tmp.Talk.ChatType != CHAT_MSG_RAID_BOSS_WHISPER)
+{
+sLog.outErrorDb("Table `%s` has invalid talk type (datalong = %u) in SCRIPT_COMMAND_TALK for script id %u",
+tableName.c_str(), tmp.Talk.ChatType, tmp.id);
+continue;
+}
+if (!tmp.Talk.TextID)
+{
+sLog.outErrorDb("Table `%s` has invalid talk text id (dataint = %i) in SCRIPT_COMMAND_TALK for script id %u",
+tableName.c_str(), tmp.Talk.TextID, tmp.id);
+continue;
+}
+if (tmp.Talk.TextID < MIN_DB_SCRIPT_STRING_ID || tmp.Talk.TextID >= MAX_DB_SCRIPT_STRING_ID)
+{
+sLog.outErrorDb("Table `%s` has out of range text id (dataint = %i expected %u-%u) in SCRIPT_COMMAND_TALK for script id %u",
+tableName.c_str(), tmp.Talk.TextID, MIN_DB_SCRIPT_STRING_ID, MAX_DB_SCRIPT_STRING_ID, tmp.id);
+continue;
+}
+
+break;
+}
+
+case SCRIPT_COMMAND_EMOTE:
+{
+if (!sEmotesStore.LookupEntry(tmp.Emote.EmoteID))
+{
+sLog.outErrorDb("Table `%s` has invalid emote id (datalong = %u) in SCRIPT_COMMAND_EMOTE for script id %u",
+tableName.c_str(), tmp.Emote.EmoteID, tmp.id);
+continue;
+}
+break;
+}
+
+case SCRIPT_COMMAND_TELEPORT_TO:
+{
+if (!sMapStore.LookupEntry(tmp.TeleportTo.MapID))
+{
+sLog.outErrorDb("Table `%s` has invalid map (Id: %u) in SCRIPT_COMMAND_TELEPORT_TO for script id %u",
+tableName.c_str(), tmp.TeleportTo.MapID, tmp.id);
+continue;
+}
+
+if (!Trinity::IsValidMapCoord(tmp.TeleportTo.DestX, tmp.TeleportTo.DestY, tmp.TeleportTo.DestZ, tmp.TeleportTo.Orientation))
+{
+sLog.outErrorDb("Table `%s` has invalid coordinates (X: %f Y: %f Z: %f O: %f) in SCRIPT_COMMAND_TELEPORT_TO for script id %u",
+tableName.c_str(), tmp.TeleportTo.DestX, tmp.TeleportTo.DestY, tmp.TeleportTo.DestZ, tmp.TeleportTo.Orientation, tmp.id);
+continue;
+}
+break;
+}
+
+case SCRIPT_COMMAND_QUEST_EXPLORED:
+{
+Quest const* quest = GetQuestTemplate(tmp.QuestExplored.QuestID);
+if (!quest)
+{
+sLog.outErrorDb("Table `%s` has invalid quest (ID: %u) in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u",
+tableName.c_str(), tmp.QuestExplored.QuestID, tmp.id);
+continue;
+}
+
+if (!quest->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
+{
+sLog.outErrorDb("Table `%s` has quest (ID: %u) in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u, but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT in quest flags. Script command or quest flags wrong. Quest modified to require objective.",
+tableName.c_str(), tmp.QuestExplored.QuestID, tmp.id);
+
+// this will prevent quest completing without objective
+const_cast<Quest*>(quest)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
+
+// continue; - quest objective requirement set and command can be allowed
+}
+
+if (float(tmp.QuestExplored.Distance) > DEFAULT_VISIBILITY_DISTANCE)
+{
+sLog.outErrorDb("Table `%s` has too large distance (%u) for exploring objective complete in `datalong2` in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u",
+tableName.c_str(), tmp.QuestExplored.Distance, tmp.id);
+continue;
+}
+
+if (tmp.QuestExplored.Distance && float(tmp.QuestExplored.Distance) > DEFAULT_VISIBILITY_DISTANCE)
+{
+sLog.outErrorDb("Table `%s` has too large distance (%u) for exploring objective complete in `datalong2` in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u, max distance is %f or 0 for disable distance check",
+tableName.c_str(), tmp.QuestExplored.Distance, tmp.id, DEFAULT_VISIBILITY_DISTANCE);
+continue;
+}
+
+if (tmp.QuestExplored.Distance && float(tmp.QuestExplored.Distance) < INTERACTION_DISTANCE)
+{
+sLog.outErrorDb("Table `%s` has too small distance (%u) for exploring objective complete in `datalong2` in SCRIPT_COMMAND_QUEST_EXPLORED in `datalong` for script id %u, min distance is %f or 0 for disable distance check",
+tableName.c_str(), tmp.QuestExplored.Distance, tmp.id, INTERACTION_DISTANCE);
+continue;
+}
+
+break;
+}
+
+case SCRIPT_COMMAND_KILL_CREDIT:
+{
+if (!GetCreatureTemplate(tmp.KillCredit.CreatureEntry))
+{
+sLog.outErrorDb("Table `%s` has invalid creature (Entry: %u) in SCRIPT_COMMAND_KILL_CREDIT for script id %u",
+tableName.c_str(), tmp.KillCredit.CreatureEntry, tmp.id);
+continue;
+}
+break;
+}
+
+case SCRIPT_COMMAND_RESPAWN_GAMEOBJECT:
+{
+GameObjectData const* data = GetGOData(tmp.RespawnGameobject.GOGuid);
+if (!data)
+{
+sLog.outErrorDb("Table `%s` has invalid gameobject (GUID: %u) in SCRIPT_COMMAND_RESPAWN_GAMEOBJECT for script id %u",
+tableName.c_str(), tmp.RespawnGameobject.GOGuid, tmp.id);
+continue;
+}
+
+GameObjectInfo const* info = GetGameObjectInfo(data->id);
+if (!info)
+{
+sLog.outErrorDb("Table `%s` has gameobject with invalid entry (GUID: %u Entry: %u) in SCRIPT_COMMAND_RESPAWN_GAMEOBJECT for script id %u",
+tableName.c_str(), tmp.RespawnGameobject.GOGuid, data->id, tmp.id);
+continue;
+}
+
+if (info->type == GAMEOBJECT_TYPE_FISHINGNODE ||
+info->type == GAMEOBJECT_TYPE_FISHINGHOLE ||
+info->type == GAMEOBJECT_TYPE_DOOR ||
+info->type == GAMEOBJECT_TYPE_BUTTON ||
+info->type == GAMEOBJECT_TYPE_TRAP)
+{
+sLog.outErrorDb("Table `%s` have gameobject type (%u) unsupported by command SCRIPT_COMMAND_RESPAWN_GAMEOBJECT for script id %u",
+tableName.c_str(), info->id, tmp.id);
+continue;
+}
+break;
+}
+
+case SCRIPT_COMMAND_TEMP_SUMMON_CREATURE:
+{
+if (!Trinity::IsValidMapCoord(tmp.TempSummonCreature.PosX, tmp.TempSummonCreature.PosY, tmp.TempSummonCreature.PosZ, tmp.TempSummonCreature.Orientation))
+{
+sLog.outErrorDb("Table `%s` has invalid coordinates (X: %f Y: %f Z: %f O: %f) in SCRIPT_COMMAND_TEMP_SUMMON_CREATURE for script id %u",
+tableName.c_str(), tmp.TempSummonCreature.PosX, tmp.TempSummonCreature.PosY, tmp.TempSummonCreature.PosZ, tmp.TempSummonCreature.Orientation, tmp.id);
+continue;
+}
+
+if (!GetCreatureTemplate(tmp.TempSummonCreature.CreatureEntry))
+{
+sLog.outErrorDb("Table `%s` has invalid creature (Entry: %u) in SCRIPT_COMMAND_TEMP_SUMMON_CREATURE for script id %u",
+tableName.c_str(), tmp.TempSummonCreature.CreatureEntry, tmp.id);
+continue;
+}
+break;
+}
+
+case SCRIPT_COMMAND_OPEN_DOOR:
+case SCRIPT_COMMAND_CLOSE_DOOR:
+{
+GameObjectData const* data = GetGOData(tmp.ToggleDoor.GOGuid);
+if (!data)
+{
+sLog.outErrorDb("Table `%s` has invalid gameobject (GUID: %u) in %s for script id %u",
+tableName.c_str(), tmp.ToggleDoor.GOGuid, GetScriptCommandName(tmp.command).c_str(), tmp.id);
+continue;
+}
+
+GameObjectInfo const* info = GetGameObjectInfo(data->id);
+if (!info)
+{
+sLog.outErrorDb("Table `%s` has gameobject with invalid entry (GUID: %u Entry: %u) in %s for script id %u",
+tableName.c_str(), tmp.ToggleDoor.GOGuid, data->id, GetScriptCommandName(tmp.command).c_str(), tmp.id);
+continue;
+}
+
+if (info->type != GAMEOBJECT_TYPE_DOOR)
+{
+sLog.outErrorDb("Table `%s` has gameobject type (%u) non supported by command %s for script id %u",
+tableName.c_str(), info->id, GetScriptCommandName(tmp.command).c_str(), tmp.id);
+continue;
+}
+
+break;
+}
+
+case SCRIPT_COMMAND_REMOVE_AURA:
+{
+if (!sSpellStore.LookupEntry(tmp.RemoveAura.SpellID))
+{
+sLog.outErrorDb("Table `%s` using non-existent spell (id: %u) in SCRIPT_COMMAND_REMOVE_AURA for script id %u",
+tableName.c_str(), tmp.RemoveAura.SpellID, tmp.id);
+continue;
+}
+if (tmp.RemoveAura.Flags & ~0x1) // 1 bits (0,1)
+{
+sLog.outErrorDb("Table `%s` using unknown flags in datalong2 (%u) in SCRIPT_COMMAND_REMOVE_AURA for script id %u",
+tableName.c_str(), tmp.RemoveAura.Flags, tmp.id);
+continue;
+}
+break;
+}
+
+case SCRIPT_COMMAND_CAST_SPELL:
+{
+if (!sSpellStore.LookupEntry(tmp.CastSpell.SpellID))
+{
+sLog.outErrorDb("Table `%s` using non-existent spell (id: %u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
+tableName.c_str(), tmp.CastSpell.SpellID, tmp.id);
+continue;
+}
+if (tmp.CastSpell.Flags > 4) // targeting type
+{
+sLog.outErrorDb("Table `%s` using unknown target in datalong2 (%u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
+tableName.c_str(), tmp.CastSpell.Flags, tmp.id);
+continue;
+}
+if (tmp.CastSpell.Flags != 4 && tmp.CastSpell.CreatureEntry & ~0x1) // 1 bit (0,1)
+{
+sLog.outErrorDb("Table `%s` using unknown flags in dataint (%u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
+tableName.c_str(), tmp.CastSpell.CreatureEntry, tmp.id);
+continue;
+}
+else if (tmp.CastSpell.Flags == 4 && !GetCreatureTemplate(tmp.CastSpell.CreatureEntry))
+{
+sLog.outErrorDb("Table `%s` using invalid creature entry in dataint (%u) in SCRIPT_COMMAND_CAST_SPELL for script id %u",
+tableName.c_str(), tmp.CastSpell.CreatureEntry, tmp.id);
+continue;
+}
+break;
+}
+
+case SCRIPT_COMMAND_CREATE_ITEM:
+{
+if (!GetItemPrototype(tmp.CreateItem.ItemEntry))
+{
+sLog.outErrorDb("Table `%s` has nonexistent item (entry: %u) in SCRIPT_COMMAND_CREATE_ITEM for script id %u",
+tableName.c_str(), tmp.CreateItem.ItemEntry, tmp.id);
+continue;
+}
+if (!tmp.CreateItem.Amount)
+{
+sLog.outErrorDb("Table `%s` SCRIPT_COMMAND_CREATE_ITEM but amount is %u for script id %u",
+tableName.c_str(), tmp.CreateItem.Amount, tmp.id);
+continue;
+}
+break;
+}
+default:
+break;
+}
+
+if (scripts->find(tmp.id) == scripts->end())
+{
+ScriptMap emptyMap;
+(*scripts)[tmp.id] = emptyMap;
+}
+(*scripts)[tmp.id].insert(std::pair<uint32, ScriptInfo>(tmp.delay, tmp));
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u script definitions", count);
+}
+
+void ObjectMgr::LoadGameObjectScripts()
+{
+LoadScripts(SCRIPTS_GAMEOBJECT);
+
+// check ids
+for (ScriptMapMap::const_iterator itr = sGameObjectScripts.begin(); itr != sGameObjectScripts.end(); ++itr)
+{
+if (!GetGOData(itr->first))
+sLog.outErrorDb("Table `gameobject_scripts` has not existing gameobject (GUID: %u) as script id",itr->first);
+}
+}
+
+void ObjectMgr::LoadQuestEndScripts()
+{
+LoadScripts(SCRIPTS_QUEST_END);
+
+// check ids
+for (ScriptMapMap::const_iterator itr = sQuestEndScripts.begin(); itr != sQuestEndScripts.end(); ++itr)
+{
+if (!GetQuestTemplate(itr->first))
+sLog.outErrorDb("Table `quest_end_scripts` has not existing quest (Id: %u) as script id",itr->first);
+}
+}
+
+void ObjectMgr::LoadQuestStartScripts()
+{
+LoadScripts(SCRIPTS_QUEST_START);
+
+// check ids
+for (ScriptMapMap::const_iterator itr = sQuestStartScripts.begin(); itr != sQuestStartScripts.end(); ++itr)
+{
+if (!GetQuestTemplate(itr->first))
+sLog.outErrorDb("Table `quest_start_scripts` has not existing quest (Id: %u) as script id",itr->first);
+}
+}
+
+void ObjectMgr::LoadSpellScripts()
+{
+LoadScripts(SCRIPTS_SPELL);
+
+// check ids
+for (ScriptMapMap::const_iterator itr = sSpellScripts.begin(); itr != sSpellScripts.end(); ++itr)
+{
+uint32 spellId = uint32(itr->first) & 0x00FFFFFF;
+SpellEntry const* spellInfo = sSpellStore.LookupEntry(spellId);
+
+if (!spellInfo)
+{
+sLog.outErrorDb("Table `spell_scripts` has not existing spell (Id: %u) as script id", spellId);
+continue;
+}
+
+uint8 i = (uint8)((uint32(itr->first) >> 24) & 0x000000FF);
+//check for correct spellEffect
+if (!spellInfo->Effect[i] || (spellInfo->Effect[i] != SPELL_EFFECT_SCRIPT_EFFECT && spellInfo->Effect[i] != SPELL_EFFECT_DUMMY))
+sLog.outErrorDb("Table `spell_scripts` - spell %u effect %u is not SPELL_EFFECT_SCRIPT_EFFECT or SPELL_EFFECT_DUMMY", spellId, i);
+}
+}
+
+void ObjectMgr::LoadEventScripts()
+{
+LoadScripts(SCRIPTS_EVENT);
+
+std::set<uint32> evt_scripts;
+// Load all possible script entries from gameobjects
+for (uint32 i = 1; i < sGOStorage.MaxEntry; ++i)
+{
+if (GameObjectInfo const * goInfo = sGOStorage.LookupEntry<GameObjectInfo>(i))
+if (uint32 eventId = goInfo->GetEventScriptId())
+evt_scripts.insert(eventId);
+}
+// Load all possible script entries from spells
+for (uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
+{
+SpellEntry const * spell = sSpellStore.LookupEntry(i);
+if (spell)
+{
+for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+{
+if (spell->Effect[j] == SPELL_EFFECT_SEND_EVENT)
+{
+if (spell->EffectMiscValue[j])
+evt_scripts.insert(spell->EffectMiscValue[j]);
+}
+}
+}
+}
+
+for(size_t path_idx = 0; path_idx < sTaxiPathNodesByPath.size(); ++path_idx)
+{
+for(size_t node_idx = 0; node_idx < sTaxiPathNodesByPath[path_idx].size(); ++node_idx)
+{
+TaxiPathNodeEntry const& node = sTaxiPathNodesByPath[path_idx][node_idx];
+
+if (node.arrivalEventID)
+evt_scripts.insert(node.arrivalEventID);
+
+if (node.departureEventID)
+evt_scripts.insert(node.departureEventID);
+}
+}
+
+// Then check if all scripts are in above list of possible script entries
+for (ScriptMapMap::const_iterator itr = sEventScripts.begin(); itr != sEventScripts.end(); ++itr)
+{
+std::set<uint32>::const_iterator itr2 = evt_scripts.find(itr->first);
+if (itr2 == evt_scripts.end())
+sLog.outErrorDb("Table `event_scripts` has script (Id: %u) not referring to any gameobject_template type 10 data2 field, type 3 data6 field, type 13 data 2 field or any spell effect %u",
+itr->first, SPELL_EFFECT_SEND_EVENT);
+}
+}
+
+//Load WP Scripts
+void ObjectMgr::LoadWaypointScripts()
+{
+LoadScripts(SCRIPTS_WAYPOINT);
+
+std::set<uint32> actionSet;
+
+for (ScriptMapMap::const_iterator itr = sWaypointScripts.begin(); itr != sWaypointScripts.end(); ++itr)
+actionSet.insert(itr->first);
+
+QueryResult result = WorldDatabase.PQuery("SELECT DISTINCT(`action`) FROM waypoint_data");
+if (result)
+{
+do
+{
+Field *fields = result->Fetch();
+uint32 action = fields[0].GetUInt32();
+
+actionSet.erase(action);
+
+} while (result->NextRow());
+}
+
+for (std::set<uint32>::iterator itr = actionSet.begin(); itr != actionSet.end(); ++itr)
+sLog.outErrorDb("There is no waypoint which links to the waypoint script %u", *itr);
+}
+
+void ObjectMgr::LoadSpellScriptNames()
+{
+mSpellScripts.clear(); // need for reload case
+QueryResult result = WorldDatabase.Query("SELECT spell_id, ScriptName FROM spell_script_names");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u spell script names", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+++count;
+bar.step();
+
+Field *fields = result->Fetch();
+
+int32 spellId = fields[0].GetInt32();
+const char *scriptName = fields[1].GetCString();
+
+bool allRanks = false;
+if (spellId <=0)
+{
+allRanks = true;
+spellId = -spellId;
+}
+
+SpellEntry const* spellEntry = sSpellStore.LookupEntry(spellId);
+if (!spellEntry)
+{
+sLog.outErrorDb("Scriptname:`%s` spell (spell_id:%d) does not exist in `Spell.dbc`.",scriptName,fields[0].GetInt32());
+continue;
+}
+
+if (allRanks)
+{
+if (sSpellMgr.GetFirstSpellInChain(spellId) != uint32(spellId))
+{
+sLog.outErrorDb("Scriptname:`%s` spell (spell_id:%d) is not first rank of spell.",scriptName,fields[0].GetInt32());
+continue;
+}
+while(spellId)
+{
+mSpellScripts.insert(SpellScriptsMap::value_type(spellId, GetScriptId(scriptName)));
+spellId = sSpellMgr.GetNextSpellInChain(spellId);
+}
+}
+else
+mSpellScripts.insert(SpellScriptsMap::value_type(spellId, GetScriptId(scriptName)));
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u spell script names", count);
+}
+
+void ObjectMgr::ValidateSpellScripts()
+{
+if (mSpellScripts.empty())
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Validation done");
+return;
+}
+
+barGoLink bar(mSpellScripts.size());
+for (SpellScriptsMap::iterator itr = mSpellScripts.begin(); itr != mSpellScripts.end();)
+{
+SpellEntry const * spellEntry = sSpellStore.LookupEntry(itr->first);
+std::vector<std::pair<SpellScriptLoader *, SpellScriptsMap::iterator> > SpellScriptLoaders;
+sScriptMgr.CreateSpellScriptLoaders(itr->first, SpellScriptLoaders);
+itr = mSpellScripts.upper_bound(itr->first);
+
+for (std::vector<std::pair<SpellScriptLoader *, SpellScriptsMap::iterator> >::iterator sitr = SpellScriptLoaders.begin(); sitr != SpellScriptLoaders.end(); ++sitr)
+{
+bar.step();
+SpellScript * spellScript = sitr->first->GetSpellScript();
+AuraScript * auraScript = sitr->first->GetAuraScript();
+bool valid = true;
+if (!spellScript && !auraScript)
+{
+sLog.outError("TSCR: Functions GetSpellScript() and GetAuraScript() of script `%s` do not return objects - script skipped", GetScriptName(sitr->second->second));
+valid = false;
+}
+if (spellScript)
+{
+spellScript->_Init(&sitr->first->GetName(), spellEntry->Id);
+spellScript->_Register();
+if (!spellScript->_Validate(spellEntry))
+valid = false;
+delete spellScript;
+}
+if (auraScript)
+{
+auraScript->_Init(&sitr->first->GetName(), spellEntry->Id);
+auraScript->_Register();
+if (!auraScript->_Validate(spellEntry))
+valid = false;
+delete auraScript;
+}
+if (!valid)
+mSpellScripts.erase(sitr->second);
+}
+}
+
+sLog.outString();
+sLog.outString(">> Validation done");
+}
+
+void ObjectMgr::LoadGossipScripts()
+{
+LoadScripts(SCRIPTS_GOSSIP);
+
+// checks are done in LoadGossipMenuItems
+}
+
+void ObjectMgr::LoadPageTexts()
+{
+sPageTextStore.Free(); // for reload case
+
+sPageTextStore.Load();
+sLog.outString(">> Loaded %u page texts", sPageTextStore.RecordCount);
+sLog.outString();
+
+for (uint32 i = 1; i < sPageTextStore.MaxEntry; ++i)
+{
+// check data correctness
+PageText const* page = sPageTextStore.LookupEntry<PageText>(i);
+if (!page)
+continue;
+
+if (page->Next_Page && !sPageTextStore.LookupEntry<PageText>(page->Next_Page))
+{
+sLog.outErrorDb("Page text (Id: %u) has not existing next page (Id:%u)", i,page->Next_Page);
+continue;
+}
+
+// detect circular reference
+std::set<uint32> checkedPages;
+for (PageText const* pageItr = page; pageItr; pageItr = sPageTextStore.LookupEntry<PageText>(pageItr->Next_Page))
+{
+if (!pageItr->Next_Page)
+break;
+checkedPages.insert(pageItr->Page_ID);
+if (checkedPages.find(pageItr->Next_Page)!= checkedPages.end())
+{
+std::ostringstream ss;
+ss << "The text page(s) ";
+for (std::set<uint32>::iterator itr= checkedPages.begin(); itr != checkedPages.end(); ++itr)
+ss << *itr << " ";
+ss << "create(s) a circular reference, which can cause the server to freeze. Changing Next_Page of page "
+<< pageItr->Page_ID <<" to 0";
+sLog.outErrorDb("%s", ss.str().c_str());
+const_cast<PageText*>(pageItr)->Next_Page = 0;
+break;
+}
+}
+}
+}
+
+void ObjectMgr::LoadPageTextLocales()
+{
+mPageTextLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT entry,text_loc1,text_loc2,text_loc3,text_loc4,text_loc5,text_loc6,text_loc7,text_loc8 FROM locales_page_text");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+PageTextLocale& data = mPageTextLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+std::string str = fields[i].GetString();
+AddLocaleString(str, LocaleConstant(i), data.Text);
+}
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu PageText locale strings", (unsigned long)mPageTextLocaleMap.size());
+}
+
+struct SQLInstanceLoader : public SQLStorageLoaderBase<SQLInstanceLoader>
+{
+template<class D>
+void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
+{
+dst = D(sObjectMgr.GetScriptId(src));
+}
+};
+
+void ObjectMgr::LoadInstanceTemplate()
+{
+SQLInstanceLoader loader;
+loader.Load(sInstanceTemplate);
+
+for (uint32 i = 0; i < sInstanceTemplate.MaxEntry; i++)
+{
+InstanceTemplate* temp = const_cast<InstanceTemplate*>(GetInstanceTemplate(i));
+if (!temp)
+continue;
+
+if (!MapManager::IsValidMAP(temp->map))
+sLog.outErrorDb("ObjectMgr::LoadInstanceTemplate: bad mapid %d for template!", temp->map);
+
+if (!MapManager::IsValidMapCoord(temp->parent,temp->startLocX,temp->startLocY,temp->startLocZ,temp->startLocO))
+{
+sLog.outErrorDb("ObjectMgr::LoadInstanceTemplate: bad parent entrance coordinates for map id %d template!", temp->map);
+temp->parent = 0; // will have wrong continent 0 parent, at least existed
+}
+}
+
+sLog.outString(">> Loaded %u Instance Template definitions", sInstanceTemplate.RecordCount);
+sLog.outString();
+}
+
+GossipText const *ObjectMgr::GetGossipText(uint32 Text_ID) const
+{
+GossipTextMap::const_iterator itr = mGossipText.find(Text_ID);
+if (itr != mGossipText.end())
+return &itr->second;
+return NULL;
+}
+
+void ObjectMgr::LoadGossipText()
+{
+QueryResult result = WorldDatabase.Query("SELECT * FROM npc_text");
+
+int count = 0;
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u npc texts", count);
+return;
+}
+
+int cic;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+++count;
+cic = 0;
+
+Field *fields = result->Fetch();
+
+bar.step();
+
+uint32 Text_ID = fields[cic++].GetUInt32();
+if (!Text_ID)
+{
+sLog.outErrorDb("Table `npc_text` has record wit reserved id 0, ignore.");
+continue;
+}
+
+GossipText& gText = mGossipText[Text_ID];
+
+for (int i = 0; i < MAX_GOSSIP_TEXT_OPTIONS; i++)
+{
+gText.Options[i].Text_0 = fields[cic++].GetString();
+gText.Options[i].Text_1 = fields[cic++].GetString();
+
+gText.Options[i].Language = fields[cic++].GetUInt32();
+gText.Options[i].Probability = fields[cic++].GetFloat();
+
+for (uint8 j=0; j < MAX_GOSSIP_TEXT_EMOTES; ++j)
+{
+gText.Options[i].Emotes[j]._Delay = fields[cic++].GetUInt32();
+gText.Options[i].Emotes[j]._Emote = fields[cic++].GetUInt32();
+}
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u npc texts", count);
+}
+
+void ObjectMgr::LoadNpcTextLocales()
+{
+mNpcTextLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT entry,"
+"Text0_0_loc1,Text0_1_loc1,Text1_0_loc1,Text1_1_loc1,Text2_0_loc1,Text2_1_loc1,Text3_0_loc1,Text3_1_loc1,Text4_0_loc1,Text4_1_loc1,Text5_0_loc1,Text5_1_loc1,Text6_0_loc1,Text6_1_loc1,Text7_0_loc1,Text7_1_loc1,"
+"Text0_0_loc2,Text0_1_loc2,Text1_0_loc2,Text1_1_loc2,Text2_0_loc2,Text2_1_loc2,Text3_0_loc2,Text3_1_loc1,Text4_0_loc2,Text4_1_loc2,Text5_0_loc2,Text5_1_loc2,Text6_0_loc2,Text6_1_loc2,Text7_0_loc2,Text7_1_loc2,"
+"Text0_0_loc3,Text0_1_loc3,Text1_0_loc3,Text1_1_loc3,Text2_0_loc3,Text2_1_loc3,Text3_0_loc3,Text3_1_loc1,Text4_0_loc3,Text4_1_loc3,Text5_0_loc3,Text5_1_loc3,Text6_0_loc3,Text6_1_loc3,Text7_0_loc3,Text7_1_loc3,"
+"Text0_0_loc4,Text0_1_loc4,Text1_0_loc4,Text1_1_loc4,Text2_0_loc4,Text2_1_loc4,Text3_0_loc4,Text3_1_loc1,Text4_0_loc4,Text4_1_loc4,Text5_0_loc4,Text5_1_loc4,Text6_0_loc4,Text6_1_loc4,Text7_0_loc4,Text7_1_loc4,"
+"Text0_0_loc5,Text0_1_loc5,Text1_0_loc5,Text1_1_loc5,Text2_0_loc5,Text2_1_loc5,Text3_0_loc5,Text3_1_loc1,Text4_0_loc5,Text4_1_loc5,Text5_0_loc5,Text5_1_loc5,Text6_0_loc5,Text6_1_loc5,Text7_0_loc5,Text7_1_loc5,"
+"Text0_0_loc6,Text0_1_loc6,Text1_0_loc6,Text1_1_loc6,Text2_0_loc6,Text2_1_loc6,Text3_0_loc6,Text3_1_loc1,Text4_0_loc6,Text4_1_loc6,Text5_0_loc6,Text5_1_loc6,Text6_0_loc6,Text6_1_loc6,Text7_0_loc6,Text7_1_loc6,"
+"Text0_0_loc7,Text0_1_loc7,Text1_0_loc7,Text1_1_loc7,Text2_0_loc7,Text2_1_loc7,Text3_0_loc7,Text3_1_loc1,Text4_0_loc7,Text4_1_loc7,Text5_0_loc7,Text5_1_loc7,Text6_0_loc7,Text6_1_loc7,Text7_0_loc7,Text7_1_loc7, "
+"Text0_0_loc8,Text0_1_loc8,Text1_0_loc8,Text1_1_loc8,Text2_0_loc8,Text2_1_loc8,Text3_0_loc8,Text3_1_loc1,Text4_0_loc8,Text4_1_loc8,Text5_0_loc8,Text5_1_loc8,Text6_0_loc8,Text6_1_loc8,Text7_0_loc8,Text7_1_loc8 "
+" FROM locales_npc_text");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+NpcTextLocale& data = mNpcTextLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+LocaleConstant locale = (LocaleConstant) i;
+for (uint8 j = 0; j < MAX_LOCALES; ++j)
+{
+std::string str0 = fields[1 + 8 * 2 * (i - 1) + 2 * j].GetString();
+AddLocaleString(str0, locale, data.Text_0[j]);
+
+std::string str1 = fields[1 + 8 * 2 * (i - 1) + 2 * j + 1].GetString();
+AddLocaleString(str1, locale, data.Text_1[j]);
+}
+}
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu NpcText locale strings", (unsigned long)mNpcTextLocaleMap.size());
+}
+
+//not very fast function but it is called only once a day, or on starting-up
+void ObjectMgr::ReturnOrDeleteOldMails(bool serverUp)
+{
+time_t basetime = time(NULL);
+sLog.outDebug("Returning mails current time: hour: %d, minute: %d, second: %d ", localtime(&basetime)->tm_hour, localtime(&basetime)->tm_min, localtime(&basetime)->tm_sec);
+//delete all old mails without item and without body immediately, if starting server
+if (!serverUp)
+CharacterDatabase.PExecute("DELETE FROM mail WHERE expire_time < '" UI64FMTD "' AND has_items = '0' AND body = ''", (uint64)basetime);
+// 0 1 2 3 4 5 6 7 8 9
+QueryResult result = CharacterDatabase.PQuery("SELECT id,messageType,sender,receiver,has_items,expire_time,cod,checked,mailTemplateId FROM mail WHERE expire_time < '" UI64FMTD "'", (uint64)basetime);
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outString(">> Only expired mails (need to be return or delete) or DB table `mail` is empty.");
+return; // any mails need to be returned or deleted
+}
+
+barGoLink bar(result->GetRowCount());
+uint32 count = 0;
+Field *fields;
+
+do
+{
+bar.step();
+
+fields = result->Fetch();
+Mail *m = new Mail;
+m->messageID = fields[0].GetUInt32();
+m->messageType = fields[1].GetUInt8();
+m->sender = fields[2].GetUInt32();
+m->receiver = fields[3].GetUInt32();
+bool has_items = fields[4].GetBool();
+m->expire_time = (time_t)fields[5].GetUInt64();
+m->deliver_time = 0;
+m->COD = fields[6].GetUInt32();
+m->checked = fields[7].GetUInt32();
+m->mailTemplateId = fields[8].GetInt16();
+
+Player *pl = NULL;
+if (serverUp)
+pl = GetPlayer((uint64)m->receiver);
+
+if (pl && pl->m_mailsLoaded)
+{ //this code will run very improbably (the time is between 4 and 5 am, in game is online a player, who has old mail
+//his in mailbox and he has already listed his mails)
+delete m;
+continue;
+}
+
+//delete or return mail:
+if (has_items)
+{
+QueryResult resultItems = CharacterDatabase.PQuery("SELECT item_guid,item_template FROM mail_items WHERE mail_id='%u'", m->messageID);
+if (resultItems)
+{
+do
+{
+Field *fields2 = resultItems->Fetch();
+
+uint32 item_guid_low = fields2[0].GetUInt32();
+uint32 item_template = fields2[1].GetUInt32();
+
+m->AddItem(item_guid_low, item_template);
+}
+while (resultItems->NextRow());
+}
+//if it is mail from AH, it shouldn't be returned, but deleted
+if (m->messageType != MAIL_NORMAL || m->messageType == MAIL_AUCTION || (m->checked & (MAIL_CHECK_MASK_COD_PAYMENT | MAIL_CHECK_MASK_RETURNED)))
+{
+// mail open and then not returned
+for (std::vector<MailItemInfo>::iterator itr2 = m->items.begin(); itr2 != m->items.end(); ++itr2)
+{
+PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
+stmt->setUInt32(0, itr2->item_guid);
+CharacterDatabase.Execute(stmt);
+}
+}
+else
+{
+//mail will be returned:
+CharacterDatabase.PExecute("UPDATE mail SET sender = '%u', receiver = '%u', expire_time = '" UI64FMTD "', deliver_time = '" UI64FMTD "',cod = '0', checked = '%u' WHERE id = '%u'", m->receiver, m->sender, (uint64)(basetime + 30*DAY), (uint64)basetime, MAIL_CHECK_MASK_RETURNED, m->messageID);
+delete m;
+continue;
+}
+}
+
+CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", m->messageID);
+delete m;
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u mails", count);
+}
+
+void ObjectMgr::LoadQuestAreaTriggers()
+{
+mQuestAreaTriggerMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT id,quest FROM areatrigger_involvedrelation");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u quest trigger points", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+++count;
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 trigger_ID = fields[0].GetUInt32();
+uint32 quest_ID = fields[1].GetUInt32();
+
+AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(trigger_ID);
+if (!atEntry)
+{
+sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",trigger_ID);
+continue;
+}
+
+Quest const* quest = GetQuestTemplate(quest_ID);
+
+if (!quest)
+{
+sLog.outErrorDb("Table `areatrigger_involvedrelation` has record (id: %u) for not existing quest %u",trigger_ID,quest_ID);
+continue;
+}
+
+if (!quest->HasFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT))
+{
+sLog.outErrorDb("Table `areatrigger_involvedrelation` has record (id: %u) for not quest %u, but quest not have flag QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT. Trigger or quest flags must be fixed, quest modified to require objective.",trigger_ID,quest_ID);
+
+// this will prevent quest completing without objective
+const_cast<Quest*>(quest)->SetFlag(QUEST_TRINITY_FLAGS_EXPLORATION_OR_EVENT);
+
+// continue; - quest modified to required objective and trigger can be allowed.
+}
+
+mQuestAreaTriggerMap[trigger_ID] = quest_ID;
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u quest trigger points", count);
+}
+
+void ObjectMgr::LoadTavernAreaTriggers()
+{
+mTavernAreaTriggerSet.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT id FROM areatrigger_tavern");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u tavern triggers", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+++count;
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 Trigger_ID = fields[0].GetUInt32();
+
+AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
+if (!atEntry)
+{
+sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",Trigger_ID);
+continue;
+}
+
+mTavernAreaTriggerSet.insert(Trigger_ID);
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u tavern triggers", count);
+}
+
+void ObjectMgr::LoadAreaTriggerScripts()
+{
+mAreaTriggerScripts.clear(); // need for reload case
+QueryResult result = WorldDatabase.Query("SELECT entry, ScriptName FROM areatrigger_scripts");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u areatrigger scripts", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+++count;
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 Trigger_ID = fields[0].GetUInt32();
+const char *scriptName = fields[1].GetCString();
+
+AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
+if (!atEntry)
+{
+sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",Trigger_ID);
+continue;
+}
+mAreaTriggerScripts[Trigger_ID] = GetScriptId(scriptName);
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u areatrigger scripts", count);
+}
+
+uint32 ObjectMgr::GetNearestTaxiNode(float x, float y, float z, uint32 mapid, uint32 team)
+{
+bool found = false;
+float dist = 10000;
+uint32 id = 0;
+
+for (uint32 i = 1; i < sTaxiNodesStore.GetNumRows(); ++i)
+{
+TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(i);
+
+if (!node || node->map_id != mapid || (!node->MountCreatureID[team == ALLIANCE ? 1 : 0] && node->MountCreatureID[0] != 32981)) // dk flight
+continue;
+
+uint8 field = (uint8)((i - 1) / 32);
+uint32 submask = 1<<((i-1)%32);
+
+// skip not taxi network nodes
+if ((sTaxiNodesMask[field] & submask) == 0)
+continue;
+
+float dist2 = (node->x - x)*(node->x - x)+(node->y - y)*(node->y - y)+(node->z - z)*(node->z - z);
+if (found)
+{
+if (dist2 < dist)
+{
+dist = dist2;
+id = i;
+}
+}
+else
+{
+found = true;
+dist = dist2;
+id = i;
+}
+}
+
+return id;
+}
+
+void ObjectMgr::GetTaxiPath(uint32 source, uint32 destination, uint32 &path, uint32 &cost)
+{
+TaxiPathSetBySource::iterator src_i = sTaxiPathSetBySource.find(source);
+if (src_i == sTaxiPathSetBySource.end())
+{
+path = 0;
+cost = 0;
+return;
+}
+
+TaxiPathSetForSource& pathSet = src_i->second;
+
+TaxiPathSetForSource::iterator dest_i = pathSet.find(destination);
+if (dest_i == pathSet.end())
+{
+path = 0;
+cost = 0;
+return;
+}
+
+cost = dest_i->second.price;
+path = dest_i->second.ID;
+}
+
+uint32 ObjectMgr::GetTaxiMountDisplayId(uint32 id, uint32 team, bool allowed_alt_team /* = false */)
+{
+uint32 mount_entry = 0;
+uint32 mount_id = 0;
+
+// select mount creature id
+TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(id);
+if (node)
+{
+if (team == ALLIANCE)
+mount_entry = node->MountCreatureID[1];
+else
+mount_entry = node->MountCreatureID[0];
+
+// Fix for Alliance not being able to use Acherus taxi
+// only one mount type for both sides
+if (mount_entry == 0 && allowed_alt_team)
+{
+// Simply reverse the selection. At least one team in theory should have a valid mount ID to choose.
+mount_entry = team == ALLIANCE ? node->MountCreatureID[0] : node->MountCreatureID[1];
+}
+
+CreatureInfo const *mount_info = GetCreatureTemplate(mount_entry);
+if (mount_info)
+{
+mount_id = mount_info->GetRandomValidModelId();
+if (!mount_id)
+{
+sLog.outErrorDb("No displayid found for the taxi mount with the entry %u! Can't load it!", mount_entry);
+return false;
+}
+}
+}
+
+CreatureModelInfo const *minfo = sObjectMgr.GetCreatureModelRandomGender(mount_id);
+if (minfo)
+mount_id = minfo->modelid;
+
+return mount_id;
+}
+
+void ObjectMgr::LoadGraveyardZones()
+{
+mGraveYardMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT id,ghost_zone,faction FROM game_graveyard_zone");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u graveyard-zone links", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+++count;
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 safeLocId = fields[0].GetUInt32();
+uint32 zoneId = fields[1].GetUInt32();
+uint32 team = fields[2].GetUInt32();
+
+WorldSafeLocsEntry const* entry = sWorldSafeLocsStore.LookupEntry(safeLocId);
+if (!entry)
+{
+sLog.outErrorDb("Table `game_graveyard_zone` has record for not existing graveyard (WorldSafeLocs.dbc id) %u, skipped.",safeLocId);
+continue;
+}
+
+AreaTableEntry const *areaEntry = GetAreaEntryByAreaID(zoneId);
+if (!areaEntry)
+{
+sLog.outErrorDb("Table `game_graveyard_zone` has record for not existing zone id (%u), skipped.",zoneId);
+continue;
+}
+
+if (areaEntry->zone != 0)
+{
+sLog.outErrorDb("Table `game_graveyard_zone` has record subzone id (%u) instead of zone, skipped.",zoneId);
+continue;
+}
+
+if (team != 0 && team != HORDE && team != ALLIANCE)
+{
+sLog.outErrorDb("Table `game_graveyard_zone` has record for non player faction (%u), skipped.",team);
+continue;
+}
+
+if (!AddGraveYardLink(safeLocId,zoneId,team,false))
+sLog.outErrorDb("Table `game_graveyard_zone` has a duplicate record for Graveyard (ID: %u) and Zone (ID: %u), skipped.",safeLocId,zoneId);
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u graveyard-zone links", count);
+}
+
+WorldSafeLocsEntry const *ObjectMgr::GetClosestGraveYard(float x, float y, float z, uint32 MapId, uint32 team)
+{
+// search for zone associated closest graveyard
+uint32 zoneId = sMapMgr.GetZoneId(MapId,x,y,z);
+
+// Simulate std. algorithm:
+// found some graveyard associated to (ghost_zone,ghost_map)
+//
+// if mapId == graveyard.mapId (ghost in plain zone or city or battleground) and search graveyard at same map
+// then check faction
+// if mapId != graveyard.mapId (ghost in instance) and search any graveyard associated
+// then check faction
+GraveYardMap::const_iterator graveLow = mGraveYardMap.lower_bound(zoneId);
+GraveYardMap::const_iterator graveUp = mGraveYardMap.upper_bound(zoneId);
+MapEntry const* map = sMapStore.LookupEntry(MapId);
+// not need to check validity of map object; MapId _MUST_ be valid here
+
+if (graveLow == graveUp && !map->IsBattleArena())
+{
+//sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
+return NULL;
+}
+
+// at corpse map
+bool foundNear = false;
+float distNear = 10000;
+WorldSafeLocsEntry const* entryNear = NULL;
+
+// at entrance map for corpse map
+bool foundEntr = false;
+float distEntr = 10000;
+WorldSafeLocsEntry const* entryEntr = NULL;
+
+// some where other
+WorldSafeLocsEntry const* entryFar = NULL;
+
+MapEntry const* mapEntry = sMapStore.LookupEntry(MapId);
+
+for (GraveYardMap::const_iterator itr = graveLow; itr != graveUp; ++itr)
+{
+GraveYardData const& data = itr->second;
+
+WorldSafeLocsEntry const* entry = sWorldSafeLocsStore.LookupEntry(data.safeLocId);
+if (!entry)
+{
+sLog.outErrorDb("Table `game_graveyard_zone` has record for not existing graveyard (WorldSafeLocs.dbc id) %u, skipped.",data.safeLocId);
+continue;
+}
+
+// skip enemy faction graveyard
+// team == 0 case can be at call from .neargrave
+if (data.team != 0 && team != 0 && data.team != team)
+continue;
+
+// find now nearest graveyard at other map
+if (MapId != entry->map_id)
+{
+// if find graveyard at different map from where entrance placed (or no entrance data), use any first
+if (!mapEntry ||
+mapEntry->entrance_map < 0 ||
+uint32(mapEntry->entrance_map) != entry->map_id ||
+(mapEntry->entrance_x == 0 && mapEntry->entrance_y == 0))
+{
+// not have any corrdinates for check distance anyway
+entryFar = entry;
+continue;
+}
+
+// at entrance map calculate distance (2D);
+float dist2 = (entry->x - mapEntry->entrance_x)*(entry->x - mapEntry->entrance_x)
++(entry->y - mapEntry->entrance_y)*(entry->y - mapEntry->entrance_y);
+if (foundEntr)
+{
+if (dist2 < distEntr)
+{
+distEntr = dist2;
+entryEntr = entry;
+}
+}
+else
+{
+foundEntr = true;
+distEntr = dist2;
+entryEntr = entry;
+}
+}
+// find now nearest graveyard at same map
+else
+{
+float dist2 = (entry->x - x)*(entry->x - x)+(entry->y - y)*(entry->y - y)+(entry->z - z)*(entry->z - z);
+if (foundNear)
+{
+if (dist2 < distNear)
+{
+distNear = dist2;
+entryNear = entry;
+}
+}
+else
+{
+foundNear = true;
+distNear = dist2;
+entryNear = entry;
+}
+}
+}
+
+if (entryNear)
+return entryNear;
+
+if (entryEntr)
+return entryEntr;
+
+return entryFar;
+}
+
+GraveYardData const* ObjectMgr::FindGraveYardData(uint32 id, uint32 zoneId)
+{
+GraveYardMap::const_iterator graveLow = mGraveYardMap.lower_bound(zoneId);
+GraveYardMap::const_iterator graveUp = mGraveYardMap.upper_bound(zoneId);
+
+for (GraveYardMap::const_iterator itr = graveLow; itr != graveUp; ++itr)
+{
+if (itr->second.safeLocId == id)
+return &itr->second;
+}
+
+return NULL;
+}
+
+bool ObjectMgr::AddGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
+{
+if (FindGraveYardData(id,zoneId))
+return false;
+
+// add link to loaded data
+GraveYardData data;
+data.safeLocId = id;
+data.team = team;
+
+mGraveYardMap.insert(GraveYardMap::value_type(zoneId,data));
+
+// add link to DB
+if (inDB)
+{
+WorldDatabase.PExecute("INSERT INTO game_graveyard_zone (id,ghost_zone,faction) "
+"VALUES ('%u', '%u','%u')",id,zoneId,team);
+}
+
+return true;
+}
+
+void ObjectMgr::RemoveGraveYardLink(uint32 id, uint32 zoneId, uint32 team, bool inDB)
+{
+GraveYardMap::iterator graveLow = mGraveYardMap.lower_bound(zoneId);
+GraveYardMap::iterator graveUp = mGraveYardMap.upper_bound(zoneId);
+if (graveLow == graveUp)
+{
+//sLog.outErrorDb("Table `game_graveyard_zone` incomplete: Zone %u Team %u does not have a linked graveyard.",zoneId,team);
+return;
+}
+
+bool found = false;
+
+GraveYardMap::iterator itr;
+
+for (itr = graveLow; itr != graveUp; ++itr)
+{
+GraveYardData & data = itr->second;
+
+// skip not matching safezone id
+if (data.safeLocId != id)
+continue;
+
+// skip enemy faction graveyard at same map (normal area, city, or battleground)
+// team == 0 case can be at call from .neargrave
+if (data.team != 0 && team != 0 && data.team != team)
+continue;
+
+found = true;
+break;
+}
+
+// no match, return
+if (!found)
+return;
+
+// remove from links
+mGraveYardMap.erase(itr);
+
+// remove link from DB
+if (inDB)
+{
+WorldDatabase.PExecute("DELETE FROM game_graveyard_zone WHERE id = '%u' AND ghost_zone = '%u' AND faction = '%u'",id,zoneId,team);
+}
+
+return;
+}
+
+void ObjectMgr::LoadAreaTriggerTeleports()
+{
+mAreaTriggers.clear(); // need for reload case
+
+uint32 count = 0;
+
+// 0 1 2 3 4 5
+QueryResult result = WorldDatabase.Query("SELECT id, target_map, target_position_x, target_position_y, target_position_z, target_orientation FROM areatrigger_teleport");
+if (!result)
+{
+
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u area trigger teleport definitions", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+
+bar.step();
+
+++count;
+
+uint32 Trigger_ID = fields[0].GetUInt32();
+
+AreaTrigger at;
+
+at.target_mapId = fields[1].GetUInt32();
+at.target_X = fields[2].GetFloat();
+at.target_Y = fields[3].GetFloat();
+at.target_Z = fields[4].GetFloat();
+at.target_Orientation = fields[5].GetFloat();
+
+AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
+if (!atEntry)
+{
+sLog.outErrorDb("Area trigger (ID:%u) does not exist in `AreaTrigger.dbc`.",Trigger_ID);
+continue;
+}
+
+MapEntry const* mapEntry = sMapStore.LookupEntry(at.target_mapId);
+if (!mapEntry)
+{
+sLog.outErrorDb("Area trigger (ID:%u) target map (ID: %u) does not exist in `Map.dbc`.",Trigger_ID,at.target_mapId);
+continue;
+}
+
+if (at.target_X == 0 && at.target_Y == 0 && at.target_Z == 0)
+{
+sLog.outErrorDb("Area trigger (ID:%u) target coordinates not provided.",Trigger_ID);
+continue;
+}
+
+mAreaTriggers[Trigger_ID] = at;
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u area trigger teleport definitions", count);
+}
+
+void ObjectMgr::LoadAccessRequirements()
+{
+mAccessRequirements.clear(); // need for reload case
+
+uint32 count = 0;
+
+// 0 1 2 3 4 5 6 7 8 9
+QueryResult result = WorldDatabase.Query("SELECT mapid, difficulty, level_min, level_max, item, item2, quest_done_A, quest_done_H, completed_achievement, quest_failed_text FROM access_requirement");
+if (!result)
+{
+
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u access requirement definitions", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+
+bar.step();
+
+++count;
+
+uint32 mapid = fields[0].GetUInt32();
+uint8 difficulty = fields[1].GetUInt8();
+uint32 requirement_ID = MAKE_PAIR32(mapid,difficulty);
+
+AccessRequirement ar;
+
+ar.levelMin = fields[2].GetUInt8();
+ar.levelMax = fields[3].GetUInt8();
+ar.item = fields[4].GetUInt32();
+ar.item2 = fields[5].GetUInt32();
+ar.quest_A = fields[6].GetUInt32();
+ar.quest_H = fields[7].GetUInt32();
+ar.achievement = fields[8].GetUInt32();
+ar.questFailedText = fields[9].GetString();
+
+if (ar.item)
+{
+ItemPrototype const *pProto = GetItemPrototype(ar.item);
+if (!pProto)
+{
+sLog.outError("Key item %u does not exist for map %u difficulty %u, removing key requirement.", ar.item, mapid, difficulty);
+ar.item = 0;
+}
+}
+
+if (ar.item2)
+{
+ItemPrototype const *pProto = GetItemPrototype(ar.item2);
+if (!pProto)
+{
+sLog.outError("Second item %u does not exist for map %u difficulty %u, removing key requirement.", ar.item2, mapid, difficulty);
+ar.item2 = 0;
+}
+}
+
+if (ar.quest_A)
+{
+if (!GetQuestTemplate(ar.quest_A))
+{
+sLog.outErrorDb("Required Alliance Quest %u not exist for map %u difficulty %u, remove quest done requirement.", ar.quest_A, mapid, difficulty);
+ar.quest_A = 0;
+}
+}
+
+if (ar.quest_H)
+{
+if (!GetQuestTemplate(ar.quest_H))
+{
+sLog.outErrorDb("Required Horde Quest %u not exist for map %u difficulty %u, remove quest done requirement.", ar.quest_H, mapid, difficulty);
+ar.quest_H = 0;
+}
+}
+
+if (ar.achievement)
+{
+if (!sAchievementStore.LookupEntry(ar.achievement))
+{
+sLog.outErrorDb("Required Achievement %u not exist for map %u difficulty %u, remove quest done requirement.", ar.achievement, mapid, difficulty);
+ar.achievement = 0;
+}
+}
+
+mAccessRequirements[requirement_ID] = ar;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u access requirement definitions", count);
+}
+
+/*
+* Searches for the areatrigger which teleports players out of the given map with instance_template.parent field support
+*/
+AreaTrigger const* ObjectMgr::GetGoBackTrigger(uint32 Map) const
+{
+bool useParentDbValue = false;
+uint32 parentId = 0;
+const MapEntry *mapEntry = sMapStore.LookupEntry(Map);
+if (!mapEntry || mapEntry->entrance_map < 0)
+return NULL;
+
+if (mapEntry->IsDungeon())
+{
+const InstanceTemplate *iTemplate = sObjectMgr.GetInstanceTemplate(Map);
+
+if (!iTemplate)
+return NULL;
+
+parentId = iTemplate->parent;
+useParentDbValue = true;
+}
+
+uint32 entrance_map = uint32(mapEntry->entrance_map);
+for (AreaTriggerMap::const_iterator itr = mAreaTriggers.begin(); itr != mAreaTriggers.end(); ++itr)
+if ((!useParentDbValue && itr->second.target_mapId == entrance_map) || (useParentDbValue && itr->second.target_mapId == parentId))
+{
+AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(itr->first);
+if (atEntry && atEntry->mapid == Map)
+return &itr->second;
+}
+return NULL;
+}
+
+/**
+* Searches for the areatrigger which teleports players to the given map
+*/
+AreaTrigger const* ObjectMgr::GetMapEntranceTrigger(uint32 Map) const
+{
+for (AreaTriggerMap::const_iterator itr = mAreaTriggers.begin(); itr != mAreaTriggers.end(); ++itr)
+{
+if (itr->second.target_mapId == Map)
+{
+AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(itr->first);
+if (atEntry)
+return &itr->second;
+}
+}
+return NULL;
+}
+
+void ObjectMgr::SetHighestGuids()
+{
+QueryResult result = CharacterDatabase.Query("SELECT MAX(guid) FROM characters");
+if (result)
+m_hiCharGuid = (*result)[0].GetUInt32()+1;
+
+result = WorldDatabase.Query("SELECT MAX(guid) FROM creature");
+if (result)
+m_hiCreatureGuid = (*result)[0].GetUInt32()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(guid) FROM item_instance");
+if (result)
+m_hiItemGuid = (*result)[0].GetUInt32()+1;
+
+// Cleanup other tables from not existed guids ( >= m_hiItemGuid)
+CharacterDatabase.PExecute("DELETE FROM character_inventory WHERE item >= '%u'", m_hiItemGuid);
+CharacterDatabase.PExecute("DELETE FROM mail_items WHERE item_guid >= '%u'", m_hiItemGuid);
+CharacterDatabase.PExecute("DELETE FROM auctionhouse WHERE itemguid >= '%u'", m_hiItemGuid);
+CharacterDatabase.PExecute("DELETE FROM guild_bank_item WHERE item_guid >= '%u'", m_hiItemGuid);
+
+result = WorldDatabase.Query("SELECT MAX(guid) FROM gameobject");
+if (result)
+m_hiGoGuid = (*result)[0].GetUInt32()+1;
+
+result = WorldDatabase.Query("SELECT MAX(guid) FROM transports");
+if (result)
+m_hiMoTransGuid = (*result)[0].GetUInt32()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(id) FROM auctionhouse");
+if (result)
+m_auctionid = (*result)[0].GetUInt32()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(id) FROM mail");
+if (result)
+m_mailid = (*result)[0].GetUInt32()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(guid) FROM corpse");
+if (result)
+m_hiCorpseGuid = (*result)[0].GetUInt32()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(arenateamid) FROM arena_team");
+if (result)
+m_arenaTeamId = (*result)[0].GetUInt32()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(setguid) FROM character_equipmentsets");
+if (result)
+m_equipmentSetGuid = (*result)[0].GetUInt64()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(guildid) FROM guild");
+if (result)
+m_guildId = (*result)[0].GetUInt32()+1;
+
+result = CharacterDatabase.Query("SELECT MAX(guid) FROM groups");
+if (result)
+m_hiGroupGuid = (*result)[0].GetUInt32()+1;
+}
+
+uint32 ObjectMgr::GenerateArenaTeamId()
+{
+if (m_arenaTeamId >= 0xFFFFFFFE)
+{
+sLog.outError("Arena team ids overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_arenaTeamId++;
+}
+
+uint32 ObjectMgr::GenerateAuctionID()
+{
+if (m_auctionid >= 0xFFFFFFFE)
+{
+sLog.outError("Auctions ids overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_auctionid++;
+}
+
+uint64 ObjectMgr::GenerateEquipmentSetGuid()
+{
+if (m_equipmentSetGuid >= 0xFFFFFFFFFFFFFFFEll)
+{
+sLog.outError("EquipmentSet guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_equipmentSetGuid++;
+}
+
+uint32 ObjectMgr::GenerateGuildId()
+{
+if (m_guildId >= 0xFFFFFFFE)
+{
+sLog.outError("Guild ids overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_guildId++;
+}
+
+uint32 ObjectMgr::GenerateMailID()
+{
+if (m_mailid >= 0xFFFFFFFE)
+{
+sLog.outError("Mail ids overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_mailid++;
+}
+
+uint32 ObjectMgr::GenerateLowGuid(HighGuid guidhigh)
+{
+switch(guidhigh)
+{
+case HIGHGUID_ITEM:
+if (m_hiItemGuid >= 0xFFFFFFFE)
+{
+sLog.outError("Item guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiItemGuid++;
+case HIGHGUID_UNIT:
+if (m_hiCreatureGuid >= 0x00FFFFFE)
+{
+sLog.outError("Creature guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiCreatureGuid++;
+case HIGHGUID_PET:
+if (m_hiPetGuid >= 0x00FFFFFE)
+{
+sLog.outError("Pet guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiPetGuid++;
+case HIGHGUID_VEHICLE:
+if (m_hiVehicleGuid >= 0x00FFFFFF)
+{
+sLog.outError("Vehicle guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiVehicleGuid++;
+case HIGHGUID_PLAYER:
+if (m_hiCharGuid >= 0xFFFFFFFE)
+{
+sLog.outError("Players guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiCharGuid++;
+case HIGHGUID_GAMEOBJECT:
+if (m_hiGoGuid >= 0x00FFFFFE)
+{
+sLog.outError("Gameobject guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiGoGuid++;
+case HIGHGUID_CORPSE:
+if (m_hiCorpseGuid >= 0xFFFFFFFE)
+{
+sLog.outError("Corpse guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiCorpseGuid++;
+case HIGHGUID_DYNAMICOBJECT:
+if (m_hiDoGuid >= 0xFFFFFFFE)
+{
+sLog.outError("DynamicObject guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiDoGuid++;
+case HIGHGUID_GROUP:
+if (m_hiGroupGuid >= 0xFFFFFFFE)
+{
+sLog.outError("Group guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiGroupGuid++;
+case HIGHGUID_MO_TRANSPORT:
+if (m_hiMoTransGuid >= 0xFFFFFFFE)
+{
+sLog.outError("MO Transport guid overflow!! Can't continue, shutting down server. ");
+World::StopNow(ERROR_EXIT_CODE);
+}
+return m_hiMoTransGuid++;
+default:
+ASSERT(0);
+}
+
+ASSERT(0);
+return 0;
+}
+
+void ObjectMgr::LoadGameObjectLocales()
+{
+mGameObjectLocaleMap.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT entry,"
+"name_loc1,name_loc2,name_loc3,name_loc4,name_loc5,name_loc6,name_loc7,name_loc8,"
+"castbarcaption_loc1,castbarcaption_loc2,castbarcaption_loc3,castbarcaption_loc4,"
+"castbarcaption_loc5,castbarcaption_loc6,castbarcaption_loc7,castbarcaption_loc8 FROM locales_gameobject");
+
+if (!result)
+return;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 entry = fields[0].GetUInt32();
+
+GameObjectLocale& data = mGameObjectLocaleMap[entry];
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+std::string str = fields[i].GetString();
+AddLocaleString(str, LocaleConstant(i), data.Name);
+}
+
+for (uint8 i = 1; i < TOTAL_LOCALES; ++i)
+{
+std::string str = fields[i + (TOTAL_LOCALES - 1)].GetString();
+AddLocaleString(str, LocaleConstant(i), data.CastBarCaption);
+}
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %lu gameobject locale strings", (unsigned long)mGameObjectLocaleMap.size());
+}
+
+struct SQLGameObjectLoader : public SQLStorageLoaderBase<SQLGameObjectLoader>
+{
+template<class D>
+void convert_from_str(uint32 /*field_pos*/, char *src, D &dst)
+{
+dst = D(sObjectMgr.GetScriptId(src));
+}
+};
+
+inline void CheckGOLockId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
+{
+if (sLockStore.LookupEntry(dataN))
+return;
+
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but lock (Id: %u) not found.",
+goInfo->id,goInfo->type,N,goInfo->door.lockId,goInfo->door.lockId);
+}
+
+inline void CheckGOLinkedTrapId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
+{
+if (GameObjectInfo const* trapInfo = sGOStorage.LookupEntry<GameObjectInfo>(dataN))
+{
+if (trapInfo->type != GAMEOBJECT_TYPE_TRAP)
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but GO (Entry %u) have not GAMEOBJECT_TYPE_TRAP (%u) type.",
+goInfo->id,goInfo->type,N,dataN,dataN,GAMEOBJECT_TYPE_TRAP);
+}
+}
+
+inline void CheckGOSpellId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
+{
+if (sSpellStore.LookupEntry(dataN))
+return;
+
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but Spell (Entry %u) not exist.",
+goInfo->id,goInfo->type,N,dataN,dataN);
+}
+
+inline void CheckAndFixGOChairHeightId(GameObjectInfo const* goInfo,uint32 const& dataN,uint32 N)
+{
+if (dataN <= (UNIT_STAND_STATE_SIT_HIGH_CHAIR-UNIT_STAND_STATE_SIT_LOW_CHAIR))
+return;
+
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but correct chair height in range 0..%i.",
+goInfo->id,goInfo->type,N,dataN,UNIT_STAND_STATE_SIT_HIGH_CHAIR-UNIT_STAND_STATE_SIT_LOW_CHAIR);
+
+// prevent client and server unexpected work
+const_cast<uint32&>(dataN) = 0;
+}
+
+inline void CheckGONoDamageImmuneId(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
+{
+// 0/1 correct values
+if (dataN <= 1)
+return;
+
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but expected boolean (0/1) noDamageImmune field value.",
+goInfo->id,goInfo->type,N,dataN);
+}
+
+inline void CheckGOConsumable(GameObjectInfo const* goInfo,uint32 dataN,uint32 N)
+{
+// 0/1 correct values
+if (dataN <= 1)
+return;
+
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data%d=%u but expected boolean (0/1) consumable field value.",
+goInfo->id,goInfo->type,N,dataN);
+}
+
+void ObjectMgr::LoadGameobjectInfo()
+{
+SQLGameObjectLoader loader;
+loader.Load(sGOStorage);
+
+// some checks
+for (uint32 id = 1; id < sGOStorage.MaxEntry; id++)
+{
+GameObjectInfo const* goInfo = sGOStorage.LookupEntry<GameObjectInfo>(id);
+if (!goInfo)
+continue;
+
+// some GO types have unused go template, check goInfo->displayId at GO spawn data loading or ignore
+
+switch(goInfo->type)
+{
+case GAMEOBJECT_TYPE_DOOR: //0
+{
+if (goInfo->door.lockId)
+CheckGOLockId(goInfo,goInfo->door.lockId,1);
+CheckGONoDamageImmuneId(goInfo,goInfo->door.noDamageImmune,3);
+break;
+}
+case GAMEOBJECT_TYPE_BUTTON: //1
+{
+if (goInfo->button.lockId)
+CheckGOLockId(goInfo,goInfo->button.lockId,1);
+CheckGONoDamageImmuneId(goInfo,goInfo->button.noDamageImmune,4);
+break;
+}
+case GAMEOBJECT_TYPE_QUESTGIVER: //2
+{
+if (goInfo->questgiver.lockId)
+CheckGOLockId(goInfo,goInfo->questgiver.lockId,0);
+CheckGONoDamageImmuneId(goInfo,goInfo->questgiver.noDamageImmune,5);
+break;
+}
+case GAMEOBJECT_TYPE_CHEST: //3
+{
+if (goInfo->chest.lockId)
+CheckGOLockId(goInfo,goInfo->chest.lockId,0);
+
+CheckGOConsumable(goInfo,goInfo->chest.consumable,3);
+
+if (goInfo->chest.linkedTrapId) // linked trap
+CheckGOLinkedTrapId(goInfo,goInfo->chest.linkedTrapId,7);
+break;
+}
+case GAMEOBJECT_TYPE_TRAP: //6
+{
+if (goInfo->trap.lockId)
+CheckGOLockId(goInfo,goInfo->trap.lockId,0);
+break;
+}
+case GAMEOBJECT_TYPE_CHAIR: //7
+CheckAndFixGOChairHeightId(goInfo,goInfo->chair.height,1);
+break;
+case GAMEOBJECT_TYPE_SPELL_FOCUS: //8
+{
+if (goInfo->spellFocus.focusId)
+{
+if (!sSpellFocusObjectStore.LookupEntry(goInfo->spellFocus.focusId))
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data0=%u but SpellFocus (Id: %u) not exist.",
+id,goInfo->type,goInfo->spellFocus.focusId,goInfo->spellFocus.focusId);
+}
+
+if (goInfo->spellFocus.linkedTrapId) // linked trap
+CheckGOLinkedTrapId(goInfo,goInfo->spellFocus.linkedTrapId,2);
+break;
+}
+case GAMEOBJECT_TYPE_GOOBER: //10
+{
+if (goInfo->goober.lockId)
+CheckGOLockId(goInfo,goInfo->goober.lockId,0);
+
+CheckGOConsumable(goInfo,goInfo->goober.consumable,3);
+
+if (goInfo->goober.pageId) // pageId
+{
+if (!sPageTextStore.LookupEntry<PageText>(goInfo->goober.pageId))
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data7=%u but PageText (Entry %u) not exist.",
+id,goInfo->type,goInfo->goober.pageId,goInfo->goober.pageId);
+}
+CheckGONoDamageImmuneId(goInfo,goInfo->goober.noDamageImmune,11);
+if (goInfo->goober.linkedTrapId) // linked trap
+CheckGOLinkedTrapId(goInfo,goInfo->goober.linkedTrapId,12);
+break;
+}
+case GAMEOBJECT_TYPE_AREADAMAGE: //12
+{
+if (goInfo->areadamage.lockId)
+CheckGOLockId(goInfo,goInfo->areadamage.lockId,0);
+break;
+}
+case GAMEOBJECT_TYPE_CAMERA: //13
+{
+if (goInfo->camera.lockId)
+CheckGOLockId(goInfo,goInfo->camera.lockId,0);
+break;
+}
+case GAMEOBJECT_TYPE_MO_TRANSPORT: //15
+{
+if (goInfo->moTransport.taxiPathId)
+{
+if (goInfo->moTransport.taxiPathId >= sTaxiPathNodesByPath.size() || sTaxiPathNodesByPath[goInfo->moTransport.taxiPathId].empty())
+sLog.outErrorDb("Gameobject (Entry: %u GoType: %u) have data0=%u but TaxiPath (Id: %u) not exist.",
+id,goInfo->type,goInfo->moTransport.taxiPathId,goInfo->moTransport.taxiPathId);
+}
+break;
+}
+case GAMEOBJECT_TYPE_SUMMONING_RITUAL: //18
+break;
+case GAMEOBJECT_TYPE_SPELLCASTER: //22
+{
+// always must have spell
+CheckGOSpellId(goInfo,goInfo->spellcaster.spellId,0);
+break;
+}
+case GAMEOBJECT_TYPE_FLAGSTAND: //24
+{
+if (goInfo->flagstand.lockId)
+CheckGOLockId(goInfo,goInfo->flagstand.lockId,0);
+CheckGONoDamageImmuneId(goInfo,goInfo->flagstand.noDamageImmune,5);
+break;
+}
+case GAMEOBJECT_TYPE_FISHINGHOLE: //25
+{
+if (goInfo->fishinghole.lockId)
+CheckGOLockId(goInfo,goInfo->fishinghole.lockId,4);
+break;
+}
+case GAMEOBJECT_TYPE_FLAGDROP: //26
+{
+if (goInfo->flagdrop.lockId)
+CheckGOLockId(goInfo,goInfo->flagdrop.lockId,0);
+CheckGONoDamageImmuneId(goInfo,goInfo->flagdrop.noDamageImmune,3);
+break;
+}
+case GAMEOBJECT_TYPE_BARBER_CHAIR: //32
+CheckAndFixGOChairHeightId(goInfo,goInfo->barberChair.chairheight,0);
+break;
+}
+}
+
+sLog.outString(">> Loaded %u game object templates", sGOStorage.RecordCount);
+sLog.outString();
+}
+
+void ObjectMgr::LoadExplorationBaseXP()
+{
+uint32 count = 0;
+QueryResult result = WorldDatabase.Query("SELECT level,basexp FROM exploration_basexp");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u BaseXP definitions", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+uint8 level = fields[0].GetUInt8();
+uint32 basexp = fields[1].GetUInt32();
+mBaseXPTable[level] = basexp;
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u BaseXP definitions", count);
+}
+
+uint32 ObjectMgr::GetBaseXP(uint8 level)
+{
+return mBaseXPTable[level] ? mBaseXPTable[level] : 0;
+}
+
+uint32 ObjectMgr::GetXPForLevel(uint8 level)
+{
+if (level < mPlayerXPperLevel.size())
+return mPlayerXPperLevel[level];
+return 0;
+}
+
+void ObjectMgr::LoadPetNames()
+{
+uint32 count = 0;
+QueryResult result = WorldDatabase.Query("SELECT word,entry,half FROM pet_name_generation");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u pet name parts", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+std::string word = fields[0].GetString();
+uint32 entry = fields[1].GetUInt32();
+bool half = fields[2].GetBool();
+if (half)
+PetHalfName1[entry].push_back(word);
+else
+PetHalfName0[entry].push_back(word);
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u pet name parts", count);
+}
+
+void ObjectMgr::LoadPetNumber()
+{
+QueryResult result = CharacterDatabase.Query("SELECT MAX(id) FROM character_pet");
+if (result)
+{
+Field *fields = result->Fetch();
+m_hiPetNumber = fields[0].GetUInt32()+1;
+}
+
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded the max pet number: %d", m_hiPetNumber-1);
+}
+
+std::string ObjectMgr::GeneratePetName(uint32 entry)
+{
+StringVector & list0 = PetHalfName0[entry];
+StringVector & list1 = PetHalfName1[entry];
+
+if (list0.empty() || list1.empty())
+{
+CreatureInfo const *cinfo = GetCreatureTemplate(entry);
+char* petname = GetPetName(cinfo->family, sWorld.GetDefaultDbcLocale());
+if (!petname)
+petname = cinfo->Name;
+return std::string(petname);
+}
+
+return *(list0.begin()+urand(0, list0.size()-1)) + *(list1.begin()+urand(0, list1.size()-1));
+}
+
+uint32 ObjectMgr::GeneratePetNumber()
+{
+return ++m_hiPetNumber;
+}
+
+void ObjectMgr::LoadCorpses()
+{
+uint32 count = 0;
+// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
+QueryResult result = CharacterDatabase.Query("SELECT position_x, position_y, position_z, orientation, map, displayId, itemCache, bytes1, bytes2, guild, flags, dynFlags, time, corpse_type, instance, phaseMask, guid, player FROM corpse WHERE corpse_type <> 0");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u corpses", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 guid = fields[16].GetUInt32();
+
+Corpse *corpse = new Corpse;
+if (!corpse->LoadFromDB(guid, fields))
+{
+delete corpse;
+continue;
+}
+
+sObjectAccessor.AddCorpse(corpse);
+
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u corpses", count);
+}
+
+void ObjectMgr::LoadReputationRewardRate()
+{
+m_RepRewardRateMap.clear(); // for reload case
+
+uint32 count = 0;
+QueryResult result = WorldDatabase.Query("SELECT faction, quest_rate, creature_rate, spell_rate FROM reputation_reward_rate");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `reputation_reward_rate`, table is empty!");
+return;
+}
+
+barGoLink bar((int)result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 factionId = fields[0].GetUInt32();
+
+RepRewardRate repRate;
+
+repRate.quest_rate = fields[1].GetFloat();
+repRate.creature_rate = fields[2].GetFloat();
+repRate.spell_rate = fields[3].GetFloat();
+
+FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
+if (!factionEntry)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_reward_rate`", factionId);
+continue;
+}
+
+if (repRate.quest_rate < 0.0f)
+{
+sLog.outErrorDb("Table reputation_reward_rate has quest_rate with invalid rate %f, skipping data for faction %u", repRate.quest_rate, factionId);
+continue;
+}
+
+if (repRate.creature_rate < 0.0f)
+{
+sLog.outErrorDb("Table reputation_reward_rate has creature_rate with invalid rate %f, skipping data for faction %u", repRate.creature_rate, factionId);
+continue;
+}
+
+if (repRate.spell_rate < 0.0f)
+{
+sLog.outErrorDb("Table reputation_reward_rate has spell_rate with invalid rate %f, skipping data for faction %u", repRate.spell_rate, factionId);
+continue;
+}
+
+m_RepRewardRateMap[factionId] = repRate;
+
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u reputation_reward_rate", count);
+}
+
+void ObjectMgr::LoadReputationOnKill()
+{
+// For reload case
+mRepOnKill.clear();
+
+uint32 count = 0;
+
+// 0 1 2
+QueryResult result = WorldDatabase.Query("SELECT creature_id, RewOnKillRepFaction1, RewOnKillRepFaction2,"
+// 3 4 5 6 7 8 9
+"IsTeamAward1, MaxStanding1, RewOnKillRepValue1, IsTeamAward2, MaxStanding2, RewOnKillRepValue2, TeamDependent "
+"FROM creature_onkill_reputation");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 creature award reputation definitions. DB table `creature_onkill_reputation` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 creature_id = fields[0].GetUInt32();
+
+ReputationOnKillEntry repOnKill;
+repOnKill.repfaction1 = fields[1].GetUInt32();
+repOnKill.repfaction2 = fields[2].GetUInt32();
+repOnKill.is_teamaward1 = fields[3].GetBool();
+repOnKill.reputation_max_cap1 = fields[4].GetUInt32();
+repOnKill.repvalue1 = fields[5].GetInt32();
+repOnKill.is_teamaward2 = fields[6].GetBool();
+repOnKill.reputation_max_cap2 = fields[7].GetUInt32();
+repOnKill.repvalue2 = fields[8].GetInt32();
+repOnKill.team_dependent = fields[9].GetUInt8();
+
+if (!GetCreatureTemplate(creature_id))
+{
+sLog.outErrorDb("Table `creature_onkill_reputation` have data for not existed creature entry (%u), skipped", creature_id);
+continue;
+}
+
+if (repOnKill.repfaction1)
+{
+FactionEntry const *factionEntry1 = sFactionStore.LookupEntry(repOnKill.repfaction1);
+if (!factionEntry1)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `creature_onkill_reputation`", repOnKill.repfaction1);
+continue;
+}
+}
+
+if (repOnKill.repfaction2)
+{
+FactionEntry const *factionEntry2 = sFactionStore.LookupEntry(repOnKill.repfaction2);
+if (!factionEntry2)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `creature_onkill_reputation`", repOnKill.repfaction2);
+continue;
+}
+}
+
+mRepOnKill[creature_id] = repOnKill;
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u creature award reputation definitions", count);
+}
+
+void ObjectMgr::LoadReputationSpilloverTemplate()
+{
+m_RepSpilloverTemplateMap.clear(); // for reload case
+
+uint32 count = 0;
+QueryResult result = WorldDatabase.Query("SELECT faction, faction1, rate_1, rank_1, faction2, rate_2, rank_2, faction3, rate_3, rank_3, faction4, rate_4, rank_4 FROM reputation_spillover_template");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `reputation_spillover_template`, table is empty!");
+return;
+}
+
+barGoLink bar((int)result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 factionId = fields[0].GetUInt32();
+
+RepSpilloverTemplate repTemplate;
+
+repTemplate.faction[0] = fields[1].GetUInt32();
+repTemplate.faction_rate[0] = fields[2].GetFloat();
+repTemplate.faction_rank[0] = fields[3].GetUInt32();
+repTemplate.faction[1] = fields[4].GetUInt32();
+repTemplate.faction_rate[1] = fields[5].GetFloat();
+repTemplate.faction_rank[1] = fields[6].GetUInt32();
+repTemplate.faction[2] = fields[7].GetUInt32();
+repTemplate.faction_rate[2] = fields[8].GetFloat();
+repTemplate.faction_rank[2] = fields[9].GetUInt32();
+repTemplate.faction[3] = fields[10].GetUInt32();
+repTemplate.faction_rate[3] = fields[11].GetFloat();
+repTemplate.faction_rank[3] = fields[12].GetUInt32();
+
+FactionEntry const *factionEntry = sFactionStore.LookupEntry(factionId);
+
+if (!factionEntry)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", factionId);
+continue;
+}
+
+if (factionEntry->team == 0)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u in `reputation_spillover_template` does not belong to any team, skipping", factionId);
+continue;
+}
+
+for (uint32 i = 0; i < MAX_SPILLOVER_FACTIONS; ++i)
+{
+if (repTemplate.faction[i])
+{
+FactionEntry const *factionSpillover = sFactionStore.LookupEntry(repTemplate.faction[i]);
+
+if (!factionSpillover)
+{
+sLog.outErrorDb("Spillover faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template` for faction %u, skipping", repTemplate.faction[i], factionId);
+continue;
+}
+
+if (factionSpillover->reputationListID < 0)
+{
+sLog.outErrorDb("Spillover faction (faction.dbc) %u for faction %u in `reputation_spillover_template` can not be listed for client, and then useless, skipping", repTemplate.faction[i], factionId);
+continue;
+}
+
+if (repTemplate.faction_rank[i] >= MAX_REPUTATION_RANK)
+{
+sLog.outErrorDb("Rank %u used in `reputation_spillover_template` for spillover faction %u is not valid, skipping", repTemplate.faction_rank[i], repTemplate.faction[i]);
+continue;
+}
+}
+}
+
+FactionEntry const *factionEntry0 = sFactionStore.LookupEntry(repTemplate.faction[0]);
+if (repTemplate.faction[0] && !factionEntry0)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[0]);
+continue;
+}
+FactionEntry const *factionEntry1 = sFactionStore.LookupEntry(repTemplate.faction[1]);
+if (repTemplate.faction[1] && !factionEntry1)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[1]);
+continue;
+}
+FactionEntry const *factionEntry2 = sFactionStore.LookupEntry(repTemplate.faction[2]);
+if (repTemplate.faction[2] && !factionEntry2)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[2]);
+continue;
+}
+FactionEntry const *factionEntry3 = sFactionStore.LookupEntry(repTemplate.faction[3]);
+if (repTemplate.faction[3] && !factionEntry3)
+{
+sLog.outErrorDb("Faction (faction.dbc) %u does not exist but is used in `reputation_spillover_template`", repTemplate.faction[3]);
+continue;
+}
+
+m_RepSpilloverTemplateMap[factionId] = repTemplate;
+
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u reputation_spillover_template", count);
+}
+
+void ObjectMgr::LoadPointsOfInterest()
+{
+mPointsOfInterest.clear(); // need for reload case
+
+uint32 count = 0;
+
+// 0 1 2 3 4 5 6
+QueryResult result = WorldDatabase.Query("SELECT entry, x, y, icon, flags, data, icon_name FROM points_of_interest");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 Points of Interest definitions. DB table `points_of_interest` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 point_id = fields[0].GetUInt32();
+
+PointOfInterest POI;
+POI.x = fields[1].GetFloat();
+POI.y = fields[2].GetFloat();
+POI.icon = fields[3].GetUInt32();
+POI.flags = fields[4].GetUInt32();
+POI.data = fields[5].GetUInt32();
+POI.icon_name = fields[6].GetString();
+
+if (!Trinity::IsValidMapCoord(POI.x,POI.y))
+{
+sLog.outErrorDb("Table `points_of_interest` (Entry: %u) have invalid coordinates (X: %f Y: %f), ignored.",point_id,POI.x,POI.y);
+continue;
+}
+
+mPointsOfInterest[point_id] = POI;
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u Points of Interest definitions", count);
+}
+
+void ObjectMgr::LoadQuestPOI()
+{
+mQuestPOIMap.clear(); // need for reload case
+
+uint32 count = 0;
+
+// 0 1 2 3 4 5 6 7
+QueryResult result = WorldDatabase.Query("SELECT questId, id, objIndex, mapid, WorldMapAreaId, FloorId, unk3, unk4 FROM quest_poi order by questId");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 quest POI definitions. DB table `quest_poi` is empty.");
+return;
+}
+
+// 0 1 2 3
+QueryResult points = WorldDatabase.PQuery("SELECT questId, id, x, y FROM quest_poi_points ORDER BY questId DESC, idx");
+
+barGoLink bar(result->GetRowCount() + (points ? points->GetRowCount() : 0));
+
+std::vector<std::vector<std::vector<QuestPOIPoint> > > POIs;
+
+if (points)
+{
+// The first result should have the highest questId
+Field *fields = points->Fetch();
+uint32 questId = fields[0].GetUInt32();
+POIs.resize(questId + 1);
+
+do
+{
+bar.step();
+
+Field *fields = points->Fetch();
+
+uint32 questId = fields[0].GetUInt32();
+uint32 id = fields[1].GetUInt32();
+int32 x = fields[2].GetInt32();
+int32 y = fields[3].GetInt32();
+
+if(POIs[questId].size() <= id + 1)
+POIs[questId].resize(id + 10);
+
+QuestPOIPoint point(x, y);
+POIs[questId][id].push_back(point);
+} while (points->NextRow());
+}
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 questId = fields[0].GetUInt32();
+uint32 id = fields[1].GetUInt32();
+int32 objIndex = fields[2].GetInt32();
+uint32 mapId = fields[3].GetUInt32();
+uint32 WorldMapAreaId = fields[4].GetUInt32();
+uint32 FloorId = fields[5].GetUInt32();
+uint32 unk3 = fields[6].GetUInt32();
+uint32 unk4 = fields[7].GetUInt32();
+
+QuestPOI POI(id, objIndex, mapId, WorldMapAreaId, FloorId, unk3, unk4);
+POI.points = POIs[questId][id];
+
+mQuestPOIMap[questId].push_back(POI);
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u quest POI definitions", count);
+}
+
+void ObjectMgr::LoadNPCSpellClickSpells()
+{
+uint32 count = 0;
+
+mSpellClickInfoMap.clear();
+// 0 1 2 3 4 5 6 7 8
+QueryResult result = WorldDatabase.Query("SELECT npc_entry, spell_id, quest_start, quest_start_active, quest_end, cast_flags, aura_required, aura_forbidden, user_type FROM npc_spellclick_spells");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 spellclick spells. DB table `npc_spellclick_spells` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+uint32 npc_entry = fields[0].GetUInt32();
+CreatureInfo const* cInfo = GetCreatureTemplate(npc_entry);
+if (!cInfo)
+{
+sLog.outErrorDb("Table npc_spellclick_spells references unknown creature_template %u. Skipping entry.", npc_entry);
+continue;
+}
+
+if (!(cInfo->npcflag & UNIT_NPC_FLAG_SPELLCLICK))
+const_cast<CreatureInfo*>(cInfo)->npcflag |= UNIT_NPC_FLAG_SPELLCLICK;
+
+uint32 spellid = fields[1].GetUInt32();
+SpellEntry const *spellinfo = sSpellStore.LookupEntry(spellid);
+if (!spellinfo)
+{
+sLog.outErrorDb("Table npc_spellclick_spells references unknown spellid %u. Skipping entry.", spellid);
+continue;
+}
+
+uint32 auraRequired = fields[6].GetUInt32();
+if (auraRequired)
+{
+SpellEntry const *aurReqInfo = sSpellStore.LookupEntry(auraRequired);
+if (!aurReqInfo)
+{
+sLog.outErrorDb("Table npc_spellclick_spells references unknown aura required %u. Skipping entry.", auraRequired);
+continue;
+}
+}
+
+uint32 auraForbidden = fields[7].GetUInt32();
+if (auraForbidden)
+{
+SpellEntry const *aurForInfo = sSpellStore.LookupEntry(auraForbidden);
+if (!aurForInfo)
+{
+sLog.outErrorDb("Table npc_spellclick_spells references unknown aura forbidden %u. Skipping entry.", auraForbidden);
+continue;
+}
+}
+
+uint32 quest_start = fields[2].GetUInt32();
+
+// quest might be 0 to enable spellclick independent of any quest
+if (quest_start)
+{
+if (mQuestTemplates.find(quest_start) == mQuestTemplates.end())
+{
+sLog.outErrorDb("Table npc_spellclick_spells references unknown start quest %u. Skipping entry.", quest_start);
+continue;
+}
+}
+
+bool quest_start_active = fields[3].GetBool();
+
+uint32 quest_end = fields[4].GetUInt32();
+// quest might be 0 to enable spellclick active infinity after start quest
+if (quest_end)
+{
+if (mQuestTemplates.find(quest_end) == mQuestTemplates.end())
+{
+sLog.outErrorDb("Table npc_spellclick_spells references unknown end quest %u. Skipping entry.", quest_end);
+continue;
+}
+}
+
+uint8 userType = fields[8].GetUInt8();
+if (userType >= SPELL_CLICK_USER_MAX)
+sLog.outErrorDb("Table npc_spellclick_spells references unknown user type %u. Skipping entry.", uint32(userType));
+
+uint8 castFlags = fields[5].GetUInt8();
+SpellClickInfo info;
+info.spellId = spellid;
+info.questStart = quest_start;
+info.questStartCanActive = quest_start_active;
+info.questEnd = quest_end;
+info.castFlags = castFlags;
+info.auraRequired = auraRequired;
+info.auraForbidden = auraForbidden;
+info.userType = SpellClickUserTypes(userType);
+mSpellClickInfoMap.insert(SpellClickInfoMap::value_type(npc_entry, info));
+
+// mark creature template as spell clickable
+const_cast<CreatureInfo*>(cInfo)->npcflag |= UNIT_NPC_FLAG_SPELLCLICK;
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u spellclick definitions", count);
+}
+
+void ObjectMgr::SaveCreatureRespawnTime(uint32 loguid, uint32 instance, time_t t)
+{
+// This function can be Called from various map threads concurrently
+{
+ACE_GUARD(ACE_Thread_Mutex, guard, m_CreatureRespawnTimesMtx);
+mCreatureRespawnTimes[MAKE_PAIR64(loguid,instance)] = t;
+}
+
+PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_DEL_CRESPAWNTIME);
+stmt->setUInt32(0, loguid);
+stmt->setUInt32(1, instance);
+WorldDatabase.Execute(stmt);
+
+if (t)
+{
+stmt = WorldDatabase.GetPreparedStatement(WORLD_ADD_CRESPAWNTIME);
+stmt->setUInt32(0, loguid);
+stmt->setUInt64(1, uint64(t));
+stmt->setUInt32(2, instance);
+WorldDatabase.Execute(stmt);
+}
+}
+
+void ObjectMgr::DeleteCreatureData(uint32 guid)
+{
+// remove mapid*cellid -> guid_set map
+CreatureData const* data = GetCreatureData(guid);
+if (data)
+RemoveCreatureFromGrid(guid, data);
+
+mCreatureDataMap.erase(guid);
+}
+
+void ObjectMgr::SaveGORespawnTime(uint32 loguid, uint32 instance, time_t t)
+{
+// This function can be called from different map threads concurrently
+{
+ACE_GUARD(ACE_Thread_Mutex, guard, m_CreatureRespawnTimesMtx);
+mGORespawnTimes[MAKE_PAIR64(loguid,instance)] = t;
+}
+
+WorldDatabase.PExecute("DELETE FROM gameobject_respawn WHERE guid = '%u' AND instance = '%u'", loguid, instance);
+if (t)
+WorldDatabase.PExecute("INSERT INTO gameobject_respawn VALUES ('%u', '" UI64FMTD "', '%u')", loguid, uint64(t), instance);
+}
+
+void ObjectMgr::DeleteRespawnTimeForInstance(uint32 instance)
+{
+// This function can be called from different map threads concurrently
+RespawnTimes::iterator next;
+
+{
+ACE_GUARD(ACE_Thread_Mutex, guard, m_GORespawnTimesMtx);
+for (RespawnTimes::iterator itr = mGORespawnTimes.begin(); itr != mGORespawnTimes.end(); itr = next)
+{
+next = itr;
+++next;
+
+if (GUID_HIPART(itr->first) == instance)
+mGORespawnTimes.erase(itr);
+}
+}
+{
+ACE_GUARD(ACE_Thread_Mutex, guard, m_CreatureRespawnTimesMtx);
+for (RespawnTimes::iterator itr = mCreatureRespawnTimes.begin(); itr != mCreatureRespawnTimes.end(); itr = next)
+{
+next = itr;
+++next;
+
+if (GUID_HIPART(itr->first) == instance)
+mCreatureRespawnTimes.erase(itr);
+}
+}
+WorldDatabase.PExecute("DELETE FROM creature_respawn WHERE instance = '%u'", instance);
+WorldDatabase.PExecute("DELETE FROM gameobject_respawn WHERE instance = '%u'", instance);
+}
+
+void ObjectMgr::DeleteGOData(uint32 guid)
+{
+// remove mapid*cellid -> guid_set map
+GameObjectData const* data = GetGOData(guid);
+if (data)
+RemoveGameobjectFromGrid(guid, data);
+
+mGameObjectDataMap.erase(guid);
+}
+
+void ObjectMgr::AddCorpseCellData(uint32 mapid, uint32 cellid, uint32 player_guid, uint32 instance)
+{
+// corpses are always added to spawn mode 0 and they are spawned by their instance id
+CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(mapid,0)][cellid];
+cell_guids.corpses[player_guid] = instance;
+}
+
+void ObjectMgr::DeleteCorpseCellData(uint32 mapid, uint32 cellid, uint32 player_guid)
+{
+// corpses are always added to spawn mode 0 and they are spawned by their instance id
+CellObjectGuids& cell_guids = mMapObjectGuids[MAKE_PAIR32(mapid,0)][cellid];
+cell_guids.corpses.erase(player_guid);
+}
+
+void ObjectMgr::LoadQuestRelationsHelper(QuestRelations& map, std::string table, bool starter, bool go)
+{
+map.clear(); // need for reload case
+
+uint32 count = 0;
+
+QueryResult result = WorldDatabase.PQuery("SELECT id, quest, pool_entry FROM %s qr LEFT JOIN pool_quest pq ON qr.quest = pq.entry", table.c_str());
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded 0 quest relations from %s, table is empty.", table.c_str());
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+PooledQuestRelation* poolRelationMap = go ? &sPoolMgr.mQuestGORelation : &sPoolMgr.mQuestCreatureRelation;
+if (starter)
+poolRelationMap->clear();
+
+do
+{
+bar.step();
+
+uint32 id = result->Fetch()[0].GetUInt32();
+uint32 quest = result->Fetch()[1].GetUInt32();
+uint32 poolId = result->Fetch()[2].GetUInt32();
+
+if (mQuestTemplates.find(quest) == mQuestTemplates.end())
+{
+sLog.outErrorDb("Table `%s: Quest %u listed for entry %u does not exist.", table.c_str(), quest, id);
+continue;
+}
+
+if (!poolId || !starter)
+map.insert(QuestRelations::value_type(id, quest));
+else if (starter)
+poolRelationMap->insert(PooledQuestRelation::value_type(quest, id));
+
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u quest relations from %s", count, table.c_str());
+}
+
+void ObjectMgr::LoadGameobjectQuestRelations()
+{
+LoadQuestRelationsHelper(mGOQuestRelations, "gameobject_questrelation", true, true);
+
+for (QuestRelations::iterator itr = mGOQuestRelations.begin(); itr != mGOQuestRelations.end(); ++itr)
+{
+GameObjectInfo const* goInfo = GetGameObjectInfo(itr->first);
+if (!goInfo)
+sLog.outErrorDb("Table `gameobject_questrelation` have data for not existed gameobject entry (%u) and existed quest %u",itr->first,itr->second);
+else if (goInfo->type != GAMEOBJECT_TYPE_QUESTGIVER)
+sLog.outErrorDb("Table `gameobject_questrelation` have data gameobject entry (%u) for quest %u, but GO is not GAMEOBJECT_TYPE_QUESTGIVER",itr->first,itr->second);
+}
+}
+
+void ObjectMgr::LoadGameobjectInvolvedRelations()
+{
+LoadQuestRelationsHelper(mGOQuestInvolvedRelations, "gameobject_involvedrelation", false, true);
+
+for (QuestRelations::iterator itr = mGOQuestInvolvedRelations.begin(); itr != mGOQuestInvolvedRelations.end(); ++itr)
+{
+GameObjectInfo const* goInfo = GetGameObjectInfo(itr->first);
+if (!goInfo)
+sLog.outErrorDb("Table `gameobject_involvedrelation` have data for not existed gameobject entry (%u) and existed quest %u",itr->first,itr->second);
+else if (goInfo->type != GAMEOBJECT_TYPE_QUESTGIVER)
+sLog.outErrorDb("Table `gameobject_involvedrelation` have data gameobject entry (%u) for quest %u, but GO is not GAMEOBJECT_TYPE_QUESTGIVER",itr->first,itr->second);
+}
+}
+
+void ObjectMgr::LoadCreatureQuestRelations()
+{
+LoadQuestRelationsHelper(mCreatureQuestRelations, "creature_questrelation", true, false);
+
+for (QuestRelations::iterator itr = mCreatureQuestRelations.begin(); itr != mCreatureQuestRelations.end(); ++itr)
+{
+CreatureInfo const* cInfo = GetCreatureTemplate(itr->first);
+if (!cInfo)
+sLog.outErrorDb("Table `creature_questrelation` have data for not existed creature entry (%u) and existed quest %u",itr->first,itr->second);
+else if (!(cInfo->npcflag & UNIT_NPC_FLAG_QUESTGIVER))
+sLog.outErrorDb("Table `creature_questrelation` has creature entry (%u) for quest %u, but npcflag does not include UNIT_NPC_FLAG_QUESTGIVER",itr->first,itr->second);
+}
+}
+
+void ObjectMgr::LoadCreatureInvolvedRelations()
+{
+LoadQuestRelationsHelper(mCreatureQuestInvolvedRelations, "creature_involvedrelation", false, false);
+
+for (QuestRelations::iterator itr = mCreatureQuestInvolvedRelations.begin(); itr != mCreatureQuestInvolvedRelations.end(); ++itr)
+{
+CreatureInfo const* cInfo = GetCreatureTemplate(itr->first);
+if (!cInfo)
+sLog.outErrorDb("Table `creature_involvedrelation` have data for not existed creature entry (%u) and existed quest %u",itr->first,itr->second);
+else if (!(cInfo->npcflag & UNIT_NPC_FLAG_QUESTGIVER))
+sLog.outErrorDb("Table `creature_involvedrelation` has creature entry (%u) for quest %u, but npcflag does not include UNIT_NPC_FLAG_QUESTGIVER",itr->first,itr->second);
+}
+}
+
+void ObjectMgr::LoadReservedPlayersNames()
+{
+m_ReservedNames.clear(); // need for reload case
+
+QueryResult result = WorldDatabase.Query("SELECT name FROM reserved_name");
+
+uint32 count = 0;
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+
+sLog.outString();
+sLog.outString(">> Loaded %u reserved player names", count);
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+Field* fields;
+do
+{
+bar.step();
+fields = result->Fetch();
+std::string name= fields[0].GetString();
+
+std::wstring wstr;
+if (!Utf8toWStr (name,wstr))
+{
+sLog.outError("Table `reserved_name` have invalid name: %s", name.c_str());
+continue;
+}
+
+wstrToLower(wstr);
+
+m_ReservedNames.insert(wstr);
+++count;
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u reserved player names", count);
+}
+
+bool ObjectMgr::IsReservedName(const std::string& name) const
+{
+std::wstring wstr;
+if (!Utf8toWStr (name,wstr))
+return false;
+
+wstrToLower(wstr);
+
+return m_ReservedNames.find(wstr) != m_ReservedNames.end();
+}
+
+enum LanguageType
+{
+LT_BASIC_LATIN = 0x0000,
+LT_EXTENDEN_LATIN = 0x0001,
+LT_CYRILLIC = 0x0002,
+LT_EAST_ASIA = 0x0004,
+LT_ANY = 0xFFFF
+};
+
+static LanguageType GetRealmLanguageType(bool create)
+{
+switch(sWorld.getIntConfig(CONFIG_REALM_ZONE))
+{
+case REALM_ZONE_UNKNOWN: // any language
+case REALM_ZONE_DEVELOPMENT:
+case REALM_ZONE_TEST_SERVER:
+case REALM_ZONE_QA_SERVER:
+return LT_ANY;
+case REALM_ZONE_UNITED_STATES: // extended-Latin
+case REALM_ZONE_OCEANIC:
+case REALM_ZONE_LATIN_AMERICA:
+case REALM_ZONE_ENGLISH:
+case REALM_ZONE_GERMAN:
+case REALM_ZONE_FRENCH:
+case REALM_ZONE_SPANISH:
+return LT_EXTENDEN_LATIN;
+case REALM_ZONE_KOREA: // East-Asian
+case REALM_ZONE_TAIWAN:
+case REALM_ZONE_CHINA:
+return LT_EAST_ASIA;
+case REALM_ZONE_RUSSIAN: // Cyrillic
+return LT_CYRILLIC;
+default:
+return create ? LT_BASIC_LATIN : LT_ANY; // basic-Latin at create, any at login
+}
+}
+
+bool isValidString(std::wstring wstr, uint32 strictMask, bool numericOrSpace, bool create = false)
+{
+if (strictMask == 0) // any language, ignore realm
+{
+if (isExtendedLatinString(wstr,numericOrSpace))
+return true;
+if (isCyrillicString(wstr,numericOrSpace))
+return true;
+if (isEastAsianString(wstr,numericOrSpace))
+return true;
+return false;
+}
+
+if (strictMask & 0x2) // realm zone specific
+{
+LanguageType lt = GetRealmLanguageType(create);
+if (lt & LT_EXTENDEN_LATIN)
+if (isExtendedLatinString(wstr,numericOrSpace))
+return true;
+if (lt & LT_CYRILLIC)
+if (isCyrillicString(wstr,numericOrSpace))
+return true;
+if (lt & LT_EAST_ASIA)
+if (isEastAsianString(wstr,numericOrSpace))
+return true;
+}
+
+if (strictMask & 0x1) // basic Latin
+{
+if (isBasicLatinString(wstr,numericOrSpace))
+return true;
+}
+
+return false;
+}
+
+uint8 ObjectMgr::CheckPlayerName(const std::string& name, bool create)
+{
+std::wstring wname;
+if (!Utf8toWStr(name,wname))
+return CHAR_NAME_INVALID_CHARACTER;
+
+if (wname.size() > MAX_PLAYER_NAME)
+return CHAR_NAME_TOO_LONG;
+
+uint32 minName = sWorld.getIntConfig(CONFIG_MIN_PLAYER_NAME);
+if (wname.size() < minName)
+return CHAR_NAME_TOO_SHORT;
+
+uint32 strictMask = sWorld.getIntConfig(CONFIG_STRICT_PLAYER_NAMES);
+if (!isValidString(wname,strictMask,false,create))
+return CHAR_NAME_MIXED_LANGUAGES;
+
+return CHAR_NAME_SUCCESS;
+}
+
+bool ObjectMgr::IsValidCharterName(const std::string& name)
+{
+std::wstring wname;
+if (!Utf8toWStr(name,wname))
+return false;
+
+if (wname.size() > MAX_CHARTER_NAME)
+return false;
+
+uint32 minName = sWorld.getIntConfig(CONFIG_MIN_CHARTER_NAME);
+if (wname.size() < minName)
+return false;
+
+uint32 strictMask = sWorld.getIntConfig(CONFIG_STRICT_CHARTER_NAMES);
+
+return isValidString(wname,strictMask,true);
+}
+
+PetNameInvalidReason ObjectMgr::CheckPetName(const std::string& name)
+{
+std::wstring wname;
+if (!Utf8toWStr(name,wname))
+return PET_NAME_INVALID;
+
+if (wname.size() > MAX_PET_NAME)
+return PET_NAME_TOO_LONG;
+
+uint32 minName = sWorld.getIntConfig(CONFIG_MIN_PET_NAME);
+if (wname.size() < minName)
+return PET_NAME_TOO_SHORT;
+
+uint32 strictMask = sWorld.getIntConfig(CONFIG_STRICT_PET_NAMES);
+if (!isValidString(wname,strictMask,false))
+return PET_NAME_MIXED_LANGUAGES;
+
+return PET_NAME_SUCCESS;
+}
+
+void ObjectMgr::LoadGameObjectForQuests()
+{
+mGameObjectForQuestSet.clear(); // need for reload case
+
+if (!sGOStorage.MaxEntry)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 GameObjects for quests");
+return;
+}
+
+barGoLink bar(sGOStorage.MaxEntry - 1);
+uint32 count = 0;
+
+// collect GO entries for GO that must activated
+for (uint32 go_entry = 1; go_entry < sGOStorage.MaxEntry; ++go_entry)
+{
+bar.step();
+GameObjectInfo const* goInfo = sGOStorage.LookupEntry<GameObjectInfo>(go_entry);
+if (!goInfo)
+continue;
+
+switch(goInfo->type)
+{
+// scan GO chest with loot including quest items
+case GAMEOBJECT_TYPE_CHEST:
+{
+uint32 loot_id = goInfo->GetLootId();
+
+// find quest loot for GO
+if (goInfo->chest.questId || LootTemplates_Gameobject.HaveQuestLootFor(loot_id))
+{
+mGameObjectForQuestSet.insert(go_entry);
+++count;
+}
+break;
+}
+case GAMEOBJECT_TYPE_GENERIC:
+{
+if (goInfo->_generic.questID) //quests objects
+{
+mGameObjectForQuestSet.insert(go_entry);
+count++;
+}
+break;
+}
+case GAMEOBJECT_TYPE_GOOBER:
+{
+if (goInfo->goober.questId) //quests objects
+{
+mGameObjectForQuestSet.insert(go_entry);
+count++;
+}
+break;
+}
+default:
+break;
+}
+}
+
+sLog.outString();
+sLog.outString(">> Loaded %u GameObjects for quests", count);
+}
+
+bool ObjectMgr::LoadTrinityStrings(char const* table, int32 min_value, int32 max_value)
+{
+int32 start_value = min_value;
+int32 end_value = max_value;
+// some string can have negative indexes range
+if (start_value < 0)
+{
+if (end_value >= start_value)
+{
+sLog.outErrorDb("Table '%s' attempt loaded with invalid range (%d - %d), strings not loaded.",table,min_value,max_value);
+return false;
+}
+
+// real range (max+1,min+1) exaple: (-10,-1000) -> -999...-10+1
+std::swap(start_value,end_value);
+++start_value;
+++end_value;
+}
+else
+{
+if (start_value >= end_value)
+{
+sLog.outErrorDb("Table '%s' attempt loaded with invalid range (%d - %d), strings not loaded.",table,min_value,max_value);
+return false;
+}
+}
+
+// cleanup affected map part for reloading case
+for (TrinityStringLocaleMap::iterator itr = mTrinityStringLocaleMap.begin(); itr != mTrinityStringLocaleMap.end();)
+{
+if (itr->first >= start_value && itr->first < end_value)
+mTrinityStringLocaleMap.erase(itr++);
+else
+++itr;
+}
+
+QueryResult result = WorldDatabase.PQuery("SELECT entry,content_default,content_loc1,content_loc2,content_loc3,content_loc4,content_loc5,content_loc6,content_loc7,content_loc8 FROM %s",table);
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+if (min_value == MIN_TRINITY_STRING_ID) // error only in case internal strings
+sLog.outErrorDb(">> Loaded 0 trinity strings. DB table `%s` is empty. Cannot continue.",table);
+else
+sLog.outString(">> Loaded 0 string templates. DB table `%s` is empty.",table);
+return false;
+}
+
+uint32 count = 0;
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+Field *fields = result->Fetch();
+bar.step();
+
+int32 entry = fields[0].GetInt32();
+
+if (entry == 0)
+{
+sLog.outErrorDb("Table `%s` contain reserved entry 0, ignored.",table);
+continue;
+}
+else if (entry < start_value || entry >= end_value)
+{
+sLog.outErrorDb("Table `%s` contain entry %i out of allowed range (%d - %d), ignored.",table,entry,min_value,max_value);
+continue;
+}
+
+TrinityStringLocale& data = mTrinityStringLocaleMap[entry];
+
+if (data.Content.size() > 0)
+{
+sLog.outErrorDb("Table `%s` contain data for already loaded entry %i (from another table?), ignored.",table,entry);
+continue;
+}
+
+data.Content.resize(1);
+++count;
+
+for (uint8 i = 0; i < TOTAL_LOCALES; ++i)
+{
+std::string str = fields[i + 1].GetString();
+AddLocaleString(str, LocaleConstant(i), data.Content);
+}
+} while (result->NextRow());
+
+sLog.outString();
+if (min_value == MIN_TRINITY_STRING_ID)
+sLog.outString(">> Loaded %u Trinity strings from table %s", count,table);
+else
+sLog.outString(">> Loaded %u string templates from %s", count,table);
+
+return true;
+}
+
+const char *ObjectMgr::GetTrinityString(int32 entry, LocaleConstant locale_idx) const
+{
+if (TrinityStringLocale const *msl = GetTrinityStringLocale(entry))
+{
+if (msl->Content.size() > size_t(locale_idx) && !msl->Content[locale_idx].empty())
+return msl->Content[locale_idx].c_str();
+
+return msl->Content[DEFAULT_LOCALE].c_str();
+}
+
+if (entry > 0)
+sLog.outErrorDb("Entry %i not found in `trinity_string` table.",entry);
+else
+sLog.outErrorDb("Trinity string entry %i not found in DB.",entry);
+return "<error>";
+}
+
+void ObjectMgr::LoadFishingBaseSkillLevel()
+{
+mFishingBaseForArea.clear(); // for reload case
+
+uint32 count = 0;
+QueryResult result = WorldDatabase.Query("SELECT entry,skill FROM skill_fishing_base_level");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `skill_fishing_base_level`, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+uint32 entry = fields[0].GetUInt32();
+int32 skill = fields[1].GetInt32();
+
+AreaTableEntry const* fArea = GetAreaEntryByAreaID(entry);
+if (!fArea)
+{
+sLog.outErrorDb("AreaId %u defined in `skill_fishing_base_level` does not exist",entry);
+continue;
+}
+
+mFishingBaseForArea[entry] = skill;
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u areas for fishing base skill level", count);
+}
+
+bool ObjectMgr::CheckDeclinedNames(std::wstring mainpart, DeclinedName const& names)
+{
+for (uint8 i =0; i < MAX_DECLINED_NAME_CASES; ++i)
+{
+std::wstring wname;
+if (!Utf8toWStr(names.name[i],wname))
+return false;
+
+if (mainpart != GetMainPartOfName(wname,i+1))
+return false;
+}
+return true;
+}
+
+uint32 ObjectMgr::GetAreaTriggerScriptId(uint32 trigger_id)
+{
+AreaTriggerScriptMap::const_iterator i = mAreaTriggerScripts.find(trigger_id);
+if (i!= mAreaTriggerScripts.end())
+return i->second;
+return 0;
+}
+
+SpellScriptsBounds ObjectMgr::GetSpellScriptsBounds(uint32 spell_id)
+{
+return SpellScriptsBounds(mSpellScripts.lower_bound(spell_id),mSpellScripts.upper_bound(spell_id));
+}
+
+SkillRangeType GetSkillRangeType(SkillLineEntry const *pSkill, bool racial)
+{
+switch(pSkill->categoryId)
+{
+case SKILL_CATEGORY_LANGUAGES: return SKILL_RANGE_LANGUAGE;
+case SKILL_CATEGORY_WEAPON:
+if (pSkill->id != SKILL_FIST_WEAPONS)
+return SKILL_RANGE_LEVEL;
+else
+return SKILL_RANGE_MONO;
+case SKILL_CATEGORY_ARMOR:
+case SKILL_CATEGORY_CLASS:
+if (pSkill->id != SKILL_LOCKPICKING)
+return SKILL_RANGE_MONO;
+else
+return SKILL_RANGE_LEVEL;
+case SKILL_CATEGORY_SECONDARY:
+case SKILL_CATEGORY_PROFESSION:
+// not set skills for professions and racial abilities
+if (IsProfessionSkill(pSkill->id))
+return SKILL_RANGE_RANK;
+else if (racial)
+return SKILL_RANGE_NONE;
+else
+return SKILL_RANGE_MONO;
+default:
+case SKILL_CATEGORY_ATTRIBUTES: //not found in dbc
+case SKILL_CATEGORY_GENERIC: //only GENERIC(DND)
+return SKILL_RANGE_NONE;
+}
+}
+
+void ObjectMgr::LoadGameTele()
+{
+m_GameTeleMap.clear(); // for reload case
+
+uint32 count = 0;
+QueryResult result = WorldDatabase.Query("SELECT id, position_x, position_y, position_z, orientation, map, name FROM game_tele");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `game_tele`, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint32 id = fields[0].GetUInt32();
+
+GameTele gt;
+
+gt.position_x = fields[1].GetFloat();
+gt.position_y = fields[2].GetFloat();
+gt.position_z = fields[3].GetFloat();
+gt.orientation = fields[4].GetFloat();
+gt.mapId = fields[5].GetUInt32();
+gt.name = fields[6].GetString();
+
+if (!MapManager::IsValidMapCoord(gt.mapId,gt.position_x,gt.position_y,gt.position_z,gt.orientation))
+{
+sLog.outErrorDb("Wrong position for id %u (name: %s) in `game_tele` table, ignoring.",id,gt.name.c_str());
+continue;
+}
+
+if (!Utf8toWStr(gt.name,gt.wnameLow))
+{
+sLog.outErrorDb("Wrong UTF8 name for id %u in `game_tele` table, ignoring.",id);
+continue;
+}
+
+wstrToLower(gt.wnameLow);
+
+m_GameTeleMap[id] = gt;
+
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u GameTeleports", count);
+}
+
+GameTele const* ObjectMgr::GetGameTele(const std::string& name) const
+{
+// explicit name case
+std::wstring wname;
+if (!Utf8toWStr(name,wname))
+return false;
+
+// converting string that we try to find to lower case
+wstrToLower(wname);
+
+// Alternative first GameTele what contains wnameLow as substring in case no GameTele location found
+const GameTele* alt = NULL;
+for (GameTeleMap::const_iterator itr = m_GameTeleMap.begin(); itr != m_GameTeleMap.end(); ++itr)
+{
+if (itr->second.wnameLow == wname)
+return &itr->second;
+else if (alt == NULL && itr->second.wnameLow.find(wname) != std::wstring::npos)
+alt = &itr->second;
+}
+
+return alt;
+}
+
+bool ObjectMgr::AddGameTele(GameTele& tele)
+{
+// find max id
+uint32 new_id = 0;
+for (GameTeleMap::const_iterator itr = m_GameTeleMap.begin(); itr != m_GameTeleMap.end(); ++itr)
+if (itr->first > new_id)
+new_id = itr->first;
+
+// use next
+++new_id;
+
+if (!Utf8toWStr(tele.name,tele.wnameLow))
+return false;
+
+wstrToLower(tele.wnameLow);
+
+m_GameTeleMap[new_id] = tele;
+
+WorldDatabase.PExecute("INSERT INTO game_tele (id,position_x,position_y,position_z,orientation,map,name) VALUES (%u,%f,%f,%f,%f,%d,'%s')",
+new_id,tele.position_x,tele.position_y,tele.position_z,tele.orientation,tele.mapId,tele.name.c_str());
+return true;
+}
+
+bool ObjectMgr::DeleteGameTele(const std::string& name)
+{
+// explicit name case
+std::wstring wname;
+if (!Utf8toWStr(name,wname))
+return false;
+
+// converting string that we try to find to lower case
+wstrToLower(wname);
+
+for (GameTeleMap::iterator itr = m_GameTeleMap.begin(); itr != m_GameTeleMap.end(); ++itr)
+{
+if (itr->second.wnameLow == wname)
+{
+WorldDatabase.PExecute("DELETE FROM game_tele WHERE name = '%s'",itr->second.name.c_str());
+m_GameTeleMap.erase(itr);
+return true;
+}
+}
+
+return false;
+}
+
+void ObjectMgr::LoadMailLevelRewards()
+{
+m_mailLevelRewardMap.clear(); // for reload case
+
+uint32 count = 0;
+QueryResult result = WorldDatabase.Query("SELECT level, raceMask, mailTemplateId, senderEntry FROM mail_level_reward");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `mail_level_reward`, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+do
+{
+bar.step();
+
+Field *fields = result->Fetch();
+
+uint8 level = fields[0].GetUInt8();
+uint32 raceMask = fields[1].GetUInt32();
+uint32 mailTemplateId = fields[2].GetUInt32();
+uint32 senderEntry = fields[3].GetUInt32();
+
+if (level > MAX_LEVEL)
+{
+sLog.outErrorDb("Table `mail_level_reward` have data for level %u that more supported by client (%u), ignoring.",level,MAX_LEVEL);
+continue;
+}
+
+if (!(raceMask & RACEMASK_ALL_PLAYABLE))
+{
+sLog.outErrorDb("Table `mail_level_reward` have raceMask (%u) for level %u that not include any player races, ignoring.",raceMask,level);
+continue;
+}
+
+if (!sMailTemplateStore.LookupEntry(mailTemplateId))
+{
+sLog.outErrorDb("Table `mail_level_reward` have invalid mailTemplateId (%u) for level %u that invalid not include any player races, ignoring.",mailTemplateId,level);
+continue;
+}
+
+if (!GetCreatureTemplateStore(senderEntry))
+{
+sLog.outErrorDb("Table `mail_level_reward` have not existed sender creature entry (%u) for level %u that invalid not include any player races, ignoring.",senderEntry,level);
+continue;
+}
+
+m_mailLevelRewardMap[level].push_back(MailLevelReward(raceMask,mailTemplateId,senderEntry));
+
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u level dependent mail rewards,", count);
+}
+
+bool ObjectMgr::AddSpellToTrainer(uint32 entry, uint32 spell, Field *fields, std::set<uint32> *skip_trainers, std::set<uint32> *talentIds)
+{
+if (entry >= TRINITY_TRAINER_START_REF)
+return false;
+
+CreatureInfo const* cInfo = GetCreatureTemplate(entry);
+if (!cInfo)
+{
+sLog.outErrorDb("Table `npc_trainer` have entry for not existed creature template (Entry: %u), ignore", entry);
+return false;
+}
+
+if (!(cInfo->npcflag & UNIT_NPC_FLAG_TRAINER))
+{
+if (skip_trainers->find(entry) == skip_trainers->end())
+{
+sLog.outErrorDb("Table `npc_trainer` have data for not creature template (Entry: %u) without trainer flag, ignore", entry);
+skip_trainers->insert(entry);
+}
+return false;
+}
+
+SpellEntry const *spellinfo = sSpellStore.LookupEntry(spell);
+if (!spellinfo)
+{
+sLog.outErrorDb("Table `npc_trainer` for Trainer (Entry: %u) has non existing spell %u, ignore", entry,spell);
+return false;
+}
+
+if (!SpellMgr::IsSpellValid(spellinfo))
+{
+sLog.outErrorDb("Table `npc_trainer` for Trainer (Entry: %u) has broken learning spell %u, ignore", entry, spell);
+return false;
+}
+
+if (GetTalentSpellCost(spell))
+{
+if (talentIds->count(spell) == 0)
+{
+sLog.outErrorDb("Table `npc_trainer` has talent as learning spell %u, ignore", spell);
+talentIds->insert(spell);
+}
+return false;
+}
+
+TrainerSpellData& data = m_mCacheTrainerSpellMap[entry];
+
+TrainerSpell& trainerSpell = data.spellList[spell];
+trainerSpell.spell = spell;
+trainerSpell.spellCost = fields[2].GetUInt32();
+trainerSpell.reqSkill = fields[3].GetUInt32();
+trainerSpell.reqSkillValue = fields[4].GetUInt32();
+trainerSpell.reqLevel = fields[5].GetUInt32();
+
+if (!trainerSpell.reqLevel)
+trainerSpell.reqLevel = spellinfo->spellLevel;
+
+// calculate learned spell for profession case when stored cast-spell
+trainerSpell.learnedSpell[0] = spell;
+for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+{
+if (spellinfo->Effect[i] != SPELL_EFFECT_LEARN_SPELL)
+continue;
+if (trainerSpell.learnedSpell[0] == spell)
+trainerSpell.learnedSpell[0] = 0;
+// player must be able to cast spell on himself
+if (spellinfo->EffectImplicitTargetA[i] != 0 && spellinfo->EffectImplicitTargetA[i] != TARGET_UNIT_TARGET_ALLY
+&& spellinfo->EffectImplicitTargetA[i] != TARGET_UNIT_TARGET_ANY && spellinfo->EffectImplicitTargetA[i] != TARGET_UNIT_CASTER)
+{
+sLog.outErrorDb("Table `npc_trainer` has spell %u for trainer entry %u with learn effect which has incorrect target type, ignoring learn effect!", spell, entry);
+continue;
+}
+
+trainerSpell.learnedSpell[i] = spellinfo->EffectTriggerSpell[i];
+}
+
+for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+{
+if (!trainerSpell.learnedSpell[i])
+continue;
+if (SpellMgr::IsProfessionSpell(trainerSpell.learnedSpell[i]))
+{
+data.trainerType = 2;
+break;
+}
+}
+return true;
+}
+int ObjectMgr::LoadReferenceTrainer(uint32 trainer, int32 spell, std::set<uint32> *skip_trainers, std::set<uint32> *talentIds)
+{
+QueryResult result = WorldDatabase.PQuery("SELECT entry, spell,spellcost,reqskill,reqskillvalue,reqlevel FROM npc_trainer WHERE entry='%d'", spell);
+if (!result)
+return 0;
+
+uint32 count = 0;
+do
+{
+
+Field* fields = result->Fetch();
+
+int32 spell = fields[1].GetInt32();
+if (spell < 0)
+count += this->LoadReferenceTrainer(trainer, -spell, skip_trainers, talentIds);
+else if (this->AddSpellToTrainer(trainer, uint32(spell), fields, skip_trainers, talentIds))
+++count;
+} while (result->NextRow());
+
+return count;
+}
+
+void ObjectMgr::LoadTrainerSpell()
+{
+// For reload case
+for (CacheTrainerSpellMap::iterator itr = m_mCacheTrainerSpellMap.begin(); itr != m_mCacheTrainerSpellMap.end(); ++itr)
+itr->second.Clear();
+m_mCacheTrainerSpellMap.clear();
+
+std::set<uint32> skip_trainers;
+
+QueryResult result = WorldDatabase.Query("SELECT entry, spell,spellcost,reqskill,reqskillvalue,reqlevel FROM npc_trainer");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `npc_trainer`, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+std::set<uint32> talentIds;
+
+uint32 count = 0;
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+
+uint32 entry = fields[0].GetUInt32();
+int32 spell = fields[1].GetInt32();
+if (spell < 0)
+count += this->LoadReferenceTrainer(entry, -spell, &skip_trainers, &talentIds);
+else if (this->AddSpellToTrainer(entry, uint32(spell), fields, &skip_trainers, &talentIds))
+++count;
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %d Trainers", count);
+}
+
+int ObjectMgr::LoadReferenceVendor(int32 vendor, int32 item, std::set<uint32> *skip_vendors)
+{
+// find all items from the reference vendor
+QueryResult result = WorldDatabase.PQuery("SELECT item, maxcount, incrtime, ExtendedCost FROM npc_vendor WHERE entry='%d' ORDER BY slot ASC", item);
+if (!result)
+return 0;
+
+uint32 count = 0;
+do
+{
+Field* fields = result->Fetch();
+
+int32 item_id = fields[0].GetInt32();
+
+// if item is a negative, its a reference
+if (item_id < 0)
+count += LoadReferenceVendor(vendor, -item_id, skip_vendors);
+else
+{
+int32 maxcount = fields[1].GetInt32();
+uint32 incrtime = fields[2].GetUInt32();
+uint32 ExtendedCost = fields[3].GetUInt32();
+
+if (!IsVendorItemValid(vendor, item_id, maxcount, incrtime, ExtendedCost, NULL, skip_vendors))
+continue;
+
+VendorItemData& vList = m_mCacheVendorItemMap[vendor];
+
+vList.AddItem(item_id, maxcount, incrtime, ExtendedCost);
+++count;
+}
+
+} while (result->NextRow());
+
+return count;
+}
+
+void ObjectMgr::LoadVendors()
+{
+// For reload case
+for (CacheVendorItemMap::iterator itr = m_mCacheVendorItemMap.begin(); itr != m_mCacheVendorItemMap.end(); ++itr)
+itr->second.Clear();
+m_mCacheVendorItemMap.clear();
+
+std::set<uint32> skip_vendors;
+
+QueryResult result = WorldDatabase.Query("SELECT entry, item, maxcount, incrtime, ExtendedCost FROM npc_vendor ORDER BY entry, slot ASC");
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `npc_vendor`, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+uint32 count = 0;
+do
+{
+bar.step();
+Field* fields = result->Fetch();
+
+uint32 entry = fields[0].GetUInt32();
+int32 item_id = fields[1].GetInt32();
+
+// if item is a negative, its a reference
+if (item_id < 0)
+count += LoadReferenceVendor(entry, -item_id, &skip_vendors);
+else
+{
+int32 maxcount = fields[2].GetInt32();
+uint32 incrtime = fields[3].GetUInt32();
+uint32 ExtendedCost = fields[4].GetUInt32();
+
+if (!IsVendorItemValid(entry, item_id, maxcount, incrtime, ExtendedCost, NULL, &skip_vendors))
+continue;
+
+VendorItemData& vList = m_mCacheVendorItemMap[entry];
+
+vList.AddItem(item_id, maxcount, incrtime, ExtendedCost);
+++count;
+}
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %d Vendors ", count);
+}
+
+void ObjectMgr::LoadNpcTextId()
+{
+
+m_mCacheNpcTextIdMap.clear();
+
+QueryResult result = WorldDatabase.Query("SELECT npc_guid, textid FROM npc_gossip");
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `npc_gossip`, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+uint32 count = 0;
+uint32 guid,textid;
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+
+guid = fields[0].GetUInt32();
+textid = fields[1].GetUInt32();
+
+if (!GetCreatureData(guid))
+{
+sLog.outErrorDb("Table `npc_gossip` have not existed creature (GUID: %u) entry, ignore. ",guid);
+continue;
+}
+if (!GetGossipText(textid))
+{
+sLog.outErrorDb("Table `npc_gossip` for creature (GUID: %u) have wrong Textid (%u), ignore. ", guid, textid);
+continue;
+}
+
+m_mCacheNpcTextIdMap[guid] = textid ;
+++count;
+
+} while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %d NpcTextId ", count);
+}
+
+void ObjectMgr::LoadGossipMenu()
+{
+m_mGossipMenusMap.clear();
+
+QueryResult result = WorldDatabase.Query("SELECT entry, text_id FROM gossip_menu");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded `gossip_menu`, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+uint32 count = 0;
+
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+
+GossipMenus gMenu;
+
+gMenu.entry = fields[0].GetUInt32();
+gMenu.text_id = fields[1].GetUInt32();
+
+if (!GetGossipText(gMenu.text_id))
+{
+sLog.outErrorDb("Table gossip_menu entry %u are using non-existing text_id %u", gMenu.entry, gMenu.text_id);
+continue;
+}
+
+m_mGossipMenusMap.insert(GossipMenusMap::value_type(gMenu.entry, gMenu));
+
+++count;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u gossip_menu entries", count);
+}
+
+void ObjectMgr::LoadGossipMenuItems()
+{
+m_mGossipMenuItemsMap.clear();
+
+QueryResult result = WorldDatabase.Query(
+"SELECT menu_id, id, option_icon, option_text, option_id, npc_option_npcflag, "
+"action_menu_id, action_poi_id, action_script_id, box_coded, box_money, box_text "
+"FROM gossip_menu_option ORDER BY menu_id, id");
+
+if (!result)
+{
+barGoLink bar(1);
+
+bar.step();
+
+sLog.outString();
+sLog.outErrorDb(">> Loaded gossip_menu_option, table is empty!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+uint32 count = 0;
+
+std::set<uint32> gossipScriptSet;
+
+for (ScriptMapMap::const_iterator itr = sGossipScripts.begin(); itr != sGossipScripts.end(); ++itr)
+gossipScriptSet.insert(itr->first);
+
+do
+{
+bar.step();
+
+Field* fields = result->Fetch();
+
+GossipMenuItems gMenuItem;
+
+gMenuItem.menu_id = fields[0].GetUInt32();
+gMenuItem.id = fields[1].GetUInt32();
+gMenuItem.option_icon = fields[2].GetUInt8();
+gMenuItem.option_text = fields[3].GetString();
+gMenuItem.option_id = fields[4].GetUInt32();
+gMenuItem.npc_option_npcflag = fields[5].GetUInt32();
+gMenuItem.action_menu_id = fields[6].GetUInt32();
+gMenuItem.action_poi_id = fields[7].GetUInt32();
+gMenuItem.action_script_id = fields[8].GetUInt32();
+gMenuItem.box_coded = fields[9].GetUInt8() != 0;
+gMenuItem.box_money = fields[10].GetUInt32();
+gMenuItem.box_text = fields[11].GetString();
+
+if (gMenuItem.option_icon >= GOSSIP_ICON_MAX)
+{
+sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u has unknown icon id %u. Replacing with GOSSIP_ICON_CHAT", gMenuItem.menu_id, gMenuItem.id, gMenuItem.option_icon);
+gMenuItem.option_icon = GOSSIP_ICON_CHAT;
+}
+
+if (gMenuItem.option_id >= GOSSIP_OPTION_MAX)
+sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u has unknown option id %u. Option will not be used", gMenuItem.menu_id, gMenuItem.id, gMenuItem.option_id);
+
+if (gMenuItem.action_poi_id && !GetPointOfInterest(gMenuItem.action_poi_id))
+{
+sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u use non-existing action_poi_id %u, ignoring", gMenuItem.menu_id, gMenuItem.id, gMenuItem.action_poi_id);
+gMenuItem.action_poi_id = 0;
+}
+
+if (gMenuItem.action_script_id)
+{
+if (gMenuItem.option_id != GOSSIP_OPTION_GOSSIP)
+{
+sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u have action_script_id %u but option_id is not GOSSIP_OPTION_GOSSIP, ignoring", gMenuItem.menu_id, gMenuItem.id, gMenuItem.action_script_id);
+continue;
+}
+
+if (sGossipScripts.find(gMenuItem.action_script_id) == sGossipScripts.end())
+{
+sLog.outErrorDb("Table gossip_menu_option for menu %u, id %u have action_script_id %u that does not exist in `gossip_scripts`, ignoring", gMenuItem.menu_id, gMenuItem.id, gMenuItem.action_script_id);
+continue;
+}
+
+gossipScriptSet.erase(gMenuItem.action_script_id);
+}
+
+m_mGossipMenuItemsMap.insert(GossipMenuItemsMap::value_type(gMenuItem.menu_id, gMenuItem));
+
+++count;
+
+}
+while (result->NextRow());
+
+if (!gossipScriptSet.empty())
+{
+for (std::set<uint32>::const_iterator itr = gossipScriptSet.begin(); itr != gossipScriptSet.end(); ++itr)
+sLog.outErrorDb("Table `gossip_scripts` contain unused script, id %u.", *itr);
+}
+
+sLog.outString();
+sLog.outString(">> Loaded %u gossip_menu_option entries", count);
+}
+
+void ObjectMgr::AddVendorItem(uint32 entry,uint32 item, int32 maxcount, uint32 incrtime, uint32 extendedcost, bool savetodb)
+{
+VendorItemData& vList = m_mCacheVendorItemMap[entry];
+vList.AddItem(item, maxcount, incrtime, extendedcost);
+
+if (savetodb)
+WorldDatabase.PExecute("INSERT INTO npc_vendor (entry,item,maxcount,incrtime,extendedcost) VALUES('%u','%u','%u','%u','%u')", entry, item, maxcount, incrtime, extendedcost);
+}
+
+bool ObjectMgr::RemoveVendorItem(uint32 entry,uint32 item, bool savetodb)
+{
+CacheVendorItemMap::iterator iter = m_mCacheVendorItemMap.find(entry);
+if (iter == m_mCacheVendorItemMap.end())
+return false;
+
+if(!iter->second.RemoveItem(item))
+return false;
+
+if (savetodb) WorldDatabase.PExecute("DELETE FROM npc_vendor WHERE entry='%u' AND item='%u'",entry, item);
+return true;
+}
+
+bool ObjectMgr::IsVendorItemValid(uint32 vendor_entry, uint32 item_id, int32 maxcount, uint32 incrtime, uint32 ExtendedCost, Player* pl, std::set<uint32>* skip_vendors, uint32 ORnpcflag) const
+{
+CreatureInfo const* cInfo = GetCreatureTemplate(vendor_entry);
+if (!cInfo)
+{
+if (pl)
+ChatHandler(pl).SendSysMessage(LANG_COMMAND_VENDORSELECTION);
+else
+sLog.outErrorDb("Table `(game_event_)npc_vendor` have data for not existed creature template (Entry: %u), ignore", vendor_entry);
+return false;
+}
+
+if (!((cInfo->npcflag | ORnpcflag) & UNIT_NPC_FLAG_VENDOR))
+{
+if (!skip_vendors || skip_vendors->count(vendor_entry) == 0)
+{
+if (pl)
+ChatHandler(pl).SendSysMessage(LANG_COMMAND_VENDORSELECTION);
+else
+sLog.outErrorDb("Table `(game_event_)npc_vendor` have data for not creature template (Entry: %u) without vendor flag, ignore", vendor_entry);
+
+if (skip_vendors)
+skip_vendors->insert(vendor_entry);
+}
+return false;
+}
+
+if (!GetItemPrototype(item_id))
+{
+if (pl)
+ChatHandler(pl).PSendSysMessage(LANG_ITEM_NOT_FOUND, item_id);
+else
+sLog.outErrorDb("Table `(game_event_)npc_vendor` for Vendor (Entry: %u) have in item list non-existed item (%u), ignore", vendor_entry, item_id);
+return false;
+}
+
+if (ExtendedCost && !sItemExtendedCostStore.LookupEntry(ExtendedCost))
+{
+if (pl)
+ChatHandler(pl).PSendSysMessage(LANG_EXTENDED_COST_NOT_EXIST, ExtendedCost);
+else
+sLog.outErrorDb("Table `(game_event_)npc_vendor` have Item (Entry: %u) with wrong ExtendedCost (%u) for vendor (%u), ignore", item_id, ExtendedCost, vendor_entry);
+return false;
+}
+
+if (maxcount > 0 && incrtime == 0)
+{
+if (pl)
+ChatHandler(pl).PSendSysMessage("MaxCount != 0 (%u) but IncrTime == 0", maxcount);
+else
+sLog.outErrorDb("Table `(game_event_)npc_vendor` has `maxcount` (%u) for item %u of vendor (Entry: %u) but `incrtime`=0, ignore", maxcount, item_id, vendor_entry);
+return false;
+}
+else if (maxcount == 0 && incrtime > 0)
+{
+if (pl)
+ChatHandler(pl).PSendSysMessage("MaxCount == 0 but IncrTime<>= 0");
+else
+sLog.outErrorDb("Table `(game_event_)npc_vendor` has `maxcount`=0 for item %u of vendor (Entry: %u) but `incrtime`<>0, ignore", item_id, vendor_entry);
+return false;
+}
+
+VendorItemData const* vItems = GetNpcVendorItemList(vendor_entry);
+if (!vItems)
+return true; // later checks for non-empty lists
+
+if (vItems->FindItemCostPair(item_id, ExtendedCost))
+{
+if (pl)
+ChatHandler(pl).PSendSysMessage(LANG_ITEM_ALREADY_IN_LIST, item_id, ExtendedCost);
+else
+sLog.outErrorDb( "Table `npc_vendor` has duplicate items %u (with extended cost %u) for vendor (Entry: %u), ignoring", item_id, ExtendedCost, vendor_entry);
+return false;
+}
+
+if (vItems->GetItemCount() >= MAX_VENDOR_ITEMS)
+{
+if (pl)
+ChatHandler(pl).SendSysMessage(LANG_COMMAND_ADDVENDORITEMITEMS);
+else
+sLog.outErrorDb("Table `npc_vendor` has too many items (%u >= %i) for vendor (Entry: %u), ignore", vItems->GetItemCount(), MAX_VENDOR_ITEMS, vendor_entry);
+return false;
+}
+
+return true;
+}
+
+void ObjectMgr::LoadScriptNames()
+{
+m_scriptNames.push_back("");
+QueryResult result = WorldDatabase.Query(
+"SELECT DISTINCT(ScriptName) FROM achievement_criteria_data WHERE ScriptName <> '' AND type = 11 "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM battleground_template WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM creature_template WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM gameobject_template WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM item_template WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM areatrigger_scripts WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM spell_script_names WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM transports WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM game_weather WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM conditions WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(ScriptName) FROM outdoorpvp_template WHERE ScriptName <> '' "
+"UNION "
+"SELECT DISTINCT(script) FROM instance_template WHERE script <> ''");
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outErrorDb(">> Loaded empty set of Script Names!");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+
+uint32 count = 1;
+
+do
+{
+bar.step();
+m_scriptNames.push_back((*result)[0].GetString());
+++count;
+}
+while (result->NextRow());
+
+std::sort(m_scriptNames.begin(), m_scriptNames.end());
+sLog.outString();
+sLog.outString(">> Loaded %d Script Names", count);
+}
+
+uint32 ObjectMgr::GetScriptId(const char *name)
+{
+// use binary search to find the script name in the sorted vector
+// assume "" is the first element
+if (!name) return 0;
+ScriptNameMap::const_iterator itr =
+std::lower_bound(m_scriptNames.begin(), m_scriptNames.end(), name);
+if (itr == m_scriptNames.end() || *itr != name) return 0;
+return itr - m_scriptNames.begin();
+}
+
+void ObjectMgr::CheckScripts(ScriptsType type, std::set<int32>& ids)
+{
+ScriptMapMap *scripts = GetScriptsMapByType(type);
+if (!scripts)
+return;
+for (ScriptMapMap::const_iterator itrMM = scripts->begin(); itrMM != scripts->end(); ++itrMM)
+{
+for (ScriptMap::const_iterator itrM = itrMM->second.begin(); itrM != itrMM->second.end(); ++itrM)
+{
+switch(itrM->second.command)
+{
+case SCRIPT_COMMAND_TALK:
+{
+if (!GetTrinityStringLocale (itrM->second.Talk.TextID))
+sLog.outErrorDb("Table `db_script_string` not has string id %u used db script (ID: %u)", itrM->second.Talk.TextID, itrMM->first);
+
+if (ids.find(itrM->second.Talk.TextID) != ids.end())
+ids.erase(itrM->second.Talk.TextID);
+}
+default:
+break;
+}
+}
+}
+}
+
+void ObjectMgr::LoadDbScriptStrings()
+{
+LoadTrinityStrings("db_script_string", MIN_DB_SCRIPT_STRING_ID, MAX_DB_SCRIPT_STRING_ID);
+
+std::set<int32> ids;
+
+for (int32 i = MIN_DB_SCRIPT_STRING_ID; i < MAX_DB_SCRIPT_STRING_ID; ++i)
+if (GetTrinityStringLocale(i))
+ids.insert(i);
+
+for (int type = SCRIPTS_FIRST; type < SCRIPTS_LAST; ++type)
+CheckScripts(ScriptsType(type), ids);
+
+for (std::set<int32>::const_iterator itr = ids.begin(); itr != ids.end(); ++itr)
+sLog.outErrorDb("Table `db_script_string` has unused string id %u", *itr);
+}
+
+// Functions for scripting access
+uint32 GetAreaTriggerScriptId(uint32 trigger_id)
+{
+return sObjectMgr.GetAreaTriggerScriptId(trigger_id);
+}
+
+bool LoadTrinityStrings(char const* table, int32 start_value, int32 end_value)
+{
+// MAX_DB_SCRIPT_STRING_ID is max allowed negative value for scripts (scrpts can use only more deep negative values
+// start/end reversed for negative values
+if (start_value > MAX_DB_SCRIPT_STRING_ID || end_value >= start_value)
+{
+sLog.outErrorDb("Table '%s' load attempted with range (%d - %d) reserved by Trinity, strings not loaded.",table,start_value,end_value+1);
+return false;
+}
+
+return sObjectMgr.LoadTrinityStrings(table, start_value, end_value);
+}
+
+uint32 GetScriptId(const char *name)
+{
+return sObjectMgr.GetScriptId(name);
+}
+
+ObjectMgr::ScriptNameMap & GetScriptNames()
+{
+return sObjectMgr.GetScriptNames();
+}
+
+GameObjectInfo const *GetGameObjectInfo(uint32 id)
+{
+return sObjectMgr.GetGameObjectInfo(id);
+}
+
+CreatureInfo const *GetCreatureInfo(uint32 id)
+{
+return sObjectMgr.GetCreatureTemplate(id);
+}
+
+CreatureInfo const* GetCreatureTemplateStore(uint32 entry)
+{
+return sCreatureStorage.LookupEntry<CreatureInfo>(entry);
+}
+
+Quest const* GetQuestTemplateStore(uint32 entry)
+{
+return sObjectMgr.GetQuestTemplate(entry);
+}
+
+CreatureBaseStats const* ObjectMgr::GetCreatureBaseStats(uint8 level, uint8 unitClass)
+{
+CreatureBaseStatsMap::const_iterator it = m_creatureBaseStatsMap.find(MAKE_PAIR16(level,unitClass));
+
+if (it != m_creatureBaseStatsMap.end())
+return &(it->second);
+
+struct DefaultCreatureBaseStats : public CreatureBaseStats
+{
+DefaultCreatureBaseStats()
+{
+BaseArmor = 1;
+for (uint8 j = 0; j < MAX_CREATURE_BASE_HP; ++j)
+BaseHealth[j] = 1;
+BaseMana = 0;
+}
+};
+static const DefaultCreatureBaseStats def_stats;
+return &def_stats;
+}
+
+void ObjectMgr::LoadCreatureClassLevelStats()
+{
+QueryResult result = WorldDatabase.Query("SELECT level, class, basehp0, basehp1, basehp2, basemana, basearmor FROM creature_classlevelstats");
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 creature base stats. DB table `creature_classlevelstats` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+uint32 counter = 0;
+
+do
+{
+Field *fields = result->Fetch();
+
+uint8 Level = fields[0].GetUInt8();
+uint8 Class = fields[1].GetUInt8();
+
+CreatureBaseStats stats;
+for (uint8 i = 0; i < MAX_CREATURE_BASE_HP; ++i)
+stats.BaseHealth[i] = fields[i + 2].GetUInt32();
+stats.BaseMana = fields[5].GetUInt32();
+stats.BaseArmor = fields[6].GetUInt32();
+
+if (!Class || ((1 << (Class - 1)) & CLASSMASK_ALL_CREATURES) == 0)
+sLog.outErrorDb("Creature base stats for level %u has invalid class %u",
+Level, Class);
+
+for (uint8 i = 0; i < MAX_CREATURE_BASE_HP; ++i)
+{
+if (stats.BaseHealth[i] < 1)
+{
+sLog.outErrorDb("Creature base stats for class %u, level %u has invalid zero base HP[%u] - set to 1",
+Class, Level, i);
+stats.BaseHealth[i] = 1;
+}
+}
+
+m_creatureBaseStatsMap[MAKE_PAIR16(Level, Class)] = stats;
+
+bar.step();
+++counter;
+}
+while (result->NextRow());
+
+for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
+{
+CreatureInfo const* info = sCreatureStorage.LookupEntry<CreatureInfo>(i);
+if (!info)
+continue;
+
+for (uint16 lvl = info->minlevel; lvl <= info->maxlevel; ++lvl)
+{
+if (m_creatureBaseStatsMap.find(MAKE_PAIR16(lvl, info->unit_class)) == m_creatureBaseStatsMap.end())
+sLog.outErrorDb("Missing base stats for creature class %u level %u", info->unit_class, lvl);
+}
+}
+
+sLog.outString();
+sLog.outString(">> Loaded %u creature base stats.", counter);
+}
+
+void ObjectMgr::LoadFactionChangeAchievements()
+{
+QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_achievement");
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 faction change achievement pairs. DB table `player_factionchange_achievement` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+uint32 counter = 0;
+
+do
+{
+Field *fields = result->Fetch();
+
+uint32 alliance = fields[0].GetUInt32();
+uint32 horde = fields[1].GetUInt32();
+
+if (!sAchievementStore.LookupEntry(alliance))
+sLog.outErrorDb("Achievement %u referenced in `player_factionchange_achievement` does not exist, pair skipped!", alliance);
+else if (!sAchievementStore.LookupEntry(horde))
+sLog.outErrorDb("Achievement %u referenced in `player_factionchange_achievement` does not exist, pair skipped!", horde);
+else
+factionchange_achievements[alliance] = horde;
+
+bar.step();
+++counter;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u faction change achievement pairs.", counter);
+}
+
+void ObjectMgr::LoadFactionChangeItems()
+{
+QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_items");
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 faction change item pairs. DB table `player_factionchange_items` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+uint32 counter = 0;
+
+do
+{
+Field *fields = result->Fetch();
+
+uint32 alliance = fields[0].GetUInt32();
+uint32 horde = fields[1].GetUInt32();
+
+if (!GetItemPrototype(alliance))
+sLog.outErrorDb("Item %u referenced in `player_factionchange_items` does not exist, pair skipped!", alliance);
+else if (!GetItemPrototype(horde))
+sLog.outErrorDb("Item %u referenced in `player_factionchange_items` does not exist, pair skipped!", horde);
+else
+factionchange_items[alliance] = horde;
+
+bar.step();
+++counter;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u faction change item pairs.", counter);
+}
+
+void ObjectMgr::LoadFactionChangeSpells()
+{
+QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_spells");
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 faction change spell pairs. DB table `player_factionchange_spells` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+uint32 counter = 0;
+
+do
+{
+Field *fields = result->Fetch();
+
+uint32 alliance = fields[0].GetUInt32();
+uint32 horde = fields[1].GetUInt32();
+
+if (!sSpellStore.LookupEntry(alliance))
+sLog.outErrorDb("Spell %u referenced in `player_factionchange_spells` does not exist, pair skipped!", alliance);
+else if (!sSpellStore.LookupEntry(horde))
+sLog.outErrorDb("Spell %u referenced in `player_factionchange_spells` does not exist, pair skipped!", horde);
+else
+factionchange_spells[alliance] = horde;
+
+bar.step();
+++counter;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u faction change spell pairs.", counter);
+}
+
+void ObjectMgr::LoadFactionChangeReputations()
+{
+QueryResult result = WorldDatabase.Query("SELECT alliance_id, horde_id FROM player_factionchange_reputations");
+
+if (!result)
+{
+barGoLink bar(1);
+bar.step();
+sLog.outString();
+sLog.outString(">> Loaded 0 faction change reputation pairs. DB table `player_factionchange_reputations` is empty.");
+return;
+}
+
+barGoLink bar(result->GetRowCount());
+uint32 counter = 0;
+
+do
+{
+Field *fields = result->Fetch();
+
+uint32 alliance = fields[0].GetUInt32();
+uint32 horde = fields[1].GetUInt32();
+
+if (!sFactionStore.LookupEntry(alliance))
+sLog.outErrorDb("Reputation %u referenced in `player_factionchange_reputations` does not exist, pair skipped!", alliance);
+else if (!sFactionStore.LookupEntry(horde))
+sLog.outErrorDb("Reputation %u referenced in `player_factionchange_reputations` does not exist, pair skipped!", horde);
+else
+factionchange_reputations[alliance] = horde;
+
+bar.step();
+++counter;
+}
+while (result->NextRow());
+
+sLog.outString();
+sLog.outString(">> Loaded %u faction change reputation pairs.", counter);
+}
+
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -105,6 +105,8 @@
 
     m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
     m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
     if (!isBGGroup())
     {
         Player *leader = sObjectMgr.GetPlayer(guid);
@@ -116,11 +118,7 @@
 
         Player::ConvertInstancesToGroup(leader, this, guid);
 
-        if (!AddMember(guid, name))
-            return false;
-
         // store group in database
-        SQLTransaction trans = CharacterDatabase.BeginTransaction();
         trans->PAppend("DELETE FROM groups WHERE guid ='%u'", lowguid);
         trans->PAppend("DELETE FROM group_member WHERE guid ='%u'", lowguid);
         trans->PAppend("INSERT INTO groups (guid,leaderGuid,lootMethod,looterGuid,lootThreshold,icon1,icon2,icon3,icon4,icon5,icon6,icon7,icon8,groupType,difficulty,raiddifficulty) "
@@ -128,10 +126,13 @@
             lowguid, GUID_LOPART(m_leaderGuid), uint32(m_lootMethod),
             GUID_LOPART(m_looterGuid), uint32(m_lootThreshold), m_targetIcons[0], m_targetIcons[1], m_targetIcons[2], m_targetIcons[3], m_targetIcons[4], m_targetIcons[5], m_targetIcons[6], m_targetIcons[7], uint8(m_groupType), uint32(m_dungeonDifficulty), m_raidDifficulty);
 
+    }
+
+    if (!AddMember(guid, name, trans))
+        return false;
+
+    if (!isBGGroup())
         CharacterDatabase.CommitTransaction(trans);
-    }
-    else if (!AddMember(guid, name))
-        return false;
 
     return true;
 }
@@ -307,12 +308,12 @@
     return NULL;
 }
 
-bool Group::AddMember(const uint64 &guid, const char* name)
+bool Group::AddMember(const uint64 &guid, const char* name, SQLTransaction& trans)
 {
     if (isLfgQueued())
         sLFGMgr.Leave(NULL, this);
 
-    if (!_addMember(guid, name))
+    if (!_addMember(guid, name, trans))
         return false;
 
     SendUpdate();
@@ -1213,7 +1214,7 @@
     }
 }
 
-bool Group::_addMember(const uint64 &guid, const char* name)
+bool Group::_addMember(const uint64 &guid, const char* name, SQLTransaction& trans)
 {
     // get first not-full group
     uint8 groupid = 0;
@@ -1233,10 +1234,10 @@
             return false;
     }
 
-    return _addMember(guid, name, groupid);
+    return _addMember(guid, name, groupid, trans);
 }
 
-bool Group::_addMember(const uint64 &guid, const char* name, uint8 group)
+bool Group::_addMember(const uint64 &guid, const char* name, uint8 group, SQLTransaction& trans)
 {
     if (IsFull())
         return false;
@@ -1280,7 +1281,7 @@
 
     // insert into the table if we're not a battleground group
     if (!isBGGroup())
-        CharacterDatabase.PExecute("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)", GUID_LOPART(m_guid), GUID_LOPART(member.guid), member.flags, member.group, member.roles);
+        trans->PAppend("INSERT INTO group_member (guid, memberGuid, memberFlags, subgroup, roles) VALUES(%u, %u, %u, %u, %u)", GUID_LOPART(m_guid), GUID_LOPART(member.guid), member.flags, member.group, member.roles);
 
     return true;
 }
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -197,7 +197,7 @@
         uint32 RemoveInvite(Player *player);
         void   RemoveAllInvites();
         bool   AddLeaderInvite(Player *player);
-        bool   AddMember(const uint64 &guid, const char* name);
+        bool   AddMember(const uint64 &guid, const char* name, SQLTransaction& trans);
         uint32 RemoveMember(const uint64 &guid, const RemoveMethod &method = GROUP_REMOVEMETHOD_DEFAULT);
         void   ChangeLeader(const uint64 &guid);
         void   SetLootMethod(LootMethod method) { m_lootMethod = method; }
@@ -412,8 +412,8 @@
         void BroadcastGroupUpdate(void);
 
     protected:
-        bool _addMember(const uint64 &guid, const char* name);
-        bool _addMember(const uint64 &guid, const char* name, uint8 group);
+        bool _addMember(const uint64 &guid, const char* name, SQLTransaction& trans);
+        bool _addMember(const uint64 &guid, const char* name, uint8 group, SQLTransaction& trans);
         bool _removeMember(const uint64 &guid);             // returns true if leader has changed
         void _setLeader(const uint64 &guid);
 
diff --git a/src/server/game/Miscellaneous/SharedDefines.h b/src/server/game/Miscellaneous/SharedDefines.h
--- a/src/server/game/Miscellaneous/SharedDefines.h
+++ b/src/server/game/Miscellaneous/SharedDefines.h
@@ -490,7 +490,7 @@
 #define SPELL_ATTR_EX6_UNK26                      0x04000000            // 26 not set in 3.0.3
 #define SPELL_ATTR_EX6_UNK27                      0x08000000            // 27 not set in 3.0.3
 #define SPELL_ATTR_EX6_UNK28                      0x10000000            // 28 not set in 3.0.3
-#define SPELL_ATTR_EX6_UNK29                      0x20000000            // 29 not set in 3.0.3
+#define SPELL_ATTR_EX6_NO_DMG_MODS                0x20000000            // 29 not set in 3.0.3
 #define SPELL_ATTR_EX6_UNK30                      0x40000000            // 30 not set in 3.0.3
 #define SPELL_ATTR_EX6_UNK31                      0x80000000            // 31 not set in 3.0.3
 
diff --git a/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.cpp
@@ -106,9 +106,22 @@
 }
 
 void
+AssistanceDistractMovementGenerator::Initialize(Unit &unit)
+{
+    DistractMovementGenerator::Initialize(unit);
+    Creature *creature = unit.ToCreature();
+    if (creature && creature->GetReactState() != REACT_PASSIVE)
+    {
+        oldReactState = creature->GetReactState();
+        creature->SetReactState(REACT_PASSIVE);
+    }
+}
+
+void
 AssistanceDistractMovementGenerator::Finalize(Unit &unit)
 {
-    unit.clearUnitState(UNIT_STAT_DISTRACTED);
-    unit.ToCreature()->SetReactState(REACT_AGGRESSIVE);
+    DistractMovementGenerator::Finalize(unit);
+    Creature *creature = unit.ToCreature();
+    if (creature && creature->GetReactState() == REACT_PASSIVE)
+        creature->SetReactState(oldReactState);
 }
-
diff --git a/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.h b/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.h
+++ b/src/server/game/Movement/MovementGenerators/IdleMovementGenerator.h
@@ -22,6 +22,7 @@
 #define TRINITY_IDLEMOVEMENTGENERATOR_H
 
 #include "MovementGenerator.h"
+#include "Unit.h"
 
 class IdleMovementGenerator : public MovementGenerator
 {
@@ -57,11 +58,11 @@
     public:
         explicit DistractMovementGenerator(uint32 timer) : m_timer(timer) {}
 
-        void Initialize(Unit& owner);
-        void Finalize(Unit& owner);
-        void Reset(Unit& owner) { Initialize(owner); }
-        bool Update(Unit& owner, const uint32& time_diff);
-        MovementGeneratorType GetMovementGeneratorType() { return DISTRACT_MOTION_TYPE; }
+        virtual void Initialize(Unit& owner);
+        virtual void Finalize(Unit& owner);
+        virtual void Reset(Unit& owner) { Initialize(owner); }
+        virtual bool Update(Unit& owner, const uint32& time_diff);
+        virtual MovementGeneratorType GetMovementGeneratorType() { return DISTRACT_MOTION_TYPE; }
 
     private:
         uint32 m_timer;
@@ -69,11 +70,14 @@
 
 class AssistanceDistractMovementGenerator : public DistractMovementGenerator
 {
+    private:
+        ReactStates oldReactState;
     public:
         AssistanceDistractMovementGenerator(uint32 timer) :
             DistractMovementGenerator(timer) {}
 
         MovementGeneratorType GetMovementGeneratorType() { return ASSISTANCE_DISTRACT_MOTION_TYPE; }
+        void Initialize(Unit& unit);
         void Finalize(Unit& unit);
 };
 
diff --git a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
--- a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
+++ b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp
@@ -96,11 +96,24 @@
 template bool PointMovementGenerator<Creature>::Update(Creature&, const uint32 &diff);
 template void PointMovementGenerator<Creature>::Finalize(Creature&);
 
-void AssistanceMovementGenerator::Finalize(Unit &unit)
+void AssistanceMovementGenerator::Initialize(Creature &creature)
 {
-    unit.ToCreature()->SetNoCallAssistance(false);
-    unit.ToCreature()->CallAssistance();
-    if (unit.isAlive())
-        unit.GetMotionMaster()->MoveSeekAssistanceDistract(sWorld.getIntConfig(CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY));
+    if (creature.GetReactState() != REACT_PASSIVE)
+    {
+        oldReactState = creature.GetReactState();
+        creature.SetReactState(REACT_PASSIVE);
+    }
+    PointMovementGenerator<Creature>::Initialize(creature);
 }
+ 
+void AssistanceMovementGenerator::Finalize(Creature &creature)
+{
+    PointMovementGenerator<Creature>::Finalize(creature);
+    creature.SetNoCallAssistance(false);
+    creature.CallAssistance();
+    if (creature.GetReactState() == REACT_PASSIVE)
+        creature.SetReactState(oldReactState);
 
+    if (creature.isAlive())
+        creature.GetMotionMaster()->MoveSeekAssistanceDistract(sWorld.getIntConfig(CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY));
+}
diff --git a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h
--- a/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h
+++ b/src/server/game/Movement/MovementGenerators/PointMovementGenerator.h
@@ -34,16 +34,16 @@
         PointMovementGenerator(uint32 _id, float _x, float _y, float _z) : id(_id),
             i_x(_x), i_y(_y), i_z(_z), i_nextMoveTime(0), arrived(false) {}
 
-        void Initialize(T &);
-        void Finalize(T &unit);
-        void Reset(T &unit){unit.StopMoving();}
-        bool Update(T &, const uint32 &diff);
+        virtual void Initialize(T &);
+        virtual void Finalize(T &unit);
+        virtual void Reset(T &unit){unit.StopMoving();}
+        virtual bool Update(T &, const uint32 &diff);
 
-        void MovementInform(T &);
+        virtual void MovementInform(T &);
 
-        MovementGeneratorType GetMovementGeneratorType() { return POINT_MOTION_TYPE; }
+        virtual MovementGeneratorType GetMovementGeneratorType() { return POINT_MOTION_TYPE; }
 
-        bool GetDestination(float& x, float& y, float& z) const { x=i_x; y=i_y; z=i_z; return true; }
+        virtual bool GetDestination(float& x, float& y, float& z) const { x=i_x; y=i_y; z=i_z; return true; }
     private:
         uint32 id;
         float i_x,i_y,i_z;
@@ -55,12 +55,15 @@
 class AssistanceMovementGenerator
 : public PointMovementGenerator<Creature>
 {
+    private:
+        ReactStates oldReactState;
     public:
         AssistanceMovementGenerator(float _x, float _y, float _z) :
             PointMovementGenerator<Creature>(0, _x, _y, _z) {}
 
         MovementGeneratorType GetMovementGeneratorType() { return ASSISTANCE_MOTION_TYPE; }
-        void Finalize(Unit &);
+        void Initialize(Creature &);
+        void Finalize(Creature &);
 };
 
 #endif
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -61,6 +61,7 @@
 void AddSC_npc_taxi();
 void AddSC_achievement_scripts();
 void AddSC_npc_customize();
+void AddSC_dungeon_finder();
 
 //guildhouse
 void AddSC_guildmaster();
@@ -648,6 +649,7 @@
     AddSC_achievement_scripts();
     AddSC_chat_log();
 	AddSC_npc_customize();
+	AddSC_dungeon_finder();
 #endif
 }
 
diff --git a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
@@ -320,6 +320,9 @@
     if (!bg)
         return;
 
+    if (bg->isArena() && bg->GetStatus() != STATUS_WAIT_LEAVE)
+        return;
+
     WorldPacket data;
     sBattlegroundMgr.BuildPvpLogDataPacket(&data, bg);
     SendPacket(&data);
diff --git a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
@@ -224,13 +224,17 @@
     {
         if (leader)
             group->RemoveInvite(leader);
+
         group->Create(group->GetLeaderGUID(), group->GetLeaderName());
         sObjectMgr.AddGroup(group);
     }
 
     // everything's fine, do it, PLAYER'S GROUP IS SET IN ADDMEMBER!!!
-    if (!group->AddMember(GetPlayer()->GetGUID(), GetPlayer()->GetName()))
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    if (!group->AddMember(GetPlayer()->GetGUID(), GetPlayer()->GetName(), trans))
         return;
+    CharacterDatabase.CommitTransaction(trans);
+
 
     SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
     for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
diff --git a/src/server/game/Server/Protocol/Handlers/ItemHandler.cpp b/src/server/game/Server/Protocol/Handlers/ItemHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/ItemHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/ItemHandler.cpp
@@ -756,18 +756,31 @@
 
     float discountMod = _player->GetReputationPriceDiscount(pCreature);
 
-    for (uint8 vendorslot = 0; vendorslot < numitems; ++vendorslot )
+    for(uint8 vendorslot = 0; vendorslot < numitems; ++vendorslot )
     {
         if (VendorItem const* crItem = vItems->GetItem(vendorslot))
         {
-            if (ItemPrototype const *pProto = sObjectMgr.GetItemPrototype(crItem->item))
+            if (ItemPrototype const *pProto = ObjectMgr::GetItemPrototype(crItem->item))
+
             {
                 if ((pProto->AllowableClass & _player->getClassMask()) == 0 && pProto->Bonding == BIND_WHEN_PICKED_UP && !_player->isGameMaster())
-                    continue;
-                // Only display items in vendor lists for the team the
-                // player is on. If GM on, display all items.
-                if (!_player->isGameMaster() && ((pProto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && _player->GetTeam() == ALLIANCE) || (pProto->Flags2 == ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && _player->GetTeam() == HORDE)))
-                    continue;
+                       if (!_player->isGameMaster())
+                {
+                    // class wrong item skip only for bindable case
+                    if ((pProto->AllowableClass & _player->getClassMask()) == 0 && pProto->Bonding == BIND_WHEN_PICKED_UP)
+                        continue;
+
+                    // race wrong item skip always
+                    if ((pProto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && _player->GetTeam() != HORDE)
+                        continue;
+
+                    if ((pProto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && _player->GetTeam() != ALLIANCE)
+                        continue;
+
+                    if ((pProto->AllowableRace & _player->getRaceMask()) == 0)
+                        continue;
+                }
+
                 ++count;
 
                 // reputation discount
@@ -926,6 +939,12 @@
         return;
     }
 
+    if (dest.size() == 1 && dest[0].pos == pItem->GetPos())
+    {
+        _player->SendEquipError( EQUIP_ERR_NONE, pItem, NULL );
+        return;
+    }
+
     _player->RemoveItem(srcbag, srcslot, true);
     _player->BankItem(dest, pItem, true);
 }
diff --git a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/MiscHandler.cpp
@@ -1,1741 +1,1742 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "Common.h"
-#include "Language.h"
-#include "DatabaseEnv.h"
-#include "WorldPacket.h"
-#include "Opcodes.h"
-#include "Log.h"
-#include "Player.h"
-#include "GossipDef.h"
-#include "World.h"
-#include "ObjectMgr.h"
-#include "WorldSession.h"
-#include "BigNumber.h"
-#include "SHA1.h"
-#include "UpdateData.h"
-#include "LootMgr.h"
-#include "Chat.h"
-#include "zlib.h"
-#include "ObjectAccessor.h"
-#include "Object.h"
-#include "Battleground.h"
-#include "OutdoorPvP.h"
-#include "Pet.h"
-#include "SocialMgr.h"
-#include "CellImpl.h"
-#include "AccountMgr.h"
-#include "Vehicle.h"
-#include "CreatureAI.h"
-#include "DBCEnums.h"
-#include "ScriptMgr.h"
-#include "MapManager.h"
-#include "InstanceScript.h"
-#include "LFGMgr.h"
-
-void WorldSession::HandleRepopRequestOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: Recvd CMSG_REPOP_REQUEST Message");
-
-    recv_data.read_skip<uint8>();
-
-    if (GetPlayer()->isAlive()||GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
-        return;
-
-    // the world update order is sessions, players, creatures
-    // the netcode runs in parallel with all of these
-    // creatures can kill players
-    // so if the server is lagging enough the player can
-    // release spirit after he's killed but before he is updated
-    if (GetPlayer()->getDeathState() == JUST_DIED)
-    {
-        sLog.outDebug("HandleRepopRequestOpcode: got request after player %s(%d) was killed and before he was updated", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
-        GetPlayer()->KillPlayer();
-    }
-
-    //this is spirit release confirm?
-    GetPlayer()->RemovePet(NULL,PET_SAVE_NOT_IN_SLOT, true);
-    GetPlayer()->BuildPlayerRepop();
-    GetPlayer()->RepopAtGraveyard();
-}
-
-void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: CMSG_GOSSIP_SELECT_OPTION");
-
-    uint32 gossipListId;
-    uint32 menuId;
-    uint64 guid;
-    std::string code = "";
-
-    recv_data >> guid >> menuId >> gossipListId;
-
-    if (_player->PlayerTalkClass->GossipOptionCoded(gossipListId))
-    {
-        // recheck
-        sLog.outBasic("reading string");
-        recv_data >> code;
-        sLog.outBasic("string read: %s", code.c_str());
-    }
-
-    Creature *unit = NULL;
-    GameObject *go = NULL;
-    if (IS_CRE_OR_VEH_GUID(guid))
-    {
-        unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
-        if (!unit)
-        {
-            sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(guid)));
-            return;
-        }
-    }
-    else if (IS_GAMEOBJECT_GUID(guid))
-    {
-        go = _player->GetMap()->GetGameObject(guid);
-        if (!go)
-        {
-            sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - GameObject (GUID: %u) not found.", uint32(GUID_LOPART(guid)));
-            return;
-        }
-    }
-    else
-    {
-        sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - unsupported GUID type for highguid %u. lowpart %u.", uint32(GUID_HIPART(guid)), uint32(GUID_LOPART(guid)));
-        return;
-    }
-
-    // remove fake death
-    if (GetPlayer()->hasUnitState(UNIT_STAT_DIED))
-        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
-
-    if ((unit && unit->GetCreatureInfo()->ScriptID != unit->LastUsedScriptID) || (go && go->GetGOInfo()->ScriptId != go->LastUsedScriptID))
-    {
-        sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - Script reloaded while in use, ignoring and set new scipt id");
-        if (unit)
-            unit->LastUsedScriptID = unit->GetCreatureInfo()->ScriptID;
-        if (go)
-            go->LastUsedScriptID = go->GetGOInfo()->ScriptId;
-        _player->PlayerTalkClass->CloseGossip();
-        return;
-    }
-    if (!code.empty())
-    {
-        if (unit)
-        {
-            if (!sScriptMgr.OnGossipSelectCode(_player, unit, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId), code.c_str()))
-                _player->OnGossipSelect(unit, gossipListId, menuId);
-        }
-        else
-            sScriptMgr.OnGossipSelectCode(_player, go, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId), code.c_str());
-    }
-    else
-    {
-        if (unit)
-        {
-            if (!sScriptMgr.OnGossipSelect(_player, unit, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId)))
-                _player->OnGossipSelect(unit, gossipListId, menuId);
-        }
-        else
-            sScriptMgr.OnGossipSelect(_player, go, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId));
-    }
-}
-
-void WorldSession::HandleWhoOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: Recvd CMSG_WHO Message");
-    //recv_data.hexlike();
-
-    uint32 clientcount = 0;
-
-    uint32 level_min, level_max, racemask, classmask, zones_count, str_count;
-    uint32 zoneids[10];                                     // 10 is client limit
-    std::string player_name, guild_name;
-
-    recv_data >> level_min;                                 // maximal player level, default 0
-    recv_data >> level_max;                                 // minimal player level, default 100 (MAX_LEVEL)
-    recv_data >> player_name;                               // player name, case sensitive...
-
-    recv_data >> guild_name;                                // guild name, case sensitive...
-
-    recv_data >> racemask;                                  // race mask
-    recv_data >> classmask;                                 // class mask
-    recv_data >> zones_count;                               // zones count, client limit = 10 (2.0.10)
-
-    if (zones_count > 10)
-        return;                                             // can't be received from real client or broken packet
-
-    for (uint32 i = 0; i < zones_count; ++i)
-    {
-        uint32 temp;
-        recv_data >> temp;                                  // zone id, 0 if zone is unknown...
-        zoneids[i] = temp;
-        sLog.outDebug("Zone %u: %u", i, zoneids[i]);
-    }
-
-    recv_data >> str_count;                                 // user entered strings count, client limit=4 (checked on 2.0.10)
-
-    if (str_count > 4)
-        return;                                             // can't be received from real client or broken packet
-
-    sLog.outDebug("Minlvl %u, maxlvl %u, name %s, guild %s, racemask %u, classmask %u, zones %u, strings %u", level_min, level_max, player_name.c_str(), guild_name.c_str(), racemask, classmask, zones_count, str_count);
-
-    std::wstring str[4];                                    // 4 is client limit
-    for (uint32 i = 0; i < str_count; ++i)
-    {
-        std::string temp;
-        recv_data >> temp;                                  // user entered string, it used as universal search pattern(guild+player name)?
-
-        if (!Utf8toWStr(temp,str[i]))
-            continue;
-
-        wstrToLower(str[i]);
-
-        sLog.outDebug("String %u: %s", i, temp.c_str());
-    }
-
-    std::wstring wplayer_name;
-    std::wstring wguild_name;
-    if (!(Utf8toWStr(player_name, wplayer_name) && Utf8toWStr(guild_name, wguild_name)))
-        return;
-    wstrToLower(wplayer_name);
-    wstrToLower(wguild_name);
-
-    // client send in case not set max level value 100 but Trinity supports 255 max level,
-    // update it to show GMs with characters after 100 level
-    if (level_max >= MAX_LEVEL)
-        level_max = STRONG_MAX_LEVEL;
-
-    uint32 team = _player->GetTeam();
-    uint32 security = GetSecurity();
-    bool allowTwoSideWhoList = sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_WHO_LIST);
-    uint32 gmLevelInWhoList  = sWorld.getIntConfig(CONFIG_GM_LEVEL_IN_WHO_LIST);
-
-    WorldPacket data(SMSG_WHO, 50);                       // guess size
-    data << uint32(clientcount);                            // clientcount place holder, listed count
-    data << uint32(clientcount);                            // clientcount place holder, online count
-
-    ACE_GUARD(ACE_Thread_Mutex, g, *HashMapHolder<Player>::GetLock());
-    HashMapHolder<Player>::MapType& m = sObjectAccessor.GetPlayers();
-    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
-    {
-        if (security == SEC_PLAYER)
-        {
-            // player can see member of other team only if CONFIG_ALLOW_TWO_SIDE_WHO_LIST
-            if (itr->second->GetTeam() != team && !allowTwoSideWhoList)
-                continue;
-
-            // player can see MODERATOR, GAME MASTER, ADMINISTRATOR only if CONFIG_GM_IN_WHO_LIST
-            if ((itr->second->GetSession()->GetSecurity() > AccountTypes(gmLevelInWhoList)))
-                continue;
-        }
-
-        //do not process players which are not in world
-        if (!(itr->second->IsInWorld()))
-            continue;
-
-        // check if target is globally visible for player
-        if (!(itr->second->IsVisibleGloballyFor(_player)))
-            continue;
-
-        // check if target's level is in level range
-        uint8 lvl = itr->second->getLevel();
-        if (lvl < level_min || lvl > level_max)
-            continue;
-
-        // check if class matches classmask
-        uint32 class_ = itr->second->getClass();
-        if (!(classmask & (1 << class_)))
-            continue;
-
-        // check if race matches racemask
-        uint32 race = itr->second->getRace();
-        if (!(racemask & (1 << race)))
-            continue;
-
-        uint32 pzoneid = itr->second->GetZoneId();
-        uint8 gender = itr->second->getGender();
-
-        bool z_show = true;
-        for (uint32 i = 0; i < zones_count; ++i)
-        {
-            if (zoneids[i] == pzoneid)
-            {
-                z_show = true;
-                break;
-            }
-
-            z_show = false;
-        }
-        if (!z_show)
-            continue;
-
-        std::string pname = itr->second->GetName();
-        std::wstring wpname;
-        if (!Utf8toWStr(pname,wpname))
-            continue;
-        wstrToLower(wpname);
-
-        if (!(wplayer_name.empty() || wpname.find(wplayer_name) != std::wstring::npos))
-            continue;
-
-        std::string gname = sObjectMgr.GetGuildNameById(itr->second->GetGuildId());
-        std::wstring wgname;
-        if (!Utf8toWStr(gname,wgname))
-            continue;
-        wstrToLower(wgname);
-
-        if (!(wguild_name.empty() || wgname.find(wguild_name) != std::wstring::npos))
-            continue;
-
-        std::string aname;
-        if (AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(itr->second->GetZoneId()))
-            aname = areaEntry->area_name[GetSessionDbcLocale()];
-
-        bool s_show = true;
-        for (uint32 i = 0; i < str_count; ++i)
-        {
-            if (!str[i].empty())
-            {
-                if (wgname.find(str[i]) != std::wstring::npos ||
-                    wpname.find(str[i]) != std::wstring::npos ||
-                    Utf8FitTo(aname, str[i]))
-                {
-                    s_show = true;
-                    break;
-                }
-                s_show = false;
-            }
-        }
-        if (!s_show)
-            continue;
-
-        data << pname;                                    // player name
-        data << gname;                                    // guild name
-        data << uint32(lvl);                              // player level
-        data << uint32(class_);                           // player class
-        data << uint32(race);                             // player race
-        data << uint8(gender);                            // player gender
-        data << uint32(pzoneid);                          // player zone id
-
-        // 49 is maximum player count sent to client - can be overridden
-        // through config, but is unstable
-        if ((++clientcount) == sWorld.getIntConfig(CONFIG_MAX_WHO))
-            break;
-    }
-
-    uint32 count = m.size();
-    data.put( 0, clientcount );                             // insert right count, listed count
-    data.put( 4, count > 50 ? count : clientcount );        // insert right count, online count
-
-    SendPacket(&data);
-    sLog.outDebug("WORLD: Send SMSG_WHO Message");
-}
-
-void WorldSession::HandleLogoutRequestOpcode(WorldPacket & /*recv_data*/)
-{
-    sLog.outDebug("WORLD: Recvd CMSG_LOGOUT_REQUEST Message, security - %u", GetSecurity());
-
-    if (uint64 lguid = GetPlayer()->GetLootGUID())
-        DoLootRelease(lguid);
-
-    uint8 reason = 0;
-
-    if (GetPlayer()->isInCombat())
-        reason = 1;
-    else if (GetPlayer()->m_movementInfo.HasMovementFlag(MOVEMENTFLAG_JUMPING | MOVEMENTFLAG_FALLING))
-        reason = 3;                                         // is jumping or falling
-    else if (GetPlayer()->duel || GetPlayer()->HasAura(9454)) // is dueling or frozen by GM via freeze command
-        reason = 2;                                         // FIXME - Need the correct value
-
-    if (reason)
-    {
-        WorldPacket data(SMSG_LOGOUT_RESPONSE, 1+4);
-        data << uint8(reason);
-        data << uint32(0);
-        SendPacket(&data);
-        LogoutRequest(0);
-        return;
-    }
-
-    //instant logout in taverns/cities or on taxi or for admins, gm's, mod's if its enabled in worldserver.conf
-    if (GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) || GetPlayer()->isInFlight() ||
-        GetSecurity() >= AccountTypes(sWorld.getIntConfig(CONFIG_INSTANT_LOGOUT)))
-    {
-        WorldPacket data(SMSG_LOGOUT_RESPONSE, 1+4);
-        data << uint8(0);
-        data << uint32(16777216);
-        SendPacket(&data);
-        LogoutPlayer(true);
-        return;
-    }
-
-    // not set flags if player can't free move to prevent lost state at logout cancel
-    if (GetPlayer()->CanFreeMove())
-    {
-        GetPlayer()->SetStandState(UNIT_STAND_STATE_SIT);
-
-        WorldPacket data(SMSG_FORCE_MOVE_ROOT, (8+4));    // guess size
-        data.append(GetPlayer()->GetPackGUID());
-        data << (uint32)2;
-        SendPacket(&data);
-        GetPlayer()->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
-    }
-
-    WorldPacket data(SMSG_LOGOUT_RESPONSE, 1+4);
-    data << uint8(0);
-    data << uint32(0);
-    SendPacket(&data);
-    LogoutRequest(time(NULL));
-}
-
-void WorldSession::HandlePlayerLogoutOpcode(WorldPacket & /*recv_data*/)
-{
-    sLog.outDebug("WORLD: Recvd CMSG_PLAYER_LOGOUT Message");
-}
-
-void WorldSession::HandleLogoutCancelOpcode(WorldPacket & /*recv_data*/)
-{
-    sLog.outDebug("WORLD: Recvd CMSG_LOGOUT_CANCEL Message");
-
-    LogoutRequest(0);
-
-    WorldPacket data(SMSG_LOGOUT_CANCEL_ACK, 0);
-    SendPacket(&data);
-
-    // not remove flags if can't free move - its not set in Logout request code.
-    if (GetPlayer()->CanFreeMove())
-    {
-        //!we can move again
-        data.Initialize(SMSG_FORCE_MOVE_UNROOT, 8);       // guess size
-        data.append(GetPlayer()->GetPackGUID());
-        data << uint32(0);
-        SendPacket(&data);
-
-        //! Stand Up
-        GetPlayer()->SetStandState(UNIT_STAND_STATE_STAND);
-
-        //! DISABLE_ROTATE
-        GetPlayer()->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
-    }
-
-    sLog.outDebug("WORLD: sent SMSG_LOGOUT_CANCEL_ACK Message");
-}
-
-void WorldSession::HandleTogglePvP(WorldPacket & recv_data)
-{
-    // this opcode can be used in two ways: Either set explicit new status or toggle old status
-    if (recv_data.size() == 1)
-    {
-        bool newPvPStatus;
-        recv_data >> newPvPStatus;
-        GetPlayer()->ApplyModFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP, newPvPStatus);
-        GetPlayer()->ApplyModFlag(PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER, !newPvPStatus);
-    }
-    else
-    {
-        GetPlayer()->ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
-        GetPlayer()->ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER);
-    }
-
-    if (GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))
-    {
-        if (!GetPlayer()->IsPvP() || GetPlayer()->pvpInfo.endTimer != 0)
-            GetPlayer()->UpdatePvP(true, true);
-    }
-    else
-    {
-        if (!GetPlayer()->pvpInfo.inHostileArea && GetPlayer()->IsPvP())
-            GetPlayer()->pvpInfo.endTimer = time(NULL);     // start toggle-off
-    }
-
-    //if (OutdoorPvP * pvp = _player->GetOutdoorPvP())
-    //    pvp->HandlePlayerActivityChanged(_player);
-}
-
-void WorldSession::HandleZoneUpdateOpcode(WorldPacket & recv_data)
-{
-    uint32 newZone;
-    recv_data >> newZone;
-
-    sLog.outDetail("WORLD: Recvd ZONE_UPDATE: %u", newZone);
-
-    // use server size data
-    uint32 newzone, newarea;
-    GetPlayer()->GetZoneAndAreaId(newzone,newarea);
-    GetPlayer()->UpdateZone(newzone,newarea);
-    //GetPlayer()->SendInitWorldStates(true,newZone);
-}
-
-void WorldSession::HandleSetTargetOpcode(WorldPacket & recv_data)
-{
-    uint64 guid;
-    recv_data >> guid;
-
-    _player->SetUInt32Value(UNIT_FIELD_TARGET, uint32(guid));
-
-    // update reputation list if need
-    Unit* unit = ObjectAccessor::GetUnit(*_player, guid);
-    if (!unit)
-        return;
-
-    if (FactionTemplateEntry const* factionTemplateEntry = sFactionTemplateStore.LookupEntry(unit->getFaction()))
-        _player->GetReputationMgr().SetVisible(factionTemplateEntry);
-}
-
-void WorldSession::HandleSetSelectionOpcode(WorldPacket & recv_data)
-{
-    uint64 guid;
-    recv_data >> guid;
-
-    _player->SetSelection(guid);
-
-    // update reputation list if need
-    Unit* unit = ObjectAccessor::GetUnit(*_player, guid);
-    if (!unit)
-        return;
-
-    if (FactionTemplateEntry const* factionTemplateEntry = sFactionTemplateStore.LookupEntry(unit->getFaction()))
-        _player->GetReputationMgr().SetVisible(factionTemplateEntry);
-}
-
-void WorldSession::HandleStandStateChangeOpcode(WorldPacket & recv_data)
-{
-    // sLog.outDebug("WORLD: Received CMSG_STANDSTATECHANGE"); -- too many spam in log at lags/debug stop
-    uint32 animstate;
-    recv_data >> animstate;
-
-    _player->SetStandState(animstate);
-}
-
-void WorldSession::HandleContactListOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: Received CMSG_CONTACT_LIST");
-    uint32 unk;
-    recv_data >> unk;
-    sLog.outDebug("unk value is %u", unk);
-    _player->GetSocial()->SendSocialList(_player);
-}
-
-void WorldSession::HandleAddFriendOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: Received CMSG_ADD_FRIEND");
-
-    std::string friendName = GetTrinityString(LANG_FRIEND_IGNORE_UNKNOWN);
-    std::string friendNote;
-
-    recv_data >> friendName;
-
-    recv_data >> friendNote;
-
-    if (!normalizePlayerName(friendName))
-        return;
-
-    CharacterDatabase.escape_string(friendName);            // prevent SQL injection - normal name don't must changed by this call
-
-    sLog.outDebug("WORLD: %s asked to add friend : '%s'",
-        GetPlayer()->GetName(), friendName.c_str());
-
-    m_addFriendCallback.SetParam(friendNote);
-    m_addFriendCallback.SetFutureResult(
-        CharacterDatabase.AsyncPQuery("SELECT guid, race, account FROM characters WHERE name = '%s'", friendName.c_str())
-        );
-}
-
-void WorldSession::HandleAddFriendOpcodeCallBack(QueryResult result, std::string friendNote)
-{
-    if (!GetPlayer())
-        return;
-
-    uint64 friendGuid;
-    uint32 friendAcctid;
-    uint32 team;
-    FriendsResult friendResult;
-
-    friendResult = FRIEND_NOT_FOUND;
-    friendGuid = 0;
-
-    if (result)
-    {
-        friendGuid = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_PLAYER);
-        team = Player::TeamForRace((*result)[1].GetUInt8());
-        friendAcctid = (*result)[2].GetUInt32();
-
-        if (GetSecurity() >= SEC_MODERATOR || sWorld.getBoolConfig(CONFIG_ALLOW_GM_FRIEND) || sAccountMgr.GetSecurity(friendAcctid) < SEC_MODERATOR)
-        {
-            if (friendGuid)
-            {
-                if (friendGuid == GetPlayer()->GetGUID())
-                    friendResult = FRIEND_SELF;
-                else if (GetPlayer()->GetTeam() != team && !sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND) && GetSecurity() < SEC_MODERATOR)
-                    friendResult = FRIEND_ENEMY;
-                else if (GetPlayer()->GetSocial()->HasFriend(GUID_LOPART(friendGuid)))
-                    friendResult = FRIEND_ALREADY;
-                else
-                {
-                    Player* pFriend = ObjectAccessor::FindPlayer(friendGuid);
-                    if (pFriend && pFriend->IsInWorld() && pFriend->IsVisibleGloballyFor(GetPlayer()))
-                        friendResult = FRIEND_ADDED_ONLINE;
-                    else
-                        friendResult = FRIEND_ADDED_OFFLINE;
-                    if (!GetPlayer()->GetSocial()->AddToSocialList(GUID_LOPART(friendGuid), false))
-                    {
-                        friendResult = FRIEND_LIST_FULL;
-                        sLog.outDebug("WORLD: %s's friend list is full.", GetPlayer()->GetName());
-                    }
-                }
-                GetPlayer()->GetSocial()->SetFriendNote(GUID_LOPART(friendGuid), friendNote);
-            }
-        }
-    }
-
-    sSocialMgr.SendFriendStatus(GetPlayer(), friendResult, GUID_LOPART(friendGuid), false);
-
-    sLog.outDebug("WORLD: Sent (SMSG_FRIEND_STATUS)");
-}
-
-void WorldSession::HandleDelFriendOpcode(WorldPacket & recv_data)
-{
-    uint64 FriendGUID;
-
-    sLog.outDebug("WORLD: Received CMSG_DEL_FRIEND");
-
-    recv_data >> FriendGUID;
-
-    _player->GetSocial()->RemoveFromSocialList(GUID_LOPART(FriendGUID), false);
-
-    sSocialMgr.SendFriendStatus(GetPlayer(), FRIEND_REMOVED, GUID_LOPART(FriendGUID), false);
-
-    sLog.outDebug("WORLD: Sent motd (SMSG_FRIEND_STATUS)");
-}
-
-void WorldSession::HandleAddIgnoreOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: Received CMSG_ADD_IGNORE");
-
-    std::string IgnoreName = GetTrinityString(LANG_FRIEND_IGNORE_UNKNOWN);
-
-    recv_data >> IgnoreName;
-
-    if (!normalizePlayerName(IgnoreName))
-        return;
-
-    CharacterDatabase.escape_string(IgnoreName);            // prevent SQL injection - normal name don't must changed by this call
-
-    sLog.outDebug("WORLD: %s asked to Ignore: '%s'",
-        GetPlayer()->GetName(), IgnoreName.c_str());
-
-    m_addIgnoreCallback = CharacterDatabase.AsyncPQuery("SELECT guid FROM characters WHERE name = '%s'", IgnoreName.c_str());
-}
-
-void WorldSession::HandleAddIgnoreOpcodeCallBack(QueryResult result)
-{
-    if (!GetPlayer())
-        return;
-
-    uint64 IgnoreGuid;
-    FriendsResult ignoreResult;
-
-    ignoreResult = FRIEND_IGNORE_NOT_FOUND;
-    IgnoreGuid = 0;
-
-    if (result)
-    {
-        IgnoreGuid = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_PLAYER);
-
-        if (IgnoreGuid)
-        {
-            if (IgnoreGuid == GetPlayer()->GetGUID())              //not add yourself
-                ignoreResult = FRIEND_IGNORE_SELF;
-            else if (GetPlayer()->GetSocial()->HasIgnore(GUID_LOPART(IgnoreGuid)))
-                ignoreResult = FRIEND_IGNORE_ALREADY;
-            else
-            {
-                ignoreResult = FRIEND_IGNORE_ADDED;
-
-                // ignore list full
-                if (!GetPlayer()->GetSocial()->AddToSocialList(GUID_LOPART(IgnoreGuid), true))
-                    ignoreResult = FRIEND_IGNORE_FULL;
-            }
-        }
-    }
-
-    sSocialMgr.SendFriendStatus(GetPlayer(), ignoreResult, GUID_LOPART(IgnoreGuid), false);
-
-    sLog.outDebug("WORLD: Sent (SMSG_FRIEND_STATUS)");
-}
-
-void WorldSession::HandleDelIgnoreOpcode(WorldPacket & recv_data)
-{
-    uint64 IgnoreGUID;
-
-    sLog.outDebug("WORLD: Received CMSG_DEL_IGNORE");
-
-    recv_data >> IgnoreGUID;
-
-    _player->GetSocial()->RemoveFromSocialList(GUID_LOPART(IgnoreGUID), true);
-
-    sSocialMgr.SendFriendStatus(GetPlayer(), FRIEND_IGNORE_REMOVED, GUID_LOPART(IgnoreGUID), false);
-
-    sLog.outDebug("WORLD: Sent motd (SMSG_FRIEND_STATUS)");
-}
-
-void WorldSession::HandleSetContactNotesOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("CMSG_SET_CONTACT_NOTES");
-    uint64 guid;
-    std::string note;
-    recv_data >> guid >> note;
-    _player->GetSocial()->SetFriendNote(GUID_LOPART(guid), note);
-}
-
-void WorldSession::HandleBugOpcode(WorldPacket & recv_data)
-{
-    uint32 suggestion, contentlen, typelen;
-    std::string content, type;
-
-    recv_data >> suggestion >> contentlen >> content;
-
-    recv_data >> typelen >> type;
-
-    if (suggestion == 0)
-        sLog.outDebug("WORLD: Received CMSG_BUG [Bug Report]");
-    else
-        sLog.outDebug("WORLD: Received CMSG_BUG [Suggestion]");
-
-    sLog.outDebug("%s", type.c_str());
-    sLog.outDebug("%s", content.c_str());
-
-    CharacterDatabase.escape_string(type);
-    CharacterDatabase.escape_string(content);
-    CharacterDatabase.PExecute ("INSERT INTO bugreport (type,content) VALUES('%s', '%s')", type.c_str(), content.c_str());
-}
-
-void WorldSession::HandleReclaimCorpseOpcode(WorldPacket &recv_data)
-{
-    sLog.outDetail("WORLD: Received CMSG_RECLAIM_CORPSE");
-
-    uint64 guid;
-    recv_data >> guid;
-
-    if (GetPlayer()->isAlive())
-        return;
-
-    // do not allow corpse reclaim in arena
-    if (GetPlayer()->InArena())
-        return;
-
-    // body not released yet
-    if (!GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
-        return;
-
-    Corpse *corpse = GetPlayer()->GetCorpse();
-
-    if (!corpse)
-        return;
-
-    // prevent resurrect before 30-sec delay after body release not finished
-    if (time_t(corpse->GetGhostTime() + GetPlayer()->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP)) > time_t(time(NULL)))
-        return;
-
-    if (!corpse->IsWithinDistInMap(GetPlayer(), CORPSE_RECLAIM_RADIUS, true))
-        return;
-
-    // resurrect
-    GetPlayer()->ResurrectPlayer(GetPlayer()->InBattleground() ? 1.0f : 0.5f);
-
-    // spawn bones
-    GetPlayer()->SpawnCorpseBones();
-}
-
-void WorldSession::HandleResurrectResponseOpcode(WorldPacket & recv_data)
-{
-    sLog.outDetail("WORLD: Received CMSG_RESURRECT_RESPONSE");
-
-    uint64 guid;
-    uint8 status;
-    recv_data >> guid;
-    recv_data >> status;
-
-    if (GetPlayer()->isAlive())
-        return;
-
-    if (status == 0)
-    {
-        GetPlayer()->clearResurrectRequestData();           // reject
-        return;
-    }
-
-    if (!GetPlayer()->isRessurectRequestedBy(guid))
-        return;
-
-    GetPlayer()->ResurectUsingRequestData();
-}
-
-void WorldSession::SendAreaTriggerMessage(const char* Text, ...)
-{
-    va_list ap;
-    char szStr [1024];
-    szStr[0] = '\0';
-
-    va_start(ap, Text);
-    vsnprintf(szStr, 1024, Text, ap);
-    va_end(ap);
-
-    uint32 length = strlen(szStr)+1;
-    WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 4+length);
-    data << length;
-    data << szStr;
-    SendPacket(&data);
-}
-
-void WorldSession::HandleAreaTriggerOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: Received CMSG_AREATRIGGER");
-
-    uint32 Trigger_ID;
-
-    recv_data >> Trigger_ID;
-    sLog.outDebug("Trigger ID:%u",Trigger_ID);
-
-    if (GetPlayer()->isInFlight())
-    {
-        sLog.outDebug("Player '%s' (GUID: %u) in flight, ignore Area Trigger ID:%u",GetPlayer()->GetName(),GetPlayer()->GetGUIDLow(), Trigger_ID);
-        return;
-    }
-
-    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
-    if (!atEntry)
-    {
-        sLog.outDebug("Player '%s' (GUID: %u) send unknown (by DBC) Area Trigger ID:%u",GetPlayer()->GetName(),GetPlayer()->GetGUIDLow(), Trigger_ID);
-        return;
-    }
-
-    if (GetPlayer()->GetMapId() != atEntry->mapid)
-    {
-        sLog.outDebug("Player '%s' (GUID: %u) too far (trigger map: %u player map: %u), ignore Area Trigger ID: %u", GetPlayer()->GetName(), atEntry->mapid, GetPlayer()->GetMapId(), GetPlayer()->GetGUIDLow(), Trigger_ID);
-        return;
-    }
-
-    // delta is safe radius
-    const float delta = 5.0f;
-    // check if player in the range of areatrigger
-    Player* pl = GetPlayer();
-
-    if (atEntry->radius > 0)
-    {
-        // if we have radius check it
-        float dist = pl->GetDistance(atEntry->x,atEntry->y,atEntry->z);
-        if (dist > atEntry->radius + delta)
-        {
-            sLog.outDebug("Player '%s' (GUID: %u) too far (radius: %f distance: %f), ignore Area Trigger ID: %u",
-                pl->GetName(), pl->GetGUIDLow(), atEntry->radius, dist, Trigger_ID);
-            return;
-        }
-    }
-    else
-    {
-        // we have only extent
-
-        // rotate the players position instead of rotating the whole cube, that way we can make a simplified
-        // is-in-cube check and we have to calculate only one point instead of 4
-
-        // 2PI = 360, keep in mind that ingame orientation is counter-clockwise
-        double rotation = 2*M_PI-atEntry->box_orientation;
-        double sinVal = sin(rotation);
-        double cosVal = cos(rotation);
-
-        float playerBoxDistX = pl->GetPositionX() - atEntry->x;
-        float playerBoxDistY = pl->GetPositionY() - atEntry->y;
-
-        float rotPlayerX = (float)(atEntry->x + playerBoxDistX * cosVal - playerBoxDistY*sinVal);
-        float rotPlayerY = (float)(atEntry->y + playerBoxDistY * cosVal + playerBoxDistX*sinVal);
-
-        // box edges are parallel to coordiante axis, so we can treat every dimension independently :D
-        float dz = pl->GetPositionZ() - atEntry->z;
-        float dx = rotPlayerX - atEntry->x;
-        float dy = rotPlayerY - atEntry->y;
-        if ((fabs(dx) > atEntry->box_x/2 + delta) ||
-            (fabs(dy) > atEntry->box_y/2 + delta) ||
-            (fabs(dz) > atEntry->box_z/2 + delta))
-        {
-            sLog.outDebug("Player '%s' (GUID: %u) too far (1/2 box X: %f 1/2 box Y: %f 1/2 box Z: %f rotatedPlayerX: %f rotatedPlayerY: %f dZ:%f), ignore Area Trigger ID: %u",
-                pl->GetName(), pl->GetGUIDLow(), atEntry->box_x/2, atEntry->box_y/2, atEntry->box_z/2, rotPlayerX, rotPlayerY, dz, Trigger_ID);
-            return;
-        }
-    }
-
-    if (GetPlayer()->isDebugAreaTriggers)
-        ChatHandler(GetPlayer()).PSendSysMessage(LANG_DEBUG_AREATRIGGER_REACHED, Trigger_ID);
-
-    if (sScriptMgr.OnAreaTrigger(GetPlayer(), atEntry))
-        return;
-
-    uint32 quest_id = sObjectMgr.GetQuestForAreaTrigger(Trigger_ID);
-    if (quest_id && GetPlayer()->isAlive() && GetPlayer()->IsActiveQuest(quest_id))
-    {
-        Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest_id);
-        if (pQuest)
-        {
-            if (GetPlayer()->GetQuestStatus(quest_id) == QUEST_STATUS_INCOMPLETE)
-                GetPlayer()->AreaExploredOrEventHappens(quest_id);
-        }
-    }
-
-    if (sObjectMgr.IsTavernAreaTrigger(Trigger_ID))
-    {
-        // set resting flag we are in the inn
-        GetPlayer()->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
-        GetPlayer()->InnEnter(time(NULL), atEntry->mapid, atEntry->x, atEntry->y, atEntry->z);
-        GetPlayer()->SetRestType(REST_TYPE_IN_TAVERN);
-
-        if (sWorld.IsFFAPvPRealm())
-            GetPlayer()->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
-
-        return;
-    }
-
-    if (GetPlayer()->InBattleground())
-    {
-        Battleground* bg = GetPlayer()->GetBattleground();
-        if (bg)
-            if (bg->GetStatus() == STATUS_IN_PROGRESS)
-                bg->HandleAreaTrigger(GetPlayer(), Trigger_ID);
-
-        return;
-    }
-
-    if (OutdoorPvP * pvp = GetPlayer()->GetOutdoorPvP())
-    {
-        if (pvp->HandleAreaTrigger(_player, Trigger_ID))
-            return;
-    }
-
-    // NULL if all values default (non teleport trigger)
-    AreaTrigger const* at = sObjectMgr.GetAreaTrigger(Trigger_ID);
-    if (!at)
-        return;
-
-    // Check only if target map != current player's map
-    // check if player can enter instance : instance not full, and raid instance not in encounter fight
-    if (GetPlayer()->GetMapId() != at->target_mapId && !sMapMgr.CanPlayerEnter(at->target_mapId, GetPlayer(), false))
-        return;
-
-    // Check if we are in LfgGroup and trying to get out the dungeon
-    if (GetPlayer()->GetGroup() && GetPlayer()->GetGroup()->isLFGGroup() && GetPlayer()->GetMap()->IsDungeon() && at->target_mapId != GetPlayer()->GetMapId())
-        sLFGMgr.TeleportPlayer(GetPlayer(), true);
-    else
-        GetPlayer()->TeleportTo(at->target_mapId,at->target_X,at->target_Y,at->target_Z,at->target_Orientation,TELE_TO_NOT_LEAVE_TRANSPORT);
-}
-
-void WorldSession::HandleUpdateAccountData(WorldPacket &recv_data)
-{
-    sLog.outDetail("WORLD: Received CMSG_UPDATE_ACCOUNT_DATA");
-
-    uint32 type, timestamp, decompressedSize;
-    recv_data >> type >> timestamp >> decompressedSize;
-
-    sLog.outDebug("UAD: type %u, time %u, decompressedSize %u", type, timestamp, decompressedSize);
-
-    if (type > NUM_ACCOUNT_DATA_TYPES)
-        return;
-
-    if (decompressedSize == 0)                               // erase
-    {
-        SetAccountData(AccountDataType(type), 0, "");
-
-        WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA_COMPLETE, 4+4);
-        data << uint32(type);
-        data << uint32(0);
-        SendPacket(&data);
-
-        return;
-    }
-
-    if (decompressedSize > 0xFFFF)
-    {
-        recv_data.rpos(recv_data.wpos());                   // unnneded warning spam in this case
-        sLog.outError("UAD: Account data packet too big, size %u", decompressedSize);
-        return;
-    }
-
-    ByteBuffer dest;
-    dest.resize(decompressedSize);
-
-    uLongf realSize = decompressedSize;
-    if (uncompress(const_cast<uint8*>(dest.contents()), &realSize, const_cast<uint8*>(recv_data.contents() + recv_data.rpos()), recv_data.size() - recv_data.rpos()) != Z_OK)
-    {
-        recv_data.rpos(recv_data.wpos());                   // unnneded warning spam in this case
-        sLog.outError("UAD: Failed to decompress account data");
-        return;
-    }
-
-    recv_data.rpos(recv_data.wpos());                       // uncompress read (recv_data.size() - recv_data.rpos())
-
-    std::string adata;
-    dest >> adata;
-
-    SetAccountData(AccountDataType(type), timestamp, adata);
-
-    WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA_COMPLETE, 4+4);
-    data << uint32(type);
-    data << uint32(0);
-    SendPacket(&data);
-}
-
-void WorldSession::HandleRequestAccountData(WorldPacket& recv_data)
-{
-    sLog.outDetail("WORLD: Received CMSG_REQUEST_ACCOUNT_DATA");
-
-    uint32 type;
-    recv_data >> type;
-
-    sLog.outDebug("RAD: type %u", type);
-
-    if (type > NUM_ACCOUNT_DATA_TYPES)
-        return;
-
-    AccountData *adata = GetAccountData(AccountDataType(type));
-
-    uint32 size = adata->Data.size();
-
-    uLongf destSize = compressBound(size);
-
-    ByteBuffer dest;
-    dest.resize(destSize);
-
-    if (size && compress(const_cast<uint8*>(dest.contents()), &destSize, (uint8*)adata->Data.c_str(), size) != Z_OK)
-    {
-        sLog.outDebug("RAD: Failed to compress account data");
-        return;
-    }
-
-    dest.resize(destSize);
-
-    WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA, 8+4+4+4+destSize);
-    data << uint64(_player ? _player->GetGUID() : 0);       // player guid
-    data << uint32(type);                                   // type (0-7)
-    data << uint32(adata->Time);                            // unix time
-    data << uint32(size);                                   // decompressed length
-    data.append(dest);                                      // compressed data
-    SendPacket(&data);
-}
-
-void WorldSession::HandleSetActionButtonOpcode(WorldPacket& recv_data)
-{
-    sLog.outDebug("WORLD: Received CMSG_SET_ACTION_BUTTON");
-    uint8 button;
-    uint32 packetData;
-    recv_data >> button >> packetData;
-
-    uint32 action = ACTION_BUTTON_ACTION(packetData);
-    uint8  type   = ACTION_BUTTON_TYPE(packetData);
-
-    sLog.outDetail("BUTTON: %u ACTION: %u TYPE: %u", button, action, type);
-    if (!packetData)
-    {
-        sLog.outDetail("MISC: Remove action from button %u", button);
-        GetPlayer()->removeActionButton(button);
-    }
-    else
-    {
-        switch(type)
-        {
-            case ACTION_BUTTON_MACRO:
-            case ACTION_BUTTON_CMACRO:
-                sLog.outDetail("MISC: Added Macro %u into button %u", action, button);
-                break;
-            case ACTION_BUTTON_EQSET:
-                sLog.outDetail("MISC: Added EquipmentSet %u into button %u", action, button);
-                break;
-            case ACTION_BUTTON_SPELL:
-                sLog.outDetail("MISC: Added Spell %u into button %u", action, button);
-                break;
-            case ACTION_BUTTON_ITEM:
-                sLog.outDetail("MISC: Added Item %u into button %u", action, button);
-                break;
-            default:
-                sLog.outError("MISC: Unknown action button type %u for action %u into button %u", type, action, button);
-                return;
-        }
-        GetPlayer()->addActionButton(button, action, type);
-    }
-}
-
-void WorldSession::HandleCompleteCinematic(WorldPacket & /*recv_data*/)
-{
-    sLog.outStaticDebug("WORLD: Player is watching cinema");
-}
-
-void WorldSession::HandleNextCinematicCamera(WorldPacket & /*recv_data*/)
-{
-    sLog.outStaticDebug("WORLD: Which movie to play");
-}
-
-void WorldSession::HandleMoveTimeSkippedOpcode(WorldPacket & recv_data)
-{
-    /*  WorldSession::Update(getMSTime());*/
-    sLog.outStaticDebug("WORLD: Time Lag/Synchronization Resent/Update");
-
-    uint64 guid;
-    recv_data.readPackGUID(guid);
-    recv_data.read_skip<uint32>();
-    /*
-        uint64 guid;
-        uint32 time_skipped;
-        recv_data >> guid;
-        recv_data >> time_skipped;
-        sLog.outDebug("WORLD: CMSG_MOVE_TIME_SKIPPED");
-
-        /// TODO
-        must be need use in Trinity
-        We substract server Lags to move time (AntiLags)
-        for exmaple
-        GetPlayer()->ModifyLastMoveTime(-int32(time_skipped));
-    */
-}
-
-void WorldSession::HandleFeatherFallAck(WorldPacket &recv_data)
-{
-    sLog.outStaticDebug("WORLD: CMSG_MOVE_FEATHER_FALL_ACK");
-
-    // no used
-    recv_data.rpos(recv_data.wpos());                       // prevent warnings spam
-}
-
-void WorldSession::HandleMoveUnRootAck(WorldPacket& recv_data)
-{
-    // no used
-    recv_data.rpos(recv_data.wpos());                       // prevent warnings spam
-/*
-    uint64 guid;
-    recv_data >> guid;
-
-    // now can skip not our packet
-    if (_player->GetGUID() != guid)
-    {
-        recv_data.rpos(recv_data.wpos());                   // prevent warnings spam
-        return;
-    }
-
-    sLog.outDebug("WORLD: CMSG_FORCE_MOVE_UNROOT_ACK");
-
-    recv_data.read_skip<uint32>();                          // unk
-
-    MovementInfo movementInfo;
-    movementInfo.guid = guid;
-    ReadMovementInfo(recv_data, &movementInfo);
-    recv_data.read_skip<float>();                           // unk2
-*/
-}
-
-void WorldSession::HandleMoveRootAck(WorldPacket& recv_data)
-{
-    // no used
-    recv_data.rpos(recv_data.wpos());                       // prevent warnings spam
-/*
-    uint64 guid;
-    recv_data >> guid;
-
-    // now can skip not our packet
-    if (_player->GetGUID() != guid)
-    {
-        recv_data.rpos(recv_data.wpos());                   // prevent warnings spam
-        return;
-    }
-
-    sLog.outDebug("WORLD: CMSG_FORCE_MOVE_ROOT_ACK");
-
-    recv_data.read_skip<uint32>();                          // unk
-
-    MovementInfo movementInfo;
-    ReadMovementInfo(recv_data, &movementInfo);
-*/
-}
-
-void WorldSession::HandleSetActionBarToggles(WorldPacket& recv_data)
-{
-    uint8 ActionBar;
-
-    recv_data >> ActionBar;
-
-    if (!GetPlayer())                                        // ignore until not logged (check needed because STATUS_AUTHED)
-    {
-        if (ActionBar != 0)
-            sLog.outError("WorldSession::HandleSetActionBarToggles in not logged state with value: %u, ignored",uint32(ActionBar));
-        return;
-    }
-
-    GetPlayer()->SetByteValue(PLAYER_FIELD_BYTES, 2, ActionBar);
-}
-
-void WorldSession::HandleWardenDataOpcode(WorldPacket& recv_data)
-{
-    recv_data.read_skip<uint8>();
-    /*
-        uint8 tmp;
-        recv_data >> tmp;
-        sLog.outDebug("Received opcode CMSG_WARDEN_DATA, not resolve.uint8 = %u",tmp);
-    */
-}
-
-void WorldSession::HandlePlayedTime(WorldPacket& recv_data)
-{
-    uint8 unk1;
-    recv_data >> unk1;                                      // 0 or 1 expected
-
-    WorldPacket data(SMSG_PLAYED_TIME, 4 + 4 + 1);
-    data << uint32(_player->GetTotalPlayedTime());
-    data << uint32(_player->GetLevelPlayedTime());
-    data << uint8(unk1);                                    // 0 - will not show in chat frame
-    SendPacket(&data);
-}
-
-void WorldSession::HandleInspectOpcode(WorldPacket& recv_data)
-{
-    uint64 guid;
-    recv_data >> guid;
-    sLog.outStaticDebug("Inspected guid is " UI64FMTD, guid);
-
-    _player->SetSelection(guid);
-
-    Player *plr = sObjectMgr.GetPlayer(guid);
-    if (!plr)                                                // wrong player
-        return;
-
-    uint32 talent_points = 0x47;
-    uint32 guid_size = plr->GetPackGUID().wpos();
-    WorldPacket data(SMSG_INSPECT_TALENT, guid_size+4+talent_points);
-    data.append(plr->GetPackGUID());
-
-    if (sWorld.getBoolConfig(CONFIG_TALENTS_INSPECTING) || _player->isGameMaster())
-    {
-        plr->BuildPlayerTalentsInfoData(&data);
-    }
-    else
-    {
-        data << uint32(0);                                  // unspentTalentPoints
-        data << uint8(0);                                   // talentGroupCount
-        data << uint8(0);                                   // talentGroupIndex
-    }
-
-    plr->BuildEnchantmentsInfoData(&data);
-    SendPacket(&data);
-}
-
-void WorldSession::HandleInspectHonorStatsOpcode(WorldPacket& recv_data)
-{
-    uint64 guid;
-    recv_data >> guid;
-
-    Player *player = sObjectMgr.GetPlayer(guid);
-
-    if (!player)
-    {
-        sLog.outError("InspectHonorStats: WTF, player not found...");
-        return;
-    }
-
-    WorldPacket data(MSG_INSPECT_HONOR_STATS, 8+1+4*4);
-    data << uint64(player->GetGUID());
-    data << uint8(player->GetHonorPoints());
-    data << uint32(player->GetUInt32Value(PLAYER_FIELD_KILLS));
-    data << uint32(player->GetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION));
-    data << uint32(player->GetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION));
-    data << uint32(player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
-    SendPacket(&data);
-}
-
-void WorldSession::HandleWorldTeleportOpcode(WorldPacket& recv_data)
-{
-    // write in client console: worldport 469 452 6454 2536 180 or /console worldport 469 452 6454 2536 180
-    // Received opcode CMSG_WORLD_TELEPORT
-    // Time is ***, map=469, x=452.000000, y=6454.000000, z=2536.000000, orient=3.141593
-
-    uint32 time;
-    uint32 mapid;
-    float PositionX;
-    float PositionY;
-    float PositionZ;
-    float Orientation;
-
-    recv_data >> time;                                      // time in m.sec.
-    recv_data >> mapid;
-    recv_data >> PositionX;
-    recv_data >> PositionY;
-    recv_data >> PositionZ;
-    recv_data >> Orientation;                               // o (3.141593 = 180 degrees)
-
-    //sLog.outDebug("Received opcode CMSG_WORLD_TELEPORT");
-    if (GetPlayer()->isInFlight())
-    {
-        sLog.outDebug("Player '%s' (GUID: %u) in flight, ignore worldport command.",GetPlayer()->GetName(),GetPlayer()->GetGUIDLow());
-        return;
-    }
-
-    sLog.outStaticDebug("Time %u sec, map=%u, x=%f, y=%f, z=%f, orient=%f", time/1000, mapid, PositionX, PositionY, PositionZ, Orientation);
-
-    if (GetSecurity() >= SEC_ADMINISTRATOR)
-        GetPlayer()->TeleportTo(mapid,PositionX,PositionY,PositionZ,Orientation);
-    else
-        SendNotification(LANG_YOU_NOT_HAVE_PERMISSION);
-    sLog.outDebug("Received worldport command from player %s", GetPlayer()->GetName());
-}
-
-void WorldSession::HandleWhoisOpcode(WorldPacket& recv_data)
-{
-    sLog.outDebug("Received opcode CMSG_WHOIS");
-    std::string charname;
-    recv_data >> charname;
-
-    if (GetSecurity() < SEC_ADMINISTRATOR)
-    {
-        SendNotification(LANG_YOU_NOT_HAVE_PERMISSION);
-        return;
-    }
-
-    if (charname.empty() || !normalizePlayerName (charname))
-    {
-        SendNotification(LANG_NEED_CHARACTER_NAME);
-        return;
-    }
-
-    Player *plr = sObjectMgr.GetPlayer(charname.c_str());
-
-    if (!plr)
-    {
-        SendNotification(LANG_PLAYER_NOT_EXIST_OR_OFFLINE, charname.c_str());
-        return;
-    }
-
-    uint32 accid = plr->GetSession()->GetAccountId();
-
-    QueryResult result = LoginDatabase.PQuery("SELECT username,email,last_ip FROM account WHERE id=%u", accid);
-    if (!result)
-    {
-        SendNotification(LANG_ACCOUNT_FOR_PLAYER_NOT_FOUND, charname.c_str());
-        return;
-    }
-
-    Field *fields = result->Fetch();
-    std::string acc = fields[0].GetString();
-    if (acc.empty())
-        acc = "Unknown";
-    std::string email = fields[1].GetString();
-    if (email.empty())
-        email = "Unknown";
-    std::string lastip = fields[2].GetString();
-    if (lastip.empty())
-        lastip = "Unknown";
-
-    std::string msg = charname + "'s " + "account is " + acc + ", e-mail: " + email + ", last ip: " + lastip;
-
-    WorldPacket data(SMSG_WHOIS, msg.size()+1);
-    data << msg;
-    _player->GetSession()->SendPacket(&data);
-
-    sLog.outDebug("Received whois command from player %s for character %s", GetPlayer()->GetName(), charname.c_str());
-}
-
-void WorldSession::HandleComplainOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: CMSG_COMPLAIN");
-    recv_data.hexlike();
-
-    uint8 spam_type;                                        // 0 - mail, 1 - chat
-    uint64 spammer_guid;
-    uint32 unk1 = 0;
-    uint32 unk2 = 0;
-    uint32 unk3 = 0;
-    uint32 unk4 = 0;
-    std::string description = "";
-    recv_data >> spam_type;                                 // unk 0x01 const, may be spam type (mail/chat)
-    recv_data >> spammer_guid;                              // player guid
-    switch(spam_type)
-    {
-        case 0:
-            recv_data >> unk1;                              // const 0
-            recv_data >> unk2;                              // probably mail id
-            recv_data >> unk3;                              // const 0
-            break;
-        case 1:
-            recv_data >> unk1;                              // probably language
-            recv_data >> unk2;                              // message type?
-            recv_data >> unk3;                              // probably channel id
-            recv_data >> unk4;                              // unk random value
-            recv_data >> description;                       // spam description string (messagetype, channel name, player name, message)
-            break;
-    }
-
-    // NOTE: all chat messages from this spammer automatically ignored by spam reporter until logout in case chat spam.
-    // if it's mail spam - ALL mails from this spammer automatically removed by client
-
-    // Complaint Received message
-    WorldPacket data(SMSG_COMPLAIN_RESULT, 1);
-    data << uint8(0);
-    SendPacket(&data);
-
-    sLog.outDebug("REPORT SPAM: type %u, guid %u, unk1 %u, unk2 %u, unk3 %u, unk4 %u, message %s", spam_type, GUID_LOPART(spammer_guid), unk1, unk2, unk3, unk4, description.c_str());
-}
-
-void WorldSession::HandleRealmSplitOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("CMSG_REALM_SPLIT");
-
-    uint32 unk;
-    std::string split_date = "01/01/01";
-    recv_data >> unk;
-
-    WorldPacket data(SMSG_REALM_SPLIT, 4+4+split_date.size()+1);
-    data << unk;
-    data << uint32(0x00000000);                             // realm split state
-    // split states:
-    // 0x0 realm normal
-    // 0x1 realm split
-    // 0x2 realm split pending
-    data << split_date;
-    SendPacket(&data);
-    //sLog.outDebug("response sent %u", unk);
-}
-
-void WorldSession::HandleFarSightOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("WORLD: CMSG_FAR_SIGHT");
-    //recv_data.hexlike();
-
-    uint8 apply;
-    recv_data >> apply;
-
-    switch(apply)
-    {
-        case 0:
-            sLog.outDebug("Player %u set vision to self", _player->GetGUIDLow());
-            _player->SetSeer(_player);
-            break;
-        case 1:
-            sLog.outDebug("Added FarSight " UI64FMTD " to player %u", _player->GetUInt64Value(PLAYER_FARSIGHT), _player->GetGUIDLow());
-            if (WorldObject *target = _player->GetViewpoint())
-                _player->SetSeer(target);
-            else
-                sLog.outError("Player %s requests non-existing seer", _player->GetName());
-            break;
-        default:
-            sLog.outDebug("Unhandled mode in CMSG_FAR_SIGHT: %u", apply);
-            return;
-    }
-
-    GetPlayer()->UpdateVisibilityForPlayer();
-}
-
-void WorldSession::HandleSetTitleOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("CMSG_SET_TITLE");
-
-    int32 title;
-    recv_data >> title;
-
-    // -1 at none
-    if (title > 0 && title < MAX_TITLE_INDEX)
-    {
-       if (!GetPlayer()->HasTitle(title))
-            return;
-    }
-    else
-        title = 0;
-
-    GetPlayer()->SetUInt32Value(PLAYER_CHOSEN_TITLE, title);
-}
-
-void WorldSession::HandleTimeSyncResp(WorldPacket & recv_data)
-{
-    sLog.outDebug("CMSG_TIME_SYNC_RESP");
-
-    uint32 counter, clientTicks;
-    recv_data >> counter >> clientTicks;
-
-    if (counter != _player->m_timeSyncCounter - 1)
-        sLog.outDebug("Wrong time sync counter from player %s (cheater?)", _player->GetName());
-
-    sLog.outDebug("Time sync received: counter %u, client ticks %u, time since last sync %u", counter, clientTicks, clientTicks - _player->m_timeSyncClient);
-
-    uint32 ourTicks = clientTicks + (getMSTime() - _player->m_timeSyncServer);
-
-    // diff should be small
-    sLog.outDebug("Our ticks: %u, diff %u, latency %u", ourTicks, ourTicks - clientTicks, GetLatency());
-
-    _player->m_timeSyncClient = clientTicks;
-}
-
-void WorldSession::HandleResetInstancesOpcode(WorldPacket & /*recv_data*/)
-{
-    sLog.outDebug("WORLD: CMSG_RESET_INSTANCES");
-    Group *pGroup = _player->GetGroup();
-    if (pGroup)
-    {
-        if (pGroup->IsLeader(_player->GetGUID()))
-        {
-            pGroup->ResetInstances(INSTANCE_RESET_ALL, false, _player);
-            pGroup->ResetInstances(INSTANCE_RESET_ALL, true,_player);
-        }
-    }
-    else
-    {
-        _player->ResetInstances(INSTANCE_RESET_ALL, false);
-        _player->ResetInstances(INSTANCE_RESET_ALL, true);
-    }
-}
-
-void WorldSession::HandleSetDungeonDifficultyOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("MSG_SET_DUNGEON_DIFFICULTY");
-
-    uint32 mode;
-    recv_data >> mode;
-
-    if (mode >= MAX_DUNGEON_DIFFICULTY)
-    {
-        sLog.outError("WorldSession::HandleSetDungeonDifficultyOpcode: player %d sent an invalid instance mode %d!", _player->GetGUIDLow(), mode);
-        return;
-    }
-
-    if (Difficulty(mode) == _player->GetDungeonDifficulty())
-        return;
-
-    // cannot reset while in an instance
-    Map *map = _player->GetMap();
-    if (map && map->IsDungeon())
-    {
-        sLog.outError("WorldSession::HandleSetDungeonDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
-        return;
-    }
-
-    if (_player->getLevel() < LEVELREQUIREMENT_HEROIC)
-        return;
-
-    Group *pGroup = _player->GetGroup();
-    if (pGroup)
-    {
-        if (pGroup->IsLeader(_player->GetGUID()))
-        {
-            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player* pGroupGuy = itr->getSource();
-                if (!pGroupGuy)
-                    continue;
-
-                if (!pGroupGuy->IsInMap(pGroupGuy))
-                    return;
-
-                map = pGroupGuy->GetMap();
-                if (map && map->IsNonRaidDungeon())
-                {
-                    sLog.outError("WorldSession::HandleSetDungeonDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
-                    return;
-                }
-            }
-            // the difficulty is set even if the instances can't be reset
-            //_player->SendDungeonDifficulty(true);
-            pGroup->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, false, _player);
-            pGroup->SetDungeonDifficulty(Difficulty(mode));
-        }
-    }
-    else
-    {
-        _player->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, false);
-        _player->SetDungeonDifficulty(Difficulty(mode));
-    }
-}
-
-void WorldSession::HandleSetRaidDifficultyOpcode(WorldPacket & recv_data)
-{
-    sLog.outDebug("MSG_SET_RAID_DIFFICULTY");
-
-    uint32 mode;
-    recv_data >> mode;
-
-    if (mode >= MAX_RAID_DIFFICULTY)
-    {
-        sLog.outError("WorldSession::HandleSetRaidDifficultyOpcode: player %d sent an invalid instance mode %d!", _player->GetGUIDLow(), mode);
-        return;
-    }
-
-    // cannot reset while in an instance
-    Map *map = _player->GetMap();
-    if (map && map->IsDungeon())
-    {
-        sLog.outError("WorldSession::HandleSetRaidDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
-        return;
-    }
-
-    if (Difficulty(mode) == _player->GetRaidDifficulty())
-        return;
-
-    if (_player->getLevel() < LEVELREQUIREMENT_HEROIC)
-        return;
-
-    Group *pGroup = _player->GetGroup();
-    if (pGroup)
-    {
-        if (pGroup->IsLeader(_player->GetGUID()))
-        {
-            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
-            {
-                Player* pGroupGuy = itr->getSource();
-                if (!pGroupGuy)
-                    continue;
-
-                if (!pGroupGuy->IsInMap(pGroupGuy))
-                    return;
-
-                map = pGroupGuy->GetMap();
-                if (map && map->IsRaid())
-                {
-                    sLog.outError("WorldSession::HandleSetRaidDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
-                    return;
-                }
-            }
-            // the difficulty is set even if the instances can't be reset
-            //_player->SendDungeonDifficulty(true);
-            pGroup->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true, _player);
-            pGroup->SetRaidDifficulty(Difficulty(mode));
-        }
-    }
-    else
-    {
-        _player->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true);
-        _player->SetRaidDifficulty(Difficulty(mode));
-    }
-}
-
-void WorldSession::HandleCancelMountAuraOpcode(WorldPacket & /*recv_data*/)
-{
-    sLog.outDebug("WORLD: CMSG_CANCEL_MOUNT_AURA");
-
-    //If player is not mounted, so go out :)
-    if (!_player->IsMounted())                              // not blizz like; no any messages on blizz
-    {
-        ChatHandler(this).SendSysMessage(LANG_CHAR_NON_MOUNTED);
-        return;
-    }
-
-    if (_player->isInFlight())                               // not blizz like; no any messages on blizz
-    {
-        ChatHandler(this).SendSysMessage(LANG_YOU_IN_FLIGHT);
-        return;
-    }
-
-    _player->Unmount();
-    _player->RemoveAurasByType(SPELL_AURA_MOUNTED);
-}
-
-void WorldSession::HandleMoveSetCanFlyAckOpcode(WorldPacket & recv_data)
-{
-    // fly mode on/off
-    sLog.outDebug("WORLD: CMSG_MOVE_SET_CAN_FLY_ACK");
-    //recv_data.hexlike();
-
-    uint64 guid;                                            // guid - unused
-    recv_data.readPackGUID(guid);
-
-
-    recv_data.read_skip<uint32>();                          // unk
-
-    MovementInfo movementInfo;
-    movementInfo.guid = guid;
-    ReadMovementInfo(recv_data, &movementInfo);
-
-    recv_data.read_skip<float>();                           // unk2
-
-    _player->m_mover->m_movementInfo.flags = movementInfo.GetMovementFlags();
-}
-
-void WorldSession::HandleRequestPetInfoOpcode(WorldPacket & /*recv_data */)
-{
-    /*
-        sLog.outDebug("WORLD: CMSG_REQUEST_PET_INFO");
-        recv_data.hexlike();
-    */
-}
-
-void WorldSession::HandleSetTaxiBenchmarkOpcode(WorldPacket & recv_data)
-{
-    uint8 mode;
-    recv_data >> mode;
-
-    sLog.outDebug("Client used \"/timetest %d\" command", mode);
-}
-
-void WorldSession::HandleQueryInspectAchievements(WorldPacket & recv_data)
-{
-    uint64 guid;
-    recv_data.readPackGUID(guid);
-
-    Player *player = sObjectMgr.GetPlayer(guid);
-    if (!player)
-        return;
-
-    player->GetAchievementMgr().SendRespondInspectAchievements(_player);
-}
-
-void WorldSession::HandleWorldStateUITimerUpdate(WorldPacket& /*recv_data*/)
-{
-    // empty opcode
-    sLog.outDebug("WORLD: CMSG_WORLD_STATE_UI_TIMER_UPDATE");
-
-    WorldPacket data(SMSG_WORLD_STATE_UI_TIMER_UPDATE, 4);
-    data << uint32(time(NULL));
-    SendPacket(&data);
-}
-
-void WorldSession::HandleReadyForAccountDataTimes(WorldPacket& /*recv_data*/)
-{
-    // empty opcode
-    sLog.outDebug("WORLD: CMSG_READY_FOR_ACCOUNT_DATA_TIMES");
-
-    SendAccountDataTimes(GLOBAL_CACHE_MASK);
-}
-
-void WorldSession::SendSetPhaseShift(uint32 PhaseShift)
-{
-    WorldPacket data(SMSG_SET_PHASE_SHIFT, 4);
-    data << uint32(PhaseShift);
-    SendPacket(&data);
-}
-
-void WorldSession::HandleHearthAndResurrect(WorldPacket &recv_data)
-{
-	if (_player->isInFlight())
-		return;
-
-	AreaTableEntry const *atEntry = sAreaStore.LookupEntry(_player->GetAreaId());
-	if (!atEntry || !(atEntry->flags & AREA_FLAG_OUTDOOR_PVP2))
-		 return;
-
-	_player->BuildPlayerRepop();
-	_player->ResurrectPlayer(100);
-	_player->TeleportTo(_player->m_homebindMapId, _player->m_homebindX, _player->m_homebindY, _player->m_homebindZ, 
-		_player->GetOrientation());
-	}
-
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "Language.h"
+#include "DatabaseEnv.h"
+#include "WorldPacket.h"
+#include "Opcodes.h"
+#include "Log.h"
+#include "Player.h"
+#include "GossipDef.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "WorldSession.h"
+#include "BigNumber.h"
+#include "SHA1.h"
+#include "UpdateData.h"
+#include "LootMgr.h"
+#include "Chat.h"
+#include "zlib.h"
+#include "ObjectAccessor.h"
+#include "Object.h"
+#include "Battleground.h"
+#include "OutdoorPvP.h"
+#include "Pet.h"
+#include "SocialMgr.h"
+#include "CellImpl.h"
+#include "AccountMgr.h"
+#include "Vehicle.h"
+#include "CreatureAI.h"
+#include "DBCEnums.h"
+#include "ScriptMgr.h"
+#include "MapManager.h"
+#include "InstanceScript.h"
+#include "LFGMgr.h"
+
+void WorldSession::HandleRepopRequestOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: Recvd CMSG_REPOP_REQUEST Message");
+
+    recv_data.read_skip<uint8>();
+
+    if (GetPlayer()->isAlive()||GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        return;
+
+    // the world update order is sessions, players, creatures
+    // the netcode runs in parallel with all of these
+    // creatures can kill players
+    // so if the server is lagging enough the player can
+    // release spirit after he's killed but before he is updated
+    if (GetPlayer()->getDeathState() == JUST_DIED)
+    {
+        sLog.outDebug("HandleRepopRequestOpcode: got request after player %s(%d) was killed and before he was updated", GetPlayer()->GetName(), GetPlayer()->GetGUIDLow());
+        GetPlayer()->KillPlayer();
+    }
+
+    //this is spirit release confirm?
+    GetPlayer()->RemovePet(NULL,PET_SAVE_NOT_IN_SLOT, true);
+    GetPlayer()->BuildPlayerRepop();
+    GetPlayer()->RepopAtGraveyard();
+}
+
+void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: CMSG_GOSSIP_SELECT_OPTION");
+
+    uint32 gossipListId;
+    uint32 menuId;
+    uint64 guid;
+    std::string code = "";
+
+    recv_data >> guid >> menuId >> gossipListId;
+
+    if (_player->PlayerTalkClass->GossipOptionCoded(gossipListId))
+    {
+        // recheck
+        sLog.outBasic("reading string");
+        recv_data >> code;
+        sLog.outBasic("string read: %s", code.c_str());
+    }
+
+    Creature *unit = NULL;
+    GameObject *go = NULL;
+    if (IS_CRE_OR_VEH_GUID(guid))
+    {
+        unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+        if (!unit)
+        {
+            sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+    }
+    else if (IS_GAMEOBJECT_GUID(guid))
+    {
+        go = _player->GetMap()->GetGameObject(guid);
+        if (!go)
+        {
+            sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - GameObject (GUID: %u) not found.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+    }
+    else
+    {
+        sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - unsupported GUID type for highguid %u. lowpart %u.", uint32(GUID_HIPART(guid)), uint32(GUID_LOPART(guid)));
+        return;
+    }
+
+    // remove fake death
+    if (GetPlayer()->hasUnitState(UNIT_STAT_DIED))
+        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
+
+    if ((unit && unit->GetCreatureInfo()->ScriptID != unit->LastUsedScriptID) || (go && go->GetGOInfo()->ScriptId != go->LastUsedScriptID))
+    {
+        sLog.outDebug("WORLD: HandleGossipSelectOptionOpcode - Script reloaded while in use, ignoring and set new scipt id");
+        if (unit)
+            unit->LastUsedScriptID = unit->GetCreatureInfo()->ScriptID;
+        if (go)
+            go->LastUsedScriptID = go->GetGOInfo()->ScriptId;
+        _player->PlayerTalkClass->CloseGossip();
+        return;
+    }
+    if (!code.empty())
+    {
+        if (unit)
+        {
+            if (!sScriptMgr.OnGossipSelectCode(_player, unit, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId), code.c_str()))
+                _player->OnGossipSelect(unit, gossipListId, menuId);
+        }
+        else
+            sScriptMgr.OnGossipSelectCode(_player, go, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId), code.c_str());
+    }
+    else
+    {
+        if (unit)
+        {
+            if (!sScriptMgr.OnGossipSelect(_player, unit, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId)))
+                _player->OnGossipSelect(unit, gossipListId, menuId);
+        }
+        else
+            sScriptMgr.OnGossipSelect(_player, go, _player->PlayerTalkClass->GossipOptionSender(gossipListId), _player->PlayerTalkClass->GossipOptionAction(gossipListId));
+    }
+}
+
+void WorldSession::HandleWhoOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: Recvd CMSG_WHO Message");
+    //recv_data.hexlike();
+
+    uint32 clientcount = 0;
+
+    uint32 level_min, level_max, racemask, classmask, zones_count, str_count;
+    uint32 zoneids[10];                                     // 10 is client limit
+    std::string player_name, guild_name;
+
+    recv_data >> level_min;                                 // maximal player level, default 0
+    recv_data >> level_max;                                 // minimal player level, default 100 (MAX_LEVEL)
+    recv_data >> player_name;                               // player name, case sensitive...
+
+    recv_data >> guild_name;                                // guild name, case sensitive...
+
+    recv_data >> racemask;                                  // race mask
+    recv_data >> classmask;                                 // class mask
+    recv_data >> zones_count;                               // zones count, client limit = 10 (2.0.10)
+
+    if (zones_count > 10)
+        return;                                             // can't be received from real client or broken packet
+
+    for (uint32 i = 0; i < zones_count; ++i)
+    {
+        uint32 temp;
+        recv_data >> temp;                                  // zone id, 0 if zone is unknown...
+        zoneids[i] = temp;
+        sLog.outDebug("Zone %u: %u", i, zoneids[i]);
+    }
+
+    recv_data >> str_count;                                 // user entered strings count, client limit=4 (checked on 2.0.10)
+
+    if (str_count > 4)
+        return;                                             // can't be received from real client or broken packet
+
+    sLog.outDebug("Minlvl %u, maxlvl %u, name %s, guild %s, racemask %u, classmask %u, zones %u, strings %u", level_min, level_max, player_name.c_str(), guild_name.c_str(), racemask, classmask, zones_count, str_count);
+
+    std::wstring str[4];                                    // 4 is client limit
+    for (uint32 i = 0; i < str_count; ++i)
+    {
+        std::string temp;
+        recv_data >> temp;                                  // user entered string, it used as universal search pattern(guild+player name)?
+
+        if (!Utf8toWStr(temp,str[i]))
+            continue;
+
+        wstrToLower(str[i]);
+
+        sLog.outDebug("String %u: %s", i, temp.c_str());
+    }
+
+    std::wstring wplayer_name;
+    std::wstring wguild_name;
+    if (!(Utf8toWStr(player_name, wplayer_name) && Utf8toWStr(guild_name, wguild_name)))
+        return;
+    wstrToLower(wplayer_name);
+    wstrToLower(wguild_name);
+
+    // client send in case not set max level value 100 but Trinity supports 255 max level,
+    // update it to show GMs with characters after 100 level
+    if (level_max >= MAX_LEVEL)
+        level_max = STRONG_MAX_LEVEL;
+
+    uint32 team = _player->GetTeam();
+    uint32 security = GetSecurity();
+    bool allowTwoSideWhoList = sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_WHO_LIST);
+    uint32 gmLevelInWhoList  = sWorld.getIntConfig(CONFIG_GM_LEVEL_IN_WHO_LIST);
+
+    WorldPacket data(SMSG_WHO, 50);                       // guess size
+    data << uint32(clientcount);                            // clientcount place holder, listed count
+    data << uint32(clientcount);                            // clientcount place holder, online count
+
+    ACE_GUARD(ACE_Thread_Mutex, g, *HashMapHolder<Player>::GetLock());
+    HashMapHolder<Player>::MapType& m = sObjectAccessor.GetPlayers();
+    for (HashMapHolder<Player>::MapType::const_iterator itr = m.begin(); itr != m.end(); ++itr)
+
+    {
+        if (security == SEC_PLAYER)
+        {
+            // player can see member of other team only if CONFIG_ALLOW_TWO_SIDE_WHO_LIST
+            if (itr->second->GetTeam() != team && !allowTwoSideWhoList)
+                continue;
+
+            // player can see MODERATOR, GAME MASTER, ADMINISTRATOR only if CONFIG_GM_IN_WHO_LIST
+            if ((itr->second->GetSession()->GetSecurity() > AccountTypes(gmLevelInWhoList)))
+                continue;
+        }
+
+        //do not process players which are not in world
+        if (!(itr->second->IsInWorld()))
+            continue;
+
+        // check if target is globally visible for player
+        if (!(itr->second->IsVisibleGloballyFor(_player)))
+            continue;
+
+        // check if target's level is in level range
+        uint8 lvl = itr->second->getLevel();
+        if (lvl < level_min || lvl > level_max)
+            continue;
+
+        // check if class matches classmask
+        uint32 class_ = itr->second->getClass();
+        if (!(classmask & (1 << class_)))
+            continue;
+
+        // check if race matches racemask
+        uint32 race = itr->second->getRace();
+        if (!(racemask & (1 << race)))
+            continue;
+
+        uint32 pzoneid = itr->second->GetZoneId();
+        uint8 gender = itr->second->getGender();
+
+        bool z_show = true;
+        for (uint32 i = 0; i < zones_count; ++i)
+        {
+            if (zoneids[i] == pzoneid)
+            {
+                z_show = true;
+                break;
+            }
+
+            z_show = false;
+        }
+        if (!z_show)
+            continue;
+
+        std::string pname = itr->second->GetName();
+        std::wstring wpname;
+        if (!Utf8toWStr(pname,wpname))
+            continue;
+        wstrToLower(wpname);
+
+        if (!(wplayer_name.empty() || wpname.find(wplayer_name) != std::wstring::npos))
+            continue;
+
+        std::string gname = sObjectMgr.GetGuildNameById(itr->second->GetGuildId());
+        std::wstring wgname;
+        if (!Utf8toWStr(gname,wgname))
+            continue;
+        wstrToLower(wgname);
+
+        if (!(wguild_name.empty() || wgname.find(wguild_name) != std::wstring::npos))
+            continue;
+
+        std::string aname;
+        if (AreaTableEntry const* areaEntry = GetAreaEntryByAreaID(itr->second->GetZoneId()))
+            aname = areaEntry->area_name[GetSessionDbcLocale()];
+
+        bool s_show = true;
+        for (uint32 i = 0; i < str_count; ++i)
+        {
+            if (!str[i].empty())
+            {
+                if (wgname.find(str[i]) != std::wstring::npos ||
+                    wpname.find(str[i]) != std::wstring::npos ||
+                    Utf8FitTo(aname, str[i]))
+                {
+                    s_show = true;
+                    break;
+                }
+                s_show = false;
+            }
+        }
+        if (!s_show)
+            continue;
+
+        data << pname;                                    // player name
+        data << gname;                                    // guild name
+        data << uint32(lvl);                              // player level
+        data << uint32(class_);                           // player class
+        data << uint32(race);                             // player race
+        data << uint8(gender);                            // player gender
+        data << uint32(pzoneid);                          // player zone id
+
+        // 49 is maximum player count sent to client - can be overridden
+        // through config, but is unstable
+        if ((++clientcount) == sWorld.getIntConfig(CONFIG_MAX_WHO))
+            break;
+    }
+
+    uint32 count = m.size();
+    data.put( 0, clientcount );                             // insert right count, listed count
+    data.put( 4, count > 50 ? count : clientcount );        // insert right count, online count
+
+    SendPacket(&data);
+    sLog.outDebug("WORLD: Send SMSG_WHO Message");
+}
+
+void WorldSession::HandleLogoutRequestOpcode(WorldPacket & /*recv_data*/)
+{
+    sLog.outDebug("WORLD: Recvd CMSG_LOGOUT_REQUEST Message, security - %u", GetSecurity());
+
+    if (uint64 lguid = GetPlayer()->GetLootGUID())
+        DoLootRelease(lguid);
+
+    uint8 reason = 0;
+
+    if (GetPlayer()->isInCombat())
+        reason = 1;
+    else if (GetPlayer()->m_movementInfo.HasMovementFlag(MOVEMENTFLAG_JUMPING | MOVEMENTFLAG_FALLING))
+        reason = 3;                                         // is jumping or falling
+    else if (GetPlayer()->duel || GetPlayer()->HasAura(9454)) // is dueling or frozen by GM via freeze command
+        reason = 2;                                         // FIXME - Need the correct value
+
+    if (reason)
+    {
+        WorldPacket data(SMSG_LOGOUT_RESPONSE, 1+4);
+        data << uint8(reason);
+        data << uint32(0);
+        SendPacket(&data);
+        LogoutRequest(0);
+        return;
+    }
+
+    //instant logout in taverns/cities or on taxi or for admins, gm's, mod's if its enabled in worldserver.conf
+    if (GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) || GetPlayer()->isInFlight() ||
+        GetSecurity() >= AccountTypes(sWorld.getIntConfig(CONFIG_INSTANT_LOGOUT)))
+    {
+        WorldPacket data(SMSG_LOGOUT_RESPONSE, 1+4);
+        data << uint8(0);
+        data << uint32(16777216);
+        SendPacket(&data);
+        LogoutPlayer(true);
+        return;
+    }
+
+    // not set flags if player can't free move to prevent lost state at logout cancel
+    if (GetPlayer()->CanFreeMove())
+    {
+        GetPlayer()->SetStandState(UNIT_STAND_STATE_SIT);
+
+        WorldPacket data(SMSG_FORCE_MOVE_ROOT, (8+4));    // guess size
+        data.append(GetPlayer()->GetPackGUID());
+        data << (uint32)2;
+        SendPacket(&data);
+        GetPlayer()->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+    }
+
+    WorldPacket data(SMSG_LOGOUT_RESPONSE, 1+4);
+    data << uint8(0);
+    data << uint32(0);
+    SendPacket(&data);
+    LogoutRequest(time(NULL));
+}
+
+void WorldSession::HandlePlayerLogoutOpcode(WorldPacket & /*recv_data*/)
+{
+    sLog.outDebug("WORLD: Recvd CMSG_PLAYER_LOGOUT Message");
+}
+
+void WorldSession::HandleLogoutCancelOpcode(WorldPacket & /*recv_data*/)
+{
+    sLog.outDebug("WORLD: Recvd CMSG_LOGOUT_CANCEL Message");
+
+    LogoutRequest(0);
+
+    WorldPacket data(SMSG_LOGOUT_CANCEL_ACK, 0);
+    SendPacket(&data);
+
+    // not remove flags if can't free move - its not set in Logout request code.
+    if (GetPlayer()->CanFreeMove())
+    {
+        //!we can move again
+        data.Initialize(SMSG_FORCE_MOVE_UNROOT, 8);       // guess size
+        data.append(GetPlayer()->GetPackGUID());
+        data << uint32(0);
+        SendPacket(&data);
+
+        //! Stand Up
+        GetPlayer()->SetStandState(UNIT_STAND_STATE_STAND);
+
+        //! DISABLE_ROTATE
+        GetPlayer()->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+    }
+
+    sLog.outDebug("WORLD: sent SMSG_LOGOUT_CANCEL_ACK Message");
+}
+
+void WorldSession::HandleTogglePvP(WorldPacket & recv_data)
+{
+    // this opcode can be used in two ways: Either set explicit new status or toggle old status
+    if (recv_data.size() == 1)
+    {
+        bool newPvPStatus;
+        recv_data >> newPvPStatus;
+        GetPlayer()->ApplyModFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP, newPvPStatus);
+        GetPlayer()->ApplyModFlag(PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER, !newPvPStatus);
+    }
+    else
+    {
+        GetPlayer()->ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
+        GetPlayer()->ToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER);
+    }
+
+    if (GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))
+    {
+        if (!GetPlayer()->IsPvP() || GetPlayer()->pvpInfo.endTimer != 0)
+            GetPlayer()->UpdatePvP(true, true);
+    }
+    else
+    {
+        if (!GetPlayer()->pvpInfo.inHostileArea && GetPlayer()->IsPvP())
+            GetPlayer()->pvpInfo.endTimer = time(NULL);     // start toggle-off
+    }
+
+    //if (OutdoorPvP * pvp = _player->GetOutdoorPvP())
+    //    pvp->HandlePlayerActivityChanged(_player);
+}
+
+void WorldSession::HandleZoneUpdateOpcode(WorldPacket & recv_data)
+{
+    uint32 newZone;
+    recv_data >> newZone;
+
+    sLog.outDetail("WORLD: Recvd ZONE_UPDATE: %u", newZone);
+
+    // use server size data
+    uint32 newzone, newarea;
+    GetPlayer()->GetZoneAndAreaId(newzone,newarea);
+    GetPlayer()->UpdateZone(newzone,newarea);
+    //GetPlayer()->SendInitWorldStates(true,newZone);
+}
+
+void WorldSession::HandleSetTargetOpcode(WorldPacket & recv_data)
+{
+    uint64 guid;
+    recv_data >> guid;
+
+    _player->SetUInt32Value(UNIT_FIELD_TARGET, uint32(guid));
+
+    // update reputation list if need
+    Unit* unit = ObjectAccessor::GetUnit(*_player, guid);
+    if (!unit)
+        return;
+
+    if (FactionTemplateEntry const* factionTemplateEntry = sFactionTemplateStore.LookupEntry(unit->getFaction()))
+        _player->GetReputationMgr().SetVisible(factionTemplateEntry);
+}
+
+void WorldSession::HandleSetSelectionOpcode(WorldPacket & recv_data)
+{
+    uint64 guid;
+    recv_data >> guid;
+
+    _player->SetSelection(guid);
+
+    // update reputation list if need
+    Unit* unit = ObjectAccessor::GetUnit(*_player, guid);
+    if (!unit)
+        return;
+
+    if (FactionTemplateEntry const* factionTemplateEntry = sFactionTemplateStore.LookupEntry(unit->getFaction()))
+        _player->GetReputationMgr().SetVisible(factionTemplateEntry);
+}
+
+void WorldSession::HandleStandStateChangeOpcode(WorldPacket & recv_data)
+{
+    // sLog.outDebug("WORLD: Received CMSG_STANDSTATECHANGE"); -- too many spam in log at lags/debug stop
+    uint32 animstate;
+    recv_data >> animstate;
+
+    _player->SetStandState(animstate);
+}
+
+void WorldSession::HandleContactListOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: Received CMSG_CONTACT_LIST");
+    uint32 unk;
+    recv_data >> unk;
+    sLog.outDebug("unk value is %u", unk);
+    _player->GetSocial()->SendSocialList(_player);
+}
+
+void WorldSession::HandleAddFriendOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: Received CMSG_ADD_FRIEND");
+
+    std::string friendName = GetTrinityString(LANG_FRIEND_IGNORE_UNKNOWN);
+    std::string friendNote;
+
+    recv_data >> friendName;
+
+    recv_data >> friendNote;
+
+    if (!normalizePlayerName(friendName))
+        return;
+
+    CharacterDatabase.escape_string(friendName);            // prevent SQL injection - normal name don't must changed by this call
+
+    sLog.outDebug("WORLD: %s asked to add friend : '%s'",
+        GetPlayer()->GetName(), friendName.c_str());
+
+    m_addFriendCallback.SetParam(friendNote);
+    m_addFriendCallback.SetFutureResult(
+        CharacterDatabase.AsyncPQuery("SELECT guid, race, account FROM characters WHERE name = '%s'", friendName.c_str())
+        );
+}
+
+void WorldSession::HandleAddFriendOpcodeCallBack(QueryResult result, std::string friendNote)
+{
+    if (!GetPlayer())
+        return;
+
+    uint64 friendGuid;
+    uint32 friendAcctid;
+    uint32 team;
+    FriendsResult friendResult;
+
+    friendResult = FRIEND_NOT_FOUND;
+    friendGuid = 0;
+
+    if (result)
+    {
+        friendGuid = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+        team = Player::TeamForRace((*result)[1].GetUInt8());
+        friendAcctid = (*result)[2].GetUInt32();
+
+        if (GetSecurity() >= SEC_MODERATOR || sWorld.getBoolConfig(CONFIG_ALLOW_GM_FRIEND) || sAccountMgr.GetSecurity(friendAcctid) < SEC_MODERATOR)
+        {
+            if (friendGuid)
+            {
+                if (friendGuid == GetPlayer()->GetGUID())
+                    friendResult = FRIEND_SELF;
+                else if (GetPlayer()->GetTeam() != team && !sWorld.getBoolConfig(CONFIG_ALLOW_TWO_SIDE_ADD_FRIEND) && GetSecurity() < SEC_MODERATOR)
+                    friendResult = FRIEND_ENEMY;
+                else if (GetPlayer()->GetSocial()->HasFriend(GUID_LOPART(friendGuid)))
+                    friendResult = FRIEND_ALREADY;
+                else
+                {
+                    Player* pFriend = ObjectAccessor::FindPlayer(friendGuid);
+                    if (pFriend && pFriend->IsInWorld() && pFriend->IsVisibleGloballyFor(GetPlayer()))
+                        friendResult = FRIEND_ADDED_ONLINE;
+                    else
+                        friendResult = FRIEND_ADDED_OFFLINE;
+                    if (!GetPlayer()->GetSocial()->AddToSocialList(GUID_LOPART(friendGuid), false))
+                    {
+                        friendResult = FRIEND_LIST_FULL;
+                        sLog.outDebug("WORLD: %s's friend list is full.", GetPlayer()->GetName());
+                    }
+                }
+                GetPlayer()->GetSocial()->SetFriendNote(GUID_LOPART(friendGuid), friendNote);
+            }
+        }
+    }
+
+    sSocialMgr.SendFriendStatus(GetPlayer(), friendResult, GUID_LOPART(friendGuid), false);
+
+    sLog.outDebug("WORLD: Sent (SMSG_FRIEND_STATUS)");
+}
+
+void WorldSession::HandleDelFriendOpcode(WorldPacket & recv_data)
+{
+    uint64 FriendGUID;
+
+    sLog.outDebug("WORLD: Received CMSG_DEL_FRIEND");
+
+    recv_data >> FriendGUID;
+
+    _player->GetSocial()->RemoveFromSocialList(GUID_LOPART(FriendGUID), false);
+
+    sSocialMgr.SendFriendStatus(GetPlayer(), FRIEND_REMOVED, GUID_LOPART(FriendGUID), false);
+
+    sLog.outDebug("WORLD: Sent motd (SMSG_FRIEND_STATUS)");
+}
+
+void WorldSession::HandleAddIgnoreOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: Received CMSG_ADD_IGNORE");
+
+    std::string IgnoreName = GetTrinityString(LANG_FRIEND_IGNORE_UNKNOWN);
+
+    recv_data >> IgnoreName;
+
+    if (!normalizePlayerName(IgnoreName))
+        return;
+
+    CharacterDatabase.escape_string(IgnoreName);            // prevent SQL injection - normal name don't must changed by this call
+
+    sLog.outDebug("WORLD: %s asked to Ignore: '%s'",
+        GetPlayer()->GetName(), IgnoreName.c_str());
+
+    m_addIgnoreCallback = CharacterDatabase.AsyncPQuery("SELECT guid FROM characters WHERE name = '%s'", IgnoreName.c_str());
+}
+
+void WorldSession::HandleAddIgnoreOpcodeCallBack(QueryResult result)
+{
+    if (!GetPlayer())
+        return;
+
+    uint64 IgnoreGuid;
+    FriendsResult ignoreResult;
+
+    ignoreResult = FRIEND_IGNORE_NOT_FOUND;
+    IgnoreGuid = 0;
+
+    if (result)
+    {
+        IgnoreGuid = MAKE_NEW_GUID((*result)[0].GetUInt32(), 0, HIGHGUID_PLAYER);
+
+        if (IgnoreGuid)
+        {
+            if (IgnoreGuid == GetPlayer()->GetGUID())              //not add yourself
+                ignoreResult = FRIEND_IGNORE_SELF;
+            else if (GetPlayer()->GetSocial()->HasIgnore(GUID_LOPART(IgnoreGuid)))
+                ignoreResult = FRIEND_IGNORE_ALREADY;
+            else
+            {
+                ignoreResult = FRIEND_IGNORE_ADDED;
+
+                // ignore list full
+                if (!GetPlayer()->GetSocial()->AddToSocialList(GUID_LOPART(IgnoreGuid), true))
+                    ignoreResult = FRIEND_IGNORE_FULL;
+            }
+        }
+    }
+
+    sSocialMgr.SendFriendStatus(GetPlayer(), ignoreResult, GUID_LOPART(IgnoreGuid), false);
+
+    sLog.outDebug("WORLD: Sent (SMSG_FRIEND_STATUS)");
+}
+
+void WorldSession::HandleDelIgnoreOpcode(WorldPacket & recv_data)
+{
+    uint64 IgnoreGUID;
+
+    sLog.outDebug("WORLD: Received CMSG_DEL_IGNORE");
+
+    recv_data >> IgnoreGUID;
+
+    _player->GetSocial()->RemoveFromSocialList(GUID_LOPART(IgnoreGUID), true);
+
+    sSocialMgr.SendFriendStatus(GetPlayer(), FRIEND_IGNORE_REMOVED, GUID_LOPART(IgnoreGUID), false);
+
+    sLog.outDebug("WORLD: Sent motd (SMSG_FRIEND_STATUS)");
+}
+
+void WorldSession::HandleSetContactNotesOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("CMSG_SET_CONTACT_NOTES");
+    uint64 guid;
+    std::string note;
+    recv_data >> guid >> note;
+    _player->GetSocial()->SetFriendNote(GUID_LOPART(guid), note);
+}
+
+void WorldSession::HandleBugOpcode(WorldPacket & recv_data)
+{
+    uint32 suggestion, contentlen, typelen;
+    std::string content, type;
+
+    recv_data >> suggestion >> contentlen >> content;
+
+    recv_data >> typelen >> type;
+
+    if (suggestion == 0)
+        sLog.outDebug("WORLD: Received CMSG_BUG [Bug Report]");
+    else
+        sLog.outDebug("WORLD: Received CMSG_BUG [Suggestion]");
+
+    sLog.outDebug("%s", type.c_str());
+    sLog.outDebug("%s", content.c_str());
+
+    CharacterDatabase.escape_string(type);
+    CharacterDatabase.escape_string(content);
+    CharacterDatabase.PExecute ("INSERT INTO bugreport (type,content) VALUES('%s', '%s')", type.c_str(), content.c_str());
+}
+
+void WorldSession::HandleReclaimCorpseOpcode(WorldPacket &recv_data)
+{
+    sLog.outDetail("WORLD: Received CMSG_RECLAIM_CORPSE");
+
+    uint64 guid;
+    recv_data >> guid;
+
+    if (GetPlayer()->isAlive())
+        return;
+
+    // do not allow corpse reclaim in arena
+    if (GetPlayer()->InArena())
+        return;
+
+    // body not released yet
+    if (!GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        return;
+
+    Corpse *corpse = GetPlayer()->GetCorpse();
+
+    if (!corpse)
+        return;
+
+    // prevent resurrect before 30-sec delay after body release not finished
+    if (time_t(corpse->GetGhostTime() + GetPlayer()->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP)) > time_t(time(NULL)))
+        return;
+
+    if (!corpse->IsWithinDistInMap(GetPlayer(), CORPSE_RECLAIM_RADIUS, true))
+        return;
+
+    // resurrect
+    GetPlayer()->ResurrectPlayer(GetPlayer()->InBattleground() ? 1.0f : 0.5f);
+
+    // spawn bones
+    GetPlayer()->SpawnCorpseBones();
+}
+
+void WorldSession::HandleResurrectResponseOpcode(WorldPacket & recv_data)
+{
+    sLog.outDetail("WORLD: Received CMSG_RESURRECT_RESPONSE");
+
+    uint64 guid;
+    uint8 status;
+    recv_data >> guid;
+    recv_data >> status;
+
+    if (GetPlayer()->isAlive())
+        return;
+
+    if (status == 0)
+    {
+        GetPlayer()->clearResurrectRequestData();           // reject
+        return;
+    }
+
+    if (!GetPlayer()->isRessurectRequestedBy(guid))
+        return;
+
+    GetPlayer()->ResurectUsingRequestData();
+}
+
+void WorldSession::SendAreaTriggerMessage(const char* Text, ...)
+{
+    va_list ap;
+    char szStr [1024];
+    szStr[0] = '\0';
+
+    va_start(ap, Text);
+    vsnprintf(szStr, 1024, Text, ap);
+    va_end(ap);
+
+    uint32 length = strlen(szStr)+1;
+    WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 4+length);
+    data << length;
+    data << szStr;
+    SendPacket(&data);
+}
+
+void WorldSession::HandleAreaTriggerOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: Received CMSG_AREATRIGGER");
+
+    uint32 Trigger_ID;
+
+    recv_data >> Trigger_ID;
+    sLog.outDebug("Trigger ID:%u",Trigger_ID);
+
+    if (GetPlayer()->isInFlight())
+    {
+        sLog.outDebug("Player '%s' (GUID: %u) in flight, ignore Area Trigger ID:%u",GetPlayer()->GetName(),GetPlayer()->GetGUIDLow(), Trigger_ID);
+        return;
+    }
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(Trigger_ID);
+    if (!atEntry)
+    {
+        sLog.outDebug("Player '%s' (GUID: %u) send unknown (by DBC) Area Trigger ID:%u",GetPlayer()->GetName(),GetPlayer()->GetGUIDLow(), Trigger_ID);
+        return;
+    }
+
+    if (GetPlayer()->GetMapId() != atEntry->mapid)
+    {
+        sLog.outDebug("Player '%s' (GUID: %u) too far (trigger map: %u player map: %u), ignore Area Trigger ID: %u", GetPlayer()->GetName(), atEntry->mapid, GetPlayer()->GetMapId(), GetPlayer()->GetGUIDLow(), Trigger_ID);
+        return;
+    }
+
+    // delta is safe radius
+    const float delta = 5.0f;
+    // check if player in the range of areatrigger
+    Player* pl = GetPlayer();
+
+    if (atEntry->radius > 0)
+    {
+        // if we have radius check it
+        float dist = pl->GetDistance(atEntry->x,atEntry->y,atEntry->z);
+        if (dist > atEntry->radius + delta)
+        {
+            sLog.outDebug("Player '%s' (GUID: %u) too far (radius: %f distance: %f), ignore Area Trigger ID: %u",
+                pl->GetName(), pl->GetGUIDLow(), atEntry->radius, dist, Trigger_ID);
+            return;
+        }
+    }
+    else
+    {
+        // we have only extent
+
+        // rotate the players position instead of rotating the whole cube, that way we can make a simplified
+        // is-in-cube check and we have to calculate only one point instead of 4
+
+        // 2PI = 360, keep in mind that ingame orientation is counter-clockwise
+        double rotation = 2*M_PI-atEntry->box_orientation;
+        double sinVal = sin(rotation);
+        double cosVal = cos(rotation);
+
+        float playerBoxDistX = pl->GetPositionX() - atEntry->x;
+        float playerBoxDistY = pl->GetPositionY() - atEntry->y;
+
+        float rotPlayerX = (float)(atEntry->x + playerBoxDistX * cosVal - playerBoxDistY*sinVal);
+        float rotPlayerY = (float)(atEntry->y + playerBoxDistY * cosVal + playerBoxDistX*sinVal);
+
+        // box edges are parallel to coordiante axis, so we can treat every dimension independently :D
+        float dz = pl->GetPositionZ() - atEntry->z;
+        float dx = rotPlayerX - atEntry->x;
+        float dy = rotPlayerY - atEntry->y;
+        if ((fabs(dx) > atEntry->box_x/2 + delta) ||
+            (fabs(dy) > atEntry->box_y/2 + delta) ||
+            (fabs(dz) > atEntry->box_z/2 + delta))
+        {
+            sLog.outDebug("Player '%s' (GUID: %u) too far (1/2 box X: %f 1/2 box Y: %f 1/2 box Z: %f rotatedPlayerX: %f rotatedPlayerY: %f dZ:%f), ignore Area Trigger ID: %u",
+                pl->GetName(), pl->GetGUIDLow(), atEntry->box_x/2, atEntry->box_y/2, atEntry->box_z/2, rotPlayerX, rotPlayerY, dz, Trigger_ID);
+            return;
+        }
+    }
+
+    if (GetPlayer()->isDebugAreaTriggers)
+        ChatHandler(GetPlayer()).PSendSysMessage(LANG_DEBUG_AREATRIGGER_REACHED, Trigger_ID);
+
+    if (sScriptMgr.OnAreaTrigger(GetPlayer(), atEntry))
+        return;
+
+    uint32 quest_id = sObjectMgr.GetQuestForAreaTrigger(Trigger_ID);
+    if (quest_id && GetPlayer()->isAlive() && GetPlayer()->IsActiveQuest(quest_id))
+    {
+        Quest const* pQuest = sObjectMgr.GetQuestTemplate(quest_id);
+        if (pQuest)
+        {
+            if (GetPlayer()->GetQuestStatus(quest_id) == QUEST_STATUS_INCOMPLETE)
+                GetPlayer()->AreaExploredOrEventHappens(quest_id);
+        }
+    }
+
+    if (sObjectMgr.IsTavernAreaTrigger(Trigger_ID))
+    {
+        // set resting flag we are in the inn
+        GetPlayer()->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+        GetPlayer()->InnEnter(time(NULL), atEntry->mapid, atEntry->x, atEntry->y, atEntry->z);
+        GetPlayer()->SetRestType(REST_TYPE_IN_TAVERN);
+
+        if (sWorld.IsFFAPvPRealm())
+            GetPlayer()->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+
+        return;
+    }
+
+    if (GetPlayer()->InBattleground())
+    {
+        Battleground* bg = GetPlayer()->GetBattleground();
+        if (bg)
+            if (bg->GetStatus() == STATUS_IN_PROGRESS)
+                bg->HandleAreaTrigger(GetPlayer(), Trigger_ID);
+
+        return;
+    }
+
+    if (OutdoorPvP * pvp = GetPlayer()->GetOutdoorPvP())
+    {
+        if (pvp->HandleAreaTrigger(_player, Trigger_ID))
+            return;
+    }
+
+    // NULL if all values default (non teleport trigger)
+    AreaTrigger const* at = sObjectMgr.GetAreaTrigger(Trigger_ID);
+    if (!at)
+        return;
+
+    // Check only if target map != current player's map
+    // check if player can enter instance : instance not full, and raid instance not in encounter fight
+    if (GetPlayer()->GetMapId() != at->target_mapId && !sMapMgr.CanPlayerEnter(at->target_mapId, GetPlayer(), false))
+        return;
+
+    // Check if we are in LfgGroup and trying to get out the dungeon
+    if (GetPlayer()->GetGroup() && GetPlayer()->GetGroup()->isLFGGroup() && GetPlayer()->GetMap()->IsDungeon() && at->target_mapId != GetPlayer()->GetMapId())
+        sLFGMgr.TeleportPlayer(GetPlayer(), true);
+    else
+        GetPlayer()->TeleportTo(at->target_mapId,at->target_X,at->target_Y,at->target_Z,at->target_Orientation,TELE_TO_NOT_LEAVE_TRANSPORT);
+}
+
+void WorldSession::HandleUpdateAccountData(WorldPacket &recv_data)
+{
+    sLog.outDetail("WORLD: Received CMSG_UPDATE_ACCOUNT_DATA");
+
+    uint32 type, timestamp, decompressedSize;
+    recv_data >> type >> timestamp >> decompressedSize;
+
+    sLog.outDebug("UAD: type %u, time %u, decompressedSize %u", type, timestamp, decompressedSize);
+
+    if (type > NUM_ACCOUNT_DATA_TYPES)
+        return;
+
+    if (decompressedSize == 0)                               // erase
+    {
+        SetAccountData(AccountDataType(type), 0, "");
+
+        WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA_COMPLETE, 4+4);
+        data << uint32(type);
+        data << uint32(0);
+        SendPacket(&data);
+
+        return;
+    }
+
+    if (decompressedSize > 0xFFFF)
+    {
+        recv_data.rpos(recv_data.wpos());                   // unnneded warning spam in this case
+        sLog.outError("UAD: Account data packet too big, size %u", decompressedSize);
+        return;
+    }
+
+    ByteBuffer dest;
+    dest.resize(decompressedSize);
+
+    uLongf realSize = decompressedSize;
+    if (uncompress(const_cast<uint8*>(dest.contents()), &realSize, const_cast<uint8*>(recv_data.contents() + recv_data.rpos()), recv_data.size() - recv_data.rpos()) != Z_OK)
+    {
+        recv_data.rpos(recv_data.wpos());                   // unnneded warning spam in this case
+        sLog.outError("UAD: Failed to decompress account data");
+        return;
+    }
+
+    recv_data.rpos(recv_data.wpos());                       // uncompress read (recv_data.size() - recv_data.rpos())
+
+    std::string adata;
+    dest >> adata;
+
+    SetAccountData(AccountDataType(type), timestamp, adata);
+
+    WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA_COMPLETE, 4+4);
+    data << uint32(type);
+    data << uint32(0);
+    SendPacket(&data);
+}
+
+void WorldSession::HandleRequestAccountData(WorldPacket& recv_data)
+{
+    sLog.outDetail("WORLD: Received CMSG_REQUEST_ACCOUNT_DATA");
+
+    uint32 type;
+    recv_data >> type;
+
+    sLog.outDebug("RAD: type %u", type);
+
+    if (type > NUM_ACCOUNT_DATA_TYPES)
+        return;
+
+    AccountData *adata = GetAccountData(AccountDataType(type));
+
+    uint32 size = adata->Data.size();
+
+    uLongf destSize = compressBound(size);
+
+    ByteBuffer dest;
+    dest.resize(destSize);
+
+    if (size && compress(const_cast<uint8*>(dest.contents()), &destSize, (uint8*)adata->Data.c_str(), size) != Z_OK)
+    {
+        sLog.outDebug("RAD: Failed to compress account data");
+        return;
+    }
+
+    dest.resize(destSize);
+
+    WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA, 8+4+4+4+destSize);
+    data << uint64(_player ? _player->GetGUID() : 0);       // player guid
+    data << uint32(type);                                   // type (0-7)
+    data << uint32(adata->Time);                            // unix time
+    data << uint32(size);                                   // decompressed length
+    data.append(dest);                                      // compressed data
+    SendPacket(&data);
+}
+
+void WorldSession::HandleSetActionButtonOpcode(WorldPacket& recv_data)
+{
+    sLog.outDebug("WORLD: Received CMSG_SET_ACTION_BUTTON");
+    uint8 button;
+    uint32 packetData;
+    recv_data >> button >> packetData;
+
+    uint32 action = ACTION_BUTTON_ACTION(packetData);
+    uint8  type   = ACTION_BUTTON_TYPE(packetData);
+
+    sLog.outDetail("BUTTON: %u ACTION: %u TYPE: %u", button, action, type);
+    if (!packetData)
+    {
+        sLog.outDetail("MISC: Remove action from button %u", button);
+        GetPlayer()->removeActionButton(button);
+    }
+    else
+    {
+        switch(type)
+        {
+            case ACTION_BUTTON_MACRO:
+            case ACTION_BUTTON_CMACRO:
+                sLog.outDetail("MISC: Added Macro %u into button %u", action, button);
+                break;
+            case ACTION_BUTTON_EQSET:
+                sLog.outDetail("MISC: Added EquipmentSet %u into button %u", action, button);
+                break;
+            case ACTION_BUTTON_SPELL:
+                sLog.outDetail("MISC: Added Spell %u into button %u", action, button);
+                break;
+            case ACTION_BUTTON_ITEM:
+                sLog.outDetail("MISC: Added Item %u into button %u", action, button);
+                break;
+            default:
+                sLog.outError("MISC: Unknown action button type %u for action %u into button %u", type, action, button);
+                return;
+        }
+        GetPlayer()->addActionButton(button, action, type);
+    }
+}
+
+void WorldSession::HandleCompleteCinematic(WorldPacket & /*recv_data*/)
+{
+    sLog.outStaticDebug("WORLD: Player is watching cinema");
+}
+
+void WorldSession::HandleNextCinematicCamera(WorldPacket & /*recv_data*/)
+{
+    sLog.outStaticDebug("WORLD: Which movie to play");
+}
+
+void WorldSession::HandleMoveTimeSkippedOpcode(WorldPacket & recv_data)
+{
+    /*  WorldSession::Update(getMSTime());*/
+    sLog.outStaticDebug("WORLD: Time Lag/Synchronization Resent/Update");
+
+    uint64 guid;
+    recv_data.readPackGUID(guid);
+    recv_data.read_skip<uint32>();
+    /*
+        uint64 guid;
+        uint32 time_skipped;
+        recv_data >> guid;
+        recv_data >> time_skipped;
+        sLog.outDebug("WORLD: CMSG_MOVE_TIME_SKIPPED");
+
+        /// TODO
+        must be need use in Trinity
+        We substract server Lags to move time (AntiLags)
+        for exmaple
+        GetPlayer()->ModifyLastMoveTime(-int32(time_skipped));
+    */
+}
+
+void WorldSession::HandleFeatherFallAck(WorldPacket &recv_data)
+{
+    sLog.outStaticDebug("WORLD: CMSG_MOVE_FEATHER_FALL_ACK");
+
+    // no used
+    recv_data.rpos(recv_data.wpos());                       // prevent warnings spam
+}
+
+void WorldSession::HandleMoveUnRootAck(WorldPacket& recv_data)
+{
+    // no used
+    recv_data.rpos(recv_data.wpos());                       // prevent warnings spam
+/*
+    uint64 guid;
+    recv_data >> guid;
+
+    // now can skip not our packet
+    if (_player->GetGUID() != guid)
+    {
+        recv_data.rpos(recv_data.wpos());                   // prevent warnings spam
+        return;
+    }
+
+    sLog.outDebug("WORLD: CMSG_FORCE_MOVE_UNROOT_ACK");
+
+    recv_data.read_skip<uint32>();                          // unk
+
+    MovementInfo movementInfo;
+    movementInfo.guid = guid;
+    ReadMovementInfo(recv_data, &movementInfo);
+    recv_data.read_skip<float>();                           // unk2
+*/
+}
+
+void WorldSession::HandleMoveRootAck(WorldPacket& recv_data)
+{
+    // no used
+    recv_data.rpos(recv_data.wpos());                       // prevent warnings spam
+/*
+    uint64 guid;
+    recv_data >> guid;
+
+    // now can skip not our packet
+    if (_player->GetGUID() != guid)
+    {
+        recv_data.rpos(recv_data.wpos());                   // prevent warnings spam
+        return;
+    }
+
+    sLog.outDebug("WORLD: CMSG_FORCE_MOVE_ROOT_ACK");
+
+    recv_data.read_skip<uint32>();                          // unk
+
+    MovementInfo movementInfo;
+    ReadMovementInfo(recv_data, &movementInfo);
+*/
+}
+
+void WorldSession::HandleSetActionBarToggles(WorldPacket& recv_data)
+{
+    uint8 ActionBar;
+
+    recv_data >> ActionBar;
+
+    if (!GetPlayer())                                        // ignore until not logged (check needed because STATUS_AUTHED)
+    {
+        if (ActionBar != 0)
+            sLog.outError("WorldSession::HandleSetActionBarToggles in not logged state with value: %u, ignored",uint32(ActionBar));
+        return;
+    }
+
+    GetPlayer()->SetByteValue(PLAYER_FIELD_BYTES, 2, ActionBar);
+}
+
+void WorldSession::HandleWardenDataOpcode(WorldPacket& recv_data)
+{
+    recv_data.read_skip<uint8>();
+    /*
+        uint8 tmp;
+        recv_data >> tmp;
+        sLog.outDebug("Received opcode CMSG_WARDEN_DATA, not resolve.uint8 = %u",tmp);
+    */
+}
+
+void WorldSession::HandlePlayedTime(WorldPacket& recv_data)
+{
+    uint8 unk1;
+    recv_data >> unk1;                                      // 0 or 1 expected
+
+    WorldPacket data(SMSG_PLAYED_TIME, 4 + 4 + 1);
+    data << uint32(_player->GetTotalPlayedTime());
+    data << uint32(_player->GetLevelPlayedTime());
+    data << uint8(unk1);                                    // 0 - will not show in chat frame
+    SendPacket(&data);
+}
+
+void WorldSession::HandleInspectOpcode(WorldPacket& recv_data)
+{
+    uint64 guid;
+    recv_data >> guid;
+    sLog.outStaticDebug("Inspected guid is " UI64FMTD, guid);
+
+    _player->SetSelection(guid);
+
+    Player *plr = sObjectMgr.GetPlayer(guid);
+    if (!plr)                                                // wrong player
+        return;
+
+    uint32 talent_points = 0x47;
+    uint32 guid_size = plr->GetPackGUID().wpos();
+    WorldPacket data(SMSG_INSPECT_TALENT, guid_size+4+talent_points);
+    data.append(plr->GetPackGUID());
+
+    if (sWorld.getBoolConfig(CONFIG_TALENTS_INSPECTING) || _player->isGameMaster())
+    {
+        plr->BuildPlayerTalentsInfoData(&data);
+    }
+    else
+    {
+        data << uint32(0);                                  // unspentTalentPoints
+        data << uint8(0);                                   // talentGroupCount
+        data << uint8(0);                                   // talentGroupIndex
+    }
+
+    plr->BuildEnchantmentsInfoData(&data);
+    SendPacket(&data);
+}
+
+void WorldSession::HandleInspectHonorStatsOpcode(WorldPacket& recv_data)
+{
+    uint64 guid;
+    recv_data >> guid;
+
+    Player *player = sObjectMgr.GetPlayer(guid);
+
+    if (!player)
+    {
+        sLog.outError("InspectHonorStats: WTF, player not found...");
+        return;
+    }
+
+    WorldPacket data(MSG_INSPECT_HONOR_STATS, 8+1+4*4);
+    data << uint64(player->GetGUID());
+    data << uint8(player->GetHonorPoints());
+    data << uint32(player->GetUInt32Value(PLAYER_FIELD_KILLS));
+    data << uint32(player->GetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION));
+    data << uint32(player->GetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION));
+    data << uint32(player->GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
+    SendPacket(&data);
+}
+
+void WorldSession::HandleWorldTeleportOpcode(WorldPacket& recv_data)
+{
+    // write in client console: worldport 469 452 6454 2536 180 or /console worldport 469 452 6454 2536 180
+    // Received opcode CMSG_WORLD_TELEPORT
+    // Time is ***, map=469, x=452.000000, y=6454.000000, z=2536.000000, orient=3.141593
+
+    uint32 time;
+    uint32 mapid;
+    float PositionX;
+    float PositionY;
+    float PositionZ;
+    float Orientation;
+
+    recv_data >> time;                                      // time in m.sec.
+    recv_data >> mapid;
+    recv_data >> PositionX;
+    recv_data >> PositionY;
+    recv_data >> PositionZ;
+    recv_data >> Orientation;                               // o (3.141593 = 180 degrees)
+
+    //sLog.outDebug("Received opcode CMSG_WORLD_TELEPORT");
+    if (GetPlayer()->isInFlight())
+    {
+        sLog.outDebug("Player '%s' (GUID: %u) in flight, ignore worldport command.",GetPlayer()->GetName(),GetPlayer()->GetGUIDLow());
+        return;
+    }
+
+    sLog.outStaticDebug("Time %u sec, map=%u, x=%f, y=%f, z=%f, orient=%f", time/1000, mapid, PositionX, PositionY, PositionZ, Orientation);
+
+    if (GetSecurity() >= SEC_ADMINISTRATOR)
+        GetPlayer()->TeleportTo(mapid,PositionX,PositionY,PositionZ,Orientation);
+    else
+        SendNotification(LANG_YOU_NOT_HAVE_PERMISSION);
+    sLog.outDebug("Received worldport command from player %s", GetPlayer()->GetName());
+}
+
+void WorldSession::HandleWhoisOpcode(WorldPacket& recv_data)
+{
+    sLog.outDebug("Received opcode CMSG_WHOIS");
+    std::string charname;
+    recv_data >> charname;
+
+    if (GetSecurity() < SEC_ADMINISTRATOR)
+    {
+        SendNotification(LANG_YOU_NOT_HAVE_PERMISSION);
+        return;
+    }
+
+    if (charname.empty() || !normalizePlayerName (charname))
+    {
+        SendNotification(LANG_NEED_CHARACTER_NAME);
+        return;
+    }
+
+    Player *plr = sObjectMgr.GetPlayer(charname.c_str());
+
+    if (!plr)
+    {
+        SendNotification(LANG_PLAYER_NOT_EXIST_OR_OFFLINE, charname.c_str());
+        return;
+    }
+
+    uint32 accid = plr->GetSession()->GetAccountId();
+
+    QueryResult result = LoginDatabase.PQuery("SELECT username,email,last_ip FROM account WHERE id=%u", accid);
+    if (!result)
+    {
+        SendNotification(LANG_ACCOUNT_FOR_PLAYER_NOT_FOUND, charname.c_str());
+        return;
+    }
+
+    Field *fields = result->Fetch();
+    std::string acc = fields[0].GetString();
+    if (acc.empty())
+        acc = "Unknown";
+    std::string email = fields[1].GetString();
+    if (email.empty())
+        email = "Unknown";
+    std::string lastip = fields[2].GetString();
+    if (lastip.empty())
+        lastip = "Unknown";
+
+    std::string msg = charname + "'s " + "account is " + acc + ", e-mail: " + email + ", last ip: " + lastip;
+
+    WorldPacket data(SMSG_WHOIS, msg.size()+1);
+    data << msg;
+    _player->GetSession()->SendPacket(&data);
+
+    sLog.outDebug("Received whois command from player %s for character %s", GetPlayer()->GetName(), charname.c_str());
+}
+
+void WorldSession::HandleComplainOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: CMSG_COMPLAIN");
+    recv_data.hexlike();
+
+    uint8 spam_type;                                        // 0 - mail, 1 - chat
+    uint64 spammer_guid;
+    uint32 unk1 = 0;
+    uint32 unk2 = 0;
+    uint32 unk3 = 0;
+    uint32 unk4 = 0;
+    std::string description = "";
+    recv_data >> spam_type;                                 // unk 0x01 const, may be spam type (mail/chat)
+    recv_data >> spammer_guid;                              // player guid
+    switch(spam_type)
+    {
+        case 0:
+            recv_data >> unk1;                              // const 0
+            recv_data >> unk2;                              // probably mail id
+            recv_data >> unk3;                              // const 0
+            break;
+        case 1:
+            recv_data >> unk1;                              // probably language
+            recv_data >> unk2;                              // message type?
+            recv_data >> unk3;                              // probably channel id
+            recv_data >> unk4;                              // unk random value
+            recv_data >> description;                       // spam description string (messagetype, channel name, player name, message)
+            break;
+    }
+
+    // NOTE: all chat messages from this spammer automatically ignored by spam reporter until logout in case chat spam.
+    // if it's mail spam - ALL mails from this spammer automatically removed by client
+
+    // Complaint Received message
+    WorldPacket data(SMSG_COMPLAIN_RESULT, 1);
+    data << uint8(0);
+    SendPacket(&data);
+
+    sLog.outDebug("REPORT SPAM: type %u, guid %u, unk1 %u, unk2 %u, unk3 %u, unk4 %u, message %s", spam_type, GUID_LOPART(spammer_guid), unk1, unk2, unk3, unk4, description.c_str());
+}
+
+void WorldSession::HandleRealmSplitOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("CMSG_REALM_SPLIT");
+
+    uint32 unk;
+    std::string split_date = "01/01/01";
+    recv_data >> unk;
+
+    WorldPacket data(SMSG_REALM_SPLIT, 4+4+split_date.size()+1);
+    data << unk;
+    data << uint32(0x00000000);                             // realm split state
+    // split states:
+    // 0x0 realm normal
+    // 0x1 realm split
+    // 0x2 realm split pending
+    data << split_date;
+    SendPacket(&data);
+    //sLog.outDebug("response sent %u", unk);
+}
+
+void WorldSession::HandleFarSightOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("WORLD: CMSG_FAR_SIGHT");
+    //recv_data.hexlike();
+
+    uint8 apply;
+    recv_data >> apply;
+
+    switch(apply)
+    {
+        case 0:
+            sLog.outDebug("Player %u set vision to self", _player->GetGUIDLow());
+            _player->SetSeer(_player);
+            break;
+        case 1:
+            sLog.outDebug("Added FarSight " UI64FMTD " to player %u", _player->GetUInt64Value(PLAYER_FARSIGHT), _player->GetGUIDLow());
+            if (WorldObject *target = _player->GetViewpoint())
+                _player->SetSeer(target);
+            else
+                sLog.outError("Player %s requests non-existing seer", _player->GetName());
+            break;
+        default:
+            sLog.outDebug("Unhandled mode in CMSG_FAR_SIGHT: %u", apply);
+            return;
+    }
+
+    GetPlayer()->UpdateVisibilityForPlayer();
+}
+
+void WorldSession::HandleSetTitleOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("CMSG_SET_TITLE");
+
+    int32 title;
+    recv_data >> title;
+
+    // -1 at none
+    if (title > 0 && title < MAX_TITLE_INDEX)
+    {
+       if (!GetPlayer()->HasTitle(title))
+            return;
+    }
+    else
+        title = 0;
+
+    GetPlayer()->SetUInt32Value(PLAYER_CHOSEN_TITLE, title);
+}
+
+void WorldSession::HandleTimeSyncResp(WorldPacket & recv_data)
+{
+    sLog.outDebug("CMSG_TIME_SYNC_RESP");
+
+    uint32 counter, clientTicks;
+    recv_data >> counter >> clientTicks;
+
+    if (counter != _player->m_timeSyncCounter - 1)
+        sLog.outDebug("Wrong time sync counter from player %s (cheater?)", _player->GetName());
+
+    sLog.outDebug("Time sync received: counter %u, client ticks %u, time since last sync %u", counter, clientTicks, clientTicks - _player->m_timeSyncClient);
+
+    uint32 ourTicks = clientTicks + (getMSTime() - _player->m_timeSyncServer);
+
+    // diff should be small
+    sLog.outDebug("Our ticks: %u, diff %u, latency %u", ourTicks, ourTicks - clientTicks, GetLatency());
+
+    _player->m_timeSyncClient = clientTicks;
+}
+
+void WorldSession::HandleResetInstancesOpcode(WorldPacket & /*recv_data*/)
+{
+    sLog.outDebug("WORLD: CMSG_RESET_INSTANCES");
+    Group *pGroup = _player->GetGroup();
+    if (pGroup)
+    {
+        if (pGroup->IsLeader(_player->GetGUID()))
+        {
+            pGroup->ResetInstances(INSTANCE_RESET_ALL, false, _player);
+            pGroup->ResetInstances(INSTANCE_RESET_ALL, true,_player);
+        }
+    }
+    else
+    {
+        _player->ResetInstances(INSTANCE_RESET_ALL, false);
+        _player->ResetInstances(INSTANCE_RESET_ALL, true);
+    }
+}
+
+void WorldSession::HandleSetDungeonDifficultyOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("MSG_SET_DUNGEON_DIFFICULTY");
+
+    uint32 mode;
+    recv_data >> mode;
+
+    if (mode >= MAX_DUNGEON_DIFFICULTY)
+    {
+        sLog.outError("WorldSession::HandleSetDungeonDifficultyOpcode: player %d sent an invalid instance mode %d!", _player->GetGUIDLow(), mode);
+        return;
+    }
+
+    if (Difficulty(mode) == _player->GetDungeonDifficulty())
+        return;
+
+    // cannot reset while in an instance
+    Map *map = _player->GetMap();
+    if (map && map->IsDungeon())
+    {
+        sLog.outError("WorldSession::HandleSetDungeonDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
+        return;
+    }
+
+    if (_player->getLevel() < LEVELREQUIREMENT_HEROIC)
+        return;
+
+    Group *pGroup = _player->GetGroup();
+    if (pGroup)
+    {
+        if (pGroup->IsLeader(_player->GetGUID()))
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* pGroupGuy = itr->getSource();
+                if (!pGroupGuy)
+                    continue;
+
+                if (!pGroupGuy->IsInMap(pGroupGuy))
+                    return;
+
+                map = pGroupGuy->GetMap();
+                if (map && map->IsRaidOrHeroicDungeon())
+                {
+                    sLog.outError("WorldSession::HandleSetDungeonDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
+                    return;
+                }
+            }
+            // the difficulty is set even if the instances can't be reset
+            //_player->SendDungeonDifficulty(true);
+            pGroup->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, false, _player);
+            pGroup->SetDungeonDifficulty(Difficulty(mode));
+        }
+    }
+    else
+    {
+        _player->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, false);
+        _player->SetDungeonDifficulty(Difficulty(mode));
+    }
+}
+
+void WorldSession::HandleSetRaidDifficultyOpcode(WorldPacket & recv_data)
+{
+    sLog.outDebug("MSG_SET_RAID_DIFFICULTY");
+
+    uint32 mode;
+    recv_data >> mode;
+
+    if (mode >= MAX_RAID_DIFFICULTY)
+    {
+        sLog.outError("WorldSession::HandleSetRaidDifficultyOpcode: player %d sent an invalid instance mode %d!", _player->GetGUIDLow(), mode);
+        return;
+    }
+
+    // cannot reset while in an instance
+    Map *map = _player->GetMap();
+    if (map && map->IsDungeon())
+    {
+        sLog.outError("WorldSession::HandleSetRaidDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
+        return;
+    }
+
+    if (Difficulty(mode) == _player->GetRaidDifficulty())
+        return;
+
+    if (_player->getLevel() < LEVELREQUIREMENT_HEROIC)
+        return;
+
+    Group *pGroup = _player->GetGroup();
+    if (pGroup)
+    {
+        if (pGroup->IsLeader(_player->GetGUID()))
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* pGroupGuy = itr->getSource();
+                if (!pGroupGuy)
+                    continue;
+
+                if (!pGroupGuy->IsInMap(pGroupGuy))
+                    return;
+
+                map = pGroupGuy->GetMap();
+                if (map && map->IsRaidOrHeroicDungeon())
+                {
+                    sLog.outError("WorldSession::HandleSetRaidDifficultyOpcode: player %d tried to reset the instance while inside!", _player->GetGUIDLow());
+                    return;
+                }
+            }
+            // the difficulty is set even if the instances can't be reset
+            //_player->SendDungeonDifficulty(true);
+            pGroup->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true, _player);
+            pGroup->SetRaidDifficulty(Difficulty(mode));
+        }
+    }
+    else
+    {
+        _player->ResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true);
+        _player->SetRaidDifficulty(Difficulty(mode));
+    }
+}
+
+void WorldSession::HandleCancelMountAuraOpcode(WorldPacket & /*recv_data*/)
+{
+    sLog.outDebug("WORLD: CMSG_CANCEL_MOUNT_AURA");
+
+    //If player is not mounted, so go out :)
+    if (!_player->IsMounted())                              // not blizz like; no any messages on blizz
+    {
+        ChatHandler(this).SendSysMessage(LANG_CHAR_NON_MOUNTED);
+        return;
+    }
+
+    if (_player->isInFlight())                               // not blizz like; no any messages on blizz
+    {
+        ChatHandler(this).SendSysMessage(LANG_YOU_IN_FLIGHT);
+        return;
+    }
+
+    _player->Unmount();
+    _player->RemoveAurasByType(SPELL_AURA_MOUNTED);
+}
+
+void WorldSession::HandleMoveSetCanFlyAckOpcode(WorldPacket & recv_data)
+{
+    // fly mode on/off
+    sLog.outDebug("WORLD: CMSG_MOVE_SET_CAN_FLY_ACK");
+    //recv_data.hexlike();
+
+    uint64 guid;                                            // guid - unused
+    recv_data.readPackGUID(guid);
+
+
+    recv_data.read_skip<uint32>();                          // unk
+
+    MovementInfo movementInfo;
+    movementInfo.guid = guid;
+    ReadMovementInfo(recv_data, &movementInfo);
+
+    recv_data.read_skip<float>();                           // unk2
+
+    _player->m_mover->m_movementInfo.flags = movementInfo.GetMovementFlags();
+}
+
+void WorldSession::HandleRequestPetInfoOpcode(WorldPacket & /*recv_data */)
+{
+    /*
+        sLog.outDebug("WORLD: CMSG_REQUEST_PET_INFO");
+        recv_data.hexlike();
+    */
+}
+
+void WorldSession::HandleSetTaxiBenchmarkOpcode(WorldPacket & recv_data)
+{
+    uint8 mode;
+    recv_data >> mode;
+
+    sLog.outDebug("Client used \"/timetest %d\" command", mode);
+}
+
+void WorldSession::HandleQueryInspectAchievements(WorldPacket & recv_data)
+{
+    uint64 guid;
+    recv_data.readPackGUID(guid);
+
+    Player *player = sObjectMgr.GetPlayer(guid);
+    if (!player)
+        return;
+
+    player->GetAchievementMgr().SendRespondInspectAchievements(_player);
+}
+
+void WorldSession::HandleWorldStateUITimerUpdate(WorldPacket& /*recv_data*/)
+{
+    // empty opcode
+    sLog.outDebug("WORLD: CMSG_WORLD_STATE_UI_TIMER_UPDATE");
+
+    WorldPacket data(SMSG_WORLD_STATE_UI_TIMER_UPDATE, 4);
+    data << uint32(time(NULL));
+    SendPacket(&data);
+}
+
+void WorldSession::HandleReadyForAccountDataTimes(WorldPacket& /*recv_data*/)
+{
+    // empty opcode
+    sLog.outDebug("WORLD: CMSG_READY_FOR_ACCOUNT_DATA_TIMES");
+
+    SendAccountDataTimes(GLOBAL_CACHE_MASK);
+}
+
+void WorldSession::SendSetPhaseShift(uint32 PhaseShift)
+{
+    WorldPacket data(SMSG_SET_PHASE_SHIFT, 4);
+    data << uint32(PhaseShift);
+    SendPacket(&data);
+}
+
+void WorldSession::HandleHearthAndResurrect(WorldPacket &recv_data)
+{
+	if (_player->isInFlight())
+		return;
+
+	AreaTableEntry const *atEntry = sAreaStore.LookupEntry(_player->GetAreaId());
+	if (!atEntry || !(atEntry->flags & AREA_FLAG_OUTDOOR_PVP2))
+		 return;
+
+	_player->BuildPlayerRepop();
+	_player->ResurrectPlayer(100);
+	_player->TeleportTo(_player->m_homebindMapId, _player->m_homebindX, _player->m_homebindY, _player->m_homebindZ, 
+		_player->GetOrientation());
+	}
+
 
  
  
  
- 
+ 
diff --git a/src/server/game/Server/Protocol/Handlers/PetHandler.cpp b/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/PetHandler.cpp
@@ -869,3 +869,5 @@
 
     _player->SendTalentsInfoData(true);
 }
+
+
diff --git a/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp b/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/SpellHandler.cpp
@@ -418,6 +418,9 @@
     if (!spellInfo)
         return;
 
+    if (IsPassiveSpell(spellId))
+        return;
+
     // not allow remove non positive spells and spells with attr SPELL_ATTR_CANT_CANCEL
     if (!IsPositiveSpell(spellId) || (spellInfo->Attributes & SPELL_ATTR_CANT_CANCEL))
         return;
diff --git a/src/server/game/Server/Protocol/Opcodes.cpp b/src/server/game/Server/Protocol/Opcodes.cpp
--- a/src/server/game/Server/Protocol/Opcodes.cpp
+++ b/src/server/game/Server/Protocol/Opcodes.cpp
@@ -774,7 +774,7 @@
     /*0x2E7*/ { "CMSG_WARDEN_DATA",                             STATUS_LOGGEDIN, &WorldSession::HandleWardenDataOpcode          },
     /*0x2E8*/ { "SMSG_GROUP_JOINED_BATTLEGROUND",               STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x2E9*/ { "MSG_BATTLEGROUND_PLAYER_POSITIONS",            STATUS_LOGGEDIN, &WorldSession::HandleBattlegroundPlayerPositionsOpcode},
-    /*0x2EA*/ { "CMSG_PET_STOP_ATTACK",                         STATUS_LOGGEDIN, &WorldSession::HandlePetStopAttack             },
+    /*0x2EA*/ { "CMSG_PET_STOP_ATTACK",                         STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x2EB*/ { "SMSG_BINDER_CONFIRM",                          STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x2EC*/ { "SMSG_BATTLEGROUND_PLAYER_JOINED",              STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x2ED*/ { "SMSG_BATTLEGROUND_PLAYER_LEFT",                STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -676,7 +676,6 @@
 
         //Pet
         void HandlePetAction(WorldPacket & recv_data);
-        void HandlePetStopAttack(WorldPacket& recv_data);
         void HandlePetActionHelper(Unit *pet, uint64 guid1, uint16 spellid, uint16 flag, uint64 guid2);
         void HandlePetNameQuery(WorldPacket & recv_data);
         void HandlePetSetAction(WorldPacket & recv_data);
@@ -688,6 +687,7 @@
         void HandlePetCastSpellOpcode(WorldPacket& recvPacket);
         void HandlePetLearnTalent(WorldPacket& recvPacket);
         void HandleLearnPreviewTalentsPet(WorldPacket& recvPacket);
+        void HandlePetStopAttack(WorldPacket& recv_data);
 
         void HandleSetActionBarToggles(WorldPacket& recv_data);
 
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -481,7 +481,7 @@
                     if (GetSpellProto()->SpellFamilyFlags[1] & 0x1 && GetSpellProto()->SpellFamilyFlags[2] & 0x8)
                     {
                         // +80.68% from sp bonus
-                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto)) * 0.8068f;
+                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto), m_spellProto) * 0.8068f;
                         // Glyph of Ice Barrier: its weird having a SPELLMOD_ALL_EFFECTS here but its blizzards doing :)
                         // Glyph of Ice Barrier is only applied at the spell damage bonus because it was already applied to the base value in CalculateSpellDamage
                         if (Player* modOwner = caster->GetSpellModOwner())
@@ -491,13 +491,13 @@
                     else if(GetSpellProto()->SpellFamilyFlags[0] & 0x8 && GetSpellProto()->SpellFamilyFlags[2] & 0x8)
                     {
                         // +80.68% from sp bonus
-                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto)) * 0.8068f;
+                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto), m_spellProto) * 0.8068f;
                     }
                     // Frost Ward
                     else if(GetSpellProto()->SpellFamilyFlags[0] & 0x100 && GetSpellProto()->SpellFamilyFlags[2] & 0x8)
                     {
                         // +80.68% from sp bonus
-                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto)) * 0.8068f;
+                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto), m_spellProto) * 0.8068f;
                     }
                     break;
                 case SPELLFAMILY_WARLOCK:
@@ -505,7 +505,7 @@
                     if (m_spellProto->SpellFamilyFlags[2] & 0x40)
                     {
                         // +80.68% from sp bonus
-                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto)) * 0.8068f;
+                        DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto), m_spellProto) * 0.8068f;
                     }
                     break;
                 case SPELLFAMILY_PRIEST:
@@ -531,7 +531,7 @@
                         if (pAurEff)
                             bonus += (float)pAurEff->GetAmount() / 100.0f;
 
-                        DoneActualBenefit = caster->SpellBaseHealingBonus(GetSpellSchoolMask(GetSpellProto())) * bonus;
+                        DoneActualBenefit = caster->SpellBaseHealingBonus(GetSpellSchoolMask(GetSpellProto()), GetSpellProto()) * bonus;
                     }
                     break;
                 case SPELLFAMILY_PALADIN:
@@ -539,7 +539,7 @@
                     if (m_spellProto->SpellFamilyFlags[1] & 0x80000)
                     {
                         // 0.75 from sp bonus
-                        DoneActualBenefit = caster->SpellBaseHealingBonus(GetSpellSchoolMask(m_spellProto)) * 0.75f;
+                        DoneActualBenefit = caster->SpellBaseHealingBonus(GetSpellSchoolMask(m_spellProto), m_spellProto) * 0.75f;
                     }
                     break;
                 default:
@@ -554,7 +554,7 @@
             if (GetSpellProto()->SpellFamilyName == SPELLFAMILY_MAGE && GetSpellProto()->SpellFamilyFlags[0] & 0x8000 && m_spellProto->SpellFamilyFlags[2] & 0x8)
             {
                 // +80.53% from +spd bonus
-                DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto)) * 0.8053f;;
+                DoneActualBenefit += caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto), m_spellProto) * 0.8053f;;
             }
             break;
         case SPELL_AURA_DUMMY:
@@ -570,7 +570,7 @@
             // Thorns
             if (GetSpellProto()->SpellFamilyName == SPELLFAMILY_DRUID && m_spellProto->SpellFamilyFlags[0] & 0x100)
                 // 3.3% from sp bonus
-                DoneActualBenefit = caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto)) * 0.033f;
+                DoneActualBenefit = caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellProto), m_spellProto) * 0.033f;
             break;
         case SPELL_AURA_PERIODIC_DAMAGE:
             if (!caster)
@@ -1037,11 +1037,8 @@
             UnitList effectTargets;
             GetTargetList(effectTargets);
             // tick on targets of effects
-            if (!caster || !caster->hasUnitState(UNIT_STAT_ISOLATED))
-            {
-                for (UnitList::iterator targetItr = effectTargets.begin(); targetItr != effectTargets.end(); ++targetItr)
-                    PeriodicTick(*targetItr, caster);
-            }
+            for (UnitList::iterator targetItr = effectTargets.begin(); targetItr != effectTargets.end(); ++targetItr)
+                PeriodicTick(*targetItr, caster);
         }
     }
 }
@@ -1207,6 +1204,12 @@
     if (prevented)
         return;
 
+    // Ignore effects of area auras if unit owner is isolated
+    if (GetBase()->GetType() == UNIT_AURA_TYPE &&
+        GetBase()->GetUnitOwner() &&
+        GetBase()->GetUnitOwner()->hasUnitState(UNIT_STAT_ISOLATED))
+        return;
+
     switch(GetAuraType())
     {
         case SPELL_AURA_PERIODIC_DAMAGE:
@@ -1243,6 +1246,7 @@
                 {
                     case 43093: case 31956: case 38801:  // Grievous Wound
                     case 35321: case 38363: case 39215:  // Gushing Wound
+                    case 48920: // Grievous Bite
                         if (target->IsFullHealth())
                         {
                             target->RemoveAurasDueToSpell(GetId());
@@ -2709,6 +2713,9 @@
 
     Unit * target = aurApp->GetTarget();
 
+	 if (target->IsVehicle())
+        return;
+
     if (apply)
     {
         target->m_detectInvisibilityMask |= (1 << GetMiscValue());
@@ -2732,6 +2739,10 @@
 
     Unit * target = aurApp->GetTarget();
 
+	
+    if (target->IsVehicle())
+       return;
+
     if (apply)
     {
         target->m_invisibilityMask |= (1 << GetMiscValue());
@@ -3881,11 +3892,11 @@
 
     Unit * target = aurApp->GetTarget();
 
-    if (!target->isAlive())
+    if (target->isDead())
         return;
 
     Unit * caster = GetCaster();
-    if (!caster || !caster->isAlive())
+    if (!caster || caster->isDead())
         return;
 
     if (target->GetTypeId() == TYPEID_PLAYER)
@@ -3901,11 +3912,11 @@
 
     Unit * target = aurApp->GetTarget();
 
-    if (!target->isAlive() || target->GetTypeId() != TYPEID_PLAYER)
+    if (target->isDead() || target->GetTypeId() != TYPEID_PLAYER)
         return;
 
     Unit * caster = GetCaster();
-    if (!caster || !caster->isAlive())
+    if (!caster || caster->isDead())
         return;
 
     target->getHostileRefManager().addTempThreat((float)GetAmount(), apply);
@@ -3918,11 +3929,11 @@
 
     Unit * target = aurApp->GetTarget();
 
-    if (!target->isAlive() || !target->CanHaveThreatList())
+    if (target->isDead() || !target->CanHaveThreatList())
         return;
 
     Unit * caster = GetCaster();
-    if (!caster || !caster->isAlive())
+    if (!caster || caster->isDead())
         return;
 
     if (apply)
@@ -4878,9 +4889,7 @@
 
     Unit * target = aurApp->GetTarget();
 
-    Powers powerType = target->getPowerType();
-    if (int32(powerType) != GetMiscValue())
-        return;
+    Powers powerType = Powers(GetMiscValue());
 
     UnitMods unitMod = UnitMods(UNIT_MOD_POWER_START + powerType);
 
@@ -4907,9 +4916,7 @@
 
     Unit * target = aurApp->GetTarget();
 
-    Powers powerType = target->getPowerType();
-    if (int32(powerType) != GetMiscValue())
-        return;
+    Powers powerType = Powers(GetMiscValue());
 
     UnitMods unitMod = UnitMods(UNIT_MOD_POWER_START + powerType);
 
@@ -5859,7 +5866,7 @@
                             return;
 
                         // final heal
-                        int32 stack = GetBase()->GetStackAmount();
+                        int32 stack = GetBase()->GetStackAmount() > 0 ? GetBase()->GetStackAmount() : 1;
                         target->CastCustomSpell(target, 33778, &m_amount, &stack, NULL, true, NULL, this, GetCasterGUID());
 
                         // restore mana
@@ -5872,13 +5879,21 @@
                     break;
                 case SPELLFAMILY_PRIEST:
                     // Vampiric Touch
-                    if (m_spellProto->SpellFamilyFlags[1] & 0x0400 && aurApp->GetRemoveMode() == AURA_REMOVE_BY_ENEMY_SPELL)
+                    if (caster && m_spellProto->SpellFamilyFlags[1] & 0x0400 && aurApp->GetRemoveMode() == AURA_REMOVE_BY_ENEMY_SPELL)
                     {
                         if (AuraEffect const * aurEff = GetBase()->GetEffect(1))
                         {
-                            int32 damage = aurEff->GetAmount()*4;
-                            // backfire damage
-                            target->CastCustomSpell(target, 64085, &damage, NULL, NULL, true, NULL, NULL,GetCasterGUID());
+                             if (GetEffIndex() == 0) {
+                                // backfire damage
+                                int32 damage = caster->SpellDamageBonus(target, GetSpellProto(), aurEff->GetAmount(), DOT) * 3;
+                                target->CastCustomSpell(target, 64085, &damage, NULL, NULL, true, NULL, NULL, GetCasterGUID());
+                            }
+                            else {
+                                // Shadow Affinity
+                                int32 returnmana = (GetSpellProto()->ManaCostPercentage * caster->GetCreateMana() / 100);
+                                if (AuraEffect* aureff = caster->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PRIEST, 178, 1))
+                                    caster->CastCustomSpell(caster, 64103, &returnmana, NULL, NULL, true, NULL, this, GetCasterGUID());
+                            }
                         }
                     }
                     break;
diff --git a/src/server/game/Spells/Auras/SpellAuras.cpp b/src/server/game/Spells/Auras/SpellAuras.cpp
--- a/src/server/game/Spells/Auras/SpellAuras.cpp
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp
@@ -610,6 +610,15 @@
         }
     }
 
+    if (caster && caster->IsInWorld() && !caster->IsInMap(m_owner)) {
+        Remove();
+    }
+
+    if (caster && caster->IsInWorld() && !caster->IsInMap(m_owner))
+    {
+        Remove();
+    }
+
     Update(diff, caster);
 
     if (m_updateTargetMapInterval <= int32(diff))
@@ -1342,6 +1351,12 @@
                     case 25771: // Remove the immunity shield marker on Forbearance removal if AW marker is not present
                         if (target->HasAura(61988) && !target->HasAura(61987))
                             target->RemoveAura(61988);
+						// Hodir Flash Freeze immunity remove
+               if (GetId() == 61990 && removeMode == AURA_REMOVE_BY_DEATH)
+                  target->RemoveAura(7940);
+						// Darkmoon Card: Illusion
+                if (GetId() == 57350 && target->getPowerType() == POWER_MANA)
+                    target->CastSpell(target, 60242, true);
                         break;
                     case 199997: // Divine Storm Helper (SERVERSIDE)
                     {
@@ -1445,9 +1460,18 @@
             }
             break;
         case SPELLFAMILY_PALADIN:
+        {
+            if (!caster)
+                break;
+
             switch(GetId())
             {
                 case 19746:
+                    // Improved concentration aura - linked aura
+                    if (caster->HasAura(20254) || caster->HasAura(20255) || caster->HasAura(20256))
+                        if (apply)
+                            target->CastSpell(target, 63510, true);
+                        else target->RemoveAura(63510);
                 case 31821:
                     // Aura Mastery Triggered Spell Handler
                     // If apply Concentration Aura -> trigger -> apply Aura Mastery Immunity
@@ -1465,7 +1489,26 @@
                         target->RemoveAurasDueToSpell(64364, GetCasterGUID());
                     break;
             }
+            if (GetSpellSpecific(GetSpellProto()) == SPELL_SPECIFIC_AURA)
+            {
+                // Improved devotion aura
+                if (caster->HasAura(20140) || caster->HasAura(20138) || caster->HasAura(20139))
+                {
+                    if (apply)
+                        caster->CastSpell(target, 63514, true);
+                    else target->RemoveAura(63514);
+                }
+                // 63531 - linked aura for both Sanctified Retribution and Swift Retribution talents
+                // Not allow for Retribution Aura (prevent stacking)
+                if ((GetSpellProto()->SpellIconID != 555) && (caster->HasAura(53648) || caster->HasAura(53484) || caster->HasAura(53379) || caster->HasAura(31869)))
+                {
+                    if (apply)
+                        caster->CastSpell(target, 63531, true);
+                    else target->RemoveAura(63531);
+                }
+            }
             break;
+        }
         case SPELLFAMILY_DEATHKNIGHT:
             if (GetSpellSpecific(GetSpellProto()) == SPELL_SPECIFIC_PRESENCE)
             {
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -1174,6 +1174,9 @@
     uint32 procVictim   = m_procVictim;
     uint32 procEx = m_procEx;
 
+    int32 enddamage = m_damage;
+    int32 endhealing = m_healing;
+
     m_spellAura = NULL; // Set aura to null for every target-make sure that pointer is not used for unit without aura applied
 
                             //Spells with this flag cannot trigger if effect is casted on self
@@ -1275,6 +1278,8 @@
 
         int32 gain = caster->HealBySpell(unitTarget, m_spellInfo, addhealth, target->crit);
         unitTarget->getHostileRefManager().threatAssist(caster, float(gain) * 0.5f, m_spellInfo);
+
+        endhealing = addhealth;
     }
     // Do damage and triggers
     else if (m_damage > 0)
@@ -1309,6 +1314,36 @@
             AuraEffect * aurEff = m_spellAura->GetEffect(1);
             aurEff->SetAmount(aurEff->GetAmount() * damageInfo.damage / 100);
         }
+        // Scourge Strike
+        if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[1] & 0x08000000)
+        {
+            uint32 count = unitTarget->GetDiseasesByCaster(caster->GetGUID());
+            if (count)
+            {
+                const SpellEntry *ProcSpell = GetSpellStore()->LookupEntry(70890);
+                SpellNonMeleeDamage damageInfoProc(caster, unitTarget, ProcSpell->Id, ProcSpell->SchoolMask);
+                float ProcModifier = 1.0f;
+                AuraEffect const* pAurEff;
+                pAurEff = caster->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 154, 0);
+                if (pAurEff)
+                    ProcModifier += (float)pAurEff->GetAmount() / 100.0f;
+                pAurEff = caster->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DEATHKNIGHT, 97, 1);
+                if (pAurEff)
+                    ProcModifier += (float)pAurEff->GetAmount() / 100.0f;
+                pAurEff = unitTarget->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_DEATHKNIGHT, 0, 0x800, 0x40, caster->GetGUID());
+                if (pAurEff) 
+                    ProcModifier += (float)pAurEff->GetAmount() / 100.0f;
+                damageInfoProc.damage = count * CalculateDamage(EFFECT_2, unitTarget) * ProcModifier * (damageInfo.damage + damageInfo.absorb) / 100;
+                // Add bonuses and fill damageInfo struct 
+                caster->CalcAbsorbResist(unitTarget, SpellSchoolMask(ProcSpell->SchoolMask), SPELL_DIRECT_DAMAGE, damageInfoProc.damage, &damageInfoProc.absorb, &damageInfoProc.resist, ProcSpell);
+                caster->DealDamageMods(damageInfoProc.target,damageInfoProc.damage,&damageInfoProc.absorb);
+                damageInfoProc.damage -= damageInfoProc.absorb + damageInfoProc.resist;
+                caster->SendSpellNonMeleeDamageLog(&damageInfoProc);
+                caster->DealSpellDamage(&damageInfoProc, true);
+            }
+        }
+
+        enddamage = damageInfo.damage;
     }
     // Passive spell hits/misses or active spells only misses (only triggers)
     else
@@ -1329,6 +1364,14 @@
             if (unitTarget->ToCreature()->IsAIEnabled)
                 unitTarget->ToCreature()->AI()->AttackStart(m_caster);
         }
+        // Improved Devouring Plague
+        if (m_spellInfo->Id == 63675 && damageInfo.damage && caster->isAlive())
+            {
+                uint32 healthGain = damageInfo.damage * 15 / 100;
+                healthGain = caster->SpellHealingBonus(caster, m_spellInfo, healthGain, HEAL);
+                caster->HealBySpell(caster, m_spellInfo, healthGain);
+            }   
+
     }
 
     if (m_caster && !m_caster->IsFriendlyTo(unit) && !IsPositiveSpell(m_spellInfo->Id))
@@ -1370,6 +1413,10 @@
 
         CallScriptAfterHitHandlers();
     }
+
+    // Used by Divine Storm Implementation
+    m_damage = enddamage;
+    m_healing = endhealing;
 }
 
 SpellMissInfo Spell::DoSpellHitOnUnit(Unit *unit, const uint32 effectMask, bool scaleAura)
@@ -1413,7 +1460,7 @@
             // I do not think this is a correct way to fix it. Sanctuary effect should make all delayed spells invalid
             // for delayed spells ignore not visible explicit target
             if (m_spellInfo->speed > 0.0f && unit == m_targets.getUnitTarget()
-                && (unit->m_invisibilityMask || m_caster->m_invisibilityMask)
+                && ((unit->m_invisibilityMask || m_caster->m_invisibilityMask) || unit->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STEALTH, SPELLFAMILY_ROGUE, SPELLFAMILYFLAG_ROGUE_VANISH))
                 && !m_caster->canSeeOrDetect(unit, true))
             {
                 // that was causing CombatLog errors
@@ -2829,6 +2876,8 @@
                 switch (m_spellInfo->Id)
                 {
                     case 27285: // Seed of Corruption proc spell
+                    case 49821: // Mind Sear proc spell Rank 1
+                    case 53022: // Mind Sear proc spell Rank 2
                         unitList.remove(m_targets.getUnitTarget());
                         break;
                     case 55789: // Improved Icy Talons
@@ -4469,7 +4518,7 @@
     bool hit = true;
     if (m_caster->GetTypeId() == TYPEID_PLAYER)
     {
-        if (m_spellInfo->powerType == POWER_RAGE || m_spellInfo->powerType == POWER_ENERGY)
+        if (m_spellInfo->powerType == POWER_RAGE || m_spellInfo->powerType == POWER_ENERGY || m_spellInfo->powerType == POWER_RUNE)
             if (uint64 targetGUID = m_targets.getUnitTargetGUID())
                 for (std::list<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
                     if (ihit->targetGUID == targetGUID)
@@ -5537,6 +5586,56 @@
         }
     }
 
+    // Dispel check - only if the first effect is dispel
+    if (!m_IsTriggeredSpell && (m_spellInfo->Effect[EFFECT_0] == SPELL_EFFECT_DISPEL))
+        if (Unit const * target = m_targets.getUnitTarget())
+            if (!GetSpellRadius(m_spellInfo, EFFECT_0, target->IsFriendlyTo(m_caster)))
+            {
+                bool check = true;
+                uint32 dispelMask = GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[EFFECT_0]));
+
+                for (uint8 effIndex = EFFECT_1; effIndex < MAX_SPELL_EFFECTS; ++effIndex)
+                {
+                    if (m_spellInfo->Effect[effIndex] == SPELL_EFFECT_DISPEL)
+                        dispelMask |= GetDispellMask(DispelType(m_spellInfo->EffectMiscValue[effIndex]));
+                    // If there is any other effect don't check
+                    else if (m_spellInfo->Effect[effIndex])
+                    {
+                        check = false;
+                        break;
+                    }
+                }
+
+                if (check)
+                {
+                    bool failed = true;
+
+                    Unit::AuraMap const & auras = target->GetOwnedAuras();
+                    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        Aura * aura = itr->second;
+                        AuraApplication * aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+                        if (!aurApp)
+                            continue;
+
+                        if ((1 << aura->GetSpellProto()->Dispel) & dispelMask)
+                        {
+                            bool positive = aurApp->IsPositive() ? !(aura->GetSpellProto()->AttributesEx & SPELL_ATTR_EX_NEGATIVE) : false;
+
+                            // Can only dispel positive auras on enemies and negative on allies
+                            if (positive != target->IsFriendlyTo(m_caster))
+                            {
+                                failed = false;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (failed)
+                        return SPELL_FAILED_NOTHING_TO_DISPEL;
+                }
+            }
+
     for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
     {
         switch(m_spellInfo->EffectApplyAuraName[i])
@@ -5704,6 +5803,13 @@
 
                 break;
             }
+            case SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN:
+            {
+                if (m_spellInfo->Id == 33206)
+                    if (!m_caster->HasAura(63248) && m_caster->HasAuraType(SPELL_AURA_MOD_STUN))
+                        return SPELL_FAILED_STUNNED;                   
+                break;
+            }
             default:
                 break;
         }
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -761,15 +761,10 @@
                     break;
                 }
                 // Shield of Righteousness
-                if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & 0x100000)
-                {
-                    damage += m_caster->GetShieldBlockValue() * SpellMgr::CalculateSpellEffectAmount(m_spellInfo, EFFECT_1) / 100;
-                    break;
-                }
-                break;
-            }
-            case SPELLFAMILY_DEATHKNIGHT:
-            {
+                 else if (m_spellInfo->SpellFamilyFlags[1]&0x00100000)
+                 {                
+					 damage += int32(m_caster->GetShieldBlockValue());
+                 }
                 // Blood Boil - bonus for diseased targets
                 if (m_spellInfo->SpellFamilyFlags[0] & 0x00040000 && unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0, 0, 0x00000002, m_caster->GetGUID()))
                 {
@@ -1245,6 +1240,36 @@
                             m_caster->CastSpell(m_caster, 59566, true, NULL, NULL, m_originalCasterGUID);
                     return;
                 }
+                case 51962:                                 // Offer Jungle Punch
+                {
+
+                    if (!m_caster || !unitTarget)
+                        return;
+
+                    if (m_caster->GetTypeId() != TYPEID_PLAYER)
+                        return;
+
+                    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    Creature *target_crature = unitTarget->ToCreature();
+                    Player *caster_player = m_caster->ToPlayer();
+                    if(target_crature && caster_player)
+                    {
+                        switch(target_crature->GetEntry())
+                        {
+                            case 27986:
+                            case 28047:
+                            case 28568:
+                                caster_player->KilledMonsterCredit(target_crature->GetEntry(),0);
+                                break;
+                            default:
+                                break;
+                        }
+                    }
+                    return;
+                }
+
             }
 
             break;
@@ -1306,7 +1331,30 @@
                 // Bloodthirst
                 case 23881:
                 {
-                    m_caster->CastCustomSpell(unitTarget, 23885, &damage, NULL, NULL, true, NULL);
+                    m_caster->CastCustomSpell(unitTarget, 55970, &damage, NULL, NULL, true, NULL);
+                    return;
+                }
+                case 55046:
+                {
+                    if (!m_caster || !unitTarget)
+                        return;
+                    if (m_caster->GetTypeId() != TYPEID_UNIT)
+                        return;
+                    if (unitTarget->GetTypeId() != TYPEID_UNIT)
+                        return;
+
+                    Creature *target_crature = unitTarget->ToCreature();
+                    Creature *caster_crature = m_caster->ToCreature();
+                    if(target_crature && caster_crature && target_crature->GetEntry() == 29639 && caster_crature->GetOwner())
+                    {
+                        if(Player *plr = caster_crature->GetOwner()->ToPlayer())
+                        {
+                            plr->KilledMonsterCredit(29734,0);
+                            plr->KilledMonsterCredit(29709,0);
+                        }
+                        target_crature->ForcedDespawn();
+                        caster_crature->ForcedDespawn();
+                    }
                     return;
                 }
             }
@@ -1368,29 +1416,49 @@
                 if (m_caster->hasUnitState(UNIT_STAT_STUNNED | UNIT_STAT_FLEEING | UNIT_STAT_ROOT | UNIT_STAT_CONFUSED))
                     return;
 
+                if ((unitTarget->HasAuraType(SPELL_AURA_MOD_STEALTH) || unitTarget->m_invisibilityMask) 
+                        && !m_caster->canSeeOrDetect(unitTarget, true))
+                    return;
+
                 m_caster->CastSpell(unitTarget, damage, true);
                 return;
             }
             break;
         case SPELLFAMILY_PALADIN:
             // Divine Storm
-            if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & SPELLFAMILYFLAG1_PALADIN_DIVINESTORM)
+             if (m_spellInfo->SpellFamilyFlags[EFFECT_1] & SPELLFAMILYFLAG1_PALADIN_DIVINESTORM)
             {
-                if (effIndex != EFFECT_0)
-                    return;
-
-                uint32 target_count = 0;
-                for (std::list<TargetInfo>::const_iterator itr = m_UniqueTargetInfo.begin(); itr != m_UniqueTargetInfo.end(); ++itr)
-                    if (itr->effectMask & (1 << EFFECT_2))
-                        ++target_count;
-
-                if (!target_count)
-                    return;
-
-                if (Aura * aura = m_caster->AddAura(199997, unitTarget))
-                    aura->SetCharges(target_count);
-
-                return;
+                int32 dmg, m_damageO, m_healingO;
+                Unit * unitTargetO;
+                switch (effIndex)
+                {
+                    case EFFECT_0:
+                        m_damageO = m_damage; m_healingO = m_healing; unitTargetO = unitTarget;                       
+                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                            if (ihit->effectMask & (1<<EFFECT_2))
+                            {
+                                DoAllEffectOnTarget(&(*ihit));
+                                ihit->damage = m_damage;
+                           }
+                        m_damage = m_damageO; m_healing = m_healingO; unitTarget = unitTargetO;
+                        return;
+                    case EFFECT_1:
+                        dmg = 0;
+                        for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                            if (ihit->effectMask & (1<<EFFECT_2))
+                                dmg += ihit->damage;
+                        if (dmg)
+                        {
+                            if (!unitTarget)
+                                unitTarget = m_caster;
+                            dmg = int32((float)dmg * (float)damage / 100.0f);
+                            m_caster->CastCustomSpell(unitTarget, 54171, &dmg, 0, 0, true);
+                        }
+                        return;
+                    default:
+                        return;
+                }
+
             }
             switch(m_spellInfo->Id)
             {
@@ -1866,7 +1934,7 @@
                 if ((spell->DmgClass == SPELL_DAMAGE_CLASS_MAGIC // only affect magic spells
                     || ((1<<spell->Dispel) & dispelMask))
                     // ignore positive and passive auras
-                    && !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive())
+                    && !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive() && !iter->second->GetBase()->IsDeathPersistent())
                 {
                     m_caster->RemoveAura(iter);
                 }
@@ -2316,6 +2384,11 @@
 
             addhealth += damageAmount;
         }
+        else if (m_spellInfo->Id == 67489 || m_spellInfo->Id == 67489)
+        {
+            if (m_caster->ToPlayer() != NULL && m_caster->ToPlayer()->HasSkill(SKILL_ENGINERING))
+                addhealth *= 1.25;
+        }
         // Swiftmend - consumes Regrowth or Rejuvenation
         else if (m_spellInfo->TargetAuraState == AURA_STATE_SWIFTMEND && unitTarget->HasAuraState(AURA_STATE_SWIFTMEND, m_spellInfo, m_caster))
         {
@@ -2389,6 +2462,13 @@
                 // consume aura
                 unitTarget->RemoveAura(aurEff->GetBase());
             }
+            for (std::list<TargetInfo>::iterator ihit = m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+            {
+                if (unitTarget->GetGUID() != ihit->targetGUID)
+                    addhealth = addhealth * 0.4;
+                else
+                    break;
+            }
         }
         // Death Pact - return pct of max health to caster
         else if (m_spellInfo->SpellFamilyName == SPELLFAMILY_DEATHKNIGHT && m_spellInfo->SpellFamilyFlags[0] & 0x00080000)
@@ -2683,6 +2763,11 @@
         case 48542:                                         // Revitalize
             damage = damage * unitTarget->GetMaxPower(power) / 100;
             break;
+        case 67490:
+        case 67487:
+            if (m_caster->ToPlayer() != NULL && m_caster->ToPlayer()->HasSkill(SKILL_ENGINERING))
+                damage *= 1.25;
+            break;
         default:
             break;
     }
@@ -3115,6 +3200,11 @@
                     if (!summon || !summon->isTotem())
                         return;
 
+                    // Mana Tide Totem
+                    if (summon->GetEntry() == 10467)
+                        if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                            damage = (m_caster->GetMaxHealth() * 0.10);
+
                     if (damage)                                            // if not spell info, DB values used
                     {
                         summon->SetMaxHealth(damage);
@@ -3169,6 +3259,12 @@
                     if (m_spellInfo->Id == 18662) // Curse of Doom
                         amount = 1;
 
+                    // Engineering dragonlings
+                    if (m_spellInfo->Id == 4073 ||
+                        m_spellInfo->Id == 12749 ||
+                        m_spellInfo->Id == 19804)
+                        amount = 1;
+
                     for (uint32 count = 0; count < amount; ++count)
                     {
                         GetSummonPosition(effIndex, pos, radius, count);
@@ -4106,7 +4202,7 @@
             else if (m_spellInfo->Id == 20467)
             {
                 spell_bonus += int32(0.08f*m_caster->GetTotalAttackPowerValue(BASE_ATTACK));
-                spell_bonus += int32(0.13f*m_caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellInfo)));
+                spell_bonus += int32(0.13f*m_caster->SpellBaseDamageBonus(GetSpellSchoolMask(m_spellInfo), m_spellInfo));
             }
             break;
         }
@@ -4195,6 +4291,9 @@
             // Blood-Caked Strike - Blood-Caked Blade
             else if (m_spellInfo->SpellIconID == 1736)
                 totalDamagePercentMod *= (float(unitTarget->GetDiseasesByCaster(m_caster->GetGUID())) * 12.5f + 100.0f) / 100.0f;
+            // Rune Strike
+            else if (m_spellInfo->SpellFamilyFlags[1] & 0x20000000)
+                m_damage += int32(m_caster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.15f);
             break;
         }
     }
@@ -4334,8 +4433,8 @@
             {
                 if (m_originalCaster)
                 {
-                    int32 duration = m_originalCaster->ModSpellDuration(m_spellInfo, unitTarget, m_originalCaster->CalcSpellDuration(m_spellInfo), false);
-                    unitTarget->ProhibitSpellScholl(GetSpellSchoolMask(curSpellInfo), duration/*GetSpellDuration(m_spellInfo)*/);
+                    int32 duration = GetSpellDuration(m_spellInfo);
+                    unitTarget->ProhibitSpellScholl(GetSpellSchoolMask(curSpellInfo), unitTarget->ModSpellDuration(m_spellInfo, unitTarget, duration, false));
                 }
                 ExecuteLogEffectInterruptCast(effIndex, unitTarget, curSpellInfo->Id);
                 unitTarget->InterruptSpell(CurrentSpellTypes(i), false);
@@ -7081,6 +7180,10 @@
             if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(63330, 0)) // glyph of Dancing Rune Weapon
                 duration += aurEff->GetAmount();
             break;
+        case 57879:
+            if (AuraEffect *aurEff = m_originalCaster->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_HUNTER, 69, 2))
+                amount += aurEff->GetAmount();
+            break;
     }
     if (Player* modOwner = m_originalCaster->GetSpellModOwner())
         modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_DURATION, duration);
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -1,4185 +1,4217 @@
-/*
- * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
- *
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "SpellMgr.h"
-#include "ObjectMgr.h"
-#include "SpellAuraDefines.h"
-#include "ProgressBar.h"
-#include "DBCStores.h"
-#include "World.h"
-#include "Chat.h"
-#include "Spell.h"
-#include "BattlegroundMgr.h"
-#include "CreatureAI.h"
-#include "MapManager.h"
-
-bool IsAreaEffectTarget[TOTAL_SPELL_TARGETS];
-SpellEffectTargetTypes EffectTargetType[TOTAL_SPELL_EFFECTS];
-SpellSelectTargetTypes SpellTargetType[TOTAL_SPELL_TARGETS];
-
-SpellMgr::SpellMgr()
-{
-    for (int i = 0; i < TOTAL_SPELL_EFFECTS; ++i)
-    {
-        switch(i)
-        {
-            case SPELL_EFFECT_PERSISTENT_AREA_AURA: //27
-            case SPELL_EFFECT_SUMMON:               //28
-            case SPELL_EFFECT_TRIGGER_MISSILE:      //32
-            case SPELL_EFFECT_TRANS_DOOR:           //50 summon object
-            case SPELL_EFFECT_SUMMON_PET:           //56
-            case SPELL_EFFECT_ADD_FARSIGHT:         //72
-            case SPELL_EFFECT_SUMMON_OBJECT_WILD:   //76
-            //case SPELL_EFFECT_SUMMON_CRITTER:       //97 not 303
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT1:  //104
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT2:  //105
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT3:  //106
-            case SPELL_EFFECT_SUMMON_OBJECT_SLOT4:  //107
-            case SPELL_EFFECT_SUMMON_DEAD_PET:      //109
-            case SPELL_EFFECT_TRIGGER_SPELL_2:      //151 ritual of summon
-                EffectTargetType[i] = SPELL_REQUIRE_DEST;
-                break;
-            case SPELL_EFFECT_PARRY: // 0
-            case SPELL_EFFECT_BLOCK: // 0
-            case SPELL_EFFECT_SKILL: // always with dummy 3 as A
-            //case SPELL_EFFECT_LEARN_SPELL: // 0 may be 5 pet
-            case SPELL_EFFECT_TRADE_SKILL: // 0 or 1
-            case SPELL_EFFECT_PROFICIENCY: // 0
-                EffectTargetType[i] = SPELL_REQUIRE_NONE;
-                break;
-            case SPELL_EFFECT_ENCHANT_ITEM:
-            case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
-            case SPELL_EFFECT_DISENCHANT:
-            //in 243 this is 0, in 309 it is 1
-            //so both item target and unit target is pushed, and cause crash
-            //case SPELL_EFFECT_FEED_PET:
-            case SPELL_EFFECT_PROSPECTING:
-            case SPELL_EFFECT_MILLING:
-            case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
-                EffectTargetType[i] = SPELL_REQUIRE_ITEM;
-                break;
-            //caster must be pushed otherwise no sound
-            case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
-            case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
-            case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
-            case SPELL_EFFECT_APPLY_AREA_AURA_PET:
-            case SPELL_EFFECT_APPLY_AREA_AURA_OWNER:
-            case SPELL_EFFECT_APPLY_AREA_AURA_RAID:
-            case SPELL_EFFECT_CHARGE:
-            case SPELL_EFFECT_CHARGE_DEST:
-            case SPELL_EFFECT_JUMP:
-            case SPELL_EFFECT_JUMP_DEST:
-            case SPELL_EFFECT_LEAP_BACK:
-                EffectTargetType[i] = SPELL_REQUIRE_CASTER;
-                break;
-            //case SPELL_EFFECT_WMO_DAMAGE:
-            //case SPELL_EFFECT_WMO_REPAIR:
-            //case SPELL_EFFECT_WMO_CHANGE:
-            //    EffectTargetType[i] = SPELL_REQUIRE_GOBJECT;
-            //    break;
-            default:
-                EffectTargetType[i] = SPELL_REQUIRE_UNIT;
-                break;
-        }
-    }
-
-    for (int i = 0; i < TOTAL_SPELL_TARGETS; ++i)
-    {
-        switch(i)
-        {
-            case TARGET_UNIT_CASTER:
-            case TARGET_UNIT_CASTER_FISHING:
-            case TARGET_UNIT_MASTER:
-            case TARGET_UNIT_PET:
-            case TARGET_UNIT_PARTY_CASTER:
-            case TARGET_UNIT_RAID_CASTER:
-            case TARGET_UNIT_VEHICLE:
-            case TARGET_UNIT_PASSENGER_0:
-            case TARGET_UNIT_PASSENGER_1:
-            case TARGET_UNIT_PASSENGER_2:
-            case TARGET_UNIT_PASSENGER_3:
-            case TARGET_UNIT_PASSENGER_4:
-            case TARGET_UNIT_PASSENGER_5:
-            case TARGET_UNIT_PASSENGER_6:
-            case TARGET_UNIT_PASSENGER_7:
-            case TARGET_UNIT_SUMMONER:
-                SpellTargetType[i] = TARGET_TYPE_UNIT_CASTER;
-                break;
-            case TARGET_UNIT_TARGET_PUPPET:
-            case TARGET_UNIT_TARGET_ALLY:
-            case TARGET_UNIT_TARGET_RAID:
-            case TARGET_UNIT_TARGET_ANY:
-            case TARGET_UNIT_TARGET_ENEMY:
-            case TARGET_UNIT_TARGET_PARTY:
-            case TARGET_UNIT_PARTY_TARGET:
-            case TARGET_UNIT_CLASS_TARGET:
-            case TARGET_UNIT_CHAINHEAL:
-                SpellTargetType[i] = TARGET_TYPE_UNIT_TARGET;
-                break;
-            case TARGET_UNIT_NEARBY_ENEMY:
-            case TARGET_UNIT_NEARBY_ALLY:
-            case TARGET_UNIT_NEARBY_ALLY_UNK:
-            case TARGET_UNIT_NEARBY_ENTRY:
-            case TARGET_UNIT_NEARBY_RAID:
-            case TARGET_GAMEOBJECT_NEARBY_ENTRY:
-                SpellTargetType[i] = TARGET_TYPE_UNIT_NEARBY;
-                break;
-            case TARGET_UNIT_AREA_ENEMY_SRC:
-            case TARGET_UNIT_AREA_ALLY_SRC:
-            case TARGET_UNIT_AREA_ENTRY_SRC:
-            case TARGET_UNIT_AREA_PARTY_SRC:
-            case TARGET_GAMEOBJECT_AREA_SRC:
-                SpellTargetType[i] = TARGET_TYPE_AREA_SRC;
-                break;
-            case TARGET_UNIT_AREA_ENEMY_DST:
-            case TARGET_UNIT_AREA_ALLY_DST:
-            case TARGET_UNIT_AREA_ENTRY_DST:
-            case TARGET_UNIT_AREA_PARTY_DST:
-            case TARGET_GAMEOBJECT_AREA_DST:
-                SpellTargetType[i] = TARGET_TYPE_AREA_DST;
-                break;
-            case TARGET_UNIT_CONE_ENEMY:
-            case TARGET_UNIT_CONE_ALLY:
-            case TARGET_UNIT_CONE_ENTRY:
-            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
-            case TARGET_UNIT_AREA_PATH:
-            case TARGET_GAMEOBJECT_AREA_PATH:
-                SpellTargetType[i] = TARGET_TYPE_AREA_CONE;
-                break;
-            case TARGET_DST_CASTER:
-            case TARGET_SRC_CASTER:
-            case TARGET_MINION:
-            case TARGET_DEST_CASTER_FRONT_LEAP:
-            case TARGET_DEST_CASTER_FRONT:
-            case TARGET_DEST_CASTER_BACK:
-            case TARGET_DEST_CASTER_RIGHT:
-            case TARGET_DEST_CASTER_LEFT:
-            case TARGET_DEST_CASTER_FRONT_LEFT:
-            case TARGET_DEST_CASTER_BACK_LEFT:
-            case TARGET_DEST_CASTER_BACK_RIGHT:
-            case TARGET_DEST_CASTER_FRONT_RIGHT:
-            case TARGET_DEST_CASTER_RANDOM:
-            case TARGET_DEST_CASTER_RADIUS:
-                SpellTargetType[i] = TARGET_TYPE_DEST_CASTER;
-                break;
-            case TARGET_DST_TARGET_ENEMY:
-            case TARGET_DEST_TARGET_ANY:
-            case TARGET_DEST_TARGET_FRONT:
-            case TARGET_DEST_TARGET_BACK:
-            case TARGET_DEST_TARGET_RIGHT:
-            case TARGET_DEST_TARGET_LEFT:
-            case TARGET_DEST_TARGET_FRONT_LEFT:
-            case TARGET_DEST_TARGET_BACK_LEFT:
-            case TARGET_DEST_TARGET_BACK_RIGHT:
-            case TARGET_DEST_TARGET_FRONT_RIGHT:
-            case TARGET_DEST_TARGET_RANDOM:
-            case TARGET_DEST_TARGET_RADIUS:
-                SpellTargetType[i] = TARGET_TYPE_DEST_TARGET;
-                break;
-            case TARGET_DEST_DYNOBJ_ENEMY:
-            case TARGET_DEST_DYNOBJ_ALLY:
-            case TARGET_DEST_DYNOBJ_NONE:
-            case TARGET_DEST_DEST:
-            case TARGET_DEST_TRAJ:
-            case TARGET_DEST_DEST_FRONT_LEFT:
-            case TARGET_DEST_DEST_BACK_LEFT:
-            case TARGET_DEST_DEST_BACK_RIGHT:
-            case TARGET_DEST_DEST_FRONT_RIGHT:
-            case TARGET_DEST_DEST_FRONT:
-            case TARGET_DEST_DEST_BACK:
-            case TARGET_DEST_DEST_RIGHT:
-            case TARGET_DEST_DEST_LEFT:
-            case TARGET_DEST_DEST_RANDOM:
-            case TARGET_DEST_DEST_RANDOM_DIR_DIST:
-                SpellTargetType[i] = TARGET_TYPE_DEST_DEST;
-                break;
-            case TARGET_DST_DB:
-            case TARGET_DST_HOME:
-            case TARGET_DST_NEARBY_ENTRY:
-                SpellTargetType[i] = TARGET_TYPE_DEST_SPECIAL;
-                break;
-            case TARGET_UNIT_CHANNEL_TARGET:
-            case TARGET_DEST_CHANNEL_TARGET:
-            case TARGET_DEST_CHANNEL_CASTER:
-                SpellTargetType[i] = TARGET_TYPE_CHANNEL;
-                break;
-            default:
-                SpellTargetType[i] = TARGET_TYPE_DEFAULT;
-        }
-    }
-
-    for (int32 i = 0; i < TOTAL_SPELL_TARGETS; ++i)
-    {
-        switch(i)
-        {
-            case TARGET_UNIT_AREA_ENEMY_DST:
-            case TARGET_UNIT_AREA_ENEMY_SRC:
-            case TARGET_UNIT_AREA_ALLY_DST:
-            case TARGET_UNIT_AREA_ALLY_SRC:
-            case TARGET_UNIT_AREA_ENTRY_DST:
-            case TARGET_UNIT_AREA_ENTRY_SRC:
-            case TARGET_UNIT_AREA_PARTY_DST:
-            case TARGET_UNIT_AREA_PARTY_SRC:
-            case TARGET_UNIT_PARTY_TARGET:
-            case TARGET_UNIT_PARTY_CASTER:
-            case TARGET_UNIT_CONE_ENEMY:
-            case TARGET_UNIT_CONE_ALLY:
-            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
-            case TARGET_UNIT_AREA_PATH:
-            case TARGET_GAMEOBJECT_AREA_PATH:
-            case TARGET_UNIT_RAID_CASTER:
-                IsAreaEffectTarget[i] = true;
-                break;
-            default:
-                IsAreaEffectTarget[i] = false;
-                break;
-        }
-    }
-}
-
-SpellMgr::~SpellMgr()
-{
-}
-
-SpellMgr& SpellMgr::Instance()
-{
-    static SpellMgr spellMgr;
-    return spellMgr;
-}
-
-bool SpellMgr::IsSrcTargetSpell(SpellEntry const *spellInfo) const
-{
-    for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
-    {
-        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_AREA_SRC || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_AREA_SRC)
-            return true;
-    }
-    return false;
-}
-
-int32 GetSpellDuration(SpellEntry const *spellInfo)
-{
-    if (!spellInfo)
-        return 0;
-    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
-    if (!du)
-        return 0;
-    return (du->Duration[0] == -1) ? -1 : abs(du->Duration[0]);
-}
-
-int32 GetSpellMaxDuration(SpellEntry const *spellInfo)
-{
-    if (!spellInfo)
-        return 0;
-    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
-    if (!du)
-        return 0;
-    return (du->Duration[2] == -1) ? -1 : abs(du->Duration[2]);
-}
-
-uint32 GetDispelChance(Unit* auraCaster, Unit* target, uint32 spellId, bool offensive, bool *result)
-{
-    // we assume that aura dispel chance is 100% on start
-    // need formula for level difference based chance
-    int32 resist_chance = 0;
-
-    // Apply dispel mod from aura caster
-    if (auraCaster)
-        if (Player* modOwner = auraCaster->GetSpellModOwner())
-            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_DISPEL_CHANCE, resist_chance);
-
-    // Dispel resistance from target SPELL_AURA_MOD_DISPEL_RESIST
-    // Only affects offensive dispels
-    if (offensive && target)
-        resist_chance += target->GetTotalAuraModifier(SPELL_AURA_MOD_DISPEL_RESIST);
-
-    // Try dispel
-    if (result)
-        *result = !roll_chance_i(resist_chance);
-
-    resist_chance = resist_chance < 0 ? 0 : resist_chance;
-    resist_chance = resist_chance > 100 ? 100 : resist_chance;
-    return 100 - resist_chance;
-}
-
-uint32 GetSpellCastTime(SpellEntry const* spellInfo, Spell * spell)
-{
-    SpellCastTimesEntry const *spellCastTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
-
-    // not all spells have cast time index and this is all is pasiive abilities
-    if (!spellCastTimeEntry)
-        return 0;
-
-    int32 castTime = spellCastTimeEntry->CastTime;
-
-    if (spell && spell->GetCaster())
-        spell->GetCaster()->ModSpellCastTime(spellInfo, castTime, spell);
-
-    if (spellInfo->Attributes & SPELL_ATTR_REQ_AMMO && (!spell || !(spell->IsAutoRepeat())))
-        castTime += 500;
-
-    return (castTime > 0) ? uint32(castTime) : 0;
-}
-
-bool IsPassiveSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-    return IsPassiveSpell(spellInfo);
-}
-
-bool IsPassiveSpell(SpellEntry const * spellInfo)
-{
-    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
-        return true;
-    return false;
-}
-
-bool IsAutocastableSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
-        return false;
-    if (spellInfo->AttributesEx & SPELL_ATTR_EX_UNAUTOCASTABLE_BY_PET)
-        return false;
-    return true;
-}
-
-bool IsHigherHankOfSpell(uint32 spellId_1, uint32 spellId_2)
-{
-    return sSpellMgr.GetSpellRank(spellId_1)<sSpellMgr.GetSpellRank(spellId_2);
-}
-
-uint32 CalculatePowerCost(SpellEntry const * spellInfo, Unit const * caster, SpellSchoolMask schoolMask)
-{
-    // Spell drain all exist power on cast (Only paladin lay of Hands)
-    if (spellInfo->AttributesEx & SPELL_ATTR_EX_DRAIN_ALL_POWER)
-    {
-        // If power type - health drain all
-        if (spellInfo->powerType == POWER_HEALTH)
-            return caster->GetHealth();
-        // Else drain all power
-        if (spellInfo->powerType < MAX_POWERS)
-            return caster->GetPower(Powers(spellInfo->powerType));
-        sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
-        return 0;
-    }
-
-    // Base powerCost
-    int32 powerCost = spellInfo->manaCost;
-    // PCT cost from total amount
-    if (spellInfo->ManaCostPercentage)
-    {
-        switch (spellInfo->powerType)
-        {
-            // health as power used
-            case POWER_HEALTH:
-                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateHealth() / 100;
-                break;
-            case POWER_MANA:
-                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateMana() / 100;
-                break;
-            case POWER_RAGE:
-            case POWER_FOCUS:
-            case POWER_ENERGY:
-            case POWER_HAPPINESS:
-                powerCost += spellInfo->ManaCostPercentage * caster->GetMaxPower(Powers(spellInfo->powerType)) / 100;
-                break;
-            case POWER_RUNE:
-            case POWER_RUNIC_POWER:
-                sLog.outDebug("CalculateManaCost: Not implemented yet!");
-                break;
-            default:
-                sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
-                return 0;
-        }
-    }
-    SpellSchools school = GetFirstSchoolInMask(schoolMask);
-    // Flat mod from caster auras by spell school
-    powerCost += caster->GetInt32Value(UNIT_FIELD_POWER_COST_MODIFIER + school);
-    // Shiv - costs 20 + weaponSpeed*10 energy (apply only to non-triggered spell with energy cost)
-    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_SPELL_VS_EXTEND_COST)
-        powerCost += caster->GetAttackTime(OFF_ATTACK)/100;
-    // Apply cost mod by spell
-    if (Player * modOwner = caster->GetSpellModOwner())
-        modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_COST, powerCost);
-
-    if (spellInfo->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION)
-        powerCost = int32(powerCost/ (1.117f* spellInfo->spellLevel / caster->getLevel() -0.1327f));
-
-    // PCT mod from user auras by school
-    powerCost = int32(powerCost * (1.0f+caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+school)));
-    if (powerCost < 0)
-        powerCost = 0;
-    return powerCost;
-}
-
-Unit* GetTriggeredSpellCaster(SpellEntry const * spellInfo, Unit * caster, Unit * target)
-{
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET
-            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_UNIT_TARGET
-            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_CHANNEL
-            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_CHANNEL
-            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_DEST_TARGET
-            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_DEST_TARGET)
-            return caster;
-    }
-    return target;
-}
-
-AuraState GetSpellAuraState(SpellEntry const * spellInfo)
-{
-    // Seals
-    if (IsSealSpell(spellInfo))
-        return AURA_STATE_JUDGEMENT;
-
-    // Conflagrate aura state on Immolate and Shadowflame
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
-        // Immolate
-        ((spellInfo->SpellFamilyFlags[0] & 4) ||
-        // Shadowflame
-        (spellInfo->SpellFamilyFlags[2] & 2)))
-        return AURA_STATE_CONFLAGRATE;
-
-    // Faerie Fire (druid versions)
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x400)
-        return AURA_STATE_FAERIE_FIRE;
-
-    // Sting (hunter's pet ability)
-    if (spellInfo->Category == 1133)
-        return AURA_STATE_FAERIE_FIRE;
-
-    // Victorious
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARRIOR &&  spellInfo->SpellFamilyFlags[1] & 0x00040000)
-        return AURA_STATE_WARRIOR_VICTORY_RUSH;
-
-    // Swiftmend state on Regrowth & Rejuvenation
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x50)
-        return AURA_STATE_SWIFTMEND;
-
-    // Deadly poison aura state
-    if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] & 0x10000)
-        return AURA_STATE_DEADLY_POISON;
-
-    // Enrage aura state
-    if (spellInfo->Dispel == DISPEL_ENRAGE)
-        return AURA_STATE_ENRAGE;
-
-    // Bleeding aura state
-    if (GetAllSpellMechanicMask(spellInfo) & 1<<MECHANIC_BLEED)
-        return AURA_STATE_BLEEDING;
-
-    if (GetSpellSchoolMask(spellInfo) & SPELL_SCHOOL_MASK_FROST)
-    {
-        for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
-        {
-            if (spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_STUN
-                || spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT)
-                return AURA_STATE_FROZEN;
-        }
-    }
-    return AURA_STATE_NONE;
-}
-
-SpellSpecific GetSpellSpecific(SpellEntry const * spellInfo)
-{
-    switch(spellInfo->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-        {
-            // Food / Drinks (mostly)
-            if (spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
-            {
-                bool food = false;
-                bool drink = false;
-                for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-                {
-                    switch(spellInfo->EffectApplyAuraName[i])
-                    {
-                        // Food
-                        case SPELL_AURA_MOD_REGEN:
-                        case SPELL_AURA_OBS_MOD_HEALTH:
-                            food = true;
-                            break;
-                        // Drink
-                        case SPELL_AURA_MOD_POWER_REGEN:
-                        case SPELL_AURA_OBS_MOD_POWER:
-                            drink = true;
-                            break;
-                        default:
-                            break;
-                    }
-                }
-
-                if (food && drink)
-                    return SPELL_SPECIFIC_FOOD_AND_DRINK;
-                else if (food)
-                    return SPELL_SPECIFIC_FOOD;
-                else if (drink)
-                    return SPELL_SPECIFIC_DRINK;
-            }
-            // scrolls effects
-            else
-            {
-                uint32 firstSpell = sSpellMgr.GetFirstSpellInChain(spellInfo->Id);
-                switch (firstSpell)
-                {
-                    case 8118: // Strength
-                    case 8099: // Stamina
-                    case 8112: // Spirit
-                    case 8096: // Intellect
-                    case 8115: // Agility
-                    case 8091: // Armor
-                        return SPELL_SPECIFIC_SCROLL;
-                    case 12880: // Enrage (Enrage)
-                    case 57518: // Enrage (Wrecking Crew)
-                        return SPELL_SPECIFIC_WARRIOR_ENRAGE;
-                }
-            }
-            break;
-        }
-        case SPELLFAMILY_MAGE:
-        {
-            // family flags 18(Molten), 25(Frost/Ice), 28(Mage)
-            if (spellInfo->SpellFamilyFlags[0] & 0x12040000)
-                return SPELL_SPECIFIC_MAGE_ARMOR;
-
-            // Arcane brillance and Arcane intelect (normal check fails because of flags difference)
-            if (spellInfo->SpellFamilyFlags[0] & 0x400)
-                return SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE;
-
-            if ((spellInfo->SpellFamilyFlags[0] & 0x1000000) && spellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOD_CONFUSE)
-                return SPELL_SPECIFIC_MAGE_POLYMORPH;
-
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            if (spellInfo->Id == 12292) // Death Wish
-                return SPELL_SPECIFIC_WARRIOR_ENRAGE;
-
-            break;
-        }
-        case SPELLFAMILY_WARLOCK:
-        {
-            // only warlock curses have this
-            if (spellInfo->Dispel == DISPEL_CURSE)
-                return SPELL_SPECIFIC_CURSE;
-
-            // Warlock (Demon Armor | Demon Skin | Fel Armor)
-            if (spellInfo->SpellFamilyFlags[1] & 0x20000020 || spellInfo->SpellFamilyFlags[2] & 0x00000010)
-                return SPELL_SPECIFIC_WARLOCK_ARMOR;
-
-            //seed of corruption and corruption
-            if (spellInfo->SpellFamilyFlags[1] & 0x10 || spellInfo->SpellFamilyFlags[0] & 0x2)
-                return SPELL_SPECIFIC_WARLOCK_CORRUPTION;
-            break;
-        }
-        case SPELLFAMILY_PRIEST:
-        {
-            // Divine Spirit and Prayer of Spirit
-            if (spellInfo->SpellFamilyFlags[0] & 0x20)
-                return SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT;
-
-            break;
-        }
-        case SPELLFAMILY_HUNTER:
-        {
-            // only hunter stings have this
-            if (spellInfo->Dispel == DISPEL_POISON)
-                return SPELL_SPECIFIC_STING;
-
-            // only hunter aspects have this (but not all aspects in hunter family)
-            if (spellInfo->SpellFamilyFlags.HasFlag(0x00380000, 0x00440000, 0x00001010))
-                return SPELL_SPECIFIC_ASPECT;
-
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            if (IsSealSpell(spellInfo))
-                return SPELL_SPECIFIC_SEAL;
-
-            if (spellInfo->SpellFamilyFlags[0] & 0x00002190)
-                return SPELL_SPECIFIC_HAND;
-
-            // Judgement of Wisdom, Judgement of Light, Judgement of Justice
-            if (spellInfo->Id == 20184 || spellInfo->Id == 20185 || spellInfo->Id == 20186)
-                return SPELL_SPECIFIC_JUDGEMENT;
-
-            // only paladin auras have this (for palaldin class family)
-            if (spellInfo->SpellFamilyFlags[2] & 0x00000020)
-                return SPELL_SPECIFIC_AURA;
-
-            break;
-        }
-        case SPELLFAMILY_SHAMAN:
-        {
-            if (IsElementalShield(spellInfo))
-                return SPELL_SPECIFIC_ELEMENTAL_SHIELD;
-
-            break;
-        }
-
-        case SPELLFAMILY_DEATHKNIGHT:
-            if (spellInfo->Id == 48266 || spellInfo->Id == 48263 || spellInfo->Id == 48265)
-            //if (spellInfo->Category == 47)
-                return SPELL_SPECIFIC_PRESENCE;
-            break;
-    }
-
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
-        {
-            switch(spellInfo->EffectApplyAuraName[i])
-            {
-                case SPELL_AURA_MOD_CHARM:
-                case SPELL_AURA_MOD_POSSESS_PET:
-                case SPELL_AURA_MOD_POSSESS:
-                case SPELL_AURA_AOE_CHARM:
-                    return SPELL_SPECIFIC_CHARM;
-                case SPELL_AURA_TRACK_CREATURES:
-                case SPELL_AURA_TRACK_RESOURCES:
-                case SPELL_AURA_TRACK_STEALTHED:
-                    return SPELL_SPECIFIC_TRACKER;
-                case SPELL_AURA_PHASE:
-                    return SPELL_SPECIFIC_PHASE;
-            }
-        }
-    }
-
-    return SPELL_SPECIFIC_NORMAL;
-}
-
-// target not allow have more one spell specific from same caster
-bool IsSingleFromSpellSpecificPerCaster(SpellSpecific spellSpec1,SpellSpecific spellSpec2)
-{
-    switch(spellSpec1)
-    {
-        case SPELL_SPECIFIC_SEAL:
-        case SPELL_SPECIFIC_HAND:
-        case SPELL_SPECIFIC_AURA:
-        case SPELL_SPECIFIC_STING:
-        case SPELL_SPECIFIC_CURSE:
-        case SPELL_SPECIFIC_ASPECT:
-        case SPELL_SPECIFIC_JUDGEMENT:
-        case SPELL_SPECIFIC_WARLOCK_CORRUPTION:
-            return spellSpec1 == spellSpec2;
-        default:
-            return false;
-    }
-}
-
-bool IsSingleFromSpellSpecificPerTarget(SpellSpecific spellSpec1, SpellSpecific spellSpec2)
-{
-    switch(spellSpec1)
-    {
-        case SPELL_SPECIFIC_PHASE:
-        case SPELL_SPECIFIC_TRACKER:
-        case SPELL_SPECIFIC_WARLOCK_ARMOR:
-        case SPELL_SPECIFIC_MAGE_ARMOR:
-        case SPELL_SPECIFIC_ELEMENTAL_SHIELD:
-        case SPELL_SPECIFIC_MAGE_POLYMORPH:
-        case SPELL_SPECIFIC_PRESENCE:
-        case SPELL_SPECIFIC_CHARM:
-        case SPELL_SPECIFIC_SCROLL:
-        case SPELL_SPECIFIC_WARRIOR_ENRAGE:
-        case SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE:
-        case SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT:
-            return spellSpec1 == spellSpec2;
-        case SPELL_SPECIFIC_FOOD:
-            return spellSpec2 == SPELL_SPECIFIC_FOOD
-                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
-        case SPELL_SPECIFIC_DRINK:
-            return spellSpec2 == SPELL_SPECIFIC_DRINK
-                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
-        case SPELL_SPECIFIC_FOOD_AND_DRINK:
-            return spellSpec2 == SPELL_SPECIFIC_FOOD
-                || spellSpec2 == SPELL_SPECIFIC_DRINK
-                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
-        default:
-            return false;
-    }
-}
-
-bool IsPositiveTarget(uint32 targetA, uint32 targetB)
-{
-    // non-positive targets
-    switch(targetA)
-    {
-        case TARGET_UNIT_NEARBY_ENEMY:
-        case TARGET_UNIT_TARGET_ENEMY:
-        case TARGET_UNIT_AREA_ENEMY_SRC:
-        case TARGET_UNIT_AREA_ENEMY_DST:
-        case TARGET_UNIT_CONE_ENEMY:
-        case TARGET_DEST_DYNOBJ_ENEMY:
-        case TARGET_DST_TARGET_ENEMY:
-            return false;
-        default:
-            break;
-    }
-    if (targetB)
-        return IsPositiveTarget(targetB, 0);
-    return true;
-}
-
-bool SpellMgr::_isPositiveEffect(uint32 spellId, uint32 effIndex, bool deep) const
-{
-    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
-    if (!spellproto) return false;
-
-    // not found a single positive spell with this attribute
-    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1)
-        return false;
-
-    switch (spellproto->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-            switch (spellId)
-            {
-                case 34700: // Allergic Reaction
-                case 61987: // Avenging Wrath Marker
-                case 61988: // Divine Shield exclude aura
-                    return false;
-                case 30877: // Tag Murloc
-                    return true;
-                default:
-                    break;
-            }
-            break;
-        case SPELLFAMILY_MAGE:
-            // Amplify Magic, Dampen Magic
-            if (spellproto->SpellFamilyFlags[0] == 0x00002000)
-                return true;
-            break;
-        case SPELLFAMILY_PRIEST:
-            switch (spellId)
-            {
-                case 64844: // Divine Hymn
-                case 64904: // Hymn of Hope
-                case 47585: // Dispersion
-                    return true;
-                default:
-                    break;
-            }
-            break;
-        case SPELLFAMILY_HUNTER:
-            // Aspect of the Viper
-            if (spellId == 34074)
-                return true;
-            break;
-        case SPELLFAMILY_SHAMAN:
-            if (spellId == 30708)
-                return false;
-            break;
-        default:
-            break;
-    }
-
-    switch (spellproto->Mechanic)
-    {
-        case MECHANIC_IMMUNE_SHIELD:
-            return true;
-        default:
-            break;
-    }
-
-    // Special case: effects which determine positivity of whole spell
-    for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
-    {
-        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_STEALTH)
-            return true;
-    }
-
-    switch(spellproto->Effect[effIndex])
-    {
-        case SPELL_EFFECT_DUMMY:
-            // some explicitly required dummy effect sets
-            switch(spellId)
-            {
-                case 28441: return false;                   // AB Effect 000
-                default:
-                    break;
-            }
-            break;
-        // always positive effects (check before target checks that provided non-positive result in some case for positive effects)
-        case SPELL_EFFECT_HEAL:
-        case SPELL_EFFECT_LEARN_SPELL:
-        case SPELL_EFFECT_SKILL_STEP:
-        case SPELL_EFFECT_HEAL_PCT:
-        case SPELL_EFFECT_ENERGIZE_PCT:
-            return true;
-
-            // non-positive aura use
-        case SPELL_EFFECT_APPLY_AURA:
-        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
-        {
-            switch(spellproto->EffectApplyAuraName[effIndex])
-            {
-                case SPELL_AURA_MOD_DAMAGE_DONE:            // dependent from bas point sign (negative -> negative)
-                case SPELL_AURA_MOD_STAT:
-                case SPELL_AURA_MOD_SKILL:
-                case SPELL_AURA_MOD_HEALING_PCT:
-                case SPELL_AURA_MOD_HEALING_DONE:
-                case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE:
-                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) < 0)
-                        return false;
-                    break;
-                case SPELL_AURA_MOD_DAMAGE_TAKEN:           // dependent from bas point sign (positive -> negative)
-                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
-                        return false;
-                    break;
-                case SPELL_AURA_MOD_CRIT_PCT:
-                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
-                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
-                        return true;                        // some expected positive spells have SPELL_ATTR_EX_NEGATIVE
-                    break;
-                case SPELL_AURA_ADD_TARGET_TRIGGER:
-                    return true;
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
-                    if (!deep)
-                    {
-                        uint32 spellTriggeredId = spellproto->EffectTriggerSpell[effIndex];
-                        SpellEntry const *spellTriggeredProto = sSpellStore.LookupEntry(spellTriggeredId);
-
-                        if (spellTriggeredProto)
-                        {
-                            // non-positive targets of main spell return early
-                            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-                            {
-                                if (!spellTriggeredProto->Effect[i])
-                                    continue;
-                                // if non-positive trigger cast targeted to positive target this main cast is non-positive
-                                // this will place this spell auras as debuffs
-                                if (IsPositiveTarget(spellTriggeredProto->EffectImplicitTargetA[effIndex],spellTriggeredProto->EffectImplicitTargetB[effIndex]) && !_isPositiveEffect(spellTriggeredId,i, true))
-                                    return false;
-                            }
-                        }
-                    }
-                case SPELL_AURA_PROC_TRIGGER_SPELL:
-                    // many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
-                    break;
-                case SPELL_AURA_MOD_STUN:                   //have positive and negative spells, we can't sort its correctly at this moment.
-                    if (effIndex == 0 && spellproto->Effect[1] == 0 && spellproto->Effect[2] == 0)
-                        return false;                       // but all single stun aura spells is negative
-                    break;
-                case SPELL_AURA_MOD_PACIFY_SILENCE:
-                    if (spellproto->Id == 24740)             // Wisp Costume
-                        return true;
-                    return false;
-                case SPELL_AURA_MOD_ROOT:
-                case SPELL_AURA_MOD_SILENCE:
-                case SPELL_AURA_GHOST:
-                case SPELL_AURA_PERIODIC_LEECH:
-                case SPELL_AURA_MOD_STALKED:
-                case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
-                case SPELL_AURA_PREVENT_RESSURECTION:
-                    return false;
-                case SPELL_AURA_PERIODIC_DAMAGE:            // used in positive spells also.
-                    // part of negative spell if casted at self (prevent cancel)
-                    if (spellproto->EffectImplicitTargetA[effIndex] == TARGET_UNIT_CASTER)
-                        return false;
-                    break;
-                case SPELL_AURA_MOD_DECREASE_SPEED:         // used in positive spells also
-                    // part of positive spell if casted at self
-                    if (spellproto->EffectImplicitTargetA[effIndex] != TARGET_UNIT_CASTER)
-                        return false;
-                    // but not this if this first effect (didn't find better check)
-                    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1 && effIndex == 0)
-                        return false;
-                    break;
-                case SPELL_AURA_MECHANIC_IMMUNITY:
-                {
-                    // non-positive immunities
-                    switch(spellproto->EffectMiscValue[effIndex])
-                    {
-                        case MECHANIC_BANDAGE:
-                        case MECHANIC_SHIELD:
-                        case MECHANIC_MOUNT:
-                        case MECHANIC_INVULNERABILITY:
-                            return false;
-                        default:
-                            break;
-                    }
-                }   break;
-                case SPELL_AURA_ADD_FLAT_MODIFIER:          // mods
-                case SPELL_AURA_ADD_PCT_MODIFIER:
-                {
-                    // non-positive mods
-                    switch(spellproto->EffectMiscValue[effIndex])
-                    {
-                        case SPELLMOD_COST:                 // dependent from bas point sign (negative -> positive)
-                            if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
-                            {
-                                if (!deep)
-                                {
-                                    bool negative = true;
-                                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; ++i)
-                                    {
-                                        if (i != effIndex)
-                                            if (_isPositiveEffect(spellId, i, true))
-                                            {
-                                                negative = false;
-                                                break;
-                                            }
-                                    }
-                                    if (negative)
-                                        return false;
-                                }
-                            }
-                            break;
-                        default:
-                            break;
-                    }
-                }   break;
-                default:
-                    break;
-            }
-            break;
-        }
-        default:
-            break;
-    }
-
-    // non-positive targets
-    if (!IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex]))
-        return false;
-
-    // AttributesEx check
-    if (spellproto->AttributesEx & SPELL_ATTR_EX_NEGATIVE)
-        return false;
-
-    if (!deep && spellproto->EffectTriggerSpell[effIndex]
-        && !spellproto->EffectApplyAuraName[effIndex]
-        && IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex])
-        && !_isPositiveSpell(spellproto->EffectTriggerSpell[effIndex], true))
-        return false;
-
-    // ok, positive
-    return true;
-}
-
-bool IsPositiveSpell(uint32 spellId)
-{
-    if (!sSpellStore.LookupEntry(spellId)) // non-existing spells
-        return false;
-    return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE);
-}
-
-bool IsPositiveEffect(uint32 spellId, uint32 effIndex)
-{
-    if (!sSpellStore.LookupEntry(spellId))
-        return false;
-    switch(effIndex)
-    {
-        default:
-        case 0: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF0);
-        case 1: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF1);
-        case 2: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF2);
-    }
-}
-
-bool SpellMgr::_isPositiveSpell(uint32 spellId, bool deep) const
-{
-    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
-    if (!spellproto) return false;
-
-    // spells with at least one negative effect are considered negative
-    // some self-applied spells have negative effects but in self casting case negative check ignored.
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        if (!_isPositiveEffect(spellId, i, deep))
-            return false;
-    return true;
-}
-
-bool IsSingleTargetSpell(SpellEntry const *spellInfo)
-{
-    // all other single target spells have if it has AttributesEx5
-    if (spellInfo->AttributesEx5 & SPELL_ATTR_EX5_SINGLE_TARGET_SPELL)
-        return true;
-
-    switch(GetSpellSpecific(spellInfo))
-    {
-        case SPELL_SPECIFIC_JUDGEMENT:
-            return true;
-        default:
-            break;
-    }
-
-    return false;
-}
-
-bool IsSingleTargetSpells(SpellEntry const *spellInfo1, SpellEntry const *spellInfo2)
-{
-    // TODO - need better check
-    // Equal icon and spellfamily
-    if (spellInfo1->SpellFamilyName == spellInfo2->SpellFamilyName &&
-        spellInfo1->SpellIconID == spellInfo2->SpellIconID)
-        return true;
-
-    // TODO - need found Judgements rule
-    SpellSpecific spec1 = GetSpellSpecific(spellInfo1);
-    // spell with single target specific types
-    switch(spec1)
-    {
-        case SPELL_SPECIFIC_JUDGEMENT:
-        case SPELL_SPECIFIC_MAGE_POLYMORPH:
-            if (GetSpellSpecific(spellInfo2) == spec1)
-                return true;
-            break;
-        default:
-            break;
-    }
-
-    return false;
-}
-
-SpellCastResult GetErrorAtShapeshiftedCast (SpellEntry const *spellInfo, uint32 form)
-{
-    // talents that learn spells can have stance requirements that need ignore
-    // (this requirement only for client-side stance show in talent description)
-    if (GetTalentSpellCost(spellInfo->Id) > 0 &&
-        (spellInfo->Effect[0] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[1] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[2] == SPELL_EFFECT_LEARN_SPELL))
-        return SPELL_CAST_OK;
-
-    uint32 stanceMask = (form ? 1 << (form - 1) : 0);
-
-    if (stanceMask & spellInfo->StancesNot)                 // can explicitly not be casted in this stance
-        return SPELL_FAILED_NOT_SHAPESHIFT;
-
-    if (stanceMask & spellInfo->Stances)                    // can explicitly be casted in this stance
-        return SPELL_CAST_OK;
-
-    bool actAsShifted = false;
-    SpellShapeshiftEntry const *shapeInfo = NULL;
-    if (form > 0)
-    {
-        shapeInfo = sSpellShapeshiftStore.LookupEntry(form);
-        if (!shapeInfo)
-        {
-            sLog.outError("GetErrorAtShapeshiftedCast: unknown shapeshift %u", form);
-            return SPELL_CAST_OK;
-        }
-        actAsShifted = !(shapeInfo->flags1 & 1);            // shapeshift acts as normal form for spells
-    }
-
-    if (actAsShifted)
-    {
-        if (spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT) // not while shapeshifted
-            return SPELL_FAILED_NOT_SHAPESHIFT;
-        else if (spellInfo->Stances != 0)                   // needs other shapeshift
-            return SPELL_FAILED_ONLY_SHAPESHIFT;
-    }
-    else
-    {
-        // needs shapeshift
-        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_NEED_SHAPESHIFT) && spellInfo->Stances != 0)
-            return SPELL_FAILED_ONLY_SHAPESHIFT;
-    }
-
-    // Check if stance disables cast of not-stance spells
-    // Example: cannot cast any other spells in zombie or ghoul form
-    // TODO: Find a way to disable use of these spells clientside
-    if (shapeInfo && shapeInfo->flags1 & 0x400)
-    {
-        if (!(stanceMask & spellInfo->Stances))
-            return SPELL_FAILED_ONLY_SHAPESHIFT;
-    }
-
-    return SPELL_CAST_OK;
-}
-
-void SpellMgr::LoadSpellTargetPositions()
-{
-    mSpellTargetPositions.clear();                                // need for reload case
-
-    uint32 count = 0;
-
-    //                                                0   1           2                  3                  4                  5
-    QueryResult result = WorldDatabase.Query("SELECT id, target_map, target_position_x, target_position_y, target_position_z, target_orientation FROM spell_target_position");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell target coordinates", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 Spell_ID = fields[0].GetUInt32();
-
-        SpellTargetPosition st;
-
-        st.target_mapId       = fields[1].GetUInt32();
-        st.target_X           = fields[2].GetFloat();
-        st.target_Y           = fields[3].GetFloat();
-        st.target_Z           = fields[4].GetFloat();
-        st.target_Orientation = fields[5].GetFloat();
-
-        MapEntry const* mapEntry = sMapStore.LookupEntry(st.target_mapId);
-        if (!mapEntry)
-        {
-            sLog.outErrorDb("Spell (ID:%u) target map (ID: %u) does not exist in `Map.dbc`.",Spell_ID,st.target_mapId);
-            continue;
-        }
-
-        if (st.target_X==0 && st.target_Y==0 && st.target_Z==0)
-        {
-            sLog.outErrorDb("Spell (ID:%u) target coordinates not provided.",Spell_ID);
-            continue;
-        }
-
-        SpellEntry const* spellInfo = sSpellStore.LookupEntry(Spell_ID);
-        if (!spellInfo)
-        {
-            sLog.outErrorDb("Spell (ID:%u) listed in `spell_target_position` does not exist.",Spell_ID);
-            continue;
-        }
-
-        bool found = false;
-        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (spellInfo->EffectImplicitTargetA[i] == TARGET_DST_DB || spellInfo->EffectImplicitTargetB[i] == TARGET_DST_DB)
-            {
-                // additional requirements
-                if (spellInfo->Effect[i]==SPELL_EFFECT_BIND && spellInfo->EffectMiscValue[i])
-                {
-                    uint32 area_id = sMapMgr.GetAreaId(st.target_mapId, st.target_X, st.target_Y, st.target_Z);
-                    if (area_id != uint32(spellInfo->EffectMiscValue[i]))
-                    {
-                        sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` expected point to zone %u bit point to zone %u.",Spell_ID, spellInfo->EffectMiscValue[i], area_id);
-                        break;
-                    }
-                }
-
-                found = true;
-                break;
-            }
-        }
-        if (!found)
-        {
-            sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` does not have target TARGET_DST_DB (17).",Spell_ID);
-            continue;
-        }
-
-        mSpellTargetPositions[Spell_ID] = st;
-        ++count;
-
-    } while (result->NextRow());
-
-    // Check all spells
-    for (uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
-    {
-        SpellEntry const * spellInfo = sSpellStore.LookupEntry(i);
-        if (!spellInfo)
-            continue;
-
-        bool found = false;
-        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            switch(spellInfo->EffectImplicitTargetA[j])
-            {
-                case TARGET_DST_DB:
-                    found = true;
-                    break;
-            }
-            if (found)
-                break;
-            switch(spellInfo->EffectImplicitTargetB[j])
-            {
-                case TARGET_DST_DB:
-                    found = true;
-                    break;
-            }
-            if (found)
-                break;
-        }
-        if (found)
-        {
-//            if (!sSpellMgr.GetSpellTargetPosition(i))
-//                sLog.outDebug("Spell (ID: %u) does not have record in `spell_target_position`", i);
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell teleport coordinates", count);
-}
-
-bool SpellMgr::IsAffectedByMod(SpellEntry const *spellInfo, SpellModifier *mod) const
-{
-    // false for spellInfo == NULL
-    if (!spellInfo || !mod)
-        return false;
-
-    SpellEntry const *affect_spell = sSpellStore.LookupEntry(mod->spellId);
-    // False if affect_spell == NULL or spellFamily not equal
-    if (!affect_spell || affect_spell->SpellFamilyName != spellInfo->SpellFamilyName)
-        return false;
-
-    // true
-    if (mod->mask  & spellInfo->SpellFamilyFlags)
-        return true;
-
-    return false;
-}
-
-void SpellMgr::LoadSpellProcEvents()
-{
-    mSpellProcEventMap.clear();                             // need for reload case
-
-    uint32 count = 0;
-
-    //                                                0      1           2                3                 4                 5                 6          7       8        9             10
-    QueryResult result = WorldDatabase.Query("SELECT entry, SchoolMask, SpellFamilyName, SpellFamilyMask0, SpellFamilyMask1, SpellFamilyMask2, procFlags, procEx, ppmRate, CustomChance, Cooldown FROM spell_proc_event");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell proc event conditions", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-    uint32 customProc = 0;
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 entry = fields[0].GetUInt32();
-
-        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
-        if (!spell)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_proc_event` does not exist", entry);
-            continue;
-        }
-
-        SpellProcEventEntry spe;
-
-        spe.schoolMask      = fields[1].GetUInt32();
-        spe.spellFamilyName = fields[2].GetUInt32();
-        spe.spellFamilyMask[0] = fields[3].GetUInt32();
-        spe.spellFamilyMask[1] = fields[4].GetUInt32();
-        spe.spellFamilyMask[2] = fields[5].GetUInt32();
-        spe.procFlags       = fields[6].GetUInt32();
-        spe.procEx          = fields[7].GetUInt32();
-        spe.ppmRate         = fields[8].GetFloat();
-        spe.customChance    = fields[9].GetFloat();
-        spe.cooldown        = fields[10].GetUInt32();
-
-        mSpellProcEventMap[entry] = spe;
-
-        if (spell->procFlags == 0)
-        {
-            if (spe.procFlags == 0)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_proc_event` probally not triggered spell", entry);
-                continue;
-            }
-            customProc++;
-        }
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    if (customProc)
-        sLog.outString(">> Loaded %u extra spell proc event conditions + %u custom",  count, customProc);
-    else
-        sLog.outString(">> Loaded %u extra spell proc event conditions", count);
-}
-
-void SpellMgr::LoadSpellBonusess()
-{
-    mSpellBonusMap.clear();                             // need for reload case
-    uint32 count = 0;
-    //                                                0      1             2          3         4
-    QueryResult result = WorldDatabase.Query("SELECT entry, direct_bonus, dot_bonus, ap_bonus, ap_dot_bonus FROM spell_bonus_data");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell bonus data", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        Field *fields = result->Fetch();
-        bar.step();
-        uint32 entry = fields[0].GetUInt32();
-
-        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
-        if (!spell)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_bonus_data` does not exist", entry);
-            continue;
-        }
-
-        SpellBonusEntry sbe;
-
-        sbe.direct_damage = fields[1].GetFloat();
-        sbe.dot_damage    = fields[2].GetFloat();
-        sbe.ap_bonus      = fields[3].GetFloat();
-        sbe.ap_dot_bonus   = fields[4].GetFloat();
-
-        mSpellBonusMap[entry] = sbe;
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u extra spell bonus data",  count);
-}
-
-bool SpellMgr::IsSpellProcEventCanTriggeredBy(SpellProcEventEntry const* spellProcEvent, uint32 EventProcFlag, SpellEntry const * procSpell, uint32 procFlags, uint32 procExtra, bool active)
-{
-    // No extra req need
-    uint32 procEvent_procEx = PROC_EX_NONE;
-
-    // check prockFlags for condition
-    if ((procFlags & EventProcFlag) == 0)
-        return false;
-
-    bool hasFamilyMask = false;
-
-    /* Check Periodic Auras
-
-    *Dots can trigger if spell has no PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
-        nor PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
-
-    *Only Hots can trigger if spell has PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
-
-    *Only dots can trigger if spell has both positivity flags or PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
-
-    *Aura has to have PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL or spellfamily specified to trigger from Hot
-
-    */
-
-    if (procFlags & PROC_FLAG_DONE_PERIODIC)
-    {
-        if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG)
-        {
-            if (!(procExtra & PROC_EX_INTERNAL_DOT))
-                return false;
-        }
-        else if (procExtra & PROC_EX_INTERNAL_HOT)
-            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
-        else if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS)
-            return false;
-    }
-
-    if (procFlags & PROC_FLAG_TAKEN_PERIODIC)
-    {
-        if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)
-        {
-            if (!(procExtra & PROC_EX_INTERNAL_DOT))
-                return false;
-        }
-        else if (procExtra & PROC_EX_INTERNAL_HOT)
-            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
-        else if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_POS)
-            return false;
-    }
-    // Trap casts are active by default
-    if (procFlags & PROC_FLAG_DONE_TRAP_ACTIVATION)
-        active = true;
-
-    // Always trigger for this
-    if (procFlags & (PROC_FLAG_KILLED | PROC_FLAG_KILL | PROC_FLAG_DEATH))
-        return true;
-
-    if (spellProcEvent)     // Exist event data
-    {
-        // Store extra req
-        procEvent_procEx = spellProcEvent->procEx;
-
-        // For melee triggers
-        if (procSpell == NULL)
-        {
-            // Check (if set) for school (melee attack have Normal school)
-            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
-                return false;
-        }
-        else // For spells need check school/spell family/family mask
-        {
-            // Check (if set) for school
-            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & procSpell->SchoolMask) == 0)
-                return false;
-
-            // Check (if set) for spellFamilyName
-            if (spellProcEvent->spellFamilyName && (spellProcEvent->spellFamilyName != procSpell->SpellFamilyName))
-                return false;
-
-            // spellFamilyName is Ok need check for spellFamilyMask if present
-            if (spellProcEvent->spellFamilyMask)
-            {
-                if ((spellProcEvent->spellFamilyMask & procSpell->SpellFamilyFlags) == 0)
-                    return false;
-                hasFamilyMask = true;
-                // Some spells are not considered as active even with have spellfamilyflags
-                if (!(procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL))
-                    active = true;
-            }
-        }
-    }
-
-    if (procExtra & (PROC_EX_INTERNAL_REQ_FAMILY))
-    {
-        if (!hasFamilyMask)
-            return false;
-    }
-
-    // Check for extra req (if none) and hit/crit
-    if (procEvent_procEx == PROC_EX_NONE)
-    {
-        // No extra req, so can trigger only for hit/crit - spell has to be active
-        if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && active)
-            return true;
-    }
-    else // Passive spells hits here only if resist/reflect/immune/evade
-    {
-        if (procExtra & AURA_SPELL_PROC_EX_MASK)
-        {
-            // if spell marked as procing only from not active spells
-            if (active && procEvent_procEx & PROC_EX_NOT_ACTIVE_SPELL)
-                return false;
-            // if spell marked as procing only from active spells
-            if (!active && procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL)
-                return false;
-            // Exist req for PROC_EX_EX_TRIGGER_ALWAYS
-            if (procEvent_procEx & PROC_EX_EX_TRIGGER_ALWAYS)
-                return true;
-            // PROC_EX_NOT_ACTIVE_SPELL and PROC_EX_ONLY_ACTIVE_SPELL flags handle: if passed checks before
-            if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && ((procEvent_procEx & (AURA_SPELL_PROC_EX_MASK)) == 0))
-                return true;
-        }
-        // Check Extra Requirement like (hit/crit/miss/resist/parry/dodge/block/immune/reflect/absorb and other)
-        if (procEvent_procEx & procExtra)
-            return true;
-    }
-    return false;
-}
-
-void SpellMgr::LoadSpellGroups()
-{
-    mSpellSpellGroup.clear();                                  // need for reload case
-    mSpellGroupSpell.clear();
-
-    uint32 count = 0;
-
-    //                                                       0   1
-    QueryResult result = WorldDatabase.Query("SELECT id, spell_id FROM spell_group");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell group definitions", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    std::set<uint32> groups;
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 group_id = fields[0].GetUInt32();
-        if (group_id <= SPELL_GROUP_DB_RANGE_MIN && group_id >= SPELL_GROUP_CORE_RANGE_MAX)
-        {
-            sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` is in core range, but is not defined in core!", group_id);
-            continue;
-        }
-        int32 spell_id = fields[1].GetInt32();
-
-        groups.insert(std::set<uint32>::value_type(group_id));
-        mSpellGroupSpell.insert(SpellGroupSpellMap::value_type((SpellGroup)group_id, spell_id));
-
-    } while (result->NextRow());
-
-    for (SpellGroupSpellMap::iterator itr = mSpellGroupSpell.begin(); itr!= mSpellGroupSpell.end() ;)
-    {
-        if (itr->second < 0)
-        {
-            if (groups.find(abs(itr->second)) == groups.end())
-            {
-                sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` does not exist", abs(itr->second));
-                mSpellGroupSpell.erase(itr++);
-            }
-            else
-                ++itr;
-        }
-        else
-        {
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(itr->second);
-
-            if (!spellInfo)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_group` does not exist", itr->second);
-                mSpellGroupSpell.erase(itr++);
-            }
-            else if (GetSpellRank(itr->second) > 1)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_group` is not first rank of spell", itr->second);
-                mSpellGroupSpell.erase(itr++);
-            }
-            else
-                ++itr;
-        }
-    }
-
-    for (std::set<uint32>::iterator groupItr = groups.begin() ; groupItr != groups.end() ; ++groupItr)
-    {
-        std::set<uint32> spells;
-        GetSetOfSpellsInSpellGroup(SpellGroup(*groupItr), spells);
-
-        for (std::set<uint32>::iterator spellItr = spells.begin() ; spellItr != spells.end() ; ++spellItr)
-        {
-            ++count;
-            mSpellSpellGroup.insert(SpellSpellGroupMap::value_type(*spellItr, SpellGroup(*groupItr)));
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell group definitions", count);
-}
-
-void SpellMgr::LoadSpellGroupStackRules()
-{
-    mSpellGroupStack.clear();                                  // need for reload case
-
-    uint32 count = 0;
-
-    //                                                       0         1
-    QueryResult result = WorldDatabase.Query("SELECT group_id, stack_rule FROM spell_group_stack_rules");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell group stack rules", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 group_id = fields[0].GetUInt32();
-        uint8 stack_rule = fields[1].GetUInt32();
-        if (stack_rule >= SPELL_GROUP_STACK_RULE_MAX)
-        {
-            sLog.outErrorDb("SpellGroupStackRule %u listed in `spell_group_stack_rules` does not exist", stack_rule);
-            continue;
-        }
-
-        SpellGroupSpellMapBounds spellGroup = GetSpellGroupSpellMapBounds((SpellGroup)group_id);
-
-        if (spellGroup.first == spellGroup.second)
-        {
-            sLog.outErrorDb("SpellGroup id %u listed in `spell_group_stack_rules` does not exist", group_id);
-            continue;
-        }
-
-        mSpellGroupStack[(SpellGroup)group_id] = (SpellGroupStackRule)stack_rule;
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell group stack rules", count);
-}
-
-void SpellMgr::LoadSpellThreats()
-{
-    mSpellThreatMap.clear();                                // need for reload case
-
-    uint32 count = 0;
-
-    //                                                0      1
-    QueryResult result = WorldDatabase.Query("SELECT entry, Threat FROM spell_threat");
-    if (!result)
-    {
-
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u aggro generating spells", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 entry = fields[0].GetUInt32();
-        uint16 Threat = fields[1].GetUInt16();
-
-        if (!sSpellStore.LookupEntry(entry))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_threat` does not exist", entry);
-            continue;
-        }
-
-        mSpellThreatMap[entry] = Threat;
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u aggro generating spells", count);
-}
-
-bool SpellMgr::IsRankSpellDueToSpell(SpellEntry const *spellInfo_1,uint32 spellId_2) const
-{
-    SpellEntry const *spellInfo_2 = sSpellStore.LookupEntry(spellId_2);
-    if (!spellInfo_1 || !spellInfo_2) return false;
-    if (spellInfo_1->Id == spellId_2) return false;
-
-    return GetFirstSpellInChain(spellInfo_1->Id) == GetFirstSpellInChain(spellId_2);
-}
-
-bool SpellMgr::canStackSpellRanks(SpellEntry const *spellInfo)
-{
-    if (IsPassiveSpell(spellInfo->Id))                       // ranked passive spell
-        return false;
-    if (spellInfo->powerType != POWER_MANA && spellInfo->powerType != POWER_HEALTH)
-        return false;
-    if (IsProfessionOrRidingSpell(spellInfo->Id))
-        return false;
-
-    if (sSpellMgr.IsSkillBonusSpell(spellInfo->Id))
-        return false;
-
-    // All stance spells. if any better way, change it.
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch(spellInfo->SpellFamilyName)
-        {
-            case SPELLFAMILY_PALADIN:
-                // Paladin aura Spell
-                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID)
-                    return false;
-                break;
-            case SPELLFAMILY_DRUID:
-                // Druid form Spell
-                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
-                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
-                    return false;
-                break;
-            case SPELLFAMILY_ROGUE:
-                // Rogue Stealth
-                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
-                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
-                    return false;
-        }
-    }
-    return true;
-}
-
-bool SpellMgr::IsProfessionOrRidingSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
-        {
-            uint32 skill = spellInfo->EffectMiscValue[i];
-
-            bool found = IsProfessionOrRidingSkill(skill);
-            if (found)
-                return true;
-        }
-    }
-    return false;
-}
-
-bool SpellMgr::IsProfessionSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
-        {
-            uint32 skill = spellInfo->EffectMiscValue[i];
-
-            bool found = IsProfessionSkill(skill);
-            if (found)
-                return true;
-        }
-    }
-    return false;
-}
-
-bool SpellMgr::IsPrimaryProfessionSpell(uint32 spellId)
-{
-    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
-    if (!spellInfo)
-        return false;
-
-    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
-    {
-        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
-        {
-            uint32 skill = spellInfo->EffectMiscValue[i];
-
-            bool found = IsPrimaryProfessionSkill(skill);
-            if (found)
-                return true;
-        }
-    }
-    return false;
-}
-
-bool SpellMgr::IsPrimaryProfessionFirstRankSpell(uint32 spellId) const
-{
-    return IsPrimaryProfessionSpell(spellId) && GetSpellRank(spellId) == 1;
-}
-
-bool SpellMgr::IsSkillBonusSpell(uint32 spellId) const
-{
-    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
-
-    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
-    {
-        SkillLineAbilityEntry const *pAbility = _spell_idx->second;
-        if (!pAbility || pAbility->learnOnGetSkill != ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
-            continue;
-
-        if (pAbility->req_skill_value > 0)
-            return true;
-    }
-
-    return false;
-}
-
-bool SpellMgr::IsSkillTypeSpell(uint32 spellId, SkillType type) const
-{
-    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
-
-    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
-        if (_spell_idx->second->skillId == uint32(type))
-            return true;
-
-    return false;
-}
-
-// basepoints provided here have to be valid basepoints (use SpellMgr::CalculateSpellEffectBaseAmount)
-int32 SpellMgr::CalculateSpellEffectAmount(SpellEntry const * spellEntry, uint8 effIndex, Unit const * caster, int32 const * effBasePoints, Unit const * /*target*/)
-{
-    float basePointsPerLevel = spellEntry->EffectRealPointsPerLevel[effIndex];
-    int32 basePoints = effBasePoints ? *effBasePoints : spellEntry->EffectBasePoints[effIndex];
-    int32 randomPoints = int32(spellEntry->EffectDieSides[effIndex]);
-
-    // base amount modification based on spell lvl vs caster lvl
-    if (caster)
-    {
-        int32 level = int32(caster->getLevel());
-        if (level > int32(spellEntry->maxLevel) && spellEntry->maxLevel > 0)
-            level = int32(spellEntry->maxLevel);
-        else if (level < int32(spellEntry->baseLevel))
-            level = int32(spellEntry->baseLevel);
-        level -= int32(spellEntry->spellLevel);
-        basePoints += int32(level * basePointsPerLevel);
-    }
-
-    // roll in a range <1;EffectDieSides> as of patch 3.3.3
-    switch(randomPoints)
-    {
-        case 0: break;
-        case 1: basePoints += 1; break;                     // range 1..1
-        default:
-            // range can have positive (1..rand) and negative (rand..1) values, so order its for irand
-            int32 randvalue = (randomPoints >= 1)
-                ? irand(1, randomPoints)
-                : irand(randomPoints, 1);
-
-            basePoints += randvalue;
-            break;
-    }
-
-    int32 value = basePoints;
-
-    // random damage
-    if (caster)
-    {
-        // bonus amount from combo points
-        if  (caster->m_movedPlayer)
-            if (uint8 comboPoints = caster->m_movedPlayer->GetComboPoints())
-                if (float comboDamage = spellEntry->EffectPointsPerComboPoint[effIndex])
-                    value += int32(comboDamage * comboPoints);
-
-        value = caster->ApplyEffectModifiers(spellEntry, effIndex, value);
-
-        // amount multiplication based on caster's level
-        if (!basePointsPerLevel && (spellEntry->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION && spellEntry->spellLevel) &&
-                spellEntry->Effect[effIndex] != SPELL_EFFECT_WEAPON_PERCENT_DAMAGE &&
-                spellEntry->Effect[effIndex] != SPELL_EFFECT_KNOCK_BACK &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_ALWAYS &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_NOT_STACK &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_INCREASE_SPEED &&
-                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_DECREASE_SPEED)
-                //there are many more: slow speed, -healing pct
-            value = int32(value*0.25f*exp(caster->getLevel()*(70-spellEntry->spellLevel)/1000.0f));
-            //value = int32(value * (int32)getLevel() / (int32)(spellProto->spellLevel ? spellProto->spellLevel : 1));
-    }
-
-    return value;
-}
-
-int32 SpellMgr::CalculateSpellEffectBaseAmount(int32 value, SpellEntry const * spellEntry, uint8 effIndex)
-{
-    if (spellEntry->EffectDieSides[effIndex] == 0)
-        return value;
-    else
-        return value - 1;
-}
-
-float SpellMgr::CalculateSpellEffectValueMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
-{
-    float multiplier = spellEntry->EffectValueMultiplier[effIndex];
-
-    if (caster)
-        if (Player * modOwner = caster->GetSpellModOwner())
-            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_VALUE_MULTIPLIER, multiplier, spell);
-    return multiplier;
-}
-
-float SpellMgr::CalculateSpellEffectDamageMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
-{
-    float multiplier = spellEntry->EffectDamageMultiplier[effIndex];
-
-    if (caster)
-        if (Player * modOwner = caster->GetSpellModOwner())
-            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_DAMAGE_MULTIPLIER, multiplier, spell);
-    return multiplier;
-}
-
-SpellEntry const* SpellMgr::SelectAuraRankForPlayerLevel(SpellEntry const* spellInfo, uint32 playerLevel) const
-{
-    // ignore passive spells
-    if (IsPassiveSpell(spellInfo->Id))
-        return spellInfo;
-
-    bool needRankSelection = false;
-    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (IsPositiveEffect(spellInfo->Id, i) && (
-            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA ||
-            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
-            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID
-))
-        {
-            needRankSelection = true;
-            break;
-        }
-    }
-
-    // not required
-    if (!needRankSelection)
-        return spellInfo;
-
-    for (uint32 nextSpellId = spellInfo->Id; nextSpellId != 0; nextSpellId = GetPrevSpellInChain(nextSpellId))
-    {
-        SpellEntry const *nextSpellInfo = sSpellStore.LookupEntry(nextSpellId);
-        if (!nextSpellInfo)
-            break;
-
-        // if found appropriate level
-        if (playerLevel + 10 >= nextSpellInfo->spellLevel)
-            return nextSpellInfo;
-
-        // one rank less then
-    }
-
-    // not found
-    return NULL;
-}
-
-void SpellMgr::LoadSpellLearnSkills()
-{
-    mSpellLearnSkills.clear();                              // need for reload case
-
-    // search auto-learned skills and add its to map also for use in unlearn spells/talents
-    uint32 dbc_count = 0;
-    barGoLink bar(sSpellStore.GetNumRows());
-    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
-    {
-        bar.step();
-        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
-
-        if (!entry)
-            continue;
-
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (entry->Effect[i] == SPELL_EFFECT_SKILL)
-            {
-                SpellLearnSkillNode dbc_node;
-                dbc_node.skill = entry->EffectMiscValue[i];
-                dbc_node.step  = SpellMgr::CalculateSpellEffectAmount(entry, i);
-                if (dbc_node.skill != SKILL_RIDING)
-                    dbc_node.value = 1;
-                else
-                    dbc_node.value = dbc_node.step * 75;
-                dbc_node.maxvalue = dbc_node.step * 75;
-                mSpellLearnSkills[spell] = dbc_node;
-                ++dbc_count;
-                break;
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u Spell Learn Skills from DBC", dbc_count);
-}
-
-void SpellMgr::LoadSpellLearnSpells()
-{
-    mSpellLearnSpells.clear();                              // need for reload case
-
-    //                                                  0      1        2
-    QueryResult result = WorldDatabase.Query("SELECT entry, SpellID, Active FROM spell_learn_spell");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded 0 spell learn spells");
-        sLog.outErrorDb("`spell_learn_spell` table is empty!");
-        return;
-    }
-
-    uint32 count = 0;
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        bar.step();
-        Field *fields = result->Fetch();
-
-        uint32 spell_id = fields[0].GetUInt32();
-
-        SpellLearnSpellNode node;
-        node.spell      = fields[1].GetUInt32();
-        node.active     = fields[2].GetBool();
-        node.autoLearned= false;
-
-        if (!sSpellStore.LookupEntry(spell_id))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` does not exist", spell_id);
-            continue;
-        }
-
-        if (!sSpellStore.LookupEntry(node.spell))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` learning not existed spell %u", spell_id, node.spell);
-            continue;
-        }
-
-        if (GetTalentSpellCost(node.spell))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` attempt learning talent spell %u, skipped", spell_id, node.spell);
-            continue;
-        }
-
-        mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell_id,node));
-
-        ++count;
-    } while (result->NextRow());
-
-    // search auto-learned spells and add its to map also for use in unlearn spells/talents
-    uint32 dbc_count = 0;
-    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
-    {
-        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
-
-        if (!entry)
-            continue;
-
-        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            if (entry->Effect[i] == SPELL_EFFECT_LEARN_SPELL)
-            {
-                SpellLearnSpellNode dbc_node;
-                dbc_node.spell = entry->EffectTriggerSpell[i];
-                dbc_node.active = true;                     // all dbc based learned spells is active (show in spell book or hide by client itself)
-
-                // ignore learning not existed spells (broken/outdated/or generic learnig spell 483
-                if (!sSpellStore.LookupEntry(dbc_node.spell))
-                    continue;
-
-                // talent or passive spells or skill-step spells auto-casted and not need dependent learning,
-                // pet teaching spells don't must be dependent learning (casted)
-                // other required explicit dependent learning
-                dbc_node.autoLearned = entry->EffectImplicitTargetA[i] == TARGET_UNIT_PET || GetTalentSpellCost(spell) > 0 || IsPassiveSpell(spell) || IsSpellHaveEffect(entry,SPELL_EFFECT_SKILL_STEP);
-
-                SpellLearnSpellMapBounds db_node_bounds = GetSpellLearnSpellMapBounds(spell);
-
-                bool found = false;
-                for (SpellLearnSpellMap::const_iterator itr = db_node_bounds.first; itr != db_node_bounds.second; ++itr)
-                {
-                    if (itr->second.spell == dbc_node.spell)
-                    {
-                        sLog.outErrorDb("Spell %u auto-learn spell %u in spell.dbc then the record in `spell_learn_spell` is redundant, please fix DB.",
-                            spell,dbc_node.spell);
-                        found = true;
-                        break;
-                    }
-                }
-
-                if (!found)                                  // add new spell-spell pair if not found
-                {
-                    mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell,dbc_node));
-                    ++dbc_count;
-                }
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell learn spells + %u found in DBC", count, dbc_count);
-}
-
-void SpellMgr::LoadSpellPetAuras()
-{
-    mSpellPetAuraMap.clear();                                  // need for reload case
-
-    uint32 count = 0;
-
-    //                                                  0       1       2    3
-    QueryResult result = WorldDatabase.Query("SELECT spell, effectId, pet, aura FROM spell_pet_auras");
-    if (!result)
-    {
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell pet auras", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 spell = fields[0].GetUInt32();
-        uint8 eff = fields[1].GetUInt8();
-        uint32 pet = fields[2].GetUInt32();
-        uint32 aura = fields[3].GetUInt32();
-
-        SpellPetAuraMap::iterator itr = mSpellPetAuraMap.find((spell<<8) + eff);
-        if (itr != mSpellPetAuraMap.end())
-            itr->second.AddAura(pet, aura);
-        else
-        {
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell);
-            if (!spellInfo)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_pet_auras` does not exist", spell);
-                continue;
-            }
-            if (spellInfo->Effect[eff] != SPELL_EFFECT_DUMMY &&
-               (spellInfo->Effect[eff] != SPELL_EFFECT_APPLY_AURA ||
-                spellInfo->EffectApplyAuraName[eff] != SPELL_AURA_DUMMY))
-            {
-                sLog.outError("Spell %u listed in `spell_pet_auras` does not have dummy aura or dummy effect", spell);
-                continue;
-            }
-
-            SpellEntry const* spellInfo2 = sSpellStore.LookupEntry(aura);
-            if (!spellInfo2)
-            {
-                sLog.outErrorDb("Aura %u listed in `spell_pet_auras` does not exist", aura);
-                continue;
-            }
-
-            PetAura pa(pet, aura, spellInfo->EffectImplicitTargetA[eff] == TARGET_UNIT_PET, SpellMgr::CalculateSpellEffectAmount(spellInfo, eff));
-            mSpellPetAuraMap[(spell<<8) + eff] = pa;
-        }
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell pet auras", count);
-}
-
-void SpellMgr::LoadPetLevelupSpellMap()
-{
-    mPetLevelupSpellMap.clear();                                   // need for reload case
-
-    uint32 count = 0;
-    uint32 family_count = 0;
-
-    barGoLink bar(sCreatureFamilyStore.GetNumRows());
-
-    for (uint32 i = 0; i < sCreatureFamilyStore.GetNumRows(); ++i)
-    {
-        bar.step();
-
-        CreatureFamilyEntry const *creatureFamily = sCreatureFamilyStore.LookupEntry(i);
-        if (!creatureFamily)                                     // not exist
-            continue;
-
-        for (uint8 j = 0; j < 2; ++j)
-        {
-            if (!creatureFamily->skillLine[j])
-                continue;
-
-            for (uint32 k = 0; k < sSkillLineAbilityStore.GetNumRows(); ++k)
-            {
-                SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(k);
-                if (!skillLine)
-                    continue;
-
-                //if (skillLine->skillId != creatureFamily->skillLine[0] &&
-                //    (!creatureFamily->skillLine[1] || skillLine->skillId != creatureFamily->skillLine[1]))
-                //    continue;
-
-                if (skillLine->skillId != creatureFamily->skillLine[j])
-                    continue;
-
-                if (skillLine->learnOnGetSkill != ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL)
-                    continue;
-
-                SpellEntry const *spell = sSpellStore.LookupEntry(skillLine->spellId);
-                if (!spell) // not exist or triggered or talent
-                    continue;
-
-                if (!spell->spellLevel)
-                    continue;
-
-                PetLevelupSpellSet& spellSet = mPetLevelupSpellMap[creatureFamily->ID];
-                if (spellSet.empty())
-                    ++family_count;
-
-                spellSet.insert(PetLevelupSpellSet::value_type(spell->spellLevel,spell->Id));
-                ++count;
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u pet levelup and default spells for %u families", count, family_count);
-}
-
-bool LoadPetDefaultSpells_helper(CreatureInfo const* cInfo, PetDefaultSpellsEntry& petDefSpells)
-{
-    // skip empty list;
-    bool have_spell = false;
-    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-    {
-        if (petDefSpells.spellid[j])
-        {
-            have_spell = true;
-            break;
-        }
-    }
-    if (!have_spell)
-        return false;
-
-    // remove duplicates with levelupSpells if any
-    if (PetLevelupSpellSet const *levelupSpells = cInfo->family ? sSpellMgr.GetPetLevelupSpellList(cInfo->family) : NULL)
-    {
-        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-        {
-            if (!petDefSpells.spellid[j])
-                continue;
-
-            for (PetLevelupSpellSet::const_iterator itr = levelupSpells->begin(); itr != levelupSpells->end(); ++itr)
-            {
-                if (itr->second == petDefSpells.spellid[j])
-                {
-                    petDefSpells.spellid[j] = 0;
-                    break;
-                }
-            }
-        }
-    }
-
-    // skip empty list;
-    have_spell = false;
-    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-    {
-        if (petDefSpells.spellid[j])
-        {
-            have_spell = true;
-            break;
-        }
-    }
-
-    return have_spell;
-}
-
-void SpellMgr::LoadPetDefaultSpells()
-{
-    mPetDefaultSpellsMap.clear();
-
-    uint32 countCreature = 0;
-    uint32 countData = 0;
-
-    barGoLink bar(sCreatureStorage.MaxEntry + sSpellStore.GetNumRows());
-
-    for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
-    {
-        bar.step();
-
-        CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i);
-        if (!cInfo)
-            continue;
-
-        if (!cInfo->PetSpellDataId)
-            continue;
-
-        // for creature with PetSpellDataId get default pet spells from dbc
-        CreatureSpellDataEntry const* spellDataEntry = sCreatureSpellDataStore.LookupEntry(cInfo->PetSpellDataId);
-        if (!spellDataEntry)
-            continue;
-
-        int32 petSpellsId = -int32(cInfo->PetSpellDataId);
-        PetDefaultSpellsEntry petDefSpells;
-        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-            petDefSpells.spellid[j] = spellDataEntry->spellId[j];
-
-        if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
-        {
-            mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
-            ++countData;
-        }
-    }
-
-    // different summon spells
-    for (uint32 i = 0; i < sSpellStore.GetNumRows(); ++i)
-    {
-        bar.step();
-
-        SpellEntry const* spellEntry = sSpellStore.LookupEntry(i);
-        if (!spellEntry)
-            continue;
-
-        for (uint8 k = 0; k < MAX_SPELL_EFFECTS; ++k)
-        {
-            if (spellEntry->Effect[k] == SPELL_EFFECT_SUMMON || spellEntry->Effect[k] == SPELL_EFFECT_SUMMON_PET)
-            {
-                uint32 creature_id = spellEntry->EffectMiscValue[k];
-                CreatureInfo const *cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(creature_id);
-                if (!cInfo)
-                    continue;
-
-                // already loaded
-                if (cInfo->PetSpellDataId)
-                    continue;
-
-                // for creature without PetSpellDataId get default pet spells from creature_template
-                int32 petSpellsId = cInfo->Entry;
-                if (mPetDefaultSpellsMap.find(cInfo->Entry) != mPetDefaultSpellsMap.end())
-                    continue;
-
-                PetDefaultSpellsEntry petDefSpells;
-                for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
-                    petDefSpells.spellid[j] = cInfo->spells[j];
-
-                if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
-                {
-                    mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
-                    ++countCreature;
-                }
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded addition spells for %u pet spell data entries.", countData);
-    sLog.outString(">> Loaded %u summonable creature templates.", countCreature);
-}
-
-/// Some checks for spells, to prevent adding deprecated/broken spells for trainers, spell book, etc
-bool SpellMgr::IsSpellValid(SpellEntry const *spellInfo, Player *pl, bool msg)
-{
-    // not exist
-    if (!spellInfo)
-        return false;
-
-    bool need_check_reagents = false;
-
-    // check effects
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch (spellInfo->Effect[i])
-        {
-            case 0:
-                continue;
-
-            // craft spell for crafting non-existed item (break client recipes list show)
-            case SPELL_EFFECT_CREATE_ITEM:
-            case SPELL_EFFECT_CREATE_ITEM_2:
-            {
-                if (spellInfo->EffectItemType[i] == 0)
-                {
-                    // skip auto-loot crafting spells, its not need explicit item info (but have special fake items sometime)
-                    if (!IsLootCraftingSpell(spellInfo))
-                    {
-                        if (msg)
-                        {
-                            if (pl)
-                                ChatHandler(pl).PSendSysMessage("Craft spell %u not have create item entry.",spellInfo->Id);
-                            else
-                                sLog.outErrorDb("Craft spell %u not have create item entry.",spellInfo->Id);
-                        }
-                        return false;
-                    }
-
-                }
-                // also possible IsLootCraftingSpell case but fake item must exist anyway
-                else if (!ObjectMgr::GetItemPrototype(spellInfo->EffectItemType[i]))
-                {
-                    if (msg)
-                    {
-                        if (pl)
-                            ChatHandler(pl).PSendSysMessage("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
-                        else
-                            sLog.outErrorDb("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
-                    }
-                    return false;
-                }
-
-                need_check_reagents = true;
-                break;
-            }
-            case SPELL_EFFECT_LEARN_SPELL:
-            {
-                SpellEntry const *spellInfo2 = sSpellStore.LookupEntry(spellInfo->EffectTriggerSpell[i]);
-                if (!IsSpellValid(spellInfo2,pl,msg))
-                {
-                    if (msg)
-                    {
-                        if (pl)
-                            ChatHandler(pl).PSendSysMessage("Spell %u learn to broken spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
-                        else
-                            sLog.outErrorDb("Spell %u learn to invalid spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
-                    }
-                    return false;
-                }
-                break;
-            }
-        }
-    }
-
-    if (need_check_reagents)
-    {
-        for (uint8 j = 0; j < MAX_SPELL_REAGENTS; ++j)
-        {
-            if (spellInfo->Reagent[j] > 0 && !ObjectMgr::GetItemPrototype(spellInfo->Reagent[j]))
-            {
-                if (msg)
-                {
-                    if (pl)
-                        ChatHandler(pl).PSendSysMessage("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
-                    else
-                        sLog.outErrorDb("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
-                }
-                return false;
-            }
-        }
-    }
-
-    return true;
-}
-
-void SpellMgr::LoadSpellAreas()
-{
-    mSpellAreaMap.clear();                                  // need for reload case
-    mSpellAreaForQuestMap.clear();
-    mSpellAreaForActiveQuestMap.clear();
-    mSpellAreaForQuestEndMap.clear();
-    mSpellAreaForAuraMap.clear();
-
-    uint32 count = 0;
-
-    //                                                  0     1         2              3               4           5          6        7       8
-    QueryResult result = WorldDatabase.Query("SELECT spell, area, quest_start, quest_start_active, quest_end, aura_spell, racemask, gender, autocast FROM spell_area");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell area requirements", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 spell = fields[0].GetUInt32();
-        SpellArea spellArea;
-        spellArea.spellId             = spell;
-        spellArea.areaId              = fields[1].GetUInt32();
-        spellArea.questStart          = fields[2].GetUInt32();
-        spellArea.questStartCanActive = fields[3].GetBool();
-        spellArea.questEnd            = fields[4].GetUInt32();
-        spellArea.auraSpell           = fields[5].GetInt32();
-        spellArea.raceMask            = fields[6].GetUInt32();
-        spellArea.gender              = Gender(fields[7].GetUInt8());
-        spellArea.autocast            = fields[8].GetBool();
-
-        if (const SpellEntry* spellInfo = sSpellStore.LookupEntry(spell))
-        {
-            if (spellArea.autocast)
-                const_cast<SpellEntry*>(spellInfo)->Attributes |= SPELL_ATTR_CANT_CANCEL;
-        }
-        else
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` does not exist", spell);
-            continue;
-        }
-
-        {
-            bool ok = true;
-            SpellAreaMapBounds sa_bounds = GetSpellAreaMapBounds(spellArea.spellId);
-            for (SpellAreaMap::const_iterator itr = sa_bounds.first; itr != sa_bounds.second; ++itr)
-            {
-                if (spellArea.spellId != itr->second.spellId)
-                    continue;
-                if (spellArea.areaId != itr->second.areaId)
-                    continue;
-                if (spellArea.questStart != itr->second.questStart)
-                    continue;
-                if (spellArea.auraSpell != itr->second.auraSpell)
-                    continue;
-                if ((spellArea.raceMask & itr->second.raceMask) == 0)
-                    continue;
-                if (spellArea.gender != itr->second.gender)
-                    continue;
-
-                // duplicate by requirements
-                ok =false;
-                break;
-            }
-
-            if (!ok)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` already listed with similar requirements.", spell);
-                continue;
-            }
-        }
-
-        if (spellArea.areaId && !GetAreaEntryByAreaID(spellArea.areaId))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong area (%u) requirement", spell,spellArea.areaId);
-            continue;
-        }
-
-        if (spellArea.questStart && !sObjectMgr.GetQuestTemplate(spellArea.questStart))
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong start quest (%u) requirement", spell,spellArea.questStart);
-            continue;
-        }
-
-        if (spellArea.questEnd)
-        {
-            if (!sObjectMgr.GetQuestTemplate(spellArea.questEnd))
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong end quest (%u) requirement", spell,spellArea.questEnd);
-                continue;
-            }
-
-            if (spellArea.questEnd == spellArea.questStart && !spellArea.questStartCanActive)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have quest (%u) requirement for start and end in same time", spell,spellArea.questEnd);
-                continue;
-            }
-        }
-
-        if (spellArea.auraSpell)
-        {
-            SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(spellArea.auraSpell));
-            if (!spellInfo)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong aura spell (%u) requirement", spell,abs(spellArea.auraSpell));
-                continue;
-            }
-
-            if (uint32(abs(spellArea.auraSpell)) == spellArea.spellId)
-            {
-                sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement for itself", spell,abs(spellArea.auraSpell));
-                continue;
-            }
-
-            // not allow autocast chains by auraSpell field (but allow use as alternative if not present)
-            if (spellArea.autocast && spellArea.auraSpell > 0)
-            {
-                bool chain = false;
-                SpellAreaForAuraMapBounds saBound = GetSpellAreaForAuraMapBounds(spellArea.spellId);
-                for (SpellAreaForAuraMap::const_iterator itr = saBound.first; itr != saBound.second; ++itr)
-                {
-                    if (itr->second->autocast && itr->second->auraSpell > 0)
-                    {
-                        chain = true;
-                        break;
-                    }
-                }
-
-                if (chain)
-                {
-                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
-                    continue;
-                }
-
-                SpellAreaMapBounds saBound2 = GetSpellAreaMapBounds(spellArea.auraSpell);
-                for (SpellAreaMap::const_iterator itr2 = saBound2.first; itr2 != saBound2.second; ++itr2)
-                {
-                    if (itr2->second.autocast && itr2->second.auraSpell > 0)
-                    {
-                        chain = true;
-                        break;
-                    }
-                }
-
-                if (chain)
-                {
-                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
-                    continue;
-                }
-            }
-        }
-
-        if (spellArea.raceMask && (spellArea.raceMask & RACEMASK_ALL_PLAYABLE) == 0)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong race mask (%u) requirement", spell,spellArea.raceMask);
-            continue;
-        }
-
-        if (spellArea.gender != GENDER_NONE && spellArea.gender != GENDER_FEMALE && spellArea.gender != GENDER_MALE)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong gender (%u) requirement", spell, spellArea.gender);
-            continue;
-        }
-
-        SpellArea const* sa = &mSpellAreaMap.insert(SpellAreaMap::value_type(spell,spellArea))->second;
-
-        // for search by current zone/subzone at zone/subzone change
-        if (spellArea.areaId)
-            mSpellAreaForAreaMap.insert(SpellAreaForAreaMap::value_type(spellArea.areaId,sa));
-
-        // for search at quest start/reward
-        if (spellArea.questStart)
-        {
-            if (spellArea.questStartCanActive)
-                mSpellAreaForActiveQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
-            else
-                mSpellAreaForQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
-        }
-
-        // for search at quest start/reward
-        if (spellArea.questEnd)
-            mSpellAreaForQuestEndMap.insert(SpellAreaForQuestMap::value_type(spellArea.questEnd,sa));
-
-        // for search at aura apply
-        if (spellArea.auraSpell)
-            mSpellAreaForAuraMap.insert(SpellAreaForAuraMap::value_type(abs(spellArea.auraSpell),sa));
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell area requirements", count);
-}
-
-SpellCastResult SpellMgr::GetSpellAllowedInLocationError(SpellEntry const *spellInfo, uint32 map_id, uint32 zone_id, uint32 area_id, Player const* player)
-{
-    // normal case
-    if (spellInfo->AreaGroupId > 0)
-    {
-        bool found = false;
-        AreaGroupEntry const* groupEntry = sAreaGroupStore.LookupEntry(spellInfo->AreaGroupId);
-        while (groupEntry)
-        {
-            for (uint8 i = 0; i < MAX_GROUP_AREA_IDS; ++i)
-                if (groupEntry->AreaId[i] == zone_id || groupEntry->AreaId[i] == area_id)
-                    found = true;
-            if (found || !groupEntry->nextGroup)
-                break;
-            // Try search in next group
-            groupEntry = sAreaGroupStore.LookupEntry(groupEntry->nextGroup);
-        }
-
-        if (!found)
-            return SPELL_FAILED_INCORRECT_AREA;
-    }
-
-    // continent limitation (virtual continent)
-    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_CAST_ONLY_IN_OUTLAND)
-    {
-        uint32 v_map = GetVirtualMapForMapAndZone(map_id, zone_id);
-        MapEntry const *mapEntry = sMapStore.LookupEntry(v_map);
-        if (!mapEntry || mapEntry->addon < 1 || !mapEntry->IsContinent())
-            return SPELL_FAILED_INCORRECT_AREA;
-    }
-
-    // raid instance limitation
-    if (spellInfo->AttributesEx6 & SPELL_ATTR_EX6_NOT_IN_RAID_INSTANCE)
-    {
-        MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-        if (!mapEntry || mapEntry->IsRaid())
-            return SPELL_FAILED_NOT_IN_RAID_INSTANCE;
-    }
-
-    // DB base check (if non empty then must fit at least single for allow)
-    SpellAreaMapBounds saBounds = sSpellMgr.GetSpellAreaMapBounds(spellInfo->Id);
-    if (saBounds.first != saBounds.second)
-    {
-        for (SpellAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
-        {
-            if (itr->second.IsFitToRequirements(player,zone_id,area_id))
-                return SPELL_CAST_OK;
-        }
-        return SPELL_FAILED_INCORRECT_AREA;
-    }
-
-    // bg spell checks
-    switch(spellInfo->Id)
-    {
-        case 23333:                                         // Warsong Flag
-        case 23335:                                         // Silverwing Flag
-            return map_id == 489 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        case 34976:                                         // Netherstorm Flag
-            return map_id == 566 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        case 2584:                                          // Waiting to Resurrect
-        case 22011:                                         // Spirit Heal Channel
-        case 22012:                                         // Spirit Heal
-        case 24171:                                         // Resurrection Impact Visual
-        case 42792:                                         // Recently Dropped Flag
-        case 43681:                                         // Inactive
-        case 44535:                                         // Spirit Heal (mana)
-        {
-            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            return zone_id == 4197 || (mapEntry->IsBattleground() && player && player->InBattleground()) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-        case 44521:                                         // Preparation
-        {
-            if (!player)
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            if (!mapEntry->IsBattleground())
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            Battleground* bg = player->GetBattleground();
-            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-        case 32724:                                         // Gold Team (Alliance)
-        case 32725:                                         // Green Team (Alliance)
-        case 35774:                                         // Gold Team (Horde)
-        case 35775:                                         // Green Team (Horde)
-        {
-            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            return mapEntry->IsBattleArena() && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-        case 32727:                                         // Arena Preparation
-        {
-            if (!player)
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
-            if (!mapEntry)
-                return SPELL_FAILED_INCORRECT_AREA;
-
-            if (!mapEntry->IsBattleArena())
-                return SPELL_FAILED_REQUIRES_AREA;
-
-            Battleground *bg = player->GetBattleground();
-            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
-        }
-    }
-
-    // aura limitations
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        switch (spellInfo->EffectApplyAuraName[i])
-        {
-            case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
-            case SPELL_AURA_FLY:
-            {
-                if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
-                    return SPELL_FAILED_INCORRECT_AREA;
-            }
-        }
-    }
-
-    return SPELL_CAST_OK;
-}
-
-void SpellMgr::LoadSkillLineAbilityMap()
-{
-    mSkillLineAbilityMap.clear();
-
-    barGoLink bar(sSkillLineAbilityStore.GetNumRows());
-    uint32 count = 0;
-
-    for (uint32 i = 0; i < sSkillLineAbilityStore.GetNumRows(); ++i)
-    {
-        bar.step();
-        SkillLineAbilityEntry const *SkillInfo = sSkillLineAbilityStore.LookupEntry(i);
-        if (!SkillInfo)
-            continue;
-
-        mSkillLineAbilityMap.insert(SkillLineAbilityMap::value_type(SkillInfo->spellId,SkillInfo));
-        ++count;
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u SkillLineAbility MultiMap Data", count);
-}
-
-DiminishingGroup GetDiminishingReturnsGroupForSpell(SpellEntry const* spellproto, bool triggered)
-{
-    // Explicit Diminishing Groups
-    switch (spellproto->SpellFamilyName)
-    {
-        case SPELLFAMILY_GENERIC:
-            // some generic arena related spells have by some strange reason MECHANIC_TURN
-            if  (spellproto->Mechanic == MECHANIC_TURN)
-                return DIMINISHING_NONE;
-            break;
-        case SPELLFAMILY_MAGE:
-        {
-            // Frostbite
-            if (spellproto->SpellFamilyFlags[1] & 0x80000000)
-                return DIMINISHING_TRIGGER_ROOT;
-            //Shattered Barrier: only flag SpellFamilyFlags[0] = 0x00080000 shared
-            //by most frost spells, using id instead
-            if (spellproto->Id == 55080)
-                return DIMINISHING_TRIGGER_ROOT;
-            // Frost Nova / Freeze (Water Elemental)
-            if (spellproto->SpellIconID == 193)
-                return DIMINISHING_CONTROL_ROOT;
-            break;
-        }
-        case SPELLFAMILY_ROGUE:
-        {
-            // Sap 0x80 Gouge 0x8
-            if (spellproto->SpellFamilyFlags[0] & 0x88)
-                return DIMINISHING_POLYMORPH;
-            // Blind
-            else if (spellproto->SpellFamilyFlags[0] & 0x1000000)
-                return DIMINISHING_FEAR_BLIND;
-            // Cheap Shot
-            else if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return DIMINISHING_CHEAPSHOT_POUNCE;
-            // Crippling poison - Limit to 10 seconds in PvP (No SpellFamilyFlags)
-            else if (spellproto->SpellIconID == 163)
-                return DIMINISHING_LIMITONLY;
-            break;
-        }
-        case SPELLFAMILY_WARLOCK:
-        {
-            // Death Coil
-            if (spellproto->SpellFamilyFlags[0] & 0x80000)
-                return DIMINISHING_DEATHCOIL;
-            // Curses/etc
-            else if (spellproto->SpellFamilyFlags[0] & 0x80000000)
-                return DIMINISHING_LIMITONLY;
-            // Howl of Terror
-            else if (spellproto->SpellFamilyFlags[1] & 0x8)
-                return DIMINISHING_FEAR_BLIND;
-            // Seduction
-            else if (spellproto->SpellFamilyFlags[0] & 0x40000000)
-                return DIMINISHING_FEAR_BLIND;
-            break;
-        }
-        case SPELLFAMILY_DRUID:
-        {
-            // Pounce
-            if (spellproto->SpellFamilyFlags[0] & 0x20000)
-                return DIMINISHING_CHEAPSHOT_POUNCE;
-            // Cyclone
-            else if (spellproto->SpellFamilyFlags[1] & 0x20)
-                return DIMINISHING_CYCLONE;
-            // Entangling Roots: to force natures grasp proc to be control root
-            else if (spellproto->SpellFamilyFlags[0] & 0x00000200)
-                return DIMINISHING_CONTROL_ROOT;
-            // Faerie Fire
-            else if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return DIMINISHING_LIMITONLY;
-            break;
-        }
-        case SPELLFAMILY_WARRIOR:
-        {
-            // Hamstring - limit duration to 10s in PvP
-            if (spellproto->SpellFamilyFlags[0] & 0x2)
-                return DIMINISHING_LIMITONLY;
-            // Intimidating Shout
-            else if (spellproto->SpellFamilyFlags[0] & 0x40000)
-                return DIMINISHING_FEAR_BLIND;
-            // Charge Stun
-            else if (spellproto->SpellFamilyFlags[0] & 0x01000000)
-                return DIMINISHING_NONE;
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Repentance
-            if (spellproto->SpellFamilyFlags[0] & 0x4)
-                return DIMINISHING_POLYMORPH;
-            break;
-        }
-        case SPELLFAMILY_DEATHKNIGHT:
-        {
-            // Hungering Cold (no flags)
-            if (spellproto->SpellIconID == 2797)
-                return DIMINISHING_POLYMORPH;
-            // Mark of Blood
-            else if ((spellproto->SpellFamilyFlags[0] & 0x10000000)
-                && spellproto->SpellIconID == 2285)
-                return DIMINISHING_LIMITONLY;
-            break;
-        }
-        case SPELLFAMILY_HUNTER:
-        {
-            // Hunter's mark
-            if ((spellproto->SpellFamilyFlags[0] & 0x400) && spellproto->SpellIconID == 538)
-                return DIMINISHING_LIMITONLY;
-            // Scatter Shot
-            if ((spellproto->SpellFamilyFlags[0] & 0x40000) && spellproto->SpellIconID == 132)
-                return DIMINISHING_NONE;
-            break;
-        }
-        default:
-            break;
-    }
-
-    // Get by mechanic
-    uint32 mechanic = GetAllSpellMechanicMask(spellproto);
-    if (mechanic == MECHANIC_NONE)          return DIMINISHING_NONE;
-    if (mechanic & ((1<<MECHANIC_STUN) |
-                    (1<<MECHANIC_SHACKLE))) return triggered ? DIMINISHING_TRIGGER_STUN : DIMINISHING_CONTROL_STUN;
-    if (mechanic & ((1<<MECHANIC_SLEEP) |
-                    (1<<MECHANIC_FREEZE))) return DIMINISHING_FREEZE_SLEEP;
-    if (mechanic & (1<<MECHANIC_POLYMORPH)) return DIMINISHING_POLYMORPH;
-    if (mechanic & (1<<MECHANIC_ROOT))      return triggered ? DIMINISHING_TRIGGER_ROOT : DIMINISHING_CONTROL_ROOT;
-    if (mechanic & ((1<<MECHANIC_FEAR) |
-                    (1<<MECHANIC_TURN)))    return DIMINISHING_FEAR_BLIND;
-    if (mechanic & (1<<MECHANIC_CHARM))     return DIMINISHING_CHARM;
-    if (mechanic & (1<<MECHANIC_SILENCE))   return DIMINISHING_SILENCE;
-    if (mechanic & (1<<MECHANIC_DISARM))    return DIMINISHING_DISARM;
-    if (mechanic & (1<<MECHANIC_FREEZE))    return DIMINISHING_FREEZE_SLEEP;
-    if (mechanic & ((1<<MECHANIC_KNOCKOUT) |
-                    (1<<MECHANIC_SAPPED)))  return DIMINISHING_KNOCKOUT;
-    if (mechanic & (1<<MECHANIC_BANISH))    return DIMINISHING_BANISH;
-    if (mechanic & (1<<MECHANIC_HORROR))    return DIMINISHING_DEATHCOIL;
-
-    // Get by effect
-    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-    {
-        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_TAUNT)
-            return DIMINISHING_TAUNT;
-    }
-    return DIMINISHING_NONE;
-}
-
-int32 GetDiminishingReturnsLimitDuration(DiminishingGroup group, SpellEntry const* spellproto)
-{
-    if (!IsDiminishingReturnsGroupDurationLimited(group))
-        return 0;
-
-    // Explicit diminishing duration
-    switch(spellproto->SpellFamilyName)
-    {
-        case SPELLFAMILY_HUNTER:
-        {
-            // Wyvern Sting
-            if (spellproto->SpellFamilyFlags[1] & 0x1000)
-                return 6 * IN_MILLISECONDS;
-            // Hunter's Mark
-            if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return 120 * IN_MILLISECONDS;
-            break;
-        }
-        case SPELLFAMILY_PALADIN:
-        {
-            // Repentance - limit to 6 seconds in PvP
-            if (spellproto->SpellFamilyFlags[0] & 0x4)
-                return 6 * IN_MILLISECONDS;
-            break;
-        }
-        case SPELLFAMILY_DRUID:
-        {
-            // Faerie Fire - limit to 40 seconds in PvP (3.1)
-            if (spellproto->SpellFamilyFlags[0] & 0x400)
-                return 40 * IN_MILLISECONDS;
-            break;
-        }
-        default:
-            break;
-    }
-
-    return 10 * IN_MILLISECONDS;
-}
-
-bool IsDiminishingReturnsGroupDurationLimited(DiminishingGroup group)
-{
-    switch(group)
-    {
-        case DIMINISHING_CONTROL_STUN:
-        case DIMINISHING_TRIGGER_STUN:
-        case DIMINISHING_FREEZE_SLEEP:
-        case DIMINISHING_CONTROL_ROOT:
-        case DIMINISHING_TRIGGER_ROOT:
-        case DIMINISHING_FEAR_BLIND:
-        case DIMINISHING_CHARM:
-        case DIMINISHING_POLYMORPH:
-        case DIMINISHING_KNOCKOUT:
-        case DIMINISHING_CYCLONE:
-        case DIMINISHING_BANISH:
-        case DIMINISHING_LIMITONLY:
-        case DIMINISHING_CHEAPSHOT_POUNCE:
-            return true;
-        default:
-            return false;
-    }
-}
-
-DiminishingLevels GetDiminishingReturnsMaxLevel(DiminishingGroup group)
-{
-    switch(group)
-    {
-        case DIMINISHING_TAUNT:
-            return DIMINISHING_LEVEL_TAUNT_IMMUNE;
-        default:
-            return DIMINISHING_LEVEL_IMMUNE;
-    }
-}
-
-DiminishingReturnsType GetDiminishingReturnsGroupType(DiminishingGroup group)
-{
-    switch(group)
-    {
-        case DIMINISHING_TAUNT:
-        case DIMINISHING_CONTROL_STUN:
-        case DIMINISHING_TRIGGER_STUN:
-        case DIMINISHING_CHEAPSHOT_POUNCE:
-        case DIMINISHING_CYCLONE:
-            return DRTYPE_ALL;
-        case DIMINISHING_FEAR_BLIND:
-        case DIMINISHING_CONTROL_ROOT:
-        case DIMINISHING_TRIGGER_ROOT:
-        case DIMINISHING_CHARM:
-        case DIMINISHING_POLYMORPH:
-        case DIMINISHING_SILENCE:
-        case DIMINISHING_DISARM:
-        case DIMINISHING_DEATHCOIL:
-        case DIMINISHING_FREEZE_SLEEP:
-        case DIMINISHING_BANISH:
-        case DIMINISHING_KNOCKOUT:
-            return DRTYPE_PLAYER;
-        default:
-            break;
-    }
-
-    return DRTYPE_NONE;
-}
-
-bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32 newArea) const
-{
-
-    if (gender != GENDER_NONE)                   // not in expected gender
-        if (!player || gender != player->getGender())
-            return false;
-
-    if (raceMask)                                // not in expected race
-        if (!player || !(raceMask & player->getRaceMask()))
-            return false;
-
-    if (areaId)                                  // not in expected zone
-        if (newZone != areaId && newArea != areaId)
-            return false;
-
-    if (questStart)                              // not in expected required quest state
-        if (!player || ((!questStartCanActive || !player->IsActiveQuest(questStart)) && !player->GetQuestRewardStatus(questStart)))
-            return false;
-
-    if (questEnd)                                // not in expected forbidden quest state
-        if (!player || player->GetQuestRewardStatus(questEnd))
-            return false;
-
-    if (auraSpell)                               // not have expected aura
-        if (!player || (auraSpell > 0 && !player->HasAura(auraSpell)) || (auraSpell < 0 && player->HasAura(-auraSpell)))
-            return false;
-
-    // Extra conditions -- leaving the possibility add extra conditions...
-    switch(spellId)
-    {
-        case 58600: // No fly Zone - Dalaran
-            if (!player)
-                return false;
-
-            AreaTableEntry const* pArea = GetAreaEntryByAreaID(player->GetAreaId());
-            if (!(pArea && pArea->flags & AREA_FLAG_NO_FLY_ZONE))
-                return false;
-            if (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY))
-                return false;
-            break;
-    }
-
-    return true;
-}
-
-//-----------TRINITY-------------
-
-bool SpellMgr::CanAurasStack(SpellEntry const *spellInfo_1, SpellEntry const *spellInfo_2, bool sameCaster) const
-{
-    SpellSpecific spellSpec_1 = GetSpellSpecific(spellInfo_1);
-    SpellSpecific spellSpec_2 = GetSpellSpecific(spellInfo_2);
-    if (spellSpec_1 && spellSpec_2)
-        if (IsSingleFromSpellSpecificPerTarget(spellSpec_1, spellSpec_2)
-            || (sameCaster && IsSingleFromSpellSpecificPerCaster(spellSpec_1, spellSpec_2)))
-            return false;
-
-    SpellGroupStackRule stackRule = CheckSpellGroupStackRules(spellInfo_1->Id, spellInfo_2->Id);
-    if (stackRule)
-    {
-        if (stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE)
-            return false;
-        if (sameCaster && stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE_FROM_SAME_CASTER)
-            return false;
-    }
-
-    if (spellInfo_1->SpellFamilyName != spellInfo_2->SpellFamilyName)
-        return true;
-
-    if (!sameCaster)
-    {
-        if (spellInfo_1->AttributesEx & SPELL_ATTR_EX_STACK_FOR_DIFF_CASTERS
-            || spellInfo_1->AttributesEx3 & SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS)
-            return true;
-
-        // check same periodic auras
-        for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
-        {
-            switch(spellInfo_1->EffectApplyAuraName[i])
-            {
-                // DOT or HOT from different casters will stack
-                case SPELL_AURA_PERIODIC_DAMAGE:
-                case SPELL_AURA_PERIODIC_DUMMY:
-                case SPELL_AURA_PERIODIC_HEAL:
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
-                case SPELL_AURA_PERIODIC_ENERGIZE:
-                case SPELL_AURA_PERIODIC_MANA_LEECH:
-                case SPELL_AURA_PERIODIC_LEECH:
-                case SPELL_AURA_POWER_BURN_MANA:
-                case SPELL_AURA_OBS_MOD_POWER:
-                case SPELL_AURA_OBS_MOD_HEALTH:
-                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
-                    return true;
-                default:
-                    break;
-            }
-        }
-    }
-
-    uint32 spellId_1 = GetLastSpellInChain(spellInfo_1->Id);
-    uint32 spellId_2 = GetLastSpellInChain(spellInfo_2->Id);
-
-    // same spell
-    if (spellId_1 == spellId_2)
-    {
-        // Hack for Incanter's Absorption
-        if (spellId_1 == 44413)
-            return true;
-        // same spell with same caster should not stack
-        return false;
-    }
-
-    return true;
-}
-
-bool CanSpellDispelAura(SpellEntry const * dispelSpell, SpellEntry const * aura)
-{
-    // These auras (like ressurection sickness) can't be dispelled
-    if (aura->Attributes & SPELL_ATTR_NEGATIVE_1)
-        return false;
-
-    // These spells (like Mass Dispel) can dispell all auras
-    if (dispelSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return true;
-
-    // These auras (like Divine Shield) can't be dispelled
-    if (aura->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return false;
-
-    // These auras (Cyclone for example) are not dispelable
-    if (aura->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
-        return false;
-
-    return true;
-}
-
-bool CanSpellPierceImmuneAura(SpellEntry const * pierceSpell, SpellEntry const * aura)
-{
-    // these spells pierce all avalible spells (Resurrection Sickness for example)
-    if (pierceSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
-        return true;
-
-    // these spells (Cyclone for example) can pierce all...
-    if ((pierceSpell->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
-        // ...but not these (Divine shield for example)
-        && !(aura && (aura->Mechanic == MECHANIC_IMMUNE_SHIELD || aura->Mechanic == MECHANIC_INVULNERABILITY)))
-        return true;
-
-    return false;
-}
-
-void SpellMgr::LoadSpellEnchantProcData()
-{
-    mSpellEnchantProcEventMap.clear();                             // need for reload case
-
-    uint32 count = 0;
-
-    //                                                  0         1           2         3
-    QueryResult result = WorldDatabase.Query("SELECT entry, customChance, PPMChance, procEx FROM spell_enchant_proc_data");
-    if (!result)
-    {
-        barGoLink bar(1);
-
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded %u spell enchant proc event conditions", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        uint32 enchantId = fields[0].GetUInt32();
-
-        SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchantId);
-        if (!ench)
-        {
-            sLog.outErrorDb("Enchancment %u listed in `spell_enchant_proc_data` does not exist", enchantId);
-            continue;
-        }
-
-        SpellEnchantProcEntry spe;
-
-        spe.customChance = fields[1].GetUInt32();
-        spe.PPMChance = fields[2].GetFloat();
-        spe.procEx = fields[3].GetUInt32();
-
-        mSpellEnchantProcEventMap[enchantId] = spe;
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u enchant proc data definitions", count);
-}
-
-void SpellMgr::LoadSpellRequired()
-{
-    mSpellsReqSpell.clear();                                   // need for reload case
-    mSpellReq.clear();                                         // need for reload case
-
-    QueryResult result = WorldDatabase.Query("SELECT spell_id, req_spell from spell_required");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded 0 spell required records");
-        sLog.outErrorDb("`spell_required` table is empty!");
-        return;
-    }
-    uint32 rows = 0;
-
-    barGoLink bar(result->GetRowCount());
-    do
-    {
-        bar.step();
-        Field *fields = result->Fetch();
-
-        uint32 spell_id =  fields[0].GetUInt32();
-        uint32 spell_req = fields[1].GetUInt32();
-        // check if chain is made with valid first spell
-        SpellEntry const * spell = sSpellStore.LookupEntry(spell_id);
-        if (!spell)
-        {
-            sLog.outErrorDb("spell_id %u in `spell_required` table is not found in dbcs, skipped", spell_id);
-            continue;
-        }
-        SpellEntry const * req_spell = sSpellStore.LookupEntry(spell_req);
-        if (!req_spell)
-        {
-            sLog.outErrorDb("req_spell %u in `spell_required` table is not found in dbcs, skipped", spell_req);
-            continue;
-        }
-        if (GetFirstSpellInChain(spell_id) == GetFirstSpellInChain(spell_req))
-        {
-            sLog.outErrorDb("req_spell %u and spell_id %u in `spell_required` table are ranks of the same spell, entry not needed, skipped", spell_req, spell_id);
-            continue;
-        }
-        if (IsSpellRequiringSpell(spell_id, spell_req))
-        {
-            sLog.outErrorDb("duplicated entry of req_spell %u and spell_id %u in `spell_required`, skipped", spell_req, spell_id);
-            continue;
-        }
-
-        mSpellReq.insert (std::pair<uint32, uint32>(spell_id, spell_req));
-        mSpellsReqSpell.insert (std::pair<uint32, uint32>(spell_req, spell_id));
-        ++rows;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell required records", rows);
-}
-
-void SpellMgr::LoadSpellRanks()
-{
-    mSpellChains.clear();                                   // need for reload case
-
-    QueryResult result = WorldDatabase.Query("SELECT first_spell_id, spell_id, rank from spell_ranks ORDER BY first_spell_id , rank");
-
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-
-        sLog.outString();
-        sLog.outString(">> Loaded 0 spell rank records");
-        sLog.outErrorDb("`spell_ranks` table is empty!");
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    uint32 rows = 0;
-    bool finished = false;
-
-    do
-    {
-                        // spellid, rank
-        std::list < std::pair < int32, int32 > > rankChain;
-        int32 currentSpell = -1;
-        int32 lastSpell = -1;
-
-        // fill one chain
-        while (currentSpell == lastSpell && !finished)
-        {
-            Field *fields = result->Fetch();
-
-            currentSpell = fields[0].GetUInt32();
-            if (lastSpell == -1)
-                lastSpell = currentSpell;
-            uint32 spell_id = fields[1].GetUInt32();
-            uint32 rank = fields[2].GetUInt32();
-
-            // don't drop the row if we're moving to the next rank
-            if (currentSpell == lastSpell)
-            {
-                bar.step();
-                rankChain.push_back(std::make_pair(spell_id, rank));
-                if (!result->NextRow())
-                    finished = true;
-            }
-            else
-                break;
-        }
-        // check if chain is made with valid first spell
-        SpellEntry const * first = sSpellStore.LookupEntry(lastSpell);
-        if (!first)
-        {
-            sLog.outErrorDb("Spell rank identifier(first_spell_id) %u listed in `spell_ranks` does not exist!", lastSpell);
-            continue;
-        }
-        // check if chain is long enough
-        if (rankChain.size() < 2)
-        {
-            sLog.outErrorDb("There is only 1 spell rank for identifier(first_spell_id) %u in `spell_ranks`, entry is not needed!", lastSpell);
-            continue;
-        }
-        int32 curRank = 0;
-        bool valid = true;
-        // check spells in chain
-        for (std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin() ; itr!= rankChain.end(); ++itr)
-        {
-            SpellEntry const * spell = sSpellStore.LookupEntry(itr->first);
-            if (!spell)
-            {
-                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not exist!", itr->first, itr->second, lastSpell);
-                valid = false;
-                break;
-            }
-            ++curRank;
-            if (itr->second != curRank)
-            {
-                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not have proper rank value(should be %u)!", itr->first, itr->second, lastSpell, curRank);
-                valid = false;
-                break;
-            }
-        }
-        if (!valid)
-            continue;
-        int32 prevRank = 0;
-        // insert the chain
-        std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin();
-        do
-        {
-            ++rows;
-            int32 addedSpell = itr->first;
-            mSpellChains[addedSpell].first = lastSpell;
-            mSpellChains[addedSpell].last = rankChain.back().first;
-            mSpellChains[addedSpell].rank = itr->second;
-            mSpellChains[addedSpell].prev = prevRank;
-            prevRank = addedSpell;
-            ++itr;
-            if (itr == rankChain.end())
-            {
-                mSpellChains[addedSpell].next = 0;
-                break;
-            }
-            else
-                mSpellChains[addedSpell].next = itr->first;
-        }
-        while (true);
-    } while (!finished);
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u spell rank records", rows);
-}
-
-// set data in core for now
-void SpellMgr::LoadSpellCustomAttr()
-{
-    mSpellCustomAttr.resize(GetSpellStore()->GetNumRows());
-
-    barGoLink bar(GetSpellStore()->GetNumRows());
-
-    uint32 count = 0;
-
-    SpellEntry *spellInfo;
-    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
-    {
-        bar.step();
-
-        mSpellCustomAttr[i] = 0;
-        spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
-        if (!spellInfo)
-            continue;
-
-        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            switch (spellInfo->Effect[j])
-            {
-                case SPELL_EFFECT_SCHOOL_DAMAGE:
-                case SPELL_EFFECT_WEAPON_DAMAGE:
-                case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
-                case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
-                case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
-                case SPELL_EFFECT_HEAL:
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_DIRECT_DAMAGE;
-                    count++;
-                    break;
-                case SPELL_EFFECT_CHARGE:
-                case SPELL_EFFECT_CHARGE_DEST:
-                case SPELL_EFFECT_JUMP:
-                case SPELL_EFFECT_JUMP_DEST:
-                case SPELL_EFFECT_LEAP_BACK:
-                    if (!spellInfo->speed && !spellInfo->SpellFamilyName)
-                        spellInfo->speed = SPEED_CHARGE;
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_CHARGE;
-                    count++;
-                    break;
-                case SPELL_EFFECT_PICKPOCKET:
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_PICKPOCKET;
-                    break;
-                case SPELL_EFFECT_TRIGGER_SPELL:
-                    if (IsPositionTarget(spellInfo->EffectImplicitTargetA[j]) ||
-                        spellInfo->Targets & (TARGET_FLAG_SOURCE_LOCATION|TARGET_FLAG_DEST_LOCATION))
-                        spellInfo->Effect[j] = SPELL_EFFECT_TRIGGER_MISSILE;
-                    count++;
-                    break;
-            }
-
-            switch (SpellTargetType[spellInfo->EffectImplicitTargetA[j]])
-            {
-                case TARGET_TYPE_UNIT_TARGET:
-                case TARGET_TYPE_DEST_TARGET:
-                    spellInfo->Targets |= TARGET_FLAG_UNIT;
-                    count++;
-                    break;
-                default:
-                    break;
-            }
-        }
-
-        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            switch (spellInfo->EffectApplyAuraName[j])
-            {
-                case SPELL_AURA_MOD_POSSESS:
-                case SPELL_AURA_MOD_CONFUSE:
-                case SPELL_AURA_MOD_CHARM:
-                case SPELL_AURA_AOE_CHARM:
-                case SPELL_AURA_MOD_FEAR:
-                case SPELL_AURA_MOD_STUN:
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
-                    count++;
-                    break;
-            }
-        }
-
-        if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
-        {
-            if (spellInfo->Mechanic != 0 &&
-                spellInfo->Mechanic != MECHANIC_INFECTED)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if (spellInfo->EffectMechanic[0] != 0 &&
-                     spellInfo->EffectMechanic[0] != MECHANIC_INFECTED &&
-                     spellInfo->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if (spellInfo->EffectMechanic[1] != 0 &&
-                     spellInfo->EffectMechanic[1] != MECHANIC_INFECTED)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if (spellInfo->Effect[0] == SPELL_EFFECT_DISPEL ||
-                     spellInfo->Effect[1] == SPELL_EFFECT_DISPEL ||
-                     spellInfo->Effect[2] == SPELL_EFFECT_DISPEL)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if (spellInfo->Effect[0] == SPELL_EFFECT_STEAL_BENEFICIAL_BUFF ||
-                     spellInfo->Effect[1] == SPELL_EFFECT_STEAL_BENEFICIAL_BUFF ||
-                     spellInfo->Effect[2] == SPELL_EFFECT_STEAL_BENEFICIAL_BUFF)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if (spellInfo->Effect[0] == SPELL_EFFECT_POWER_BURN ||
-                     spellInfo->Effect[1] == SPELL_EFFECT_POWER_BURN ||
-                     spellInfo->Effect[2] == SPELL_EFFECT_POWER_BURN)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if (spellInfo->Effect[0] == SPELL_EFFECT_POWER_DRAIN ||
-                     spellInfo->Effect[1] == SPELL_EFFECT_POWER_DRAIN ||
-                     spellInfo->Effect[2] == SPELL_EFFECT_POWER_DRAIN)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if (spellInfo->EffectApplyAuraName[0] == SPELL_AURA_PERIODIC_MANA_LEECH ||
-                     spellInfo->EffectApplyAuraName[1] == SPELL_AURA_PERIODIC_MANA_LEECH ||
-                     spellInfo->EffectApplyAuraName[2] == SPELL_AURA_PERIODIC_MANA_LEECH)
-            {
-                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                count++;
-            }
-            else if ((spellInfo->Dispel == DISPEL_POISON) ||
-                (spellInfo->Dispel == DISPEL_CURSE) ||
-                (spellInfo->Dispel == DISPEL_DISEASE))
-            {
-                if (spellInfo->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE &&
-                    spellInfo->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE &&
-                    spellInfo->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE &&
-                    spellInfo->EffectApplyAuraName[0] != SPELL_AURA_PERIODIC_DAMAGE &&
-                    spellInfo->EffectApplyAuraName[1] != SPELL_AURA_PERIODIC_DAMAGE &&
-                    spellInfo->EffectApplyAuraName[2] != SPELL_AURA_PERIODIC_DAMAGE)
-                {
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
-                    count++;
-                }
-            }
-        }
-
-        if (!_isPositiveEffect(i, 0, false))
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF0;
-            count++;
-        }
-        if (!_isPositiveEffect(i, 1, false))
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF1;
-            count++;
-        }
-        if (!_isPositiveEffect(i, 2, false))
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF2;
-            count++;
-        }
-
-        if (spellInfo->SpellVisual[0] == 3879)
-        {
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_BACK;
-            count++;
-        }
-
-        if (spellInfo->activeIconID == 2158)  // flight
-        {
-            spellInfo->Attributes |= SPELL_ATTR_PASSIVE;
-            count++;
-        }
-
-        switch(i)
-        {
-        // Bind
-        case 3286:
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_TARGET_ENEMY;
-            spellInfo->EffectImplicitTargetA[1] = TARGET_UNIT_TARGET_ENEMY;
-            count++;
-            break;
-        // Heroism
-        case 32182:
-            spellInfo->excludeCasterAuraSpell = 57723; // Exhaustion
-            count++;
-            break;
-        // Blazing Harpoon
-        case 61588:
-            spellInfo->MaxAffectedTargets = 1;
-            count++;
-            break;
-        // Bloodlust
-        case 2825:
-            spellInfo->excludeCasterAuraSpell = 57724; // Sated
-            count++;
-            break;
-        // Heart of the Crusader
-        case 20335:
-        case 20336:
-        case 20337:
-        // Glyph of Life Tap
-        case 63320:
-        // Entries were not updated after spell effect change, we have to do that manually :/
-            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_CAN_PROC_TRIGGERED;
-            count++;
-            break;
-        case 16007: // Draco-Incarcinatrix 900
-            // was 46, but effect is aura effect
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_NEARBY_ENTRY;
-            spellInfo->EffectImplicitTargetB[0] = TARGET_DST_NEARBY_ENTRY;
-            count++;
-            break;
-        case 26029: // dark glare
-        case 37433: // spout
-        case 43140: case 43215: // flame breath
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_LINE;
-            count++;
-            break;
-        case 24340: case 26558: case 28884:     // Meteor
-        case 36837: case 38903: case 41276:     // Meteor
-        case 57467:                             // Meteor
-        case 26789:                             // Shard of the Fallen Star
-        case 31436:                             // Malevolent Cleave
-        case 35181:                             // Dive Bomb
-        case 40810: case 43267: case 43268:     // Saber Lash
-        case 42384:                             // Brutal Swipe
-        case 45150:                             // Meteor Slash
-        case 64422: case 64688:                 // Sonic Screech
-        case 72373:                             // Shared Suffering
-        case 71904:                             // Chaos Bane
-        case 70492: case 72505:                 // Ooze Eruption
-        case 72624: case 72625:                 // Ooze Eruption
-            // ONLY SPELLS WITH SPELLFAMILY_GENERIC and EFFECT_SCHOOL_DAMAGE
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_SHARE_DAMAGE;
-            count++;
-            break;
-        case 59725:                             // Improved Spell Reflection - aoe aura
-            // Target entry seems to be wrong for this spell :/
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_PARTY_CASTER;
-            spellInfo->EffectRadiusIndex[0] = 45;
-            count++;
-            break;
-        case 27820:                             // Mana Detonation
-        //case 28062: case 39090:                 // Positive/Negative Charge
-        //case 28085: case 39093:
-        case 69782: case 69796:                 // Ooze Flood
-        case 69798: case 69801:                 // Ooze Flood
-        case 69538: case 69553: case 69610:     // Ooze Combine
-	    case 71614:                             // Ice Lock
-
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
-            count++;
-            break;
-        case 44978: case 45001: case 45002:     // Wild Magic
-        case 45004: case 45006: case 45010:     // Wild Magic
-        case 31347: // Doom
-        case 41635: // Prayer of Mending
-        case 44869: // Spectral Blast
-        case 45027: // Revitalize
-        case 45976: // Muru Portal Channel
-        case 39365: // Thundering Storm
-        case 41071: // Raise Dead (HACK)
-        case 52124: // Sky Darkener Assault
-        case 42442: // Vengeance Landing Cannonfire
-        case 45863: // Cosmetic - Incinerate to Random Target
-        case 25425: // Shoot
-        case 45761: // Shoot
-        case 42611: // Shoot
-        case 62374: // Pursued
-            spellInfo->MaxAffectedTargets = 1;
-            count++;
-            break;
-        case 52479: // Gift of the Harvester
-            spellInfo->MaxAffectedTargets = 1;
-            // a trap always has dst = src?
-            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_CASTER;
-            spellInfo->EffectImplicitTargetA[1] = TARGET_DST_CASTER;
-            count++;
-            break;
-        case 41376: // Spite
-        case 39992: // Needle Spine
-        case 29576: // Multi-Shot
-        case 40816: // Saber Lash
-        case 37790: // Spread Shot
-        case 46771: // Flame Sear
-        case 45248: // Shadow Blades
-        case 41303: // Soul Drain
-        case 54172: // Divine Storm (heal)
-        case 29213: // Curse of the Plaguebringer - Noth
-        case 28542: // Life Drain - Sapphiron
-        case 66588: // Flaming Spear
-        case 54171: // Divine Storm
-            spellInfo->MaxAffectedTargets = 3;
-            count++;
-            break;
-        case 38310: // Multi-Shot
-        case 53385: // Divine Storm (Damage)
-            spellInfo->MaxAffectedTargets = 4;
-            count++;
-            break;
-        case 42005: // Bloodboil
-        case 38296: // Spitfire Totem
-        case 37676: // Insidious Whisper
-        case 46008: // Negative Energy
-        case 45641: // Fire Bloom
-        case 55665: // Life Drain - Sapphiron (H)
-        case 28796: // Poison Bolt Volly - Faerlina
-            spellInfo->MaxAffectedTargets = 5;
-            count++;
-            break;
-        case 40827: // Sinful Beam
-        case 40859: // Sinister Beam
-        case 40860: // Vile Beam
-        case 40861: // Wicked Beam
-        case 54835: // Curse of the Plaguebringer - Noth (H)
-        case 54098: // Poison Bolt Volly - Faerlina (H)
-            spellInfo->MaxAffectedTargets = 10;
-            count++;
-            break;
-        case 50312: // Unholy Frenzy
-            spellInfo->MaxAffectedTargets = 15;
-            count++;
-            break;
-        case 38794: case 33711: //Murmur's Touch
-            spellInfo->MaxAffectedTargets = 1;
-            spellInfo->EffectTriggerSpell[0] = 33760;
-            count++;
-            break;
-        case 17941:    // Shadow Trance
-        case 22008:    // Netherwind Focus
-        case 31834:    // Light's Grace
-        case 34754:    // Clearcasting
-        case 34936:    // Backlash
-        case 48108:    // Hot Streak
-        case 51124:    // Killing Machine
-        case 54741:    // Firestarter
-        case 57761:    // Fireball!
-        case 39805:    // Lightning Overload
-        case 64823:    // Item - Druid T8 Balance 4P Bonus
-        case 44401:
-            spellInfo->procCharges = 1;
-            count++;
-            break;
-        case 44544:    // Fingers of Frost
-            spellInfo->EffectSpellClassMask[0] = flag96(685904631, 1151048, 0);
-            count++;
-            break;
-        case 74396:    // Fingers of Frost visual buff
-            spellInfo->procCharges = 2;
-            spellInfo->StackAmount = 0;
-            count++;
-            break;
-			case 53256:
-        case 53259:
-        case 53260:
-            spellInfo->procCharges = 2;
-            count++;
-            break;
-        case 28200:    // Ascendance (Talisman of Ascendance trinket)
-            spellInfo->procCharges = 6;
-            count++;
-            break;
-        case 47201:    // Everlasting Affliction
-        case 47202:
-        case 47203:
-        case 47204:
-        case 47205:
-            // add corruption to affected spells
-            spellInfo->EffectSpellClassMask[1][0] |= 2;
-            count++;
-            break;
-        case 51852:    // The Eye of Acherus (no spawn in phase 2 in db)
-            spellInfo->EffectMiscValue[0] |= 1;
-            count++;
-            break;
-        case 52025:    // Cleansing Totem Effect
-            spellInfo->EffectDieSides[1] = 1;
-            count++;
-            break;
-        case 51904:     // Summon Ghouls On Scarlet Crusade (core does not know the triggered spell is summon spell)
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
-            count++;
-            break;
-        case 29809:     // Desecration Arm - 36 instead of 37 - typo? :/
-            spellInfo->EffectRadiusIndex[0] = 37;
-            count++;
-            break;
-        // Master Shapeshifter: missing stance data for forms other than bear - bear version has correct data
-        // To prevent aura staying on target after talent unlearned
-        case 48420:
-            spellInfo->Stances = 1 << (FORM_CAT - 1);
-            count++;
-            break;
-        case 48421:
-            spellInfo->Stances = 1 << (FORM_MOONKIN - 1);
-            count++;
-            break;
-        case 48422:
-            spellInfo->Stances = 1 << (FORM_TREE - 1);
-            count++;
-            break;
-        case 30421:     // Nether Portal - Perseverence
-            spellInfo->EffectBasePoints[2] += 30000;
-            count++;
-            break;
-        // some dummy spell only has dest, should push caster in this case
-        case 62324: // Throw Passenger
-            spellInfo->Targets |= TARGET_FLAG_UNIT_CASTER;
-            count++;
-            break;
-        case 51735: // Ebon Plague
-        case 51734:
-        case 51726:
-            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS;
-            spellInfo->SpellFamilyFlags[2] = 0x10;
-            count++;
-            break;
-        case 41013:     // Parasitic Shadowfiend Passive
-            spellInfo->EffectApplyAuraName[0] = 4; // proc debuff, and summon infinite fiends
-            count++;
-            break;
-        case 27892:     // To Anchor 1
-        case 27928:     // To Anchor 1
-        case 27935:     // To Anchor 1
-        case 27915:     // Anchor to Skulls
-        case 27931:     // Anchor to Skulls
-        case 27937:     // Anchor to Skulls
-            spellInfo->rangeIndex = 13;
-            count++;
-            break;
-        case 48743: // Death Pact
-            spellInfo->AttributesEx &= ~SPELL_ATTR_EX_CANT_TARGET_SELF;
-            count++;
-            break;
-        // target allys instead of enemies, target A is src_caster, spells with effect like that have ally target
-        // this is the only known exception, probably just wrong data
-        case 29214: // Wrath of the Plaguebringer
-        case 54836: // Wrath of the Plaguebringer
-            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_AREA_ALLY_SRC;
-            spellInfo->EffectImplicitTargetB[1] = TARGET_UNIT_AREA_ALLY_SRC;
-            count++;
-            break;
-        case 31687: // Summon Water Elemental
-            // 322-330 switch - effect changed to dummy, target entry not changed in client:(
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
-            count++;
-            break;
-        case 25771: // Forbearance - wrong mechanic immunity in DBC since 3.0.x
-            spellInfo->EffectMiscValue[0] = MECHANIC_IMMUNE_SHIELD;
-            count++;
-            break;
-        case 64321: // Potent Pheromones
-            // spell should dispel area aura, but doesn't have the attribute
-            // may be db data bug, or blizz may keep reapplying area auras every update with checking immunity
-            // that will be clear if we get more spells with problem like this
-            spellInfo->AttributesEx |= SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY;
-            count++;
-            break;
-        case 69055:     // Saber Lash
-        case 70814:     // Saber Lash
-            spellInfo->EffectRadiusIndex[0] = 8;
-            count++;
-            break;
-        case 69075:     // Bone Storm
-        case 70834:     // Bone Storm
-        case 70835:     // Bone Storm
-        case 70836:     // Bone Storm
-            spellInfo->EffectRadiusIndex[0] = 12;
-            count++;
-            break;
-        case 18500: // Wing Buffet
-        case 33086: // Wild Bite
-        case 49749: // Piercing Blow
-        case 52890: // Penetrating Strike
-        case 53454: // Impale
-        case 59446: // Impale
-        case 62383: // Shatter
-        case 64777: // Machine Gun
-        case 65239: // Machine Gun
-        case 65919: // Impale
-        case 67858: // Impale
-        case 67859: // Impale
-        case 67860: // Impale
-        case 69293: // Wing Buffet
-        case 74439: // Machine Gun
-            mSpellCustomAttr[i] |= SPELL_ATTR_CU_IGNORE_ARMOR;
-            count++;
-            break;
-        // THESE SPELLS ARE WORKING CORRECTLY EVEN WITHOUT THIS HACK
-        // THE ONLY REASON ITS HERE IS THAT CURRENT GRID SYSTEM
-        // DOES NOT ALLOW FAR OBJECT SELECTION (dist > 333)
-        case 70781: // Light's Hammer Teleport
-        case 70856: // Oratory of the Damned Teleport
-        case 70857: // Rampart of Skulls Teleport
-        case 70858: // Deathbringer's Rise Teleport
-        case 70859: // Upper Spire Teleport
-        case 70860: // Frozen Throne Teleport
-        case 70861: // Sindragosa's Lair Teleport
-            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_DB;
-            count++;
-            break;
-        case 63675: // Improved Devouring Plague
-            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_NO_DONE_BONUS;
-            count++;
-            break;
-        case 53241: // Marked for Death (Rank 1)
-        case 53243: // Marked for Death (Rank 2)
-        case 53244: // Marked for Death (Rank 3)
-        case 53245: // Marked for Death (Rank 4)
-        case 53246: // Marked for Death (Rank 5)
-            spellInfo->EffectSpellClassMask[0] = flag96(423937, 276955137, 2049);
-            count++;
-            break;
-			case 70728: // Exploit Weakness
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
-            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_PET;
-            count++;
-            break;
-			// this is here until targetAuraSpell and alike support SpellDifficulty.dbc
-        case 70459: // Ooze Eruption Search Effect
-            spellInfo->targetAuraSpell = 0;
-            count++;
-            break;
-        case 70840: // Devious Minds
-            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
-            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_PET;
-            count++;
-            break;
-        case 71413: // Green Ooze Summon
-        case 71414: // Orange Ooze Summon
-            spellInfo->EffectImplicitTargetA[0] = TARGET_DEST_DEST;
-            count++;
-            break;
-        // THIS IS HERE BECAUSE COOLDOWN ON CREATURE PROCS IS NOT IMPLEMENTED
-        case 71604: // Mutated Strength
-        case 72673: // Mutated Strength
-        case 72674: // Mutated Strength
-        case 72675: // Mutated Strength
-            spellInfo->Effect[1] = 0;
-            count++;
-            break;
-        case 70447: // Volatile Ooze Adhesive
-        case 72836: // Volatile Ooze Adhesive
-        case 72837: // Volatile Ooze Adhesive
-        case 72838: // Volatile Ooze Adhesive
-        case 70672: // Gaseous Bloat
-        case 72455: // Gaseous Bloat
-        case 72832: // Gaseous Bloat
-        case 72833: // Gaseous Bloat
-            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_TARGET_ENEMY;
-            spellInfo->EffectImplicitTargetB[1] = TARGET_UNIT_TARGET_ENEMY;
-            spellInfo->EffectImplicitTargetB[2] = TARGET_UNIT_TARGET_ENEMY;
-            count++;
-            break;
-        case 70911: // Unbound Plague
-        case 72854: // Unbound Plague
-        case 72855: // Unbound Plague
-        case 72856: // Unbound Plague
-            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_TARGET_ENEMY;
-            count++;
-            break;
-			case 71708: // Empowered Flare
-			case 72785: // Empowered Flare
-			case 72786: // Empowered Flare
-			case 72787: // Empowered Flare
-				spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_NO_DONE_BONUS;
-				count++;
-				break;
-        default:
-            break;
-        }
-
-        switch(spellInfo->SpellFamilyName)
-        {
-            case SPELLFAMILY_WARRIOR:
-                // Shout
-                if (spellInfo->SpellFamilyFlags[0] & 0x20000 || spellInfo->SpellFamilyFlags[1] & 0x20)
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
-                else
-                    break;
-                count++;
-                break;
-            case SPELLFAMILY_DRUID:
-                // Starfall Target Selection
-                if (spellInfo->SpellFamilyFlags[2] & 0x100)
-                    spellInfo->MaxAffectedTargets = 2;
-                // Starfall AOE Damage
-                else if (spellInfo->SpellFamilyFlags[2] & 0x800000)
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
-                // Roar
-                else if (spellInfo->SpellFamilyFlags[0] & 0x8)
-                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
-                else
-                    break;
-                count++;
-                break;
-                // Do not allow Deadly throw and Slice and Dice to proc twice
-            case SPELLFAMILY_ROGUE:
-                if (spellInfo->SpellFamilyFlags[1] & 0x1 || spellInfo->SpellFamilyFlags[0] & 0x40000)
-                    spellInfo->AttributesEx4 |= SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST;
-                else
-                    break;
-                count++;
-                break;
-        }
-    }
-
-    SummonPropertiesEntry *properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(121));
-    properties->Type = SUMMON_TYPE_TOTEM;
-    properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(647)); // 52893
-    properties->Type = SUMMON_TYPE_TOTEM;
-
-    CreatureAI::FillAISpellInfo();
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u custom spell attributes", count);
-}
-
-// Fill custom data about enchancments
-void SpellMgr::LoadEnchantCustomAttr()
-{
-    uint32 size = sSpellItemEnchantmentStore.GetNumRows();
-    mEnchantCustomAttr.resize(size);
-
-    barGoLink bar(GetSpellStore()->GetNumRows());
-
-    uint32 count = 0;
-
-    for (uint32 i = 0; i < size; ++i)
-       mEnchantCustomAttr[i] = 0;
-
-    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
-    {
-        bar.step();
-
-        SpellEntry * spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
-        if (!spellInfo)
-            continue;
-
-        // TODO: find a better check
-        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_UNK13) || !(spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT))
-            continue;
-
-        for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
-        {
-            if (spellInfo->Effect[j] == SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY)
-            {
-                uint32 enchId = spellInfo->EffectMiscValue[j];
-                SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchId);
-                if (!ench)
-                    continue;
-                mEnchantCustomAttr[enchId] = true;
-                count++;
-                break;
-            }
-        }
-    }
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u custom enchant attributes", count);
-}
-
-void SpellMgr::LoadSpellLinked()
-{
-    mSpellLinkedMap.clear();    // need for reload case
-    uint32 count = 0;
-
-    //                                                0              1             2
-    QueryResult result = WorldDatabase.Query("SELECT spell_trigger, spell_effect, type FROM spell_linked_spell");
-    if (!result)
-    {
-        barGoLink bar(1);
-        bar.step();
-        sLog.outString();
-        sLog.outString(">> Loaded %u linked spells", count);
-        return;
-    }
-
-    barGoLink bar(result->GetRowCount());
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        bar.step();
-
-        int32 trigger = fields[0].GetInt32();
-        int32 effect =  fields[1].GetInt32();
-        int32 type =    fields[2].GetInt32();
-
-        SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(trigger));
-        if (!spellInfo)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(trigger));
-            continue;
-        }
-        spellInfo = sSpellStore.LookupEntry(abs(effect));
-        if (!spellInfo)
-        {
-            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(effect));
-            continue;
-        }
-
-        if (trigger > 0)
-        {
-            switch(type)
-            {
-                case 0: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_CAST; break;
-                case 1: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_HIT;  break;
-                case 2: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_AURA; break;
-            }
-        }
-        else
-        {
-            mSpellCustomAttr[-trigger] |= SPELL_ATTR_CU_LINK_REMOVE;
-        }
-
-        if (type) //we will find a better way when more types are needed
-        {
-            if (trigger > 0)
-                trigger += SPELL_LINKED_MAX_SPELLS * type;
-            else
-                trigger -= SPELL_LINKED_MAX_SPELLS * type;
-        }
-        mSpellLinkedMap[trigger].push_back(effect);
-
-        ++count;
-    } while (result->NextRow());
-
-    sLog.outString();
-    sLog.outString(">> Loaded %u linked spells", count);
-}
+/*
+ * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
+ *
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "SpellMgr.h"
+#include "ObjectMgr.h"
+#include "SpellAuraDefines.h"
+#include "ProgressBar.h"
+#include "DBCStores.h"
+#include "World.h"
+#include "Chat.h"
+#include "Spell.h"
+#include "BattlegroundMgr.h"
+#include "CreatureAI.h"
+#include "MapManager.h"
+
+bool IsAreaEffectTarget[TOTAL_SPELL_TARGETS];
+SpellEffectTargetTypes EffectTargetType[TOTAL_SPELL_EFFECTS];
+SpellSelectTargetTypes SpellTargetType[TOTAL_SPELL_TARGETS];
+
+SpellMgr::SpellMgr()
+{
+    for (int i = 0; i < TOTAL_SPELL_EFFECTS; ++i)
+    {
+        switch(i)
+        {
+            case SPELL_EFFECT_PERSISTENT_AREA_AURA: //27
+            case SPELL_EFFECT_SUMMON:               //28
+            case SPELL_EFFECT_TRIGGER_MISSILE:      //32
+            case SPELL_EFFECT_TRANS_DOOR:           //50 summon object
+            case SPELL_EFFECT_SUMMON_PET:           //56
+            case SPELL_EFFECT_ADD_FARSIGHT:         //72
+            case SPELL_EFFECT_SUMMON_OBJECT_WILD:   //76
+            //case SPELL_EFFECT_SUMMON_CRITTER:       //97 not 303
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT1:  //104
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT2:  //105
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT3:  //106
+            case SPELL_EFFECT_SUMMON_OBJECT_SLOT4:  //107
+            case SPELL_EFFECT_SUMMON_DEAD_PET:      //109
+            case SPELL_EFFECT_TRIGGER_SPELL_2:      //151 ritual of summon
+                EffectTargetType[i] = SPELL_REQUIRE_DEST;
+                break;
+            case SPELL_EFFECT_PARRY: // 0
+            case SPELL_EFFECT_BLOCK: // 0
+            case SPELL_EFFECT_SKILL: // always with dummy 3 as A
+            //case SPELL_EFFECT_LEARN_SPELL: // 0 may be 5 pet
+            case SPELL_EFFECT_TRADE_SKILL: // 0 or 1
+            case SPELL_EFFECT_PROFICIENCY: // 0
+                EffectTargetType[i] = SPELL_REQUIRE_NONE;
+                break;
+            case SPELL_EFFECT_ENCHANT_ITEM:
+            case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
+            case SPELL_EFFECT_DISENCHANT:
+            //in 243 this is 0, in 309 it is 1
+            //so both item target and unit target is pushed, and cause crash
+            //case SPELL_EFFECT_FEED_PET:
+            case SPELL_EFFECT_PROSPECTING:
+            case SPELL_EFFECT_MILLING:
+            case SPELL_EFFECT_ENCHANT_ITEM_PRISMATIC:
+                EffectTargetType[i] = SPELL_REQUIRE_ITEM;
+                break;
+            //caster must be pushed otherwise no sound
+            case SPELL_EFFECT_APPLY_AREA_AURA_PARTY:
+            case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
+            case SPELL_EFFECT_APPLY_AREA_AURA_ENEMY:
+            case SPELL_EFFECT_APPLY_AREA_AURA_PET:
+            case SPELL_EFFECT_APPLY_AREA_AURA_OWNER:
+            case SPELL_EFFECT_APPLY_AREA_AURA_RAID:
+            case SPELL_EFFECT_CHARGE:
+            case SPELL_EFFECT_CHARGE_DEST:
+            case SPELL_EFFECT_JUMP:
+            case SPELL_EFFECT_JUMP_DEST:
+            case SPELL_EFFECT_LEAP_BACK:
+                EffectTargetType[i] = SPELL_REQUIRE_CASTER;
+                break;
+            //case SPELL_EFFECT_WMO_DAMAGE:
+            //case SPELL_EFFECT_WMO_REPAIR:
+            //case SPELL_EFFECT_WMO_CHANGE:
+            //    EffectTargetType[i] = SPELL_REQUIRE_GOBJECT;
+            //    break;
+            default:
+                EffectTargetType[i] = SPELL_REQUIRE_UNIT;
+                break;
+        }
+    }
+
+    for (int i = 0; i < TOTAL_SPELL_TARGETS; ++i)
+    {
+        switch(i)
+        {
+            case TARGET_UNIT_CASTER:
+            case TARGET_UNIT_CASTER_FISHING:
+            case TARGET_UNIT_MASTER:
+            case TARGET_UNIT_PET:
+            case TARGET_UNIT_PARTY_CASTER:
+            case TARGET_UNIT_RAID_CASTER:
+            case TARGET_UNIT_VEHICLE:
+            case TARGET_UNIT_PASSENGER_0:
+            case TARGET_UNIT_PASSENGER_1:
+            case TARGET_UNIT_PASSENGER_2:
+            case TARGET_UNIT_PASSENGER_3:
+            case TARGET_UNIT_PASSENGER_4:
+            case TARGET_UNIT_PASSENGER_5:
+            case TARGET_UNIT_PASSENGER_6:
+            case TARGET_UNIT_PASSENGER_7:
+            case TARGET_UNIT_SUMMONER:
+                SpellTargetType[i] = TARGET_TYPE_UNIT_CASTER;
+                break;
+            case TARGET_UNIT_TARGET_PUPPET:
+            case TARGET_UNIT_TARGET_ALLY:
+            case TARGET_UNIT_TARGET_RAID:
+            case TARGET_UNIT_TARGET_ANY:
+            case TARGET_UNIT_TARGET_ENEMY:
+            case TARGET_UNIT_TARGET_PARTY:
+            case TARGET_UNIT_PARTY_TARGET:
+            case TARGET_UNIT_CLASS_TARGET:
+            case TARGET_UNIT_CHAINHEAL:
+                SpellTargetType[i] = TARGET_TYPE_UNIT_TARGET;
+                break;
+            case TARGET_UNIT_NEARBY_ENEMY:
+            case TARGET_UNIT_NEARBY_ALLY:
+            case TARGET_UNIT_NEARBY_ALLY_UNK:
+            case TARGET_UNIT_NEARBY_ENTRY:
+            case TARGET_UNIT_NEARBY_RAID:
+            case TARGET_GAMEOBJECT_NEARBY_ENTRY:
+                SpellTargetType[i] = TARGET_TYPE_UNIT_NEARBY;
+                break;
+            case TARGET_UNIT_AREA_ENEMY_SRC:
+            case TARGET_UNIT_AREA_ALLY_SRC:
+            case TARGET_UNIT_AREA_ENTRY_SRC:
+            case TARGET_UNIT_AREA_PARTY_SRC:
+            case TARGET_GAMEOBJECT_AREA_SRC:
+                SpellTargetType[i] = TARGET_TYPE_AREA_SRC;
+                break;
+            case TARGET_UNIT_AREA_ENEMY_DST:
+            case TARGET_UNIT_AREA_ALLY_DST:
+            case TARGET_UNIT_AREA_ENTRY_DST:
+            case TARGET_UNIT_AREA_PARTY_DST:
+            case TARGET_GAMEOBJECT_AREA_DST:
+                SpellTargetType[i] = TARGET_TYPE_AREA_DST;
+                break;
+            case TARGET_UNIT_CONE_ENEMY:
+            case TARGET_UNIT_CONE_ALLY:
+            case TARGET_UNIT_CONE_ENTRY:
+            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
+            case TARGET_UNIT_AREA_PATH:
+            case TARGET_GAMEOBJECT_AREA_PATH:
+                SpellTargetType[i] = TARGET_TYPE_AREA_CONE;
+                break;
+            case TARGET_DST_CASTER:
+            case TARGET_SRC_CASTER:
+            case TARGET_MINION:
+            case TARGET_DEST_CASTER_FRONT_LEAP:
+            case TARGET_DEST_CASTER_FRONT:
+            case TARGET_DEST_CASTER_BACK:
+            case TARGET_DEST_CASTER_RIGHT:
+            case TARGET_DEST_CASTER_LEFT:
+            case TARGET_DEST_CASTER_FRONT_LEFT:
+            case TARGET_DEST_CASTER_BACK_LEFT:
+            case TARGET_DEST_CASTER_BACK_RIGHT:
+            case TARGET_DEST_CASTER_FRONT_RIGHT:
+            case TARGET_DEST_CASTER_RANDOM:
+            case TARGET_DEST_CASTER_RADIUS:
+                SpellTargetType[i] = TARGET_TYPE_DEST_CASTER;
+                break;
+            case TARGET_DST_TARGET_ENEMY:
+            case TARGET_DEST_TARGET_ANY:
+            case TARGET_DEST_TARGET_FRONT:
+            case TARGET_DEST_TARGET_BACK:
+            case TARGET_DEST_TARGET_RIGHT:
+            case TARGET_DEST_TARGET_LEFT:
+            case TARGET_DEST_TARGET_FRONT_LEFT:
+            case TARGET_DEST_TARGET_BACK_LEFT:
+            case TARGET_DEST_TARGET_BACK_RIGHT:
+            case TARGET_DEST_TARGET_FRONT_RIGHT:
+            case TARGET_DEST_TARGET_RANDOM:
+            case TARGET_DEST_TARGET_RADIUS:
+                SpellTargetType[i] = TARGET_TYPE_DEST_TARGET;
+                break;
+            case TARGET_DEST_DYNOBJ_ENEMY:
+            case TARGET_DEST_DYNOBJ_ALLY:
+            case TARGET_DEST_DYNOBJ_NONE:
+            case TARGET_DEST_DEST:
+            case TARGET_DEST_TRAJ:
+            case TARGET_DEST_DEST_FRONT_LEFT:
+            case TARGET_DEST_DEST_BACK_LEFT:
+            case TARGET_DEST_DEST_BACK_RIGHT:
+            case TARGET_DEST_DEST_FRONT_RIGHT:
+            case TARGET_DEST_DEST_FRONT:
+            case TARGET_DEST_DEST_BACK:
+            case TARGET_DEST_DEST_RIGHT:
+            case TARGET_DEST_DEST_LEFT:
+            case TARGET_DEST_DEST_RANDOM:
+            case TARGET_DEST_DEST_RANDOM_DIR_DIST:
+                SpellTargetType[i] = TARGET_TYPE_DEST_DEST;
+                break;
+            case TARGET_DST_DB:
+            case TARGET_DST_HOME:
+            case TARGET_DST_NEARBY_ENTRY:
+                SpellTargetType[i] = TARGET_TYPE_DEST_SPECIAL;
+                break;
+            case TARGET_UNIT_CHANNEL_TARGET:
+            case TARGET_DEST_CHANNEL_TARGET:
+            case TARGET_DEST_CHANNEL_CASTER:
+                SpellTargetType[i] = TARGET_TYPE_CHANNEL;
+                break;
+            default:
+                SpellTargetType[i] = TARGET_TYPE_DEFAULT;
+        }
+    }
+
+    for (int32 i = 0; i < TOTAL_SPELL_TARGETS; ++i)
+    {
+        switch(i)
+        {
+            case TARGET_UNIT_AREA_ENEMY_DST:
+            case TARGET_UNIT_AREA_ENEMY_SRC:
+            case TARGET_UNIT_AREA_ALLY_DST:
+            case TARGET_UNIT_AREA_ALLY_SRC:
+            case TARGET_UNIT_AREA_ENTRY_DST:
+            case TARGET_UNIT_AREA_ENTRY_SRC:
+            case TARGET_UNIT_AREA_PARTY_DST:
+            case TARGET_UNIT_AREA_PARTY_SRC:
+            case TARGET_UNIT_PARTY_TARGET:
+            case TARGET_UNIT_PARTY_CASTER:
+            case TARGET_UNIT_CONE_ENEMY:
+            case TARGET_UNIT_CONE_ALLY:
+            case TARGET_UNIT_CONE_ENEMY_UNKNOWN:
+            case TARGET_UNIT_AREA_PATH:
+            case TARGET_GAMEOBJECT_AREA_PATH:
+            case TARGET_UNIT_RAID_CASTER:
+                IsAreaEffectTarget[i] = true;
+                break;
+            default:
+                IsAreaEffectTarget[i] = false;
+                break;
+        }
+    }
+}
+
+SpellMgr::~SpellMgr()
+{
+}
+
+SpellMgr& SpellMgr::Instance()
+{
+    static SpellMgr spellMgr;
+    return spellMgr;
+}
+
+bool SpellMgr::IsSrcTargetSpell(SpellEntry const *spellInfo) const
+{
+    for (uint8 i = 0; i< MAX_SPELL_EFFECTS; ++i)
+    {
+        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_AREA_SRC || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_AREA_SRC)
+            return true;
+    }
+    return false;
+}
+
+int32 GetSpellDuration(SpellEntry const *spellInfo)
+{
+    if (!spellInfo)
+        return 0;
+    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
+    if (!du)
+        return 0;
+    return (du->Duration[0] == -1) ? -1 : abs(du->Duration[0]);
+}
+
+int32 GetSpellMaxDuration(SpellEntry const *spellInfo)
+{
+    if (!spellInfo)
+        return 0;
+    SpellDurationEntry const *du = sSpellDurationStore.LookupEntry(spellInfo->DurationIndex);
+    if (!du)
+        return 0;
+    return (du->Duration[2] == -1) ? -1 : abs(du->Duration[2]);
+}
+
+uint32 GetDispelChance(Unit* auraCaster, Unit* target, uint32 spellId, bool offensive, bool *result)
+{
+    // we assume that aura dispel chance is 100% on start
+    // need formula for level difference based chance
+    int32 resist_chance = 0;
+
+    // Apply dispel mod from aura caster
+    if (auraCaster)
+        if (Player* modOwner = auraCaster->GetSpellModOwner())
+            modOwner->ApplySpellMod(spellId, SPELLMOD_RESIST_DISPEL_CHANCE, resist_chance);
+
+    // Dispel resistance from target SPELL_AURA_MOD_DISPEL_RESIST
+    // Only affects offensive dispels
+    if (offensive && target)
+        resist_chance += target->GetTotalAuraModifier(SPELL_AURA_MOD_DISPEL_RESIST);
+
+    // Try dispel
+    if (result)
+        *result = !roll_chance_i(resist_chance);
+
+    resist_chance = resist_chance < 0 ? 0 : resist_chance;
+    resist_chance = resist_chance > 100 ? 100 : resist_chance;
+    return 100 - resist_chance;
+}
+
+uint32 GetSpellCastTime(SpellEntry const* spellInfo, Spell * spell)
+{
+    SpellCastTimesEntry const *spellCastTimeEntry = sSpellCastTimesStore.LookupEntry(spellInfo->CastingTimeIndex);
+
+    // not all spells have cast time index and this is all is pasiive abilities
+    if (!spellCastTimeEntry)
+        return 0;
+
+    int32 castTime = spellCastTimeEntry->CastTime;
+
+    if (spell && spell->GetCaster())
+        spell->GetCaster()->ModSpellCastTime(spellInfo, castTime, spell);
+
+    if (spellInfo->Attributes & SPELL_ATTR_REQ_AMMO && (!spell || !(spell->IsAutoRepeat())))
+        castTime += 500;
+
+    return (castTime > 0) ? uint32(castTime) : 0;
+}
+
+bool IsPassiveSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+    return IsPassiveSpell(spellInfo);
+}
+
+bool IsPassiveSpell(SpellEntry const * spellInfo)
+{
+    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
+        return true;
+    return false;
+}
+
+bool IsAutocastableSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+    if (spellInfo->Attributes & SPELL_ATTR_PASSIVE)
+        return false;
+    if (spellInfo->AttributesEx & SPELL_ATTR_EX_UNAUTOCASTABLE_BY_PET)
+        return false;
+    return true;
+}
+
+bool IsHigherHankOfSpell(uint32 spellId_1, uint32 spellId_2)
+{
+    return sSpellMgr.GetSpellRank(spellId_1)<sSpellMgr.GetSpellRank(spellId_2);
+}
+
+uint32 CalculatePowerCost(SpellEntry const * spellInfo, Unit const * caster, SpellSchoolMask schoolMask)
+{
+    // Spell drain all exist power on cast (Only paladin lay of Hands)
+    if (spellInfo->AttributesEx & SPELL_ATTR_EX_DRAIN_ALL_POWER)
+    {
+        // If power type - health drain all
+        if (spellInfo->powerType == POWER_HEALTH)
+            return caster->GetHealth();
+        // Else drain all power
+        if (spellInfo->powerType < MAX_POWERS)
+            return caster->GetPower(Powers(spellInfo->powerType));
+        sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
+        return 0;
+    }
+
+    // Base powerCost
+    int32 powerCost = spellInfo->manaCost;
+    // PCT cost from total amount
+    if (spellInfo->ManaCostPercentage)
+    {
+        switch (spellInfo->powerType)
+        {
+            // health as power used
+            case POWER_HEALTH:
+                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateHealth() / 100;
+                break;
+            case POWER_MANA:
+                powerCost += spellInfo->ManaCostPercentage * caster->GetCreateMana() / 100;
+                break;
+            case POWER_RAGE:
+            case POWER_FOCUS:
+            case POWER_ENERGY:
+            case POWER_HAPPINESS:
+                powerCost += spellInfo->ManaCostPercentage * caster->GetMaxPower(Powers(spellInfo->powerType)) / 100;
+                break;
+            case POWER_RUNE:
+            case POWER_RUNIC_POWER:
+                sLog.outDebug("CalculateManaCost: Not implemented yet!");
+                break;
+            default:
+                sLog.outError("CalculateManaCost: Unknown power type '%d' in spell %d", spellInfo->powerType, spellInfo->Id);
+                return 0;
+        }
+    }
+    SpellSchools school = GetFirstSchoolInMask(schoolMask);
+    // Flat mod from caster auras by spell school
+    powerCost += caster->GetInt32Value(UNIT_FIELD_POWER_COST_MODIFIER + school);
+    // Shiv - costs 20 + weaponSpeed*10 energy (apply only to non-triggered spell with energy cost)
+    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_SPELL_VS_EXTEND_COST)
+        powerCost += caster->GetAttackTime(OFF_ATTACK)/100;
+    // Apply cost mod by spell
+    if (Player * modOwner = caster->GetSpellModOwner())
+        modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_COST, powerCost);
+
+    if (spellInfo->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION)
+        powerCost = int32(powerCost/ (1.117f* spellInfo->spellLevel / caster->getLevel() -0.1327f));
+
+    // PCT mod from user auras by school
+    powerCost = int32(powerCost * (1.0f+caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+school)));
+    if (powerCost < 0)
+        powerCost = 0;
+    return powerCost;
+}
+
+Unit* GetTriggeredSpellCaster(SpellEntry const * spellInfo, Unit * caster, Unit * target)
+{
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_UNIT_TARGET
+            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_UNIT_TARGET
+            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_CHANNEL
+            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_CHANNEL
+            || SpellTargetType[spellInfo->EffectImplicitTargetA[i]] == TARGET_TYPE_DEST_TARGET
+            || SpellTargetType[spellInfo->EffectImplicitTargetB[i]] == TARGET_TYPE_DEST_TARGET)
+            return caster;
+    }
+    return target;
+}
+
+AuraState GetSpellAuraState(SpellEntry const * spellInfo)
+{
+    // Seals
+    if (IsSealSpell(spellInfo))
+        return AURA_STATE_JUDGEMENT;
+
+    // Conflagrate aura state on Immolate and Shadowflame
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+        // Immolate
+        ((spellInfo->SpellFamilyFlags[0] & 4) ||
+        // Shadowflame
+        (spellInfo->SpellFamilyFlags[2] & 2)))
+        return AURA_STATE_CONFLAGRATE;
+
+    // Faerie Fire (druid versions)
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x400)
+        return AURA_STATE_FAERIE_FIRE;
+
+    // Sting (hunter's pet ability)
+    if (spellInfo->Category == 1133)
+        return AURA_STATE_FAERIE_FIRE;
+
+    // Victorious
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_WARRIOR &&  spellInfo->SpellFamilyFlags[1] & 0x00040000)
+        return AURA_STATE_WARRIOR_VICTORY_RUSH;
+
+    // Swiftmend state on Regrowth & Rejuvenation
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_DRUID && spellInfo->SpellFamilyFlags[0] & 0x50)
+        return AURA_STATE_SWIFTMEND;
+
+    // Deadly poison aura state
+    if (spellInfo->SpellFamilyName == SPELLFAMILY_ROGUE && spellInfo->SpellFamilyFlags[0] & 0x10000)
+        return AURA_STATE_DEADLY_POISON;
+
+    // Enrage aura state
+    if (spellInfo->Dispel == DISPEL_ENRAGE)
+        return AURA_STATE_ENRAGE;
+
+    // Bleeding aura state
+    if (GetAllSpellMechanicMask(spellInfo) & 1<<MECHANIC_BLEED)
+        return AURA_STATE_BLEEDING;
+
+    if (GetSpellSchoolMask(spellInfo) & SPELL_SCHOOL_MASK_FROST)
+    {
+        for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_STUN
+                || spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT)
+                return AURA_STATE_FROZEN;
+        }
+    }
+    return AURA_STATE_NONE;
+}
+
+SpellSpecific GetSpellSpecific(SpellEntry const * spellInfo)
+{
+    switch(spellInfo->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+        {
+            // Food / Drinks (mostly)
+            if (spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
+            {
+                bool food = false;
+                bool drink = false;
+                for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch(spellInfo->EffectApplyAuraName[i])
+                    {
+                        // Food
+                        case SPELL_AURA_MOD_REGEN:
+                        case SPELL_AURA_OBS_MOD_HEALTH:
+                            food = true;
+                            break;
+                        // Drink
+                        case SPELL_AURA_MOD_POWER_REGEN:
+                        case SPELL_AURA_OBS_MOD_POWER:
+                            drink = true;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+
+                if (food && drink)
+                    return SPELL_SPECIFIC_FOOD_AND_DRINK;
+                else if (food)
+                    return SPELL_SPECIFIC_FOOD;
+                else if (drink)
+                    return SPELL_SPECIFIC_DRINK;
+            }
+            // scrolls effects
+            else
+            {
+                uint32 firstSpell = sSpellMgr.GetFirstSpellInChain(spellInfo->Id);
+                switch (firstSpell)
+                {
+                    case 8118: // Strength
+                    case 8099: // Stamina
+                    case 8112: // Spirit
+                    case 8096: // Intellect
+                    case 8115: // Agility
+                    case 8091: // Armor
+                        return SPELL_SPECIFIC_SCROLL;
+                    case 12880: // Enrage (Enrage)
+                    case 57518: // Enrage (Wrecking Crew)
+                        return SPELL_SPECIFIC_WARRIOR_ENRAGE;
+                }
+            }
+            break;
+        }
+        case SPELLFAMILY_MAGE:
+        {
+            // family flags 18(Molten), 25(Frost/Ice), 28(Mage)
+            if (spellInfo->SpellFamilyFlags[0] & 0x12040000)
+                return SPELL_SPECIFIC_MAGE_ARMOR;
+
+            // Arcane brillance and Arcane intelect (normal check fails because of flags difference)
+            if (spellInfo->SpellFamilyFlags[0] & 0x400)
+                return SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE;
+
+            if ((spellInfo->SpellFamilyFlags[0] & 0x1000000) && spellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOD_CONFUSE)
+                return SPELL_SPECIFIC_MAGE_POLYMORPH;
+
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            if (spellInfo->Id == 12292) // Death Wish
+                return SPELL_SPECIFIC_WARRIOR_ENRAGE;
+
+            break;
+        }
+        case SPELLFAMILY_WARLOCK:
+        {
+            // only warlock curses have this
+            if (spellInfo->Dispel == DISPEL_CURSE)
+                return SPELL_SPECIFIC_CURSE;
+
+            // Warlock (Demon Armor | Demon Skin | Fel Armor)
+            if (spellInfo->SpellFamilyFlags[1] & 0x20000020 || spellInfo->SpellFamilyFlags[2] & 0x00000010)
+                return SPELL_SPECIFIC_WARLOCK_ARMOR;
+
+            //seed of corruption and corruption
+            if (spellInfo->SpellFamilyFlags[1] & 0x10 || spellInfo->SpellFamilyFlags[0] & 0x2)
+                return SPELL_SPECIFIC_WARLOCK_CORRUPTION;
+            break;
+        }
+        case SPELLFAMILY_PRIEST:
+        {
+            // Divine Spirit and Prayer of Spirit
+            if (spellInfo->SpellFamilyFlags[0] & 0x20)
+                return SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT;
+
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // only hunter stings have this
+            if (spellInfo->Dispel == DISPEL_POISON)
+                return SPELL_SPECIFIC_STING;
+
+            // only hunter aspects have this (but not all aspects in hunter family)
+            if (spellInfo->SpellFamilyFlags.HasFlag(0x00380000, 0x00440000, 0x00001010))
+                return SPELL_SPECIFIC_ASPECT;
+
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            if (IsSealSpell(spellInfo))
+                return SPELL_SPECIFIC_SEAL;
+
+            if (spellInfo->SpellFamilyFlags[0] & 0x00002190)
+                return SPELL_SPECIFIC_HAND;
+
+            // Judgement of Wisdom, Judgement of Light, Judgement of Justice
+            if (spellInfo->Id == 20184 || spellInfo->Id == 20185 || spellInfo->Id == 20186)
+                return SPELL_SPECIFIC_JUDGEMENT;
+
+            // only paladin auras have this (for palaldin class family)
+            if (spellInfo->SpellFamilyFlags[2] & 0x00000020)
+                return SPELL_SPECIFIC_AURA;
+
+            break;
+        }
+        case SPELLFAMILY_SHAMAN:
+        {
+            if (IsElementalShield(spellInfo))
+                return SPELL_SPECIFIC_ELEMENTAL_SHIELD;
+
+            break;
+        }
+
+        case SPELLFAMILY_DEATHKNIGHT:
+            if (spellInfo->Id == 48266 || spellInfo->Id == 48263 || spellInfo->Id == 48265)
+            //if (spellInfo->Category == 47)
+                return SPELL_SPECIFIC_PRESENCE;
+            break;
+    }
+
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA)
+        {
+            switch(spellInfo->EffectApplyAuraName[i])
+            {
+                case SPELL_AURA_MOD_CHARM:
+                case SPELL_AURA_MOD_POSSESS_PET:
+                case SPELL_AURA_MOD_POSSESS:
+                case SPELL_AURA_AOE_CHARM:
+                    return SPELL_SPECIFIC_CHARM;
+                case SPELL_AURA_TRACK_CREATURES:
+                case SPELL_AURA_TRACK_RESOURCES:
+                case SPELL_AURA_TRACK_STEALTHED:
+                    return SPELL_SPECIFIC_TRACKER;
+                case SPELL_AURA_PHASE:
+                    return SPELL_SPECIFIC_PHASE;
+            }
+        }
+    }
+
+    return SPELL_SPECIFIC_NORMAL;
+}
+
+// target not allow have more one spell specific from same caster
+bool IsSingleFromSpellSpecificPerCaster(SpellSpecific spellSpec1,SpellSpecific spellSpec2)
+{
+    switch(spellSpec1)
+    {
+        case SPELL_SPECIFIC_SEAL:
+        case SPELL_SPECIFIC_HAND:
+        case SPELL_SPECIFIC_AURA:
+        case SPELL_SPECIFIC_STING:
+        case SPELL_SPECIFIC_CURSE:
+        case SPELL_SPECIFIC_ASPECT:
+        case SPELL_SPECIFIC_JUDGEMENT:
+        case SPELL_SPECIFIC_WARLOCK_CORRUPTION:
+            return spellSpec1 == spellSpec2;
+        default:
+            return false;
+    }
+}
+
+bool IsSingleFromSpellSpecificPerTarget(SpellSpecific spellSpec1, SpellSpecific spellSpec2)
+{
+    switch(spellSpec1)
+    {
+        case SPELL_SPECIFIC_PHASE:
+        case SPELL_SPECIFIC_TRACKER:
+        case SPELL_SPECIFIC_WARLOCK_ARMOR:
+        case SPELL_SPECIFIC_MAGE_ARMOR:
+        case SPELL_SPECIFIC_ELEMENTAL_SHIELD:
+        case SPELL_SPECIFIC_MAGE_POLYMORPH:
+        case SPELL_SPECIFIC_PRESENCE:
+        case SPELL_SPECIFIC_CHARM:
+        case SPELL_SPECIFIC_SCROLL:
+        case SPELL_SPECIFIC_WARRIOR_ENRAGE:
+        case SPELL_SPECIFIC_MAGE_ARCANE_BRILLANCE:
+        case SPELL_SPECIFIC_PRIEST_DIVINE_SPIRIT:
+            return spellSpec1 == spellSpec2;
+        case SPELL_SPECIFIC_FOOD:
+            return spellSpec2 == SPELL_SPECIFIC_FOOD
+                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
+        case SPELL_SPECIFIC_DRINK:
+            return spellSpec2 == SPELL_SPECIFIC_DRINK
+                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
+        case SPELL_SPECIFIC_FOOD_AND_DRINK:
+            return spellSpec2 == SPELL_SPECIFIC_FOOD
+                || spellSpec2 == SPELL_SPECIFIC_DRINK
+                || spellSpec2 == SPELL_SPECIFIC_FOOD_AND_DRINK;
+        default:
+            return false;
+    }
+}
+
+bool IsPositiveTarget(uint32 targetA, uint32 targetB)
+{
+    // non-positive targets
+    switch(targetA)
+    {
+        case TARGET_UNIT_NEARBY_ENEMY:
+        case TARGET_UNIT_TARGET_ENEMY:
+        case TARGET_UNIT_AREA_ENEMY_SRC:
+        case TARGET_UNIT_AREA_ENEMY_DST:
+        case TARGET_UNIT_CONE_ENEMY:
+        case TARGET_DEST_DYNOBJ_ENEMY:
+        case TARGET_DST_TARGET_ENEMY:
+            return false;
+        default:
+            break;
+    }
+    if (targetB)
+        return IsPositiveTarget(targetB, 0);
+    return true;
+}
+
+bool SpellMgr::_isPositiveEffect(uint32 spellId, uint32 effIndex, bool deep) const
+{
+    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
+    if (!spellproto) return false;
+
+    // not found a single positive spell with this attribute
+    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1)
+        return false;
+
+    switch (spellproto->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+            switch (spellId)
+            {
+                case 34700: // Allergic Reaction
+                case 61987: // Avenging Wrath Marker
+                case 61988: // Divine Shield exclude aura
+                    return false;
+                case 30877: // Tag Murloc
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case SPELLFAMILY_MAGE:
+            // Amplify Magic, Dampen Magic
+            if (spellproto->SpellFamilyFlags[0] == 0x00002000)
+                return true;
+            break;
+        case SPELLFAMILY_PRIEST:
+            switch (spellId)
+            {
+                case 64844: // Divine Hymn
+                case 64904: // Hymn of Hope
+                case 47585: // Dispersion
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case SPELLFAMILY_HUNTER:
+            // Aspect of the Viper
+            if (spellId == 34074)
+                return true;
+            break;
+        case SPELLFAMILY_SHAMAN:
+            if (spellId == 30708)
+                return false;
+            break;
+        default:
+            break;
+    }
+
+    switch (spellproto->Mechanic)
+    {
+        case MECHANIC_IMMUNE_SHIELD:
+            return true;
+        default:
+            break;
+    }
+
+    // Amplify Magic / Dampen Magic
+    if (spellproto->SpellFamilyName == SPELLFAMILY_MAGE && spellproto->SpellFamilyFlags[0] & 0x2000 && spellproto->SpellFamilyFlags[2] & 0x8)
+        return true;
+
+    // Special case: effects which determine positivity of whole spell
+    for (uint8 i = 0; i<MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_STEALTH)
+            return true;
+    }
+
+    switch(spellproto->Effect[effIndex])
+    {
+        case SPELL_EFFECT_DUMMY:
+            // some explicitly required dummy effect sets
+            switch(spellId)
+            {
+                case 28441: return false;                   // AB Effect 000
+                default:
+                    break;
+            }
+            break;
+        // always positive effects (check before target checks that provided non-positive result in some case for positive effects)
+        case SPELL_EFFECT_HEAL:
+        case SPELL_EFFECT_LEARN_SPELL:
+        case SPELL_EFFECT_SKILL_STEP:
+        case SPELL_EFFECT_HEAL_PCT:
+        case SPELL_EFFECT_ENERGIZE_PCT:
+            return true;
+
+            // non-positive aura use
+        case SPELL_EFFECT_APPLY_AURA:
+        case SPELL_EFFECT_APPLY_AREA_AURA_FRIEND:
+        {
+            switch(spellproto->EffectApplyAuraName[effIndex])
+            {
+                case SPELL_AURA_MOD_DAMAGE_DONE:            // dependent from bas point sign (negative -> negative)
+                case SPELL_AURA_MOD_STAT:
+                case SPELL_AURA_MOD_SKILL:
+                case SPELL_AURA_MOD_HEALING_PCT:
+                case SPELL_AURA_MOD_HEALING_DONE:
+                case SPELL_AURA_MOD_DAMAGE_PERCENT_DONE:
+                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) < 0)
+                        return false;
+                    break;
+                case SPELL_AURA_MOD_DAMAGE_TAKEN:           // dependent from bas point sign (positive -> negative)
+                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
+                        return false;
+                    break;
+                case SPELL_AURA_MOD_CRIT_PCT:
+                case SPELL_AURA_MOD_SPELL_CRIT_CHANCE:
+                    if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
+                        return true;                        // some expected positive spells have SPELL_ATTR_EX_NEGATIVE
+                    break;
+                case SPELL_AURA_ADD_TARGET_TRIGGER:
+                    return true;
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
+                    if (!deep)
+                    {
+                        uint32 spellTriggeredId = spellproto->EffectTriggerSpell[effIndex];
+                        SpellEntry const *spellTriggeredProto = sSpellStore.LookupEntry(spellTriggeredId);
+
+                        if (spellTriggeredProto)
+                        {
+                            // non-positive targets of main spell return early
+                            for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                            {
+                                if (!spellTriggeredProto->Effect[i])
+                                    continue;
+                                // if non-positive trigger cast targeted to positive target this main cast is non-positive
+                                // this will place this spell auras as debuffs
+                                if (IsPositiveTarget(spellTriggeredProto->EffectImplicitTargetA[effIndex],spellTriggeredProto->EffectImplicitTargetB[effIndex]) && !_isPositiveEffect(spellTriggeredId,i, true))
+                                    return false;
+                            }
+                        }
+                    }
+                case SPELL_AURA_PROC_TRIGGER_SPELL:
+                    // many positive auras have negative triggered spells at damage for example and this not make it negative (it can be canceled for example)
+                    break;
+                case SPELL_AURA_MOD_STUN:                   //have positive and negative spells, we can't sort its correctly at this moment.
+                    if (effIndex == 0 && spellproto->Effect[1] == 0 && spellproto->Effect[2] == 0)
+                        return false;                       // but all single stun aura spells is negative
+                    if (spellproto->Id == 46968)
+                        return false;
+                    break;
+                case SPELL_AURA_MOD_PACIFY_SILENCE:
+                    if (spellproto->Id == 24740)             // Wisp Costume
+                        return true;
+                    return false;
+                case SPELL_AURA_MOD_ROOT:
+                case SPELL_AURA_MOD_SILENCE:
+                case SPELL_AURA_GHOST:
+                case SPELL_AURA_PERIODIC_LEECH:
+                case SPELL_AURA_MOD_STALKED:
+                case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
+                case SPELL_AURA_PREVENT_RESSURECTION:
+                    return false;
+                case SPELL_AURA_PERIODIC_DAMAGE:            // used in positive spells also.
+                    // part of negative spell if casted at self (prevent cancel)
+                    if (spellproto->EffectImplicitTargetA[effIndex] == TARGET_UNIT_CASTER)
+                        return false;
+                    break;
+                case SPELL_AURA_MOD_DECREASE_SPEED:         // used in positive spells also
+                    // part of positive spell if casted at self
+                    if (spellproto->EffectImplicitTargetA[effIndex] != TARGET_UNIT_CASTER)
+                        return false;
+                    // but not this if this first effect (didn't find better check)
+                    if (spellproto->Attributes & SPELL_ATTR_NEGATIVE_1 && effIndex == 0)
+                        return false;
+                    break;
+                case SPELL_AURA_MECHANIC_IMMUNITY:
+                {
+                    // non-positive immunities
+                    switch(spellproto->EffectMiscValue[effIndex])
+                    {
+                        case MECHANIC_BANDAGE:
+                        case MECHANIC_SHIELD:
+                        case MECHANIC_MOUNT:
+                        case MECHANIC_INVULNERABILITY:
+                            return false;
+                        default:
+                            break;
+                    }
+                }   break;
+                case SPELL_AURA_ADD_FLAT_MODIFIER:          // mods
+                case SPELL_AURA_ADD_PCT_MODIFIER:
+                {
+                    // non-positive mods
+                    switch(spellproto->EffectMiscValue[effIndex])
+                    {
+                        case SPELLMOD_COST:                 // dependent from bas point sign (negative -> positive)
+                            if (SpellMgr::CalculateSpellEffectAmount(spellproto, effIndex) > 0)
+                            {
+                                if (!deep)
+                                {
+                                    bool negative = true;
+                                    for (uint8 i=0; i<MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (i != effIndex)
+                                            if (_isPositiveEffect(spellId, i, true))
+                                            {
+                                                negative = false;
+                                                break;
+                                            }
+                                    }
+                                    if (negative)
+                                        return false;
+                                }
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                }   break;
+                default:
+                    break;
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    // non-positive targets
+    if (!IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex]))
+        return false;
+
+    // AttributesEx check
+    if (spellproto->AttributesEx & SPELL_ATTR_EX_NEGATIVE)
+        return false;
+
+    if (!deep && spellproto->EffectTriggerSpell[effIndex]
+        && !spellproto->EffectApplyAuraName[effIndex]
+        && IsPositiveTarget(spellproto->EffectImplicitTargetA[effIndex],spellproto->EffectImplicitTargetB[effIndex])
+        && !_isPositiveSpell(spellproto->EffectTriggerSpell[effIndex], true))
+        return false;
+
+    // ok, positive
+    return true;
+}
+
+bool IsPositiveSpell(uint32 spellId)
+{
+    if (!sSpellStore.LookupEntry(spellId)) // non-existing spells
+        return false;
+    return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE);
+}
+
+bool IsPositiveEffect(uint32 spellId, uint32 effIndex)
+{
+    if (!sSpellStore.LookupEntry(spellId))
+        return false;
+    switch(effIndex)
+    {
+        default:
+        case 0: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF0);
+        case 1: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF1);
+        case 2: return !(sSpellMgr.GetSpellCustomAttr(spellId) & SPELL_ATTR_CU_NEGATIVE_EFF2);
+    }
+}
+
+bool SpellMgr::_isPositiveSpell(uint32 spellId, bool deep) const
+{
+    SpellEntry const *spellproto = sSpellStore.LookupEntry(spellId);
+    if (!spellproto) return false;
+
+    // spells with at least one negative effect are considered negative
+    // some self-applied spells have negative effects but in self casting case negative check ignored.
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        if (!_isPositiveEffect(spellId, i, deep))
+            return false;
+    return true;
+}
+
+bool IsSingleTargetSpell(SpellEntry const *spellInfo)
+{
+    // all other single target spells have if it has AttributesEx5
+    if (spellInfo->AttributesEx5 & SPELL_ATTR_EX5_SINGLE_TARGET_SPELL)
+        return true;
+
+    switch(GetSpellSpecific(spellInfo))
+    {
+        case SPELL_SPECIFIC_JUDGEMENT:
+            return true;
+        default:
+            break;
+    }
+
+    return false;
+}
+
+bool IsSingleTargetSpells(SpellEntry const *spellInfo1, SpellEntry const *spellInfo2)
+{
+    // TODO - need better check
+    // Equal icon and spellfamily
+    if (spellInfo1->SpellFamilyName == spellInfo2->SpellFamilyName &&
+        spellInfo1->SpellIconID == spellInfo2->SpellIconID)
+        return true;
+
+    // TODO - need found Judgements rule
+    SpellSpecific spec1 = GetSpellSpecific(spellInfo1);
+    // spell with single target specific types
+    switch(spec1)
+    {
+        case SPELL_SPECIFIC_JUDGEMENT:
+        case SPELL_SPECIFIC_MAGE_POLYMORPH:
+            if (GetSpellSpecific(spellInfo2) == spec1)
+                return true;
+            break;
+        default:
+            break;
+    }
+
+    return false;
+}
+
+SpellCastResult GetErrorAtShapeshiftedCast (SpellEntry const *spellInfo, uint32 form)
+{
+    // talents that learn spells can have stance requirements that need ignore
+    // (this requirement only for client-side stance show in talent description)
+    if (GetTalentSpellCost(spellInfo->Id) > 0 &&
+        (spellInfo->Effect[0] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[1] == SPELL_EFFECT_LEARN_SPELL || spellInfo->Effect[2] == SPELL_EFFECT_LEARN_SPELL))
+        return SPELL_CAST_OK;
+
+    uint32 stanceMask = (form ? 1 << (form - 1) : 0);
+
+    if (stanceMask & spellInfo->StancesNot)                 // can explicitly not be casted in this stance
+        return SPELL_FAILED_NOT_SHAPESHIFT;
+
+    if (stanceMask & spellInfo->Stances)                    // can explicitly be casted in this stance
+        return SPELL_CAST_OK;
+
+    bool actAsShifted = false;
+    SpellShapeshiftEntry const *shapeInfo = NULL;
+    if (form > 0)
+    {
+        shapeInfo = sSpellShapeshiftStore.LookupEntry(form);
+        if (!shapeInfo)
+        {
+            sLog.outError("GetErrorAtShapeshiftedCast: unknown shapeshift %u", form);
+            return SPELL_CAST_OK;
+        }
+        actAsShifted = !(shapeInfo->flags1 & 1);            // shapeshift acts as normal form for spells
+    }
+
+    if (actAsShifted)
+    {
+        if (spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT) // not while shapeshifted
+            return SPELL_FAILED_NOT_SHAPESHIFT;
+        else if (spellInfo->Stances != 0)                   // needs other shapeshift
+            return SPELL_FAILED_ONLY_SHAPESHIFT;
+    }
+    else
+    {
+        // needs shapeshift
+        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_NOT_NEED_SHAPESHIFT) && spellInfo->Stances != 0)
+            return SPELL_FAILED_ONLY_SHAPESHIFT;
+    }
+
+    // Check if stance disables cast of not-stance spells
+    // Example: cannot cast any other spells in zombie or ghoul form
+    // TODO: Find a way to disable use of these spells clientside
+    if (shapeInfo && shapeInfo->flags1 & 0x400)
+    {
+        if (!(stanceMask & spellInfo->Stances))
+            return SPELL_FAILED_ONLY_SHAPESHIFT;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+void SpellMgr::LoadSpellTargetPositions()
+{
+    mSpellTargetPositions.clear();                                // need for reload case
+
+    uint32 count = 0;
+
+    //                                                0   1           2                  3                  4                  5
+    QueryResult result = WorldDatabase.Query("SELECT id, target_map, target_position_x, target_position_y, target_position_z, target_orientation FROM spell_target_position");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell target coordinates", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 Spell_ID = fields[0].GetUInt32();
+
+        SpellTargetPosition st;
+
+        st.target_mapId       = fields[1].GetUInt32();
+        st.target_X           = fields[2].GetFloat();
+        st.target_Y           = fields[3].GetFloat();
+        st.target_Z           = fields[4].GetFloat();
+        st.target_Orientation = fields[5].GetFloat();
+
+        MapEntry const* mapEntry = sMapStore.LookupEntry(st.target_mapId);
+        if (!mapEntry)
+        {
+            sLog.outErrorDb("Spell (ID:%u) target map (ID: %u) does not exist in `Map.dbc`.",Spell_ID,st.target_mapId);
+            continue;
+        }
+
+        if (st.target_X==0 && st.target_Y==0 && st.target_Z==0)
+        {
+            sLog.outErrorDb("Spell (ID:%u) target coordinates not provided.",Spell_ID);
+            continue;
+        }
+
+        SpellEntry const* spellInfo = sSpellStore.LookupEntry(Spell_ID);
+        if (!spellInfo)
+        {
+            sLog.outErrorDb("Spell (ID:%u) listed in `spell_target_position` does not exist.",Spell_ID);
+            continue;
+        }
+
+        bool found = false;
+        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->EffectImplicitTargetA[i] == TARGET_DST_DB || spellInfo->EffectImplicitTargetB[i] == TARGET_DST_DB)
+            {
+                // additional requirements
+                if (spellInfo->Effect[i]==SPELL_EFFECT_BIND && spellInfo->EffectMiscValue[i])
+                {
+                    uint32 area_id = sMapMgr.GetAreaId(st.target_mapId, st.target_X, st.target_Y, st.target_Z);
+                    if (area_id != uint32(spellInfo->EffectMiscValue[i]))
+                    {
+                        sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` expected point to zone %u bit point to zone %u.",Spell_ID, spellInfo->EffectMiscValue[i], area_id);
+                        break;
+                    }
+                }
+
+                found = true;
+                break;
+            }
+        }
+        if (!found)
+        {
+            sLog.outErrorDb("Spell (Id: %u) listed in `spell_target_position` does not have target TARGET_DST_DB (17).",Spell_ID);
+            continue;
+        }
+
+        mSpellTargetPositions[Spell_ID] = st;
+        ++count;
+
+    } while (result->NextRow());
+
+    // Check all spells
+    for (uint32 i = 1; i < sSpellStore.GetNumRows(); ++i)
+    {
+        SpellEntry const * spellInfo = sSpellStore.LookupEntry(i);
+        if (!spellInfo)
+            continue;
+
+        bool found = false;
+        for (int j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            switch(spellInfo->EffectImplicitTargetA[j])
+            {
+                case TARGET_DST_DB:
+                    found = true;
+                    break;
+            }
+            if (found)
+                break;
+            switch(spellInfo->EffectImplicitTargetB[j])
+            {
+                case TARGET_DST_DB:
+                    found = true;
+                    break;
+            }
+            if (found)
+                break;
+        }
+        if (found)
+        {
+//            if (!sSpellMgr.GetSpellTargetPosition(i))
+//                sLog.outDebug("Spell (ID: %u) does not have record in `spell_target_position`", i);
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell teleport coordinates", count);
+}
+
+bool SpellMgr::IsAffectedByMod(SpellEntry const *spellInfo, SpellModifier *mod) const
+{
+    // false for spellInfo == NULL
+    if (!spellInfo || !mod)
+        return false;
+
+    SpellEntry const *affect_spell = sSpellStore.LookupEntry(mod->spellId);
+    // False if affect_spell == NULL or spellFamily not equal
+    if (!affect_spell || affect_spell->SpellFamilyName != spellInfo->SpellFamilyName)
+        return false;
+
+    // true
+    if (mod->mask  & spellInfo->SpellFamilyFlags)
+        return true;
+
+    return false;
+}
+
+void SpellMgr::LoadSpellProcEvents()
+{
+    mSpellProcEventMap.clear();                             // need for reload case
+
+    uint32 count = 0;
+
+    //                                                0      1           2                3                 4                 5                 6          7       8        9             10
+    QueryResult result = WorldDatabase.Query("SELECT entry, SchoolMask, SpellFamilyName, SpellFamilyMask0, SpellFamilyMask1, SpellFamilyMask2, procFlags, procEx, ppmRate, CustomChance, Cooldown FROM spell_proc_event");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell proc event conditions", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+    uint32 customProc = 0;
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 entry = fields[0].GetUInt32();
+
+        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
+        if (!spell)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_proc_event` does not exist", entry);
+            continue;
+        }
+
+        SpellProcEventEntry spe;
+
+        spe.schoolMask      = fields[1].GetUInt32();
+        spe.spellFamilyName = fields[2].GetUInt32();
+        spe.spellFamilyMask[0] = fields[3].GetUInt32();
+        spe.spellFamilyMask[1] = fields[4].GetUInt32();
+        spe.spellFamilyMask[2] = fields[5].GetUInt32();
+        spe.procFlags       = fields[6].GetUInt32();
+        spe.procEx          = fields[7].GetUInt32();
+        spe.ppmRate         = fields[8].GetFloat();
+        spe.customChance    = fields[9].GetFloat();
+        spe.cooldown        = fields[10].GetUInt32();
+
+        mSpellProcEventMap[entry] = spe;
+
+        if (spell->procFlags == 0)
+        {
+            if (spe.procFlags == 0)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_proc_event` probally not triggered spell", entry);
+                continue;
+            }
+            customProc++;
+        }
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    if (customProc)
+        sLog.outString(">> Loaded %u extra spell proc event conditions + %u custom",  count, customProc);
+    else
+        sLog.outString(">> Loaded %u extra spell proc event conditions", count);
+}
+
+void SpellMgr::LoadSpellBonusess()
+{
+    mSpellBonusMap.clear();                             // need for reload case
+    uint32 count = 0;
+    //                                                0      1             2          3         4
+    QueryResult result = WorldDatabase.Query("SELECT entry, direct_bonus, dot_bonus, ap_bonus, ap_dot_bonus FROM spell_bonus_data");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell bonus data", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        Field *fields = result->Fetch();
+        bar.step();
+        uint32 entry = fields[0].GetUInt32();
+
+        const SpellEntry *spell = sSpellStore.LookupEntry(entry);
+        if (!spell)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_bonus_data` does not exist", entry);
+            continue;
+        }
+
+        SpellBonusEntry sbe;
+
+        sbe.direct_damage = fields[1].GetFloat();
+        sbe.dot_damage    = fields[2].GetFloat();
+        sbe.ap_bonus      = fields[3].GetFloat();
+        sbe.ap_dot_bonus   = fields[4].GetFloat();
+
+        mSpellBonusMap[entry] = sbe;
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u extra spell bonus data",  count);
+}
+
+bool SpellMgr::IsSpellProcEventCanTriggeredBy(SpellProcEventEntry const* spellProcEvent, uint32 EventProcFlag, SpellEntry const * procSpell, uint32 procFlags, uint32 procExtra, bool active)
+{
+    // No extra req need
+    uint32 procEvent_procEx = PROC_EX_NONE;
+
+    // check prockFlags for condition
+    if ((procFlags & EventProcFlag) == 0)
+        return false;
+
+    bool hasFamilyMask = false;
+
+    /* Check Periodic Auras
+
+    *Dots can trigger if spell has no PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
+        nor PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
+
+    *Only Hots can trigger if spell has PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL
+
+    *Only dots can trigger if spell has both positivity flags or PROC_FLAG_SUCCESSFUL_NEGATIVE_MAGIC_SPELL
+
+    *Aura has to have PROC_FLAG_TAKEN_POSITIVE_MAGIC_SPELL or spellfamily specified to trigger from Hot
+
+    */
+
+    if (procFlags & PROC_FLAG_DONE_PERIODIC)
+    {
+        if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG)
+        {
+            if (!(procExtra & PROC_EX_INTERNAL_DOT))
+                return false;
+        }
+        else if (procExtra & PROC_EX_INTERNAL_HOT)
+            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
+        else if (EventProcFlag & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS)
+            return false;
+    }
+
+    if (procFlags & PROC_FLAG_TAKEN_PERIODIC)
+    {
+        if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS)
+        {
+            if (!(procExtra & PROC_EX_INTERNAL_DOT))
+                return false;
+        }
+        else if (procExtra & PROC_EX_INTERNAL_HOT)
+            procExtra |= PROC_EX_INTERNAL_REQ_FAMILY;
+        else if (EventProcFlag & PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_POS)
+            return false;
+    }
+    // Trap casts are active by default
+    if (procFlags & PROC_FLAG_DONE_TRAP_ACTIVATION)
+        active = true;
+
+    // Always trigger for this
+    if (procFlags & (PROC_FLAG_KILLED | PROC_FLAG_KILL | PROC_FLAG_DEATH))
+        return true;
+
+    if (spellProcEvent)     // Exist event data
+    {
+        // Store extra req
+        procEvent_procEx = spellProcEvent->procEx;
+
+        // For melee triggers
+        if (procSpell == NULL)
+        {
+            // Check (if set) for school (melee attack have Normal school)
+            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & SPELL_SCHOOL_MASK_NORMAL) == 0)
+                return false;
+        }
+        else // For spells need check school/spell family/family mask
+        {
+            // Check (if set) for school
+            if (spellProcEvent->schoolMask && (spellProcEvent->schoolMask & procSpell->SchoolMask) == 0)
+                return false;
+
+            // Check (if set) for spellFamilyName
+            if (spellProcEvent->spellFamilyName && (spellProcEvent->spellFamilyName != procSpell->SpellFamilyName))
+                return false;
+
+            // spellFamilyName is Ok need check for spellFamilyMask if present
+            if (spellProcEvent->spellFamilyMask)
+            {
+                if ((spellProcEvent->spellFamilyMask & procSpell->SpellFamilyFlags) == 0)
+                    return false;
+                hasFamilyMask = true;
+                // Some spells are not considered as active even with have spellfamilyflags
+                if (!(procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL))
+                    active = true;
+            }
+        }
+    }
+
+    if (procExtra & (PROC_EX_INTERNAL_REQ_FAMILY))
+    {
+        if (!hasFamilyMask)
+            return false;
+    }
+
+    // Check for extra req (if none) and hit/crit
+    if (procEvent_procEx == PROC_EX_NONE)
+    {
+        // No extra req, so can trigger only for hit/crit - spell has to be active
+        if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && active)
+            return true;
+    }
+    else // Passive spells hits here only if resist/reflect/immune/evade
+    {
+        if (procExtra & AURA_SPELL_PROC_EX_MASK)
+        {
+            // if spell marked as procing only from not active spells
+            if (active && procEvent_procEx & PROC_EX_NOT_ACTIVE_SPELL)
+                return false;
+            // if spell marked as procing only from active spells
+            if (!active && procEvent_procEx & PROC_EX_ONLY_ACTIVE_SPELL)
+                return false;
+            // Exist req for PROC_EX_EX_TRIGGER_ALWAYS
+            if (procEvent_procEx & PROC_EX_EX_TRIGGER_ALWAYS)
+                return true;
+            // PROC_EX_NOT_ACTIVE_SPELL and PROC_EX_ONLY_ACTIVE_SPELL flags handle: if passed checks before
+            if ((procExtra & (PROC_EX_NORMAL_HIT|PROC_EX_CRITICAL_HIT)) && ((procEvent_procEx & (AURA_SPELL_PROC_EX_MASK)) == 0))
+                return true;
+        }
+        // Check Extra Requirement like (hit/crit/miss/resist/parry/dodge/block/immune/reflect/absorb and other)
+        if (procEvent_procEx & procExtra)
+            return true;
+    }
+    return false;
+}
+
+void SpellMgr::LoadSpellGroups()
+{
+    mSpellSpellGroup.clear();                                  // need for reload case
+    mSpellGroupSpell.clear();
+
+    uint32 count = 0;
+
+    //                                                       0   1
+    QueryResult result = WorldDatabase.Query("SELECT id, spell_id FROM spell_group");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell group definitions", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    std::set<uint32> groups;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 group_id = fields[0].GetUInt32();
+        if (group_id <= SPELL_GROUP_DB_RANGE_MIN && group_id >= SPELL_GROUP_CORE_RANGE_MAX)
+        {
+            sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` is in core range, but is not defined in core!", group_id);
+            continue;
+        }
+        int32 spell_id = fields[1].GetInt32();
+
+        groups.insert(std::set<uint32>::value_type(group_id));
+        mSpellGroupSpell.insert(SpellGroupSpellMap::value_type((SpellGroup)group_id, spell_id));
+
+    } while (result->NextRow());
+
+    for (SpellGroupSpellMap::iterator itr = mSpellGroupSpell.begin(); itr!= mSpellGroupSpell.end() ;)
+    {
+        if (itr->second < 0)
+        {
+            if (groups.find(abs(itr->second)) == groups.end())
+            {
+                sLog.outErrorDb("SpellGroup id %u listed in `spell_groups` does not exist", abs(itr->second));
+                mSpellGroupSpell.erase(itr++);
+            }
+            else
+                ++itr;
+        }
+        else
+        {
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(itr->second);
+
+            if (!spellInfo)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_group` does not exist", itr->second);
+                mSpellGroupSpell.erase(itr++);
+            }
+            else if (GetSpellRank(itr->second) > 1)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_group` is not first rank of spell", itr->second);
+                mSpellGroupSpell.erase(itr++);
+            }
+            else
+                ++itr;
+        }
+    }
+
+    for (std::set<uint32>::iterator groupItr = groups.begin() ; groupItr != groups.end() ; ++groupItr)
+    {
+        std::set<uint32> spells;
+        GetSetOfSpellsInSpellGroup(SpellGroup(*groupItr), spells);
+
+        for (std::set<uint32>::iterator spellItr = spells.begin() ; spellItr != spells.end() ; ++spellItr)
+        {
+            ++count;
+            mSpellSpellGroup.insert(SpellSpellGroupMap::value_type(*spellItr, SpellGroup(*groupItr)));
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell group definitions", count);
+}
+
+void SpellMgr::LoadSpellGroupStackRules()
+{
+    mSpellGroupStack.clear();                                  // need for reload case
+
+    uint32 count = 0;
+
+    //                                                       0         1
+    QueryResult result = WorldDatabase.Query("SELECT group_id, stack_rule FROM spell_group_stack_rules");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell group stack rules", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 group_id = fields[0].GetUInt32();
+        uint8 stack_rule = fields[1].GetUInt32();
+        if (stack_rule >= SPELL_GROUP_STACK_RULE_MAX)
+        {
+            sLog.outErrorDb("SpellGroupStackRule %u listed in `spell_group_stack_rules` does not exist", stack_rule);
+            continue;
+        }
+
+        SpellGroupSpellMapBounds spellGroup = GetSpellGroupSpellMapBounds((SpellGroup)group_id);
+
+        if (spellGroup.first == spellGroup.second)
+        {
+            sLog.outErrorDb("SpellGroup id %u listed in `spell_group_stack_rules` does not exist", group_id);
+            continue;
+        }
+
+        mSpellGroupStack[(SpellGroup)group_id] = (SpellGroupStackRule)stack_rule;
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell group stack rules", count);
+}
+
+void SpellMgr::LoadSpellThreats()
+{
+    mSpellThreatMap.clear();                                // need for reload case
+
+    uint32 count = 0;
+
+    //                                                0      1
+    QueryResult result = WorldDatabase.Query("SELECT entry, Threat FROM spell_threat");
+    if (!result)
+    {
+
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u aggro generating spells", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 entry = fields[0].GetUInt32();
+        uint16 Threat = fields[1].GetUInt16();
+
+        if (!sSpellStore.LookupEntry(entry))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_threat` does not exist", entry);
+            continue;
+        }
+
+        mSpellThreatMap[entry] = Threat;
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u aggro generating spells", count);
+}
+
+bool SpellMgr::IsRankSpellDueToSpell(SpellEntry const *spellInfo_1,uint32 spellId_2) const
+{
+    SpellEntry const *spellInfo_2 = sSpellStore.LookupEntry(spellId_2);
+    if (!spellInfo_1 || !spellInfo_2) return false;
+    if (spellInfo_1->Id == spellId_2) return false;
+
+    return GetFirstSpellInChain(spellInfo_1->Id) == GetFirstSpellInChain(spellId_2);
+}
+
+bool SpellMgr::canStackSpellRanks(SpellEntry const *spellInfo)
+{
+    if (IsPassiveSpell(spellInfo->Id))                       // ranked passive spell
+        return false;
+    if (spellInfo->powerType != POWER_MANA && spellInfo->powerType != POWER_HEALTH)
+        return false;
+    if (IsProfessionOrRidingSpell(spellInfo->Id))
+        return false;
+
+    if (sSpellMgr.IsSkillBonusSpell(spellInfo->Id))
+        return false;
+
+    // All stance spells. if any better way, change it.
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch(spellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_PALADIN:
+                // Paladin aura Spell
+                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID)
+                    return false;
+                break;
+            case SPELLFAMILY_DRUID:
+                // Druid form Spell
+                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
+                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
+                    return false;
+                break;
+            case SPELLFAMILY_ROGUE:
+                // Rogue Stealth
+                if (spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA &&
+                    spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_SHAPESHIFT)
+                    return false;
+        }
+    }
+    return true;
+}
+
+bool SpellMgr::IsProfessionOrRidingSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
+        {
+            uint32 skill = spellInfo->EffectMiscValue[i];
+
+            bool found = IsProfessionOrRidingSkill(skill);
+            if (found)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool SpellMgr::IsProfessionSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
+        {
+            uint32 skill = spellInfo->EffectMiscValue[i];
+
+            bool found = IsProfessionSkill(skill);
+            if (found)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool SpellMgr::IsPrimaryProfessionSpell(uint32 spellId)
+{
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spellId);
+    if (!spellInfo)
+        return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (spellInfo->Effect[i] == SPELL_EFFECT_SKILL)
+        {
+            uint32 skill = spellInfo->EffectMiscValue[i];
+
+            bool found = IsPrimaryProfessionSkill(skill);
+            if (found)
+                return true;
+        }
+    }
+    return false;
+}
+
+bool SpellMgr::IsPrimaryProfessionFirstRankSpell(uint32 spellId) const
+{
+    return IsPrimaryProfessionSpell(spellId) && GetSpellRank(spellId) == 1;
+}
+
+bool SpellMgr::IsSkillBonusSpell(uint32 spellId) const
+{
+    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
+
+    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
+    {
+        SkillLineAbilityEntry const *pAbility = _spell_idx->second;
+        if (!pAbility || pAbility->learnOnGetSkill != ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
+            continue;
+
+        if (pAbility->req_skill_value > 0)
+            return true;
+    }
+
+    return false;
+}
+
+bool SpellMgr::IsSkillTypeSpell(uint32 spellId, SkillType type) const
+{
+    SkillLineAbilityMapBounds bounds = GetSkillLineAbilityMapBounds(spellId);
+
+    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
+        if (_spell_idx->second->skillId == uint32(type))
+            return true;
+
+    return false;
+}
+
+// basepoints provided here have to be valid basepoints (use SpellMgr::CalculateSpellEffectBaseAmount)
+int32 SpellMgr::CalculateSpellEffectAmount(SpellEntry const * spellEntry, uint8 effIndex, Unit const * caster, int32 const * effBasePoints, Unit const * /*target*/)
+{
+    float basePointsPerLevel = spellEntry->EffectRealPointsPerLevel[effIndex];
+    int32 basePoints = effBasePoints ? *effBasePoints : spellEntry->EffectBasePoints[effIndex];
+    int32 randomPoints = int32(spellEntry->EffectDieSides[effIndex]);
+
+    // base amount modification based on spell lvl vs caster lvl
+    if (caster)
+    {
+        int32 level = int32(caster->getLevel());
+        if (level > int32(spellEntry->maxLevel) && spellEntry->maxLevel > 0)
+            level = int32(spellEntry->maxLevel);
+        else if (level < int32(spellEntry->baseLevel))
+            level = int32(spellEntry->baseLevel);
+        level -= int32(spellEntry->spellLevel);
+        basePoints += int32(level * basePointsPerLevel);
+    }
+
+    // roll in a range <1;EffectDieSides> as of patch 3.3.3
+    switch(randomPoints)
+    {
+        case 0: break;
+        case 1: basePoints += 1; break;                     // range 1..1
+        default:
+            // range can have positive (1..rand) and negative (rand..1) values, so order its for irand
+            int32 randvalue = (randomPoints >= 1)
+                ? irand(1, randomPoints)
+                : irand(randomPoints, 1);
+
+            basePoints += randvalue;
+            break;
+    }
+
+    int32 value = basePoints;
+
+    // random damage
+    if (caster)
+    {
+        // bonus amount from combo points
+        if  (caster->m_movedPlayer)
+            if (uint8 comboPoints = caster->m_movedPlayer->GetComboPoints())
+                if (float comboDamage = spellEntry->EffectPointsPerComboPoint[effIndex])
+                    value += int32(comboDamage * comboPoints);
+
+        value = caster->ApplyEffectModifiers(spellEntry, effIndex, value);
+
+        // amount multiplication based on caster's level
+        if (!basePointsPerLevel && (spellEntry->Attributes & SPELL_ATTR_LEVEL_DAMAGE_CALCULATION && spellEntry->spellLevel) &&
+                spellEntry->Effect[effIndex] != SPELL_EFFECT_WEAPON_PERCENT_DAMAGE &&
+                spellEntry->Effect[effIndex] != SPELL_EFFECT_KNOCK_BACK &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_ALWAYS &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_SPEED_NOT_STACK &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_INCREASE_SPEED &&
+                spellEntry->EffectApplyAuraName[effIndex] != SPELL_AURA_MOD_DECREASE_SPEED)
+                //there are many more: slow speed, -healing pct
+            value = int32(value*0.25f*exp(caster->getLevel()*(70-spellEntry->spellLevel)/1000.0f));
+            //value = int32(value * (int32)getLevel() / (int32)(spellProto->spellLevel ? spellProto->spellLevel : 1));
+    }
+
+    return value;
+}
+
+int32 SpellMgr::CalculateSpellEffectBaseAmount(int32 value, SpellEntry const * spellEntry, uint8 effIndex)
+{
+    if (spellEntry->EffectDieSides[effIndex] == 0)
+        return value;
+    else
+        return value - 1;
+}
+
+float SpellMgr::CalculateSpellEffectValueMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
+{
+    float multiplier = spellEntry->EffectValueMultiplier[effIndex];
+
+    if (caster)
+        if (Player * modOwner = caster->GetSpellModOwner())
+            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_VALUE_MULTIPLIER, multiplier, spell);
+    return multiplier;
+}
+
+float SpellMgr::CalculateSpellEffectDamageMultiplier(SpellEntry const * spellEntry, uint8 effIndex, Unit * caster, Spell * spell)
+{
+    float multiplier = spellEntry->EffectDamageMultiplier[effIndex];
+
+    if (caster)
+        if (Player * modOwner = caster->GetSpellModOwner())
+            modOwner->ApplySpellMod(spellEntry->Id, SPELLMOD_DAMAGE_MULTIPLIER, multiplier, spell);
+    return multiplier;
+}
+
+SpellEntry const* SpellMgr::SelectAuraRankForPlayerLevel(SpellEntry const* spellInfo, uint32 playerLevel) const
+{
+    // ignore passive spells
+    if (IsPassiveSpell(spellInfo->Id))
+        return spellInfo;
+
+    bool needRankSelection = false;
+    for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (IsPositiveEffect(spellInfo->Id, i) && (
+            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AURA ||
+            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
+            spellInfo->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA_RAID
+))
+        {
+            needRankSelection = true;
+            break;
+        }
+    }
+
+    // not required
+    if (!needRankSelection)
+        return spellInfo;
+
+    for (uint32 nextSpellId = spellInfo->Id; nextSpellId != 0; nextSpellId = GetPrevSpellInChain(nextSpellId))
+    {
+        SpellEntry const *nextSpellInfo = sSpellStore.LookupEntry(nextSpellId);
+        if (!nextSpellInfo)
+            break;
+
+        // if found appropriate level
+        if (playerLevel + 10 >= nextSpellInfo->spellLevel)
+            return nextSpellInfo;
+
+        // one rank less then
+    }
+
+    // not found
+    return NULL;
+}
+
+void SpellMgr::LoadSpellLearnSkills()
+{
+    mSpellLearnSkills.clear();                              // need for reload case
+
+    // search auto-learned skills and add its to map also for use in unlearn spells/talents
+    uint32 dbc_count = 0;
+    barGoLink bar(sSpellStore.GetNumRows());
+    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
+    {
+        bar.step();
+        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
+
+        if (!entry)
+            continue;
+
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (entry->Effect[i] == SPELL_EFFECT_SKILL)
+            {
+                SpellLearnSkillNode dbc_node;
+                dbc_node.skill = entry->EffectMiscValue[i];
+                dbc_node.step  = SpellMgr::CalculateSpellEffectAmount(entry, i);
+                if (dbc_node.skill != SKILL_RIDING)
+                    dbc_node.value = 1;
+                else
+                    dbc_node.value = dbc_node.step * 75;
+                dbc_node.maxvalue = dbc_node.step * 75;
+                mSpellLearnSkills[spell] = dbc_node;
+                ++dbc_count;
+                break;
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u Spell Learn Skills from DBC", dbc_count);
+}
+
+void SpellMgr::LoadSpellLearnSpells()
+{
+    mSpellLearnSpells.clear();                              // need for reload case
+
+    //                                                  0      1        2
+    QueryResult result = WorldDatabase.Query("SELECT entry, SpellID, Active FROM spell_learn_spell");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded 0 spell learn spells");
+        sLog.outErrorDb("`spell_learn_spell` table is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        bar.step();
+        Field *fields = result->Fetch();
+
+        uint32 spell_id = fields[0].GetUInt32();
+
+        SpellLearnSpellNode node;
+        node.spell      = fields[1].GetUInt32();
+        node.active     = fields[2].GetBool();
+        node.autoLearned= false;
+
+        if (!sSpellStore.LookupEntry(spell_id))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` does not exist", spell_id);
+            continue;
+        }
+
+        if (!sSpellStore.LookupEntry(node.spell))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` learning not existed spell %u", spell_id, node.spell);
+            continue;
+        }
+
+        if (GetTalentSpellCost(node.spell))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_learn_spell` attempt learning talent spell %u, skipped", spell_id, node.spell);
+            continue;
+        }
+
+        mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell_id,node));
+
+        ++count;
+    } while (result->NextRow());
+
+    // search auto-learned spells and add its to map also for use in unlearn spells/talents
+    uint32 dbc_count = 0;
+    for (uint32 spell = 0; spell < sSpellStore.GetNumRows(); ++spell)
+    {
+        SpellEntry const* entry = sSpellStore.LookupEntry(spell);
+
+        if (!entry)
+            continue;
+
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (entry->Effect[i] == SPELL_EFFECT_LEARN_SPELL)
+            {
+                SpellLearnSpellNode dbc_node;
+                dbc_node.spell = entry->EffectTriggerSpell[i];
+                dbc_node.active = true;                     // all dbc based learned spells is active (show in spell book or hide by client itself)
+
+                // ignore learning not existed spells (broken/outdated/or generic learnig spell 483
+                if (!sSpellStore.LookupEntry(dbc_node.spell))
+                    continue;
+
+                // talent or passive spells or skill-step spells auto-casted and not need dependent learning,
+                // pet teaching spells don't must be dependent learning (casted)
+                // other required explicit dependent learning
+                dbc_node.autoLearned = entry->EffectImplicitTargetA[i] == TARGET_UNIT_PET || GetTalentSpellCost(spell) > 0 || IsPassiveSpell(spell) || IsSpellHaveEffect(entry,SPELL_EFFECT_SKILL_STEP);
+
+                SpellLearnSpellMapBounds db_node_bounds = GetSpellLearnSpellMapBounds(spell);
+
+                bool found = false;
+                for (SpellLearnSpellMap::const_iterator itr = db_node_bounds.first; itr != db_node_bounds.second; ++itr)
+                {
+                    if (itr->second.spell == dbc_node.spell)
+                    {
+                        sLog.outErrorDb("Spell %u auto-learn spell %u in spell.dbc then the record in `spell_learn_spell` is redundant, please fix DB.",
+                            spell,dbc_node.spell);
+                        found = true;
+                        break;
+                    }
+                }
+
+                if (!found)                                  // add new spell-spell pair if not found
+                {
+                    mSpellLearnSpells.insert(SpellLearnSpellMap::value_type(spell,dbc_node));
+                    ++dbc_count;
+                }
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell learn spells + %u found in DBC", count, dbc_count);
+}
+
+void SpellMgr::LoadSpellPetAuras()
+{
+    mSpellPetAuraMap.clear();                                  // need for reload case
+
+    uint32 count = 0;
+
+    //                                                  0       1       2    3
+    QueryResult result = WorldDatabase.Query("SELECT spell, effectId, pet, aura FROM spell_pet_auras");
+    if (!result)
+    {
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell pet auras", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 spell = fields[0].GetUInt32();
+        uint8 eff = fields[1].GetUInt8();
+        uint32 pet = fields[2].GetUInt32();
+        uint32 aura = fields[3].GetUInt32();
+
+        SpellPetAuraMap::iterator itr = mSpellPetAuraMap.find((spell<<8) + eff);
+        if (itr != mSpellPetAuraMap.end())
+            itr->second.AddAura(pet, aura);
+        else
+        {
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(spell);
+            if (!spellInfo)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_pet_auras` does not exist", spell);
+                continue;
+            }
+            if (spellInfo->Effect[eff] != SPELL_EFFECT_DUMMY &&
+               (spellInfo->Effect[eff] != SPELL_EFFECT_APPLY_AURA ||
+                spellInfo->EffectApplyAuraName[eff] != SPELL_AURA_DUMMY))
+            {
+                sLog.outError("Spell %u listed in `spell_pet_auras` does not have dummy aura or dummy effect", spell);
+                continue;
+            }
+
+            SpellEntry const* spellInfo2 = sSpellStore.LookupEntry(aura);
+            if (!spellInfo2)
+            {
+                sLog.outErrorDb("Aura %u listed in `spell_pet_auras` does not exist", aura);
+                continue;
+            }
+
+            PetAura pa(pet, aura, spellInfo->EffectImplicitTargetA[eff] == TARGET_UNIT_PET, SpellMgr::CalculateSpellEffectAmount(spellInfo, eff));
+            mSpellPetAuraMap[(spell<<8) + eff] = pa;
+        }
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell pet auras", count);
+}
+
+void SpellMgr::LoadPetLevelupSpellMap()
+{
+    mPetLevelupSpellMap.clear();                                   // need for reload case
+
+    uint32 count = 0;
+    uint32 family_count = 0;
+
+    barGoLink bar(sCreatureFamilyStore.GetNumRows());
+
+    for (uint32 i = 0; i < sCreatureFamilyStore.GetNumRows(); ++i)
+    {
+        bar.step();
+
+        CreatureFamilyEntry const *creatureFamily = sCreatureFamilyStore.LookupEntry(i);
+        if (!creatureFamily)                                     // not exist
+            continue;
+
+        for (uint8 j = 0; j < 2; ++j)
+        {
+            if (!creatureFamily->skillLine[j])
+                continue;
+
+            for (uint32 k = 0; k < sSkillLineAbilityStore.GetNumRows(); ++k)
+            {
+                SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(k);
+                if (!skillLine)
+                    continue;
+
+                //if (skillLine->skillId != creatureFamily->skillLine[0] &&
+                //    (!creatureFamily->skillLine[1] || skillLine->skillId != creatureFamily->skillLine[1]))
+                //    continue;
+
+                if (skillLine->skillId != creatureFamily->skillLine[j])
+                    continue;
+
+                if (skillLine->learnOnGetSkill != ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL)
+                    continue;
+
+                SpellEntry const *spell = sSpellStore.LookupEntry(skillLine->spellId);
+                if (!spell) // not exist or triggered or talent
+                    continue;
+
+                if (!spell->spellLevel)
+                    continue;
+
+                PetLevelupSpellSet& spellSet = mPetLevelupSpellMap[creatureFamily->ID];
+                if (spellSet.empty())
+                    ++family_count;
+
+                spellSet.insert(PetLevelupSpellSet::value_type(spell->spellLevel,spell->Id));
+                ++count;
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u pet levelup and default spells for %u families", count, family_count);
+}
+
+bool LoadPetDefaultSpells_helper(CreatureInfo const* cInfo, PetDefaultSpellsEntry& petDefSpells)
+{
+    // skip empty list;
+    bool have_spell = false;
+    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+    {
+        if (petDefSpells.spellid[j])
+        {
+            have_spell = true;
+            break;
+        }
+    }
+    if (!have_spell)
+        return false;
+
+    // remove duplicates with levelupSpells if any
+    if (PetLevelupSpellSet const *levelupSpells = cInfo->family ? sSpellMgr.GetPetLevelupSpellList(cInfo->family) : NULL)
+    {
+        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+        {
+            if (!petDefSpells.spellid[j])
+                continue;
+
+            for (PetLevelupSpellSet::const_iterator itr = levelupSpells->begin(); itr != levelupSpells->end(); ++itr)
+            {
+                if (itr->second == petDefSpells.spellid[j])
+                {
+                    petDefSpells.spellid[j] = 0;
+                    break;
+                }
+            }
+        }
+    }
+
+    // skip empty list;
+    have_spell = false;
+    for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+    {
+        if (petDefSpells.spellid[j])
+        {
+            have_spell = true;
+            break;
+        }
+    }
+
+    return have_spell;
+}
+
+void SpellMgr::LoadPetDefaultSpells()
+{
+    mPetDefaultSpellsMap.clear();
+
+    uint32 countCreature = 0;
+    uint32 countData = 0;
+
+    barGoLink bar(sCreatureStorage.MaxEntry + sSpellStore.GetNumRows());
+
+    for (uint32 i = 0; i < sCreatureStorage.MaxEntry; ++i)
+    {
+        bar.step();
+
+        CreatureInfo const* cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(i);
+        if (!cInfo)
+            continue;
+
+        if (!cInfo->PetSpellDataId)
+            continue;
+
+        // for creature with PetSpellDataId get default pet spells from dbc
+        CreatureSpellDataEntry const* spellDataEntry = sCreatureSpellDataStore.LookupEntry(cInfo->PetSpellDataId);
+        if (!spellDataEntry)
+            continue;
+
+        int32 petSpellsId = -int32(cInfo->PetSpellDataId);
+        PetDefaultSpellsEntry petDefSpells;
+        for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+            petDefSpells.spellid[j] = spellDataEntry->spellId[j];
+
+        if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
+        {
+            mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
+            ++countData;
+        }
+    }
+
+    // different summon spells
+    for (uint32 i = 0; i < sSpellStore.GetNumRows(); ++i)
+    {
+        bar.step();
+
+        SpellEntry const* spellEntry = sSpellStore.LookupEntry(i);
+        if (!spellEntry)
+            continue;
+
+        for (uint8 k = 0; k < MAX_SPELL_EFFECTS; ++k)
+        {
+            if (spellEntry->Effect[k] == SPELL_EFFECT_SUMMON || spellEntry->Effect[k] == SPELL_EFFECT_SUMMON_PET)
+            {
+                uint32 creature_id = spellEntry->EffectMiscValue[k];
+                CreatureInfo const *cInfo = sCreatureStorage.LookupEntry<CreatureInfo>(creature_id);
+                if (!cInfo)
+                    continue;
+
+                // already loaded
+                if (cInfo->PetSpellDataId)
+                    continue;
+
+                // for creature without PetSpellDataId get default pet spells from creature_template
+                int32 petSpellsId = cInfo->Entry;
+                if (mPetDefaultSpellsMap.find(cInfo->Entry) != mPetDefaultSpellsMap.end())
+                    continue;
+
+                PetDefaultSpellsEntry petDefSpells;
+                for (uint8 j = 0; j < MAX_CREATURE_SPELL_DATA_SLOT; ++j)
+                    petDefSpells.spellid[j] = cInfo->spells[j];
+
+                if (LoadPetDefaultSpells_helper(cInfo, petDefSpells))
+                {
+                    mPetDefaultSpellsMap[petSpellsId] = petDefSpells;
+                    ++countCreature;
+                }
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded addition spells for %u pet spell data entries.", countData);
+    sLog.outString(">> Loaded %u summonable creature templates.", countCreature);
+}
+
+/// Some checks for spells, to prevent adding deprecated/broken spells for trainers, spell book, etc
+bool SpellMgr::IsSpellValid(SpellEntry const *spellInfo, Player *pl, bool msg)
+{
+    // not exist
+    if (!spellInfo)
+        return false;
+
+    bool need_check_reagents = false;
+
+    // check effects
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spellInfo->Effect[i])
+        {
+            case 0:
+                continue;
+
+            // craft spell for crafting non-existed item (break client recipes list show)
+            case SPELL_EFFECT_CREATE_ITEM:
+            case SPELL_EFFECT_CREATE_ITEM_2:
+            {
+                if (spellInfo->EffectItemType[i] == 0)
+                {
+                    // skip auto-loot crafting spells, its not need explicit item info (but have special fake items sometime)
+                    if (!IsLootCraftingSpell(spellInfo))
+                    {
+                        if (msg)
+                        {
+                            if (pl)
+                                ChatHandler(pl).PSendSysMessage("Craft spell %u not have create item entry.",spellInfo->Id);
+                            else
+                                sLog.outErrorDb("Craft spell %u not have create item entry.",spellInfo->Id);
+                        }
+                        return false;
+                    }
+
+                }
+                // also possible IsLootCraftingSpell case but fake item must exist anyway
+                else if (!ObjectMgr::GetItemPrototype(spellInfo->EffectItemType[i]))
+                {
+                    if (msg)
+                    {
+                        if (pl)
+                            ChatHandler(pl).PSendSysMessage("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
+                        else
+                            sLog.outErrorDb("Craft spell %u create not-exist in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->EffectItemType[i]);
+                    }
+                    return false;
+                }
+
+                need_check_reagents = true;
+                break;
+            }
+            case SPELL_EFFECT_LEARN_SPELL:
+            {
+                SpellEntry const *spellInfo2 = sSpellStore.LookupEntry(spellInfo->EffectTriggerSpell[i]);
+                if (!IsSpellValid(spellInfo2,pl,msg))
+                {
+                    if (msg)
+                    {
+                        if (pl)
+                            ChatHandler(pl).PSendSysMessage("Spell %u learn to broken spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
+                        else
+                            sLog.outErrorDb("Spell %u learn to invalid spell %u, and then...",spellInfo->Id,spellInfo->EffectTriggerSpell[i]);
+                    }
+                    return false;
+                }
+                break;
+            }
+        }
+    }
+
+    if (need_check_reagents)
+    {
+        for (uint8 j = 0; j < MAX_SPELL_REAGENTS; ++j)
+        {
+            if (spellInfo->Reagent[j] > 0 && !ObjectMgr::GetItemPrototype(spellInfo->Reagent[j]))
+            {
+                if (msg)
+                {
+                    if (pl)
+                        ChatHandler(pl).PSendSysMessage("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
+                    else
+                        sLog.outErrorDb("Craft spell %u have not-exist reagent in DB item (Entry: %u) and then...",spellInfo->Id,spellInfo->Reagent[j]);
+                }
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
+void SpellMgr::LoadSpellAreas()
+{
+    mSpellAreaMap.clear();                                  // need for reload case
+    mSpellAreaForQuestMap.clear();
+    mSpellAreaForActiveQuestMap.clear();
+    mSpellAreaForQuestEndMap.clear();
+    mSpellAreaForAuraMap.clear();
+
+    uint32 count = 0;
+
+    //                                                  0     1         2              3               4           5          6        7       8
+    QueryResult result = WorldDatabase.Query("SELECT spell, area, quest_start, quest_start_active, quest_end, aura_spell, racemask, gender, autocast FROM spell_area");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell area requirements", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 spell = fields[0].GetUInt32();
+        SpellArea spellArea;
+        spellArea.spellId             = spell;
+        spellArea.areaId              = fields[1].GetUInt32();
+        spellArea.questStart          = fields[2].GetUInt32();
+        spellArea.questStartCanActive = fields[3].GetBool();
+        spellArea.questEnd            = fields[4].GetUInt32();
+        spellArea.auraSpell           = fields[5].GetInt32();
+        spellArea.raceMask            = fields[6].GetUInt32();
+        spellArea.gender              = Gender(fields[7].GetUInt8());
+        spellArea.autocast            = fields[8].GetBool();
+
+        if (const SpellEntry* spellInfo = sSpellStore.LookupEntry(spell))
+        {
+            if (spellArea.autocast)
+                const_cast<SpellEntry*>(spellInfo)->Attributes |= SPELL_ATTR_CANT_CANCEL;
+        }
+        else
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` does not exist", spell);
+            continue;
+        }
+
+        {
+            bool ok = true;
+            SpellAreaMapBounds sa_bounds = GetSpellAreaMapBounds(spellArea.spellId);
+            for (SpellAreaMap::const_iterator itr = sa_bounds.first; itr != sa_bounds.second; ++itr)
+            {
+                if (spellArea.spellId != itr->second.spellId)
+                    continue;
+                if (spellArea.areaId != itr->second.areaId)
+                    continue;
+                if (spellArea.questStart != itr->second.questStart)
+                    continue;
+                if (spellArea.auraSpell != itr->second.auraSpell)
+                    continue;
+                if ((spellArea.raceMask & itr->second.raceMask) == 0)
+                    continue;
+                if (spellArea.gender != itr->second.gender)
+                    continue;
+
+                // duplicate by requirements
+                ok =false;
+                break;
+            }
+
+            if (!ok)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` already listed with similar requirements.", spell);
+                continue;
+            }
+        }
+
+        if (spellArea.areaId && !GetAreaEntryByAreaID(spellArea.areaId))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong area (%u) requirement", spell,spellArea.areaId);
+            continue;
+        }
+
+        if (spellArea.questStart && !sObjectMgr.GetQuestTemplate(spellArea.questStart))
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong start quest (%u) requirement", spell,spellArea.questStart);
+            continue;
+        }
+
+        if (spellArea.questEnd)
+        {
+            if (!sObjectMgr.GetQuestTemplate(spellArea.questEnd))
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong end quest (%u) requirement", spell,spellArea.questEnd);
+                continue;
+            }
+
+            if (spellArea.questEnd == spellArea.questStart && !spellArea.questStartCanActive)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have quest (%u) requirement for start and end in same time", spell,spellArea.questEnd);
+                continue;
+            }
+        }
+
+        if (spellArea.auraSpell)
+        {
+            SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(spellArea.auraSpell));
+            if (!spellInfo)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have wrong aura spell (%u) requirement", spell,abs(spellArea.auraSpell));
+                continue;
+            }
+
+            if (uint32(abs(spellArea.auraSpell)) == spellArea.spellId)
+            {
+                sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement for itself", spell,abs(spellArea.auraSpell));
+                continue;
+            }
+
+            // not allow autocast chains by auraSpell field (but allow use as alternative if not present)
+            if (spellArea.autocast && spellArea.auraSpell > 0)
+            {
+                bool chain = false;
+                SpellAreaForAuraMapBounds saBound = GetSpellAreaForAuraMapBounds(spellArea.spellId);
+                for (SpellAreaForAuraMap::const_iterator itr = saBound.first; itr != saBound.second; ++itr)
+                {
+                    if (itr->second->autocast && itr->second->auraSpell > 0)
+                    {
+                        chain = true;
+                        break;
+                    }
+                }
+
+                if (chain)
+                {
+                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
+                    continue;
+                }
+
+                SpellAreaMapBounds saBound2 = GetSpellAreaMapBounds(spellArea.auraSpell);
+                for (SpellAreaMap::const_iterator itr2 = saBound2.first; itr2 != saBound2.second; ++itr2)
+                {
+                    if (itr2->second.autocast && itr2->second.auraSpell > 0)
+                    {
+                        chain = true;
+                        break;
+                    }
+                }
+
+                if (chain)
+                {
+                    sLog.outErrorDb("Spell %u listed in `spell_area` have aura spell (%u) requirement that itself autocast from aura", spell,spellArea.auraSpell);
+                    continue;
+                }
+            }
+        }
+
+        if (spellArea.raceMask && (spellArea.raceMask & RACEMASK_ALL_PLAYABLE) == 0)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong race mask (%u) requirement", spell,spellArea.raceMask);
+            continue;
+        }
+
+        if (spellArea.gender != GENDER_NONE && spellArea.gender != GENDER_FEMALE && spellArea.gender != GENDER_MALE)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_area` have wrong gender (%u) requirement", spell, spellArea.gender);
+            continue;
+        }
+
+        SpellArea const* sa = &mSpellAreaMap.insert(SpellAreaMap::value_type(spell,spellArea))->second;
+
+        // for search by current zone/subzone at zone/subzone change
+        if (spellArea.areaId)
+            mSpellAreaForAreaMap.insert(SpellAreaForAreaMap::value_type(spellArea.areaId,sa));
+
+        // for search at quest start/reward
+        if (spellArea.questStart)
+        {
+            if (spellArea.questStartCanActive)
+                mSpellAreaForActiveQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
+            else
+                mSpellAreaForQuestMap.insert(SpellAreaForQuestMap::value_type(spellArea.questStart,sa));
+        }
+
+        // for search at quest start/reward
+        if (spellArea.questEnd)
+            mSpellAreaForQuestEndMap.insert(SpellAreaForQuestMap::value_type(spellArea.questEnd,sa));
+
+        // for search at aura apply
+        if (spellArea.auraSpell)
+            mSpellAreaForAuraMap.insert(SpellAreaForAuraMap::value_type(abs(spellArea.auraSpell),sa));
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell area requirements", count);
+}
+
+SpellCastResult SpellMgr::GetSpellAllowedInLocationError(SpellEntry const *spellInfo, uint32 map_id, uint32 zone_id, uint32 area_id, Player const* player)
+{
+    // normal case
+    if (spellInfo->AreaGroupId > 0)
+    {
+        bool found = false;
+        AreaGroupEntry const* groupEntry = sAreaGroupStore.LookupEntry(spellInfo->AreaGroupId);
+        while (groupEntry)
+        {
+            for (uint8 i = 0; i < MAX_GROUP_AREA_IDS; ++i)
+                if (groupEntry->AreaId[i] == zone_id || groupEntry->AreaId[i] == area_id)
+                    found = true;
+            if (found || !groupEntry->nextGroup)
+                break;
+            // Try search in next group
+            groupEntry = sAreaGroupStore.LookupEntry(groupEntry->nextGroup);
+        }
+
+        if (!found)
+            return SPELL_FAILED_INCORRECT_AREA;
+    }
+
+    // continent limitation (virtual continent)
+    if (spellInfo->AttributesEx4 & SPELL_ATTR_EX4_CAST_ONLY_IN_OUTLAND)
+    {
+        uint32 v_map = GetVirtualMapForMapAndZone(map_id, zone_id);
+        MapEntry const *mapEntry = sMapStore.LookupEntry(v_map);
+        if (!mapEntry || mapEntry->addon < 1 || !mapEntry->IsContinent())
+            return SPELL_FAILED_INCORRECT_AREA;
+    }
+
+    // raid instance limitation
+    if (spellInfo->AttributesEx6 & SPELL_ATTR_EX6_NOT_IN_RAID_INSTANCE)
+    {
+        MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+        if (!mapEntry || mapEntry->IsRaid())
+            return SPELL_FAILED_NOT_IN_RAID_INSTANCE;
+    }
+
+    // DB base check (if non empty then must fit at least single for allow)
+    SpellAreaMapBounds saBounds = sSpellMgr.GetSpellAreaMapBounds(spellInfo->Id);
+    if (saBounds.first != saBounds.second)
+    {
+        for (SpellAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+        {
+            if (itr->second.IsFitToRequirements(player,zone_id,area_id))
+                return SPELL_CAST_OK;
+        }
+        return SPELL_FAILED_INCORRECT_AREA;
+    }
+
+    // bg spell checks
+    switch(spellInfo->Id)
+    {
+        case 23333:                                         // Warsong Flag
+        case 23335:                                         // Silverwing Flag
+            return map_id == 489 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        case 34976:                                         // Netherstorm Flag
+            return map_id == 566 && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        case 2584:                                          // Waiting to Resurrect
+        case 22011:                                         // Spirit Heal Channel
+        case 22012:                                         // Spirit Heal
+        case 24171:                                         // Resurrection Impact Visual
+        case 42792:                                         // Recently Dropped Flag
+        case 43681:                                         // Inactive
+        case 44535:                                         // Spirit Heal (mana)
+        {
+            MapEntry const* mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            return zone_id == 4197 || (mapEntry->IsBattleground() && player && player->InBattleground()) ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+        case 44521:                                         // Preparation
+        {
+            if (!player)
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            if (!mapEntry->IsBattleground())
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            Battleground* bg = player->GetBattleground();
+            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+        case 32724:                                         // Gold Team (Alliance)
+        case 32725:                                         // Green Team (Alliance)
+        case 35774:                                         // Gold Team (Horde)
+        case 35775:                                         // Green Team (Horde)
+        {
+            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            return mapEntry->IsBattleArena() && player && player->InBattleground() ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+        case 32727:                                         // Arena Preparation
+        {
+            if (!player)
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            MapEntry const *mapEntry = sMapStore.LookupEntry(map_id);
+            if (!mapEntry)
+                return SPELL_FAILED_INCORRECT_AREA;
+
+            if (!mapEntry->IsBattleArena())
+                return SPELL_FAILED_REQUIRES_AREA;
+
+            Battleground *bg = player->GetBattleground();
+            return bg && bg->GetStatus() == STATUS_WAIT_JOIN ? SPELL_CAST_OK : SPELL_FAILED_REQUIRES_AREA;
+        }
+    }
+
+    // aura limitations
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spellInfo->EffectApplyAuraName[i])
+        {
+            case SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED:
+            case SPELL_AURA_FLY:
+            {
+                if (player && !player->IsKnowHowFlyIn(map_id, zone_id))
+                    return SPELL_FAILED_INCORRECT_AREA;
+            }
+        }
+    }
+
+    return SPELL_CAST_OK;
+}
+
+void SpellMgr::LoadSkillLineAbilityMap()
+{
+    mSkillLineAbilityMap.clear();
+
+    barGoLink bar(sSkillLineAbilityStore.GetNumRows());
+    uint32 count = 0;
+
+    for (uint32 i = 0; i < sSkillLineAbilityStore.GetNumRows(); ++i)
+    {
+        bar.step();
+        SkillLineAbilityEntry const *SkillInfo = sSkillLineAbilityStore.LookupEntry(i);
+        if (!SkillInfo)
+            continue;
+
+        mSkillLineAbilityMap.insert(SkillLineAbilityMap::value_type(SkillInfo->spellId,SkillInfo));
+        ++count;
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u SkillLineAbility MultiMap Data", count);
+}
+
+DiminishingGroup GetDiminishingReturnsGroupForSpell(SpellEntry const* spellproto, bool triggered)
+{
+    // Explicit Diminishing Groups
+    switch (spellproto->SpellFamilyName)
+    {
+        case SPELLFAMILY_GENERIC:
+            // some generic arena related spells have by some strange reason MECHANIC_TURN
+            if  (spellproto->Mechanic == MECHANIC_TURN)
+                return DIMINISHING_NONE;
+            break;
+        case SPELLFAMILY_MAGE:
+        {
+            // Frostbite
+            if (spellproto->SpellFamilyFlags[1] & 0x80000000)
+                return DIMINISHING_TRIGGER_ROOT;
+            //Shattered Barrier: only flag SpellFamilyFlags[0] = 0x00080000 shared
+            //by most frost spells, using id instead
+            if (spellproto->Id == 55080)
+                return DIMINISHING_TRIGGER_ROOT;
+            // Frost Nova / Freeze (Water Elemental)
+            if (spellproto->SpellIconID == 193)
+                return DIMINISHING_CONTROL_ROOT;
+            break;
+        }
+        case SPELLFAMILY_ROGUE:
+        {
+            // Sap 0x80 Gouge 0x8
+            if (spellproto->SpellFamilyFlags[0] & 0x88)
+                return DIMINISHING_POLYMORPH;
+            // Blind
+            else if (spellproto->SpellFamilyFlags[0] & 0x1000000)
+                return DIMINISHING_FEAR_BLIND;
+            // Cheap Shot
+            else if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return DIMINISHING_CHEAPSHOT_POUNCE;
+            // Crippling poison - Limit to 10 seconds in PvP (No SpellFamilyFlags)
+            else if (spellproto->SpellIconID == 163)
+                return DIMINISHING_LIMITONLY;
+            break;
+        }
+        case SPELLFAMILY_WARLOCK:
+        {
+            // Death Coil
+            if (spellproto->SpellFamilyFlags[0] & 0x80000)
+                return DIMINISHING_DEATHCOIL;
+            // Curses/etc
+            else if (spellproto->SpellFamilyFlags[0] & 0x80000000)
+                return DIMINISHING_LIMITONLY;
+            // Howl of Terror
+            else if (spellproto->SpellFamilyFlags[1] & 0x8)
+                return DIMINISHING_FEAR_BLIND;
+            // Seduction
+            else if (spellproto->SpellFamilyFlags[0] & 0x40000000)
+                return DIMINISHING_FEAR_BLIND;
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            // Pounce
+            if (spellproto->SpellFamilyFlags[0] & 0x20000)
+                return DIMINISHING_CHEAPSHOT_POUNCE;
+            // Cyclone
+            else if (spellproto->SpellFamilyFlags[1] & 0x20)
+                return DIMINISHING_CYCLONE;
+            // Entangling Roots: to force natures grasp proc to be control root
+            else if (spellproto->SpellFamilyFlags[0] & 0x00000200)
+                return DIMINISHING_CONTROL_ROOT;
+            // Faerie Fire
+            else if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return DIMINISHING_LIMITONLY;
+            break;
+        }
+        case SPELLFAMILY_WARRIOR:
+        {
+            // Hamstring - limit duration to 10s in PvP
+            if (spellproto->SpellFamilyFlags[0] & 0x2)
+                return DIMINISHING_LIMITONLY;
+            // Intimidating Shout
+            else if (spellproto->SpellFamilyFlags[0] & 0x40000)
+                return DIMINISHING_FEAR_BLIND;
+            // Charge Stun
+            else if (spellproto->SpellFamilyFlags[0] & 0x01000000)
+                return DIMINISHING_NONE;
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Repentance
+            if (spellproto->SpellFamilyFlags[0] & 0x4)
+                return DIMINISHING_POLYMORPH;
+            break;
+        }
+        case SPELLFAMILY_DEATHKNIGHT:
+        {
+            // Hungering Cold (no flags)
+            if (spellproto->SpellIconID == 2797)
+                return DIMINISHING_POLYMORPH;
+            // Mark of Blood
+            else if ((spellproto->SpellFamilyFlags[0] & 0x10000000)
+                && spellproto->SpellIconID == 2285)
+                return DIMINISHING_LIMITONLY;
+            break;
+        }
+        case SPELLFAMILY_HUNTER:
+        {
+            // Hunter's mark
+            if ((spellproto->SpellFamilyFlags[0] & 0x400) && spellproto->SpellIconID == 538)
+                return DIMINISHING_LIMITONLY;
+            // Scatter Shot
+            if ((spellproto->SpellFamilyFlags[0] & 0x40000) && spellproto->SpellIconID == 132)
+                return DIMINISHING_NONE;
+            break;
+        }
+        default:
+            break;
+    }
+
+    // Get by mechanic
+    uint32 mechanic = GetAllSpellMechanicMask(spellproto);
+    if (mechanic == MECHANIC_NONE)          return DIMINISHING_NONE;
+    if (mechanic & ((1<<MECHANIC_STUN) |
+                    (1<<MECHANIC_SHACKLE))) return triggered ? DIMINISHING_TRIGGER_STUN : DIMINISHING_CONTROL_STUN;
+    if (mechanic & ((1<<MECHANIC_SLEEP) |
+                    (1<<MECHANIC_FREEZE))) return DIMINISHING_FREEZE_SLEEP;
+    if (mechanic & (1<<MECHANIC_POLYMORPH)) return DIMINISHING_POLYMORPH;
+    if (mechanic & (1<<MECHANIC_ROOT))      return triggered ? DIMINISHING_TRIGGER_ROOT : DIMINISHING_CONTROL_ROOT;
+    if (mechanic & ((1<<MECHANIC_FEAR) |
+                    (1<<MECHANIC_TURN)))    return DIMINISHING_FEAR_BLIND;
+    if (mechanic & (1<<MECHANIC_CHARM))     return DIMINISHING_CHARM;
+    if (mechanic & (1<<MECHANIC_SILENCE))   return DIMINISHING_SILENCE;
+    if (mechanic & (1<<MECHANIC_DISARM))    return DIMINISHING_DISARM;
+    if (mechanic & (1<<MECHANIC_FREEZE))    return DIMINISHING_FREEZE_SLEEP;
+    if (mechanic & ((1<<MECHANIC_KNOCKOUT) |
+                    (1<<MECHANIC_SAPPED)))  return DIMINISHING_KNOCKOUT;
+    if (mechanic & (1<<MECHANIC_BANISH))    return DIMINISHING_BANISH;
+    if (mechanic & (1<<MECHANIC_HORROR))    return DIMINISHING_DEATHCOIL;
+
+    // Get by effect
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellproto->EffectApplyAuraName[i] == SPELL_AURA_MOD_TAUNT)
+            return DIMINISHING_TAUNT;
+    }
+    return DIMINISHING_NONE;
+}
+
+int32 GetDiminishingReturnsLimitDuration(DiminishingGroup group, SpellEntry const* spellproto)
+{
+    if (!IsDiminishingReturnsGroupDurationLimited(group))
+        return 0;
+
+    // Explicit diminishing duration
+    switch(spellproto->SpellFamilyName)
+    {
+        case SPELLFAMILY_HUNTER:
+        {
+            // Wyvern Sting
+            if (spellproto->SpellFamilyFlags[1] & 0x1000)
+                return 6 * IN_MILLISECONDS;
+            // Hunter's Mark
+            if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return 120 * IN_MILLISECONDS;
+            break;
+        }
+        case SPELLFAMILY_PALADIN:
+        {
+            // Repentance - limit to 6 seconds in PvP
+            if (spellproto->SpellFamilyFlags[0] & 0x4)
+                return 6 * IN_MILLISECONDS;
+            break;
+        }
+        case SPELLFAMILY_DRUID:
+        {
+            // Faerie Fire - limit to 40 seconds in PvP (3.1)
+            if (spellproto->SpellFamilyFlags[0] & 0x400)
+                return 40 * IN_MILLISECONDS;
+            break;
+        }
+        default:
+            break;
+    }
+
+    return 10 * IN_MILLISECONDS;
+}
+
+bool IsDiminishingReturnsGroupDurationLimited(DiminishingGroup group)
+{
+    switch(group)
+    {
+        case DIMINISHING_CONTROL_STUN:
+        case DIMINISHING_TRIGGER_STUN:
+        case DIMINISHING_FREEZE_SLEEP:
+        case DIMINISHING_CONTROL_ROOT:
+        case DIMINISHING_TRIGGER_ROOT:
+        case DIMINISHING_FEAR_BLIND:
+        case DIMINISHING_CHARM:
+        case DIMINISHING_POLYMORPH:
+        case DIMINISHING_KNOCKOUT:
+        case DIMINISHING_CYCLONE:
+        case DIMINISHING_BANISH:
+        case DIMINISHING_LIMITONLY:
+        case DIMINISHING_CHEAPSHOT_POUNCE:
+            return true;
+        default:
+            return false;
+    }
+}
+
+DiminishingLevels GetDiminishingReturnsMaxLevel(DiminishingGroup group)
+{
+    switch(group)
+    {
+        case DIMINISHING_TAUNT:
+            return DIMINISHING_LEVEL_TAUNT_IMMUNE;
+        default:
+            return DIMINISHING_LEVEL_IMMUNE;
+    }
+}
+
+DiminishingReturnsType GetDiminishingReturnsGroupType(DiminishingGroup group)
+{
+    switch(group)
+    {
+        case DIMINISHING_TAUNT:
+        case DIMINISHING_CONTROL_STUN:
+        case DIMINISHING_TRIGGER_STUN:
+        case DIMINISHING_CHEAPSHOT_POUNCE:
+        case DIMINISHING_CYCLONE:
+            return DRTYPE_ALL;
+        case DIMINISHING_FEAR_BLIND:
+        case DIMINISHING_CONTROL_ROOT:
+        case DIMINISHING_TRIGGER_ROOT:
+        case DIMINISHING_CHARM:
+        case DIMINISHING_POLYMORPH:
+        case DIMINISHING_SILENCE:
+        case DIMINISHING_DISARM:
+        case DIMINISHING_DEATHCOIL:
+        case DIMINISHING_FREEZE_SLEEP:
+        case DIMINISHING_BANISH:
+        case DIMINISHING_KNOCKOUT:
+            return DRTYPE_PLAYER;
+        default:
+            break;
+    }
+
+    return DRTYPE_NONE;
+}
+
+bool SpellArea::IsFitToRequirements(Player const* player, uint32 newZone, uint32 newArea) const
+{
+
+    if (gender != GENDER_NONE)                   // not in expected gender
+        if (!player || gender != player->getGender())
+            return false;
+
+    if (raceMask)                                // not in expected race
+        if (!player || !(raceMask & player->getRaceMask()))
+            return false;
+
+    if (areaId)                                  // not in expected zone
+        if (newZone != areaId && newArea != areaId)
+            return false;
+
+    if (questStart)                              // not in expected required quest state
+        if (!player || ((!questStartCanActive || !player->IsActiveQuest(questStart)) && !player->GetQuestRewardStatus(questStart)))
+            return false;
+
+    if (questEnd)                                // not in expected forbidden quest state
+        if (!player || player->GetQuestRewardStatus(questEnd))
+            return false;
+
+    if (auraSpell)                               // not have expected aura
+        if (!player || (auraSpell > 0 && !player->HasAura(auraSpell)) || (auraSpell < 0 && player->HasAura(-auraSpell)))
+            return false;
+
+    // Extra conditions -- leaving the possibility add extra conditions...
+    switch(spellId)
+    {
+        case 58600: // No fly Zone - Dalaran
+            if (!player)
+                return false;
+
+            AreaTableEntry const* pArea = GetAreaEntryByAreaID(player->GetAreaId());
+            if (!(pArea && pArea->flags & AREA_FLAG_NO_FLY_ZONE))
+                return false;
+            if (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY))
+                return false;
+            break;
+    }
+
+    return true;
+}
+
+//-----------TRINITY-------------
+
+bool SpellMgr::CanAurasStack(SpellEntry const *spellInfo_1, SpellEntry const *spellInfo_2, bool sameCaster) const
+{
+    SpellSpecific spellSpec_1 = GetSpellSpecific(spellInfo_1);
+    SpellSpecific spellSpec_2 = GetSpellSpecific(spellInfo_2);
+    if (spellSpec_1 && spellSpec_2)
+        if (IsSingleFromSpellSpecificPerTarget(spellSpec_1, spellSpec_2)
+            || (sameCaster && IsSingleFromSpellSpecificPerCaster(spellSpec_1, spellSpec_2)))
+            return false;
+
+    SpellGroupStackRule stackRule = CheckSpellGroupStackRules(spellInfo_1->Id, spellInfo_2->Id);
+    if (stackRule)
+    {
+        if (stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE)
+            return false;
+        if (sameCaster && stackRule == SPELL_GROUP_STACK_RULE_EXCLUSIVE_FROM_SAME_CASTER)
+            return false;
+    }
+
+    if (spellInfo_1->SpellFamilyName != spellInfo_2->SpellFamilyName)
+        return true;
+
+    if (!sameCaster)
+    {
+        if (spellInfo_1->AttributesEx & SPELL_ATTR_EX_STACK_FOR_DIFF_CASTERS
+            || spellInfo_1->AttributesEx3 & SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS)
+            return true;
+
+        if (spellInfo_1 == spellInfo_2 && spellInfo_1->Id == 57669)
+            return false;
+
+        // check same periodic auras
+        for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            switch(spellInfo_1->EffectApplyAuraName[i])
+            {
+                // DOT or HOT from different casters will stack
+                case SPELL_AURA_PERIODIC_DAMAGE:
+                case SPELL_AURA_PERIODIC_DUMMY:
+                case SPELL_AURA_PERIODIC_HEAL:
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
+                case SPELL_AURA_PERIODIC_ENERGIZE:
+                case SPELL_AURA_PERIODIC_MANA_LEECH:
+                case SPELL_AURA_PERIODIC_LEECH:
+                case SPELL_AURA_POWER_BURN_MANA:
+                case SPELL_AURA_OBS_MOD_POWER:
+                case SPELL_AURA_OBS_MOD_HEALTH:
+                case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+                    return true;
+                default:
+                    break;
+            }
+        }
+    }
+
+    uint32 spellId_1 = GetLastSpellInChain(spellInfo_1->Id);
+    uint32 spellId_2 = GetLastSpellInChain(spellInfo_2->Id);
+
+    // same spell
+    if (spellId_1 == spellId_2)
+    {
+        // Hack for Incanter's Absorption
+        if (spellId_1 == 44413)
+            return true;
+        // same spell with same caster should not stack
+        return false;
+    }
+
+    return true;
+}
+
+bool CanSpellDispelAura(SpellEntry const * dispelSpell, SpellEntry const * aura)
+{
+    // These auras (like ressurection sickness) can't be dispelled
+    if (aura->Attributes & SPELL_ATTR_NEGATIVE_1)
+        return false;
+
+    // These spells (like Mass Dispel) can dispell all auras
+    if (dispelSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return true;
+
+    // These auras (like Divine Shield) can't be dispelled
+    if (aura->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return false;
+
+    // These auras (Cyclone for example) are not dispelable
+    if (aura->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
+        return false;
+
+    return true;
+}
+
+bool CanSpellPierceImmuneAura(SpellEntry const * pierceSpell, SpellEntry const * aura)
+{
+    // these spells pierce all avalible spells (Resurrection Sickness for example)
+    if (pierceSpell->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY)
+        return true;
+
+    // these spells (Cyclone for example) can pierce all...
+    if ((pierceSpell->AttributesEx & SPELL_ATTR_EX_UNAFFECTED_BY_SCHOOL_IMMUNE)
+        // ...but not these (Divine shield for example)
+        && !(aura && (aura->Mechanic == MECHANIC_IMMUNE_SHIELD || aura->Mechanic == MECHANIC_INVULNERABILITY)))
+        return true;
+
+    return false;
+}
+
+void SpellMgr::LoadSpellEnchantProcData()
+{
+    mSpellEnchantProcEventMap.clear();                             // need for reload case
+
+    uint32 count = 0;
+
+    //                                                  0         1           2         3
+    QueryResult result = WorldDatabase.Query("SELECT entry, customChance, PPMChance, procEx FROM spell_enchant_proc_data");
+    if (!result)
+    {
+        barGoLink bar(1);
+
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u spell enchant proc event conditions", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        uint32 enchantId = fields[0].GetUInt32();
+
+        SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchantId);
+        if (!ench)
+        {
+            sLog.outErrorDb("Enchancment %u listed in `spell_enchant_proc_data` does not exist", enchantId);
+            continue;
+        }
+
+        SpellEnchantProcEntry spe;
+
+        spe.customChance = fields[1].GetUInt32();
+        spe.PPMChance = fields[2].GetFloat();
+        spe.procEx = fields[3].GetUInt32();
+
+        mSpellEnchantProcEventMap[enchantId] = spe;
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u enchant proc data definitions", count);
+}
+
+void SpellMgr::LoadSpellRequired()
+{
+    mSpellsReqSpell.clear();                                   // need for reload case
+    mSpellReq.clear();                                         // need for reload case
+
+    QueryResult result = WorldDatabase.Query("SELECT spell_id, req_spell from spell_required");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded 0 spell required records");
+        sLog.outErrorDb("`spell_required` table is empty!");
+        return;
+    }
+    uint32 rows = 0;
+
+    barGoLink bar(result->GetRowCount());
+    do
+    {
+        bar.step();
+        Field *fields = result->Fetch();
+
+        uint32 spell_id =  fields[0].GetUInt32();
+        uint32 spell_req = fields[1].GetUInt32();
+        // check if chain is made with valid first spell
+        SpellEntry const * spell = sSpellStore.LookupEntry(spell_id);
+        if (!spell)
+        {
+            sLog.outErrorDb("spell_id %u in `spell_required` table is not found in dbcs, skipped", spell_id);
+            continue;
+        }
+        SpellEntry const * req_spell = sSpellStore.LookupEntry(spell_req);
+        if (!req_spell)
+        {
+            sLog.outErrorDb("req_spell %u in `spell_required` table is not found in dbcs, skipped", spell_req);
+            continue;
+        }
+        if (GetFirstSpellInChain(spell_id) == GetFirstSpellInChain(spell_req))
+        {
+            sLog.outErrorDb("req_spell %u and spell_id %u in `spell_required` table are ranks of the same spell, entry not needed, skipped", spell_req, spell_id);
+            continue;
+        }
+        if (IsSpellRequiringSpell(spell_id, spell_req))
+        {
+            sLog.outErrorDb("duplicated entry of req_spell %u and spell_id %u in `spell_required`, skipped", spell_req, spell_id);
+            continue;
+        }
+
+        mSpellReq.insert (std::pair<uint32, uint32>(spell_id, spell_req));
+        mSpellsReqSpell.insert (std::pair<uint32, uint32>(spell_req, spell_id));
+        ++rows;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell required records", rows);
+}
+
+void SpellMgr::LoadSpellRanks()
+{
+    mSpellChains.clear();                                   // need for reload case
+
+    QueryResult result = WorldDatabase.Query("SELECT first_spell_id, spell_id, rank from spell_ranks ORDER BY first_spell_id , rank");
+
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+
+        sLog.outString();
+        sLog.outString(">> Loaded 0 spell rank records");
+        sLog.outErrorDb("`spell_ranks` table is empty!");
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    uint32 rows = 0;
+    bool finished = false;
+
+    do
+    {
+                        // spellid, rank
+        std::list < std::pair < int32, int32 > > rankChain;
+        int32 currentSpell = -1;
+        int32 lastSpell = -1;
+
+        // fill one chain
+        while (currentSpell == lastSpell && !finished)
+        {
+            Field *fields = result->Fetch();
+
+            currentSpell = fields[0].GetUInt32();
+            if (lastSpell == -1)
+                lastSpell = currentSpell;
+            uint32 spell_id = fields[1].GetUInt32();
+            uint32 rank = fields[2].GetUInt32();
+
+            // don't drop the row if we're moving to the next rank
+            if (currentSpell == lastSpell)
+            {
+                bar.step();
+                rankChain.push_back(std::make_pair(spell_id, rank));
+                if (!result->NextRow())
+                    finished = true;
+            }
+            else
+                break;
+        }
+        // check if chain is made with valid first spell
+        SpellEntry const * first = sSpellStore.LookupEntry(lastSpell);
+        if (!first)
+        {
+            sLog.outErrorDb("Spell rank identifier(first_spell_id) %u listed in `spell_ranks` does not exist!", lastSpell);
+            continue;
+        }
+        // check if chain is long enough
+        if (rankChain.size() < 2)
+        {
+            sLog.outErrorDb("There is only 1 spell rank for identifier(first_spell_id) %u in `spell_ranks`, entry is not needed!", lastSpell);
+            continue;
+        }
+        int32 curRank = 0;
+        bool valid = true;
+        // check spells in chain
+        for (std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin() ; itr!= rankChain.end(); ++itr)
+        {
+            SpellEntry const * spell = sSpellStore.LookupEntry(itr->first);
+            if (!spell)
+            {
+                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not exist!", itr->first, itr->second, lastSpell);
+                valid = false;
+                break;
+            }
+            ++curRank;
+            if (itr->second != curRank)
+            {
+                sLog.outErrorDb("Spell %u (rank %u) listed in `spell_ranks` for chain %u does not have proper rank value(should be %u)!", itr->first, itr->second, lastSpell, curRank);
+                valid = false;
+                break;
+            }
+        }
+        if (!valid)
+            continue;
+        int32 prevRank = 0;
+        // insert the chain
+        std::list<std::pair<int32, int32> >::iterator itr = rankChain.begin();
+        do
+        {
+            ++rows;
+            int32 addedSpell = itr->first;
+            mSpellChains[addedSpell].first = lastSpell;
+            mSpellChains[addedSpell].last = rankChain.back().first;
+            mSpellChains[addedSpell].rank = itr->second;
+            mSpellChains[addedSpell].prev = prevRank;
+            prevRank = addedSpell;
+            ++itr;
+            if (itr == rankChain.end())
+            {
+                mSpellChains[addedSpell].next = 0;
+                break;
+            }
+            else
+                mSpellChains[addedSpell].next = itr->first;
+        }
+        while (true);
+    } while (!finished);
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u spell rank records", rows);
+}
+
+// set data in core for now
+void SpellMgr::LoadSpellCustomAttr()
+{
+    mSpellCustomAttr.resize(GetSpellStore()->GetNumRows());
+
+    barGoLink bar(GetSpellStore()->GetNumRows());
+
+    uint32 count = 0;
+
+    SpellEntry *spellInfo;
+    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
+    {
+        bar.step();
+
+        mSpellCustomAttr[i] = 0;
+        spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
+        if (!spellInfo)
+            continue;
+
+        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            switch (spellInfo->Effect[j])
+            {
+                case SPELL_EFFECT_SCHOOL_DAMAGE:
+                case SPELL_EFFECT_WEAPON_DAMAGE:
+                case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+                case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                case SPELL_EFFECT_HEAL:
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_DIRECT_DAMAGE;
+                    count++;
+                    break;
+                case SPELL_EFFECT_CHARGE:
+                case SPELL_EFFECT_CHARGE_DEST:
+                case SPELL_EFFECT_JUMP:
+                case SPELL_EFFECT_JUMP_DEST:
+                case SPELL_EFFECT_LEAP_BACK:
+                    if (!spellInfo->speed && !spellInfo->SpellFamilyName)
+                        spellInfo->speed = SPEED_CHARGE;
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_CHARGE;
+                    count++;
+                    break;
+                case SPELL_EFFECT_PICKPOCKET:
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_PICKPOCKET;
+                    break;
+                case SPELL_EFFECT_TRIGGER_SPELL:
+                    if (IsPositionTarget(spellInfo->EffectImplicitTargetA[j]) ||
+                        spellInfo->Targets & (TARGET_FLAG_SOURCE_LOCATION|TARGET_FLAG_DEST_LOCATION))
+                        spellInfo->Effect[j] = SPELL_EFFECT_TRIGGER_MISSILE;
+                    count++;
+                    break;
+            }
+
+            switch (SpellTargetType[spellInfo->EffectImplicitTargetA[j]])
+            {
+                case TARGET_TYPE_UNIT_TARGET:
+                case TARGET_TYPE_DEST_TARGET:
+                    spellInfo->Targets |= TARGET_FLAG_UNIT;
+                    count++;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        for (uint8 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            switch (spellInfo->EffectApplyAuraName[j])
+            {
+                case SPELL_AURA_MOD_POSSESS:
+                case SPELL_AURA_MOD_CONFUSE:
+                case SPELL_AURA_MOD_CHARM:
+                case SPELL_AURA_AOE_CHARM:
+                case SPELL_AURA_MOD_FEAR:
+                case SPELL_AURA_MOD_STUN:
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
+                    count++;
+                    break;
+            }
+        }
+
+        if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
+        {
+            if (spellInfo->Mechanic != 0 &&
+                spellInfo->Mechanic != MECHANIC_INFECTED)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if (spellInfo->EffectMechanic[0] != 0 &&
+                     spellInfo->EffectMechanic[0] != MECHANIC_INFECTED &&
+                     spellInfo->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if (spellInfo->EffectMechanic[1] != 0 &&
+                     spellInfo->EffectMechanic[1] != MECHANIC_INFECTED)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if (spellInfo->Effect[0] == SPELL_EFFECT_DISPEL ||
+                     spellInfo->Effect[1] == SPELL_EFFECT_DISPEL ||
+                     spellInfo->Effect[2] == SPELL_EFFECT_DISPEL)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if (spellInfo->Effect[0] == SPELL_EFFECT_STEAL_BENEFICIAL_BUFF ||
+                     spellInfo->Effect[1] == SPELL_EFFECT_STEAL_BENEFICIAL_BUFF ||
+                     spellInfo->Effect[2] == SPELL_EFFECT_STEAL_BENEFICIAL_BUFF)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if (spellInfo->Effect[0] == SPELL_EFFECT_POWER_BURN ||
+                     spellInfo->Effect[1] == SPELL_EFFECT_POWER_BURN ||
+                     spellInfo->Effect[2] == SPELL_EFFECT_POWER_BURN)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if (spellInfo->Effect[0] == SPELL_EFFECT_POWER_DRAIN ||
+                     spellInfo->Effect[1] == SPELL_EFFECT_POWER_DRAIN ||
+                     spellInfo->Effect[2] == SPELL_EFFECT_POWER_DRAIN)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if (spellInfo->EffectApplyAuraName[0] == SPELL_AURA_PERIODIC_MANA_LEECH ||
+                     spellInfo->EffectApplyAuraName[1] == SPELL_AURA_PERIODIC_MANA_LEECH ||
+                     spellInfo->EffectApplyAuraName[2] == SPELL_AURA_PERIODIC_MANA_LEECH)
+            {
+                mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                count++;
+            }
+            else if ((spellInfo->Dispel == DISPEL_POISON) ||
+                (spellInfo->Dispel == DISPEL_CURSE) ||
+                (spellInfo->Dispel == DISPEL_DISEASE))
+            {
+                if (spellInfo->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE &&
+                    spellInfo->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE &&
+                    spellInfo->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE &&
+                    spellInfo->EffectApplyAuraName[0] != SPELL_AURA_PERIODIC_DAMAGE &&
+                    spellInfo->EffectApplyAuraName[1] != SPELL_AURA_PERIODIC_DAMAGE &&
+                    spellInfo->EffectApplyAuraName[2] != SPELL_AURA_PERIODIC_DAMAGE)
+                {
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_BINARY;
+                    count++;
+                }
+            }
+        }
+
+        if (!_isPositiveEffect(i, 0, false))
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF0;
+            count++;
+        }
+        if (!_isPositiveEffect(i, 1, false))
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF1;
+            count++;
+        }
+        if (!_isPositiveEffect(i, 2, false))
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_NEGATIVE_EFF2;
+            count++;
+        }
+
+        if (spellInfo->SpellVisual[0] == 3879)
+        {
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_BACK;
+            count++;
+        }
+
+        if (spellInfo->activeIconID == 2158)  // flight
+        {
+            spellInfo->Attributes |= SPELL_ATTR_PASSIVE;
+            count++;
+        }
+
+        switch(i)
+        {
+        // Natural Shapeshifter
+        case 16834:
+        case 16835:
+        {
+            SpellEntry const* spellInf = sSpellStore.LookupEntry(16833);
+            spellInfo->DurationIndex = spellInf->DurationIndex;
+            count++;
+            break;
+        }
+        // Bind
+        case 3286:
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_TARGET_ENEMY;
+            spellInfo->EffectImplicitTargetA[1] = TARGET_UNIT_TARGET_ENEMY;
+            count++;
+            break;
+        // Heroism
+        case 32182:
+            spellInfo->excludeCasterAuraSpell = 57723; // Exhaustion
+            count++;
+            break;
+        // Blazing Harpoon
+        case 61588:
+            spellInfo->MaxAffectedTargets = 1;
+            count++;
+            break;
+        // Bloodlust
+        case 2825:
+            spellInfo->excludeCasterAuraSpell = 57724; // Sated
+            count++;
+            break;
+        // Heart of the Crusader
+        case 20335:
+        case 20336:
+        case 20337:
+        // Glyph of Life Tap
+        case 63320:
+        // Entries were not updated after spell effect change, we have to do that manually :/
+            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_CAN_PROC_TRIGGERED;
+            count++;
+            break;
+        case 16007: // Draco-Incarcinatrix 900
+            // was 46, but effect is aura effect
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_NEARBY_ENTRY;
+            spellInfo->EffectImplicitTargetB[0] = TARGET_DST_NEARBY_ENTRY;
+            count++;
+            break;
+        case 26029: // dark glare
+        case 37433: // spout
+        case 43140: case 43215: // flame breath
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_CONE_LINE;
+            count++;
+            break;
+        case 33778:
+            {
+                SpellEntry const* spellInf = sSpellStore.LookupEntry(33763);
+                spellInfo->SpellFamilyFlags[0] = spellInf->SpellFamilyFlags[0];
+                spellInfo->SpellFamilyFlags[1] = spellInf->SpellFamilyFlags[1];
+                spellInfo->SpellFamilyFlags[2] = spellInf->SpellFamilyFlags[2];
+                count++;
+                break;
+            }
+        case 24340: case 26558: case 28884:     // Meteor
+        case 36837: case 38903: case 41276:     // Meteor
+        case 57467:                             // Meteor
+        case 26789:                             // Shard of the Fallen Star
+        case 31436:                             // Malevolent Cleave
+        case 35181:                             // Dive Bomb
+        case 40810: case 43267: case 43268:     // Saber Lash
+        case 42384:                             // Brutal Swipe
+        case 45150:                             // Meteor Slash
+        case 64422: case 64688:                 // Sonic Screech
+        case 72373:                             // Shared Suffering
+        case 71904:                             // Chaos Bane
+        case 70492: case 72505:                 // Ooze Eruption
+        case 72624: case 72625:                 // Ooze Eruption
+            // ONLY SPELLS WITH SPELLFAMILY_GENERIC and EFFECT_SCHOOL_DAMAGE
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_SHARE_DAMAGE;
+            count++;
+            break;
+        case 59725:                             // Improved Spell Reflection - aoe aura
+            // Target entry seems to be wrong for this spell :/
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_PARTY_CASTER;
+            spellInfo->EffectRadiusIndex[0] = 45;
+            count++;
+            break;
+        case 27820:                             // Mana Detonation
+        //case 28062: case 39090:                 // Positive/Negative Charge
+        //case 28085: case 39093:
+        case 69782: case 69796:                 // Ooze Flood
+        case 69798: case 69801:                 // Ooze Flood
+        case 69538: case 69553: case 69610:     // Ooze Combine
+	    case 71614:                             // Ice Lock
+
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
+            count++;
+            break;
+        case 44978: case 45001: case 45002:     // Wild Magic
+        case 45004: case 45006: case 45010:     // Wild Magic
+        case 31347: // Doom
+        case 41635: // Prayer of Mending
+        case 44869: // Spectral Blast
+        case 45027: // Revitalize
+        case 45976: // Muru Portal Channel
+        case 39365: // Thundering Storm
+        case 41071: // Raise Dead (HACK)
+        case 52124: // Sky Darkener Assault
+        case 42442: // Vengeance Landing Cannonfire
+        case 45863: // Cosmetic - Incinerate to Random Target
+        case 25425: // Shoot
+        case 45761: // Shoot
+        case 42611: // Shoot
+        case 62374: // Pursued
+            spellInfo->MaxAffectedTargets = 1;
+            count++;
+            break;
+        case 52479: // Gift of the Harvester
+            spellInfo->MaxAffectedTargets = 1;
+            // a trap always has dst = src?
+            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_CASTER;
+            spellInfo->EffectImplicitTargetA[1] = TARGET_DST_CASTER;
+            count++;
+            break;
+        case 41376: // Spite
+        case 39992: // Needle Spine
+        case 29576: // Multi-Shot
+        case 40816: // Saber Lash
+        case 37790: // Spread Shot
+        case 46771: // Flame Sear
+        case 45248: // Shadow Blades
+        case 41303: // Soul Drain
+        case 54172: // Divine Storm (heal)
+        case 29213: // Curse of the Plaguebringer - Noth
+        case 28542: // Life Drain - Sapphiron
+        case 66588: // Flaming Spear
+        case 54171: // Divine Storm
+            spellInfo->MaxAffectedTargets = 3;
+            count++;
+            break;
+        case 38310: // Multi-Shot
+        case 53385: // Divine Storm (Damage)
+            spellInfo->MaxAffectedTargets = 4;
+            count++;
+            break;
+        case 42005: // Bloodboil
+        case 38296: // Spitfire Totem
+        case 37676: // Insidious Whisper
+        case 46008: // Negative Energy
+        case 45641: // Fire Bloom
+        case 55665: // Life Drain - Sapphiron (H)
+        case 28796: // Poison Bolt Volly - Faerlina
+            spellInfo->MaxAffectedTargets = 5;
+            count++;
+            break;
+        case 40827: // Sinful Beam
+        case 40859: // Sinister Beam
+        case 40860: // Vile Beam
+        case 40861: // Wicked Beam
+        case 54835: // Curse of the Plaguebringer - Noth (H)
+        case 54098: // Poison Bolt Volly - Faerlina (H)
+            spellInfo->MaxAffectedTargets = 10;
+            count++;
+            break;
+        case 50312: // Unholy Frenzy
+            spellInfo->MaxAffectedTargets = 15;
+            count++;
+            break;
+        case 38794: case 33711: //Murmur's Touch
+            spellInfo->MaxAffectedTargets = 1;
+            spellInfo->EffectTriggerSpell[0] = 33760;
+            count++;
+            break;
+        case 17941:    // Shadow Trance
+        case 22008:    // Netherwind Focus
+        case 31834:    // Light's Grace
+        case 34754:    // Clearcasting
+        case 34936:    // Backlash
+        case 48108:    // Hot Streak
+        case 51124:    // Killing Machine
+        case 54741:    // Firestarter
+        case 57761:    // Fireball!
+        case 39805:    // Lightning Overload
+        case 64823:    // Item - Druid T8 Balance 4P Bonus
+        case 67210:    // Item - Rogue T9 2P Bonus Clearcasting
+        case 44401:
+            spellInfo->procCharges = 1;
+            count++;
+            break;
+        case 44544:    // Fingers of Frost
+            spellInfo->EffectSpellClassMask[0] = flag96(685904631, 1151048, 0);
+            count++;
+            break;
+        case 74396:    // Fingers of Frost visual buff
+            spellInfo->procCharges = 2;
+            spellInfo->StackAmount = 0;
+            count++;
+            break;
+			case 53256:
+        case 53259:
+        case 53260:
+            spellInfo->procCharges = 2;
+            count++;
+            break;
+        case 28200:    // Ascendance (Talisman of Ascendance trinket)
+            spellInfo->procCharges = 6;
+            count++;
+            break;
+        case 47201:    // Everlasting Affliction
+        case 47202:
+        case 47203:
+        case 47204:
+        case 47205:
+            // add corruption to affected spells
+            spellInfo->EffectSpellClassMask[1][0] |= 2;
+            count++;
+            break;
+        case 51852:    // The Eye of Acherus (no spawn in phase 2 in db)
+            spellInfo->EffectMiscValue[0] |= 1;
+            count++;
+            break;
+        case 52025:    // Cleansing Totem Effect
+            spellInfo->EffectDieSides[1] = 1;
+            count++;
+            break;
+        case 51904:     // Summon Ghouls On Scarlet Crusade (core does not know the triggered spell is summon spell)
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
+            count++;
+            break;
+        case 29809:     // Desecration Arm - 36 instead of 37 - typo? :/
+            spellInfo->EffectRadiusIndex[0] = 37;
+            count++;
+            break;
+        // Master Shapeshifter: missing stance data for forms other than bear - bear version has correct data
+        // To prevent aura staying on target after talent unlearned
+        case 48420:
+            spellInfo->Stances = 1 << (FORM_CAT - 1);
+            count++;
+            break;
+        case 48421:
+            spellInfo->Stances = 1 << (FORM_MOONKIN - 1);
+            count++;
+            break;
+        case 48422:
+            spellInfo->Stances = 1 << (FORM_TREE - 1);
+            count++;
+            break;
+        case 30421:     // Nether Portal - Perseverence
+            spellInfo->EffectBasePoints[2] += 30000;
+            count++;
+            break;
+        // some dummy spell only has dest, should push caster in this case
+        case 62324: // Throw Passenger
+            spellInfo->Targets |= TARGET_FLAG_UNIT_CASTER;
+            count++;
+            break;
+        case 51735: // Ebon Plague
+        case 51734:
+        case 51726:
+            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_STACK_FOR_DIFF_CASTERS;
+            spellInfo->SpellFamilyFlags[2] = 0x10;
+            count++;
+            break;
+        case 41013:     // Parasitic Shadowfiend Passive
+            spellInfo->EffectApplyAuraName[0] = 4; // proc debuff, and summon infinite fiends
+            count++;
+            break;
+        case 27892:     // To Anchor 1
+        case 27928:     // To Anchor 1
+        case 27935:     // To Anchor 1
+        case 27915:     // Anchor to Skulls
+        case 27931:     // Anchor to Skulls
+        case 27937:     // Anchor to Skulls
+            spellInfo->rangeIndex = 13;
+            count++;
+            break;
+        case 48743: // Death Pact
+            spellInfo->AttributesEx &= ~SPELL_ATTR_EX_CANT_TARGET_SELF;
+            count++;
+            break;
+        // target allys instead of enemies, target A is src_caster, spells with effect like that have ally target
+        // this is the only known exception, probably just wrong data
+        case 29214: // Wrath of the Plaguebringer
+        case 54836: // Wrath of the Plaguebringer
+            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_AREA_ALLY_SRC;
+            spellInfo->EffectImplicitTargetB[1] = TARGET_UNIT_AREA_ALLY_SRC;
+            count++;
+            break;
+        case 31687: // Summon Water Elemental
+            // 322-330 switch - effect changed to dummy, target entry not changed in client:(
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
+            count++;
+            break;
+        case 25771: // Forbearance - wrong mechanic immunity in DBC since 3.0.x
+            spellInfo->EffectMiscValue[0] = MECHANIC_IMMUNE_SHIELD;
+            count++;
+            break;
+        case 64321: // Potent Pheromones
+            // spell should dispel area aura, but doesn't have the attribute
+            // may be db data bug, or blizz may keep reapplying area auras every update with checking immunity
+            // that will be clear if we get more spells with problem like this
+            spellInfo->AttributesEx |= SPELL_ATTR_EX_DISPEL_AURAS_ON_IMMUNITY;
+            count++;
+            break;
+        case 69055:     // Saber Lash
+        case 70814:     // Saber Lash
+            spellInfo->EffectRadiusIndex[0] = 8;
+            count++;
+            break;
+        case 69075:     // Bone Storm
+        case 70834:     // Bone Storm
+        case 70835:     // Bone Storm
+        case 70836:     // Bone Storm
+            spellInfo->EffectRadiusIndex[0] = 12;
+            count++;
+            break;
+        case 18500: // Wing Buffet
+        case 33086: // Wild Bite
+        case 49749: // Piercing Blow
+        case 52890: // Penetrating Strike
+        case 53454: // Impale
+        case 59446: // Impale
+        case 62383: // Shatter
+        case 64777: // Machine Gun
+        case 65239: // Machine Gun
+        case 65919: // Impale
+        case 67858: // Impale
+        case 67859: // Impale
+        case 67860: // Impale
+        case 69293: // Wing Buffet
+        case 74439: // Machine Gun
+            mSpellCustomAttr[i] |= SPELL_ATTR_CU_IGNORE_ARMOR;
+            count++;
+            break;
+        case 12051:
+            spellInfo->InterruptFlags |= SPELL_INTERRUPT_FLAG_INTERRUPT;
+            count++;
+            break;
+        // THESE SPELLS ARE WORKING CORRECTLY EVEN WITHOUT THIS HACK
+        // THE ONLY REASON ITS HERE IS THAT CURRENT GRID SYSTEM
+        // DOES NOT ALLOW FAR OBJECT SELECTION (dist > 333)
+        case 70781: // Light's Hammer Teleport
+        case 70856: // Oratory of the Damned Teleport
+        case 70857: // Rampart of Skulls Teleport
+        case 70858: // Deathbringer's Rise Teleport
+        case 70859: // Upper Spire Teleport
+        case 70860: // Frozen Throne Teleport
+        case 70861: // Sindragosa's Lair Teleport
+            spellInfo->EffectImplicitTargetA[0] = TARGET_DST_DB;
+            count++;
+            break;
+        case 63675: // Improved Devouring Plague
+            spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_NO_DONE_BONUS;
+            count++;
+            break;
+        case 53241: // Marked for Death (Rank 1)
+        case 53243: // Marked for Death (Rank 2)
+        case 53244: // Marked for Death (Rank 3)
+        case 53245: // Marked for Death (Rank 4)
+        case 53246: // Marked for Death (Rank 5)
+            spellInfo->EffectSpellClassMask[0] = flag96(423937, 276955137, 2049);
+            count++;
+            break;
+			case 70728: // Exploit Weakness
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
+            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_PET;
+            count++;
+            break;
+			// this is here until targetAuraSpell and alike support SpellDifficulty.dbc
+        case 70459: // Ooze Eruption Search Effect
+            spellInfo->targetAuraSpell = 0;
+            count++;
+            break;
+        case 70840: // Devious Minds
+            spellInfo->EffectImplicitTargetA[0] = TARGET_UNIT_CASTER;
+            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_PET;
+            count++;
+            break;
+        case 71413: // Green Ooze Summon
+        case 71414: // Orange Ooze Summon
+            spellInfo->EffectImplicitTargetA[0] = TARGET_DEST_DEST;
+            count++;
+            break;
+        // THIS IS HERE BECAUSE COOLDOWN ON CREATURE PROCS IS NOT IMPLEMENTED
+        case 71604: // Mutated Strength
+        case 72673: // Mutated Strength
+        case 72674: // Mutated Strength
+        case 72675: // Mutated Strength
+            spellInfo->Effect[1] = 0;
+            count++;
+            break;
+        case 70447: // Volatile Ooze Adhesive
+        case 72836: // Volatile Ooze Adhesive
+        case 72837: // Volatile Ooze Adhesive
+        case 72838: // Volatile Ooze Adhesive
+        case 70672: // Gaseous Bloat
+        case 72455: // Gaseous Bloat
+        case 72832: // Gaseous Bloat
+        case 72833: // Gaseous Bloat
+            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_TARGET_ENEMY;
+            spellInfo->EffectImplicitTargetB[1] = TARGET_UNIT_TARGET_ENEMY;
+            spellInfo->EffectImplicitTargetB[2] = TARGET_UNIT_TARGET_ENEMY;
+            count++;
+            break;
+        case 70911: // Unbound Plague
+        case 72854: // Unbound Plague
+        case 72855: // Unbound Plague
+        case 72856: // Unbound Plague
+            spellInfo->EffectImplicitTargetB[0] = TARGET_UNIT_TARGET_ENEMY;
+            count++;
+            break;
+			case 71708: // Empowered Flare
+			case 72785: // Empowered Flare
+			case 72786: // Empowered Flare
+			case 72787: // Empowered Flare
+				spellInfo->AttributesEx3 |= SPELL_ATTR_EX3_NO_DONE_BONUS;
+				count++;
+				break;
+        default:
+            break;
+        }
+
+        switch(spellInfo->SpellFamilyName)
+        {
+            case SPELLFAMILY_WARRIOR:
+                // Shout
+                if (spellInfo->SpellFamilyFlags[0] & 0x20000 || spellInfo->SpellFamilyFlags[1] & 0x20)
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
+                else
+                    break;
+                count++;
+                break;
+            case SPELLFAMILY_DRUID:
+                // Starfall Target Selection
+                if (spellInfo->SpellFamilyFlags[2] & 0x100)
+                    spellInfo->MaxAffectedTargets = 2;
+                // Starfall AOE Damage
+                else if (spellInfo->SpellFamilyFlags[2] & 0x800000)
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_EXCLUDE_SELF;
+                // Roar
+                else if (spellInfo->SpellFamilyFlags[0] & 0x8)
+                    mSpellCustomAttr[i] |= SPELL_ATTR_CU_AURA_CC;
+                else
+                    break;
+                count++;
+                break;
+                // Do not allow Deadly throw and Slice and Dice to proc twice
+            case SPELLFAMILY_ROGUE:
+                if (spellInfo->SpellFamilyFlags[1] & 0x1 || spellInfo->SpellFamilyFlags[0] & 0x40000)
+                    spellInfo->AttributesEx4 |= SPELL_ATTR_EX4_CANT_PROC_FROM_SELFCAST;
+                else
+                    break;
+                count++;
+                break;
+        }
+    }
+
+    SummonPropertiesEntry *properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(121));
+    properties->Type = SUMMON_TYPE_TOTEM;
+    properties = const_cast<SummonPropertiesEntry*>(sSummonPropertiesStore.LookupEntry(647)); // 52893
+    properties->Type = SUMMON_TYPE_TOTEM;
+
+    CreatureAI::FillAISpellInfo();
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u custom spell attributes", count);
+}
+
+// Fill custom data about enchancments
+void SpellMgr::LoadEnchantCustomAttr()
+{
+    uint32 size = sSpellItemEnchantmentStore.GetNumRows();
+    mEnchantCustomAttr.resize(size);
+
+    barGoLink bar(GetSpellStore()->GetNumRows());
+
+    uint32 count = 0;
+
+    for (uint32 i = 0; i < size; ++i)
+       mEnchantCustomAttr[i] = 0;
+
+    for (uint32 i = 0; i < GetSpellStore()->GetNumRows(); ++i)
+    {
+        bar.step();
+
+        SpellEntry * spellInfo = (SpellEntry*)GetSpellStore()->LookupEntry(i);
+        if (!spellInfo)
+            continue;
+
+        // TODO: find a better check
+        if (!(spellInfo->AttributesEx2 & SPELL_ATTR_EX2_UNK13) || !(spellInfo->Attributes & SPELL_ATTR_NOT_SHAPESHIFT))
+            continue;
+
+        for (uint32 j = 0; j < MAX_SPELL_EFFECTS; ++j)
+        {
+            if (spellInfo->Effect[j] == SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY)
+            {
+                uint32 enchId = spellInfo->EffectMiscValue[j];
+                SpellItemEnchantmentEntry const *ench = sSpellItemEnchantmentStore.LookupEntry(enchId);
+                if (!ench)
+                    continue;
+                mEnchantCustomAttr[enchId] = true;
+                count++;
+                break;
+            }
+        }
+    }
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u custom enchant attributes", count);
+}
+
+void SpellMgr::LoadSpellLinked()
+{
+    mSpellLinkedMap.clear();    // need for reload case
+    uint32 count = 0;
+
+    //                                                0              1             2
+    QueryResult result = WorldDatabase.Query("SELECT spell_trigger, spell_effect, type FROM spell_linked_spell");
+    if (!result)
+    {
+        barGoLink bar(1);
+        bar.step();
+        sLog.outString();
+        sLog.outString(">> Loaded %u linked spells", count);
+        return;
+    }
+
+    barGoLink bar(result->GetRowCount());
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        bar.step();
+
+        int32 trigger = fields[0].GetInt32();
+        int32 effect =  fields[1].GetInt32();
+        int32 type =    fields[2].GetInt32();
+
+        SpellEntry const* spellInfo = sSpellStore.LookupEntry(abs(trigger));
+        if (!spellInfo)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(trigger));
+            continue;
+        }
+        spellInfo = sSpellStore.LookupEntry(abs(effect));
+        if (!spellInfo)
+        {
+            sLog.outErrorDb("Spell %u listed in `spell_linked_spell` does not exist", abs(effect));
+            continue;
+        }
+
+        if (trigger > 0)
+        {
+            switch(type)
+            {
+                case 0: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_CAST; break;
+                case 1: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_HIT;  break;
+                case 2: mSpellCustomAttr[trigger] |= SPELL_ATTR_CU_LINK_AURA; break;
+            }
+        }
+        else
+        {
+            mSpellCustomAttr[-trigger] |= SPELL_ATTR_CU_LINK_REMOVE;
+        }
+
+        if (type) //we will find a better way when more types are needed
+        {
+            if (trigger > 0)
+                trigger += SPELL_LINKED_MAX_SPELLS * type;
+            else
+                trigger -= SPELL_LINKED_MAX_SPELLS * type;
+        }
+        mSpellLinkedMap[trigger].push_back(effect);
+
+        ++count;
+    } while (result->NextRow());
+
+    sLog.outString();
+    sLog.outString(">> Loaded %u linked spells", count);
+}
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1881,12 +1881,22 @@
     {
         if (m_updateTimeSum > m_int_configs[CONFIG_INTERVAL_LOG_UPDATE])
         {
-            sLog.outBasic("Update time diff: %u. Players online: %u.", m_updateTimeSum / m_updateTimeCount, GetActiveSessionCount());
+            uint32 t_diff = m_updateTimeSum / m_updateTimeCount;
+            sLog.outBasic("Update time diff: %u. Players online: %u.", t_diff, GetActiveSessionCount());
             m_updateTimeSum = m_updateTime;
             m_updateTimeCount = 1;
+
+            uint32 t_accounts = GetActiveSessionCount();
+            uint32 t_players = GetPlayerCount();
+            uint64 t_uptime = uint64(time(NULL));
+
+            LoginDatabase.PExecute("INSERT into stats (time, accounts, players, diff, maxdiff, realmid) VALUES (" UI64FMTD ", %u, %u, %u, %u, %u)", t_uptime, t_accounts, t_players, t_diff, m_maxDiff, realmID);
+            m_maxDiff = 0;
         }
         else
         {
+            if (m_maxDiff < m_updateTime)
+                m_maxDiff = m_updateTime;
             m_updateTimeSum += m_updateTime;
             ++m_updateTimeCount;
         }
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -786,6 +786,7 @@
         time_t mail_timer;
         time_t mail_timer_expires;
         uint32 m_updateTime, m_updateTimeSum;
+        uint32 m_maxDiff;
         uint32 m_updateTimeCount;
         uint32 m_currentTime;
 
diff --git a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter1.cpp
@@ -178,30 +178,42 @@
             case PHASE_CHAINED:
                 if (!anchorGUID)
                 {
-                    if (Creature *anchor = me->FindNearestCreature(29521, 30))
+                    Creature *anchor = NULL;
+                    std::list<Creature*> anchors;
+                    me->GetCreatureListWithEntryInGrid(anchors, 29521, 30);
+                    float dist = 99.0f;
+                    if (anchors.empty()) {
+                        sLog.outError("npc_unworthy_initiateAI: empty list");
+                        return;
+                    }
+                    for (std::list<Creature*>::iterator iter = anchors.begin(); iter != anchors.end(); ++iter) 
+                    {
+                        Creature *c = *iter;
+                        float distc = me->GetDistance(c);
+                        if (distc < dist)
+                        {
+                            dist = distc;
+                            anchor = c;
+                        }
+                    }
+                    if (anchor)
                     {
                         anchor->AI()->SetGUID(me->GetGUID());
                         anchor->CastSpell(me, SPELL_SOUL_PRISON_CHAIN, true);
                         anchorGUID = anchor->GetGUID();
                     }
                     else
+                    {
                         sLog.outError("npc_unworthy_initiateAI: unable to find anchor!");
+                        return;
+                    }
 
-                    float dist = 99.0f;
                     GameObject *prison = NULL;
-
                     for (uint8 i = 0; i < 12; ++i)
                     {
-                        if (GameObject* temp_prison = me->FindNearestGameObject(acherus_soul_prison[i],30))
-                        {
-                            if (me->IsWithinDist(temp_prison, dist, false))
-                            {
-                                dist = me->GetDistance2d(temp_prison);
-                                prison = temp_prison;
-                            }
-                        }
+                        if (prison = anchor->FindNearestGameObject(acherus_soul_prison[i],1))
+                            break;
                     }
-
                     if (prison)
                         prison->ResetDoorOrButton();
                     else
@@ -319,10 +331,19 @@
 
     bool OnGossipHello(Player* pPlayer, GameObject* pGo)
     {
-        if (Creature *anchor = pGo->FindNearestCreature(29521, 15))
-            if (uint64 prisonerGUID = anchor->AI()->GetGUID())
-                if (Creature* prisoner = Creature::GetCreature(*pPlayer, prisonerGUID))
+        if (Creature *anchor = pGo->FindNearestCreature(29521, 15)) {
+            if (uint64 prisonerGUID = anchor->AI()->GetGUID()) {
+                if (Creature* prisoner = Creature::GetCreature(*pPlayer, prisonerGUID)) {
                     CAST_AI(npc_unworthy_initiate::npc_unworthy_initiateAI, prisoner->AI())->EventStart(anchor, pPlayer);
+                } else {
+                    sLog.outError("prisoner of trigger not found");
+                }
+            } else {
+                sLog.outError("prisoner of trigger is 0");
+            }
+        } else {
+            sLog.outError("Trigger not found");
+        }
 
         return false;
     }
diff --git a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter5.cpp b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter5.cpp
--- a/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter5.cpp
+++ b/src/server/scripts/EasternKingdoms/ScarletEnclave/chapter5.cpp
@@ -18,7 +18,7 @@
 #include "ScriptPCH.h"
 #include "ScriptedEscortAI.h"
 
-#define LESS_MOB // if you do not have a good server and do not want it to be laggy as hell
+//#define LESS_MOB // if you do not have a good server and do not want it to be laggy as hell
 //Light of Dawn
 enum mograine
 {
@@ -325,6 +325,7 @@
         npc_highlord_darion_mograineAI(Creature *pCreature) : npc_escortAI(pCreature)
         {
             Reset();
+            SetMaxPlayerDistance(90.0f);
         }
 
         bool bIsBattle;
@@ -392,6 +393,11 @@
                 me->Mount(25279);
                 me->SetVisibility(VISIBILITY_ON);
 
+                me->SetSpeed(MOVE_RUN, 1);
+ 
+                me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
+                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+
                 UpdateWorldState(me->GetMap(), WORLD_STATE_REMAINS, 0);
                 //UpdateWorldState(me->GetMap(), WORLD_STATE_COUNTDOWN, 0);
                 UpdateWorldState(me->GetMap(), WORLD_STATE_EVENT_BEGIN, 0);
@@ -1321,11 +1327,9 @@
                                             i->getSource()->CastSpell(i->getSource(), SPELL_THE_LIGHT_OF_DAWN_Q, false);
                                 }
                             }
-                            me->SetVisibility(VISIBILITY_OFF); // respawns another Darion for quest turn in
-                            me->SummonCreature(NPC_HIGHLORD_DARION_MOGRAINE, me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 180000);
-                            JumpToNextStep(1000);
+                            me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
+                            JumpToNextStep(300000);
                             break;
-
                         case 72:
                             SetHoldState(false); // Escort ends
                             JumpToNextStep(25000);
diff --git a/src/server/scripts/EasternKingdoms/ZulGurub/boss_thekal.cpp b/src/server/scripts/EasternKingdoms/ZulGurub/boss_thekal.cpp
--- a/src/server/scripts/EasternKingdoms/ZulGurub/boss_thekal.cpp
+++ b/src/server/scripts/EasternKingdoms/ZulGurub/boss_thekal.cpp
@@ -121,7 +121,13 @@
                     m_pInstance->SetData(TYPE_THEKAL, NOT_STARTED);
             }
 
-            void UpdateAI(const uint32 diff)
+        void DamageTaken(Unit* pDoneBy, uint32 &uiDamage)
+        {
+            if (!PhaseTwo && WasDead)
+                uiDamage = 0;
+        }
+
+        void UpdateAI(const uint32 diff)
             {
                 if (!UpdateVictim())
                     return;
diff --git a/src/server/scripts/EasternKingdoms/dun_morogh.cpp b/src/server/scripts/EasternKingdoms/dun_morogh.cpp
--- a/src/server/scripts/EasternKingdoms/dun_morogh.cpp
+++ b/src/server/scripts/EasternKingdoms/dun_morogh.cpp
@@ -61,6 +61,7 @@
             lifeTimer = 120000;
             me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
             me->SetStandState(UNIT_STAND_STATE_DEAD);
+            me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
             spellHit = false;
         }
 
@@ -70,18 +71,14 @@
 
         void MoveInLineOfSight(Unit * /*who*/)
         {
-            return;
         }
 
         void UpdateAI(const uint32 diff)
         {
-           if (me->IsStandState())
+            if (me->getStandState() == UNIT_STAND_STATE_STAND)
             {
                 if (lifeTimer <= diff)
-                {
-                    EnterEvadeMode();
-                    return;
-                }
+                    Reset();
                 else
                     lifeTimer -= diff;
             }
@@ -94,6 +91,7 @@
                 DoCast(me, 32343);
                 me->SetStandState(UNIT_STAND_STATE_STAND);
                 me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
+                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
                 //me->RemoveAllAuras();
                 DoScriptText(SAY_HEAL, me);
                 spellHit = true;
diff --git a/src/server/scripts/EasternKingdoms/elwynn_forest.cpp b/src/server/scripts/EasternKingdoms/elwynn_forest.cpp
--- a/src/server/scripts/EasternKingdoms/elwynn_forest.cpp
+++ b/src/server/scripts/EasternKingdoms/elwynn_forest.cpp
@@ -59,6 +59,7 @@
             lifeTimer = 120000;
             me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
             me->SetStandState(UNIT_STAND_STATE_DEAD);   // lay down
+            me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
             spellHit = false;
         }
 
@@ -72,13 +73,10 @@
 
         void UpdateAI(const uint32 diff)
         {
-            if (me->IsStandState())
+            if (me->getStandState() == UNIT_STAND_STATE_STAND)
             {
                 if (lifeTimer <= diff)
-                {
-                    EnterEvadeMode();
-                    return;
-                }
+                    Reset();
                 else
                     lifeTimer -= diff;
             }
@@ -91,6 +89,7 @@
                 DoCast(me, 32343);
                 me->SetStandState(UNIT_STAND_STATE_STAND);
                 me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
+                me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_QUESTGIVER);
                 //me->RemoveAllAuras();
                 DoScriptText(SAY_HEAL, me);
                 spellHit = true;
diff --git a/src/server/scripts/EasternKingdoms/silvermoon_city.cpp b/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
--- a/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
+++ b/src/server/scripts/EasternKingdoms/silvermoon_city.cpp
@@ -76,10 +76,10 @@
 
         void UpdateAI(const uint32 diff)
         {
-            if (me->IsStandState())
+            if (me->getStandState() == UNIT_STAND_STATE_STAND)
             {
                 if (lifeTimer <= diff)
-                    me->AI()->EnterEvadeMode();
+                    Reset();
                 else
                     lifeTimer -= diff;
             }
diff --git a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_scourgelord_tyrannus.cpp b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_scourgelord_tyrannus.cpp
--- a/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_scourgelord_tyrannus.cpp
+++ b/src/server/scripts/Northrend/FrozenHalls/PitOfSaron/boss_scourgelord_tyrannus.cpp
@@ -55,8 +55,6 @@
     SPELL_FORCEFUL_SMASH                        = 69155,
     H_SPELL_FORCEFUL_SMASH                      = 69627,
     SPELL_OVERLORDS_BRAND                       = 69172,
-	SPELL_OVERLORD_BRAND_DAMAGE                 = 69189,
-	SPELL_OVERLORD_BRAND_HEAL                   = 69190,
     SPELL_DARK_MIGHT                            = 69167,
     H_SPELL_DARK_MIGHT                          = 69629,
     SPELL_HOARFROST                             = 69246,
@@ -274,87 +272,8 @@
 
 };
 
-class player_overlord_brandAI : public PlayerAI
-{
-    public:
-        player_overlord_brandAI(Player* pPlayer) : PlayerAI(pPlayer)
-        {
-            tyrannus = NULL;
-        }
-
-        void SetGUID(const uint64& guid, int32 /*type*/)
-        {
-            tyrannus = ObjectAccessor::GetCreature(*me, guid);
-            if (!tyrannus)
-                me->IsAIEnabled = false;
-        }
-
-        void DamageDealt(Unit* /*victim*/, uint32& damage, DamageEffectType /*damageType*/)
-        {
-            me->CastCustomSpell(SPELL_OVERLORD_BRAND_DAMAGE, SPELLVALUE_BASE_POINT0, damage, tyrannus->getVictim(), true, NULL, NULL, tyrannus->GetGUID());
-        }
-
-        void HealDone(Unit* /*target*/, uint32& addHealth)
-        {
-            me->CastCustomSpell(SPELL_OVERLORD_BRAND_HEAL, SPELLVALUE_BASE_POINT0, int32(addHealth*5.5f), tyrannus, true, NULL, NULL, tyrannus->GetGUID());
-        }
-
-        void UpdateAI(const uint32 diff) { }
-
-    private:
-        Creature* tyrannus;
-};
-
-class spell_tyrannus_overlord_brand : public SpellScriptLoader
-{
-    public:
-        spell_tyrannus_overlord_brand() : SpellScriptLoader("spell_tyrannus_overlord_brand") { }
-
-        class spell_tyrannus_overlord_brand_AuraScript : public AuraScript
-        {
-            PrepareAuraScript(spell_tyrannus_overlord_brand_AuraScript);
-
-            void OnApply(AuraEffect const* /*aurEff*/, AuraApplication const* aurApp, AuraEffectHandleModes /*mode*/)
-            {
-                if (aurApp->GetTarget()->GetTypeId() != TYPEID_PLAYER)
-                    return;
-
-                oldAI = aurApp->GetTarget()->GetAI();
-                aurApp->GetTarget()->SetAI(new player_overlord_brandAI(aurApp->GetTarget()->ToPlayer()));
-                aurApp->GetTarget()->GetAI()->SetGUID(GetCasterGUID());
-                oldAIState = aurApp->GetTarget()->IsAIEnabled;
-                aurApp->GetTarget()->IsAIEnabled = true;
-            }
-
-            void OnRemove(AuraEffect const* /*aurEff*/, AuraApplication const* aurApp, AuraEffectHandleModes /*mode*/)
-            {
-                delete aurApp->GetTarget()->GetAI();
-                aurApp->GetTarget()->SetAI(oldAI);
-                aurApp->GetTarget()->IsAIEnabled = oldAIState;
-            }
-
-            void Register()
-            {
-                OnEffectApply += AuraEffectApplyFn(spell_tyrannus_overlord_brand_AuraScript::OnApply, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
-                OnEffectRemove += AuraEffectRemoveFn(spell_tyrannus_overlord_brand_AuraScript::OnRemove, EFFECT_0, SPELL_AURA_DUMMY, AURA_EFFECT_HANDLE_REAL);
-            }
-
-            UnitAI* oldAI;
-            bool oldAIState;
-        };
-
-        AuraScript* GetAuraScript() const
-        {
-            return new spell_tyrannus_overlord_brand_AuraScript();
-        }
-};
-
-
-
-
 void AddSC_boss_tyrannus()
 {
     new boss_tyrannus();
     new boss_rimefang();
-	new spell_tyrannus_overlord_brand();
 }
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_gunship_battle.cpp
@@ -1,211 +1,25 @@
-/*
- * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "ScriptPCH.h"
-#include "icecrown_citadel.h"
-#include "MapManager.h"
-#include "Transport.h"
-#include "Transport.cpp"
-class npc_muradin_bronzebeard_gunship : public CreatureScript
-{
-    public:
-        npc_muradin_bronzebeard_gunship() : CreatureScript("npc_myradin_icc") { }
-
-        bool OnGossipHello(Player* pPlayer, Creature* pCreature)
-        {
-            InstanceScript* pInstance = pCreature->GetInstanceScript();
-            if (pInstance && pInstance->GetBossState(DATA_GUNSHIP_BATTLE) != DONE)
-            {
-                if (!pCreature->GetTransport())
-		{
-            pPlayer->ADD_GOSSIP_ITEM(0, "START", 631, 1000);
-		//	} if(pPlayer->GetSecurity())
-		}else
-		pPlayer->ADD_GOSSIP_ITEM(0, "My companions are all accounted for, Saurfang. Let's go!", 631, 1001);
-		pPlayer->ADD_GOSSIP_ITEM(0, "DESPAWN", 631, 1003);
-					
-			pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
-                return true;
-            }
-
-            return false;
-        }
-
-        bool OnGossipSelect(Player* player, Creature* pCreature, uint32 /*sender*/, uint32 action)
-        {
-            player->PlayerTalkClass->ClearMenus();
-            player->CLOSE_GOSSIP_MENU();
-            if (action == 1000)
-            {
-
-            uint32 entry = 201812;
-            const GameObjectInfo *goinfo = sObjectMgr.GetGameObjectInfo(entry);
-               if (!goinfo)
-		             // sLog.outErrorDb("Transport ID:%u, Name: %s, will not be loaded, gameobject_template missing", entry, name.c_str());
-		    return false;
-		
-                Transport *t = new Transport(51584, goinfo->ScriptId);
-			               
-               std::set<uint32> unused;
-                if (!t->GenerateWaypoints(goinfo->moTransport.taxiPathId, unused))
-                {
-                    delete t;
-                    return false;
-                }
-
-                theguid = sObjectMgr.GenerateLowGuid(HIGHGUID_MO_TRANSPORT);
-                // creates the Gameobject
-                if (!t->Create(theguid, entry, t->m_WayPoints.begin()->second.mapid, t->m_WayPoints.begin()->second.x, t->m_WayPoints.begin()->second.y, t->m_WayPoints.begin()->second.z, 0.0f, 0, 0))
-                {
-                    delete t;
-                    return false;
-               }
-
-               Map* tMap = player->GetMap();
-              //  t->SetUInt32Value(GAMEOBJECT_DYNAMIC, 0x10830010);   // dunno, seen in sniffs	
-		//t->SetFloatValue(GAMEOBJECT_PARENTROTATION+3, 1.0f);
-		t->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE);
-		t->SetGoState(GO_STATE_READY);
-
-                t->SetMap(tMap);
-                t->AddToWorld();
-
-                // transmit creation packet
-                for (Map::PlayerList::const_iterator itr = tMap->GetPlayers().begin(); itr != tMap->GetPlayers().end(); ++itr)
-                {
-                    if (Player* pPlayer = itr->getSource())
-                    {
-                        UpdateData transData;
-                       t->BuildCreateUpdateBlockForPlayer(&transData, pPlayer);
-                   WorldPacket packet;
-                        transData.BuildPacket(&packet);
-                        pPlayer->SendDirectMessage(&packet);
-		     
-               }
-                }
-
-                sMapMgr.m_Transports.insert(t); // for updating
-
-
-				{
-        
-        Field *fields = fields ;
-        uint32 guid = fields[0].GetUInt32();
-	    uint32 entry = fields[1].GetUInt32();
-        uint32 transportEntry = fields[2].GetUInt32();
-        float tX = fields[3].GetFloat();
-		float tY = fields[4].GetFloat();
-		float tZ = fields[5].GetFloat();
-		float tO = fields[6].GetFloat();
-		uint32 anim = fields[7].GetUInt32();
-
-		for (MapManager::TransportSet::iterator itr = sMapMgr.m_Transports.begin(); itr != sMapMgr.m_Transports.end(); ++itr)
-		{
-			if ((*itr)->GetEntry() == transportEntry)
-			{
-				(*itr)->AddNPCPassenger(guid, entry, tX, tY, tZ, tO, anim);
-				break;
-			}
-				}
-				}
-	//	UpdateData transData;
-		
-	//	t->BuildCreateUpdateBlockForPlayer(&transData, player);
-	//	WorldPacket packet;
-	//	transData.BuildPacket(&packet);
-	//	player->GetSession()->SendPacket(&packet);
-                t->UpdateNPCPositions();
-		t->Update(1);
-		t->BuildStopMovePacket(tMap);
-		
-		
-            }
-	     
-            if (action == 1001)
-            {
-        if (Transport* t = pCreature->GetTransport())
-		{    
-	//	pInstance->SetData(DATA_GUNSHIP_BATTLE_EVENT, IN_PROGRESS);
-	//	skybreaker->BuildStartMovePacket(player->GetMap());
-	//	skybreaker->SetGoState(GO_STATE_ACTIVE);
-	//	skybreaker->Update(0);
-	  skybreaker->SetUInt32Value(GAMEOBJECT_DYNAMIC, 0x10830010);   // dunno, seen in sniffs
-skybreaker->SetFloatValue(GAMEOBJECT_PARENTROTATION+3, 1.0f);
-                
-               //skybreaker->AddToWorld();
-	//	UpdateData transData;
-	//	skybreaker->BuildCreateUpdateBlockForPlayer(&transData, player);
-	////	WorldPacket packet;
-	///	transData.BuildPacket(&packet);
-	//	player->GetSession()->SendPacket(&packet);
-	Map* tMap = player->GetMap();
-	
-		skybreaker->BuildStopMovePacket(tMap);
-								
-		}    
-            }
-            else if (action == 1003)
-            {
-                Transport* skybreaker = pCreature->GetTransport();
-                if (!skybreaker)
-                    return true;
-
-                sMapMgr.m_Transports.erase(skybreaker);
-                for (Transport::PlayerSet::const_iterator itr = skybreaker->GetPassengers().begin(); itr != skybreaker->GetPassengers().end(); ++itr)
-                {
-                    skybreaker->RemovePassenger(*itr);
-                    if (Player* plr = *itr)
-                        plr->SetTransport(NULL);
-                }
-
-               
-                for (Transport::CreatureSet::iterator itr = skybreaker->m_NPCPassengerSet.begin(); itr != skybreaker->m_NPCPassengerSet.end();)
-				
-
-
-
-                skybreaker->m_NPCPassengerSet.clear();
-
-                UpdateData transData;
-                skybreaker->BuildOutOfRangeUpdateBlock(&transData);
-                WorldPacket out_packet;
-                transData.BuildPacket(&out_packet);
-
-                for (Map::PlayerList::const_iterator itr = skybreaker->GetMap()->GetPlayers().begin(); itr != skybreaker->GetMap()->GetPlayers().end(); ++itr)
-                    if (skybreaker != itr->getSource()->GetTransport())
-                        itr->getSource()->SendDirectMessage(&out_packet);
-
-                skybreaker->Delete();
-                skybreaker = NULL;
-            }
-
-            return true;
-        }
-        uint64 theguid;
-		Transport *skybreaker;
-	private:
-	         InstanceScript* pInstance;
-		 
-};
-
- 
-void AddSC_boss_gunship_battle()
-{
-    //new transport_gunship();
-    new npc_muradin_bronzebeard_gunship();
-}
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "icecrown_citadel.h"
+
+void AddSC_boss_gunship_battle()
+{
+   
+}
\ No newline at end of file
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp b/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp
--- a/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_heigan.cpp
@@ -26,6 +26,7 @@
 #define SPELL_SPELL_DISRUPTION  29310
 #define SPELL_DECREPIT_FEVER    RAID_MODE(29998,55011)
 #define SPELL_PLAGUE_CLOUD      29350
+#define ACHIEV_SAFETY_DANCE     RAID_MODE(1996,2139)
 
 enum Events
 {
@@ -59,6 +60,8 @@
         uint32 eruptSection;
         bool eruptDirection;
         Phases phase;
+		bool bNobodyDied;
+
 
         void Reset()
         {
@@ -67,6 +70,7 @@
 
         void KilledUnit(Unit* /*Victim*/)
         {
+			bNobodyDied = false;
             if (!(rand()%5))
                 DoScriptText(SAY_SLAY, me);
         }
@@ -75,11 +79,15 @@
         {
             _JustDied();
             DoScriptText(SAY_DEATH, me);
+
+			if (instance && bNobodyDied)
+            instance->DoCompleteAchievement(ACHIEV_SAFETY_DANCE);
         }
 
         void EnterCombat(Unit * /*who*/)
         {
             _EnterCombat();
+            bNobodyDied = true;
             TeleportCheaters();
             DoScriptText(SAY_AGGRO, me);
             EnterPhase(PHASE_FIGHT);
diff --git a/src/server/scripts/Northrend/grizzly_hills.cpp b/src/server/scripts/Northrend/grizzly_hills.cpp
--- a/src/server/scripts/Northrend/grizzly_hills.cpp
+++ b/src/server/scripts/Northrend/grizzly_hills.cpp
@@ -479,10 +479,13 @@
                     me->SetStandState(UNIT_STAND_STATE_DEAD);
                     me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
                     me->SetUInt32Value(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_DEAD);
-                }
-                m_uiPhase = 0;
-            }
+                    m_uiPhase = 0;
+				}
         }
+		 if (!UpdateVictim())
+                return;
+           DoMeleeAttackIfReady();
+		}
     };
 
     CreatureAI *GetAI(Creature *creature) const
diff --git a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/instance_serpent_shrine.cpp b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/instance_serpent_shrine.cpp
--- a/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/instance_serpent_shrine.cpp
+++ b/src/server/scripts/Outland/CoilfangReservoir/SerpentShrine/instance_serpent_shrine.cpp
@@ -32,6 +32,8 @@
 #define TRASHMOB_COILFANG_PRIESTESS 21220  //6*2
 #define TRASHMOB_COILFANG_SHATTERER 21301  //6*3
 
+#define SPELL_LURKER_HOOK_ACHIEVEMENT 54587  //The Lurker Hook Achievement
+
 #define MIN_KILLS 30
 
 //NOTE: there are 6 platforms
@@ -80,6 +82,8 @@
     struct instance_serpentshrine_cavern_InstanceMapScript : public InstanceScript
     {
         instance_serpentshrine_cavern_InstanceMapScript(Map* pMap) : InstanceScript(pMap) {Initialize();};
+        
+        Player *pFisher;
 
         uint64 LurkerBelow;
         uint64 Sharkkis;
@@ -109,6 +113,8 @@
         {
             memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
 
+            pFisher = NULL;
+
             LurkerBelow = 0;
             Sharkkis = 0;
             Tidalvess = 0;
@@ -136,7 +142,6 @@
             FrenzySpawnTimer = 2000;
             DoSpawnFrenzy = false;
             TrashCount = 0;
-
         }
 
         bool IsEncounterInProgress() const
@@ -154,10 +159,21 @@
             {
                 if (FishingTimer <= diff)
                 {
-                    LurkerSubEvent = LURKER_HOOKED;
-                    SetData(DATA_STRANGE_POOL, IN_PROGRESS);//just fished, signal Lurker script to emerge and start fight, we use IN_PROGRESS so it won't get saved and lurker will be alway invis at start if server restarted
+                    if (pFisher)
+                        if (!pFisher->hasUnitState(UNIT_STAT_CASTING))
+                        {
+                            pFisher->CastSpell(pFisher,SPELL_LURKER_HOOK_ACHIEVEMENT,true);                                                
+                            LurkerSubEvent = LURKER_HOOKED;
+                            SetData(DATA_STRANGE_POOL, IN_PROGRESS);//just fished, signal Lurker script to emerge and start fight, we use IN_PROGRESS so it won't get saved and lurker will be alway invis at start if server restarted
+                        }
                 } else FishingTimer -= diff;
             }
+            if (pFisher)
+                if (!pFisher->hasUnitState(UNIT_STAT_CASTING))
+                {
+                    pFisher->CastSpell(pFisher,SPELL_LURKER_HOOK_ACHIEVEMENT,true);
+                    pFisher = NULL;
+                }
             //Water checks
             if (WaterCheckTimer <= diff)
             {
@@ -238,6 +254,10 @@
                     {
                         FishingTimer = 10000+rand()%30000;//random time before lurker emerges
                         LurkerSubEvent = LURKER_FISHING;
+                        if (Unit * pUnit = pGo->GetOwner())
+                            if (pUnit->GetTypeId() == TYPEID_PLAYER)
+                                pFisher = pGo->GetOwner()->ToPlayer();
+                                    
                     }
                     break;
             }
diff --git a/src/server/scripts/World/npcs_special.cpp b/src/server/scripts/World/npcs_special.cpp
--- a/src/server/scripts/World/npcs_special.cpp
+++ b/src/server/scripts/World/npcs_special.cpp
@@ -1286,7 +1286,7 @@
         if (pCreature->isCanTrainingAndResetTalentsOf(pPlayer))
             pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, GOSSIP_HELLO_ROGUE1, GOSSIP_SENDER_MAIN, GOSSIP_OPTION_UNLEARNTALENTS);
 
-        if (!(pPlayer->GetSpecsCount() == 1 && pCreature->isCanTrainingAndResetTalentsOf(pPlayer) && !(pPlayer->getLevel() < sWorld.getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))))
+        if (pPlayer->GetSpecsCount() == 1 && pCreature->isCanTrainingAndResetTalentsOf(pPlayer) && !(pPlayer->getLevel() < sWorld.getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL)))
             pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, GOSSIP_HELLO_ROGUE3, GOSSIP_SENDER_MAIN, GOSSIP_OPTION_LEARNDUALSPEC);
 
         if (pPlayer->getClass() == CLASS_ROGUE && pPlayer->getLevel() >= 24 && !pPlayer->HasItemCount(17126,1) && !pPlayer->GetQuestRewardStatus(6681))
@@ -2014,89 +2014,89 @@
     }
 };
 
-enum eTrainingDummy
-{
-    NPC_ADVANCED_TARGET_DUMMY                  = 2674,
-    NPC_TARGET_DUMMY                           = 2673
-};
-
-class npc_training_dummy : public CreatureScript
-{
-public:
-    npc_training_dummy() : CreatureScript("npc_training_dummy") { }
-
-    struct npc_training_dummyAI : Scripted_NoMovementAI
-    {
-        npc_training_dummyAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
-        {
-            uiEntry = pCreature->GetEntry();
-        }
-
-        uint32 uiEntry;
-        uint32 uiResetTimer;
-        uint32 uiDespawnTimer;
-
-        void Reset()
-        {
-            me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
-            me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);//imune to knock aways like blast wave
-
-            uiResetTimer = 5000;
-            uiDespawnTimer = 15000;
-        }
-
-        void EnterEvadeMode()
-        {
-            if (!_EnterEvadeMode())
-                return;
-
-            Reset();
-        }
-
-        void DamageTaken(Unit * /*done_by*/, uint32 &damage)
-        {
-            uiResetTimer = 5000;
-            damage = 0;
-        }
-
-        void EnterCombat(Unit * /*who*/)
-        {
-            if (uiEntry != NPC_ADVANCED_TARGET_DUMMY && uiEntry != NPC_TARGET_DUMMY)
-                return;
-        }
-
-        void UpdateAI(const uint32 uiDiff)
-        {
-            if (!UpdateVictim())
-                return;
-
-            if (!me->hasUnitState(UNIT_STAT_STUNNED))
-                me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
-
-            if (uiEntry != NPC_ADVANCED_TARGET_DUMMY && uiEntry != NPC_TARGET_DUMMY)
-            {
-                if (uiResetTimer <= uiDiff)
-                {
-                    EnterEvadeMode();
-                    uiResetTimer = 5000;
-                }
-                else
-                    uiResetTimer -= uiDiff;
-                return;
-            }
-            else
-            {
-                if (uiDespawnTimer <= uiDiff)
-                    me->ForcedDespawn();
-                else
-                    uiDespawnTimer -= uiDiff;
-            }
-        }
-        void MoveInLineOfSight(Unit * /*who*/){return;}
-    };
-
-    CreatureAI* GetAI(Creature* pCreature) const
-    {
+enum eTrainingDummy
+{
+    NPC_ADVANCED_TARGET_DUMMY                  = 2674,
+    NPC_TARGET_DUMMY                           = 2673
+};
+
+class npc_training_dummy : public CreatureScript
+{
+public:
+    npc_training_dummy() : CreatureScript("npc_training_dummy") { }
+
+    struct npc_training_dummyAI : Scripted_NoMovementAI
+    {
+        npc_training_dummyAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+        {
+            uiEntry = pCreature->GetEntry();
+        }
+
+        uint32 uiEntry;
+        uint32 uiResetTimer;
+        uint32 uiDespawnTimer;
+
+        void Reset()
+        {
+            me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
+            me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);//imune to knock aways like blast wave
+
+            uiResetTimer = 5000;
+            uiDespawnTimer = 15000;
+        }
+
+        void EnterEvadeMode()
+        {
+            if (!_EnterEvadeMode())
+                return;
+
+            Reset();
+        }
+
+        void DamageTaken(Unit * /*done_by*/, uint32 &damage)
+        {
+            uiResetTimer = 5000;
+            damage = 0;
+        }
+
+        void EnterCombat(Unit * /*who*/)
+        {
+            if (uiEntry != NPC_ADVANCED_TARGET_DUMMY && uiEntry != NPC_TARGET_DUMMY)
+                return;
+        }
+
+        void UpdateAI(const uint32 uiDiff)
+        {
+            if (!UpdateVictim())
+                return;
+
+            if (!me->hasUnitState(UNIT_STAT_STUNNED))
+                me->SetControlled(true,UNIT_STAT_STUNNED);//disable rotate
+
+            if (uiEntry != NPC_ADVANCED_TARGET_DUMMY && uiEntry != NPC_TARGET_DUMMY)
+            {
+                if (uiResetTimer <= uiDiff)
+                {
+                    EnterEvadeMode();
+                    uiResetTimer = 5000;
+                }
+                else
+                    uiResetTimer -= uiDiff;
+                return;
+            }
+            else
+            {
+                if (uiDespawnTimer <= uiDiff)
+                    me->ForcedDespawn();
+                else
+                    uiDespawnTimer -= uiDiff;
+            }
+        }
+        void MoveInLineOfSight(Unit * /*who*/){return;}
+    };
+
+    CreatureAI* GetAI(Creature* pCreature) const
+    {
         return new npc_training_dummyAI(pCreature);
     }
 };
