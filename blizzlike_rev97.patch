# HG changeset patch
# User asniker
# Date 1288608149 -18000
# Node ID 40c7381dde3e1f8898837a77d0b327a9c20b71fd
# Parent  ef790cdd9b6384252952c26c00d96bf48d392135
забытое

diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -63,13 +63,13 @@
 void AddSC_achievement_scripts();
 void AddSC_npc_customize();
 void AddSC_dungeon_finder();
-void AddSC_PVP_System();
+void AddSC_pvp_system();
 
 //guildhouse
 void AddSC_guildmaster();
 
 //hunter
-void AddSC_npc_buffNPC();
+void AddSC_npc_buffnpc();
 
 //eastern kingdoms
 void AddSC_alterac_valley();                 //Alterac Valley
@@ -609,7 +609,7 @@
 	AddSC_guildmaster();
 
 	//hunter
-    AddSC_npc_buffNPC();
+    AddSC_npc_buffnpc();
 	
 #endif
 }
@@ -661,7 +661,7 @@
     AddSC_chat_log();
 	AddSC_npc_customize();
 	AddSC_dungeon_finder();
-    AddSC_PVP_System();
+    AddSC_pvp_system();
 	
 #endif
 }
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -30,18 +30,15 @@
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
   Custom/npc_teleport.cpp
-  
-
-Custom/buffNPC.cpp
-
-../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  Custom/buffnpc.cpp
+  Custom/guildmaster.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
   ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
   ../game/AI/ScriptedAI/ScriptedGuardAI.cpp
   ../game/AI/ScriptedAI/ScriptedSimpleAI.cpp
-  Custom/guildmaster.cpp
 )
 
 if(SCRIPTS)
diff --git a/src/server/scripts/Custom/buffnpc.cpp b/src/server/scripts/Custom/buffnpc.cpp
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/Custom/buffnpc.cpp
@@ -0,0 +1,108 @@
+// -- Buff NPC Script for MCWoW - by FreeCry -- //
+#include "ScriptPCH.h"
+#include "buffNPC.h"
+
+
+class npc_buffnpc : public CreatureScript
+{
+public:
+	npc_buffnpc() : CreatureScript("npc_buffnpc") { }
+
+bool OnGossipHello(Player* player, Creature* creature)
+{
+	if (player->isInCombat())
+	{
+		player->SEND_GOSSIP_MENU(40033, creature->GetGUID());
+		return true;
+	}
+	else
+	{	
+		player->ADD_GOSSIP_ITEM(0, "  ,                   .", GOSSIP_SENDER_MAIN, buffs);
+		player->ADD_GOSSIP_ITEM(0, "   ,                      .", GOSSIP_SENDER_MAIN, closemenu);
+
+		player->SEND_GOSSIP_MENU(40034, creature->GetGUID());
+		return true;
+	}
+}
+bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+{
+	switch(action)
+	{
+
+	case buffs:
+		player->ADD_GOSSIP_ITEM(3, "                ", GOSSIP_SENDER_MAIN, gsdm);
+		player->ADD_GOSSIP_ITEM(3, "                 ", GOSSIP_SENDER_MAIN, gsdk);
+		player->ADD_GOSSIP_ITEM(3, "                         ", GOSSIP_SENDER_MAIN, gsdw);
+		player->ADD_GOSSIP_ITEM(3, "                 ", GOSSIP_SENDER_MAIN, gsdr);
+		player->ADD_GOSSIP_ITEM(3, "         ", GOSSIP_SENDER_MAIN, ai);
+		player->ADD_GOSSIP_ITEM(3, "                     ", GOSSIP_SENDER_MAIN, buffpkt1);
+		player->ADD_GOSSIP_ITEM(0, "               .", GOSSIP_SENDER_MAIN, closemenu);
+
+
+		player->SEND_GOSSIP_MENU(40035, creature->GetGUID());
+		break;
+
+	case gsdm:
+		player->CastSpell(player, 48934, true);
+
+		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
+		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
+		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
+		return true;
+
+	case gsdk:
+		player->CastSpell(player, 25898, true);
+
+		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
+		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
+		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
+		return true;
+
+	case gsdw:
+		player->CastSpell(player, 48938, true);
+
+		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
+		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
+		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
+		return true;
+
+	case gsdr:
+		player->CastSpell(player, 25899, true);
+
+		player->ADD_GOSSIP_ITEM(0, "  ,       ..", GOSSIP_SENDER_MAIN, buffs);
+		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
+		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
+		return true;
+
+	case ai:
+		player->CastSpell(player, 42995, true);
+
+		player->ADD_GOSSIP_ITEM(0, "  ,       .", GOSSIP_SENDER_MAIN, buffs);
+		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
+		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
+		return true;
+
+	case buffpkt1:
+		player->CastSpell(player, 48162, true);
+		player->CastSpell(player, 48074, true);
+		player->CastSpell(player, 48170, true);
+		player->CastSpell(player, 48470, true);
+
+		player->ADD_GOSSIP_ITEM(0, "  ,       ..", GOSSIP_SENDER_MAIN, buffs);
+		player->ADD_GOSSIP_ITEM(0, "   ,             .", GOSSIP_SENDER_MAIN, closemenu);
+		player->SEND_GOSSIP_MENU(40036, creature->GetGUID());
+		return true;
+
+	case closemenu:
+		player->CLOSE_GOSSIP_MENU();break;
+		return true;
+	}
+
+return true;
+}
+};
+
+void AddSC_npc_buffNPC()
+{
+new npc_buffnpc;
+}
diff --git a/src/server/scripts/Custom/buffnpc.h b/src/server/scripts/Custom/buffnpc.h
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/Custom/buffnpc.h
@@ -0,0 +1,21 @@
+// -- Buff NPC Script for MCWoW - by FreeCry -- //
+#ifndef BUFFNPC
+#define BUFFNPC
+
+enum
+{	
+	menu		=		100,
+	closemenu	=		200,
+	buffs		=		300,
+
+	gsdm		=		301,
+	gsdk		=		302,
+	gsdw		=		303,
+	gsdr		=		304,
+	gds			=		305,
+	ai			=		306,
+	buffpkt1	=		307,
+};
+
+#endif
+
diff --git a/src/server/scripts/Custom/hunterpet_vendor.cpp b/src/server/scripts/Custom/hunterpet_vendor.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..6e3e083a24fb59b5690e9ed69273fb28423f36de
GIT binary patch
literal 28866
zc%1EBTW=#t6|UDH@gG{V5}O%jcj7pA1X3=ZBslQ|cTCv4L{8$wmJ=uVLKs&23lZWM
zpxqb53Kj&*14tm2bH1wXu5NcH)$OY6KC~=f`chw=Q{Smmr>d*U-~8{5cq2UV5xqRI
zEhb_l#^O%g($O9r4d|#NhII9azQ^?abNU{LOS)%B_xR$1zI)=Hu6bfhyr<7Y!a1Sq
zC-i$>yrt_MdTrD9d+{>Ni}U@y_#WOL5W;|vZYak~y4MpgV#r67dQW^Tx^zD4{;nqN
zJ!Cx-ztUulQuCX0{{U&PfYlLmlt)w4#HKhFE&Mto*=yo}B-x|yV{uBKO}bCMJW&zr
zqAHfff|BWJv;+Fy0m>m=X%X_AhF2A9VufC2Xbs4;2ehVmhZ3sMSzW$0dROUfhS-Em
zTg31?u?x)^_gF(*1m=QRDvanu&J#M{r1Fe#mm%wFVcZk?+$VHDChZDozd|gTGcM&j
zpmPl%>-;Pe;-azcK3VNPp)_JBQmzHkv|^03OIkJw>i}}4m0(bYi^g2XG1E$Kh43oI
z)>y~)R?MQMR8=bf#atZJVRv<UA3&=5RN1W(syW^!N-eS#UA_wJW0i2t^xPAl&~Yu5
z)m7+e%4!`)r>MpIkgOTQTP37w0ki|svj#@v(s8|AS2fI(hX}I;tMe0>OYjBN9JTg{
zj@j~d>D|)&l^4F)hATPhnT{IwSB$y@4{ge>tOv)cjy2U$-0N2%n`ymZMD_%=6xrC9
zGB2j(7h!Fo*0xd@UdtgF*RQvV2On41=jrmTDpYfu2~c;Hk51Z41&I0aBr~5U@VK=M
z>h7GeUuJIi(E`_SF6o=s!LcdYKD^X1Fn5%P*@~6oGQ6N^l#oPBw!zD=K2x+NP#T1B
zs%$V>hZ%1zCnqgLFk6b_MhuaC);h}3)D9(DvgBmhEurj8<AOSLY>>_@)lO==R)J?-
zDvX)rqk=YM)wtzlf6@vgOCKf3Eiva3mzUdMF3U9w$kS0nWb3Aq`>IXWTTsdPGJM&(
zAr7}tKZDmv;w%Emlo^g;BqRHDK8{pHlwj%$xm32*@qS8FzC?0W!@dLeJKEGw8qw7O
z^))UCVY>IB_dPtZLGOFI=bX~^D20dqP=|2Fbe4bV{T<HbQ+(=aHk6+;%X1!mt&Jyg
znx{UI8Qu%veM;}o!jd?rD|aNFM@$Tek2{nKBkxhl8+zSQ4o4`j_rQIHa)^#!r^v_m
zTqMrD)XHRza=1d@az2Ljk@$(YhTPjBL$VZpOfSwy#?L<DIIhjIZGWlI=R*7>>Lyv)
zj<Pr(9{PxmWNdIqc`QJW7vgu~Z{qLbEAfT+i}<hjtN4%jBc1;}eSS^9U*N7dhL0FX
z_6g6>Cb74EjZ$JwMkL#hW|Zm=;?LqwB-z*EOYtv~<sWqX<qVQ_#IK3hF>Eqhx*&a0
zzC)aEk$fCIF2D!9PGOuec2NeqbT_wz^I%Hm7etFg+`%aZbTp>#37rXK`b>SZEsp3j
z&T?^?E2?bs$;>&L$ZJx+eCX663C5Oc7~eO6j~v4jdnmC1eCIIbY8!d?NTxxob_UFh
z!~<O&(_LMXaQg1xzKD$r)Y*<^`y1i4Im9M;Yrvwa0dJKBbb<RDq|aybS1AZOulZ|d
zAlq+I2meVm^9%6}o%xFD<G;y!<du)DL2`9Va!g{LV;1=u(720qL*nlOzXv(x8)Tr^
zk+BJl&#Aq-Lkn<&)}c;kx#i@x&cn3<MlAb~g{_gxD4!m~sho!Jg)a4YhhOLPIYPPJ
zlH`mmTWU}I6z%r4mTGpbWKIusen{5tnx!7<Jxg&3J04ol;DJ7S@RxDvXYnIGN`=!7
zkV`%pM~T#SO4X;7?3V`x<cU(+k!2T=Vh@pD8|-f3*91PPL)s5e>#t+?<>fk_+J&V~
z>#+mxF#wXRb%8%=(dUOM#odg$WZ7&{J?fD5obd8V)eqCzt2=d+PoLhG&^NzCGW88g
zsBclSO;}OnIr2%?PNcTO+#aQAqpsww)m<&6Eh}oPn1^e^F_r&yAs^ijamE^keF+bU
ziw^2iaS3lU40|;oF69KCD}M~4OBrF<YN7A({C607y&L2(L<BEmHjX<cVMKh6KFqjK
ziyh>3t@=SW<3U}IEtC}ZD7YoMC)uTk>#5eGXv7iZVKW9ifm~xH*-#zj@3A~&;@FdO
zgq|9gupeuMM;IIE7K%k5LR{OWs!Pk<b<sCCR}o4_crh(*HA#x=5TM)Ag6rdzikpY%
z2VA39Izdm}Q$0XWoZ>s^FUbB*&}ZPNWe-v4WdY5k1hT%4FnYl8oINk8>v)1lA<*eW
z`HG@4U#nh%8(9M%bBXbkk=Dj}luq(9M2siX6xBl3>(6Jjs9<bx9~Qz<Lp!t*4>48;
zJx-RsqejlzZffD!-zaPkc-{}&;f>~FKE`YIam8#6&By901;^^nRf@iLZhEXrmwLlW
zf9?XFN%okA1$&u#dRzU>9_(Ta^vi?~l9m$GRGuT&C(8)>GI=$K=X9;cKiuizD{m-k
zK@<~28f~k{hsR#qXdh<P%I>&P7j^VbjZEI<?(q#%5Nx$s6SSsLl)yN*XkX=({GL#z
zvuhW1q!?&zDcd*a)K`&d-Y7keXTNVB$Dd6)o7Q+7>mQ8J<_^`EWj-m#k09AD&&Q;e
z{oeOzzXxbR@_V(%ba63;<*U(>yyF?8Fr6JaxHtYwM2jC%*|p(g`#EL02{G)A?@6og
zQTqHNc2Qb8@@&%m7b-I8<@Vj}MCxxRGHf6^zr`~bn^EEPb8tNl`>w==Z^WyV*f8y>
zp&lcq<?UmP;ucnxd~Q2$I7j_)y^hej_rm9~zkr56q;koZ?h~ZTm*!OEB`sgtnzXzl
z(xFA)hnUrKhFP)988gXt!80Furn0n(6*YHY;R$Qs#%v>B)E==1M(|QueWlhYBw3w)
z)@q;C>9qnSt9DpT>&0a~pSI0w)~bz?TX)=MJ+rsXZPxmklH1w2HDNU#MZ0G=KBu;1
z`8jKF)cbSKb2KZv<k$|!94)8uoSY$Jo7?2-zLHOSadJAJ(F`N|Tt@3FOCH_%-p6KJ
z+2-`Im98bn&&9F3wl!<jamlSaZlk$;w%Lr<e3$&W<4>Q@XPZHNHG9dS%Q`qc^U;27
zoZe5M<n%c>jpmBF<22gUq2$ySr|HjZ(q`AX<Tcn?qvX{Vujx;1(&rny7(JTa<D}%)
z?bu*^9=1zP%MpFod}hyEx6NzzZa*czZu!;c_q$+K-*Ktr@;SH+);YLiGuZR0<kKae
z>8m^Jvzos5SjnwzZsq!xV9(W>wpL*zk~^_xS;h2<0yod)^gY>1OK?}qv({JGXEl9q
zypr4J<JL`#mA*$|$*ap=?)3T``~BSMy&_9aZE%_vX|aB{&U|ljSIv?~mrnw+R(jbV
zH_qDMwB+~s_;u5!rtdRb^6HLPv(<&Rc{bbsx8(iX;oa^0HuD{tOa5K<k%ASj_WMP_
z4%sDt?)ZyV1KZ{=+L^rM&+Tl}Xa%*4Ii}IB@FkD#cucN4x6Nd7SN@XA*|`jM-H!Gc
zH`z%&*q2-$@hU92bIvAxULtZi6XyR)z!-AZ?_dU2AVd7$<X&OU>jPr4;A~ur>FXYL
z`j_Y9cu%F|a&3q<c1x2eY5yq~|3?H9%zKgkzX&pqA7os8svPs@tnV0~mbZT0M($0)
cyFc{s6p>LR{*|&!Y1`3Et$;BzE7Gm<|A*1;CjbBd

diff --git a/src/server/scripts/Custom/hunterpet_vendor.h b/src/server/scripts/Custom/hunterpet_vendor.h
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/Custom/hunterpet_vendor.h
@@ -0,0 +1,56 @@
+// -- Custom Hunter-Vendor Script By MCWoW (FreeCry) -- //
+
+#ifndef HUNTERPETVENDOR
+#define HUNTERPETVENDOR
+
+    enum normalpets
+	{
+	main					=  100,
+	pets					=  200,
+	exotic					=  300,
+	felshetzer				=  201,
+	fledermaus				=  202,
+	netherrochen			=  203,
+	raubvogelrot			=  204,
+	raubvogelschwarz		=  205,
+	raubvogelweiss			=  206,
+	schlange				=  207,
+	spinne					=  208,
+	gorillaschwarz			=  209,
+	gorillaweiss			=  210,
+	krebs					=  211,
+	krokolisk				=  212,
+	aasvogel				=  213,
+	hyaene					=  214,
+	katzetiger				=  215,
+	katzeloewe				=  216,
+	katzeluchs				=  217,
+	raptorgruen				=  218,
+	raptorrot				=  219,	
+	weitschreiter			=  220,
+	wesperot				=  221,
+	wespeblau				=  222,
+	wolfruestung			=  223,
+	wolfgrau				=  224,
+	wolfweiss				=  225
+	};
+	
+	enum exotic
+	{
+	schimaere				=  326,
+	silithidgelb			=  327,
+	silithidrot				=  328,
+	rhinozeros				=  329,
+	wurmbraun				=  330,
+	wurmgelb				=  331,
+	kernhundweiss			=  332,
+	kernhundrot				=  333,
+	teufelssaurierweiss		=  334,
+	teufelssaurierschwarz	=  335,
+	skoll					=  336,
+	loque					=  337,
+	gondria					=  338,
+	arcturis				=  339
+};
+
+#endif
diff --git a/src/server/scripts/Northrend/wintergrasp.cpp b/src/server/scripts/Northrend/wintergrasp.cpp
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/Northrend/wintergrasp.cpp
@@ -0,0 +1,89 @@
+/* Copyright (C) 2008 - 2009 Trinity <http://www.trinitycore.org/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ */
+
+#include "ScriptPCH.h"
+#include "OutdoorPvPWG.h"
+
+#define GOSSIP_HELLO_DEMO1  "Build catapult."
+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
+
+class npc_demolisher_engineerer : public CreatureScript
+{
+public:
+    npc_demolisher_engineerer() : CreatureScript("npc_demolisher_engineerer") { }
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if (pCreature->isQuestGiver())
+        pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        if (pPlayer->HasAura(SPELL_CORPORAL))
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+        else if (pPlayer->HasAura(SPELL_LIEUTENANT))
+        {
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+1);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+2);
+        }
+    }
+    else
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+9);
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
+        {
+            case 0: pPlayer->CastSpell(pPlayer, 56663, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 1: pPlayer->CastSpell(pPlayer, 56575, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 2: pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? 61408 : 56661, false, NULL, NULL, pCreature->GetGUID()); break;
+        }
+    }
+
+    return true;
+}
+
+    CreatureAI* GetAI(Creature* pCreature) const
+    {
+        return new npc_demolisher_engineererAI(pCreature);
+    }
+
+    struct npc_demolisher_engineererAI : public ScriptedAI
+    {
+        npc_demolisher_engineererAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            me->SetReactState(REACT_PASSIVE);
+        }
+    };
+
+};
+void AddSC_wintergrasp()
+{
+    new npc_demolisher_engineerer();
+}
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
@@ -0,0 +1,2288 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ */
+
+#include "OutdoorPvPWG.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "ObjectMgr.h"
+#include "World.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "ScriptedCreature.h"
+#include "ScriptPCH.h"
+
+Creature* FortressSpirit;
+uint32 entry;
+uint32 guide_entry;
+uint32 guide_entry_fortress_horde;
+uint32 guide_entry_fortress_alliance;
+
+/* Vehicle teleport Need to be fixed Crash
+Map* pMap;
+uint64 VehicleTeleporterGUID;
+uint64 VehicleTeleporterGUID2;*/
+
+OutdoorPvPWG::OutdoorPvPWG()
+{
+    m_TypeId = OUTDOOR_PVP_WG;
+    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
+}
+
+void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
+{
+    while((*pair)[0])
+    {
+        pairMap[(*pair)[0]] = (*pair)[1];
+        pairMap[(*pair)[1]] = (*pair)[0];
+        ++pair;
+    }
+}
+
+void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
+{
+    if (cr)
+    {
+        cr->SetOriginalEntry(entry);
+        if (entry != cr->GetEntry() || !cr->isAlive())
+            cr->Respawn(true);
+        cr->SetVisibility(VISIBILITY_ON);
+    }
+}
+
+bool OutdoorPvPWG::SetupOutdoorPvP()
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+        return false;
+    }
+
+    //load worlstates
+    QueryResult result = CharacterDatabase.PQuery("SELECT `entry`, `value` from `worldstates` where `entry` in ('31001','31002','31003') order by `entry`");
+    
+    m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+
+    if (result)
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+            switch (fields[0].GetUInt32())
+            {
+                case 31001:
+                    m_wartime = fields[1].GetBool();
+                    break;
+                case 31002:
+                    m_timer = fields[1].GetUInt32();
+                    break;
+                case 31003:
+                    m_defender = TeamId(fields[1].GetUInt32());
+                    break;
+            }
+        }while(result->NextRow());
+    }
+    else
+    {
+        m_wartime = false;
+        m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
+        m_defender = TeamId(rand()%2);
+    }
+
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    m_changeDefender = false;
+    m_workshopCount[TEAM_ALLIANCE] = 0;
+    m_workshopCount[TEAM_HORDE] = 0;
+    m_tenacityStack = 0;
+    m_gate = NULL;
+
+    std::list<uint32> engGuids;
+    std::list<uint32> spiritGuids;
+
+    // Store Eng, spirit guide guids and questgiver for later use
+    result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
+         " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
+         CRE_ENG_A, CRE_ENG_H, CRE_SPI_A, CRE_SPI_H, 31101, 31051, 31102, 31052,
+         31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
+    if (!result)
+        sLog.outError("Cannot find siege workshop master or spirit guides in creature!");
+    else
+    {
+        do
+        {
+            Position posHorde, posAlli;
+            Field *fields = result->Fetch();
+            switch(fields[1].GetUInt32())
+            {
+                case CRE_ENG_A:
+                case CRE_ENG_H:
+                    engGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case CRE_SPI_A:
+                case CRE_SPI_H:
+                    spiritGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case 31051:
+                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
+                    posAlli.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31101:
+                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31052:
+                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
+                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31102:
+                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31109:
+                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
+                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31107:
+                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31153:
+                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
+                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31151:
+                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31108:
+                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
+                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31106:
+                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31054:
+                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
+                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31053:
+                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31036:
+                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
+                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31091:
+                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                default:
+                    break;
+            }
+        }while(result->NextRow());
+    }
+
+    // Select POI
+    AreaPOIList areaPOIs;
+    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
+    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
+    {
+        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
+        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
+        {
+            areaPOIs.push_back(poiInfo);
+            if (minX > poiInfo->x) minX = poiInfo->x;
+            if (minY > poiInfo->y) minY = poiInfo->y;
+            if (maxX < poiInfo->x) maxX = poiInfo->x;
+            if (maxY < poiInfo->y) maxY = poiInfo->y;
+        }
+    }
+    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
+
+    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
+    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
+        " WHERE gameobject.map=571"
+        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
+        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
+        " AND gameobject_template.type=33"
+        " AND gameobject.id=gameobject_template.entry",
+        minX, minY, maxX, maxY);
+    if (!result)
+        return false;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        uint32 guid = fields[0].GetUInt32();
+        GameObjectData const * goData = sObjectMgr.GetGOData(guid);
+        if (!goData) // this should not happen
+            continue;
+
+        float x = goData->posX, y = goData->posY;
+        float minDist = 100;
+        AreaPOIList::iterator poi = areaPOIs.end();
+        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
+        {
+            if (!(*itr)->icon[1]) // note: may for other use
+                continue;
+
+            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
+            if (minDist > dist)
+            {
+                minDist = dist;
+                poi = itr;
+            }
+        }
+
+        if (poi == areaPOIs.end())
+            continue;
+
+        // add building to the list
+        TeamId teamId = x > POS_X_CENTER ? getDefenderTeam() : getAttackerTeam();
+        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
+        if ((*poi)->id == 2246)
+            m_gate = m_buildingStates[guid];
+        areaPOIs.erase(poi);
+
+        // add capture point
+        uint32 capturePointEntry = 0;
+
+        switch(goData->id)
+        {    
+            //West Goblin Workshops
+            case 192028: // NW
+            case 192030: // W
+            case 192032: // SW
+                capturePointEntry = 190475;
+                break;
+            //East Goblin Workshops
+            case 192029: // NE
+            case 192031: // E
+            case 192033: // SE
+                capturePointEntry = 190487;
+                break;
+        }
+
+        if (capturePointEntry)
+        {
+            uint32 engGuid = 0;
+            uint32 spiritGuid = 0;
+            // Find closest Eng to Workshop
+            float minDist = 100;
+            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    engGuid = *itr;
+                }
+            }
+
+            if (!engGuid)
+            {
+                sLog.outError("Cannot find nearby siege workshop master!");
+                continue;
+            }
+            else
+                engGuids.remove(engGuid);
+            // Find closest Spirit Guide to Workshop
+            minDist = 255;
+            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr.GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    spiritGuid = *itr;
+                }
+            }
+
+            // Inside fortress won't be capturable
+            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
+            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
+            {
+                delete workshop;
+                sLog.outError("Cannot add capture point!");
+                continue;
+            }
+
+            const CreatureData *creData = sObjectMgr.GetCreatureData(engGuid);
+            if (!creData)
+                continue;
+
+            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
+            const_cast<CreatureData*>(creData)->displayid = 0;
+            workshop->m_engGuid = engGuid;
+
+            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
+            if (spiritGuid)
+            {
+                spiritGuids.remove(spiritGuid);
+
+                const CreatureData *spiritData = sObjectMgr.GetCreatureData(spiritGuid);
+                if (!spiritData)
+                    continue;
+
+                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
+                const_cast<CreatureData*>(spiritData)->displayid = 0;
+                workshop->m_spiGuid = spiritGuid;
+            }
+            else
+                workshop->m_spiGuid = 0;
+            workshop->m_workshopGuid = guid;
+            AddCapturePoint(workshop);
+            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
+            workshop->SetTeamByBuildingState();
+        }
+    }while(result->NextRow());
+
+    engGuids.clear();
+    spiritGuids.clear();
+
+    if (!m_gate)
+    {
+        sLog.outError("Cannot find wintergrasp fortress gate!");
+        return false;
+    }
+
+    // Load Graveyard
+    GraveYardMap::const_iterator graveLow  = sObjectMgr.mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
+    GraveYardMap::const_iterator graveUp   = sObjectMgr.mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
+    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
+    {
+        if ((*itr)->icon[1] == 8)
+        {
+            // find or create grave yard
+            const WorldSafeLocsEntry *loc = sObjectMgr.GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
+            if (!loc)
+            {
+                ++itr;
+                continue;
+            }
+
+            GraveYardMap::const_iterator graveItr;
+            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
+                if (graveItr->second.safeLocId == loc->ID)
+                    break;
+            if (graveItr == graveUp)
+            {
+                GraveYardData graveData;
+                graveData.safeLocId = loc->ID;
+                graveData.team = 0;
+                graveItr = sObjectMgr.mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
+            }
+
+            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
+            {
+                if (stateItr->second->worldState == (*itr)->worldState)
+                {
+                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
+                    break;
+                }
+            }
+            areaPOIs.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+
+    //Titan Relic
+    sObjectMgr.AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
+
+    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
+    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
+
+    sWorld.SendWintergraspState();
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+
+    RemoveOfflinePlayerWGAuras();
+
+    RegisterZone(ZONE_WINTERGRASP);
+
+    if (m_wartime)
+    {
+        uint32 m_WSTimer = m_timer;
+        StartBattle();
+        m_timer = m_WSTimer;
+    }
+
+    return true;
+}
+
+void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
+{	
+    if (obj->GetEntry() == 192829) // Titan Relic
+    {
+        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && m_gate && m_gate->damageState == DAMAGE_DESTROYED)
+        {
+            m_changeDefender = true;
+            m_timer = 0;
+        }
+    }
+    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
+        if (itr == m_buildingStates.end())
+            return;
+
+        std::string msgStr;
+        switch(eventId)
+        { // TODO - Localized msgs of GO names
+            case 19672: case 19675: // Flamewatch Tower
+                msgStr = "Flamewatch";
+                break;
+            case 18553: case 19677: // Shadowsight Tower
+                msgStr = "Shadowsight";
+                break;
+            case 19673: case 19676: // Winter's Edge Tower
+                msgStr = "Winter's Edge";
+                break;
+            case 19776: case 19778: // E Workshop damaged
+                msgStr = "Sunken Ring";
+                break;
+            case 19777: case 19779: // W Workshop damaged
+                msgStr = "Broken Temple";
+                break;
+            case 19782: case 19786: // NW Workshop damaged
+                msgStr = "north-western";
+                break;
+            case 19783: case 19787: // NE Workshop damaged
+                msgStr = "north-eastern";
+                break;
+            case 19784: case 19788: // SW Workshop damaged
+                msgStr = "Westpark";
+                break;
+            case 19785: case 19789: // SE Workshop damaged
+                msgStr = "Eastpark";
+                break;
+            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
+                msgStr = "north-western";
+                break;
+            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
+                msgStr = "north-eastern";
+                break;
+            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
+                msgStr = "south-western";
+                break;
+            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
+                msgStr = "south-eastern";
+                break;
+            default:
+                msgStr = "";
+        }
+
+        BuildingState *state = itr->second;
+        if (eventId == obj->GetGOInfo()->building.damagedEvent)
+        {
+            state->damageState = DAMAGE_DAMAGED;
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+	           for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+	                  (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+		break;
+                case BUILDING_TOWER:
+                    ++m_towerDamagedCount[state->GetTeam()];
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+			   for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                  }
+                     else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+	                   (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+                    break;
+            }
+        }
+        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
+        {
+            state->damageState = DAMAGE_DESTROYED;
+
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                    ModifyWorkshopCount(state->GetTeam(), false);
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    break;
+                case BUILDING_WALL:
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+			    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+		          (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                  }
+                    break;
+                case BUILDING_TOWER:
+                    --m_towerDamagedCount[state->GetTeam()];
+                    ++m_towerDestroyedCount[state->GetTeam()];
+                    if (state->GetTeam() == getAttackerTeam())
+                    {
+                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
+                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
+                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
+
+                        if (m_towerDestroyedCount[getAttackerTeam()])
+                        {
+                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
+                        }
+
+                        if (attStack)
+                        {
+                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
+                        }
+                        else
+                        {
+                            if (m_timer < 600000)
+                                m_timer = 0;
+                            else
+                                m_timer = m_timer - 600000; // - 10 mins
+                        }
+                    }
+                    msgStr = fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
+                    sWorld.SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+	    	    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                   {
+	                if (getDefenderTeam()==TEAM_ALLIANCE)
+	                  {
+                      TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+	                  }
+                    else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+	                (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                  {
+	               if (getDefenderTeam()==TEAM_ALLIANCE)
+	                 {
+                     TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+	                 }
+                   else TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+			       (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
+                  }
+                    break;
+            }
+            BroadcastStateChange(state);
+        }
+    }
+}
+
+void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
+{
+    // if server crashed while in battle there could be players with rank or tenacity
+    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
+        SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
+}
+
+void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
+{
+    if (team == TEAM_NEUTRAL)
+        return;
+
+    if (add)
+        ++m_workshopCount[team];
+    else if (m_workshopCount[team])
+        --m_workshopCount[team];
+    else
+        sLog.outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
+
+    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
+}
+
+uint32 OutdoorPvPWG::GetCreatureEntry(uint32 guidlow, const CreatureData *data)
+{
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+    {
+        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
+        if (itr != m_creEntryPair.end())
+        {
+            const_cast<CreatureData*>(data)->displayid = 0;
+            return itr->second;
+        }
+    }
+    return data->id;
+}
+
+OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
+{
+    // VEHICLES, GUARDS and TURRETS gives kill credit
+    // OTHER Not in wartime
+    // TURRET Only during wartime
+    // SPECIAL like "OTHER" but no despawn conditions
+    // Entries like Case A: Case: B have their own despawn function
+    switch(entry)
+    {
+        case 27881: // Catapult
+        case 28094: // Demolisher
+        case 28312: // Alliance Siege Engine
+        case 32627: // Horde Siege Engine
+        case 28319: // Siege turret
+        case 32629: // Siege turret
+            return CREATURE_SIEGE_VEHICLE;
+        case 28366: // Wintergrasp Tower cannon
+            return CREATURE_TURRET;
+        case CRE_ENG_A: // Alliance Engineer
+        case CRE_ENG_H: // Horde Engineer
+            return CREATURE_ENGINEER;
+        case 30739:case 30740: // Champions
+        case 32307:case 32308: // Guards
+            return CREATURE_GUARD;
+        case CRE_SPI_A: // Dwarven Spirit Guide
+        case CRE_SPI_H: // Taunka Spirit Guide
+            return CREATURE_SPIRIT_GUIDE;
+        case 6491: // Spirit Healers
+            return CREATURE_SPIRIT_HEALER;
+        case 31101:case 31051: // Hoodoo Master & Sorceress
+        case 31102:case 31052: // Vieron Blazefeather & Bowyer
+        case 31107:case 31109: // Lieutenant & Senior Demolitionist
+        case 31151:case 31153: // Tactical Officer
+        case 31106:case 31108: // Siegesmith & Siege Master
+        case 31053:case 31054: // Primalist & Anchorite
+        case 31091:case 31036: // Commander
+            return CREATURE_QUESTGIVER;
+        case 32615:case 32626: // Warbringer && Brigadier General
+        case 32296:case 32294: // Quartermaster
+        case 39173:case 39172: // Ros'slai && Marshal Magruder
+        case 30870:case 30869: // Flight Masters
+            return CREATURE_SPECIAL;
+        default:
+            return CREATURE_OTHER; // Revenants, Elementals, etc
+    }
+}
+
+void OutdoorPvPWG::OnCreatureCreate(Creature *creature, bool add)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            if (add)
+            {
+                if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                    team = TEAM_ALLIANCE;
+                else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                    team = TEAM_HORDE;
+                else
+                    return;
+
+                if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
+                {
+                    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
+                    {
+                        if (CanBuildVehicle(workshop))
+                        {
+                            m_vehicles[team].insert(creature);
+                            //workshop->m_vehicles.insert(creature);
+                        }
+                        else
+                        {
+                            creature->setDeathState(DEAD);
+                            creature->SetRespawnTime(DAY);
+                            return;
+                        }
+                    }
+                }
+
+                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
+                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
+            }
+            else // the faction may be changed in uncharm
+            {
+                // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
+                if (m_vehicles[TEAM_ALLIANCE].erase(creature))
+                    team = TEAM_ALLIANCE;
+                else if (m_vehicles[TEAM_HORDE].erase(creature))
+                    team = TEAM_HORDE;
+                else
+                    return;
+            }
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            if (add)
+                m_questgivers[creature->GetDBTableGUIDLow()] = creature;
+            else
+                m_questgivers.erase(creature->GetDBTableGUIDLow());
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = add ? creature : NULL;
+                        break;
+                    }
+            }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = add ? creature : NULL;
+                        break;
+                    }
+            }
+            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
+        case CREATURE_SPIRIT_HEALER:
+        case CREATURE_TURRET:
+        case CREATURE_OTHER:
+            if (add)
+                UpdateCreatureInfo(creature);
+        default:
+            if (add)
+                m_creatures.insert(creature);
+            else
+                m_creatures.erase(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectCreate(GameObject *go, bool add)
+{
+	/*Vehicle teleport need to be fixed crash
+    uint32 entry = go->GetEntry();
+	switch(entry)
+	{
+		case 192951:
+			VehicleTeleporterGUID = go->GetGUID(); // 1th Teleporter (GUID = 67268)
+			VehicleTeleporterGUID2 = VehicleTeleporterGUID-1; // 2th Teleporter (GUID = 67267)
+			break;
+	}*/
+
+    OutdoorPvP::OnGameObjectCreate(go, add);
+
+    if (UpdateGameObjectInfo(go))
+    {
+        if (add) m_gobjects.insert(go);
+        else m_gobjects.erase(go);
+    }
+    //do we need to store building?
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+        {
+            itr->second->building = add ? go : NULL;
+            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
+                itr->second->type = BUILDING_TOWER;
+            if (!add || itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
+            {
+                itr->second->health = go->GetGOValue()->building.health;
+                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+            else
+            {
+                go->GetGOValue()->building.health = itr->second->health;
+                if (itr->second->damageState == DAMAGE_DAMAGED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                else if (itr->second->damageState == DAMAGE_DESTROYED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::UpdateAllWorldObject()
+{
+    // update cre and go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+        UpdateGameObjectInfo(*itr);
+    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
+        UpdateCreatureInfo(*itr);
+    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
+        UpdateQuestGiverPosition((*itr).first, (*itr).second);
+
+    // rebuild and update building states
+    RebuildAllBuildings();
+
+    // update capture points
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            workshop->SetTeamByBuildingState();
+}
+
+void OutdoorPvPWG::RebuildAllBuildings()
+{
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+    {
+        if (itr->second->building)
+        {
+            UpdateGameObjectInfo(itr->second->building);
+            itr->second->building->Rebuild();
+            itr->second->health = itr->second->building->GetGOValue()->building.health;
+        }
+        else
+            itr->second->health = 0;
+
+        if (itr->second->damageState == DAMAGE_DESTROYED)
+        {
+            if (itr->second->type == BUILDING_WORKSHOP)
+                ModifyWorkshopCount(itr->second->GetTeam(), true);
+        }
+
+        itr->second->damageState = DAMAGE_INTACT;
+        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
+    }
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+}
+
+void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
+    data << uint32(571);
+    data << uint32(ZONE_WINTERGRASP);
+    data << uint32(0);
+    data << uint16(4+2+4+m_buildingStates.size());
+
+    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << m_clock[i];
+
+    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
+    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
+    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
+    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
+
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+        itr->second->FillData(data);
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        BroadcastPacket(data);
+}
+
+void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
+{
+    if (m_sendUpdate)
+        for (uint32 team = 0; team < 2; ++team)
+            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+                state->SendUpdate(*p_itr);
+}
+
+// Called at Start and Battle End
+bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
+{
+    if (!creature)
+        return false;
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_TURRET:
+            if (isWarTime())
+            {
+                if (!creature->isAlive())
+                    creature->Respawn(true);
+                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
+                creature->SetVisibility(VISIBILITY_ON);
+            }
+            else
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->SetVisibility(VISIBILITY_OFF);
+                creature->setFaction(35);
+            }
+            return false;
+        case CREATURE_OTHER:
+            if (isWarTime())
+            {
+                creature->SetVisibility(VISIBILITY_OFF);
+                creature->setFaction(35);
+            }
+            else
+            {
+                creature->RestoreFaction();
+                creature->SetVisibility(VISIBILITY_ON);
+            }
+            return false;
+        case CREATURE_SPIRIT_GUIDE:
+            /*Vehicle teleport Need to be fixed crash 
+            pMap = creature->GetMap(); */
+            if (isWarTime())
+            {
+               if (creature->GetAreaId() == 4575) // Select Fortress Spirit
+               {
+                 FortressSpirit = creature;
+                 if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
+                 {
+                    FortressSpirit->UpdateEntry(CRE_SPI_A);
+                 }
+                 if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
+                 {
+                    FortressSpirit->UpdateEntry(CRE_SPI_H);
+                 }
+               }
+                creature->SetVisibility(VISIBILITY_ON);
+                //creature->setDeathState(ALIVE);
+            }
+            else
+            {
+                creature->SetVisibility(VISIBILITY_OFF);
+                //creature->setDeathState(DEAD);
+            }
+            return false;
+        case CREATURE_SPIRIT_HEALER:
+            creature->SetVisibility(isWarTime() ? VISIBILITY_OFF : VISIBILITY_ON);
+            return false;
+        case CREATURE_ENGINEER:
+            return false;
+        case CREATURE_SIEGE_VEHICLE:
+            //creature->DisappearAndDie();
+            return false;
+        case CREATURE_GUARD:
+        case CREATURE_SPECIAL:
+        {
+            TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
+            if (itr != m_creEntryPair.end())
+            {
+                entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
+                _RespawnCreatureIfNeeded(creature, entry);
+            }
+            return false;
+        }
+        default:
+            return false;
+    }
+}
+
+bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
+{
+    assert(guid);
+    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
+
+    if (creature && creature->IsInWorld())
+    {
+        // if not questgiver or position is the same, do nothing
+        if (creature->GetPositionX() == pos.GetPositionX() &&
+            creature->GetPositionY() == pos.GetPositionY() &&
+            creature->GetPositionZ() == pos.GetPositionZ())
+            return false;
+
+        if (creature->isAlive() && creature->isInCombat())
+        {
+            creature->CombatStop(true);
+            creature->getHostileRefManager().deleteReferences();
+        }
+        creature->SetHomePosition(pos);
+        creature->DestroyForNearbyPlayers();
+        if (!creature->GetMap()->IsLoaded(pos.GetPositionX(), pos.GetPositionY()))
+            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
+        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+        if (!creature->isAlive())
+            creature->Respawn(true);
+    }
+    else
+        sObjectMgr.MoveCreData(guid, 571, pos);
+
+    return true;
+}
+
+// Return false = Need to rebuild at battle End/Start
+//        true  = no need to rebuild (ie: Banners or teleporters)
+bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
+{
+    uint32 attFaction = 35;
+    uint32 defFaction = 35;
+
+    if (isWarTime())
+    {
+        attFaction = WintergraspFaction[getAttackerTeam()];
+        defFaction = WintergraspFaction[getDefenderTeam()];
+    }
+
+    switch(go->GetGOInfo()->displayId)
+    {
+        case 8244: // Defender's Portal - Vehicle Teleporter
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
+            return true;
+        case 7967: // Titan relic
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
+            return true;
+
+        case 8165: // Wintergrasp Keep Door
+        case 7877: // Wintergrasp Fortress Wall
+        case 7878: // Wintergrasp Keep Tower
+        case 7906: // Wintergrasp Fortress Gate
+        case 7909: // Wintergrasp Wall
+            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
+            return false;
+        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
+            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
+            return false;
+        case 8208: // Goblin Workshop
+            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
+            if (workshop)
+                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
+            return false;
+    }
+
+    // Note: this is only for test, still need db support
+    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
+    if (itr != m_goDisplayPair.end())
+    {
+        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
+            itr->second : itr->first);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+		if (plr->getLevel() < 75) 
+		{
+		plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
+		return;
+		}
+        if (plr->getLevel() > 74)
+        {
+            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
+                && !plr->HasAura(SPELL_LIEUTENANT))
+                plr->CastSpell(plr, SPELL_RECRUIT, true);
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            }
+            else
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+            }
+        }
+    }
+
+    SendInitWorldStatesTo(plr);
+    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+// Reapply Auras if needed
+void OutdoorPvPWG::HandlePlayerResurrects(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() > 74)
+        {
+            // Tenacity
+            if (plr->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
+                plr->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
+            {
+                if (plr->HasAura(SPELL_TENACITY))
+                    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
+                if (newStack > 20)
+                    newStack = 20;
+                plr->SetAuraStack(SPELL_TENACITY, plr, newStack);
+            }
+
+            // Tower Control
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            }
+            else
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+            }
+        }
+    }
+    OutdoorPvP::HandlePlayerResurrects(plr, zone);
+}
+
+void OutdoorPvPWG::HandlePlayerLeaveZone(Player * plr, uint32 zone)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (!plr->GetSession()->PlayerLogout())
+    {
+        if (plr->GetVehicle()) // dismiss in change zone case
+            plr->GetVehicle()->Dismiss();
+        plr->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        plr->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        plr->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        plr->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        plr->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    }
+    plr->RemoveAurasDueToSpell(SPELL_TENACITY);
+    OutdoorPvP::HandlePlayerLeaveZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::PromotePlayer(Player *killer) const
+{
+    Aura * aur;
+    if (aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
+        }
+        else
+            killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
+        }
+        else
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
+        return;
+
+    bool ok = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->getLevel() >= 70)
+            ok = true;
+        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+    }
+    else
+    {
+        switch(GetCreatureType(victim->GetEntry()))
+        {
+            case CREATURE_SIEGE_VEHICLE:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
+                ok = true;
+                break;
+            case CREATURE_GUARD:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+                ok = true;
+                break;
+            case CREATURE_TURRET:
+                ok = true;
+                break;
+        }
+    }
+
+    if (ok)
+    {
+        if (Group *pGroup = killer->GetGroup())
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
+                    PromotePlayer(itr->getSource());
+        }
+        else if (killer->getLevel() > 74)
+            PromotePlayer(killer);
+    }
+}
+
+// Recalculates Tenacity and applies it to Players / Vehicles
+void OutdoorPvPWG::UpdateTenacityStack()
+{
+    if (!isWarTime())
+        return;
+
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = 0;
+    uint32 hordeNum = 0;
+    int32 newStack = 0;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++allianceNum;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++hordeNum;
+
+    if (allianceNum && hordeNum)
+    {
+        if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+    }
+
+    if (newStack == m_tenacityStack)
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
+    }
+}
+
+void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
+{
+    uint32 value = timer%mod;
+    if (m_clock[digit] != value)
+    {
+        m_clock[digit] = value;
+        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
+        sWorld.SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
+    }
+}
+
+void OutdoorPvPWG::UpdateClock()
+{
+    uint32 timer = m_timer / 1000;
+    if (!isWarTime())
+        UpdateClockDigit(timer, 1, 10);
+    else
+        UpdateClockDigit(timer, 0, 10);
+
+//Announce in all world, comment it if you don't like/need it
+	 // Announce 30 minutes left
+ 	 if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false)) 
+        sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
+ 
+ 	 // Announce 10 minutes left
+	 if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false)) 
+       sWorld.SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
+}
+
+bool OutdoorPvPWG::Update(uint32 diff)
+{
+    if (!sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return false;
+
+    if (m_timer > diff)
+    {
+        m_timer -= diff;
+
+        if (isWarTime())
+        {
+            OutdoorPvP::Update(diff); // update capture points
+
+            /*********************************************************/
+            /***      BATTLEGROUND VEHICLE TELEPORTER SYSTEM       ***/
+            /*********************************************************/
+ /*Need to be fixed Crash ant timer freeze
+            GameObject* VehicleTeleporter;
+            GameObject* VehicleTeleporter2;
+
+            if (!VehicleTeleporterGUID)
+            {
+                return false;
+            }
+            else
+            {
+                VehicleTeleporter = pMap->GetGameObject(VehicleTeleporterGUID);
+                VehicleTeleporter2 = pMap->GetGameObject(VehicleTeleporterGUID2);
+
+                Map::PlayerList const &PlayerList = pMap->GetPlayers();
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (getDefenderTeam() == TEAM_ALLIANCE)
+                    {
+                        if (i->getSource()->ToPlayer()->GetTeam() == ALLIANCE)
+                        {
+                            if (i->getSource()->GetDistance2d(VehicleTeleporter) <= 4 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()) && i->getSource()->isAlive())
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 28319) // Alliance Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisibility(VISIBILITY_ON);
+                                    Old->ForcedDespawn();
+                                }
+                                else
+                                {
+                                Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                New->SetHealth(Old->GetHealth());
+                                New->SetRespawnTime(Old->GetRespawnTime());
+                                i->getSource()->ExitVehicle();
+                                Old->SetVisibility(VISIBILITY_ON);
+                                Old->ForcedDespawn();
+                                Vehicle *vehicle = New->GetVehicleKit();
+                                i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                i->getSource()->EnterVehicle(vehicle);
+                                }
+                            }
+                            if (i->getSource()->GetDistance2d(VehicleTeleporter2) <= 4 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()))
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 28319) // Alliance Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisibility(VISIBILITY_ON);
+                                    Old->ForcedDespawn();
+                                }
+                                else
+                                {
+                                Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                New->SetHealth(Old->GetHealth());
+                                New->SetRespawnTime(Old->GetRespawnTime());
+                                i->getSource()->ExitVehicle();
+                                Old->SetVisibility(VISIBILITY_ON);
+                                Old->ForcedDespawn();
+                                Vehicle *vehicle = New->GetVehicleKit();
+                                i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                i->getSource()->EnterVehicle(vehicle);
+                                }
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (i->getSource()->ToPlayer()->GetTeam() == HORDE)
+                        {
+                            if (i->getSource()->GetDistance2d(VehicleTeleporter) <= 4 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()) && i->getSource()->isAlive())
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 32629) // Horde Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisibility(VISIBILITY_ON);
+                                    Old->ForcedDespawn();
+                                }
+                                else
+                                {
+                                Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                New->SetHealth(Old->GetHealth());
+                                New->SetRespawnTime(Old->GetRespawnTime());
+                                i->getSource()->ExitVehicle();
+                                Old->SetVisibility(VISIBILITY_ON);
+                                Old->ForcedDespawn();
+                                Vehicle *vehicle = New->GetVehicleKit();
+                                i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                i->getSource()->EnterVehicle(vehicle);
+                                }
+                            }
+                            if (i->getSource()->GetDistance2d(VehicleTeleporter2) <= 4 && i->getSource()->IsOnVehicle(i->getSource()->GetVehicleCreatureBase()) && i->getSource()->isAlive())
+                            {
+                                Creature* Old = i->getSource()->GetVehicleCreatureBase();
+                                if (Old->GetEntry() == 32629) // Horde Turret
+                                {
+                                    i->getSource()->ExitVehicle();
+                                    i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                    Old->SetVisibility(VISIBILITY_ON);
+                                    Old->ForcedDespawn();
+                                }
+                                else
+                                {
+                                Creature* New = i->getSource()->SummonCreature(Old->GetEntry(), 5141.191406f, 2841.045410f, 408.703217f, 3.163321f, TEMPSUMMON_MANUAL_DESPAWN);
+                                New->SetPower(POWER_MANA, Old->GetPower(POWER_MANA));
+                                New->SetPower(POWER_RAGE, Old->GetPower(POWER_RAGE));
+                                New->SetPower(POWER_FOCUS, Old->GetPower(POWER_FOCUS));
+                                New->SetPower(POWER_ENERGY, Old->GetPower(POWER_ENERGY));
+                                New->SetHealth(Old->GetHealth());
+                                New->SetRespawnTime(Old->GetRespawnTime());
+                                i->getSource()->ExitVehicle();
+                                Old->SetVisibility(VISIBILITY_ON);
+                                Old->ForcedDespawn();
+                                Vehicle *vehicle = New->GetVehicleKit();
+                                i->getSource()->NearTeleportTo(5141.191406f, 2841.045410f, 408.703217f, 3.163321f, true); // Out of the Fortress Gate
+                                i->getSource()->EnterVehicle(vehicle);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+*/
+            /*********************************************************/
+            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
+            /*********************************************************/
+
+            //this should be handled by spell system
+            m_LastResurrectTime += diff;
+            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+            {
+                if (GetReviveQueueSize())
+                {
+                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+                    {
+                        Creature* sh = NULL;
+                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                        {
+                            Player *plr = sObjectMgr.GetPlayer(*itr2);
+                            if (!plr)
+                                continue;
+
+                            if (!sh && plr->IsInWorld())
+                            {
+                                sh = plr->GetMap()->GetCreature(itr->first);
+                                // only for visual effect
+                                if (sh)
+                                    // Spirit Heal, effect 117
+                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                            }
+
+                            // Resurrection visual
+                         if (plr->GetDistance2d(sh) <= 18.0f)
+                           {
+                            plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+                            m_ResurrectQueue.push_back(*itr2);
+                           }
+                        }
+                        (itr->second).clear();
+                    }
+
+                    m_ReviveQueue.clear();
+                    m_LastResurrectTime = 0;
+                }
+                else
+                    // queue is clear and time passed, just update last resurrection time
+                    m_LastResurrectTime = 0;
+            }
+            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+            {
+                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+                {
+                    Player *plr = sObjectMgr.GetPlayer(*itr);
+                    if (!plr)
+                        continue;
+                    plr->ResurrectPlayer(1.0f);
+                    plr->CastSpell(plr, 6962, true);
+                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+                    sObjectAccessor.ConvertCorpseForPlayer(*itr);
+                }
+                m_ResurrectQueue.clear();
+            }
+        }
+        UpdateClock();
+    }
+    else
+    {
+        m_sendUpdate = false;
+        int32 entry = LANG_BG_WG_DEFENDED;
+
+        if (m_changeDefender)
+        {
+            m_changeDefender = false;
+            m_defender = getAttackerTeam();
+            entry = LANG_BG_WG_CAPTURED;
+        }
+
+        if (isWarTime())
+        {
+            if (m_timer != 1) // 1 = forceStopBattle
+                sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(entry), sObjectMgr.GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+            EndBattle();
+        }
+        else
+        {
+            if (m_timer != 1) // 1 = forceStartBattle
+                sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
+            StartBattle();
+        }
+
+        UpdateAllWorldObject();
+        UpdateClock();
+
+        SendInitWorldStatesTo();
+        m_sendUpdate = true;
+    }
+
+    if (m_WSSaveTimer < diff)
+    {
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31001', `value`='%d', `comment`='wg m_wartime'",m_wartime);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31002', `value`='%d', `comment`='wg m_timer'",m_timer);
+        CharacterDatabase.PExecute("replace  `worldstates` set `entry`='31003', `value`='%d', `comment`='wg m_defender'",m_defender);
+        m_WSSaveTimer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+    } else m_WSSaveTimer -= diff;
+
+
+    return false;
+}
+
+void OutdoorPvPWG::forceStartBattle()
+{ // Uptime will do all the work
+    m_wartime = false;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
+    }
+		sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceStopBattle()
+{ // Uptime will do all the work.
+
+    if (!isWarTime())
+        m_wartime = true;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld.SendZoneText(ZONE_WINTERGRASP, sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
+    }
+	sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceChangeTeam()
+{
+    m_changeDefender = true;
+    m_timer = 1;
+    sWorld.SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr.GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr.GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+    if (isWarTime())
+        forceStartBattle();
+    else
+        forceStopBattle();
+}
+
+// Can be forced by gm's while in battle so have to reset in case it was wartime
+void OutdoorPvPWG::StartBattle()
+{
+	uint32 CountDef=0;
+	uint32 CountAtk=0;
+    m_wartime = true;
+    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
+
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+       if ((*itr)->getLevel() < 75)
+        {
+          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        }
+       else
+        {
+          CountDef++;
+          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        if ((*itr)->getLevel() < 75)
+        {
+          (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        }
+        else
+        {
+          CountAtk++;
+          (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+          (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+          (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+          (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+        }
+    }
+
+if (sWorld.getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
+ {
+ if ((CountAtk < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld.getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
+  {
+   if (CountAtk<=CountDef)
+	   sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
+   if (CountDef<CountAtk)
+     {  
+	 sWorld.SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
+	 m_changeDefender=true;
+     }
+   forceStopBattle();
+   return;
+  }
+ }
+
+//    TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
+
+    // Remove Essence of Wintergrasp to all players
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+    sWorld.UpdateAreaDependentAuras();
+
+    // destroyed all vehicles
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+        {
+            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() > 74)
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+    }
+    UpdateTenacityStack();
+	// Update timer in players battlegrounds tab
+    sWorld.SendWintergraspState();
+}
+
+void OutdoorPvPWG::EndBattle()
+{
+    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
+    sWorld.setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    sWorld.UpdateAreaDependentAuras();
+//Sound on End Battle
+for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+{
+	if (getDefenderTeam()==TEAM_ALLIANCE)
+	{
+    TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
+	}
+    else TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
+	(*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
+}
+for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+{
+   (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
+}
+
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // destroyed all vehicles
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+
+        if (m_players[team].empty())
+            continue;
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            // When WG ends the zone is cleaned including corpses, revive all players if dead
+            if ((*itr)->isDead())
+            {
+                (*itr)->ResurrectPlayer(1.0f);
+				sObjectAccessor.ConvertCorpseForPlayer((*itr)->GetGUID());
+                //ObjectAccessor::Instance().ConvertCorpseForPlayer((*itr)->GetGUID());
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+            (*itr)->CombatStop(true);
+            (*itr)->getHostileRefManager().deleteReferences();
+        }
+
+        if (m_timer == 1) // Battle End was forced so no reward.
+        {
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+            continue;
+        }
+
+        // calculate rewards
+        uint32 intactNum = 0;
+        uint32 damagedNum = 0;
+        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                if (workshop->m_buildingState->GetTeam() == team)
+                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
+                        ++damagedNum;
+                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
+                        ++intactNum;
+
+        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
+        uint32 baseHonor = 0;
+        uint32 marks = 0;
+        uint32 playersWithRankNum = 0;
+        uint32 honor = 0;
+
+        if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+        {
+            // Calculate Level 70+ with Corporal or Lieutenant rank
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
+                    ++playersWithRankNum;
+
+            baseHonor = team == getDefenderTeam() ? sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
+            baseHonor += (sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
+            if (playersWithRankNum)
+                baseHonor /= playersWithRankNum;
+        }
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+
+            if ((*itr)->getLevel() < 75)
+                continue; // No rewards for level <75
+
+            // give rewards
+            if (sWorld.getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+            {
+                if (team == getDefenderTeam())
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 3;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 2;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 1;
+                        honor = 0;
+                    }
+                }
+                else
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else
+                    {
+                        marks = 0;
+                        honor = 0;
+                    }
+                }
+                (*itr)->RewardHonor(NULL, 1, honor);
+                RewardMarkOfHonor(*itr, marks);
+                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
+            }
+            else
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    // TODO - Honor from SpellReward should be shared by team players
+                    // TODO - Marks should be given depending on Rank but 3 are given
+                    // each time so Won't give any to recruits
+                    (*itr)->CastSpell(*itr, spellRewardId, true);
+                    for (uint32 i = 0; i < intactNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
+                    for (uint32 i = 0; i < damagedNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
+                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
+                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
+                }
+            }
+            if (team == getDefenderTeam())
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
+                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
+                }
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        }
+    }
+
+    m_wartime = false;
+    m_timer = sWorld.getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
+    RemoveOfflinePlayerWGAuras();
+    // Update timer in players battlegrounds tab
+    sWorld.SendWintergraspState();
+}
+
+bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
+{
+    TeamId team = workshop->m_buildingState->GetTeam();
+    if (team == TEAM_NEUTRAL)
+        return false;
+
+    return isWarTime()
+        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
+        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
+}
+
+uint32 OutdoorPvPWG::GetData(uint32 id)
+{
+    // if can build more vehicles
+    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
+        return CanBuildVehicle(workshop) ? 1 : 0;
+
+    return 0;
+}
+
+void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return;
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        sLog.outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
+{
+    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
+    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
+    m_questgivers[guid] = NULL;
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+        sObjectMgr.MoveCreData(guid, 571, posAlli);
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
+{
+    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
+        return dynamic_cast<OPvPCapturePointWG*>(cp);
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_engGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_workshopGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+/*########################################################
+ * Copy of Battleground system to make Spirit Guides Work
+ *#######################################################*/
+void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    pl->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player *plr = sObjectMgr.GetPlayer(player_guid);
+    if (!plr)
+        return;
+
+    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+
+                Player *plr = sObjectMgr.GetPlayer(player_guid);
+                if (!plr)
+                    return;
+
+                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+
+                return;
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr.GetPlayer(*itr);
+			if (!plr)
+                continue;
+
+			if (plr->getFaction() == ALLIANCE)
+			{
+            if (!ClosestGrave)
+                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+			}
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr.GetPlayer(*itr);
+			if (!plr)
+                continue;
+
+			if (plr->getFaction() == HORDE)
+			{
+            if (!ClosestGrave)
+                ClosestGrave = sObjectMgr.GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+
+            if (ClosestGrave)
+                plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+			}
+        }
+    }
+}
+
+/*######
+##OPvPCapturePointWG
+######*/
+
+OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state)
+: OPvPCapturePoint(opvp), m_buildingState(state), m_wintergrasp(opvp)
+, m_engineer(NULL), m_engGuid(0), m_spiritguide(NULL)
+, m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_spiGuid(0)
+{
+}
+
+void OPvPCapturePointWG::SetTeamByBuildingState()
+{
+    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
+    {
+        m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+    }
+    else if (m_buildingState->GetTeam() == TEAM_HORDE)
+    {
+        m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+    }
+    else
+    {
+        m_value = 0;
+        m_State = OBJECTIVESTATE_NEUTRAL;
+    }
+
+    if (m_team != m_buildingState->GetTeam())
+    {
+        TeamId oldTeam = m_team;
+        m_team = m_buildingState->GetTeam();
+        ChangeTeam(oldTeam);
+    }
+
+    SendChangePhase();
+}
+
+void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
+{
+   entry = 0;
+   guide_entry = 0;
+   guide_entry_fortress_horde = 0;
+   guide_entry_fortress_alliance = 0;
+
+    if (oldTeam != TEAM_NEUTRAL)
+        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
+
+    if (m_team != TEAM_NEUTRAL)
+    {
+        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
+        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
+        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
+        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
+        m_wintergrasp->ModifyWorkshopCount(m_team, true);
+    }
+
+    if (m_capturePoint)
+        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
+
+    m_buildingState->SetTeam(m_team);
+    // TODO: this may be sent twice
+    m_wintergrasp->BroadcastStateChange(m_buildingState);
+
+    if (m_buildingState->building)
+        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
+
+    if (entry)
+    {
+        if (m_engGuid)
+        {
+            *m_engEntry = entry;
+            _RespawnCreatureIfNeeded(m_engineer, entry);
+        }
+        if (m_spiGuid)
+        {
+         if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
+         {
+            *m_spiEntry = guide_entry;
+            _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
+            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
+            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
+         }
+         else
+         {
+            *m_spiEntry = guide_entry;
+            _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
+            m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
+            _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+            m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
+         }
+        }
+    }
+    else if (m_engineer)
+        m_engineer->SetVisibility(VISIBILITY_OFF);
+
+    sLog.outDebug("Wintergrasp workshop now belongs to %u.", (uint32)m_buildingState->GetTeam());
+}
+
+class OutdoorPvP_wintergrasp : public OutdoorPvPScript
+{
+    public:
+
+        OutdoorPvP_wintergrasp()
+            : OutdoorPvPScript("outdoorpvp_wg")
+        {
+        }
+
+        OutdoorPvP* GetOutdoorPvP() const
+        {
+            return new OutdoorPvPWG();
+        }
+};
+
+void AddSC_outdoorpvp_wg()
+{
+    new OutdoorPvP_wintergrasp();
+}
\ No newline at end of file
diff --git a/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2008-2010 Trinity <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ */
+
+#ifndef OUTDOOR_PVP_WG_
+#define OUTDOOR_PVP_WG_
+
+#include "OutdoorPvP.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+
+#define ZONE_DALARAN             4395
+#define ZONE_WINTERGRASP         4197
+#define POS_X_CENTER             5100
+#define MAX_VEHICLE_PER_WORKSHOP    4
+
+const uint32 WintergraspFaction[3] = {1802, 1801, 35};
+const uint32 WG_MARK_OF_HONOR = 43589;
+const uint32 VehNumWorldState[2] = {3680,3490};
+const uint32 MaxVehNumWorldState[2] = {3681,3491};
+const uint32 ClockWorldState[2] = {3781,4354};
+
+enum OutdoorPvPWGSpell
+{
+    // Wartime auras
+    SPELL_RECRUIT                                = 37795,
+    SPELL_CORPORAL                               = 33280,
+    SPELL_LIEUTENANT                             = 55629,
+    SPELL_TENACITY                               = 58549,
+    SPELL_TENACITY_VEHICLE                       = 59911,
+    SPELL_TOWER_CONTROL                          = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                         = 56902,
+    SPELL_DEFEAT_REWARD                          = 58494,
+    SPELL_DAMAGED_TOWER                          = 59135,
+    SPELL_DESTROYED_TOWER                        = 59136,
+    SPELL_DAMAGED_BUILDING                       = 59201,
+    SPELL_INTACT_BUILDING                        = 59203,
+
+	SPELL_TELEPORT_ALLIENCE_CAMP                 = 58632,
+	SPELL_TELEPORT_HORDE_CAMP                    = 58633,
+    SPELL_TELEPORT_FORTRESS                      = 59096,
+
+    SPELL_TELEPORT_DALARAN                       = 53360,
+    SPELL_VICTORY_AURA                           = 60044,
+};
+
+const uint16 GameEventWintergraspDefender[2] = {50, 51};
+
+enum OutdoorPvP_WG_Sounds
+{
+    OutdoorPvP_WG_SOUND_KEEP_CLAIMED            = 8192,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE  = 8173,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE     = 8213,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE = 8212,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE    = 8174,
+    OutdoorPvP_WG_SOUND_NEAR_VICTORY            = 8456,
+    OutdoorPvP_WG_SOUND_HORDE_WINS              = 8454,
+    OutdoorPvP_WG_SOUND_ALLIANCE_WINS           = 8455,
+    OutdoorPvP_WG_SOUND_WORKSHOP_Horde          = 6205, // время убивать орда
+    OutdoorPvP_WG_SOUND_WORKSHOP_ALLIANCE       = 6298, // к оружию альянс
+    OutdoorPvP_WG_HORDE_CAPTAIN                 = 8333,
+    OutdoorPvP_WG_ALLIANCE_CAPTAIN              = 8232,
+//    OutdoorPvP_WG_SOUND_START_BATTLE            = 11803,   //L70ETC Concert
+    OutdoorPvP_WG_SOUND_START_BATTLE            = 3439, //Standart BG Start sound
+};
+
+enum DataId
+{
+    DATA_ENGINEER_DIE,
+};
+
+enum OutdoorPvP_WG_KeepStatus
+{
+    OutdoorPvP_WG_KEEP_TYPE_NEUTRAL             = 0,
+    OutdoorPvP_WG_KEEP_TYPE_CONTESTED           = 1,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_CONTESTED    = 1,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_CONTESTED   = 2,
+    OutdoorPvP_WG_KEEP_TYPE_OCCUPIED            = 3,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_OCCUPIED     = 3,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_OCCUPIED    = 4
+};
+
+
+enum OutdoorPVPWGStatus
+{
+ WORLDSTATE_WINTERGRASP_CONTROLING_FACTION,
+ WORLDSTATE_VALUE_COUNT,
+};
+
+enum OutdoorPvPWGCreType
+{
+    CREATURE_OTHER,
+    CREATURE_SIEGE_VEHICLE,
+    CREATURE_TURRET,
+    CREATURE_ENGINEER,
+    CREATURE_GUARD,
+    CREATURE_SPECIAL,
+    CREATURE_SPIRIT_GUIDE,
+    CREATURE_SPIRIT_HEALER,
+    CREATURE_QUESTGIVER,
+};
+
+enum OutdoorPvPWGBuildingType
+{
+    BUILDING_WALL,
+    BUILDING_WORKSHOP,
+    BUILDING_TOWER,
+};
+
+enum OutdoorPvPWGDamageState
+{ // Do not change order
+    DAMAGE_INTACT,
+    DAMAGE_DAMAGED,
+    DAMAGE_DESTROYED,
+};
+
+typedef uint32 TeamPair[2];
+
+enum OutdoorPvPWGQuest
+{
+    A_VICTORY_IN_WG                              = 13181,
+    H_VICTORY_IN_WG                              = 13183,
+    CRE_PVP_KILL                                 = 31086, //Quest Objective - Fixme: this should be handled by DB
+    CRE_PVP_KILL_V                               = 31093, //Quest Objective - Fixme: this should be handled by DB
+};
+
+enum OutdoorPvPWGCreEntry
+{
+    CRE_ENG_A                                    = 30499,
+    CRE_ENG_H                                    = 30400,
+    CRE_SPI_A                                    = 31842,
+    CRE_SPI_H                                    = 31841,
+};
+
+const TeamPair OutdoorPvPWGCreEntryPair[] =
+{
+    {32307, 32308}, // Guards
+    {30739, 30740}, // Champions
+    {32296, 32294}, // Quartermaster
+    {39173, 39172}, // Ros'slai & Marshal Magruder
+    {32615, 32626}, // Warbringer & Brigadier General
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const TeamPair OutdoorPvPWGGODisplayPair[] =
+{
+    {5651, 5652},
+    {8256, 8257},
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const uint32 AreaPOIIconId[3][3] = {{7,8,9},{4,5,6},{1,2,3}};
+typedef std::list<const AreaPOIEntry *> AreaPOIList;
+
+struct BuildingState
+{
+    explicit BuildingState(uint32 _worldState, TeamId _team, bool asDefault)
+        : worldState(_worldState), health(0)
+        , defaultTeam(asDefault ? _team : OTHER_TEAM(_team)), team(_team), damageState(DAMAGE_INTACT)
+        , building(NULL), type(BUILDING_WALL), graveTeam(NULL)
+    {}
+    uint32 worldState;
+    uint32 health;
+    TeamId defaultTeam;
+    OutdoorPvPWGDamageState damageState;
+    GameObject *building;
+    uint32 *graveTeam;
+    OutdoorPvPWGBuildingType type;
+
+    void SendUpdate(Player *player) const
+    {
+        player->SendUpdateWorldState(worldState, AreaPOIIconId[team][damageState]);
+    }
+
+    void FillData(WorldPacket &data) const
+    {
+        data << worldState << AreaPOIIconId[team][damageState];
+    }
+
+    TeamId GetTeam() const { return team; }
+    void SetTeam(TeamId t)
+    {
+        team = t;
+        if(graveTeam)
+            if (uint32 newTeam = TeamId2Team[t])
+                *graveTeam = newTeam;
+    }
+
+private:
+    TeamId team;
+};
+
+typedef std::map<uint32, uint32> TeamPairMap;
+
+class OPvPCapturePointWG;
+
+class OutdoorPvPWG : public OutdoorPvP
+{
+    protected:
+        typedef std::map<uint32, BuildingState *> BuildingStateMap;
+        typedef std::set<Creature*> CreatureSet;
+        typedef std::set<GameObject*> GameObjectSet;
+        typedef std::map<std::pair<uint32, bool>, Position> QuestGiverPositionMap;
+        typedef std::map<uint32, Creature*> QuestGiverMap;
+    public:
+        OutdoorPvPWG();
+        bool SetupOutdoorPvP();
+        int TeamIDsound;
+        uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data);
+
+        void OnCreatureCreate(Creature *creature, bool add);
+        void OnGameObjectCreate(GameObject *go, bool add);
+
+        void ProcessEvent(GameObject *obj, uint32 eventId);
+
+        void HandlePlayerEnterZone(Player *plr, uint32 zone);
+        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+        void HandlePlayerResurrects(Player * plr, uint32 zone);
+        void HandleKill(Player *killer, Unit *victim);
+
+        bool Update(uint32 diff);
+
+        void BroadcastStateChange(BuildingState *state) const;
+
+        uint32 GetData(uint32 id);
+        void SetData(uint32 id, uint32 value) {};
+
+        void ModifyWorkshopCount(TeamId team, bool add);
+        uint32 GetTimer() const { return m_timer / 1000; };
+        bool isWarTime() const { return m_wartime; };
+        void setTimer(uint32 timer) { if (timer >= 0) m_timer = timer; };
+        uint32 GetNumPlayersA() const { return m_players[TEAM_ALLIANCE].size(); };
+        uint32 GetNumPlayersH() const { return m_players[TEAM_HORDE].size(); };
+        TeamId getDefenderTeam() const { return m_defender; };
+        TeamId getAttackerTeam() const { return OTHER_TEAM(m_defender); };
+        void forceChangeTeam();
+        void forceStopBattle();
+        void forceStartBattle();
+
+        // Temporal BG specific till 3.2
+        void SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid);
+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+        void RemovePlayerFromResurrectQueue(uint64 player_guid);
+        void RelocateAllianceDeadPlayers(Creature *cr);
+        void RelocateHordeDeadPlayers(Creature *cr);
+        // BG end
+        void SendInitWorldStatesTo(Player *player = NULL) const;
+        uint32 m_timer;
+    protected:
+        // Temporal BG specific till 3.2
+        std::vector<uint64> m_ResurrectQueue;               // Player GUID
+        uint32 m_LastResurrectTime;
+        // Spirit Guide guid + Player list GUIDS
+        std::map<uint64, std::vector<uint64> >  m_ReviveQueue;
+
+        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
+        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
+        // BG end
+
+        TeamId m_defender;
+        int32 m_tenacityStack;
+
+        BuildingStateMap m_buildingStates;
+        BuildingState *m_gate;
+
+        CreatureSet m_creatures;
+        CreatureSet m_vehicles[2];
+        GameObjectSet m_gobjects;
+        QuestGiverMap m_questgivers;
+
+        TeamPairMap m_creEntryPair, m_goDisplayPair;
+        QuestGiverPositionMap m_qgPosMap;
+
+        bool m_wartime;
+        bool m_changeDefender;
+        uint32 m_clock[2];
+        uint32 m_workshopCount[2];
+        uint32 m_towerDestroyedCount[2];
+        uint32 m_towerDamagedCount[2];
+		uint32 m_WSSaveTimer;
+
+        OPvPCapturePointWG *GetWorkshop(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByEngGuid(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByGOGuid(uint64 lowguid) const;
+
+        void StartBattle();
+        void EndBattle();
+
+        void UpdateClock();
+        void UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod);
+        void PromotePlayer(Player *player) const;
+        void UpdateTenacityStack();
+        void UpdateAllWorldObject();
+        bool UpdateCreatureInfo(Creature *creature);
+        bool UpdateGameObjectInfo(GameObject *go) const;
+
+        bool CanBuildVehicle(OPvPCapturePointWG *workshop) const;
+        OutdoorPvPWGCreType GetCreatureType(uint32 entry) const;
+
+        void RebuildAllBuildings();
+
+        void RemoveOfflinePlayerWGAuras();
+        void RewardMarkOfHonor(Player *player, uint32 count);
+        void MoveQuestGiver(uint32 guid);
+        void LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli);
+        bool UpdateQuestGiverPosition(uint32 guid, Creature *creature);
+};
+
+class OPvPCapturePointWG : public OPvPCapturePoint
+{
+    public:
+        explicit OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state);
+        void SetTeamByBuildingState();
+        void ChangeState() {}
+        void ChangeTeam(TeamId oldteam);
+
+        uint32 *m_spiEntry;
+        uint32 m_spiGuid;
+        Creature *m_spiritguide;
+        Creature *m_spiritguide_horde;
+        Creature *m_spiritguide_alliance;
+
+        uint32 *m_engEntry;
+        uint32 m_engGuid;
+        Creature *m_engineer;
+        uint32 m_workshopGuid;
+        BuildingState *m_buildingState;
+    protected:
+        OutdoorPvPWG *m_wintergrasp;
+};
+
+#endif
diff --git a/src/server/scripts/World/CMakeLists.txt b/src/server/scripts/World/CMakeLists.txt
--- a/src/server/scripts/World/CMakeLists.txt
+++ b/src/server/scripts/World/CMakeLists.txt
@@ -1,24 +1,24 @@
-set(scripts_STAT_SRCS
-  ${scripts_STAT_SRCS}
-  World/npc_professions.cpp
-  World/mob_generic_creature.cpp
-  World/npc_taxi.cpp
-  World/boss_lethon.cpp
-  World/areatrigger_scripts.cpp
-  World/boss_emeriss.cpp
-  World/guards.cpp
-  World/item_scripts.cpp
-  World/npc_customize.cpp
-  World/boss_ysondre.cpp
-  World/npcs_special.cpp
-  World/chat_log.cpp
-  World/boss_taerar.cpp
-  World/npc_mount.cpp
- World/go_scripts.cpp
-  world/PVP_System_Streaks.cpp
- World/npc_innkeeper.cpp
-  World/dungeon_finder.cpp
- World/achievement_scripts.cpp
-)
-
-message("  -> Prepared: World")
+set(scripts_STAT_SRCS
+  ${scripts_STAT_SRCS}
+  World/npc_professions.cpp
+  World/mob_generic_creature.cpp
+  World/npc_taxi.cpp
+  World/boss_lethon.cpp
+  World/areatrigger_scripts.cpp
+  World/boss_emeriss.cpp
+  World/guards.cpp
+  World/item_scripts.cpp
+  World/npc_customize.cpp
+  World/boss_ysondre.cpp
+  World/npcs_special.cpp
+  World/chat_log.cpp
+  World/boss_taerar.cpp
+  World/npc_mount.cpp
+  World/go_scripts.cpp
+  world/pvp_system_streaks.cpp
+  World/npc_innkeeper.cpp
+  World/dungeon_finder.cpp
+  World/achievement_scripts.cpp
+)
+
+message("  -> Prepared: World")
diff --git a/src/server/scripts/World/dungeon_finder.cpp b/src/server/scripts/World/dungeon_finder.cpp
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/World/dungeon_finder.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Interaction between core and LFGMgr
+ */
+
+#include "ScriptPCH.h"
+#include "LFGMgr.h"
+
+class DungeonFinderScript: public GroupScript, PlayerScript
+{
+public:
+    DungeonFinderScript(): GroupScript("DungeonFinderScript"), PlayerScript("DungeonFinderScript") { }
+
+    void OnAddMember(Group* group, uint64 guid)
+    {
+        uint64 gguid = group->GetGUID();
+        sLog.outDebug("OnAddMember [" UI64FMTD "]: added [" UI64FMTD "]", gguid, guid);
+        if (!gguid)
+            return;
+
+        for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            if (Player *plrg = itr->getSource())
+            {
+                plrg->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_CLEAR_LOCK_LIST);
+                plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_CLEAR_LOCK_LIST);
+            }
+        }
+
+        if (group->isLfgQueued())
+            sLFGMgr.Leave(NULL, group);
+
+        Player *plr = sObjectMgr.GetPlayer(guid);
+        if (plr && plr->isUsingLfg())
+            sLFGMgr.Leave(plr);
+    }
+
+    void OnRemoveMember(Group* group, uint64 guid, RemoveMethod& method)
+    {
+        uint64 gguid = group->GetGUID();
+        sLog.outDebug("OnRemoveMember [" UI64FMTD "]: remove [" UI64FMTD "] Method: %d", gguid, guid, method);
+        if (!gguid)
+            return;
+
+        if (group->isLfgQueued())
+        {
+            // TODO - Do not remove, just remove the one leaving and rejoin queue with all other data
+            sLFGMgr.Leave(NULL, group);
+        }
+
+        if (!group->isLFGGroup())
+            return;
+
+        if (!group->isLfgDungeonComplete())                 // Need more players to finish the dungeon
+            sLFGMgr.OfferContinue(group);
+
+        if (method == GROUP_REMOVEMETHOD_KICK)              // Player have been kicked
+        {
+            // TODO - Update internal kick cooldown
+        }
+        else
+        {
+            // Deserter flag
+        }
+
+        if (Player *plr = sObjectMgr.GetPlayer(guid))
+        {
+            plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_LEADER);
+            if (plr->GetMap()->IsDungeon())                 // Teleport player out the dungeon
+                sLFGMgr.TeleportPlayer(plr, true);
+        }
+    }
+
+    void OnDisband(Group* group)
+    {
+        uint64 gguid = group->GetGUID();
+        sLog.outDebug("OnDisband [" UI64FMTD "]", gguid);
+        if (!gguid)
+            return;
+
+        if (group->isLfgQueued())
+            sLFGMgr.Leave(NULL, group);
+
+        for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            if (Player *plrg = itr->getSource())
+            {
+                plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_GROUP_DISBAND);
+                plrg->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_LEADER);
+                if (plrg->GetMap()->IsDungeon())            // Teleport player out the dungeon
+                    sLFGMgr.TeleportPlayer(plrg, true);
+            }
+        }
+    }
+
+    void OnChangeLeader(Group* group, uint64 newLeaderGuid, uint64 oldLeaderGuid)
+    {
+        uint64 gguid = group->GetGUID();
+        sLog.outDebug("OnChangeLeader [" UI64FMTD "]: old [" UI64FMTD "] new [" UI64FMTD "]", gguid, newLeaderGuid, oldLeaderGuid);
+        if (!gguid)
+            return;
+
+        Player *plr = sObjectMgr.GetPlayer(newLeaderGuid);
+        if (plr)
+            plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_LEADER);
+
+        plr = sObjectMgr.GetPlayer(oldLeaderGuid);
+        if (plr)
+            plr->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_GROUP_DISBAND);
+    }
+
+    void OnInviteMember(Group* group, uint64 guid)
+    {
+        uint64 gguid = group->GetGUID();
+        sLog.outDebug("OnInviteMember [" UI64FMTD "]: invite [" UI64FMTD "] leader [" UI64FMTD "]", gguid, guid, group->GetLeaderGUID());
+        if (!gguid)
+            return;
+
+        sLFGMgr.Leave(NULL, group);
+    }
+
+    void OnLevelChanged(Player* /*player*/, uint8 /*newLevel*/)
+    {
+    }
+
+    void OnLogout(Player* player)
+    {
+        sLFGMgr.Leave(player);
+        player->GetSession()->SendLfgUpdateParty(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
+        player->GetSession()->SendLfgUpdatePlayer(LFG_UPDATETYPE_REMOVED_FROM_QUEUE);
+        player->GetSession()->SendLfgUpdateSearch(false);
+    }
+};
+
+void AddSC_dungeon_finder()
+{
+    new DungeonFinderScript();
+}
+
diff --git a/src/server/scripts/World/pvp_system_streaks.cpp b/src/server/scripts/World/pvp_system_streaks.cpp
new file mode 100644
--- /dev/null
+++ b/src/server/scripts/World/pvp_system_streaks.cpp
@@ -0,0 +1,167 @@
+
+//  Posted by kjanko @ http://forum.trinitycore.org/topic/28829-killstreak-pvp-system/
+//  Updated By {VAS} KalCorp to 1.01
+
+
+#include "ScriptPCH.h"
+#include "Configuration/Config.h"
+#include "ScriptMgr.h"
+#include "string.h"
+
+float version = 1.01f;
+std::string PVP_System_Streaks = "";
+uint32 PVP_System_Last_Streak = 50;
+int PVP_System_LoseToken = 0;
+int PVP_System_AnyPlace = 0;
+int PVP_System_BattleGounds = 1;
+int PVP_System_SamePlayer = 1;
+int PVP_System_AddToken = 0;
+std::string PVP_System_Color = "cffFF8000";
+
+
+struct SystemInfo
+{
+    uint32 KillStreak;
+    uint32 LastGUIDKill;
+};
+
+static std::map<uint32, SystemInfo> KillingStreak;
+
+class PVP_System_Streaks_WorldScript : public WorldScript
+{
+    public:
+        PVP_System_Streaks_WorldScript() : WorldScript("PVP_System_Streaks_WorldScript") {}
+
+
+	void SetInitialWorldSettings()
+	{
+		//Needs VAS-Hooks v1.01+ to work
+
+		sLog.outString("----------------------------------------------------");
+		sLog.outString("  Powered by PVP System Streaks v%4.2f ",version); 
+		sLog.outString("----------------------------------------------------");
+
+		PVP_System_Streaks = sConfig.GetStringDefault("PVP.System.Streaks", "5,10,20,30,40,50");
+		PVP_System_Last_Streak = sConfig.GetIntDefault("PVP_System.Last.Streak", 50);
+		PVP_System_LoseToken = sConfig.GetIntDefault("PVP.System.LoseToken", 0);
+		PVP_System_AnyPlace = sConfig.GetIntDefault("PVP.System.AnyPlace", 0);
+		PVP_System_BattleGounds = sConfig.GetIntDefault("PVP.System.BattleGounds", 1);
+		PVP_System_Color = sConfig.GetStringDefault("PVP.System.Color", "cffFF8000");
+		PVP_System_SamePlayer = sConfig.GetIntDefault("PVP.System.SamePlayer", 1);
+		PVP_System_AddToken = sConfig.GetIntDefault("PVP.System.AddToken", 1);
+
+		sLog.outString("  PVP.System.Streaks = %s", PVP_System_Streaks);
+		sLog.outString("  PVP.System.Last.Streak = %u", PVP_System_Last_Streak);
+		sLog.outString("  PVP.System.AnyPlace = %u", PVP_System_AnyPlace);
+		sLog.outString("  PVP.System.BattleGounds = %u", PVP_System_BattleGounds);
+		sLog.outString("  PVP.System.SamePlayer = %u", PVP_System_SamePlayer);
+		sLog.outString("  PVP.System.AddToken = %u", PVP_System_AddToken);
+		sLog.outString("  PVP.System.LoseToken = %u", PVP_System_LoseToken);
+		sLog.outString("  PVP.System.Color = %s", PVP_System_Color.c_str());
+
+		sLog.outString("  Contributors: kjanko, Rusfighter, KalCorp");
+
+		sLog.outString("----------------------------------------------------\n");
+	}
+};
+
+class PVP_System_Streaks_PlayerScript : public PlayerScript
+{
+    public:
+        PVP_System_Streaks_PlayerScript() : PlayerScript("PVP_System_Streaks_PlayerScript") {}
+
+	void OnPVPKill(Player *pKiller, Player *pVictim)
+	{
+		uint32 kGUID; 
+		uint32 vGUID;
+		kGUID = pKiller->GetGUID();
+		vGUID = pVictim->GetGUID(); 
+		char msg[500];
+
+		sLog.outString("PVP_System_Streaks_PlayerScript started");
+
+		if (PVP_System_AnyPlace != 0)
+			if ((!pKiller->GetMap()->IsBattleground()) && PVP_System_BattleGounds != 1)
+				return;
+
+		if(kGUID == vGUID)
+			return;
+                
+		if(KillingStreak[kGUID].LastGUIDKill == vGUID)
+			if (PVP_System_SamePlayer !=1 )
+				return;
+
+                
+		KillingStreak[kGUID].KillStreak++;
+		KillingStreak[vGUID].KillStreak = 0;
+		KillingStreak[kGUID].LastGUIDKill = vGUID;
+		KillingStreak[vGUID].LastGUIDKill = 0;
+
+		if (PVP_System_AddToken == 1)
+			pKiller->AddItem(29434, 1);
+
+		if (PVP_System_LoseToken == 1)
+			pVictim->DestroyItemCount(29434,1,true,false);
+
+
+ 
+		if ( CheckString(PVP_System_Streaks,KillingStreak[kGUID].KillStreak) )
+		{
+			sprintf(msg, "|%s[PvP System]: %s killed %s and is on a %u Killing Streak! |r",PVP_System_Color.c_str(), pKiller->GetName(), pVictim->GetName(),KillingStreak[kGUID].KillStreak);
+			sWorld.SendWorldText(LANG_SYSTEMMESSAGE, msg);
+			pKiller->AddItem(29434, int(KillingStreak[kGUID].KillStreak/2));
+			if (KillingStreak[kGUID].KillStreak >= PVP_System_Last_Streak)
+				KillingStreak[kGUID].KillStreak = 0;
+		}
+	}
+
+	bool CheckString(std::string IDString,int CurrentID)
+	{
+        std::string temp_str;
+        std::stringstream map_ss;
+		map_ss.str(IDString);
+        while (std::getline(map_ss, temp_str, ','))
+        {
+			std::stringstream ss2(temp_str);
+			int temp_num = -1;
+			ss2 >> temp_num;
+			if (temp_num >= 0)
+			{
+				if (temp_num == CurrentID)
+						return true;
+				}
+		}
+		return false;
+	}
+
+	void OnLogin(Player *Player)
+	{
+
+		PVP_System_Streaks = sConfig.GetStringDefault("PVP.System.Streaks", "5,10,20,30,40,50");
+		PVP_System_Last_Streak = sConfig.GetIntDefault("PVP_System.Last.Streak", 50);
+		PVP_System_LoseToken = sConfig.GetIntDefault("PVP.System.LoseToken", 0);
+		PVP_System_AnyPlace = sConfig.GetIntDefault("PVP.System.AnyPlace", 0);
+		PVP_System_BattleGounds = sConfig.GetIntDefault("PVP.System.BattleGounds", 1);
+		PVP_System_Color = sConfig.GetStringDefault("PVP.System.Color", "cffFF8000");
+		PVP_System_SamePlayer = sConfig.GetIntDefault("PVP.System.SamePlayer", 1);
+		PVP_System_AddToken = sConfig.GetIntDefault("PVP.System.AddToken", 1);
+
+		ChatHandler chH = ChatHandler(Player);
+		chH.PSendSysMessage("\n|%s----------------------------------------------------|r",PVP_System_Color.c_str());
+		chH.PSendSysMessage("|%s  Powered by {VAS} PVP System Streaks v%4.2f |r",PVP_System_Color.c_str(),version);
+		chH.PSendSysMessage("|%s----------------------------------------------------|r \n",PVP_System_Color.c_str());
+		chH.PSendSysMessage("|%s  PVP.System.Streaks = %s|r",PVP_System_Color.c_str(), PVP_System_Streaks);
+		chH.PSendSysMessage("|%s  PVP.System.Last.Streak = %u|r",PVP_System_Color.c_str(), PVP_System_Last_Streak);
+		chH.PSendSysMessage("|%s  PVP.System.AnyPlace = %u|r",PVP_System_Color.c_str(), PVP_System_AnyPlace);
+		chH.PSendSysMessage("|%s  PVP.System.BattleGounds = %u|r",PVP_System_Color.c_str(), PVP_System_BattleGounds);
+		chH.PSendSysMessage("|%s----------------------------------------------------|r \n",PVP_System_Color.c_str());
+	}
+
+};
+
+
+void AddSC_PVP_System()
+{
+    new PVP_System_Streaks_PlayerScript;
+	new PVP_System_Streaks_WorldScript;
+}
\ No newline at end of file
